---
name: Vite
slug: vite
text_format: markdown
generator: src:devdocs
version: ''
copyright: |-
  © 2019–present, Yuxi (Evan) You and Vite contributors
  Licensed under the MIT License.
  https://vitejs.dev/
homepage: https://vitejs.dev/

---
- name: Backend Integration
  id: guide/backend-integration
  summary: If you want to serve the HTML using a traditional backend (e.g
  description: "# Backend Integration\n\n**Note**\n\nIf you want to serve the HTML using a traditional backend (e.g. Rails, Laravel) but use Vite for serving assets, check for existing integrations listed in [Awesome Vite](https://github.com/vitejs/awesome-vite#integrations-with-backends).\n\nIf you need a custom integration, you can follow the steps in this guide to configure it manually\n\n1.  In your Vite config, configure the entry and enable build manifest:\n\n    js\n    ``` javascript\n    // vite.config.js\n    export default defineConfig({\n      build: {\n        // generate .vite/manifest.json in outDir\n        manifest: true,\n        rollupOptions: {\n          // overwrite default .html entry\n          input: '/path/to/main.js',\n        },\n      },\n    })\n    ```\n\n    If you haven't disabled the [module preload polyfill](../config/build-options#build-polyfillmodulepreload), you also need to import the polyfill in your entry\n\n    js\n    ``` javascript\n    // add the beginning of your app entry\n    import 'vite/modulepreload-polyfill'\n    ```\n\n2.  For development, inject the following in your server's HTML template (substitute `http://localhost:5173` with the local URL Vite is running at):\n\n    html\n    ``` javascript\n    <!-- if development -->\n    <script type=\"module\" src=\"http://localhost:5173/@vite/client\"></script>\n    <script type=\"module\" src=\"http://localhost:5173/main.js\"></script>\n    ```\n\n    In order to properly serve assets, you have two options:\n\n    - Make sure the server is configured to proxy static assets requests to the Vite server\n    - Set [`server.origin`](../config/server-options#server-origin) so that generated asset URLs will be resolved using the back-end server URL instead of a relative path\n\n    This is needed for assets such as images to load properly.\n\n    Note if you are using React with `@vitejs/plugin-react`, you'll also need to add this before the above scripts, since the plugin is not able to modify the HTML you are serving (substitute `http://localhost:5173` with the local URL Vite is running at):\n\n    html\n    ``` javascript\n    <script type=\"module\">\n      import RefreshRuntime from 'http://localhost:5173/@react-refresh'\n      RefreshRuntime.injectIntoGlobalHook(window)\n      window.$RefreshReg$ = () => {}\n      window.$RefreshSig$ = () => (type) => type\n      window.__vite_plugin_react_preamble_installed__ = true\n    </script>\n    ```\n\n3.  For production: after running `vite build`, a `.vite/manifest.json` file will be generated alongside other asset files. An example manifest file looks like this:\n\n    json\n    ``` javascript\n    {\n      \"_shared-D5fCFa4Q.js\": {\n        \"file\": \"assets/shared-ChJ_j-JJ.css\",\n        \"src\": \"_shared-D5fCFa4Q.js\"\n      },\n      \"_shared-B7PI925R.js\": {\n        \"file\": \"assets/shared-B7PI925R.js\",\n        \"name\": \"shared\",\n        \"css\": [\"assets/shared-ChJ_j-JJ.css\"]\n      },\n      \"baz.js\": {\n        \"file\": \"assets/baz-B2H3sXNv.js\",\n        \"name\": \"baz\",\n        \"src\": \"baz.js\",\n        \"isDynamicEntry\": true\n      },\n      \"views/bar.js\": {\n        \"file\": \"assets/bar-gkvgaI9m.js\",\n        \"name\": \"bar\",\n        \"src\": \"views/bar.js\",\n        \"isEntry\": true,\n        \"imports\": [\"_shared-B7PI925R.js\"],\n        \"dynamicImports\": [\"baz.js\"]\n      },\n      \"views/foo.js\": {\n        \"file\": \"assets/foo-BRBmoGS9.js\",\n        \"name\": \"foo\",\n        \"src\": \"views/foo.js\",\n        \"isEntry\": true,\n        \"imports\": [\"_shared-B7PI925R.js\"],\n        \"css\": [\"assets/foo-5UjPuW-k.css\"]\n      }\n    }\n    ```\n\n    - The manifest has a `Record<name, chunk>` structure\n    - For entry or dynamic entry chunks, the key is the relative src path from project root.\n    - For non entry chunks, the key is the base name of the generated file prefixed with `_`.\n    - Chunks will contain information on its static and dynamic imports (both are keys that map to the corresponding chunk in the manifest), and also its corresponding CSS and asset files (if any).\n\n4.  You can use this file to render links or preload directives with hashed filenames.\n\n    Here is an example HTML template to render the proper links. The syntax here is for explanation only, substitute with your server templating language. The `importedChunks` function is for illustration and isn't provided by Vite.\n\n    html\n    ``` javascript\n    <!-- if production -->\n\n    <!-- for cssFile of manifest[name].css -->\n    <link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n    <!-- for chunk of importedChunks(manifest, name) -->\n    <!-- for cssFile of chunk.css -->\n    <link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n    <script type=\"module\" src=\"/{{ manifest[name].file }}\"></script>\n\n    <!-- for chunk of importedChunks(manifest, name) -->\n    <link rel=\"modulepreload\" href=\"/{{ chunk.file }}\" />\n    ```\n\n    Specifically, a backend generating HTML should include the following tags given a manifest file and an entry point:\n\n    - A `<link rel=\"stylesheet\">` tag for each file in the entry point chunk's `css` list\n    - Recursively follow all chunks in the entry point's `imports` list and include a `<link rel=\"stylesheet\">` tag for each CSS file of each imported chunk.\n    - A tag for the `file` key of the entry point chunk (`<script type=\"module\">` for JavaScript, or `<link rel=\"stylesheet\">` for CSS)\n    - Optionally, `<link rel=\"modulepreload\">` tag for the `file` of each imported JavaScript chunk, again recursively following the imports starting from the entry point chunk.\n\n    Following the above example manifest, for the entry point `views/foo.js` the following tags should be included in production:\n\n    html\n    ``` javascript\n    <link rel=\"stylesheet\" href=\"assets/foo-5UjPuW-k.css\" />\n    <link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" />\n    <script type=\"module\" src=\"assets/foo-BRBmoGS9.js\"></script>\n    <!-- optional -->\n    <link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" />\n    ```\n\n    While the following should be included for the entry point `views/bar.js`:\n\n    html\n    ``` javascript\n    <link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" />\n    <script type=\"module\" src=\"assets/bar-gkvgaI9m.js\"></script>\n    <!-- optional -->\n    <link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" />\n    ```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/backend-integration](https://vitejs.dev/guide/backend-integration)"
- name: 'Backend Integration: APIs'
  id: guide/backend-integration
  summary: If you want to serve the HTML using a traditional backend (e.g
  description: "# Backend Integration\n\n**Note**\n\nIf you want to serve the HTML using a traditional backend (e.g. Rails, Laravel) but use Vite for serving assets, check for existing integrations listed in [Awesome Vite](https://github.com/vitejs/awesome-vite#integrations-with-backends).\n\nIf you need a custom integration, you can follow the steps in this guide to configure it manually\n\n1.  In your Vite config, configure the entry and enable build manifest:\n\n    js\n    ``` javascript\n    // vite.config.js\n    export default defineConfig({\n      build: {\n        // generate .vite/manifest.json in outDir\n        manifest: true,\n        rollupOptions: {\n          // overwrite default .html entry\n          input: '/path/to/main.js',\n        },\n      },\n    })\n    ```\n\n    If you haven't disabled the [module preload polyfill](../config/build-options#build-polyfillmodulepreload), you also need to import the polyfill in your entry\n\n    js\n    ``` javascript\n    // add the beginning of your app entry\n    import 'vite/modulepreload-polyfill'\n    ```\n\n2.  For development, inject the following in your server's HTML template (substitute `http://localhost:5173` with the local URL Vite is running at):\n\n    html\n    ``` javascript\n    <!-- if development -->\n    <script type=\"module\" src=\"http://localhost:5173/@vite/client\"></script>\n    <script type=\"module\" src=\"http://localhost:5173/main.js\"></script>\n    ```\n\n    In order to properly serve assets, you have two options:\n\n    - Make sure the server is configured to proxy static assets requests to the Vite server\n    - Set [`server.origin`](../config/server-options#server-origin) so that generated asset URLs will be resolved using the back-end server URL instead of a relative path\n\n    This is needed for assets such as images to load properly.\n\n    Note if you are using React with `@vitejs/plugin-react`, you'll also need to add this before the above scripts, since the plugin is not able to modify the HTML you are serving (substitute `http://localhost:5173` with the local URL Vite is running at):\n\n    html\n    ``` javascript\n    <script type=\"module\">\n      import RefreshRuntime from 'http://localhost:5173/@react-refresh'\n      RefreshRuntime.injectIntoGlobalHook(window)\n      window.$RefreshReg$ = () => {}\n      window.$RefreshSig$ = () => (type) => type\n      window.__vite_plugin_react_preamble_installed__ = true\n    </script>\n    ```\n\n3.  For production: after running `vite build`, a `.vite/manifest.json` file will be generated alongside other asset files. An example manifest file looks like this:\n\n    json\n    ``` javascript\n    {\n      \"_shared-D5fCFa4Q.js\": {\n        \"file\": \"assets/shared-ChJ_j-JJ.css\",\n        \"src\": \"_shared-D5fCFa4Q.js\"\n      },\n      \"_shared-B7PI925R.js\": {\n        \"file\": \"assets/shared-B7PI925R.js\",\n        \"name\": \"shared\",\n        \"css\": [\"assets/shared-ChJ_j-JJ.css\"]\n      },\n      \"baz.js\": {\n        \"file\": \"assets/baz-B2H3sXNv.js\",\n        \"name\": \"baz\",\n        \"src\": \"baz.js\",\n        \"isDynamicEntry\": true\n      },\n      \"views/bar.js\": {\n        \"file\": \"assets/bar-gkvgaI9m.js\",\n        \"name\": \"bar\",\n        \"src\": \"views/bar.js\",\n        \"isEntry\": true,\n        \"imports\": [\"_shared-B7PI925R.js\"],\n        \"dynamicImports\": [\"baz.js\"]\n      },\n      \"views/foo.js\": {\n        \"file\": \"assets/foo-BRBmoGS9.js\",\n        \"name\": \"foo\",\n        \"src\": \"views/foo.js\",\n        \"isEntry\": true,\n        \"imports\": [\"_shared-B7PI925R.js\"],\n        \"css\": [\"assets/foo-5UjPuW-k.css\"]\n      }\n    }\n    ```\n\n    - The manifest has a `Record<name, chunk>` structure\n    - For entry or dynamic entry chunks, the key is the relative src path from project root.\n    - For non entry chunks, the key is the base name of the generated file prefixed with `_`.\n    - Chunks will contain information on its static and dynamic imports (both are keys that map to the corresponding chunk in the manifest), and also its corresponding CSS and asset files (if any).\n\n4.  You can use this file to render links or preload directives with hashed filenames.\n\n    Here is an example HTML template to render the proper links. The syntax here is for explanation only, substitute with your server templating language. The `importedChunks` function is for illustration and isn't provided by Vite.\n\n    html\n    ``` javascript\n    <!-- if production -->\n\n    <!-- for cssFile of manifest[name].css -->\n    <link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n    <!-- for chunk of importedChunks(manifest, name) -->\n    <!-- for cssFile of chunk.css -->\n    <link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n    <script type=\"module\" src=\"/{{ manifest[name].file }}\"></script>\n\n    <!-- for chunk of importedChunks(manifest, name) -->\n    <link rel=\"modulepreload\" href=\"/{{ chunk.file }}\" />\n    ```\n\n    Specifically, a backend generating HTML should include the following tags given a manifest file and an entry point:\n\n    - A `<link rel=\"stylesheet\">` tag for each file in the entry point chunk's `css` list\n    - Recursively follow all chunks in the entry point's `imports` list and include a `<link rel=\"stylesheet\">` tag for each CSS file of each imported chunk.\n    - A tag for the `file` key of the entry point chunk (`<script type=\"module\">` for JavaScript, or `<link rel=\"stylesheet\">` for CSS)\n    - Optionally, `<link rel=\"modulepreload\">` tag for the `file` of each imported JavaScript chunk, again recursively following the imports starting from the entry point chunk.\n\n    Following the above example manifest, for the entry point `views/foo.js` the following tags should be included in production:\n\n    html\n    ``` javascript\n    <link rel=\"stylesheet\" href=\"assets/foo-5UjPuW-k.css\" />\n    <link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" />\n    <script type=\"module\" src=\"assets/foo-BRBmoGS9.js\"></script>\n    <!-- optional -->\n    <link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" />\n    ```\n\n    While the following should be included for the entry point `views/bar.js`:\n\n    html\n    ``` javascript\n    <link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" />\n    <script type=\"module\" src=\"assets/bar-gkvgaI9m.js\"></script>\n    <!-- optional -->\n    <link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" />\n    ```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/backend-integration](https://vitejs.dev/guide/backend-integration)"
- name: 'Backend Integration: Guide'
  id: guide/backend-integration
  summary: If you want to serve the HTML using a traditional backend (e.g
  description: "# Backend Integration\n\n**Note**\n\nIf you want to serve the HTML using a traditional backend (e.g. Rails, Laravel) but use Vite for serving assets, check for existing integrations listed in [Awesome Vite](https://github.com/vitejs/awesome-vite#integrations-with-backends).\n\nIf you need a custom integration, you can follow the steps in this guide to configure it manually\n\n1.  In your Vite config, configure the entry and enable build manifest:\n\n    js\n    ``` javascript\n    // vite.config.js\n    export default defineConfig({\n      build: {\n        // generate .vite/manifest.json in outDir\n        manifest: true,\n        rollupOptions: {\n          // overwrite default .html entry\n          input: '/path/to/main.js',\n        },\n      },\n    })\n    ```\n\n    If you haven't disabled the [module preload polyfill](../config/build-options#build-polyfillmodulepreload), you also need to import the polyfill in your entry\n\n    js\n    ``` javascript\n    // add the beginning of your app entry\n    import 'vite/modulepreload-polyfill'\n    ```\n\n2.  For development, inject the following in your server's HTML template (substitute `http://localhost:5173` with the local URL Vite is running at):\n\n    html\n    ``` javascript\n    <!-- if development -->\n    <script type=\"module\" src=\"http://localhost:5173/@vite/client\"></script>\n    <script type=\"module\" src=\"http://localhost:5173/main.js\"></script>\n    ```\n\n    In order to properly serve assets, you have two options:\n\n    - Make sure the server is configured to proxy static assets requests to the Vite server\n    - Set [`server.origin`](../config/server-options#server-origin) so that generated asset URLs will be resolved using the back-end server URL instead of a relative path\n\n    This is needed for assets such as images to load properly.\n\n    Note if you are using React with `@vitejs/plugin-react`, you'll also need to add this before the above scripts, since the plugin is not able to modify the HTML you are serving (substitute `http://localhost:5173` with the local URL Vite is running at):\n\n    html\n    ``` javascript\n    <script type=\"module\">\n      import RefreshRuntime from 'http://localhost:5173/@react-refresh'\n      RefreshRuntime.injectIntoGlobalHook(window)\n      window.$RefreshReg$ = () => {}\n      window.$RefreshSig$ = () => (type) => type\n      window.__vite_plugin_react_preamble_installed__ = true\n    </script>\n    ```\n\n3.  For production: after running `vite build`, a `.vite/manifest.json` file will be generated alongside other asset files. An example manifest file looks like this:\n\n    json\n    ``` javascript\n    {\n      \"_shared-D5fCFa4Q.js\": {\n        \"file\": \"assets/shared-ChJ_j-JJ.css\",\n        \"src\": \"_shared-D5fCFa4Q.js\"\n      },\n      \"_shared-B7PI925R.js\": {\n        \"file\": \"assets/shared-B7PI925R.js\",\n        \"name\": \"shared\",\n        \"css\": [\"assets/shared-ChJ_j-JJ.css\"]\n      },\n      \"baz.js\": {\n        \"file\": \"assets/baz-B2H3sXNv.js\",\n        \"name\": \"baz\",\n        \"src\": \"baz.js\",\n        \"isDynamicEntry\": true\n      },\n      \"views/bar.js\": {\n        \"file\": \"assets/bar-gkvgaI9m.js\",\n        \"name\": \"bar\",\n        \"src\": \"views/bar.js\",\n        \"isEntry\": true,\n        \"imports\": [\"_shared-B7PI925R.js\"],\n        \"dynamicImports\": [\"baz.js\"]\n      },\n      \"views/foo.js\": {\n        \"file\": \"assets/foo-BRBmoGS9.js\",\n        \"name\": \"foo\",\n        \"src\": \"views/foo.js\",\n        \"isEntry\": true,\n        \"imports\": [\"_shared-B7PI925R.js\"],\n        \"css\": [\"assets/foo-5UjPuW-k.css\"]\n      }\n    }\n    ```\n\n    - The manifest has a `Record<name, chunk>` structure\n    - For entry or dynamic entry chunks, the key is the relative src path from project root.\n    - For non entry chunks, the key is the base name of the generated file prefixed with `_`.\n    - Chunks will contain information on its static and dynamic imports (both are keys that map to the corresponding chunk in the manifest), and also its corresponding CSS and asset files (if any).\n\n4.  You can use this file to render links or preload directives with hashed filenames.\n\n    Here is an example HTML template to render the proper links. The syntax here is for explanation only, substitute with your server templating language. The `importedChunks` function is for illustration and isn't provided by Vite.\n\n    html\n    ``` javascript\n    <!-- if production -->\n\n    <!-- for cssFile of manifest[name].css -->\n    <link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n    <!-- for chunk of importedChunks(manifest, name) -->\n    <!-- for cssFile of chunk.css -->\n    <link rel=\"stylesheet\" href=\"/{{ cssFile }}\" />\n\n    <script type=\"module\" src=\"/{{ manifest[name].file }}\"></script>\n\n    <!-- for chunk of importedChunks(manifest, name) -->\n    <link rel=\"modulepreload\" href=\"/{{ chunk.file }}\" />\n    ```\n\n    Specifically, a backend generating HTML should include the following tags given a manifest file and an entry point:\n\n    - A `<link rel=\"stylesheet\">` tag for each file in the entry point chunk's `css` list\n    - Recursively follow all chunks in the entry point's `imports` list and include a `<link rel=\"stylesheet\">` tag for each CSS file of each imported chunk.\n    - A tag for the `file` key of the entry point chunk (`<script type=\"module\">` for JavaScript, or `<link rel=\"stylesheet\">` for CSS)\n    - Optionally, `<link rel=\"modulepreload\">` tag for the `file` of each imported JavaScript chunk, again recursively following the imports starting from the entry point chunk.\n\n    Following the above example manifest, for the entry point `views/foo.js` the following tags should be included in production:\n\n    html\n    ``` javascript\n    <link rel=\"stylesheet\" href=\"assets/foo-5UjPuW-k.css\" />\n    <link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" />\n    <script type=\"module\" src=\"assets/foo-BRBmoGS9.js\"></script>\n    <!-- optional -->\n    <link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" />\n    ```\n\n    While the following should be included for the entry point `views/bar.js`:\n\n    html\n    ``` javascript\n    <link rel=\"stylesheet\" href=\"assets/shared-ChJ_j-JJ.css\" />\n    <script type=\"module\" src=\"assets/bar-gkvgaI9m.js\"></script>\n    <!-- optional -->\n    <link rel=\"modulepreload\" href=\"assets/shared-B7PI925R.js\" />\n    ```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/backend-integration](https://vitejs.dev/guide/backend-integration)"
- name: Build Options
  id: config/build-options
  summary: Browser compatibility target for the final bundle
  description: "# Build Options\n\n## build.target\n\n- **Type:** `string | string[]`\n- **Default:** `'modules'`\n- **Related:** [Browser Compatibility](../guide/build#browser-compatibility)\n\nBrowser compatibility target for the final bundle. The default value is a Vite special value, `'modules'`, which targets browsers with [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) support. Vite will replace `'modules'` to `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`\n\nAnother special value is `'esnext'` - which assumes native dynamic imports support and will transpile as little as possible:\n\n- If the [`build.minify`](#build-minify) option is `'terser'` and the installed Terser version is below 5.16.0, `'esnext'` will be forced down to `'es2021'`.\n- In other cases, it will perform no transpilation at all.\n\nThe transform is performed with esbuild and the value should be a valid [esbuild target option](https://esbuild.github.io/api/#target). Custom targets can either be an ES version (e.g. `es2015`), a browser with version (e.g. `chrome58`), or an array of multiple target strings.\n\nNote the build will fail if the code contains features that cannot be safely transpiled by esbuild. See [esbuild docs](https://esbuild.github.io/content-types/#javascript) for more details.\n\n## build.modulePreload\n\n- **Type:** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`\n- **Default:** `{ polyfill: true }`\n\nBy default, a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) is automatically injected. The polyfill is auto injected into the proxy module of each `index.html` entry. If the build is configured to use a non-HTML custom entry via `build.rollupOptions.input`, then it is necessary to manually import the polyfill in your custom entry:\n\njs\n\n``` javascript\nimport 'vite/modulepreload-polyfill'\n```\n\nNote: the polyfill does **not** apply to [Library Mode](../guide/build#library-mode). If you need to support browsers without native dynamic import, you should probably avoid using it in your library.\n\nThe polyfill can be disabled using `{ polyfill: false }`.\n\nThe list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the `base` will be used when loading these dependencies. If the `base` is relative (`''` or `'./'`), `import.meta.url` is used at runtime to avoid absolute paths that depend on the final deployed base.\n\nThere is experimental support for fine grained control over the dependencies list and their paths using the `resolveDependencies` function. [Give Feedback](https://github.com/vitejs/vite/discussions/13841). It expects a function of type `ResolveModulePreloadDependenciesFn`:\n\nts\n\n``` javascript\ntype ResolveModulePreloadDependenciesFn = (\n  url: string,\n  deps: string[],\n  context: {\n    importer: string\n  },\n) => string[]\n```\n\nThe `resolveDependencies` function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The `deps` paths are relative to the `build.outDir`. Returning a relative path to the `hostId` for `hostType === 'js'` is allowed, in which case `new URL(dep, import.meta.url)` is used to get an absolute path when injecting this module preload in the HTML head.\n\njs\n\n``` javascript\nmodulePreload: {\n  resolveDependencies: (filename, deps, { hostId, hostType }) => {\n    return deps.filter(condition)\n  },\n},\n```\n\nThe resolved dependency paths can be further modified using [`experimental.renderBuiltUrl`](../guide/build#advanced-base-options).\n\n## build.polyfillModulePreload\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Deprecated** use `build.modulePreload.polyfill` instead\n\nWhether to automatically inject a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill).\n\n## build.outDir\n\n- **Type:** `string`\n- **Default:** `dist`\n\nSpecify the output directory (relative to [project root](../guide/index#index-html-and-project-root)).\n\n## build.assetsDir\n\n- **Type:** `string`\n- **Default:** `assets`\n\nSpecify the directory to nest generated assets under (relative to `build.outDir`. This is not used in [Library Mode](../guide/build#library-mode)).\n\n## build.assetsInlineLimit\n\n- **Type:** `number` \\| `((filePath: string, content: Buffer) => boolean | undefined)`\n- **Default:** `4096` (4 KiB)\n\nImported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to `0` to disable inlining altogether.\n\nIf a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.\n\nGit LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.\n\n**Note**\n\nIf you specify `build.lib`, `build.assetsInlineLimit` will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.\n\n## build.cssCodeSplit\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nEnable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.\n\nIf disabled, all CSS in the entire project will be extracted into a single CSS file.\n\n**Note**\n\nIf you specify `build.lib`, `build.cssCodeSplit` will be `false` as default.\n\n## build.cssTarget\n\n- **Type:** `string | string[]`\n- **Default:** the same as [`build.target`](#build-target)\n\nThis option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.\n\nIt should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the [`#RGBA` hexadecimal color notation in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors). In this case, you need to set `build.cssTarget` to `chrome61` to prevent vite from transform `rgba()` colors into `#RGBA` hexadecimal notations.\n\n## build.cssMinify\n\n- **Type:** `boolean | 'esbuild' | 'lightningcss'`\n- **Default:** the same as [`build.minify`](#build-minify)\n\nThis option allows users to override CSS minification specifically instead of defaulting to `build.minify`, so you can configure minification for JS and CSS separately. Vite uses `esbuild` by default to minify CSS. Set the option to `'lightningcss'` to use [Lightning CSS](https://lightningcss.dev/minification.html) instead. If selected, it can be configured using [`css.lightningcss`](shared-options#css-lightningcss).\n\n## build.sourcemap\n\n- **Type:** `boolean | 'inline' | 'hidden'`\n- **Default:** `false`\n\nGenerate production source maps. If `true`, a separate sourcemap file will be created. If `'inline'`, the sourcemap will be appended to the resulting output file as a data URI. `'hidden'` works like `true` except that the corresponding sourcemap comments in the bundled files are suppressed.\n\n## build.rollupOptions\n\n- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)\n\nDirectly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See [Rollup options docs](https://rollupjs.org/configuration-options/) for more details.\n\n## build.commonjsOptions\n\n- **Type:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)\n\nOptions to pass on to [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs).\n\n## build.dynamicImportVarsOptions\n\n- **Type:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)\n- **Related:** [Dynamic Import](../guide/features#dynamic-import)\n\nOptions to pass on to [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars).\n\n## build.lib\n\n- **Type:** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string) }`\n- **Related:** [Library Mode](../guide/build#library-mode)\n\nBuild as a library. `entry` is required since the library cannot use HTML as entry. `name` is the exposed global variable and is required when `formats` includes `'umd'` or `'iife'`. Default `formats` are `['es', 'umd']`, or `['es', 'cjs']`, if multiple entries are used. `fileName` is the name of the package file output, default `fileName` is the name option of package.json, it can also be defined as function taking the `format` and `entryAlias` as arguments.\n\n## build.manifest\n\n- **Type:** `boolean | string`\n- **Default:** `false`\n- **Related:** [Backend Integration](../guide/backend-integration)\n\nWhen set to `true`, the build will also generate a `.vite/manifest.json` file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.\n\n## build.ssrManifest\n\n- **Type:** `boolean | string`\n- **Default:** `false`\n- **Related:** [Server-Side Rendering](../guide/ssr)\n\nWhen set to `true`, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.\n\n## build.ssr\n\n- **Type:** `boolean | string`\n- **Default:** `false`\n- **Related:** [Server-Side Rendering](../guide/ssr)\n\nProduce SSR-oriented build. The value can be a string to directly specify the SSR entry, or `true`, which requires specifying the SSR entry via `rollupOptions.input`.\n\n## build.ssrEmitAssets\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nDuring the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.\n\n## build.minify\n\n- **Type:** `boolean | 'terser' | 'esbuild'`\n- **Default:** `'esbuild'` for client build, `false` for SSR build\n\nSet to `false` to disable minification, or specify the minifier to use. The default is [esbuild](https://github.com/evanw/esbuild) which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. [Benchmarks](https://github.com/privatenumber/minification-benchmarks)\n\nNote the `build.minify` option does not minify whitespaces when using the `'es'` format in lib mode, as it removes pure annotations and breaks tree-shaking.\n\nTerser must be installed when it is set to `'terser'`.\n\nsh\n\n``` javascript\nnpm add -D terser\n```\n\n## build.terserOptions\n\n- **Type:** `TerserOptions`\n\nAdditional [minify options](https://terser.org/docs/api-reference#minify-options) to pass on to Terser.\n\nIn addition, you can also pass a `maxWorkers: number` option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.\n\n## build.write\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nSet to `false` to disable writing the bundle to disk. This is mostly used in [programmatic `build()` calls](../guide/api-javascript#build) where further post processing of the bundle is needed before writing to disk.\n\n## build.emptyOutDir\n\n- **Type:** `boolean`\n- **Default:** `true` if `outDir` is inside `root`\n\nBy default, Vite will empty the `outDir` on build if it is inside project root. It will emit a warning if `outDir` is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as `--emptyOutDir`.\n\n## build.copyPublicDir\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nBy default, Vite will copy files from the `publicDir` into the `outDir` on build. Set to `false` to disable this.\n\n## build.reportCompressedSize\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nEnable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.\n\n## build.chunkSizeWarningLimit\n\n- **Type:** `number`\n- **Default:** `500`\n\nLimit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the [JavaScript size itself is related to the execution time](https://v8.dev/blog/cost-of-javascript-2019).\n\n## build.watch\n\n- **Type:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch)`| null`\n- **Default:** `null`\n\nSet to `{}` to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.\n\n**Using Vite on Windows Subsystem for Linux (WSL) 2**\n\nThere are cases that file system watching does not work with WSL2. See [`server.watch`](server-options#server-watch) for more details.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/build-options](https://vitejs.dev/config/build-options)"
- name: 'Build Options: build.assetsDir'
  id: config/build-options#build-assetsdir
  summary: Specify the directory to nest generated assets under (relative to build.outDir
  belongs_to: Build Options
  description: |-
    ## build.assetsDir

    - **Type:** `string`
    - **Default:** `assets`

    Specify the directory to nest generated assets under (relative to `build.outDir`. This is not used in [Library Mode](../guide/build#library-mode)).
- name: 'Build Options: build.assetsInlineLimit'
  id: config/build-options#build-assetsinlinelimit
  summary: Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests
  belongs_to: Build Options
  description: |-
    ## build.assetsInlineLimit

    - **Type:**`number` \| `((filePath: string, content: Buffer) => boolean | undefined)`
    - **Default:**`4096` (4 KiB)

    Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to `0` to disable inlining altogether.

    If a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.

    Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.

    **Note**

    If you specify `build.lib`, `build.assetsInlineLimit` will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.
- name: 'Build Options: build.chunkSizeWarningLimit'
  id: config/build-options#build-chunksizewarninglimit
  summary: Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the JavaScript size itself is related to the execution time
  belongs_to: Build Options
  description: |-
    ## build.chunkSizeWarningLimit

    - **Type:** `number`
    - **Default:** `500`

    Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the [JavaScript size itself is related to the execution time](https://v8.dev/blog/cost-of-javascript-2019).
- name: 'Build Options: build.commonjsOptions'
  id: config/build-options#build-commonjsoptions
  summary: Options to pass on to @rollup/plugin-commonjs
  belongs_to: Build Options
  description: |-
    ## build.commonjsOptions

    - **Type:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)

    Options to pass on to [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs).
- name: 'Build Options: build.copyPublicDir'
  id: config/build-options#build-copypublicdir
  summary: By default, Vite will copy files from the publicDir into the outDir on build
  belongs_to: Build Options
  description: |-
    ## build.copyPublicDir

    - **Type:** `boolean`
    - **Default:** `true`

    By default, Vite will copy files from the `publicDir` into the `outDir` on build. Set to `false` to disable this.
- name: 'Build Options: build.cssCodeSplit'
  id: config/build-options#build-csscodesplit
  summary: Enable/disable CSS code splitting
  belongs_to: Build Options
  description: |-
    ## build.cssCodeSplit

    - **Type:** `boolean`
    - **Default:** `true`

    Enable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.

    If disabled, all CSS in the entire project will be extracted into a single CSS file.

    **Note**

    If you specify `build.lib`, `build.cssCodeSplit` will be `false` as default.
- name: 'Build Options: build.cssMinify'
  id: config/build-options#build-cssminify
  summary: This option allows users to override CSS minification specifically instead of defaulting to build.minify, so you can configure minification for JS and CSS separately
  belongs_to: Build Options
  description: |-
    ## build.cssMinify

    - **Type:** `boolean | 'esbuild' | 'lightningcss'`
    - **Default:** the same as [`build.minify`](#build-minify)

    This option allows users to override CSS minification specifically instead of defaulting to `build.minify`, so you can configure minification for JS and CSS separately. Vite uses `esbuild` by default to minify CSS. Set the option to `'lightningcss'` to use [Lightning CSS](https://lightningcss.dev/minification.html) instead. If selected, it can be configured using [`css.lightningcss`](shared-options#css-lightningcss).
- name: 'Build Options: build.cssTarget'
  id: config/build-options#build-csstarget
  summary: This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation
  belongs_to: Build Options
  description: |-
    ## build.cssTarget

    - **Type:** `string | string[]`
    - **Default:** the same as [`build.target`](#build-target)

    This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.

    It should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the [`#RGBA` hexadecimal color notation in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors). In this case, you need to set `build.cssTarget` to `chrome61` to prevent vite from transform `rgba()` colors into `#RGBA` hexadecimal notations.
- name: 'Build Options: build.dynamicImportVarsOptions'
  id: config/build-options#build-dynamicimportvarsoptions
  summary: Options to pass on to @rollup/plugin-dynamic-import-vars
  belongs_to: Build Options
  description: |-
    ## build.dynamicImportVarsOptions

    - **Type:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)
    - **Related:** [Dynamic Import](../guide/features#dynamic-import)

    Options to pass on to [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars).
- name: 'Build Options: build.emptyOutDir'
  id: config/build-options#build-emptyoutdir
  summary: By default, Vite will empty the outDir on build if it is inside project root
  belongs_to: Build Options
  description: |-
    ## build.emptyOutDir

    - **Type:** `boolean`
    - **Default:**`true` if `outDir` is inside `root`

    By default, Vite will empty the `outDir` on build if it is inside project root. It will emit a warning if `outDir` is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as `--emptyOutDir`.
- name: 'Build Options: build.lib'
  id: config/build-options#build-lib
  summary: Build as a library
  belongs_to: Build Options
  description: |-
    ## build.lib

    - **Type:** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string) }`
    - **Related:** [Library Mode](../guide/build#library-mode)

    Build as a library. `entry` is required since the library cannot use HTML as entry. `name` is the exposed global variable and is required when `formats` includes `'umd'` or `'iife'`. Default `formats` are `['es', 'umd']`, or `['es', 'cjs']`, if multiple entries are used. `fileName` is the name of the package file output, default `fileName` is the name option of package.json, it can also be defined as function taking the `format` and `entryAlias` as arguments.
- name: 'Build Options: build.manifest'
  id: config/build-options#build-manifest
  summary: When set to true, the build will also generate a .vite/manifest.json file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links
  belongs_to: Build Options
  description: |-
    ## build.manifest

    - **Type:** `boolean | string`
    - **Default:** `false`
    - **Related:** [Backend Integration](../guide/backend-integration)

    When set to `true`, the build will also generate a `.vite/manifest.json` file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.
- name: 'Build Options: build.minify'
  id: config/build-options#build-minify
  summary: Set to false to disable minification, or specify the minifier to use
  belongs_to: Build Options
  description: |-
    ## build.minify

    - **Type:** `boolean | 'terser' | 'esbuild'`
    - **Default:**`'esbuild'` for client build, `false` for SSR build

    Set to `false` to disable minification, or specify the minifier to use. The default is [esbuild](https://github.com/evanw/esbuild) which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. [Benchmarks](https://github.com/privatenumber/minification-benchmarks)

    Note the `build.minify` option does not minify whitespaces when using the `'es'` format in lib mode, as it removes pure annotations and breaks tree-shaking.

    Terser must be installed when it is set to `'terser'`.

    sh

    ``` javascript
    npm add -D terser
    ```
- name: 'Build Options: build.modulePreload'
  id: config/build-options#build-modulepreload
  summary: By default, a module preload polyfill is automatically injected
  belongs_to: Build Options
  description: |-
    ## build.modulePreload

    - **Type:** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`
    - **Default:** `{ polyfill: true }`

    By default, a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) is automatically injected. The polyfill is auto injected into the proxy module of each `index.html` entry. If the build is configured to use a non-HTML custom entry via `build.rollupOptions.input`, then it is necessary to manually import the polyfill in your custom entry:

    js

    ``` javascript
    import 'vite/modulepreload-polyfill'
    ```

    Note: the polyfill does **not** apply to [Library Mode](../guide/build#library-mode). If you need to support browsers without native dynamic import, you should probably avoid using it in your library.

    The polyfill can be disabled using `{ polyfill: false }`.

    The list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the `base` will be used when loading these dependencies. If the `base` is relative (`''` or `'./'`), `import.meta.url` is used at runtime to avoid absolute paths that depend on the final deployed base.

    There is experimental support for fine grained control over the dependencies list and their paths using the `resolveDependencies` function. [Give Feedback](https://github.com/vitejs/vite/discussions/13841). It expects a function of type `ResolveModulePreloadDependenciesFn`:

    ts

    ``` javascript
    type ResolveModulePreloadDependenciesFn = (
      url: string,
      deps: string[],
      context: {
        importer: string
      },
    ) => string[]
    ```

    The `resolveDependencies` function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The `deps` paths are relative to the `build.outDir`. Returning a relative path to the `hostId` for `hostType === 'js'` is allowed, in which case `new URL(dep, import.meta.url)` is used to get an absolute path when injecting this module preload in the HTML head.

    js

    ``` javascript
    modulePreload: {
      resolveDependencies: (filename, deps, { hostId, hostType }) => {
        return deps.filter(condition)
      },
    },
    ```

    The resolved dependency paths can be further modified using [`experimental.renderBuiltUrl`](../guide/build#advanced-base-options).
- name: 'Build Options: build.outDir'
  id: config/build-options#build-outdir
  summary: null
  belongs_to: Build Options
  description: |-
    ## build.outDir

    - **Type:** `string`
    - **Default:** `dist`

    Specify the output directory (relative to [project root](../guide/index#index-html-and-project-root)).
- name: 'Build Options: build.polyfillModulePreload'
  id: config/build-options#build-polyfillmodulepreload
  summary: Whether to automatically inject a module preload polyfill
  belongs_to: Build Options
  description: |-
    ## build.polyfillModulePreload

    - **Type:** `boolean`
    - **Default:** `true`
    - **Deprecated** use `build.modulePreload.polyfill` instead

    Whether to automatically inject a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill).
- name: 'Build Options: build.reportCompressedSize'
  id: config/build-options#build-reportcompressedsize
  summary: Enable/disable gzip-compressed size reporting
  belongs_to: Build Options
  description: |-
    ## build.reportCompressedSize

    - **Type:** `boolean`
    - **Default:** `true`

    Enable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.
- name: 'Build Options: build.rollupOptions'
  id: config/build-options#build-rollupoptions
  summary: Directly customize the underlying Rollup bundle
  belongs_to: Build Options
  description: |-
    ## build.rollupOptions

    - **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)

    Directly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See [Rollup options docs](https://rollupjs.org/configuration-options/) for more details.
- name: 'Build Options: build.sourcemap'
  id: config/build-options#build-sourcemap
  summary: Generate production source maps
  belongs_to: Build Options
  description: |-
    ## build.sourcemap

    - **Type:** `boolean | 'inline' | 'hidden'`
    - **Default:** `false`

    Generate production source maps. If `true`, a separate sourcemap file will be created. If `'inline'`, the sourcemap will be appended to the resulting output file as a data URI. `'hidden'` works like `true` except that the corresponding sourcemap comments in the bundled files are suppressed.
- name: 'Build Options: build.ssr'
  id: config/build-options#build-ssr
  summary: Produce SSR-oriented build
  belongs_to: Build Options
  description: |-
    ## build.ssr

    - **Type:** `boolean | string`
    - **Default:** `false`
    - **Related:** [Server-Side Rendering](../guide/ssr)

    Produce SSR-oriented build. The value can be a string to directly specify the SSR entry, or `true`, which requires specifying the SSR entry via `rollupOptions.input`.
- name: 'Build Options: build.ssrEmitAssets'
  id: config/build-options#build-ssremitassets
  summary: During the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build
  belongs_to: Build Options
  description: |-
    ## build.ssrEmitAssets

    - **Type:** `boolean`
    - **Default:** `false`

    During the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.
- name: 'Build Options: build.ssrManifest'
  id: config/build-options#build-ssrmanifest
  summary: When set to true, the build will also generate an SSR manifest for determining style links and asset preload directives in production
  belongs_to: Build Options
  description: |-
    ## build.ssrManifest

    - **Type:** `boolean | string`
    - **Default:** `false`
    - **Related:** [Server-Side Rendering](../guide/ssr)

    When set to `true`, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.
- name: 'Build Options: build.target'
  id: config/build-options#build-target
  summary: Browser compatibility target for the final bundle
  belongs_to: Build Options
  description: |-
    ## build.target

    - **Type:** `string | string[]`
    - **Default:** `'modules'`
    - **Related:** [Browser Compatibility](../guide/build#browser-compatibility)

    Browser compatibility target for the final bundle. The default value is a Vite special value, `'modules'`, which targets browsers with [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) support. Vite will replace `'modules'` to `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`

    Another special value is `'esnext'` - which assumes native dynamic imports support and will transpile as little as possible:

    - If the [`build.minify`](#build-minify) option is `'terser'` and the installed Terser version is below 5.16.0, `'esnext'` will be forced down to `'es2021'`.
    - In other cases, it will perform no transpilation at all.

    The transform is performed with esbuild and the value should be a valid [esbuild target option](https://esbuild.github.io/api/#target). Custom targets can either be an ES version (e.g. `es2015`), a browser with version (e.g. `chrome58`), or an array of multiple target strings.

    Note the build will fail if the code contains features that cannot be safely transpiled by esbuild. See [esbuild docs](https://esbuild.github.io/content-types/#javascript) for more details.
- name: 'Build Options: build.terserOptions'
  id: config/build-options#build-terseroptions
  summary: Additional minify options to pass on to Terser
  belongs_to: Build Options
  description: |-
    ## build.terserOptions

    - **Type:** `TerserOptions`

    Additional [minify options](https://terser.org/docs/api-reference#minify-options) to pass on to Terser.

    In addition, you can also pass a `maxWorkers: number` option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.
- name: 'Build Options: build.watch'
  id: config/build-options#build-watch
  summary: Set to {} to enable rollup watcher
  belongs_to: Build Options
  description: "## build.watch\n\n- **Type:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) `| null`\n- **Default:** `null`\n\nSet to `{}` to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.\n\n**Using Vite on Windows Subsystem for Linux (WSL) 2**\n\nThere are cases that file system watching does not work with WSL2. See [`server.watch`](server-options#server-watch) for more details.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/build-options](https://vitejs.dev/config/build-options)"
- name: 'Build Options: build.write'
  id: config/build-options#build-write
  summary: Set to false to disable writing the bundle to disk
  belongs_to: Build Options
  description: |-
    ## build.write

    - **Type:** `boolean`
    - **Default:** `true`

    Set to `false` to disable writing the bundle to disk. This is mostly used in [programmatic `build()` calls](../guide/api-javascript#build) where further post processing of the bundle is needed before writing to disk.
- name: 'Build Options: Config'
  id: config/build-options
  summary: Browser compatibility target for the final bundle
  description: "# Build Options\n\n## build.target\n\n- **Type:** `string | string[]`\n- **Default:** `'modules'`\n- **Related:** [Browser Compatibility](../guide/build#browser-compatibility)\n\nBrowser compatibility target for the final bundle. The default value is a Vite special value, `'modules'`, which targets browsers with [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta) support. Vite will replace `'modules'` to `['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']`\n\nAnother special value is `'esnext'` - which assumes native dynamic imports support and will transpile as little as possible:\n\n- If the [`build.minify`](#build-minify) option is `'terser'` and the installed Terser version is below 5.16.0, `'esnext'` will be forced down to `'es2021'`.\n- In other cases, it will perform no transpilation at all.\n\nThe transform is performed with esbuild and the value should be a valid [esbuild target option](https://esbuild.github.io/api/#target). Custom targets can either be an ES version (e.g. `es2015`), a browser with version (e.g. `chrome58`), or an array of multiple target strings.\n\nNote the build will fail if the code contains features that cannot be safely transpiled by esbuild. See [esbuild docs](https://esbuild.github.io/content-types/#javascript) for more details.\n\n## build.modulePreload\n\n- **Type:** `boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }`\n- **Default:** `{ polyfill: true }`\n\nBy default, a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill) is automatically injected. The polyfill is auto injected into the proxy module of each `index.html` entry. If the build is configured to use a non-HTML custom entry via `build.rollupOptions.input`, then it is necessary to manually import the polyfill in your custom entry:\n\njs\n\n``` javascript\nimport 'vite/modulepreload-polyfill'\n```\n\nNote: the polyfill does **not** apply to [Library Mode](../guide/build#library-mode). If you need to support browsers without native dynamic import, you should probably avoid using it in your library.\n\nThe polyfill can be disabled using `{ polyfill: false }`.\n\nThe list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the `base` will be used when loading these dependencies. If the `base` is relative (`''` or `'./'`), `import.meta.url` is used at runtime to avoid absolute paths that depend on the final deployed base.\n\nThere is experimental support for fine grained control over the dependencies list and their paths using the `resolveDependencies` function. [Give Feedback](https://github.com/vitejs/vite/discussions/13841). It expects a function of type `ResolveModulePreloadDependenciesFn`:\n\nts\n\n``` javascript\ntype ResolveModulePreloadDependenciesFn = (\n  url: string,\n  deps: string[],\n  context: {\n    importer: string\n  },\n) => string[]\n```\n\nThe `resolveDependencies` function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The `deps` paths are relative to the `build.outDir`. Returning a relative path to the `hostId` for `hostType === 'js'` is allowed, in which case `new URL(dep, import.meta.url)` is used to get an absolute path when injecting this module preload in the HTML head.\n\njs\n\n``` javascript\nmodulePreload: {\n  resolveDependencies: (filename, deps, { hostId, hostType }) => {\n    return deps.filter(condition)\n  },\n},\n```\n\nThe resolved dependency paths can be further modified using [`experimental.renderBuiltUrl`](../guide/build#advanced-base-options).\n\n## build.polyfillModulePreload\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Deprecated** use `build.modulePreload.polyfill` instead\n\nWhether to automatically inject a [module preload polyfill](https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill).\n\n## build.outDir\n\n- **Type:** `string`\n- **Default:** `dist`\n\nSpecify the output directory (relative to [project root](../guide/index#index-html-and-project-root)).\n\n## build.assetsDir\n\n- **Type:** `string`\n- **Default:** `assets`\n\nSpecify the directory to nest generated assets under (relative to `build.outDir`. This is not used in [Library Mode](../guide/build#library-mode)).\n\n## build.assetsInlineLimit\n\n- **Type:** `number` \\| `((filePath: string, content: Buffer) => boolean | undefined)`\n- **Default:** `4096` (4 KiB)\n\nImported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to `0` to disable inlining altogether.\n\nIf a callback is passed, a boolean can be returned to opt-in or opt-out. If nothing is returned the default logic applies.\n\nGit LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.\n\n**Note**\n\nIf you specify `build.lib`, `build.assetsInlineLimit` will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.\n\n## build.cssCodeSplit\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nEnable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.\n\nIf disabled, all CSS in the entire project will be extracted into a single CSS file.\n\n**Note**\n\nIf you specify `build.lib`, `build.cssCodeSplit` will be `false` as default.\n\n## build.cssTarget\n\n- **Type:** `string | string[]`\n- **Default:** the same as [`build.target`](#build-target)\n\nThis option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.\n\nIt should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the [`#RGBA` hexadecimal color notation in CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors). In this case, you need to set `build.cssTarget` to `chrome61` to prevent vite from transform `rgba()` colors into `#RGBA` hexadecimal notations.\n\n## build.cssMinify\n\n- **Type:** `boolean | 'esbuild' | 'lightningcss'`\n- **Default:** the same as [`build.minify`](#build-minify)\n\nThis option allows users to override CSS minification specifically instead of defaulting to `build.minify`, so you can configure minification for JS and CSS separately. Vite uses `esbuild` by default to minify CSS. Set the option to `'lightningcss'` to use [Lightning CSS](https://lightningcss.dev/minification.html) instead. If selected, it can be configured using [`css.lightningcss`](shared-options#css-lightningcss).\n\n## build.sourcemap\n\n- **Type:** `boolean | 'inline' | 'hidden'`\n- **Default:** `false`\n\nGenerate production source maps. If `true`, a separate sourcemap file will be created. If `'inline'`, the sourcemap will be appended to the resulting output file as a data URI. `'hidden'` works like `true` except that the corresponding sourcemap comments in the bundled files are suppressed.\n\n## build.rollupOptions\n\n- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)\n\nDirectly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See [Rollup options docs](https://rollupjs.org/configuration-options/) for more details.\n\n## build.commonjsOptions\n\n- **Type:** [`RollupCommonJSOptions`](https://github.com/rollup/plugins/tree/master/packages/commonjs#options)\n\nOptions to pass on to [@rollup/plugin-commonjs](https://github.com/rollup/plugins/tree/master/packages/commonjs).\n\n## build.dynamicImportVarsOptions\n\n- **Type:** [`RollupDynamicImportVarsOptions`](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options)\n- **Related:** [Dynamic Import](../guide/features#dynamic-import)\n\nOptions to pass on to [@rollup/plugin-dynamic-import-vars](https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars).\n\n## build.lib\n\n- **Type:** `{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string) }`\n- **Related:** [Library Mode](../guide/build#library-mode)\n\nBuild as a library. `entry` is required since the library cannot use HTML as entry. `name` is the exposed global variable and is required when `formats` includes `'umd'` or `'iife'`. Default `formats` are `['es', 'umd']`, or `['es', 'cjs']`, if multiple entries are used. `fileName` is the name of the package file output, default `fileName` is the name option of package.json, it can also be defined as function taking the `format` and `entryAlias` as arguments.\n\n## build.manifest\n\n- **Type:** `boolean | string`\n- **Default:** `false`\n- **Related:** [Backend Integration](../guide/backend-integration)\n\nWhen set to `true`, the build will also generate a `.vite/manifest.json` file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.\n\n## build.ssrManifest\n\n- **Type:** `boolean | string`\n- **Default:** `false`\n- **Related:** [Server-Side Rendering](../guide/ssr)\n\nWhen set to `true`, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.\n\n## build.ssr\n\n- **Type:** `boolean | string`\n- **Default:** `false`\n- **Related:** [Server-Side Rendering](../guide/ssr)\n\nProduce SSR-oriented build. The value can be a string to directly specify the SSR entry, or `true`, which requires specifying the SSR entry via `rollupOptions.input`.\n\n## build.ssrEmitAssets\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nDuring the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.\n\n## build.minify\n\n- **Type:** `boolean | 'terser' | 'esbuild'`\n- **Default:** `'esbuild'` for client build, `false` for SSR build\n\nSet to `false` to disable minification, or specify the minifier to use. The default is [esbuild](https://github.com/evanw/esbuild) which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. [Benchmarks](https://github.com/privatenumber/minification-benchmarks)\n\nNote the `build.minify` option does not minify whitespaces when using the `'es'` format in lib mode, as it removes pure annotations and breaks tree-shaking.\n\nTerser must be installed when it is set to `'terser'`.\n\nsh\n\n``` javascript\nnpm add -D terser\n```\n\n## build.terserOptions\n\n- **Type:** `TerserOptions`\n\nAdditional [minify options](https://terser.org/docs/api-reference#minify-options) to pass on to Terser.\n\nIn addition, you can also pass a `maxWorkers: number` option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.\n\n## build.write\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nSet to `false` to disable writing the bundle to disk. This is mostly used in [programmatic `build()` calls](../guide/api-javascript#build) where further post processing of the bundle is needed before writing to disk.\n\n## build.emptyOutDir\n\n- **Type:** `boolean`\n- **Default:** `true` if `outDir` is inside `root`\n\nBy default, Vite will empty the `outDir` on build if it is inside project root. It will emit a warning if `outDir` is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as `--emptyOutDir`.\n\n## build.copyPublicDir\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nBy default, Vite will copy files from the `publicDir` into the `outDir` on build. Set to `false` to disable this.\n\n## build.reportCompressedSize\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nEnable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.\n\n## build.chunkSizeWarningLimit\n\n- **Type:** `number`\n- **Default:** `500`\n\nLimit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the [JavaScript size itself is related to the execution time](https://v8.dev/blog/cost-of-javascript-2019).\n\n## build.watch\n\n- **Type:** [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch)`| null`\n- **Default:** `null`\n\nSet to `{}` to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.\n\n**Using Vite on Windows Subsystem for Linux (WSL) 2**\n\nThere are cases that file system watching does not work with WSL2. See [`server.watch`](server-options#server-watch) for more details.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/build-options](https://vitejs.dev/config/build-options)"
- name: Building for Production
  id: guide/build
  summary: When it is time to deploy your app for production, simply run the vite build command
  description: "# Building for Production\n\nWhen it is time to deploy your app for production, simply run the `vite build` command. By default, it uses `<root>/index.html` as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the [Deploying a Static Site](static-deploy) for guides about popular services.\n\n## Browser Compatibility\n\nThe production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta):\n\n- Chrome \\>=87\n- Firefox \\>=78\n- Safari \\>=14\n- Edge \\>=88\n\nYou can specify custom targets via the [`build.target` config option](../config/build-options#build-target), where the lowest target is `es2015`.\n\nNote that by default, Vite only handles syntax transforms and **does not cover polyfills**. You can check out [Polyfill.io](https://polyfill.io/) which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.\n\nLegacy browsers can be supported via [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy), which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.\n\n## Public Base Path\n\n- Related: [Asset Handling](assets)\n\nIf you are deploying your project under a nested public path, simply specify the [`base` config option](../config/shared-options#base) and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. `vite build --base=/my/public/path/`.\n\nJS-imported asset URLs, CSS `url()` references, and asset references in your `.html` files are all automatically adjusted to respect this option during build.\n\nThe exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected `import.meta.env.BASE_URL` variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. `import.meta.env['BASE_URL']` won't work).\n\nFor advanced base path control, check out [Advanced Base Options](#advanced-base-options).\n\n## Customizing the Build\n\nThe build can be customized via various [build config options](../config/build-options). Specifically, you can directly adjust the underlying [Rollup options](https://rollupjs.org/configuration-options/) via `build.rollupOptions`:\n\njs\n\n``` javascript\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/configuration-options/\n    },\n  },\n})\n```\n\nFor example, you can specify multiple Rollup outputs with plugins that are only applied during build.\n\n## Chunking Strategy\n\nYou can configure how chunks are split using `build.rollupOptions.output.manualChunks` (see [Rollup docs](https://rollupjs.org/configuration-options/#output-manualchunks)). If you use a framework, refer to their documentation for configuring how chunks are splitted.\n\n## Load Error Handling\n\nVite emits `vite:preloadError` event when it fails to load dynamic imports. `event.payload` contains the original import error. If you call `event.preventDefault()`, the error will not be thrown.\n\njs\n\n``` javascript\nwindow.addEventListener('vite:preloadError', (event) => {\n  window.location.reload() // for example, refresh the page\n})\n```\n\nWhen a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.\n\n## Rebuild on files changes\n\nYou can enable rollup watcher with `vite build --watch`. Or, you can directly adjust the underlying [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) via `build.watch`:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    watch: {\n      // https://rollupjs.org/configuration-options/#watch\n    },\n  },\n})\n```\n\nWith the `--watch` flag enabled, changes to the `vite.config.js`, as well as any files to be bundled, will trigger a rebuild.\n\n## Multi-Page App\n\nSuppose you have the following source code structure:\n\n``` javascript\n├── package.json\n├── vite.config.js\n├── index.html\n├── main.js\n└── nested\n    ├── index.html\n    └── nested.js\n```\n\nDuring dev, simply navigate or link to `/nested/` - it works as expected, just like for a normal static file server.\n\nDuring build, all you need to do is to specify multiple `.html` files as entry points:\n\njs\n\n``` javascript\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      input: {\n        main: resolve(__dirname, 'index.html'),\n        nested: resolve(__dirname, 'nested/index.html'),\n      },\n    },\n  },\n})\n```\n\nIf you specify a different root, remember that `__dirname` will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your `root` entry to the arguments for `resolve`.\n\nNote that for HTML files, Vite ignores the name given to the entry in the `rollupOptions.input` object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.\n\n## Library Mode\n\nWhen you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your `index.html` for that purpose to get the smooth development experience.\n\nWhen it is time to bundle your library for distribution, use the [`build.lib` config option](../config/build-options#build-lib). Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. `vue` or `react`:\n\njs\n\n``` javascript\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      // Could also be a dictionary or array of multiple entry points\n      entry: resolve(__dirname, 'lib/main.js'),\n      name: 'MyLib',\n      // the proper extensions will be added\n      fileName: 'my-lib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})\n```\n\nThe entry file would contain exports that can be imported by users of your package:\n\njs\n\n``` javascript\n// lib/main.js\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\nexport { Foo, Bar }\n```\n\nRunning `vite build` with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: `es` and `umd` (configurable via `build.lib`):\n\n``` javascript\n$ vite build\nbuilding for production...\ndist/my-lib.js      0.08 kB / gzip: 0.07 kB\ndist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB\n```\n\nRecommended `package.json` for your lib:\n\njson\n\n``` javascript\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    }\n  }\n}\n```\n\nOr, if exposing multiple entry points:\n\njson\n\n``` javascript\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.cjs\"\n    },\n    \"./secondary\": {\n      \"import\": \"./dist/secondary.js\",\n      \"require\": \"./dist/secondary.cjs\"\n    }\n  }\n}\n```\n\n**File Extensions**\n\nIf the `package.json` does not contain `\"type\": \"module\"`, Vite will generate different file extensions for Node.js compatibility. `.js` will become `.mjs` and `.cjs` will become `.js`.\n\n**Environment Variables**\n\nIn library mode, all [`import.meta.env.*`](env-and-mode) usage are statically replaced when building for production. However, `process.env.*` usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use `define: { 'process.env.NODE_ENV': '\"production\"' }` for example to statically replace them, or use [`esm-env`](https://github.com/benmccann/esm-env) for better compatibility with bundlers and runtimes.\n\n**Advanced Usage**\n\nLibrary mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use [Rollup](https://rollupjs.org) or [esbuild](https://esbuild.github.io) directly.\n\n## Advanced Base Options\n\n**WARNING**\n\nThis feature is experimental. [Give Feedback](https://github.com/vitejs/vite/discussions/13834).\n\nFor advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:\n\n- The generated entry HTML files (which may be processed during SSR)\n- The generated hashed assets (JS, CSS, and other file types like images)\n- The copied [public files](assets#the-public-directory)\n\nA single static [base](#public-base-path) isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using `experimental.renderBuiltUrl`.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostType }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  },\n},\n```\n\nIf the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset `type` included in the second `context` param given to the function.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostId, hostType, type }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    } else if (path.extname(hostId) === '.js') {\n      return { runtime: `window.__assetsPath(${JSON.stringify(filename)})` }\n    } else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  },\n},\n```\n\nNote that the `filename` passed is a decoded URL, and if the function returns a URL string, it should also be decoded. Vite will handle the encoding automatically when rendering the URLs. If an object with `runtime` is returned, encoding should be handled yourself where needed as the runtime code will be rendered as is.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/build](https://vitejs.dev/guide/build)"
- name: 'Building for Production: Advanced Base Options'
  id: guide/build#advanced-base-options
  summary: This feature is experimental
  belongs_to: Building for Production
  description: "## Advanced Base Options\n\n**WARNING**\n\nThis feature is experimental. [Give Feedback](https://github.com/vitejs/vite/discussions/13834).\n\nFor advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:\n\n- The generated entry HTML files (which may be processed during SSR)\n- The generated hashed assets (JS, CSS, and other file types like images)\n- The copied [public files](assets#the-public-directory)\n\nA single static [base](#public-base-path) isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using `experimental.renderBuiltUrl`.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostType }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  },\n},\n```\n\nIf the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset `type` included in the second `context` param given to the function.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostId, hostType, type }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    } else if (path.extname(hostId) === '.js') {\n      return { runtime: `window.__assetsPath(${JSON.stringify(filename)})` }\n    } else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  },\n},\n```\n\nNote that the `filename` passed is a decoded URL, and if the function returns a URL string, it should also be decoded. Vite will handle the encoding automatically when rendering the URLs. If an object with `runtime` is returned, encoding should be handled yourself where needed as the runtime code will be rendered as is.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/build](https://vitejs.dev/guide/build)"
- name: 'Building for Production: APIs'
  id: guide/build
  summary: When it is time to deploy your app for production, simply run the vite build command
  description: "# Building for Production\n\nWhen it is time to deploy your app for production, simply run the `vite build` command. By default, it uses `<root>/index.html` as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the [Deploying a Static Site](static-deploy) for guides about popular services.\n\n## Browser Compatibility\n\nThe production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta):\n\n- Chrome \\>=87\n- Firefox \\>=78\n- Safari \\>=14\n- Edge \\>=88\n\nYou can specify custom targets via the [`build.target` config option](../config/build-options#build-target), where the lowest target is `es2015`.\n\nNote that by default, Vite only handles syntax transforms and **does not cover polyfills**. You can check out [Polyfill.io](https://polyfill.io/) which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.\n\nLegacy browsers can be supported via [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy), which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.\n\n## Public Base Path\n\n- Related: [Asset Handling](assets)\n\nIf you are deploying your project under a nested public path, simply specify the [`base` config option](../config/shared-options#base) and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. `vite build --base=/my/public/path/`.\n\nJS-imported asset URLs, CSS `url()` references, and asset references in your `.html` files are all automatically adjusted to respect this option during build.\n\nThe exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected `import.meta.env.BASE_URL` variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. `import.meta.env['BASE_URL']` won't work).\n\nFor advanced base path control, check out [Advanced Base Options](#advanced-base-options).\n\n## Customizing the Build\n\nThe build can be customized via various [build config options](../config/build-options). Specifically, you can directly adjust the underlying [Rollup options](https://rollupjs.org/configuration-options/) via `build.rollupOptions`:\n\njs\n\n``` javascript\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/configuration-options/\n    },\n  },\n})\n```\n\nFor example, you can specify multiple Rollup outputs with plugins that are only applied during build.\n\n## Chunking Strategy\n\nYou can configure how chunks are split using `build.rollupOptions.output.manualChunks` (see [Rollup docs](https://rollupjs.org/configuration-options/#output-manualchunks)). If you use a framework, refer to their documentation for configuring how chunks are splitted.\n\n## Load Error Handling\n\nVite emits `vite:preloadError` event when it fails to load dynamic imports. `event.payload` contains the original import error. If you call `event.preventDefault()`, the error will not be thrown.\n\njs\n\n``` javascript\nwindow.addEventListener('vite:preloadError', (event) => {\n  window.location.reload() // for example, refresh the page\n})\n```\n\nWhen a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.\n\n## Rebuild on files changes\n\nYou can enable rollup watcher with `vite build --watch`. Or, you can directly adjust the underlying [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) via `build.watch`:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    watch: {\n      // https://rollupjs.org/configuration-options/#watch\n    },\n  },\n})\n```\n\nWith the `--watch` flag enabled, changes to the `vite.config.js`, as well as any files to be bundled, will trigger a rebuild.\n\n## Multi-Page App\n\nSuppose you have the following source code structure:\n\n``` javascript\n├── package.json\n├── vite.config.js\n├── index.html\n├── main.js\n└── nested\n    ├── index.html\n    └── nested.js\n```\n\nDuring dev, simply navigate or link to `/nested/` - it works as expected, just like for a normal static file server.\n\nDuring build, all you need to do is to specify multiple `.html` files as entry points:\n\njs\n\n``` javascript\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      input: {\n        main: resolve(__dirname, 'index.html'),\n        nested: resolve(__dirname, 'nested/index.html'),\n      },\n    },\n  },\n})\n```\n\nIf you specify a different root, remember that `__dirname` will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your `root` entry to the arguments for `resolve`.\n\nNote that for HTML files, Vite ignores the name given to the entry in the `rollupOptions.input` object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.\n\n## Library Mode\n\nWhen you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your `index.html` for that purpose to get the smooth development experience.\n\nWhen it is time to bundle your library for distribution, use the [`build.lib` config option](../config/build-options#build-lib). Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. `vue` or `react`:\n\njs\n\n``` javascript\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      // Could also be a dictionary or array of multiple entry points\n      entry: resolve(__dirname, 'lib/main.js'),\n      name: 'MyLib',\n      // the proper extensions will be added\n      fileName: 'my-lib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})\n```\n\nThe entry file would contain exports that can be imported by users of your package:\n\njs\n\n``` javascript\n// lib/main.js\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\nexport { Foo, Bar }\n```\n\nRunning `vite build` with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: `es` and `umd` (configurable via `build.lib`):\n\n``` javascript\n$ vite build\nbuilding for production...\ndist/my-lib.js      0.08 kB / gzip: 0.07 kB\ndist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB\n```\n\nRecommended `package.json` for your lib:\n\njson\n\n``` javascript\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    }\n  }\n}\n```\n\nOr, if exposing multiple entry points:\n\njson\n\n``` javascript\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.cjs\"\n    },\n    \"./secondary\": {\n      \"import\": \"./dist/secondary.js\",\n      \"require\": \"./dist/secondary.cjs\"\n    }\n  }\n}\n```\n\n**File Extensions**\n\nIf the `package.json` does not contain `\"type\": \"module\"`, Vite will generate different file extensions for Node.js compatibility. `.js` will become `.mjs` and `.cjs` will become `.js`.\n\n**Environment Variables**\n\nIn library mode, all [`import.meta.env.*`](env-and-mode) usage are statically replaced when building for production. However, `process.env.*` usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use `define: { 'process.env.NODE_ENV': '\"production\"' }` for example to statically replace them, or use [`esm-env`](https://github.com/benmccann/esm-env) for better compatibility with bundlers and runtimes.\n\n**Advanced Usage**\n\nLibrary mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use [Rollup](https://rollupjs.org) or [esbuild](https://esbuild.github.io) directly.\n\n## Advanced Base Options\n\n**WARNING**\n\nThis feature is experimental. [Give Feedback](https://github.com/vitejs/vite/discussions/13834).\n\nFor advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:\n\n- The generated entry HTML files (which may be processed during SSR)\n- The generated hashed assets (JS, CSS, and other file types like images)\n- The copied [public files](assets#the-public-directory)\n\nA single static [base](#public-base-path) isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using `experimental.renderBuiltUrl`.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostType }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  },\n},\n```\n\nIf the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset `type` included in the second `context` param given to the function.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostId, hostType, type }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    } else if (path.extname(hostId) === '.js') {\n      return { runtime: `window.__assetsPath(${JSON.stringify(filename)})` }\n    } else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  },\n},\n```\n\nNote that the `filename` passed is a decoded URL, and if the function returns a URL string, it should also be decoded. Vite will handle the encoding automatically when rendering the URLs. If an object with `runtime` is returned, encoding should be handled yourself where needed as the runtime code will be rendered as is.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/build](https://vitejs.dev/guide/build)"
- name: 'Building for Production: Browser Compatibility'
  id: guide/build#browser-compatibility
  summary: The production bundle assumes support for modern JavaScript
  belongs_to: Building for Production
  description: |-
    ## Browser Compatibility

    The production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta):

    - Chrome \>=87
    - Firefox \>=78
    - Safari \>=14
    - Edge \>=88

    You can specify custom targets via the [`build.target` config option](../config/build-options#build-target), where the lowest target is `es2015`.

    Note that by default, Vite only handles syntax transforms and **does not cover polyfills**. You can check out [Polyfill.io](https://polyfill.io/) which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.

    Legacy browsers can be supported via [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy), which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.
- name: 'Building for Production: Chunking Strategy'
  id: guide/build#chunking-strategy
  summary: You can configure how chunks are split using build.rollupOptions.output.manualChunks (see Rollup docs). If you use a framework, refer to their documentation for configuring how chunks are splitted
  belongs_to: Building for Production
  description: |-
    ## Chunking Strategy

    You can configure how chunks are split using `build.rollupOptions.output.manualChunks` (see [Rollup docs](https://rollupjs.org/configuration-options/#output-manualchunks)). If you use a framework, refer to their documentation for configuring how chunks are splitted.
- name: 'Building for Production: Customizing the Build'
  id: guide/build#customizing-the-build
  summary: The build can be customized via various build config options
  belongs_to: Building for Production
  description: |-
    ## Customizing the Build

    The build can be customized via various [build config options](../config/build-options). Specifically, you can directly adjust the underlying [Rollup options](https://rollupjs.org/configuration-options/) via `build.rollupOptions`:

    js

    ``` javascript
    export default defineConfig({
      build: {
        rollupOptions: {
          // https://rollupjs.org/configuration-options/
        },
      },
    })
    ```

    For example, you can specify multiple Rollup outputs with plugins that are only applied during build.
- name: 'Building for Production: Guide'
  id: guide/build
  summary: When it is time to deploy your app for production, simply run the vite build command
  description: "# Building for Production\n\nWhen it is time to deploy your app for production, simply run the `vite build` command. By default, it uses `<root>/index.html` as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the [Deploying a Static Site](static-deploy) for guides about popular services.\n\n## Browser Compatibility\n\nThe production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta):\n\n- Chrome \\>=87\n- Firefox \\>=78\n- Safari \\>=14\n- Edge \\>=88\n\nYou can specify custom targets via the [`build.target` config option](../config/build-options#build-target), where the lowest target is `es2015`.\n\nNote that by default, Vite only handles syntax transforms and **does not cover polyfills**. You can check out [Polyfill.io](https://polyfill.io/) which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.\n\nLegacy browsers can be supported via [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy), which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.\n\n## Public Base Path\n\n- Related: [Asset Handling](assets)\n\nIf you are deploying your project under a nested public path, simply specify the [`base` config option](../config/shared-options#base) and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. `vite build --base=/my/public/path/`.\n\nJS-imported asset URLs, CSS `url()` references, and asset references in your `.html` files are all automatically adjusted to respect this option during build.\n\nThe exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected `import.meta.env.BASE_URL` variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. `import.meta.env['BASE_URL']` won't work).\n\nFor advanced base path control, check out [Advanced Base Options](#advanced-base-options).\n\n## Customizing the Build\n\nThe build can be customized via various [build config options](../config/build-options). Specifically, you can directly adjust the underlying [Rollup options](https://rollupjs.org/configuration-options/) via `build.rollupOptions`:\n\njs\n\n``` javascript\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/configuration-options/\n    },\n  },\n})\n```\n\nFor example, you can specify multiple Rollup outputs with plugins that are only applied during build.\n\n## Chunking Strategy\n\nYou can configure how chunks are split using `build.rollupOptions.output.manualChunks` (see [Rollup docs](https://rollupjs.org/configuration-options/#output-manualchunks)). If you use a framework, refer to their documentation for configuring how chunks are splitted.\n\n## Load Error Handling\n\nVite emits `vite:preloadError` event when it fails to load dynamic imports. `event.payload` contains the original import error. If you call `event.preventDefault()`, the error will not be thrown.\n\njs\n\n``` javascript\nwindow.addEventListener('vite:preloadError', (event) => {\n  window.location.reload() // for example, refresh the page\n})\n```\n\nWhen a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.\n\n## Rebuild on files changes\n\nYou can enable rollup watcher with `vite build --watch`. Or, you can directly adjust the underlying [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) via `build.watch`:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    watch: {\n      // https://rollupjs.org/configuration-options/#watch\n    },\n  },\n})\n```\n\nWith the `--watch` flag enabled, changes to the `vite.config.js`, as well as any files to be bundled, will trigger a rebuild.\n\n## Multi-Page App\n\nSuppose you have the following source code structure:\n\n``` javascript\n├── package.json\n├── vite.config.js\n├── index.html\n├── main.js\n└── nested\n    ├── index.html\n    └── nested.js\n```\n\nDuring dev, simply navigate or link to `/nested/` - it works as expected, just like for a normal static file server.\n\nDuring build, all you need to do is to specify multiple `.html` files as entry points:\n\njs\n\n``` javascript\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      input: {\n        main: resolve(__dirname, 'index.html'),\n        nested: resolve(__dirname, 'nested/index.html'),\n      },\n    },\n  },\n})\n```\n\nIf you specify a different root, remember that `__dirname` will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your `root` entry to the arguments for `resolve`.\n\nNote that for HTML files, Vite ignores the name given to the entry in the `rollupOptions.input` object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.\n\n## Library Mode\n\nWhen you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your `index.html` for that purpose to get the smooth development experience.\n\nWhen it is time to bundle your library for distribution, use the [`build.lib` config option](../config/build-options#build-lib). Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. `vue` or `react`:\n\njs\n\n``` javascript\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      // Could also be a dictionary or array of multiple entry points\n      entry: resolve(__dirname, 'lib/main.js'),\n      name: 'MyLib',\n      // the proper extensions will be added\n      fileName: 'my-lib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})\n```\n\nThe entry file would contain exports that can be imported by users of your package:\n\njs\n\n``` javascript\n// lib/main.js\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\nexport { Foo, Bar }\n```\n\nRunning `vite build` with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: `es` and `umd` (configurable via `build.lib`):\n\n``` javascript\n$ vite build\nbuilding for production...\ndist/my-lib.js      0.08 kB / gzip: 0.07 kB\ndist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB\n```\n\nRecommended `package.json` for your lib:\n\njson\n\n``` javascript\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    }\n  }\n}\n```\n\nOr, if exposing multiple entry points:\n\njson\n\n``` javascript\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.cjs\"\n    },\n    \"./secondary\": {\n      \"import\": \"./dist/secondary.js\",\n      \"require\": \"./dist/secondary.cjs\"\n    }\n  }\n}\n```\n\n**File Extensions**\n\nIf the `package.json` does not contain `\"type\": \"module\"`, Vite will generate different file extensions for Node.js compatibility. `.js` will become `.mjs` and `.cjs` will become `.js`.\n\n**Environment Variables**\n\nIn library mode, all [`import.meta.env.*`](env-and-mode) usage are statically replaced when building for production. However, `process.env.*` usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use `define: { 'process.env.NODE_ENV': '\"production\"' }` for example to statically replace them, or use [`esm-env`](https://github.com/benmccann/esm-env) for better compatibility with bundlers and runtimes.\n\n**Advanced Usage**\n\nLibrary mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use [Rollup](https://rollupjs.org) or [esbuild](https://esbuild.github.io) directly.\n\n## Advanced Base Options\n\n**WARNING**\n\nThis feature is experimental. [Give Feedback](https://github.com/vitejs/vite/discussions/13834).\n\nFor advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:\n\n- The generated entry HTML files (which may be processed during SSR)\n- The generated hashed assets (JS, CSS, and other file types like images)\n- The copied [public files](assets#the-public-directory)\n\nA single static [base](#public-base-path) isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using `experimental.renderBuiltUrl`.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostType }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  },\n},\n```\n\nIf the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset `type` included in the second `context` param given to the function.\n\nts\n\n``` javascript\nexperimental: {\n  renderBuiltUrl(filename, { hostId, hostType, type }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    } else if (path.extname(hostId) === '.js') {\n      return { runtime: `window.__assetsPath(${JSON.stringify(filename)})` }\n    } else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  },\n},\n```\n\nNote that the `filename` passed is a decoded URL, and if the function returns a URL string, it should also be decoded. Vite will handle the encoding automatically when rendering the URLs. If an object with `runtime` is returned, encoding should be handled yourself where needed as the runtime code will be rendered as is.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/build](https://vitejs.dev/guide/build)"
- name: 'Building for Production: Library Mode'
  id: guide/build#library-mode
  summary: When you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library
  belongs_to: Building for Production
  description: |-
    ## Library Mode

    When you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your `index.html` for that purpose to get the smooth development experience.

    When it is time to bundle your library for distribution, use the [`build.lib` config option](../config/build-options#build-lib). Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. `vue` or `react`:

    js

    ``` javascript
    // vite.config.js
    import { resolve } from 'path'
    import { defineConfig } from 'vite'

    export default defineConfig({
      build: {
        lib: {
          // Could also be a dictionary or array of multiple entry points
          entry: resolve(__dirname, 'lib/main.js'),
          name: 'MyLib',
          // the proper extensions will be added
          fileName: 'my-lib',
        },
        rollupOptions: {
          // make sure to externalize deps that shouldn't be bundled
          // into your library
          external: ['vue'],
          output: {
            // Provide global variables to use in the UMD build
            // for externalized deps
            globals: {
              vue: 'Vue',
            },
          },
        },
      },
    })
    ```

    The entry file would contain exports that can be imported by users of your package:

    js

    ``` javascript
    // lib/main.js
    import Foo from './Foo.vue'
    import Bar from './Bar.vue'
    export { Foo, Bar }
    ```

    Running `vite build` with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: `es` and `umd` (configurable via `build.lib`):

    ``` javascript
    $ vite build
    building for production...
    dist/my-lib.js      0.08 kB / gzip: 0.07 kB
    dist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB
    ```

    Recommended `package.json` for your lib:

    json

    ``` javascript
    {
      "name": "my-lib",
      "type": "module",
      "files": ["dist"],
      "main": "./dist/my-lib.umd.cjs",
      "module": "./dist/my-lib.js",
      "exports": {
        ".": {
          "import": "./dist/my-lib.js",
          "require": "./dist/my-lib.umd.cjs"
        }
      }
    }
    ```

    Or, if exposing multiple entry points:

    json

    ``` javascript
    {
      "name": "my-lib",
      "type": "module",
      "files": ["dist"],
      "main": "./dist/my-lib.cjs",
      "module": "./dist/my-lib.js",
      "exports": {
        ".": {
          "import": "./dist/my-lib.js",
          "require": "./dist/my-lib.cjs"
        },
        "./secondary": {
          "import": "./dist/secondary.js",
          "require": "./dist/secondary.cjs"
        }
      }
    }
    ```

    **File Extensions**

    If the `package.json` does not contain `"type": "module"`, Vite will generate different file extensions for Node.js compatibility. `.js` will become `.mjs` and `.cjs` will become `.js`.

    **Environment Variables**

    In library mode, all [`import.meta.env.*`](env-and-mode) usage are statically replaced when building for production. However, `process.env.*` usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use `define: { 'process.env.NODE_ENV': '"production"' }` for example to statically replace them, or use [`esm-env`](https://github.com/benmccann/esm-env) for better compatibility with bundlers and runtimes.

    **Advanced Usage**

    Library mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use [Rollup](https://rollupjs.org) or [esbuild](https://esbuild.github.io) directly.
- name: 'Building for Production: Load Error Handling'
  id: guide/build#load-error-handling
  summary: Vite emits vite:preloadError event when it fails to load dynamic imports
  belongs_to: Building for Production
  description: |-
    ## Load Error Handling

    Vite emits `vite:preloadError` event when it fails to load dynamic imports. `event.payload` contains the original import error. If you call `event.preventDefault()`, the error will not be thrown.

    js

    ``` javascript
    window.addEventListener('vite:preloadError', (event) => {
      window.location.reload() // for example, refresh the page
    })
    ```

    When a new deployment occurs, the hosting service may delete the assets from previous deployments. As a result, a user who visited your site before the new deployment might encounter an import error. This error happens because the assets running on that user's device are outdated and it tries to import the corresponding old chunk, which is deleted. This event is useful for addressing this situation.
- name: 'Building for Production: Multi-Page App'
  id: guide/build#multi-page-app
  summary: During dev, simply navigate or link to /nested/ - it works as expected, just like for a normal static file server
  belongs_to: Building for Production
  description: |-
    ## Multi-Page App

    Suppose you have the following source code structure:

    ``` javascript
    ├── package.json
    ├── vite.config.js
    ├── index.html
    ├── main.js
    └── nested
        ├── index.html
        └── nested.js
    ```

    During dev, simply navigate or link to `/nested/` - it works as expected, just like for a normal static file server.

    During build, all you need to do is to specify multiple `.html` files as entry points:

    js

    ``` javascript
    // vite.config.js
    import { resolve } from 'path'
    import { defineConfig } from 'vite'

    export default defineConfig({
      build: {
        rollupOptions: {
          input: {
            main: resolve(__dirname, 'index.html'),
            nested: resolve(__dirname, 'nested/index.html'),
          },
        },
      },
    })
    ```

    If you specify a different root, remember that `__dirname` will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your `root` entry to the arguments for `resolve`.

    Note that for HTML files, Vite ignores the name given to the entry in the `rollupOptions.input` object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.
- name: 'Building for Production: Public Base Path'
  id: guide/build#public-base-path
  summary: If you are deploying your project under a nested public path, simply specify the base config option and all asset paths will be rewritten accordingly
  belongs_to: Building for Production
  description: |-
    ## Public Base Path

    - Related: [Asset Handling](assets)

    If you are deploying your project under a nested public path, simply specify the [`base` config option](../config/shared-options#base) and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. `vite build --base=/my/public/path/`.

    JS-imported asset URLs, CSS `url()` references, and asset references in your `.html` files are all automatically adjusted to respect this option during build.

    The exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected `import.meta.env.BASE_URL` variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. `import.meta.env['BASE_URL']` won't work).

    For advanced base path control, check out [Advanced Base Options](#advanced-base-options).
- name: 'Building for Production: Rebuild on files changes'
  id: guide/build#rebuild-on-files-changes
  summary: You can enable rollup watcher with vite build --watch
  belongs_to: Building for Production
  description: |-
    ## Rebuild on files changes

    You can enable rollup watcher with `vite build --watch`. Or, you can directly adjust the underlying [`WatcherOptions`](https://rollupjs.org/configuration-options/#watch) via `build.watch`:

    js

    ``` javascript
    // vite.config.js
    export default defineConfig({
      build: {
        watch: {
          // https://rollupjs.org/configuration-options/#watch
        },
      },
    })
    ```

    With the `--watch` flag enabled, changes to the `vite.config.js`, as well as any files to be bundled, will trigger a rebuild.
- name: Command Line Interface
  id: guide/cli
  summary: Start Vite dev server in the current directory
  description: "# Command Line Interface\n\n## Dev server\n\n### `vite`\n\nStart Vite dev server in the current directory. `vite dev` and `vite serve` are aliases for `vite`.\n\n#### Usage\n\nbash\n\n``` javascript\nvite [root]\n```\n\n#### Options\n\n| Options                  |                                                                                                             |\n|--------------------------|-------------------------------------------------------------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                                                                                 |\n| `--port <port>`          | Specify port (`number`)                                                                                     |\n| `--open [path]`          | Open browser on startup (`boolean | string`)                                                                |\n| `--cors`                 | Enable CORS (`boolean`)                                                                                     |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`)                                                        |\n| `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`)                                           |\n| `-c, --config <file>`    | Use specified config file (`string`)                                                                        |\n| `--base <path>`          | Public base path (default: `/`) (`string`)                                                                  |\n| `-l, --logLevel <level>` | info \\| warn \\| error \\| silent (`string`)                                                                  |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)                                                         |\n| `--profile`              | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks)) |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                                                                        |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                                                                                |\n| `-m, --mode <mode>`      | Set env mode (`string`)                                                                                     |\n| `-h, --help`             | Display available CLI options                                                                               |\n| `-v, --version`          | Display version number                                                                                      |\n\n## Build\n\n### `vite build`\n\nBuild for production.\n\n#### Usage\n\nbash\n\n``` javascript\nvite build [root]\n```\n\n#### Options\n\n| Options                        |                                                                                                                   |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------|\n| `--target <target>`            | Transpile target (default: `\"modules\"`) (`string`)                                                                |\n| `--outDir <dir>`               | Output directory (default: `dist`) (`string`)                                                                     |\n| `--assetsDir <dir>`            | Directory under outDir to place assets in (default: `\"assets\"`) (`string`)                                        |\n| `--assetsInlineLimit <number>` | Static asset base64 inline threshold in bytes (default: `4096`) (`number`)                                        |\n| `--ssr [entry]`                | Build specified entry for server-side rendering (`string`)                                                        |\n| `--sourcemap [output]`         | Output source maps for build (default: `false`) (`boolean | \"inline\" | \"hidden\"`)                                 |\n| `--minify [minifier]`          | Enable/disable minification, or specify minifier to use (default: `\"esbuild\"`) (`boolean | \"terser\" | \"esbuild\"`) |\n| `--manifest [name]`            | Emit build manifest json (`boolean | string`)                                                                     |\n| `--ssrManifest [name]`         | Emit ssr manifest json (`boolean | string`)                                                                       |\n| `--emptyOutDir`                | Force empty outDir when it's outside of root (`boolean`)                                                          |\n| `-w, --watch`                  | Rebuilds when modules have changed on disk (`boolean`)                                                            |\n| `-c, --config <file>`          | Use specified config file (`string`)                                                                              |\n| `--base <path>`                | Public base path (default: `/`) (`string`)                                                                        |\n| `-l, --logLevel <level>`       | Info \\| warn \\| error \\| silent (`string`)                                                                        |\n| `--clearScreen`                | Allow/disable clear screen when logging (`boolean`)                                                               |\n| `--profile`                    | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks))       |\n| `-d, --debug [feat]`           | Show debug logs (`string | boolean`)                                                                              |\n| `-f, --filter <filter>`        | Filter debug logs (`string`)                                                                                      |\n| `-m, --mode <mode>`            | Set env mode (`string`)                                                                                           |\n| `-h, --help`                   | Display available CLI options                                                                                     |\n\n## Others\n\n### `vite optimize`\n\nPre-bundle dependencies.\n\n#### Usage\n\nbash\n\n``` javascript\nvite optimize [root]\n```\n\n#### Options\n\n| Options                  |                                                                   |\n|--------------------------|-------------------------------------------------------------------|\n| `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`) |\n| `-c, --config <file>`    | Use specified config file (`string`)                              |\n| `--base <path>`          | Public base path (default: `/`) (`string`)                        |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)                        |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)               |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                              |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                                      |\n| `-m, --mode <mode>`      | Set env mode (`string`)                                           |\n| `-h, --help`             | Display available CLI options                                     |\n\n### `vite preview`\n\nLocally preview the production build. Do not use this as a production server as it's not designed for it.\n\n#### Usage\n\nbash\n\n``` javascript\nvite preview [root]\n```\n\n#### Options\n\n| Options                  |                                                      |\n|--------------------------|------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                          |\n| `--port <port>`          | Specify port (`number`)                              |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`) |\n| `--open [path]`          | Open browser on startup (`boolean | string`)         |\n| `--outDir <dir>`         | Output directory (default: `dist`)(`string`)         |\n| `-c, --config <file>`    | Use specified config file (`string`)                 |\n| `--base <path>`          | Public base path (default: `/`) (`string`)           |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)           |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)  |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                 |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                         |\n| `-m, --mode <mode>`      | Set env mode (`string`)                              |\n| `-h, --help`             | Display available CLI options                        |\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/cli](https://vitejs.dev/guide/cli)"
- name: 'Command Line Interface: APIs'
  id: guide/cli
  summary: Start Vite dev server in the current directory
  description: "# Command Line Interface\n\n## Dev server\n\n### `vite`\n\nStart Vite dev server in the current directory. `vite dev` and `vite serve` are aliases for `vite`.\n\n#### Usage\n\nbash\n\n``` javascript\nvite [root]\n```\n\n#### Options\n\n| Options                  |                                                                                                             |\n|--------------------------|-------------------------------------------------------------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                                                                                 |\n| `--port <port>`          | Specify port (`number`)                                                                                     |\n| `--open [path]`          | Open browser on startup (`boolean | string`)                                                                |\n| `--cors`                 | Enable CORS (`boolean`)                                                                                     |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`)                                                        |\n| `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`)                                           |\n| `-c, --config <file>`    | Use specified config file (`string`)                                                                        |\n| `--base <path>`          | Public base path (default: `/`) (`string`)                                                                  |\n| `-l, --logLevel <level>` | info \\| warn \\| error \\| silent (`string`)                                                                  |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)                                                         |\n| `--profile`              | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks)) |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                                                                        |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                                                                                |\n| `-m, --mode <mode>`      | Set env mode (`string`)                                                                                     |\n| `-h, --help`             | Display available CLI options                                                                               |\n| `-v, --version`          | Display version number                                                                                      |\n\n## Build\n\n### `vite build`\n\nBuild for production.\n\n#### Usage\n\nbash\n\n``` javascript\nvite build [root]\n```\n\n#### Options\n\n| Options                        |                                                                                                                   |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------|\n| `--target <target>`            | Transpile target (default: `\"modules\"`) (`string`)                                                                |\n| `--outDir <dir>`               | Output directory (default: `dist`) (`string`)                                                                     |\n| `--assetsDir <dir>`            | Directory under outDir to place assets in (default: `\"assets\"`) (`string`)                                        |\n| `--assetsInlineLimit <number>` | Static asset base64 inline threshold in bytes (default: `4096`) (`number`)                                        |\n| `--ssr [entry]`                | Build specified entry for server-side rendering (`string`)                                                        |\n| `--sourcemap [output]`         | Output source maps for build (default: `false`) (`boolean | \"inline\" | \"hidden\"`)                                 |\n| `--minify [minifier]`          | Enable/disable minification, or specify minifier to use (default: `\"esbuild\"`) (`boolean | \"terser\" | \"esbuild\"`) |\n| `--manifest [name]`            | Emit build manifest json (`boolean | string`)                                                                     |\n| `--ssrManifest [name]`         | Emit ssr manifest json (`boolean | string`)                                                                       |\n| `--emptyOutDir`                | Force empty outDir when it's outside of root (`boolean`)                                                          |\n| `-w, --watch`                  | Rebuilds when modules have changed on disk (`boolean`)                                                            |\n| `-c, --config <file>`          | Use specified config file (`string`)                                                                              |\n| `--base <path>`                | Public base path (default: `/`) (`string`)                                                                        |\n| `-l, --logLevel <level>`       | Info \\| warn \\| error \\| silent (`string`)                                                                        |\n| `--clearScreen`                | Allow/disable clear screen when logging (`boolean`)                                                               |\n| `--profile`                    | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks))       |\n| `-d, --debug [feat]`           | Show debug logs (`string | boolean`)                                                                              |\n| `-f, --filter <filter>`        | Filter debug logs (`string`)                                                                                      |\n| `-m, --mode <mode>`            | Set env mode (`string`)                                                                                           |\n| `-h, --help`                   | Display available CLI options                                                                                     |\n\n## Others\n\n### `vite optimize`\n\nPre-bundle dependencies.\n\n#### Usage\n\nbash\n\n``` javascript\nvite optimize [root]\n```\n\n#### Options\n\n| Options                  |                                                                   |\n|--------------------------|-------------------------------------------------------------------|\n| `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`) |\n| `-c, --config <file>`    | Use specified config file (`string`)                              |\n| `--base <path>`          | Public base path (default: `/`) (`string`)                        |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)                        |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)               |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                              |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                                      |\n| `-m, --mode <mode>`      | Set env mode (`string`)                                           |\n| `-h, --help`             | Display available CLI options                                     |\n\n### `vite preview`\n\nLocally preview the production build. Do not use this as a production server as it's not designed for it.\n\n#### Usage\n\nbash\n\n``` javascript\nvite preview [root]\n```\n\n#### Options\n\n| Options                  |                                                      |\n|--------------------------|------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                          |\n| `--port <port>`          | Specify port (`number`)                              |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`) |\n| `--open [path]`          | Open browser on startup (`boolean | string`)         |\n| `--outDir <dir>`         | Output directory (default: `dist`)(`string`)         |\n| `-c, --config <file>`    | Use specified config file (`string`)                 |\n| `--base <path>`          | Public base path (default: `/`) (`string`)           |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)           |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)  |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                 |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                         |\n| `-m, --mode <mode>`      | Set env mode (`string`)                              |\n| `-h, --help`             | Display available CLI options                        |\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/cli](https://vitejs.dev/guide/cli)"
- name: 'Command Line Interface: Build'
  id: guide/cli#build
  summary: null
  belongs_to: Command Line Interface
  description: '## Build'
- name: 'Command Line Interface: Dev server'
  id: guide/cli#dev-server
  summary: null
  belongs_to: Command Line Interface
  description: '## Dev server'
- name: 'Command Line Interface: Guide'
  id: guide/cli
  summary: Start Vite dev server in the current directory
  description: "# Command Line Interface\n\n## Dev server\n\n### `vite`\n\nStart Vite dev server in the current directory. `vite dev` and `vite serve` are aliases for `vite`.\n\n#### Usage\n\nbash\n\n``` javascript\nvite [root]\n```\n\n#### Options\n\n| Options                  |                                                                                                             |\n|--------------------------|-------------------------------------------------------------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                                                                                 |\n| `--port <port>`          | Specify port (`number`)                                                                                     |\n| `--open [path]`          | Open browser on startup (`boolean | string`)                                                                |\n| `--cors`                 | Enable CORS (`boolean`)                                                                                     |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`)                                                        |\n| `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`)                                           |\n| `-c, --config <file>`    | Use specified config file (`string`)                                                                        |\n| `--base <path>`          | Public base path (default: `/`) (`string`)                                                                  |\n| `-l, --logLevel <level>` | info \\| warn \\| error \\| silent (`string`)                                                                  |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)                                                         |\n| `--profile`              | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks)) |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                                                                        |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                                                                                |\n| `-m, --mode <mode>`      | Set env mode (`string`)                                                                                     |\n| `-h, --help`             | Display available CLI options                                                                               |\n| `-v, --version`          | Display version number                                                                                      |\n\n## Build\n\n### `vite build`\n\nBuild for production.\n\n#### Usage\n\nbash\n\n``` javascript\nvite build [root]\n```\n\n#### Options\n\n| Options                        |                                                                                                                   |\n|--------------------------------|-------------------------------------------------------------------------------------------------------------------|\n| `--target <target>`            | Transpile target (default: `\"modules\"`) (`string`)                                                                |\n| `--outDir <dir>`               | Output directory (default: `dist`) (`string`)                                                                     |\n| `--assetsDir <dir>`            | Directory under outDir to place assets in (default: `\"assets\"`) (`string`)                                        |\n| `--assetsInlineLimit <number>` | Static asset base64 inline threshold in bytes (default: `4096`) (`number`)                                        |\n| `--ssr [entry]`                | Build specified entry for server-side rendering (`string`)                                                        |\n| `--sourcemap [output]`         | Output source maps for build (default: `false`) (`boolean | \"inline\" | \"hidden\"`)                                 |\n| `--minify [minifier]`          | Enable/disable minification, or specify minifier to use (default: `\"esbuild\"`) (`boolean | \"terser\" | \"esbuild\"`) |\n| `--manifest [name]`            | Emit build manifest json (`boolean | string`)                                                                     |\n| `--ssrManifest [name]`         | Emit ssr manifest json (`boolean | string`)                                                                       |\n| `--emptyOutDir`                | Force empty outDir when it's outside of root (`boolean`)                                                          |\n| `-w, --watch`                  | Rebuilds when modules have changed on disk (`boolean`)                                                            |\n| `-c, --config <file>`          | Use specified config file (`string`)                                                                              |\n| `--base <path>`                | Public base path (default: `/`) (`string`)                                                                        |\n| `-l, --logLevel <level>`       | Info \\| warn \\| error \\| silent (`string`)                                                                        |\n| `--clearScreen`                | Allow/disable clear screen when logging (`boolean`)                                                               |\n| `--profile`                    | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks))       |\n| `-d, --debug [feat]`           | Show debug logs (`string | boolean`)                                                                              |\n| `-f, --filter <filter>`        | Filter debug logs (`string`)                                                                                      |\n| `-m, --mode <mode>`            | Set env mode (`string`)                                                                                           |\n| `-h, --help`                   | Display available CLI options                                                                                     |\n\n## Others\n\n### `vite optimize`\n\nPre-bundle dependencies.\n\n#### Usage\n\nbash\n\n``` javascript\nvite optimize [root]\n```\n\n#### Options\n\n| Options                  |                                                                   |\n|--------------------------|-------------------------------------------------------------------|\n| `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`) |\n| `-c, --config <file>`    | Use specified config file (`string`)                              |\n| `--base <path>`          | Public base path (default: `/`) (`string`)                        |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)                        |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)               |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                              |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                                      |\n| `-m, --mode <mode>`      | Set env mode (`string`)                                           |\n| `-h, --help`             | Display available CLI options                                     |\n\n### `vite preview`\n\nLocally preview the production build. Do not use this as a production server as it's not designed for it.\n\n#### Usage\n\nbash\n\n``` javascript\nvite preview [root]\n```\n\n#### Options\n\n| Options                  |                                                      |\n|--------------------------|------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                          |\n| `--port <port>`          | Specify port (`number`)                              |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`) |\n| `--open [path]`          | Open browser on startup (`boolean | string`)         |\n| `--outDir <dir>`         | Output directory (default: `dist`)(`string`)         |\n| `-c, --config <file>`    | Use specified config file (`string`)                 |\n| `--base <path>`          | Public base path (default: `/`) (`string`)           |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)           |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)  |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                 |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                         |\n| `-m, --mode <mode>`      | Set env mode (`string`)                              |\n| `-h, --help`             | Display available CLI options                        |\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/cli](https://vitejs.dev/guide/cli)"
- name: 'Command Line Interface: Others'
  id: guide/cli#others
  summary: null
  belongs_to: Command Line Interface
  description: '## Others'
- name: 'Command Line Interface: vite'
  id: guide/cli#vite
  summary: Start Vite dev server in the current directory
  belongs_to: Command Line Interface
  description: |-
    ### `vite`

    Start Vite dev server in the current directory. `vite dev` and `vite serve` are aliases for `vite`.

    #### Usage

    bash

    ``` javascript
    vite [root]
    ```

    #### Options

    | Options                  |                                                                                                             |
    |--------------------------|-------------------------------------------------------------------------------------------------------------|
    | `--host [host]`          | Specify hostname (`string`)                                                                                 |
    | `--port <port>`          | Specify port (`number`)                                                                                     |
    | `--open [path]`          | Open browser on startup (`boolean | string`)                                                                |
    | `--cors`                 | Enable CORS (`boolean`)                                                                                     |
    | `--strictPort`           | Exit if specified port is already in use (`boolean`)                                                        |
    | `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`)                                           |
    | `-c, --config <file>`    | Use specified config file (`string`)                                                                        |
    | `--base <path>`          | Public base path (default: `/`) (`string`)                                                                  |
    | `-l, --logLevel <level>` | info \| warn \| error \| silent (`string`)                                                                  |
    | `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)                                                         |
    | `--profile`              | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks)) |
    | `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                                                                        |
    | `-f, --filter <filter>`  | Filter debug logs (`string`)                                                                                |
    | `-m, --mode <mode>`      | Set env mode (`string`)                                                                                     |
    | `-h, --help`             | Display available CLI options                                                                               |
    | `-v, --version`          | Display version number                                                                                      |
- name: 'Command Line Interface: vite build'
  id: guide/cli#vite-build
  summary: Build for production
  belongs_to: Command Line Interface
  description: |-
    ### `vite build`

    Build for production.

    #### Usage

    bash

    ``` javascript
    vite build [root]
    ```

    #### Options

    | Options                        |                                                                                                                   |
    |--------------------------------|-------------------------------------------------------------------------------------------------------------------|
    | `--target <target>`            | Transpile target (default: `"modules"`) (`string`)                                                                |
    | `--outDir <dir>`               | Output directory (default: `dist`) (`string`)                                                                     |
    | `--assetsDir <dir>`            | Directory under outDir to place assets in (default: `"assets"`) (`string`)                                        |
    | `--assetsInlineLimit <number>` | Static asset base64 inline threshold in bytes (default: `4096`) (`number`)                                        |
    | `--ssr [entry]`                | Build specified entry for server-side rendering (`string`)                                                        |
    | `--sourcemap [output]`         | Output source maps for build (default: `false`) (`boolean | "inline" | "hidden"`)                                 |
    | `--minify [minifier]`          | Enable/disable minification, or specify minifier to use (default: `"esbuild"`) (`boolean | "terser" | "esbuild"`) |
    | `--manifest [name]`            | Emit build manifest json (`boolean | string`)                                                                     |
    | `--ssrManifest [name]`         | Emit ssr manifest json (`boolean | string`)                                                                       |
    | `--emptyOutDir`                | Force empty outDir when it's outside of root (`boolean`)                                                          |
    | `-w, --watch`                  | Rebuilds when modules have changed on disk (`boolean`)                                                            |
    | `-c, --config <file>`          | Use specified config file (`string`)                                                                              |
    | `--base <path>`                | Public base path (default: `/`) (`string`)                                                                        |
    | `-l, --logLevel <level>`       | Info \| warn \| error \| silent (`string`)                                                                        |
    | `--clearScreen`                | Allow/disable clear screen when logging (`boolean`)                                                               |
    | `--profile`                    | Start built-in Node.js inspector (check [Performance bottlenecks](troubleshooting#performance-bottlenecks))       |
    | `-d, --debug [feat]`           | Show debug logs (`string | boolean`)                                                                              |
    | `-f, --filter <filter>`        | Filter debug logs (`string`)                                                                                      |
    | `-m, --mode <mode>`            | Set env mode (`string`)                                                                                           |
    | `-h, --help`                   | Display available CLI options                                                                                     |
- name: 'Command Line Interface: vite optimize'
  id: guide/cli#vite-optimize
  summary: Pre-bundle dependencies
  belongs_to: Command Line Interface
  description: |-
    ### `vite optimize`

    Pre-bundle dependencies.

    #### Usage

    bash

    ``` javascript
    vite optimize [root]
    ```

    #### Options

    | Options                  |                                                                   |
    |--------------------------|-------------------------------------------------------------------|
    | `--force`                | Force the optimizer to ignore the cache and re-bundle (`boolean`) |
    | `-c, --config <file>`    | Use specified config file (`string`)                              |
    | `--base <path>`          | Public base path (default: `/`) (`string`)                        |
    | `-l, --logLevel <level>` | Info \| warn \| error \| silent (`string`)                        |
    | `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)               |
    | `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                              |
    | `-f, --filter <filter>`  | Filter debug logs (`string`)                                      |
    | `-m, --mode <mode>`      | Set env mode (`string`)                                           |
    | `-h, --help`             | Display available CLI options                                     |
- name: 'Command Line Interface: vite preview'
  id: guide/cli#vite-preview
  summary: Locally preview the production build
  belongs_to: Command Line Interface
  description: "### `vite preview`\n\nLocally preview the production build. Do not use this as a production server as it's not designed for it.\n\n#### Usage\n\nbash\n\n``` javascript\nvite preview [root]\n```\n\n#### Options\n\n| Options                  |                                                      |\n|--------------------------|------------------------------------------------------|\n| `--host [host]`          | Specify hostname (`string`)                          |\n| `--port <port>`          | Specify port (`number`)                              |\n| `--strictPort`           | Exit if specified port is already in use (`boolean`) |\n| `--open [path]`          | Open browser on startup (`boolean | string`)         |\n| `--outDir <dir>`         | Output directory (default: `dist`)(`string`)         |\n| `-c, --config <file>`    | Use specified config file (`string`)                 |\n| `--base <path>`          | Public base path (default: `/`) (`string`)           |\n| `-l, --logLevel <level>` | Info \\| warn \\| error \\| silent (`string`)           |\n| `--clearScreen`          | Allow/disable clear screen when logging (`boolean`)  |\n| `-d, --debug [feat]`     | Show debug logs (`string | boolean`)                 |\n| `-f, --filter <filter>`  | Filter debug logs (`string`)                         |\n| `-m, --mode <mode>`      | Set env mode (`string`)                              |\n| `-h, --help`             | Display available CLI options                        |\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/cli](https://vitejs.dev/guide/cli)"
- name: Comparisons
  id: guide/comparisons
  summary: WMR by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it
  description: "# Comparisons\n\n## WMR\n\n[WMR](https://github.com/preactjs/wmr) by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it.\n\nWMR is mainly designed for [Preact](https://preactjs.com/) projects, and offers more integrated features such as pre-rendering. In terms of scope, it's closer to a Preact meta framework, with the same emphasis on compact size as Preact itself. If you are using Preact, WMR is likely going to offer a more fine-tuned experience.\n\n## @web/dev-server\n\n[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (previously `es-dev-server`) is a great project and Vite 1.0's Koa-based server setup was inspired by it.\n\n`@web/dev-server` is a bit lower-level in terms of scope. It does not provide official framework integrations, and requires manually setting up a Rollup configuration for the production build.\n\nOverall, Vite is a more opinionated / higher-level tool that aims to provide a more out-of-the-box workflow. That said, the `@web` umbrella project contains many other excellent tools that may benefit Vite users as well.\n\n## Snowpack\n\n[Snowpack](https://www.snowpack.dev/) was also a no-bundle native ESM dev server, very similar in scope to Vite. The project is no longer being maintained. The Snowpack team is now working on [Astro](https://astro.build/), a static site builder powered by Vite. The Astro team is now an active player in the ecosystem, and they are helping to improve Vite.\n\nAside from different implementation details, the two projects shared a lot in terms of technical advantages over traditional tooling. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Some of the main differences between the two projects are listed in [the v2 Comparisons Guide](https://v2.vitejs.dev/guide/comparisons).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/comparisons](https://vitejs.dev/guide/comparisons)"
- name: 'Comparisons: @web/dev-server'
  id: guide/comparisons#web-dev-server
  summary: '@web/dev-server (previously es-dev-server) is a great project and Vite 1.0''s Koa-based server setup was inspired by it'
  belongs_to: Comparisons
  description: |-
    ## @web/dev-server

    [@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (previously `es-dev-server`) is a great project and Vite 1.0's Koa-based server setup was inspired by it.

    `@web/dev-server` is a bit lower-level in terms of scope. It does not provide official framework integrations, and requires manually setting up a Rollup configuration for the production build.

    Overall, Vite is a more opinionated / higher-level tool that aims to provide a more out-of-the-box workflow. That said, the `@web` umbrella project contains many other excellent tools that may benefit Vite users as well.
- name: 'Comparisons: APIs'
  id: guide/comparisons
  summary: WMR by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it
  description: "# Comparisons\n\n## WMR\n\n[WMR](https://github.com/preactjs/wmr) by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it.\n\nWMR is mainly designed for [Preact](https://preactjs.com/) projects, and offers more integrated features such as pre-rendering. In terms of scope, it's closer to a Preact meta framework, with the same emphasis on compact size as Preact itself. If you are using Preact, WMR is likely going to offer a more fine-tuned experience.\n\n## @web/dev-server\n\n[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (previously `es-dev-server`) is a great project and Vite 1.0's Koa-based server setup was inspired by it.\n\n`@web/dev-server` is a bit lower-level in terms of scope. It does not provide official framework integrations, and requires manually setting up a Rollup configuration for the production build.\n\nOverall, Vite is a more opinionated / higher-level tool that aims to provide a more out-of-the-box workflow. That said, the `@web` umbrella project contains many other excellent tools that may benefit Vite users as well.\n\n## Snowpack\n\n[Snowpack](https://www.snowpack.dev/) was also a no-bundle native ESM dev server, very similar in scope to Vite. The project is no longer being maintained. The Snowpack team is now working on [Astro](https://astro.build/), a static site builder powered by Vite. The Astro team is now an active player in the ecosystem, and they are helping to improve Vite.\n\nAside from different implementation details, the two projects shared a lot in terms of technical advantages over traditional tooling. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Some of the main differences between the two projects are listed in [the v2 Comparisons Guide](https://v2.vitejs.dev/guide/comparisons).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/comparisons](https://vitejs.dev/guide/comparisons)"
- name: 'Comparisons: Guide'
  id: guide/comparisons
  summary: WMR by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it
  description: "# Comparisons\n\n## WMR\n\n[WMR](https://github.com/preactjs/wmr) by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it.\n\nWMR is mainly designed for [Preact](https://preactjs.com/) projects, and offers more integrated features such as pre-rendering. In terms of scope, it's closer to a Preact meta framework, with the same emphasis on compact size as Preact itself. If you are using Preact, WMR is likely going to offer a more fine-tuned experience.\n\n## @web/dev-server\n\n[@web/dev-server](https://modern-web.dev/docs/dev-server/overview/) (previously `es-dev-server`) is a great project and Vite 1.0's Koa-based server setup was inspired by it.\n\n`@web/dev-server` is a bit lower-level in terms of scope. It does not provide official framework integrations, and requires manually setting up a Rollup configuration for the production build.\n\nOverall, Vite is a more opinionated / higher-level tool that aims to provide a more out-of-the-box workflow. That said, the `@web` umbrella project contains many other excellent tools that may benefit Vite users as well.\n\n## Snowpack\n\n[Snowpack](https://www.snowpack.dev/) was also a no-bundle native ESM dev server, very similar in scope to Vite. The project is no longer being maintained. The Snowpack team is now working on [Astro](https://astro.build/), a static site builder powered by Vite. The Astro team is now an active player in the ecosystem, and they are helping to improve Vite.\n\nAside from different implementation details, the two projects shared a lot in terms of technical advantages over traditional tooling. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Some of the main differences between the two projects are listed in [the v2 Comparisons Guide](https://v2.vitejs.dev/guide/comparisons).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/comparisons](https://vitejs.dev/guide/comparisons)"
- name: 'Comparisons: Snowpack'
  id: guide/comparisons#snowpack
  summary: Snowpack was also a no-bundle native ESM dev server, very similar in scope to Vite
  belongs_to: Comparisons
  description: "## Snowpack\n\n[Snowpack](https://www.snowpack.dev/) was also a no-bundle native ESM dev server, very similar in scope to Vite. The project is no longer being maintained. The Snowpack team is now working on [Astro](https://astro.build/), a static site builder powered by Vite. The Astro team is now an active player in the ecosystem, and they are helping to improve Vite.\n\nAside from different implementation details, the two projects shared a lot in terms of technical advantages over traditional tooling. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now [`esinstall`](https://github.com/snowpackjs/snowpack/tree/main/esinstall)). Some of the main differences between the two projects are listed in [the v2 Comparisons Guide](https://v2.vitejs.dev/guide/comparisons).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/comparisons](https://vitejs.dev/guide/comparisons)"
- name: 'Comparisons: WMR'
  id: guide/comparisons#wmr
  summary: WMR by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it
  belongs_to: Comparisons
  description: |-
    ## WMR

    [WMR](https://github.com/preactjs/wmr) by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it.

    WMR is mainly designed for [Preact](https://preactjs.com/) projects, and offers more integrated features such as pre-rendering. In terms of scope, it's closer to a Preact meta framework, with the same emphasis on compact size as Preact itself. If you are using Preact, WMR is likely going to offer a more fine-tuned experience.
- name: Configuring Vite
  id: config/index
  summary: Note Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g
  description: "# Configuring Vite\n\nWhen running `vite` from the command line, Vite will automatically try to resolve a config file named `vite.config.js` inside [project root](../guide/index#index-html-and-project-root) (other JS and TS extensions are also supported).\n\nThe most basic config file looks like this:\n\njs\n\n``` javascript\n// vite.config.js\nexport default {\n  // config options\n}\n```\n\nNote Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. `type: \"module\"` in `package.json`. In this case, the config file is auto pre-processed before load.\n\nYou can also explicitly specify a config file to use with the `--config` CLI option (resolved relative to `cwd`):\n\nbash\n\n``` javascript\nvite --config my-config.js\n```\n\n## Config Intellisense\n\nSince Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:\n\njs\n\n``` javascript\n/** @type {import('vite').UserConfig} */\nexport default {\n  // ...\n}\n```\n\nAlternatively, you can use the `defineConfig` helper which should provide intellisense without the need for jsdoc annotations:\n\njs\n\n``` javascript\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n})\n```\n\nVite also directly supports TS config files. You can use `vite.config.ts` with the `defineConfig` helper as well.\n\n## Conditional Config\n\nIf the config needs to conditionally determine options based on the command (`serve` or `build`), the [mode](../guide/env-and-mode) being used, if it's an SSR build (`isSsrBuild`), or is previewing the build (`isPreview`), it can export a function instead:\n\njs\n\n``` javascript\nexport default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {\n  if (command === 'serve') {\n    return {\n      // dev specific config\n    }\n  } else {\n    // command === 'build'\n    return {\n      // build specific config\n    }\n  }\n})\n```\n\nIt is important to note that in Vite's API the `command` value is `serve` during dev (in the cli [`vite`](../guide/cli#vite), `vite dev`, and `vite serve` are aliases), and `build` when building for production ([`vite build`](../guide/cli#vite-build)).\n\n`isSsrBuild` and `isPreview` are additional optional flags to differentiate the kind of `build` and `serve` commands respectively. Some tools that load the Vite config may not support these flags and will pass `undefined` instead. Hence, it's recommended to use explicit comparison against `true` and `false`.\n\n## Async Config\n\nIf the config needs to call async functions, it can export an async function instead. And this async function can also be passed through `defineConfig` for improved intellisense support:\n\njs\n\n``` javascript\nexport default defineConfig(async ({ command, mode }) => {\n  const data = await asyncFunction()\n  return {\n    // vite config\n  }\n})\n```\n\n## Using Environment Variables in Config\n\nEnvironmental Variables can be obtained from `process.env` as usual.\n\nNote that Vite doesn't load `.env` files by default as the files to load can only be determined after evaluating the Vite config, for example, the `root` and `envDir` options affect the loading behaviour. However, you can use the exported `loadEnv` helper to load the specific `.env` file if needed.\n\njs\n\n``` javascript\nimport { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ command, mode }) => {\n  // Load env file based on `mode` in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the `VITE_` prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      __APP_ENV__: JSON.stringify(env.APP_ENV),\n    },\n  }\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/](https://vitejs.dev/config/)"
- name: 'Configuring Vite: Async Config'
  id: config/index#async-config
  summary: If the config needs to call async functions, it can export an async function instead
  belongs_to: Configuring Vite
  description: |-
    ## Async Config

    If the config needs to call async functions, it can export an async function instead. And this async function can also be passed through `defineConfig` for improved intellisense support:

    js

    ``` javascript
    export default defineConfig(async ({ command, mode }) => {
      const data = await asyncFunction()
      return {
        // vite config
      }
    })
    ```
- name: 'Configuring Vite: Conditional Config'
  id: config/index#conditional-config
  summary: isSsrBuild and isPreview are additional optional flags to differentiate the kind of build and serve commands respectively
  belongs_to: Configuring Vite
  description: |-
    ## Conditional Config

    If the config needs to conditionally determine options based on the command (`serve` or `build`), the [mode](../guide/env-and-mode) being used, if it's an SSR build (`isSsrBuild`), or is previewing the build (`isPreview`), it can export a function instead:

    js

    ``` javascript
    export default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {
      if (command === 'serve') {
        return {
          // dev specific config
        }
      } else {
        // command === 'build'
        return {
          // build specific config
        }
      }
    })
    ```

    It is important to note that in Vite's API the `command` value is `serve` during dev (in the cli [`vite`](../guide/cli#vite), `vite dev`, and `vite serve` are aliases), and `build` when building for production ([`vite build`](../guide/cli#vite-build)).

    `isSsrBuild` and `isPreview` are additional optional flags to differentiate the kind of `build` and `serve` commands respectively. Some tools that load the Vite config may not support these flags and will pass `undefined` instead. Hence, it's recommended to use explicit comparison against `true` and `false`.
- name: 'Configuring Vite: Config'
  id: config/index
  summary: Note Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g
  description: "# Configuring Vite\n\nWhen running `vite` from the command line, Vite will automatically try to resolve a config file named `vite.config.js` inside [project root](../guide/index#index-html-and-project-root) (other JS and TS extensions are also supported).\n\nThe most basic config file looks like this:\n\njs\n\n``` javascript\n// vite.config.js\nexport default {\n  // config options\n}\n```\n\nNote Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. `type: \"module\"` in `package.json`. In this case, the config file is auto pre-processed before load.\n\nYou can also explicitly specify a config file to use with the `--config` CLI option (resolved relative to `cwd`):\n\nbash\n\n``` javascript\nvite --config my-config.js\n```\n\n## Config Intellisense\n\nSince Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:\n\njs\n\n``` javascript\n/** @type {import('vite').UserConfig} */\nexport default {\n  // ...\n}\n```\n\nAlternatively, you can use the `defineConfig` helper which should provide intellisense without the need for jsdoc annotations:\n\njs\n\n``` javascript\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n})\n```\n\nVite also directly supports TS config files. You can use `vite.config.ts` with the `defineConfig` helper as well.\n\n## Conditional Config\n\nIf the config needs to conditionally determine options based on the command (`serve` or `build`), the [mode](../guide/env-and-mode) being used, if it's an SSR build (`isSsrBuild`), or is previewing the build (`isPreview`), it can export a function instead:\n\njs\n\n``` javascript\nexport default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {\n  if (command === 'serve') {\n    return {\n      // dev specific config\n    }\n  } else {\n    // command === 'build'\n    return {\n      // build specific config\n    }\n  }\n})\n```\n\nIt is important to note that in Vite's API the `command` value is `serve` during dev (in the cli [`vite`](../guide/cli#vite), `vite dev`, and `vite serve` are aliases), and `build` when building for production ([`vite build`](../guide/cli#vite-build)).\n\n`isSsrBuild` and `isPreview` are additional optional flags to differentiate the kind of `build` and `serve` commands respectively. Some tools that load the Vite config may not support these flags and will pass `undefined` instead. Hence, it's recommended to use explicit comparison against `true` and `false`.\n\n## Async Config\n\nIf the config needs to call async functions, it can export an async function instead. And this async function can also be passed through `defineConfig` for improved intellisense support:\n\njs\n\n``` javascript\nexport default defineConfig(async ({ command, mode }) => {\n  const data = await asyncFunction()\n  return {\n    // vite config\n  }\n})\n```\n\n## Using Environment Variables in Config\n\nEnvironmental Variables can be obtained from `process.env` as usual.\n\nNote that Vite doesn't load `.env` files by default as the files to load can only be determined after evaluating the Vite config, for example, the `root` and `envDir` options affect the loading behaviour. However, you can use the exported `loadEnv` helper to load the specific `.env` file if needed.\n\njs\n\n``` javascript\nimport { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ command, mode }) => {\n  // Load env file based on `mode` in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the `VITE_` prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      __APP_ENV__: JSON.stringify(env.APP_ENV),\n    },\n  }\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/](https://vitejs.dev/config/)"
- name: 'Configuring Vite: Config Intellisense'
  id: config/index#config-intellisense
  summary: Vite also directly supports TS config files
  belongs_to: Configuring Vite
  description: |-
    ## Config Intellisense

    Since Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:

    js

    ``` javascript
    /** @type {import('vite').UserConfig} */
    export default {
      // ...
    }
    ```

    Alternatively, you can use the `defineConfig` helper which should provide intellisense without the need for jsdoc annotations:

    js

    ``` javascript
    import { defineConfig } from 'vite'

    export default defineConfig({
      // ...
    })
    ```

    Vite also directly supports TS config files. You can use `vite.config.ts` with the `defineConfig` helper as well.
- name: 'Configuring Vite: Using Environment Variables in Config'
  id: config/index#using-environment-variables-in-config
  summary: Environmental Variables can be obtained from process.env as usual
  belongs_to: Configuring Vite
  description: "## Using Environment Variables in Config\n\nEnvironmental Variables can be obtained from `process.env` as usual.\n\nNote that Vite doesn't load `.env` files by default as the files to load can only be determined after evaluating the Vite config, for example, the `root` and `envDir` options affect the loading behaviour. However, you can use the exported `loadEnv` helper to load the specific `.env` file if needed.\n\njs\n\n``` javascript\nimport { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ command, mode }) => {\n  // Load env file based on `mode` in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the `VITE_` prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      __APP_ENV__: JSON.stringify(env.APP_ENV),\n    },\n  }\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/](https://vitejs.dev/config/)"
- name: Dep Optimization Options
  id: config/dep-optimization-options
  summary: By default, Vite will crawl all your .html files to detect dependencies that need to be pre-bundled (ignoring node_modules, build.outDir, __tests__ and coverage). If build.rollupOptions.input is specified, Vite will crawl those entry points instead
  description: "# Dep Optimization Options\n\n- **Related:** [Dependency Pre-Bundling](../guide/dep-pre-bundling)\n\n## optimizeDeps.entries\n\n- **Type:** `string | string[]`\n\nBy default, Vite will crawl all your `.html` files to detect dependencies that need to be pre-bundled (ignoring `node_modules`, `build.outDir`, `__tests__` and `coverage`). If `build.rollupOptions.input` is specified, Vite will crawl those entry points instead.\n\nIf neither of these fit your needs, you can specify custom entries using this option - the value should be a [fast-glob pattern](https://github.com/mrmlnc/fast-glob#basic-syntax) or array of patterns that are relative from Vite project root. This will overwrite default entries inference. Only `node_modules` and `build.outDir` folders will be ignored by default when `optimizeDeps.entries` is explicitly defined. If other folders need to be ignored, you can use an ignore pattern as part of the entries list, marked with an initial `!`. If you don't want to ignore `node_modules` and `build.outDir`, you can specify using literal string paths (without fast-glob patterns) instead.\n\n## optimizeDeps.exclude\n\n- **Type:** `string[]`\n\nDependencies to exclude from pre-bundling.\n\n**CommonJS**\n\nCommonJS dependencies should not be excluded from optimization. If an ESM dependency is excluded from optimization, but has a nested CommonJS dependency, the CommonJS dependency should be added to `optimizeDeps.include`. Example:\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['esm-dep > cjs-dep'],\n  },\n})\n```\n\n## optimizeDeps.include\n\n- **Type:** `string[]`\n\nBy default, linked packages not inside `node_modules` are not pre-bundled. Use this option to force a linked package to be pre-bundled.\n\n**Experimental:** If you're using a library with many deep imports, you can also specify a trailing glob pattern to pre-bundle all deep imports at once. This will avoid constantly pre-bundling whenever a new deep import is used. [Give Feedback](https://github.com/vitejs/vite/discussions/15833). For example:\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['my-lib/components/**/*.vue'],\n  },\n})\n```\n\n## optimizeDeps.esbuildOptions\n\n- **Type:** [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)`<`[`EsbuildBuildOptions`](https://esbuild.github.io/api/#simple-options)`, | 'bundle' | 'entryPoints' | 'external' | 'write' | 'watch' | 'outdir' | 'outfile' | 'outbase' | 'outExtension' | 'metafile'>`\n\nOptions to pass to esbuild during the dep scanning and optimization.\n\nCertain options are omitted since changing them would not be compatible with Vite's dep optimization.\n\n- `external` is also omitted, use Vite's `optimizeDeps.exclude` option\n- `plugins` are merged with Vite's dep plugin\n\n## optimizeDeps.force\n\n- **Type:** `boolean`\n\nSet to `true` to force dependency pre-bundling, ignoring previously cached optimized dependencies.\n\n## optimizeDeps.holdUntilCrawlEnd\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15834)\n- **Type:** `boolean`\n- **Default:** `true`\n\nWhen enabled, it will hold the first optimized deps results until all static imports are crawled on cold start. This avoids the need for full-page reloads when new dependencies are discovered and they trigger the generation of new common chunks. If all dependencies are found by the scanner plus the explicitely defined ones in `include`, it is better to disable this option to let the browser process more requests in parallel.\n\n## optimizeDeps.disabled\n\n- **Deprecated**\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13839)\n- **Type:** `boolean | 'build' | 'dev'`\n- **Default:** `'build'`\n\nThis option is deprecated. As of Vite 5.1, pre-bundling of dependencies during build have been removed. Setting `optimizeDeps.disabled` to `true` or `'dev'` disables the optimizer, and configured to `false` or `'build'` leaves the optimizer during dev enabled.\n\nTo disable the optimizer completely, use `optimizeDeps.noDiscovery: true` to disallow automatic discovery of dependencies and leave `optimizeDeps.include` undefined or empty.\n\n**WARNING**\n\nOptimizing dependencies during build time was an **experimental** feature. Projects trying out this strategy also removed `@rollup/plugin-commonjs` using `build.commonjsOptions: { include: [] }`. If you did so, a warning will guide you to re-enable it to support CJS only packages while bundling.\n\n## optimizeDeps.needsInterop\n\n- **Experimental**\n- **Type:** `string[]`\n\nForces ESM interop when importing these dependencies. Vite is able to properly detect when a dependency needs interop, so this option isn't generally needed. However, different combinations of dependencies could cause some of them to be prebundled differently. Adding these packages to `needsInterop` can speed up cold start by avoiding full-page reloads. You'll receive a warning if this is the case for one of your dependencies, suggesting to add the package name to this array in your config.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/dep-optimization-options](https://vitejs.dev/config/dep-optimization-options)"
- name: 'Dep Optimization Options: Config'
  id: config/dep-optimization-options
  summary: By default, Vite will crawl all your .html files to detect dependencies that need to be pre-bundled (ignoring node_modules, build.outDir, __tests__ and coverage). If build.rollupOptions.input is specified, Vite will crawl those entry points instead
  description: "# Dep Optimization Options\n\n- **Related:** [Dependency Pre-Bundling](../guide/dep-pre-bundling)\n\n## optimizeDeps.entries\n\n- **Type:** `string | string[]`\n\nBy default, Vite will crawl all your `.html` files to detect dependencies that need to be pre-bundled (ignoring `node_modules`, `build.outDir`, `__tests__` and `coverage`). If `build.rollupOptions.input` is specified, Vite will crawl those entry points instead.\n\nIf neither of these fit your needs, you can specify custom entries using this option - the value should be a [fast-glob pattern](https://github.com/mrmlnc/fast-glob#basic-syntax) or array of patterns that are relative from Vite project root. This will overwrite default entries inference. Only `node_modules` and `build.outDir` folders will be ignored by default when `optimizeDeps.entries` is explicitly defined. If other folders need to be ignored, you can use an ignore pattern as part of the entries list, marked with an initial `!`. If you don't want to ignore `node_modules` and `build.outDir`, you can specify using literal string paths (without fast-glob patterns) instead.\n\n## optimizeDeps.exclude\n\n- **Type:** `string[]`\n\nDependencies to exclude from pre-bundling.\n\n**CommonJS**\n\nCommonJS dependencies should not be excluded from optimization. If an ESM dependency is excluded from optimization, but has a nested CommonJS dependency, the CommonJS dependency should be added to `optimizeDeps.include`. Example:\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['esm-dep > cjs-dep'],\n  },\n})\n```\n\n## optimizeDeps.include\n\n- **Type:** `string[]`\n\nBy default, linked packages not inside `node_modules` are not pre-bundled. Use this option to force a linked package to be pre-bundled.\n\n**Experimental:** If you're using a library with many deep imports, you can also specify a trailing glob pattern to pre-bundle all deep imports at once. This will avoid constantly pre-bundling whenever a new deep import is used. [Give Feedback](https://github.com/vitejs/vite/discussions/15833). For example:\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['my-lib/components/**/*.vue'],\n  },\n})\n```\n\n## optimizeDeps.esbuildOptions\n\n- **Type:** [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys)`<`[`EsbuildBuildOptions`](https://esbuild.github.io/api/#simple-options)`, | 'bundle' | 'entryPoints' | 'external' | 'write' | 'watch' | 'outdir' | 'outfile' | 'outbase' | 'outExtension' | 'metafile'>`\n\nOptions to pass to esbuild during the dep scanning and optimization.\n\nCertain options are omitted since changing them would not be compatible with Vite's dep optimization.\n\n- `external` is also omitted, use Vite's `optimizeDeps.exclude` option\n- `plugins` are merged with Vite's dep plugin\n\n## optimizeDeps.force\n\n- **Type:** `boolean`\n\nSet to `true` to force dependency pre-bundling, ignoring previously cached optimized dependencies.\n\n## optimizeDeps.holdUntilCrawlEnd\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15834)\n- **Type:** `boolean`\n- **Default:** `true`\n\nWhen enabled, it will hold the first optimized deps results until all static imports are crawled on cold start. This avoids the need for full-page reloads when new dependencies are discovered and they trigger the generation of new common chunks. If all dependencies are found by the scanner plus the explicitely defined ones in `include`, it is better to disable this option to let the browser process more requests in parallel.\n\n## optimizeDeps.disabled\n\n- **Deprecated**\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13839)\n- **Type:** `boolean | 'build' | 'dev'`\n- **Default:** `'build'`\n\nThis option is deprecated. As of Vite 5.1, pre-bundling of dependencies during build have been removed. Setting `optimizeDeps.disabled` to `true` or `'dev'` disables the optimizer, and configured to `false` or `'build'` leaves the optimizer during dev enabled.\n\nTo disable the optimizer completely, use `optimizeDeps.noDiscovery: true` to disallow automatic discovery of dependencies and leave `optimizeDeps.include` undefined or empty.\n\n**WARNING**\n\nOptimizing dependencies during build time was an **experimental** feature. Projects trying out this strategy also removed `@rollup/plugin-commonjs` using `build.commonjsOptions: { include: [] }`. If you did so, a warning will guide you to re-enable it to support CJS only packages while bundling.\n\n## optimizeDeps.needsInterop\n\n- **Experimental**\n- **Type:** `string[]`\n\nForces ESM interop when importing these dependencies. Vite is able to properly detect when a dependency needs interop, so this option isn't generally needed. However, different combinations of dependencies could cause some of them to be prebundled differently. Adding these packages to `needsInterop` can speed up cold start by avoiding full-page reloads. You'll receive a warning if this is the case for one of your dependencies, suggesting to add the package name to this array in your config.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/dep-optimization-options](https://vitejs.dev/config/dep-optimization-options)"
- name: 'Dep Optimization Options: optimizeDeps.disabled'
  id: config/dep-optimization-options#optimizedeps-disabled
  summary: This option is deprecated
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.disabled

    - **Deprecated**
    - **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13839)
    - **Type:** `boolean | 'build' | 'dev'`
    - **Default:** `'build'`

    This option is deprecated. As of Vite 5.1, pre-bundling of dependencies during build have been removed. Setting `optimizeDeps.disabled` to `true` or `'dev'` disables the optimizer, and configured to `false` or `'build'` leaves the optimizer during dev enabled.

    To disable the optimizer completely, use `optimizeDeps.noDiscovery: true` to disallow automatic discovery of dependencies and leave `optimizeDeps.include` undefined or empty.

    **WARNING**

    Optimizing dependencies during build time was an **experimental** feature. Projects trying out this strategy also removed `@rollup/plugin-commonjs` using `build.commonjsOptions: { include: [] }`. If you did so, a warning will guide you to re-enable it to support CJS only packages while bundling.
- name: 'Dep Optimization Options: optimizeDeps.entries'
  id: config/dep-optimization-options#optimizedeps-entries
  summary: By default, Vite will crawl all your .html files to detect dependencies that need to be pre-bundled (ignoring node_modules, build.outDir, __tests__ and coverage). If build.rollupOptions.input is specified, Vite will crawl those entry points instead
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.entries

    - **Type:** `string | string[]`

    By default, Vite will crawl all your `.html` files to detect dependencies that need to be pre-bundled (ignoring `node_modules`, `build.outDir`, `__tests__` and `coverage`). If `build.rollupOptions.input` is specified, Vite will crawl those entry points instead.

    If neither of these fit your needs, you can specify custom entries using this option - the value should be a [fast-glob pattern](https://github.com/mrmlnc/fast-glob#basic-syntax) or array of patterns that are relative from Vite project root. This will overwrite default entries inference. Only `node_modules` and `build.outDir` folders will be ignored by default when `optimizeDeps.entries` is explicitly defined. If other folders need to be ignored, you can use an ignore pattern as part of the entries list, marked with an initial `!`. If you don't want to ignore `node_modules` and `build.outDir`, you can specify using literal string paths (without fast-glob patterns) instead.
- name: 'Dep Optimization Options: optimizeDeps.esbuildOptions'
  id: config/dep-optimization-options#optimizedeps-esbuildoptions
  summary: Options to pass to esbuild during the dep scanning and optimization
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.esbuildOptions

    - **Type:** [`Omit`](https://www.typescriptlang.org/docs/handbook/utility-types.html#omittype-keys) `<` [`EsbuildBuildOptions`](https://esbuild.github.io/api/#simple-options) `, | 'bundle' | 'entryPoints' | 'external' | 'write' | 'watch' | 'outdir' | 'outfile' | 'outbase' | 'outExtension' | 'metafile'>`

    Options to pass to esbuild during the dep scanning and optimization.

    Certain options are omitted since changing them would not be compatible with Vite's dep optimization.

    - `external` is also omitted, use Vite's `optimizeDeps.exclude` option
    - `plugins` are merged with Vite's dep plugin

    &nbsp;
- name: 'Dep Optimization Options: optimizeDeps.exclude'
  id: config/dep-optimization-options#optimizedeps-exclude
  summary: Dependencies to exclude from pre-bundling
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.exclude

    - **Type:** `string[]`

    Dependencies to exclude from pre-bundling.

    **CommonJS**

    CommonJS dependencies should not be excluded from optimization. If an ESM dependency is excluded from optimization, but has a nested CommonJS dependency, the CommonJS dependency should be added to `optimizeDeps.include`. Example:

    js

    ``` javascript
    export default defineConfig({
      optimizeDeps: {
        include: ['esm-dep > cjs-dep'],
      },
    })
    ```
- name: 'Dep Optimization Options: optimizeDeps.force'
  id: config/dep-optimization-options#optimizedeps-force
  summary: Set to true to force dependency pre-bundling, ignoring previously cached optimized dependencies
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.force

    - **Type:** `boolean`

    Set to `true` to force dependency pre-bundling, ignoring previously cached optimized dependencies.
- name: 'Dep Optimization Options: optimizeDeps.holdUntilCrawlEnd'
  id: config/dep-optimization-options#optimizedeps-holduntilcrawlend
  summary: When enabled, it will hold the first optimized deps results until all static imports are crawled on cold start
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.holdUntilCrawlEnd

    - **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15834)
    - **Type:** `boolean`
    - **Default:** `true`

    When enabled, it will hold the first optimized deps results until all static imports are crawled on cold start. This avoids the need for full-page reloads when new dependencies are discovered and they trigger the generation of new common chunks. If all dependencies are found by the scanner plus the explicitely defined ones in `include`, it is better to disable this option to let the browser process more requests in parallel.
- name: 'Dep Optimization Options: optimizeDeps.include'
  id: config/dep-optimization-options#optimizedeps-include
  summary: By default, linked packages not inside node_modules are not pre-bundled
  belongs_to: Dep Optimization Options
  description: |-
    ## optimizeDeps.include

    - **Type:** `string[]`

    By default, linked packages not inside `node_modules` are not pre-bundled. Use this option to force a linked package to be pre-bundled.

    **Experimental:** If you're using a library with many deep imports, you can also specify a trailing glob pattern to pre-bundle all deep imports at once. This will avoid constantly pre-bundling whenever a new deep import is used. [Give Feedback](https://github.com/vitejs/vite/discussions/15833). For example:

    js

    ``` javascript
    export default defineConfig({
      optimizeDeps: {
        include: ['my-lib/components/**/*.vue'],
      },
    })
    ```
- name: 'Dep Optimization Options: optimizeDeps.needsInterop'
  id: config/dep-optimization-options#optimizedeps-needsinterop
  summary: Forces ESM interop when importing these dependencies
  belongs_to: Dep Optimization Options
  description: "## optimizeDeps.needsInterop\n\n- **Experimental**\n- **Type:** `string[]`\n\nForces ESM interop when importing these dependencies. Vite is able to properly detect when a dependency needs interop, so this option isn't generally needed. However, different combinations of dependencies could cause some of them to be prebundled differently. Adding these packages to `needsInterop` can speed up cold start by avoiding full-page reloads. You'll receive a warning if this is the case for one of your dependencies, suggesting to add the package name to this array in your config.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/dep-optimization-options](https://vitejs.dev/config/dep-optimization-options)"
- name: Dependency Pre-Bundling
  id: guide/dep-pre-bundling
  summary: When you run vite for the first time, Vite prebundles your project dependencies before loading your site locally
  description: "# Dependency Pre-Bundling\n\nWhen you run `vite` for the first time, Vite prebundles your project dependencies before loading your site locally. It is done automatically and transparently by default.\n\n## The Why\n\nThis is Vite performing what we call \"dependency pre-bundling\". This process serves two purposes:\n\n1.  **CommonJS and UMD compatibility:** During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.\n\n    When converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):\n\n    js\n    ``` javascript\n    // works as expected\n    import React, { useState } from 'react'\n    ```\n\n2.  **Performance:** Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.\n\n    Some packages ship their ES modules builds as many separate files importing one another. For example, [`lodash-es` has over 600 internal modules](https://unpkg.com/browse/lodash-es/)! When we do `import { debounce } from 'lodash-es'`, the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.\n\n    By pre-bundling `lodash-es` into a single module, we now only need one HTTP request instead!\n\n**NOTE**\n\nDependency pre-bundling only applies in development mode, and uses `esbuild` to convert dependencies to ESM. In production builds, `@rollup/plugin-commonjs` is used instead.\n\n## Automatic Dependency Discovery\n\nIf an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. \"bare imports\" that expect to be resolved from `node_modules`) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with `esbuild` so it's typically very fast.\n\nAfter the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.\n\n## Monorepos and Linked Dependencies\n\nIn a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from `node_modules` and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.\n\nHowever, this requires the linked dep to be exported as ESM. If not, you can add the dependency to [`optimizeDeps.include`](../config/dep-optimization-options#optimizedeps-include) and [`build.commonjsOptions.include`](../config/build-options#build-commonjsoptions) in your config.\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['linked-dep'],\n  },\n  build: {\n    commonjsOptions: {\n      include: [/linked-dep/, /node_modules/],\n    },\n  },\n})\n```\n\nWhen making changes to the linked dep, restart the dev server with the `--force` command line option for the changes to take effect.\n\n## Customizing the Behavior\n\nThe default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the [`optimizeDeps` config options](../config/dep-optimization-options).\n\nA typical use case for `optimizeDeps.include` or `optimizeDeps.exclude` is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.\n\nBoth `include` and `exclude` can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.\n\nYou can further customize esbuild too with the [`optimizeDeps.esbuildOptions` option](../config/dep-optimization-options#optimizedeps-esbuildoptions). For example, adding an esbuild plugin to handle special files in dependencies or changing the [build `target`](https://esbuild.github.io/api/#target).\n\n## Caching\n\n### File System Cache\n\nVite caches the pre-bundled dependencies in `node_modules/.vite`. It determines whether it needs to re-run the pre-bundling step based on a few sources:\n\n- Package manager lockfile content, e.g. `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml` or `bun.lockb`.\n- Patches folder modification time.\n- Relevant fields in your `vite.config.js`, if present.\n- `NODE_ENV` value.\n\nThe pre-bundling step will only need to be re-run when one of the above has changed.\n\nIf for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the `--force` command line option, or manually delete the `node_modules/.vite` cache directory.\n\n### Browser Cache\n\nResolved dependency requests are strongly cached with HTTP headers `max-age=31536000,immutable` to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:\n\n1.  Temporarily disable cache via the Network tab of your browser devtools;\n2.  Restart Vite dev server with the `--force` flag to re-bundle the deps;\n3.  Reload the page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/dep-pre-bundling](https://vitejs.dev/guide/dep-pre-bundling)"
- name: 'Dependency Pre-Bundling: APIs'
  id: guide/dep-pre-bundling
  summary: When you run vite for the first time, Vite prebundles your project dependencies before loading your site locally
  description: "# Dependency Pre-Bundling\n\nWhen you run `vite` for the first time, Vite prebundles your project dependencies before loading your site locally. It is done automatically and transparently by default.\n\n## The Why\n\nThis is Vite performing what we call \"dependency pre-bundling\". This process serves two purposes:\n\n1.  **CommonJS and UMD compatibility:** During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.\n\n    When converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):\n\n    js\n    ``` javascript\n    // works as expected\n    import React, { useState } from 'react'\n    ```\n\n2.  **Performance:** Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.\n\n    Some packages ship their ES modules builds as many separate files importing one another. For example, [`lodash-es` has over 600 internal modules](https://unpkg.com/browse/lodash-es/)! When we do `import { debounce } from 'lodash-es'`, the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.\n\n    By pre-bundling `lodash-es` into a single module, we now only need one HTTP request instead!\n\n**NOTE**\n\nDependency pre-bundling only applies in development mode, and uses `esbuild` to convert dependencies to ESM. In production builds, `@rollup/plugin-commonjs` is used instead.\n\n## Automatic Dependency Discovery\n\nIf an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. \"bare imports\" that expect to be resolved from `node_modules`) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with `esbuild` so it's typically very fast.\n\nAfter the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.\n\n## Monorepos and Linked Dependencies\n\nIn a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from `node_modules` and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.\n\nHowever, this requires the linked dep to be exported as ESM. If not, you can add the dependency to [`optimizeDeps.include`](../config/dep-optimization-options#optimizedeps-include) and [`build.commonjsOptions.include`](../config/build-options#build-commonjsoptions) in your config.\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['linked-dep'],\n  },\n  build: {\n    commonjsOptions: {\n      include: [/linked-dep/, /node_modules/],\n    },\n  },\n})\n```\n\nWhen making changes to the linked dep, restart the dev server with the `--force` command line option for the changes to take effect.\n\n## Customizing the Behavior\n\nThe default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the [`optimizeDeps` config options](../config/dep-optimization-options).\n\nA typical use case for `optimizeDeps.include` or `optimizeDeps.exclude` is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.\n\nBoth `include` and `exclude` can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.\n\nYou can further customize esbuild too with the [`optimizeDeps.esbuildOptions` option](../config/dep-optimization-options#optimizedeps-esbuildoptions). For example, adding an esbuild plugin to handle special files in dependencies or changing the [build `target`](https://esbuild.github.io/api/#target).\n\n## Caching\n\n### File System Cache\n\nVite caches the pre-bundled dependencies in `node_modules/.vite`. It determines whether it needs to re-run the pre-bundling step based on a few sources:\n\n- Package manager lockfile content, e.g. `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml` or `bun.lockb`.\n- Patches folder modification time.\n- Relevant fields in your `vite.config.js`, if present.\n- `NODE_ENV` value.\n\nThe pre-bundling step will only need to be re-run when one of the above has changed.\n\nIf for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the `--force` command line option, or manually delete the `node_modules/.vite` cache directory.\n\n### Browser Cache\n\nResolved dependency requests are strongly cached with HTTP headers `max-age=31536000,immutable` to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:\n\n1.  Temporarily disable cache via the Network tab of your browser devtools;\n2.  Restart Vite dev server with the `--force` flag to re-bundle the deps;\n3.  Reload the page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/dep-pre-bundling](https://vitejs.dev/guide/dep-pre-bundling)"
- name: 'Dependency Pre-Bundling: Automatic Dependency Discovery'
  id: guide/dep-pre-bundling#automatic-dependency-discovery
  summary: If an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e
  belongs_to: Dependency Pre-Bundling
  description: |-
    ## Automatic Dependency Discovery

    If an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. "bare imports" that expect to be resolved from `node_modules`) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with `esbuild` so it's typically very fast.

    After the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.
- name: 'Dependency Pre-Bundling: Browser Cache'
  id: guide/dep-pre-bundling#browser-cache
  summary: Resolved dependency requests are strongly cached with HTTP headers max-age=31536000,immutable to improve page reload performance during dev
  belongs_to: Dependency Pre-Bundling
  description: "### Browser Cache\n\nResolved dependency requests are strongly cached with HTTP headers `max-age=31536000,immutable` to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:\n\n1.  Temporarily disable cache via the Network tab of your browser devtools;\n2.  Restart Vite dev server with the `--force` flag to re-bundle the deps;\n3.  Reload the page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/dep-pre-bundling](https://vitejs.dev/guide/dep-pre-bundling)"
- name: 'Dependency Pre-Bundling: Caching'
  id: guide/dep-pre-bundling#caching
  summary: null
  belongs_to: Dependency Pre-Bundling
  description: '## Caching'
- name: 'Dependency Pre-Bundling: Customizing the Behavior'
  id: guide/dep-pre-bundling#customizing-the-behavior
  summary: The default dependency discovery heuristics may not always be desirable
  belongs_to: Dependency Pre-Bundling
  description: |-
    ## Customizing the Behavior

    The default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the [`optimizeDeps` config options](../config/dep-optimization-options).

    A typical use case for `optimizeDeps.include` or `optimizeDeps.exclude` is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.

    Both `include` and `exclude` can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.

    You can further customize esbuild too with the [`optimizeDeps.esbuildOptions` option](../config/dep-optimization-options#optimizedeps-esbuildoptions). For example, adding an esbuild plugin to handle special files in dependencies or changing the [build `target`](https://esbuild.github.io/api/#target).
- name: 'Dependency Pre-Bundling: File System Cache'
  id: guide/dep-pre-bundling#file-system-cache
  summary: Vite caches the pre-bundled dependencies in node_modules/.vite
  belongs_to: Dependency Pre-Bundling
  description: |-
    ### File System Cache

    Vite caches the pre-bundled dependencies in `node_modules/.vite`. It determines whether it needs to re-run the pre-bundling step based on a few sources:

    - Package manager lockfile content, e.g. `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml` or `bun.lockb`.
    - Patches folder modification time.
    - Relevant fields in your `vite.config.js`, if present.
    - `NODE_ENV` value.

    The pre-bundling step will only need to be re-run when one of the above has changed.

    If for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the `--force` command line option, or manually delete the `node_modules/.vite` cache directory.
- name: 'Dependency Pre-Bundling: Guide'
  id: guide/dep-pre-bundling
  summary: When you run vite for the first time, Vite prebundles your project dependencies before loading your site locally
  description: "# Dependency Pre-Bundling\n\nWhen you run `vite` for the first time, Vite prebundles your project dependencies before loading your site locally. It is done automatically and transparently by default.\n\n## The Why\n\nThis is Vite performing what we call \"dependency pre-bundling\". This process serves two purposes:\n\n1.  **CommonJS and UMD compatibility:** During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.\n\n    When converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):\n\n    js\n    ``` javascript\n    // works as expected\n    import React, { useState } from 'react'\n    ```\n\n2.  **Performance:** Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.\n\n    Some packages ship their ES modules builds as many separate files importing one another. For example, [`lodash-es` has over 600 internal modules](https://unpkg.com/browse/lodash-es/)! When we do `import { debounce } from 'lodash-es'`, the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.\n\n    By pre-bundling `lodash-es` into a single module, we now only need one HTTP request instead!\n\n**NOTE**\n\nDependency pre-bundling only applies in development mode, and uses `esbuild` to convert dependencies to ESM. In production builds, `@rollup/plugin-commonjs` is used instead.\n\n## Automatic Dependency Discovery\n\nIf an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. \"bare imports\" that expect to be resolved from `node_modules`) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with `esbuild` so it's typically very fast.\n\nAfter the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.\n\n## Monorepos and Linked Dependencies\n\nIn a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from `node_modules` and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.\n\nHowever, this requires the linked dep to be exported as ESM. If not, you can add the dependency to [`optimizeDeps.include`](../config/dep-optimization-options#optimizedeps-include) and [`build.commonjsOptions.include`](../config/build-options#build-commonjsoptions) in your config.\n\njs\n\n``` javascript\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['linked-dep'],\n  },\n  build: {\n    commonjsOptions: {\n      include: [/linked-dep/, /node_modules/],\n    },\n  },\n})\n```\n\nWhen making changes to the linked dep, restart the dev server with the `--force` command line option for the changes to take effect.\n\n## Customizing the Behavior\n\nThe default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the [`optimizeDeps` config options](../config/dep-optimization-options).\n\nA typical use case for `optimizeDeps.include` or `optimizeDeps.exclude` is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.\n\nBoth `include` and `exclude` can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.\n\nYou can further customize esbuild too with the [`optimizeDeps.esbuildOptions` option](../config/dep-optimization-options#optimizedeps-esbuildoptions). For example, adding an esbuild plugin to handle special files in dependencies or changing the [build `target`](https://esbuild.github.io/api/#target).\n\n## Caching\n\n### File System Cache\n\nVite caches the pre-bundled dependencies in `node_modules/.vite`. It determines whether it needs to re-run the pre-bundling step based on a few sources:\n\n- Package manager lockfile content, e.g. `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml` or `bun.lockb`.\n- Patches folder modification time.\n- Relevant fields in your `vite.config.js`, if present.\n- `NODE_ENV` value.\n\nThe pre-bundling step will only need to be re-run when one of the above has changed.\n\nIf for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the `--force` command line option, or manually delete the `node_modules/.vite` cache directory.\n\n### Browser Cache\n\nResolved dependency requests are strongly cached with HTTP headers `max-age=31536000,immutable` to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:\n\n1.  Temporarily disable cache via the Network tab of your browser devtools;\n2.  Restart Vite dev server with the `--force` flag to re-bundle the deps;\n3.  Reload the page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/dep-pre-bundling](https://vitejs.dev/guide/dep-pre-bundling)"
- name: 'Dependency Pre-Bundling: Monorepos and Linked Dependencies'
  id: guide/dep-pre-bundling#monorepos-and-linked-dependencies
  summary: In a monorepo setup, a dependency may be a linked package from the same repo
  belongs_to: Dependency Pre-Bundling
  description: |-
    ## Monorepos and Linked Dependencies

    In a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from `node_modules` and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.

    However, this requires the linked dep to be exported as ESM. If not, you can add the dependency to [`optimizeDeps.include`](../config/dep-optimization-options#optimizedeps-include) and [`build.commonjsOptions.include`](../config/build-options#build-commonjsoptions) in your config.

    js

    ``` javascript
    export default defineConfig({
      optimizeDeps: {
        include: ['linked-dep'],
      },
      build: {
        commonjsOptions: {
          include: [/linked-dep/, /node_modules/],
        },
      },
    })
    ```

    When making changes to the linked dep, restart the dev server with the `--force` command line option for the changes to take effect.
- name: 'Dependency Pre-Bundling: The Why'
  id: guide/dep-pre-bundling#the-why
  summary: 'CommonJS and UMD compatibility: During development, Vite''s dev serves all code as native ESM'
  belongs_to: Dependency Pre-Bundling
  description: |-
    ## The Why

    This is Vite performing what we call "dependency pre-bundling". This process serves two purposes:

    1.  **CommonJS and UMD compatibility:** During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.

        When converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):

        js
        ``` javascript
        // works as expected
        import React, { useState } from 'react'
        ```

    2.  **Performance:** Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.

        Some packages ship their ES modules builds as many separate files importing one another. For example, [`lodash-es` has over 600 internal modules](https://unpkg.com/browse/lodash-es/)! When we do `import { debounce } from 'lodash-es'`, the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.

        By pre-bundling `lodash-es` into a single module, we now only need one HTTP request instead!

    **NOTE**

    Dependency pre-bundling only applies in development mode, and uses `esbuild` to convert dependencies to ESM. In production builds, `@rollup/plugin-commonjs` is used instead.
- name: Deploying a Static Site
  id: guide/static-deploy
  summary: It is important to note that vite preview is intended for previewing the build locally and not meant as a production server
  description: "# Deploying a Static Site\n\nThe following guides are based on some shared assumptions:\n\n- You are using the default build output location (`dist`). This location [can be changed using `build.outDir`](../config/build-options#build-outdir), and you can extrapolate instructions from these guides in that case.\n- You are using npm. You can use equivalent commands to run the scripts if you are using Yarn or other package managers.\n- Vite is installed as a local dev dependency in your project, and you have setup the following npm scripts:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  }\n}\n```\n\nIt is important to note that `vite preview` is intended for previewing the build locally and not meant as a production server.\n\n**NOTE**\n\nThese guides provide instructions for performing a static deployment of your Vite site. Vite also supports Server Side Rendering. SSR refers to front-end frameworks that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. Check out the [SSR Guide](ssr) to learn about this feature. On the other hand, if you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](backend-integration) instead.\n\n## Building the App\n\nYou may run `npm run build` command to build the app.\n\nbash\n\n``` javascript\n$ npm run build\n```\n\nBy default, the build output will be placed at `dist`. You may deploy this `dist` folder to any of your preferred platforms.\n\n### Testing the App Locally\n\nOnce you've built the app, you may test it locally by running `npm run preview` command.\n\nbash\n\n``` javascript\n$ npm run preview\n```\n\nThe `vite preview` command will boot up a local static web server that serves the files from `dist` at `http://localhost:4173`. It's an easy way to check if the production build looks OK in your local environment.\n\nYou may configure the port of the server by passing the `--port` flag as an argument.\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"preview\": \"vite preview --port 8080\"\n  }\n}\n```\n\nNow the `preview` command will launch the server at `http://localhost:8080`.\n\n## GitHub Pages\n\n1.  Set the correct `base` in `vite.config.js`.\n\n    If you are deploying to `https://<USERNAME>.github.io/`, or to a custom domain through GitHub Pages (eg. `www.example.com`), set `base` to `'/'`. Alternatively, you can remove `base` from the configuration, as it defaults to `'/'`.\n\n    If you are deploying to `https://<USERNAME>.github.io/<REPO>/` (eg. your repository is at `https://github.com/<USERNAME>/<REPO>`), then set `base` to `'/<REPO>/'`.\n\n2.  Go to your GitHub Pages configuration in the repository settings page and choose the source of deployment as \"GitHub Actions\", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:\n\n    yml\n    ``` javascript\n    # Simple workflow for deploying static content to GitHub Pages\n    name: Deploy static content to Pages\n\n    on:\n      # Runs on pushes targeting the default branch\n      push:\n        branches: ['main']\n\n      # Allows you to run this workflow manually from the Actions tab\n      workflow_dispatch:\n\n    # Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages\n    permissions:\n      contents: read\n      pages: write\n      id-token: write\n\n    # Allow one concurrent deployment\n    concurrency:\n      group: 'pages'\n      cancel-in-progress: true\n\n    jobs:\n      # Single deploy job since we're just deploying\n      deploy:\n        environment:\n          name: github-pages\n          url: ${{ steps.deployment.outputs.page_url }}\n        runs-on: ubuntu-latest\n        steps:\n          - name: Checkout\n            uses: actions/checkout@v4\n          - name: Set up Node\n            uses: actions/setup-node@v4\n            with:\n              node-version: 20\n              cache: 'npm'\n          - name: Install dependencies\n            run: npm ci\n          - name: Build\n            run: npm run build\n          - name: Setup Pages\n            uses: actions/configure-pages@v4\n          - name: Upload artifact\n            uses: actions/upload-pages-artifact@v3\n            with:\n              # Upload dist folder\n              path: './dist'\n          - name: Deploy to GitHub Pages\n            id: deployment\n            uses: actions/deploy-pages@v4\n    ```\n\n## GitLab Pages and GitLab CI\n\n1.  Set the correct `base` in `vite.config.js`.\n\n    If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/`, you can omit `base` as it defaults to `'/'`.\n\n    If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/<REPO>/`, for example your repository is at `https://gitlab.com/<USERNAME>/<REPO>`, then set `base` to `'/<REPO>/'`.\n\n2.  Create a file called `.gitlab-ci.yml` in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:\n\n    yaml\n    ``` javascript\n    image: node:16.5.0\n    pages:\n      stage: deploy\n      cache:\n        key:\n          files:\n            - package-lock.json\n          prefix: npm\n        paths:\n          - node_modules/\n      script:\n        - npm install\n        - npm run build\n        - cp -a dist/. public/\n      artifacts:\n        paths:\n          - public\n      rules:\n        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    ```\n\n## Netlify\n\n### Netlify CLI\n\n1.  Install the [Netlify CLI](https://cli.netlify.com/).\n2.  Create a new site using `ntl init`.\n3.  Deploy using `ntl deploy`.\n\nbash\n\n``` javascript\n# Install the Netlify CLI\n$ npm install -g netlify-cli\n\n# Create a new site in Netlify\n$ ntl init\n\n# Deploy to a unique preview URL\n$ ntl deploy\n```\n\nThe Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the `prod` flag:\n\nbash\n\n``` javascript\n# Deploy the site into production\n$ ntl deploy --prod\n```\n\n### Netlify with Git\n\n1.  Push your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).\n2.  [Import the project](https://app.netlify.com/start) to Netlify.\n3.  Choose the branch, output directory, and set up environment variables if applicable.\n4.  Click on **Deploy**.\n5.  Your Vite app is deployed!\n\nAfter your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate [Preview Deployments](https://docs.netlify.com/site-deploys/deploy-previews/), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://docs.netlify.com/site-deploys/overview/#definitions).\n\n## Vercel\n\n### Vercel CLI\n\n1.  Install the [Vercel CLI](https://vercel.com/cli) and run `vercel` to deploy.\n2.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.\n3.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))\n\nbash\n\n``` javascript\n$ npm i -g vercel\n$ vercel init vite\nVercel CLI\n> Success! Initialized \"vite\" example in ~/your-folder.\n- To deploy, `cd vite` and run `vercel`.\n```\n\n### Vercel for Git\n\n1.  Push your code to your git repository (GitHub, GitLab, Bitbucket).\n2.  [Import your Vite project](https://vercel.com/new) into Vercel.\n3.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.\n4.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://vercel.com/docs/concepts/deployments/environments#preview), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://vercel.com/docs/concepts/deployments/environments#production).\n\nLearn more about Vercel’s [Git Integration](https://vercel.com/docs/concepts/git).\n\n## Cloudflare Pages\n\n### Cloudflare Pages via Wrangler\n\n1.  Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).\n2.  Authenticate Wrangler with your Cloudflare account using `wrangler login`.\n3.  Run your build command.\n4.  Deploy using `npx wrangler pages deploy dist`.\n\nbash\n\n``` javascript\n# Install Wrangler CLI\n$ npm install -g wrangler\n\n# Login to Cloudflare account from CLI\n$ wrangler login\n\n# Run your build command\n$ npm run build\n\n# Create new deployment\n$ npx wrangler pages deploy dist\n```\n\nAfter your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.\n\n### Cloudflare Pages with Git\n\n1.  Push your code to your git repository (GitHub, GitLab).\n2.  Log in to the Cloudflare dashboard and select your account in **Account Home** \\> **Pages**.\n3.  Select **Create a new Project** and the **Connect Git** option.\n4.  Select the git project you want to deploy and click **Begin setup**\n5.  Select the corresponding framework preset in the build setting depending on the Vite framework you have selected.\n6.  Then save and deploy!\n7.  Your application is deployed! (e.g `https://<PROJECTNAME>.pages.dev/`)\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://developers.cloudflare.com/pages/platform/preview-deployments/) unless specified not to in your [branch build controls](https://developers.cloudflare.com/pages/platform/branch-build-controls/). All changes to the Production Branch (commonly “main”) will result in a Production Deployment.\n\nYou can also add custom domains and handle custom build settings on Pages. Learn more about [Cloudflare Pages Git Integration](https://developers.cloudflare.com/pages/get-started/#manage-your-site).\n\n## Google Firebase\n\n1.  Make sure you have [firebase-tools](https://www.npmjs.com/package/firebase-tools) installed.\n\n2.  Create `firebase.json` and `.firebaserc` at the root of your project with the following content:\n\n    `firebase.json`:\n\n    json\n    ``` javascript\n    {\n      \"hosting\": {\n        \"public\": \"dist\",\n        \"ignore\": [],\n        \"rewrites\": [\n          {\n            \"source\": \"**\",\n            \"destination\": \"/index.html\"\n          }\n        ]\n      }\n    }\n    ```\n\n    `.firebaserc`:\n\n    js\n    ``` javascript\n    {\n      \"projects\": {\n        \"default\": \"<YOUR_FIREBASE_ID>\"\n      }\n    }\n    ```\n\n3.  After running `npm run build`, deploy using the command `firebase deploy`.\n\n## Surge\n\n1.  First install [surge](https://www.npmjs.com/package/surge), if you haven’t already.\n\n2.  Run `npm run build`.\n\n3.  Deploy to surge by typing `surge dist`.\n\nYou can also deploy to a [custom domain](http://surge.sh/help/adding-a-custom-domain) by adding `surge dist yourdomain.com`.\n\n## Azure Static Web Apps\n\nYou can quickly deploy your Vite app with Microsoft Azure [Static Web Apps](https://aka.ms/staticwebapps) service. You need:\n\n- An Azure account and a subscription key. You can create a [free Azure account here](https://azure.microsoft.com/free).\n- Your app code pushed to [GitHub](https://github.com).\n- The [SWA Extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) in [Visual Studio Code](https://code.visualstudio.com).\n\nInstall the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.\n\nFollow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually `/`) and built file location `/dist`. The wizard will run and will create a GitHub action in your repo in a `.github` folder.\n\nThe action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.\n\n## Render\n\nYou can deploy your Vite app as a Static Site on [Render](https://render.com/).\n\n1.  Create a [Render account](https://dashboard.render.com/register).\n\n2.  In the [Dashboard](https://dashboard.render.com/), click the **New** button and select **Static Site**.\n\n3.  Connect your GitHub/GitLab account or use a public repository.\n\n4.  Specify a project name and branch.\n\n    - **Build Command**: `npm run build`\n    - **Publish Directory**: `dist`\n\n5.  Click **Create Static Site**.\n\n    Your app should be deployed at `https://<PROJECTNAME>.onrender.com/`.\n\nBy default, any new commit pushed to the specified branch will automatically trigger a new deployment. [Auto-Deploy](https://render.com/docs/deploys#toggling-auto-deploy-for-a-service) can be configured in the project settings.\n\nYou can also add a [custom domain](https://render.com/docs/custom-domains) to your project.\n\n## Flightcontrol\n\nDeploy your static site using [Flightcontrol](https://www.flightcontrol.dev/?ref=docs-vite) by following these [instructions](https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite).\n\n## Kinsta Static Site Hosting\n\nDeploy your static site using [Kinsta](https://kinsta.com/static-site-hosting/) by following these [instructions](https://kinsta.com/docs/react-vite-example/).\n\n## xmit Static Site Hosting\n\nDeploy your static site using [xmit](https://xmit.co) by following this [guide](https://xmit.dev/posts/vite-quickstart/).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/static-deploy](https://vitejs.dev/guide/static-deploy)"
- name: 'Deploying a Static Site: APIs'
  id: guide/static-deploy
  summary: It is important to note that vite preview is intended for previewing the build locally and not meant as a production server
  description: "# Deploying a Static Site\n\nThe following guides are based on some shared assumptions:\n\n- You are using the default build output location (`dist`). This location [can be changed using `build.outDir`](../config/build-options#build-outdir), and you can extrapolate instructions from these guides in that case.\n- You are using npm. You can use equivalent commands to run the scripts if you are using Yarn or other package managers.\n- Vite is installed as a local dev dependency in your project, and you have setup the following npm scripts:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  }\n}\n```\n\nIt is important to note that `vite preview` is intended for previewing the build locally and not meant as a production server.\n\n**NOTE**\n\nThese guides provide instructions for performing a static deployment of your Vite site. Vite also supports Server Side Rendering. SSR refers to front-end frameworks that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. Check out the [SSR Guide](ssr) to learn about this feature. On the other hand, if you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](backend-integration) instead.\n\n## Building the App\n\nYou may run `npm run build` command to build the app.\n\nbash\n\n``` javascript\n$ npm run build\n```\n\nBy default, the build output will be placed at `dist`. You may deploy this `dist` folder to any of your preferred platforms.\n\n### Testing the App Locally\n\nOnce you've built the app, you may test it locally by running `npm run preview` command.\n\nbash\n\n``` javascript\n$ npm run preview\n```\n\nThe `vite preview` command will boot up a local static web server that serves the files from `dist` at `http://localhost:4173`. It's an easy way to check if the production build looks OK in your local environment.\n\nYou may configure the port of the server by passing the `--port` flag as an argument.\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"preview\": \"vite preview --port 8080\"\n  }\n}\n```\n\nNow the `preview` command will launch the server at `http://localhost:8080`.\n\n## GitHub Pages\n\n1.  Set the correct `base` in `vite.config.js`.\n\n    If you are deploying to `https://<USERNAME>.github.io/`, or to a custom domain through GitHub Pages (eg. `www.example.com`), set `base` to `'/'`. Alternatively, you can remove `base` from the configuration, as it defaults to `'/'`.\n\n    If you are deploying to `https://<USERNAME>.github.io/<REPO>/` (eg. your repository is at `https://github.com/<USERNAME>/<REPO>`), then set `base` to `'/<REPO>/'`.\n\n2.  Go to your GitHub Pages configuration in the repository settings page and choose the source of deployment as \"GitHub Actions\", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:\n\n    yml\n    ``` javascript\n    # Simple workflow for deploying static content to GitHub Pages\n    name: Deploy static content to Pages\n\n    on:\n      # Runs on pushes targeting the default branch\n      push:\n        branches: ['main']\n\n      # Allows you to run this workflow manually from the Actions tab\n      workflow_dispatch:\n\n    # Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages\n    permissions:\n      contents: read\n      pages: write\n      id-token: write\n\n    # Allow one concurrent deployment\n    concurrency:\n      group: 'pages'\n      cancel-in-progress: true\n\n    jobs:\n      # Single deploy job since we're just deploying\n      deploy:\n        environment:\n          name: github-pages\n          url: ${{ steps.deployment.outputs.page_url }}\n        runs-on: ubuntu-latest\n        steps:\n          - name: Checkout\n            uses: actions/checkout@v4\n          - name: Set up Node\n            uses: actions/setup-node@v4\n            with:\n              node-version: 20\n              cache: 'npm'\n          - name: Install dependencies\n            run: npm ci\n          - name: Build\n            run: npm run build\n          - name: Setup Pages\n            uses: actions/configure-pages@v4\n          - name: Upload artifact\n            uses: actions/upload-pages-artifact@v3\n            with:\n              # Upload dist folder\n              path: './dist'\n          - name: Deploy to GitHub Pages\n            id: deployment\n            uses: actions/deploy-pages@v4\n    ```\n\n## GitLab Pages and GitLab CI\n\n1.  Set the correct `base` in `vite.config.js`.\n\n    If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/`, you can omit `base` as it defaults to `'/'`.\n\n    If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/<REPO>/`, for example your repository is at `https://gitlab.com/<USERNAME>/<REPO>`, then set `base` to `'/<REPO>/'`.\n\n2.  Create a file called `.gitlab-ci.yml` in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:\n\n    yaml\n    ``` javascript\n    image: node:16.5.0\n    pages:\n      stage: deploy\n      cache:\n        key:\n          files:\n            - package-lock.json\n          prefix: npm\n        paths:\n          - node_modules/\n      script:\n        - npm install\n        - npm run build\n        - cp -a dist/. public/\n      artifacts:\n        paths:\n          - public\n      rules:\n        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    ```\n\n## Netlify\n\n### Netlify CLI\n\n1.  Install the [Netlify CLI](https://cli.netlify.com/).\n2.  Create a new site using `ntl init`.\n3.  Deploy using `ntl deploy`.\n\nbash\n\n``` javascript\n# Install the Netlify CLI\n$ npm install -g netlify-cli\n\n# Create a new site in Netlify\n$ ntl init\n\n# Deploy to a unique preview URL\n$ ntl deploy\n```\n\nThe Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the `prod` flag:\n\nbash\n\n``` javascript\n# Deploy the site into production\n$ ntl deploy --prod\n```\n\n### Netlify with Git\n\n1.  Push your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).\n2.  [Import the project](https://app.netlify.com/start) to Netlify.\n3.  Choose the branch, output directory, and set up environment variables if applicable.\n4.  Click on **Deploy**.\n5.  Your Vite app is deployed!\n\nAfter your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate [Preview Deployments](https://docs.netlify.com/site-deploys/deploy-previews/), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://docs.netlify.com/site-deploys/overview/#definitions).\n\n## Vercel\n\n### Vercel CLI\n\n1.  Install the [Vercel CLI](https://vercel.com/cli) and run `vercel` to deploy.\n2.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.\n3.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))\n\nbash\n\n``` javascript\n$ npm i -g vercel\n$ vercel init vite\nVercel CLI\n> Success! Initialized \"vite\" example in ~/your-folder.\n- To deploy, `cd vite` and run `vercel`.\n```\n\n### Vercel for Git\n\n1.  Push your code to your git repository (GitHub, GitLab, Bitbucket).\n2.  [Import your Vite project](https://vercel.com/new) into Vercel.\n3.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.\n4.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://vercel.com/docs/concepts/deployments/environments#preview), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://vercel.com/docs/concepts/deployments/environments#production).\n\nLearn more about Vercel’s [Git Integration](https://vercel.com/docs/concepts/git).\n\n## Cloudflare Pages\n\n### Cloudflare Pages via Wrangler\n\n1.  Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).\n2.  Authenticate Wrangler with your Cloudflare account using `wrangler login`.\n3.  Run your build command.\n4.  Deploy using `npx wrangler pages deploy dist`.\n\nbash\n\n``` javascript\n# Install Wrangler CLI\n$ npm install -g wrangler\n\n# Login to Cloudflare account from CLI\n$ wrangler login\n\n# Run your build command\n$ npm run build\n\n# Create new deployment\n$ npx wrangler pages deploy dist\n```\n\nAfter your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.\n\n### Cloudflare Pages with Git\n\n1.  Push your code to your git repository (GitHub, GitLab).\n2.  Log in to the Cloudflare dashboard and select your account in **Account Home** \\> **Pages**.\n3.  Select **Create a new Project** and the **Connect Git** option.\n4.  Select the git project you want to deploy and click **Begin setup**\n5.  Select the corresponding framework preset in the build setting depending on the Vite framework you have selected.\n6.  Then save and deploy!\n7.  Your application is deployed! (e.g `https://<PROJECTNAME>.pages.dev/`)\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://developers.cloudflare.com/pages/platform/preview-deployments/) unless specified not to in your [branch build controls](https://developers.cloudflare.com/pages/platform/branch-build-controls/). All changes to the Production Branch (commonly “main”) will result in a Production Deployment.\n\nYou can also add custom domains and handle custom build settings on Pages. Learn more about [Cloudflare Pages Git Integration](https://developers.cloudflare.com/pages/get-started/#manage-your-site).\n\n## Google Firebase\n\n1.  Make sure you have [firebase-tools](https://www.npmjs.com/package/firebase-tools) installed.\n\n2.  Create `firebase.json` and `.firebaserc` at the root of your project with the following content:\n\n    `firebase.json`:\n\n    json\n    ``` javascript\n    {\n      \"hosting\": {\n        \"public\": \"dist\",\n        \"ignore\": [],\n        \"rewrites\": [\n          {\n            \"source\": \"**\",\n            \"destination\": \"/index.html\"\n          }\n        ]\n      }\n    }\n    ```\n\n    `.firebaserc`:\n\n    js\n    ``` javascript\n    {\n      \"projects\": {\n        \"default\": \"<YOUR_FIREBASE_ID>\"\n      }\n    }\n    ```\n\n3.  After running `npm run build`, deploy using the command `firebase deploy`.\n\n## Surge\n\n1.  First install [surge](https://www.npmjs.com/package/surge), if you haven’t already.\n\n2.  Run `npm run build`.\n\n3.  Deploy to surge by typing `surge dist`.\n\nYou can also deploy to a [custom domain](http://surge.sh/help/adding-a-custom-domain) by adding `surge dist yourdomain.com`.\n\n## Azure Static Web Apps\n\nYou can quickly deploy your Vite app with Microsoft Azure [Static Web Apps](https://aka.ms/staticwebapps) service. You need:\n\n- An Azure account and a subscription key. You can create a [free Azure account here](https://azure.microsoft.com/free).\n- Your app code pushed to [GitHub](https://github.com).\n- The [SWA Extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) in [Visual Studio Code](https://code.visualstudio.com).\n\nInstall the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.\n\nFollow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually `/`) and built file location `/dist`. The wizard will run and will create a GitHub action in your repo in a `.github` folder.\n\nThe action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.\n\n## Render\n\nYou can deploy your Vite app as a Static Site on [Render](https://render.com/).\n\n1.  Create a [Render account](https://dashboard.render.com/register).\n\n2.  In the [Dashboard](https://dashboard.render.com/), click the **New** button and select **Static Site**.\n\n3.  Connect your GitHub/GitLab account or use a public repository.\n\n4.  Specify a project name and branch.\n\n    - **Build Command**: `npm run build`\n    - **Publish Directory**: `dist`\n\n5.  Click **Create Static Site**.\n\n    Your app should be deployed at `https://<PROJECTNAME>.onrender.com/`.\n\nBy default, any new commit pushed to the specified branch will automatically trigger a new deployment. [Auto-Deploy](https://render.com/docs/deploys#toggling-auto-deploy-for-a-service) can be configured in the project settings.\n\nYou can also add a [custom domain](https://render.com/docs/custom-domains) to your project.\n\n## Flightcontrol\n\nDeploy your static site using [Flightcontrol](https://www.flightcontrol.dev/?ref=docs-vite) by following these [instructions](https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite).\n\n## Kinsta Static Site Hosting\n\nDeploy your static site using [Kinsta](https://kinsta.com/static-site-hosting/) by following these [instructions](https://kinsta.com/docs/react-vite-example/).\n\n## xmit Static Site Hosting\n\nDeploy your static site using [xmit](https://xmit.co) by following this [guide](https://xmit.dev/posts/vite-quickstart/).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/static-deploy](https://vitejs.dev/guide/static-deploy)"
- name: 'Deploying a Static Site: Azure Static Web Apps'
  id: guide/static-deploy#azure-static-web-apps
  summary: You can quickly deploy your Vite app with Microsoft Azure Static Web Apps service
  belongs_to: Deploying a Static Site
  description: |-
    ## Azure Static Web Apps

    You can quickly deploy your Vite app with Microsoft Azure [Static Web Apps](https://aka.ms/staticwebapps) service. You need:

    - An Azure account and a subscription key. You can create a [free Azure account here](https://azure.microsoft.com/free).
    - Your app code pushed to [GitHub](https://github.com).
    - The [SWA Extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) in [Visual Studio Code](https://code.visualstudio.com).

    Install the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.

    Follow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually `/`) and built file location `/dist`. The wizard will run and will create a GitHub action in your repo in a `.github` folder.

    The action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.
- name: 'Deploying a Static Site: Building the App'
  id: guide/static-deploy#building-the-app
  summary: You may run npm run build command to build the app
  belongs_to: Deploying a Static Site
  description: |-
    ## Building the App

    You may run `npm run build` command to build the app.

    bash

    ``` javascript
    $ npm run build
    ```

    By default, the build output will be placed at `dist`. You may deploy this `dist` folder to any of your preferred platforms.
- name: 'Deploying a Static Site: Cloudflare Pages'
  id: guide/static-deploy#cloudflare-pages
  summary: null
  belongs_to: Deploying a Static Site
  description: '## Cloudflare Pages'
- name: 'Deploying a Static Site: Cloudflare Pages via Wrangler'
  id: guide/static-deploy#cloudflare-pages-via-wrangler
  summary: After your assets are uploaded, Wrangler will give you a preview URL to inspect your site
  belongs_to: Deploying a Static Site
  description: |-
    ### Cloudflare Pages via Wrangler

    1.  Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).
    2.  Authenticate Wrangler with your Cloudflare account using `wrangler login`.
    3.  Run your build command.
    4.  Deploy using `npx wrangler pages deploy dist`.

    bash

    ``` javascript
    # Install Wrangler CLI
    $ npm install -g wrangler

    # Login to Cloudflare account from CLI
    $ wrangler login

    # Run your build command
    $ npm run build

    # Create new deployment
    $ npx wrangler pages deploy dist
    ```

    After your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.
- name: 'Deploying a Static Site: Cloudflare Pages with Git'
  id: guide/static-deploy#cloudflare-pages-with-git
  summary: After your project has been imported and deployed, all subsequent pushes to branches will generate Preview Deployments unless specified not to in your branch build controls
  belongs_to: Deploying a Static Site
  description: |-
    ### Cloudflare Pages with Git

    1.  Push your code to your git repository (GitHub, GitLab).
    2.  Log in to the Cloudflare dashboard and select your account in **Account Home** \> **Pages**.
    3.  Select **Create a new Project** and the **Connect Git** option.
    4.  Select the git project you want to deploy and click **Begin setup**
    5.  Select the corresponding framework preset in the build setting depending on the Vite framework you have selected.
    6.  Then save and deploy!
    7.  Your application is deployed! (e.g `https://<PROJECTNAME>.pages.dev/`)

    After your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://developers.cloudflare.com/pages/platform/preview-deployments/) unless specified not to in your [branch build controls](https://developers.cloudflare.com/pages/platform/branch-build-controls/). All changes to the Production Branch (commonly “main”) will result in a Production Deployment.

    You can also add custom domains and handle custom build settings on Pages. Learn more about [Cloudflare Pages Git Integration](https://developers.cloudflare.com/pages/get-started/#manage-your-site).
- name: 'Deploying a Static Site: Flightcontrol'
  id: guide/static-deploy#flightcontrol
  summary: Deploy your static site using Flightcontrol by following these instructions
  belongs_to: Deploying a Static Site
  description: |-
    ## Flightcontrol

    Deploy your static site using [Flightcontrol](https://www.flightcontrol.dev/?ref=docs-vite) by following these [instructions](https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite).
- name: 'Deploying a Static Site: GitHub Pages'
  id: guide/static-deploy#github-pages
  summary: Set the correct base in vite.config.js
  belongs_to: Deploying a Static Site
  description: |-
    ## GitHub Pages

    1.  Set the correct `base` in `vite.config.js`.

        If you are deploying to `https://<USERNAME>.github.io/`, or to a custom domain through GitHub Pages (eg. `www.example.com`), set `base` to `'/'`. Alternatively, you can remove `base` from the configuration, as it defaults to `'/'`.

        If you are deploying to `https://<USERNAME>.github.io/<REPO>/` (eg. your repository is at `https://github.com/<USERNAME>/<REPO>`), then set `base` to `'/<REPO>/'`.

    2.  Go to your GitHub Pages configuration in the repository settings page and choose the source of deployment as "GitHub Actions", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:

        yml
        ``` javascript
        # Simple workflow for deploying static content to GitHub Pages
        name: Deploy static content to Pages

        on:
          # Runs on pushes targeting the default branch
          push:
            branches: ['main']

          # Allows you to run this workflow manually from the Actions tab
          workflow_dispatch:

        # Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages
        permissions:
          contents: read
          pages: write
          id-token: write

        # Allow one concurrent deployment
        concurrency:
          group: 'pages'
          cancel-in-progress: true

        jobs:
          # Single deploy job since we're just deploying
          deploy:
            environment:
              name: github-pages
              url: ${{ steps.deployment.outputs.page_url }}
            runs-on: ubuntu-latest
            steps:
              - name: Checkout
                uses: actions/checkout@v4
              - name: Set up Node
                uses: actions/setup-node@v4
                with:
                  node-version: 20
                  cache: 'npm'
              - name: Install dependencies
                run: npm ci
              - name: Build
                run: npm run build
              - name: Setup Pages
                uses: actions/configure-pages@v4
              - name: Upload artifact
                uses: actions/upload-pages-artifact@v3
                with:
                  # Upload dist folder
                  path: './dist'
              - name: Deploy to GitHub Pages
                id: deployment
                uses: actions/deploy-pages@v4
        ```
- name: 'Deploying a Static Site: GitLab Pages and GitLab CI'
  id: guide/static-deploy#gitlab-pages-and-gitlab-ci
  summary: Set the correct base in vite.config.js
  belongs_to: Deploying a Static Site
  description: |-
    ## GitLab Pages and GitLab CI

    1.  Set the correct `base` in `vite.config.js`.

        If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/`, you can omit `base` as it defaults to `'/'`.

        If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/<REPO>/`, for example your repository is at `https://gitlab.com/<USERNAME>/<REPO>`, then set `base` to `'/<REPO>/'`.

    2.  Create a file called `.gitlab-ci.yml` in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:

        yaml
        ``` javascript
        image: node:16.5.0
        pages:
          stage: deploy
          cache:
            key:
              files:
                - package-lock.json
              prefix: npm
            paths:
              - node_modules/
          script:
            - npm install
            - npm run build
            - cp -a dist/. public/
          artifacts:
            paths:
              - public
          rules:
            - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
        ```

    &nbsp;
- name: 'Deploying a Static Site: Google Firebase'
  id: guide/static-deploy#google-firebase
  summary: Make sure you have firebase-tools installed
  belongs_to: Deploying a Static Site
  description: |-
    ## Google Firebase

    1.  Make sure you have [firebase-tools](https://www.npmjs.com/package/firebase-tools) installed.

    2.  Create `firebase.json` and `.firebaserc` at the root of your project with the following content:

        `firebase.json`:

        json
        ``` javascript
        {
          "hosting": {
            "public": "dist",
            "ignore": [],
            "rewrites": [
              {
                "source": "**",
                "destination": "/index.html"
              }
            ]
          }
        }
        ```

        `.firebaserc`:

        js
        ``` javascript
        {
          "projects": {
            "default": "<YOUR_FIREBASE_ID>"
          }
        }
        ```

    3.  After running `npm run build`, deploy using the command `firebase deploy`.

    &nbsp;
- name: 'Deploying a Static Site: Guide'
  id: guide/static-deploy
  summary: It is important to note that vite preview is intended for previewing the build locally and not meant as a production server
  description: "# Deploying a Static Site\n\nThe following guides are based on some shared assumptions:\n\n- You are using the default build output location (`dist`). This location [can be changed using `build.outDir`](../config/build-options#build-outdir), and you can extrapolate instructions from these guides in that case.\n- You are using npm. You can use equivalent commands to run the scripts if you are using Yarn or other package managers.\n- Vite is installed as a local dev dependency in your project, and you have setup the following npm scripts:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  }\n}\n```\n\nIt is important to note that `vite preview` is intended for previewing the build locally and not meant as a production server.\n\n**NOTE**\n\nThese guides provide instructions for performing a static deployment of your Vite site. Vite also supports Server Side Rendering. SSR refers to front-end frameworks that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. Check out the [SSR Guide](ssr) to learn about this feature. On the other hand, if you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](backend-integration) instead.\n\n## Building the App\n\nYou may run `npm run build` command to build the app.\n\nbash\n\n``` javascript\n$ npm run build\n```\n\nBy default, the build output will be placed at `dist`. You may deploy this `dist` folder to any of your preferred platforms.\n\n### Testing the App Locally\n\nOnce you've built the app, you may test it locally by running `npm run preview` command.\n\nbash\n\n``` javascript\n$ npm run preview\n```\n\nThe `vite preview` command will boot up a local static web server that serves the files from `dist` at `http://localhost:4173`. It's an easy way to check if the production build looks OK in your local environment.\n\nYou may configure the port of the server by passing the `--port` flag as an argument.\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"preview\": \"vite preview --port 8080\"\n  }\n}\n```\n\nNow the `preview` command will launch the server at `http://localhost:8080`.\n\n## GitHub Pages\n\n1.  Set the correct `base` in `vite.config.js`.\n\n    If you are deploying to `https://<USERNAME>.github.io/`, or to a custom domain through GitHub Pages (eg. `www.example.com`), set `base` to `'/'`. Alternatively, you can remove `base` from the configuration, as it defaults to `'/'`.\n\n    If you are deploying to `https://<USERNAME>.github.io/<REPO>/` (eg. your repository is at `https://github.com/<USERNAME>/<REPO>`), then set `base` to `'/<REPO>/'`.\n\n2.  Go to your GitHub Pages configuration in the repository settings page and choose the source of deployment as \"GitHub Actions\", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:\n\n    yml\n    ``` javascript\n    # Simple workflow for deploying static content to GitHub Pages\n    name: Deploy static content to Pages\n\n    on:\n      # Runs on pushes targeting the default branch\n      push:\n        branches: ['main']\n\n      # Allows you to run this workflow manually from the Actions tab\n      workflow_dispatch:\n\n    # Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages\n    permissions:\n      contents: read\n      pages: write\n      id-token: write\n\n    # Allow one concurrent deployment\n    concurrency:\n      group: 'pages'\n      cancel-in-progress: true\n\n    jobs:\n      # Single deploy job since we're just deploying\n      deploy:\n        environment:\n          name: github-pages\n          url: ${{ steps.deployment.outputs.page_url }}\n        runs-on: ubuntu-latest\n        steps:\n          - name: Checkout\n            uses: actions/checkout@v4\n          - name: Set up Node\n            uses: actions/setup-node@v4\n            with:\n              node-version: 20\n              cache: 'npm'\n          - name: Install dependencies\n            run: npm ci\n          - name: Build\n            run: npm run build\n          - name: Setup Pages\n            uses: actions/configure-pages@v4\n          - name: Upload artifact\n            uses: actions/upload-pages-artifact@v3\n            with:\n              # Upload dist folder\n              path: './dist'\n          - name: Deploy to GitHub Pages\n            id: deployment\n            uses: actions/deploy-pages@v4\n    ```\n\n## GitLab Pages and GitLab CI\n\n1.  Set the correct `base` in `vite.config.js`.\n\n    If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/`, you can omit `base` as it defaults to `'/'`.\n\n    If you are deploying to `https://<USERNAME or GROUP>.gitlab.io/<REPO>/`, for example your repository is at `https://gitlab.com/<USERNAME>/<REPO>`, then set `base` to `'/<REPO>/'`.\n\n2.  Create a file called `.gitlab-ci.yml` in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:\n\n    yaml\n    ``` javascript\n    image: node:16.5.0\n    pages:\n      stage: deploy\n      cache:\n        key:\n          files:\n            - package-lock.json\n          prefix: npm\n        paths:\n          - node_modules/\n      script:\n        - npm install\n        - npm run build\n        - cp -a dist/. public/\n      artifacts:\n        paths:\n          - public\n      rules:\n        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    ```\n\n## Netlify\n\n### Netlify CLI\n\n1.  Install the [Netlify CLI](https://cli.netlify.com/).\n2.  Create a new site using `ntl init`.\n3.  Deploy using `ntl deploy`.\n\nbash\n\n``` javascript\n# Install the Netlify CLI\n$ npm install -g netlify-cli\n\n# Create a new site in Netlify\n$ ntl init\n\n# Deploy to a unique preview URL\n$ ntl deploy\n```\n\nThe Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the `prod` flag:\n\nbash\n\n``` javascript\n# Deploy the site into production\n$ ntl deploy --prod\n```\n\n### Netlify with Git\n\n1.  Push your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).\n2.  [Import the project](https://app.netlify.com/start) to Netlify.\n3.  Choose the branch, output directory, and set up environment variables if applicable.\n4.  Click on **Deploy**.\n5.  Your Vite app is deployed!\n\nAfter your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate [Preview Deployments](https://docs.netlify.com/site-deploys/deploy-previews/), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://docs.netlify.com/site-deploys/overview/#definitions).\n\n## Vercel\n\n### Vercel CLI\n\n1.  Install the [Vercel CLI](https://vercel.com/cli) and run `vercel` to deploy.\n2.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.\n3.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))\n\nbash\n\n``` javascript\n$ npm i -g vercel\n$ vercel init vite\nVercel CLI\n> Success! Initialized \"vite\" example in ~/your-folder.\n- To deploy, `cd vite` and run `vercel`.\n```\n\n### Vercel for Git\n\n1.  Push your code to your git repository (GitHub, GitLab, Bitbucket).\n2.  [Import your Vite project](https://vercel.com/new) into Vercel.\n3.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.\n4.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://vercel.com/docs/concepts/deployments/environments#preview), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://vercel.com/docs/concepts/deployments/environments#production).\n\nLearn more about Vercel’s [Git Integration](https://vercel.com/docs/concepts/git).\n\n## Cloudflare Pages\n\n### Cloudflare Pages via Wrangler\n\n1.  Install [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/get-started/).\n2.  Authenticate Wrangler with your Cloudflare account using `wrangler login`.\n3.  Run your build command.\n4.  Deploy using `npx wrangler pages deploy dist`.\n\nbash\n\n``` javascript\n# Install Wrangler CLI\n$ npm install -g wrangler\n\n# Login to Cloudflare account from CLI\n$ wrangler login\n\n# Run your build command\n$ npm run build\n\n# Create new deployment\n$ npx wrangler pages deploy dist\n```\n\nAfter your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.\n\n### Cloudflare Pages with Git\n\n1.  Push your code to your git repository (GitHub, GitLab).\n2.  Log in to the Cloudflare dashboard and select your account in **Account Home** \\> **Pages**.\n3.  Select **Create a new Project** and the **Connect Git** option.\n4.  Select the git project you want to deploy and click **Begin setup**\n5.  Select the corresponding framework preset in the build setting depending on the Vite framework you have selected.\n6.  Then save and deploy!\n7.  Your application is deployed! (e.g `https://<PROJECTNAME>.pages.dev/`)\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://developers.cloudflare.com/pages/platform/preview-deployments/) unless specified not to in your [branch build controls](https://developers.cloudflare.com/pages/platform/branch-build-controls/). All changes to the Production Branch (commonly “main”) will result in a Production Deployment.\n\nYou can also add custom domains and handle custom build settings on Pages. Learn more about [Cloudflare Pages Git Integration](https://developers.cloudflare.com/pages/get-started/#manage-your-site).\n\n## Google Firebase\n\n1.  Make sure you have [firebase-tools](https://www.npmjs.com/package/firebase-tools) installed.\n\n2.  Create `firebase.json` and `.firebaserc` at the root of your project with the following content:\n\n    `firebase.json`:\n\n    json\n    ``` javascript\n    {\n      \"hosting\": {\n        \"public\": \"dist\",\n        \"ignore\": [],\n        \"rewrites\": [\n          {\n            \"source\": \"**\",\n            \"destination\": \"/index.html\"\n          }\n        ]\n      }\n    }\n    ```\n\n    `.firebaserc`:\n\n    js\n    ``` javascript\n    {\n      \"projects\": {\n        \"default\": \"<YOUR_FIREBASE_ID>\"\n      }\n    }\n    ```\n\n3.  After running `npm run build`, deploy using the command `firebase deploy`.\n\n## Surge\n\n1.  First install [surge](https://www.npmjs.com/package/surge), if you haven’t already.\n\n2.  Run `npm run build`.\n\n3.  Deploy to surge by typing `surge dist`.\n\nYou can also deploy to a [custom domain](http://surge.sh/help/adding-a-custom-domain) by adding `surge dist yourdomain.com`.\n\n## Azure Static Web Apps\n\nYou can quickly deploy your Vite app with Microsoft Azure [Static Web Apps](https://aka.ms/staticwebapps) service. You need:\n\n- An Azure account and a subscription key. You can create a [free Azure account here](https://azure.microsoft.com/free).\n- Your app code pushed to [GitHub](https://github.com).\n- The [SWA Extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps) in [Visual Studio Code](https://code.visualstudio.com).\n\nInstall the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.\n\nFollow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually `/`) and built file location `/dist`. The wizard will run and will create a GitHub action in your repo in a `.github` folder.\n\nThe action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.\n\n## Render\n\nYou can deploy your Vite app as a Static Site on [Render](https://render.com/).\n\n1.  Create a [Render account](https://dashboard.render.com/register).\n\n2.  In the [Dashboard](https://dashboard.render.com/), click the **New** button and select **Static Site**.\n\n3.  Connect your GitHub/GitLab account or use a public repository.\n\n4.  Specify a project name and branch.\n\n    - **Build Command**: `npm run build`\n    - **Publish Directory**: `dist`\n\n5.  Click **Create Static Site**.\n\n    Your app should be deployed at `https://<PROJECTNAME>.onrender.com/`.\n\nBy default, any new commit pushed to the specified branch will automatically trigger a new deployment. [Auto-Deploy](https://render.com/docs/deploys#toggling-auto-deploy-for-a-service) can be configured in the project settings.\n\nYou can also add a [custom domain](https://render.com/docs/custom-domains) to your project.\n\n## Flightcontrol\n\nDeploy your static site using [Flightcontrol](https://www.flightcontrol.dev/?ref=docs-vite) by following these [instructions](https://www.flightcontrol.dev/docs/reference/examples/vite?ref=docs-vite).\n\n## Kinsta Static Site Hosting\n\nDeploy your static site using [Kinsta](https://kinsta.com/static-site-hosting/) by following these [instructions](https://kinsta.com/docs/react-vite-example/).\n\n## xmit Static Site Hosting\n\nDeploy your static site using [xmit](https://xmit.co) by following this [guide](https://xmit.dev/posts/vite-quickstart/).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/static-deploy](https://vitejs.dev/guide/static-deploy)"
- name: 'Deploying a Static Site: Kinsta Static Site Hosting'
  id: guide/static-deploy#kinsta-static-site-hosting
  summary: Deploy your static site using Kinsta by following these instructions
  belongs_to: Deploying a Static Site
  description: |-
    ## Kinsta Static Site Hosting

    Deploy your static site using [Kinsta](https://kinsta.com/static-site-hosting/) by following these [instructions](https://kinsta.com/docs/react-vite-example/).
- name: 'Deploying a Static Site: Netlify'
  id: guide/static-deploy#netlify
  summary: null
  belongs_to: Deploying a Static Site
  description: '## Netlify'
- name: 'Deploying a Static Site: Netlify CLI'
  id: guide/static-deploy#netlify-cli
  summary: The Netlify CLI will share with you a preview URL to inspect
  belongs_to: Deploying a Static Site
  description: |-
    ### Netlify CLI

    1.  Install the [Netlify CLI](https://cli.netlify.com/).
    2.  Create a new site using `ntl init`.
    3.  Deploy using `ntl deploy`.

    bash

    ``` javascript
    # Install the Netlify CLI
    $ npm install -g netlify-cli

    # Create a new site in Netlify
    $ ntl init

    # Deploy to a unique preview URL
    $ ntl deploy
    ```

    The Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the `prod` flag:

    bash

    ``` javascript
    # Deploy the site into production
    $ ntl deploy --prod
    ```
- name: 'Deploying a Static Site: Netlify with Git'
  id: guide/static-deploy#netlify-with-git
  summary: After your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate Preview Deployments, and all changes made to the Production Branch (commonly “main”) will result in a Production Deployment
  belongs_to: Deploying a Static Site
  description: |-
    ### Netlify with Git

    1.  Push your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).
    2.  [Import the project](https://app.netlify.com/start) to Netlify.
    3.  Choose the branch, output directory, and set up environment variables if applicable.
    4.  Click on **Deploy**.
    5.  Your Vite app is deployed!

    After your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate [Preview Deployments](https://docs.netlify.com/site-deploys/deploy-previews/), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://docs.netlify.com/site-deploys/overview/#definitions).
- name: 'Deploying a Static Site: Render'
  id: guide/static-deploy#render
  summary: You can deploy your Vite app as a Static Site on Render
  belongs_to: Deploying a Static Site
  description: |-
    ## Render

    You can deploy your Vite app as a Static Site on [Render](https://render.com/).

    1.  Create a [Render account](https://dashboard.render.com/register).

    2.  In the [Dashboard](https://dashboard.render.com/), click the **New** button and select **Static Site**.

    3.  Connect your GitHub/GitLab account or use a public repository.

    4.  Specify a project name and branch.

        - **Build Command**: `npm run build`
        - **Publish Directory**: `dist`

    5.  Click **Create Static Site**.

        Your app should be deployed at `https://<PROJECTNAME>.onrender.com/`.

    By default, any new commit pushed to the specified branch will automatically trigger a new deployment. [Auto-Deploy](https://render.com/docs/deploys#toggling-auto-deploy-for-a-service) can be configured in the project settings.

    You can also add a [custom domain](https://render.com/docs/custom-domains) to your project.
- name: 'Deploying a Static Site: Surge'
  id: guide/static-deploy#surge
  summary: First install surge, if you haven’t already
  belongs_to: Deploying a Static Site
  description: |-
    ## Surge

    1.  First install [surge](https://www.npmjs.com/package/surge), if you haven’t already.

    2.  Run `npm run build`.

    3.  Deploy to surge by typing `surge dist`.

    You can also deploy to a [custom domain](http://surge.sh/help/adding-a-custom-domain) by adding `surge dist yourdomain.com`.
- name: 'Deploying a Static Site: Testing the App Locally'
  id: guide/static-deploy#testing-the-app-locally
  summary: Once you've built the app, you may test it locally by running npm run preview command
  belongs_to: Deploying a Static Site
  description: |-
    ### Testing the App Locally

    Once you've built the app, you may test it locally by running `npm run preview` command.

    bash

    ``` javascript
    $ npm run preview
    ```

    The `vite preview` command will boot up a local static web server that serves the files from `dist` at `http://localhost:4173`. It's an easy way to check if the production build looks OK in your local environment.

    You may configure the port of the server by passing the `--port` flag as an argument.

    json

    ``` javascript
    {
      "scripts": {
        "preview": "vite preview --port 8080"
      }
    }
    ```

    Now the `preview` command will launch the server at `http://localhost:8080`.
- name: 'Deploying a Static Site: Vercel'
  id: guide/static-deploy#vercel
  summary: null
  belongs_to: Deploying a Static Site
  description: '## Vercel'
- name: 'Deploying a Static Site: Vercel CLI'
  id: guide/static-deploy#vercel-cli
  summary: null
  belongs_to: Deploying a Static Site
  description: |-
    ### Vercel CLI

    1.  Install the [Vercel CLI](https://vercel.com/cli) and run `vercel` to deploy.
    2.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.
    3.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))

    bash

    ``` javascript
    $ npm i -g vercel
    $ vercel init vite
    Vercel CLI
    > Success! Initialized "vite" example in ~/your-folder.
    - To deploy, `cd vite` and run `vercel`.
    ```
- name: 'Deploying a Static Site: Vercel for Git'
  id: guide/static-deploy#vercel-for-git
  summary: After your project has been imported and deployed, all subsequent pushes to branches will generate Preview Deployments, and all changes made to the Production Branch (commonly “main”) will result in a Production Deployment
  belongs_to: Deploying a Static Site
  description: |-
    ### Vercel for Git

    1.  Push your code to your git repository (GitHub, GitLab, Bitbucket).
    2.  [Import your Vite project](https://vercel.com/new) into Vercel.
    3.  Vercel will detect that you are using Vite and will enable the correct settings for your deployment.
    4.  Your application is deployed! (e.g. [vite-vue-template.vercel.app](https://vite-vue-template.vercel.app/))

    After your project has been imported and deployed, all subsequent pushes to branches will generate [Preview Deployments](https://vercel.com/docs/concepts/deployments/environments#preview), and all changes made to the Production Branch (commonly “main”) will result in a [Production Deployment](https://vercel.com/docs/concepts/deployments/environments#production).

    Learn more about Vercel’s [Git Integration](https://vercel.com/docs/concepts/git).
- name: 'Deploying a Static Site: xmit Static Site Hosting'
  id: guide/static-deploy#xmit-static-site-hosting
  summary: Deploy your static site using xmit by following this guide
  belongs_to: Deploying a Static Site
  description: "## xmit Static Site Hosting\n\nDeploy your static site using [xmit](https://xmit.co) by following this [guide](https://xmit.dev/posts/vite-quickstart/).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/static-deploy](https://vitejs.dev/guide/static-deploy)"
- name: Env Variables and Modes
  id: guide/env-and-mode
  summary: Vite exposes env variables on the special import.meta.env object, which are statically replaced at build time
  description: "# Env Variables and Modes\n\n## Env Variables\n\nVite exposes env variables on the special **`import.meta.env`** object, which are statically replaced at build time. Some built-in variables are available in all cases:\n\n- **`import.meta.env.MODE`**: {string} the [mode](#modes) the app is running in.\n\n- **`import.meta.env.BASE_URL`**: {string} the base url the app is being served from. This is determined by the [`base` config option](../config/shared-options#base).\n\n- **`import.meta.env.PROD`**: {boolean} whether the app is running in production (running the dev server with `NODE_ENV='production'` or running an app built with `NODE_ENV='production'`).\n\n- **`import.meta.env.DEV`**: {boolean} whether the app is running in development (always the opposite of `import.meta.env.PROD`)\n\n- **`import.meta.env.SSR`**: {boolean} whether the app is running in the [server](ssr#conditional-logic).\n\n## `.env` Files\n\nVite uses [dotenv](https://github.com/motdotla/dotenv) to load additional environment variables from the following files in your [environment directory](../config/shared-options#envdir):\n\n``` javascript\n.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git\n```\n\n**Env Loading Priorities**\n\nAn env file for a specific mode (e.g. `.env.production`) will take higher priority than a generic one (e.g. `.env`).\n\nIn addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by `.env` files. For example, when running `VITE_SOME_KEY=123 vite build`.\n\n`.env` files are loaded at the start of Vite. Restart the server after making changes.\n\nLoaded env variables are also exposed to your client source code via `import.meta.env` as strings.\n\nTo prevent accidentally leaking env variables to the client, only variables prefixed with `VITE_` are exposed to your Vite-processed code. e.g. for the following env variables:\n\n``` javascript\nVITE_SOME_KEY=123\nDB_PASSWORD=foobar\n```\n\nOnly `VITE_SOME_KEY` will be exposed as `import.meta.env.VITE_SOME_KEY` to your client source code, but `DB_PASSWORD` will not.\n\njs\n\n``` javascript\nconsole.log(import.meta.env.VITE_SOME_KEY) // \"123\"\nconsole.log(import.meta.env.DB_PASSWORD) // undefined\n```\n\n**Env parsing**\n\nAs shown above, `VITE_SOME_KEY` is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.\n\nAlso, Vite uses [dotenv-expand](https://github.com/motdotla/dotenv-expand) to expand variables out of the box. To learn more about the syntax, check out [their docs](https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow).\n\nNote that if you want to use `$` inside your environment value, you have to escape it with `\\`.\n\n``` javascript\nKEY=123\nNEW_KEY1=test$foo   # test\nNEW_KEY2=test\\$foo  # test$foo\nNEW_KEY3=test$KEY   # test123\n```\n\nIf you want to customize the env variables prefix, see the [envPrefix](../config/shared-options#envprefix) option.\n\n**SECURITY NOTES**\n\n- `.env.*.local` files are local-only and can contain sensitive variables. You should add `*.local` to your `.gitignore` to avoid them being checked into git.\n\n- Since any variables exposed to your Vite source code will end up in your client bundle, `VITE_*` variables should *not* contain any sensitive information.\n\n### IntelliSense for TypeScript\n\nBy default, Vite provides type definitions for `import.meta.env` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with `VITE_`.\n\nTo achieve this, you can create an `vite-env.d.ts` in `src` directory, then augment `ImportMetaEnv` like this:\n\ntypescript\n\n``` javascript\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_APP_TITLE: string\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n```\n\nIf your code relies on types from browser environments such as [DOM](https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts) and [WebWorker](https://github.com/microsoft/TypeScript/blob/main/lib/lib.webworker.d.ts), you can update the [lib](https://www.typescriptlang.org/tsconfig#lib) field in `tsconfig.json`.\n\njson\n\n``` javascript\n{\n  \"lib\": [\"WebWorker\"]\n}\n```\n\n**Imports will break type augmentation**\n\nIf the `ImportMetaEnv` augmentation does not work, make sure you do not have any `import` statements in `vite-env.d.ts`. See the [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined) for more information.\n\n## HTML Env Replacement\n\nVite also supports replacing env variables in HTML files. Any properties in `import.meta.env` can be used in HTML files with a special `%ENV_NAME%` syntax:\n\nhtml\n\n``` javascript\n<h1>Vite is running in %MODE%</h1>\n<p>Using data from %VITE_API_URL%</p>\n```\n\nIf the env doesn't exist in `import.meta.env`, e.g. `%NON_EXISTENT%`, it will be ignored and not replaced, unlike `import.meta.env.NON_EXISTENT` in JS where it's replaced as `undefined`.\n\nGiven that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using [an existing userland plugin](https://github.com/vitejs/awesome-vite#transformers) or a custom plugin that implements the [`transformIndexHtml` hook](api-plugin#transformindexhtml).\n\n## Modes\n\nBy default, the dev server (`dev` command) runs in `development` mode and the `build` command runs in `production` mode.\n\nThis means when running `vite build`, it will load the env variables from `.env.production` if there is one:\n\n``` javascript\n# .env.production\nVITE_APP_TITLE=My App\n```\n\nIn your app, you can render the title using `import.meta.env.VITE_APP_TITLE`.\n\nIn some cases, you may want to run `vite build` with a different mode to render a different title. You can overwrite the default mode used for a command by passing the `--mode` option flag. For example, if you want to build your app for a staging mode:\n\nbash\n\n``` javascript\nvite build --mode staging\n```\n\nAnd create a `.env.staging` file:\n\n``` javascript\n# .env.staging\nVITE_APP_TITLE=My App (staging)\n```\n\nAs `vite build` runs a production build by default, you can also change this and run a development build by using a different mode and `.env` file configuration:\n\n``` javascript\n# .env.testing\nNODE_ENV=development\n```\n\n## NODE_ENV and Modes\n\nIt's important to note that `NODE_ENV` (`process.env.NODE_ENV`) and modes are two different concepts. Here's how different commands affect the `NODE_ENV` and mode:\n\n| Command                                              | NODE_ENV        | Mode            |\n|------------------------------------------------------|-----------------|-----------------|\n| `vite build`                                         | `\"production\"`  | `\"production\"`  |\n| `vite build --mode development`                      | `\"production\"`  | `\"development\"` |\n| `NODE_ENV=development vite build`                    | `\"development\"` | `\"production\"`  |\n| `NODE_ENV=development vite build --mode development` | `\"development\"` | `\"development\"` |\n\nThe different values of `NODE_ENV` and mode also reflect on its corresponding `import.meta.env` properties:\n\n| Command                | `import.meta.env.PROD` | `import.meta.env.DEV` |\n|------------------------|------------------------|-----------------------|\n| `NODE_ENV=production`  | `true`                 | `false`               |\n| `NODE_ENV=development` | `false`                | `true`                |\n| `NODE_ENV=other`       | `false`                | `true`                |\n\n| Command              | `import.meta.env.MODE` |\n|----------------------|------------------------|\n| `--mode production`  | `\"production\"`         |\n| `--mode development` | `\"development\"`        |\n| `--mode staging`     | `\"staging\"`            |\n\n**`NODE_ENV` in `.env` files**\n\n`NODE_ENV=...` can be set in the command, and also in your `.env` file. If `NODE_ENV` is specified in a `.env.[mode]` file, the mode can be used to control its value. However, both `NODE_ENV` and modes remain as two different concepts.\n\nThe main benefit with `NODE_ENV=...` in the command is that it allows Vite to detect the value early. It also allows you to read `process.env.NODE_ENV` in your Vite config as Vite can only load the env files once the config is evaluated.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode)"
- name: 'Env Variables and Modes: .env Files'
  id: guide/env-and-mode#env-files
  summary: An env file for a specific mode (e.g
  belongs_to: Env Variables and Modes
  description: |-
    ## `.env` Files

    Vite uses [dotenv](https://github.com/motdotla/dotenv) to load additional environment variables from the following files in your [environment directory](../config/shared-options#envdir):

    ``` javascript
    .env                # loaded in all cases
    .env.local          # loaded in all cases, ignored by git
    .env.[mode]         # only loaded in specified mode
    .env.[mode].local   # only loaded in specified mode, ignored by git
    ```

    **Env Loading Priorities**

    An env file for a specific mode (e.g. `.env.production`) will take higher priority than a generic one (e.g. `.env`).

    In addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by `.env` files. For example, when running `VITE_SOME_KEY=123 vite build`.

    `.env` files are loaded at the start of Vite. Restart the server after making changes.

    Loaded env variables are also exposed to your client source code via `import.meta.env` as strings.

    To prevent accidentally leaking env variables to the client, only variables prefixed with `VITE_` are exposed to your Vite-processed code. e.g. for the following env variables:

    ``` javascript
    VITE_SOME_KEY=123
    DB_PASSWORD=foobar
    ```

    Only `VITE_SOME_KEY` will be exposed as `import.meta.env.VITE_SOME_KEY` to your client source code, but `DB_PASSWORD` will not.

    js

    ``` javascript
    console.log(import.meta.env.VITE_SOME_KEY) // "123"
    console.log(import.meta.env.DB_PASSWORD) // undefined
    ```

    **Env parsing**

    As shown above, `VITE_SOME_KEY` is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.

    Also, Vite uses [dotenv-expand](https://github.com/motdotla/dotenv-expand) to expand variables out of the box. To learn more about the syntax, check out [their docs](https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow).

    Note that if you want to use `$` inside your environment value, you have to escape it with `\`.

    ``` javascript
    KEY=123
    NEW_KEY1=test$foo   # test
    NEW_KEY2=test\$foo  # test$foo
    NEW_KEY3=test$KEY   # test123
    ```

    If you want to customize the env variables prefix, see the [envPrefix](../config/shared-options#envprefix) option.

    **SECURITY NOTES**

    - `.env.*.local` files are local-only and can contain sensitive variables. You should add `*.local` to your `.gitignore` to avoid them being checked into git.

    - Since any variables exposed to your Vite source code will end up in your client bundle, `VITE_*` variables should *not* contain any sensitive information.
- name: 'Env Variables and Modes: APIs'
  id: guide/env-and-mode
  summary: Vite exposes env variables on the special import.meta.env object, which are statically replaced at build time
  description: "# Env Variables and Modes\n\n## Env Variables\n\nVite exposes env variables on the special **`import.meta.env`** object, which are statically replaced at build time. Some built-in variables are available in all cases:\n\n- **`import.meta.env.MODE`**: {string} the [mode](#modes) the app is running in.\n\n- **`import.meta.env.BASE_URL`**: {string} the base url the app is being served from. This is determined by the [`base` config option](../config/shared-options#base).\n\n- **`import.meta.env.PROD`**: {boolean} whether the app is running in production (running the dev server with `NODE_ENV='production'` or running an app built with `NODE_ENV='production'`).\n\n- **`import.meta.env.DEV`**: {boolean} whether the app is running in development (always the opposite of `import.meta.env.PROD`)\n\n- **`import.meta.env.SSR`**: {boolean} whether the app is running in the [server](ssr#conditional-logic).\n\n## `.env` Files\n\nVite uses [dotenv](https://github.com/motdotla/dotenv) to load additional environment variables from the following files in your [environment directory](../config/shared-options#envdir):\n\n``` javascript\n.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git\n```\n\n**Env Loading Priorities**\n\nAn env file for a specific mode (e.g. `.env.production`) will take higher priority than a generic one (e.g. `.env`).\n\nIn addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by `.env` files. For example, when running `VITE_SOME_KEY=123 vite build`.\n\n`.env` files are loaded at the start of Vite. Restart the server after making changes.\n\nLoaded env variables are also exposed to your client source code via `import.meta.env` as strings.\n\nTo prevent accidentally leaking env variables to the client, only variables prefixed with `VITE_` are exposed to your Vite-processed code. e.g. for the following env variables:\n\n``` javascript\nVITE_SOME_KEY=123\nDB_PASSWORD=foobar\n```\n\nOnly `VITE_SOME_KEY` will be exposed as `import.meta.env.VITE_SOME_KEY` to your client source code, but `DB_PASSWORD` will not.\n\njs\n\n``` javascript\nconsole.log(import.meta.env.VITE_SOME_KEY) // \"123\"\nconsole.log(import.meta.env.DB_PASSWORD) // undefined\n```\n\n**Env parsing**\n\nAs shown above, `VITE_SOME_KEY` is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.\n\nAlso, Vite uses [dotenv-expand](https://github.com/motdotla/dotenv-expand) to expand variables out of the box. To learn more about the syntax, check out [their docs](https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow).\n\nNote that if you want to use `$` inside your environment value, you have to escape it with `\\`.\n\n``` javascript\nKEY=123\nNEW_KEY1=test$foo   # test\nNEW_KEY2=test\\$foo  # test$foo\nNEW_KEY3=test$KEY   # test123\n```\n\nIf you want to customize the env variables prefix, see the [envPrefix](../config/shared-options#envprefix) option.\n\n**SECURITY NOTES**\n\n- `.env.*.local` files are local-only and can contain sensitive variables. You should add `*.local` to your `.gitignore` to avoid them being checked into git.\n\n- Since any variables exposed to your Vite source code will end up in your client bundle, `VITE_*` variables should *not* contain any sensitive information.\n\n### IntelliSense for TypeScript\n\nBy default, Vite provides type definitions for `import.meta.env` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with `VITE_`.\n\nTo achieve this, you can create an `vite-env.d.ts` in `src` directory, then augment `ImportMetaEnv` like this:\n\ntypescript\n\n``` javascript\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_APP_TITLE: string\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n```\n\nIf your code relies on types from browser environments such as [DOM](https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts) and [WebWorker](https://github.com/microsoft/TypeScript/blob/main/lib/lib.webworker.d.ts), you can update the [lib](https://www.typescriptlang.org/tsconfig#lib) field in `tsconfig.json`.\n\njson\n\n``` javascript\n{\n  \"lib\": [\"WebWorker\"]\n}\n```\n\n**Imports will break type augmentation**\n\nIf the `ImportMetaEnv` augmentation does not work, make sure you do not have any `import` statements in `vite-env.d.ts`. See the [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined) for more information.\n\n## HTML Env Replacement\n\nVite also supports replacing env variables in HTML files. Any properties in `import.meta.env` can be used in HTML files with a special `%ENV_NAME%` syntax:\n\nhtml\n\n``` javascript\n<h1>Vite is running in %MODE%</h1>\n<p>Using data from %VITE_API_URL%</p>\n```\n\nIf the env doesn't exist in `import.meta.env`, e.g. `%NON_EXISTENT%`, it will be ignored and not replaced, unlike `import.meta.env.NON_EXISTENT` in JS where it's replaced as `undefined`.\n\nGiven that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using [an existing userland plugin](https://github.com/vitejs/awesome-vite#transformers) or a custom plugin that implements the [`transformIndexHtml` hook](api-plugin#transformindexhtml).\n\n## Modes\n\nBy default, the dev server (`dev` command) runs in `development` mode and the `build` command runs in `production` mode.\n\nThis means when running `vite build`, it will load the env variables from `.env.production` if there is one:\n\n``` javascript\n# .env.production\nVITE_APP_TITLE=My App\n```\n\nIn your app, you can render the title using `import.meta.env.VITE_APP_TITLE`.\n\nIn some cases, you may want to run `vite build` with a different mode to render a different title. You can overwrite the default mode used for a command by passing the `--mode` option flag. For example, if you want to build your app for a staging mode:\n\nbash\n\n``` javascript\nvite build --mode staging\n```\n\nAnd create a `.env.staging` file:\n\n``` javascript\n# .env.staging\nVITE_APP_TITLE=My App (staging)\n```\n\nAs `vite build` runs a production build by default, you can also change this and run a development build by using a different mode and `.env` file configuration:\n\n``` javascript\n# .env.testing\nNODE_ENV=development\n```\n\n## NODE_ENV and Modes\n\nIt's important to note that `NODE_ENV` (`process.env.NODE_ENV`) and modes are two different concepts. Here's how different commands affect the `NODE_ENV` and mode:\n\n| Command                                              | NODE_ENV        | Mode            |\n|------------------------------------------------------|-----------------|-----------------|\n| `vite build`                                         | `\"production\"`  | `\"production\"`  |\n| `vite build --mode development`                      | `\"production\"`  | `\"development\"` |\n| `NODE_ENV=development vite build`                    | `\"development\"` | `\"production\"`  |\n| `NODE_ENV=development vite build --mode development` | `\"development\"` | `\"development\"` |\n\nThe different values of `NODE_ENV` and mode also reflect on its corresponding `import.meta.env` properties:\n\n| Command                | `import.meta.env.PROD` | `import.meta.env.DEV` |\n|------------------------|------------------------|-----------------------|\n| `NODE_ENV=production`  | `true`                 | `false`               |\n| `NODE_ENV=development` | `false`                | `true`                |\n| `NODE_ENV=other`       | `false`                | `true`                |\n\n| Command              | `import.meta.env.MODE` |\n|----------------------|------------------------|\n| `--mode production`  | `\"production\"`         |\n| `--mode development` | `\"development\"`        |\n| `--mode staging`     | `\"staging\"`            |\n\n**`NODE_ENV` in `.env` files**\n\n`NODE_ENV=...` can be set in the command, and also in your `.env` file. If `NODE_ENV` is specified in a `.env.[mode]` file, the mode can be used to control its value. However, both `NODE_ENV` and modes remain as two different concepts.\n\nThe main benefit with `NODE_ENV=...` in the command is that it allows Vite to detect the value early. It also allows you to read `process.env.NODE_ENV` in your Vite config as Vite can only load the env files once the config is evaluated.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode)"
- name: 'Env Variables and Modes: Env Variables'
  id: guide/env-and-mode#env-variables
  summary: Vite exposes env variables on the special import.meta.env object, which are statically replaced at build time
  belongs_to: Env Variables and Modes
  description: |-
    ## Env Variables

    Vite exposes env variables on the special **`import.meta.env`** object, which are statically replaced at build time. Some built-in variables are available in all cases:

    - **`import.meta.env.MODE`**: {string} the [mode](#modes) the app is running in.

    - **`import.meta.env.BASE_URL`**: {string} the base url the app is being served from. This is determined by the [`base` config option](../config/shared-options#base).

    - **`import.meta.env.PROD`**: {boolean} whether the app is running in production (running the dev server with `NODE_ENV='production'` or running an app built with `NODE_ENV='production'`).

    - **`import.meta.env.DEV`**: {boolean} whether the app is running in development (always the opposite of `import.meta.env.PROD`)

    - **`import.meta.env.SSR`**: {boolean} whether the app is running in the [server](ssr#conditional-logic).
- name: 'Env Variables and Modes: Guide'
  id: guide/env-and-mode
  summary: Vite exposes env variables on the special import.meta.env object, which are statically replaced at build time
  description: "# Env Variables and Modes\n\n## Env Variables\n\nVite exposes env variables on the special **`import.meta.env`** object, which are statically replaced at build time. Some built-in variables are available in all cases:\n\n- **`import.meta.env.MODE`**: {string} the [mode](#modes) the app is running in.\n\n- **`import.meta.env.BASE_URL`**: {string} the base url the app is being served from. This is determined by the [`base` config option](../config/shared-options#base).\n\n- **`import.meta.env.PROD`**: {boolean} whether the app is running in production (running the dev server with `NODE_ENV='production'` or running an app built with `NODE_ENV='production'`).\n\n- **`import.meta.env.DEV`**: {boolean} whether the app is running in development (always the opposite of `import.meta.env.PROD`)\n\n- **`import.meta.env.SSR`**: {boolean} whether the app is running in the [server](ssr#conditional-logic).\n\n## `.env` Files\n\nVite uses [dotenv](https://github.com/motdotla/dotenv) to load additional environment variables from the following files in your [environment directory](../config/shared-options#envdir):\n\n``` javascript\n.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git\n```\n\n**Env Loading Priorities**\n\nAn env file for a specific mode (e.g. `.env.production`) will take higher priority than a generic one (e.g. `.env`).\n\nIn addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by `.env` files. For example, when running `VITE_SOME_KEY=123 vite build`.\n\n`.env` files are loaded at the start of Vite. Restart the server after making changes.\n\nLoaded env variables are also exposed to your client source code via `import.meta.env` as strings.\n\nTo prevent accidentally leaking env variables to the client, only variables prefixed with `VITE_` are exposed to your Vite-processed code. e.g. for the following env variables:\n\n``` javascript\nVITE_SOME_KEY=123\nDB_PASSWORD=foobar\n```\n\nOnly `VITE_SOME_KEY` will be exposed as `import.meta.env.VITE_SOME_KEY` to your client source code, but `DB_PASSWORD` will not.\n\njs\n\n``` javascript\nconsole.log(import.meta.env.VITE_SOME_KEY) // \"123\"\nconsole.log(import.meta.env.DB_PASSWORD) // undefined\n```\n\n**Env parsing**\n\nAs shown above, `VITE_SOME_KEY` is a number but returns a string when parsed. The same would also happen for boolean env variables. Make sure to convert to the desired type when using it in your code.\n\nAlso, Vite uses [dotenv-expand](https://github.com/motdotla/dotenv-expand) to expand variables out of the box. To learn more about the syntax, check out [their docs](https://github.com/motdotla/dotenv-expand#what-rules-does-the-expansion-engine-follow).\n\nNote that if you want to use `$` inside your environment value, you have to escape it with `\\`.\n\n``` javascript\nKEY=123\nNEW_KEY1=test$foo   # test\nNEW_KEY2=test\\$foo  # test$foo\nNEW_KEY3=test$KEY   # test123\n```\n\nIf you want to customize the env variables prefix, see the [envPrefix](../config/shared-options#envprefix) option.\n\n**SECURITY NOTES**\n\n- `.env.*.local` files are local-only and can contain sensitive variables. You should add `*.local` to your `.gitignore` to avoid them being checked into git.\n\n- Since any variables exposed to your Vite source code will end up in your client bundle, `VITE_*` variables should *not* contain any sensitive information.\n\n### IntelliSense for TypeScript\n\nBy default, Vite provides type definitions for `import.meta.env` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with `VITE_`.\n\nTo achieve this, you can create an `vite-env.d.ts` in `src` directory, then augment `ImportMetaEnv` like this:\n\ntypescript\n\n``` javascript\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_APP_TITLE: string\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n```\n\nIf your code relies on types from browser environments such as [DOM](https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts) and [WebWorker](https://github.com/microsoft/TypeScript/blob/main/lib/lib.webworker.d.ts), you can update the [lib](https://www.typescriptlang.org/tsconfig#lib) field in `tsconfig.json`.\n\njson\n\n``` javascript\n{\n  \"lib\": [\"WebWorker\"]\n}\n```\n\n**Imports will break type augmentation**\n\nIf the `ImportMetaEnv` augmentation does not work, make sure you do not have any `import` statements in `vite-env.d.ts`. See the [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined) for more information.\n\n## HTML Env Replacement\n\nVite also supports replacing env variables in HTML files. Any properties in `import.meta.env` can be used in HTML files with a special `%ENV_NAME%` syntax:\n\nhtml\n\n``` javascript\n<h1>Vite is running in %MODE%</h1>\n<p>Using data from %VITE_API_URL%</p>\n```\n\nIf the env doesn't exist in `import.meta.env`, e.g. `%NON_EXISTENT%`, it will be ignored and not replaced, unlike `import.meta.env.NON_EXISTENT` in JS where it's replaced as `undefined`.\n\nGiven that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using [an existing userland plugin](https://github.com/vitejs/awesome-vite#transformers) or a custom plugin that implements the [`transformIndexHtml` hook](api-plugin#transformindexhtml).\n\n## Modes\n\nBy default, the dev server (`dev` command) runs in `development` mode and the `build` command runs in `production` mode.\n\nThis means when running `vite build`, it will load the env variables from `.env.production` if there is one:\n\n``` javascript\n# .env.production\nVITE_APP_TITLE=My App\n```\n\nIn your app, you can render the title using `import.meta.env.VITE_APP_TITLE`.\n\nIn some cases, you may want to run `vite build` with a different mode to render a different title. You can overwrite the default mode used for a command by passing the `--mode` option flag. For example, if you want to build your app for a staging mode:\n\nbash\n\n``` javascript\nvite build --mode staging\n```\n\nAnd create a `.env.staging` file:\n\n``` javascript\n# .env.staging\nVITE_APP_TITLE=My App (staging)\n```\n\nAs `vite build` runs a production build by default, you can also change this and run a development build by using a different mode and `.env` file configuration:\n\n``` javascript\n# .env.testing\nNODE_ENV=development\n```\n\n## NODE_ENV and Modes\n\nIt's important to note that `NODE_ENV` (`process.env.NODE_ENV`) and modes are two different concepts. Here's how different commands affect the `NODE_ENV` and mode:\n\n| Command                                              | NODE_ENV        | Mode            |\n|------------------------------------------------------|-----------------|-----------------|\n| `vite build`                                         | `\"production\"`  | `\"production\"`  |\n| `vite build --mode development`                      | `\"production\"`  | `\"development\"` |\n| `NODE_ENV=development vite build`                    | `\"development\"` | `\"production\"`  |\n| `NODE_ENV=development vite build --mode development` | `\"development\"` | `\"development\"` |\n\nThe different values of `NODE_ENV` and mode also reflect on its corresponding `import.meta.env` properties:\n\n| Command                | `import.meta.env.PROD` | `import.meta.env.DEV` |\n|------------------------|------------------------|-----------------------|\n| `NODE_ENV=production`  | `true`                 | `false`               |\n| `NODE_ENV=development` | `false`                | `true`                |\n| `NODE_ENV=other`       | `false`                | `true`                |\n\n| Command              | `import.meta.env.MODE` |\n|----------------------|------------------------|\n| `--mode production`  | `\"production\"`         |\n| `--mode development` | `\"development\"`        |\n| `--mode staging`     | `\"staging\"`            |\n\n**`NODE_ENV` in `.env` files**\n\n`NODE_ENV=...` can be set in the command, and also in your `.env` file. If `NODE_ENV` is specified in a `.env.[mode]` file, the mode can be used to control its value. However, both `NODE_ENV` and modes remain as two different concepts.\n\nThe main benefit with `NODE_ENV=...` in the command is that it allows Vite to detect the value early. It also allows you to read `process.env.NODE_ENV` in your Vite config as Vite can only load the env files once the config is evaluated.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode)"
- name: 'Env Variables and Modes: HTML Env Replacement'
  id: guide/env-and-mode#html-env-replacement
  summary: Vite also supports replacing env variables in HTML files
  belongs_to: Env Variables and Modes
  description: |-
    ## HTML Env Replacement

    Vite also supports replacing env variables in HTML files. Any properties in `import.meta.env` can be used in HTML files with a special `%ENV_NAME%` syntax:

    html

    ``` javascript
    <h1>Vite is running in %MODE%</h1>
    <p>Using data from %VITE_API_URL%</p>
    ```

    If the env doesn't exist in `import.meta.env`, e.g. `%NON_EXISTENT%`, it will be ignored and not replaced, unlike `import.meta.env.NON_EXISTENT` in JS where it's replaced as `undefined`.

    Given that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using [an existing userland plugin](https://github.com/vitejs/awesome-vite#transformers) or a custom plugin that implements the [`transformIndexHtml` hook](api-plugin#transformindexhtml).
- name: 'Env Variables and Modes: IntelliSense for TypeScript'
  id: guide/env-and-mode#intellisense-for-typescript
  summary: By default, Vite provides type definitions for import.meta.env in vite/client.d.ts
  belongs_to: Env Variables and Modes
  description: |-
    ### IntelliSense for TypeScript

    By default, Vite provides type definitions for `import.meta.env` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). While you can define more custom env variables in `.env.[mode]` files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with `VITE_`.

    To achieve this, you can create an `vite-env.d.ts` in `src` directory, then augment `ImportMetaEnv` like this:

    typescript

    ``` javascript
    /// <reference types="vite/client" />

    interface ImportMetaEnv {
      readonly VITE_APP_TITLE: string
      // more env variables...
    }

    interface ImportMeta {
      readonly env: ImportMetaEnv
    }
    ```

    If your code relies on types from browser environments such as [DOM](https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts) and [WebWorker](https://github.com/microsoft/TypeScript/blob/main/lib/lib.webworker.d.ts), you can update the [lib](https://www.typescriptlang.org/tsconfig#lib) field in `tsconfig.json`.

    json

    ``` javascript
    {
      "lib": ["WebWorker"]
    }
    ```

    **Imports will break type augmentation**

    If the `ImportMetaEnv` augmentation does not work, make sure you do not have any `import` statements in `vite-env.d.ts`. See the [TypeScript documentation](https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined) for more information.
- name: 'Env Variables and Modes: Modes'
  id: guide/env-and-mode#modes
  summary: By default, the dev server (dev command) runs in development mode and the build command runs in production mode
  belongs_to: Env Variables and Modes
  description: |-
    ## Modes

    By default, the dev server (`dev` command) runs in `development` mode and the `build` command runs in `production` mode.

    This means when running `vite build`, it will load the env variables from `.env.production` if there is one:

    ``` javascript
    # .env.production
    VITE_APP_TITLE=My App
    ```

    In your app, you can render the title using `import.meta.env.VITE_APP_TITLE`.

    In some cases, you may want to run `vite build` with a different mode to render a different title. You can overwrite the default mode used for a command by passing the `--mode` option flag. For example, if you want to build your app for a staging mode:

    bash

    ``` javascript
    vite build --mode staging
    ```

    And create a `.env.staging` file:

    ``` javascript
    # .env.staging
    VITE_APP_TITLE=My App (staging)
    ```

    As `vite build` runs a production build by default, you can also change this and run a development build by using a different mode and `.env` file configuration:

    ``` javascript
    # .env.testing
    NODE_ENV=development
    ```
- name: 'Env Variables and Modes: NODE_ENV and Modes'
  id: guide/env-and-mode#node-env-and-modes
  summary: It's important to note that NODE_ENV (process.env.NODE_ENV) and modes are two different concepts
  belongs_to: Env Variables and Modes
  description: "## NODE_ENV and Modes\n\nIt's important to note that `NODE_ENV` (`process.env.NODE_ENV`) and modes are two different concepts. Here's how different commands affect the `NODE_ENV` and mode:\n\n| Command                                              | NODE_ENV        | Mode            |\n|------------------------------------------------------|-----------------|-----------------|\n| `vite build`                                         | `\"production\"`  | `\"production\"`  |\n| `vite build --mode development`                      | `\"production\"`  | `\"development\"` |\n| `NODE_ENV=development vite build`                    | `\"development\"` | `\"production\"`  |\n| `NODE_ENV=development vite build --mode development` | `\"development\"` | `\"development\"` |\n\nThe different values of `NODE_ENV` and mode also reflect on its corresponding `import.meta.env` properties:\n\n| Command                | `import.meta.env.PROD` | `import.meta.env.DEV` |\n|------------------------|------------------------|-----------------------|\n| `NODE_ENV=production`  | `true`                 | `false`               |\n| `NODE_ENV=development` | `false`                | `true`                |\n| `NODE_ENV=other`       | `false`                | `true`                |\n\n| Command              | `import.meta.env.MODE` |\n|----------------------|------------------------|\n| `--mode production`  | `\"production\"`         |\n| `--mode development` | `\"development\"`        |\n| `--mode staging`     | `\"staging\"`            |\n\n**`NODE_ENV` in `.env` files**\n\n`NODE_ENV=...` can be set in the command, and also in your `.env` file. If `NODE_ENV` is specified in a `.env.[mode]` file, the mode can be used to control its value. However, both `NODE_ENV` and modes remain as two different concepts.\n\nThe main benefit with `NODE_ENV=...` in the command is that it allows Vite to detect the value early. It also allows you to read `process.env.NODE_ENV` in your Vite config as Vite can only load the env files once the config is evaluated.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/env-and-mode](https://vitejs.dev/guide/env-and-mode)"
- name: Features
  id: guide/features
  summary: At the very basic level, developing using Vite is not that different from using a static file server
  description: "# Features\n\nAt the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.\n\n## NPM Dependency Resolving and Pre-Bundling\n\nNative ES imports do not support bare module imports like the following:\n\njs\n\n``` javascript\nimport { someMethod } from 'my-dep'\n```\n\nThe above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:\n\n1.  [Pre-bundle](dep-pre-bundling) them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with [esbuild](http://esbuild.github.io/) and makes Vite's cold start time significantly faster than any JavaScript-based bundler.\n\n2.  Rewrite the imports to valid URLs like `/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd` so that the browser can import them properly.\n\n**Dependencies are Strongly Cached**\n\nVite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps [here](dep-pre-bundling#browser-cache).\n\n## Hot Module Replacement\n\nVite provides an [HMR API](api-hmr) over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for [Vue Single File Components](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) and [React Fast Refresh](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react). There are also official integrations for Preact via [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite).\n\nNote you don't need to manually set these up - when you [create an app via `create-vite`](index), the selected templates would have these pre-configured for you already.\n\n## TypeScript\n\nVite supports importing `.ts` files out of the box.\n\n### Transpile Only\n\nNote that Vite only performs transpilation on `.ts` files and does **NOT** perform type checking. It assumes type checking is taken care of by your IDE and build process.\n\nThe reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.\n\nVite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.\n\n- For production builds, you can run `tsc --noEmit` in addition to Vite's build command.\n\n- During development, if you need more than IDE hints, we recommend running `tsc --noEmit --watch` in a separate process, or use [vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker) if you prefer having type errors directly reported in the browser.\n\nVite uses [esbuild](https://github.com/evanw/esbuild) to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla `tsc`, and HMR updates can reflect in the browser in under 50ms.\n\nUse the [Type-Only Imports and Export](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:\n\nts\n\n``` javascript\nimport type { T } from 'only/types'\nexport type { T }\n```\n\n### TypeScript Compiler Options\n\nSome configuration fields under `compilerOptions` in `tsconfig.json` require special attention.\n\n#### `isolatedModules`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#isolatedModules)\n\nShould be set to `true`.\n\nIt is because `esbuild` only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.\n\nYou must set `\"isolatedModules\": true` in your `tsconfig.json` under `compilerOptions`, so that TS will warn you against the features that do not work with isolated transpilation.\n\nIf a dependency doesn't work well with `\"isolatedModules\": true`. You can use `\"skipLibCheck\": true` to temporarily suppress the errors until it is fixed upstream.\n\n#### `useDefineForClassFields`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n\nStarting from Vite 2.5.0, the default value will be `true` if the TypeScript target is `ESNext` or `ES2022` or newer. It is consistent with the [behavior of `tsc` 4.3.2 and later](https://github.com/microsoft/TypeScript/pull/42663). It is also the standard ECMAScript runtime behavior.\n\nOther TypeScript targets will default to `false`.\n\nBut it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the [TypeScript 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).\n\nIf you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.\n\nMost libraries expect `\"useDefineForClassFields\": true`, such as [MobX](https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties).\n\nBut a few libraries haven't transitioned to this new default yet, including [`lit-element`](https://github.com/lit/lit-element/issues/1030). Please explicitly set `useDefineForClassFields` to `false` in these cases.\n\n#### `target`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#target)\n\nVite does not transpile TypeScript with the configured `target` value by default, following the same behaviour as `esbuild`.\n\nThe [`esbuild.target`](../config/shared-options#esbuild) option can be used instead, which defaults to `esnext` for minimal transpilation. In builds, the [`build.target`](../config/build-options#build-target) option takes higher priority and can also be set if needed.\n\n**`useDefineForClassFields`**\n\nIf `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.\n\nAs such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.\n\n#### Other Compiler Options Affecting the Build Result\n\n- [`extends`](https://www.typescriptlang.org/tsconfig#extends)\n- [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)\n- [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n- [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax)\n- [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n- [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)\n- [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)\n\n**`skipLibCheck`**\n\nVite starter templates have `\"skipLibCheck\": \"true\"` by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at [vuejs/vue-cli#5688](https://github.com/vuejs/vue-cli/pull/5688).\n\n### Client Types\n\nVite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a `d.ts` declaration file:\n\ntypescript\n\n``` javascript\n/// <reference types=\"vite/client\" />\n```\n\nAlternatively, you can add `vite/client` to `compilerOptions.types` inside `tsconfig.json`:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\"vite/client\"]\n  }\n}\n```\n\nThis will provide the following type shims:\n\n- Asset imports (e.g. importing an `.svg` file)\n- Types for the Vite-injected [env variables](env-and-mode#env-variables) on `import.meta.env`\n- Types for the [HMR API](api-hmr) on `import.meta.hot`\n\n**TIP**\n\nTo override the default typing, add a type definition file that contains your typings. Then, add the type reference before `vite/client`.\n\nFor example, to make the default import of `*.svg` a React component:\n\n- `vite-env-override.d.ts` (the file that contains your typings):\n  ts\n  ``` javascript\n  declare module '*.svg' {\n    const content: React.FC<React.SVGProps<SVGElement>>\n    export default content\n  }\n  ```\n- The file containing the reference to `vite/client`:\n  ts\n  ``` javascript\n  /// <reference types=\"./vite-env-override.d.ts\" />\n  /// <reference types=\"vite/client\" />\n  ```\n\n## Vue\n\nVite provides first-class Vue support:\n\n- Vue 3 SFC support via [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)\n- Vue 3 JSX support via [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)\n- Vue 2.7 SFC support via [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2)\n- Vue 2.7 JSX support via [@vitejs/plugin-vue2-jsx](https://github.com/vitejs/vite-plugin-vue2-jsx)\n\n## JSX\n\n`.jsx` and `.tsx` files are also supported out of the box. JSX transpilation is also handled via [esbuild](https://esbuild.github.io).\n\nVue users should use the official [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.\n\nIf using JSX without React or Vue, custom `jsxFactory` and `jsxFragment` can be configured using the [`esbuild` option](../config/shared-options#esbuild). For example for Preact:\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n```\n\nMore details in [esbuild docs](https://esbuild.github.io/content-types/#jsx).\n\nYou can inject the JSX helpers using `jsxInject` (which is a Vite-only option) to avoid manual imports:\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n```\n\n## CSS\n\nImporting `.css` files will inject its content to the page via a `<style>` tag with HMR support.\n\n### `@import` Inlining and Rebasing\n\nVite is pre-configured to support CSS `@import` inlining via `postcss-import`. Vite aliases are also respected for CSS `@import`. In addition, all CSS `url()` references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.\n\n`@import` aliases and URL rebasing are also supported for Sass and Less files (see [CSS Pre-processors](#css-pre-processors)).\n\n### PostCSS\n\nIf the project contains valid PostCSS config (any format supported by [postcss-load-config](https://github.com/postcss/postcss-load-config), e.g. `postcss.config.js`), it will be automatically applied to all imported CSS.\n\nNote that CSS minification will run after PostCSS and will use [`build.cssTarget`](../config/build-options#build-csstarget) option.\n\n### CSS Modules\n\nAny CSS file ending with `.module.css` is considered a [CSS modules file](https://github.com/css-modules/css-modules). Importing such a file will return the corresponding module object:\n\ncss\n\n``` javascript\n/* example.module.css */\n.red {\n  color: red;\n}\n```\n\njs\n\n``` javascript\nimport classes from './example.module.css'\ndocument.getElementById('foo').className = classes.red\n```\n\nCSS modules behavior can be configured via the [`css.modules` option](../config/shared-options#css-modules).\n\nIf `css.modules.localsConvention` is set to enable camelCase locals (e.g. `localsConvention: 'camelCaseOnly'`), you can also use named imports:\n\njs\n\n``` javascript\n// .apply-color -> applyColor\nimport { applyColor } from './example.module.css'\ndocument.getElementById('foo').className = applyColor\n```\n\n### CSS Pre-processors\n\nBecause Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting)) and author plain, future-standards-compliant CSS.\n\nThat said, Vite does provide built-in support for `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:\n\nbash\n\n``` javascript\n# .scss and .sass\nnpm add -D sass\n\n# .less\nnpm add -D less\n\n# .styl and .stylus\nnpm add -D stylus\n```\n\nIf using Vue single file components, this also automatically enables `<style lang=\"sass\">` et al.\n\nVite improves `@import` resolving for Sass and Less so that Vite aliases are also respected. In addition, relative `url()` references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.\n\n`@import` alias and url rebasing are not supported for Stylus due to its API constraints.\n\nYou can also use CSS modules combined with pre-processors by prepending `.module` to the file extension, for example `style.module.scss`.\n\n### Disabling CSS injection into the page\n\nThe automatic injection of CSS contents can be turned off via the `?inline` query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.\n\njs\n\n``` javascript\nimport './foo.css' // will be injected into the page\nimport otherStyles from './bar.css?inline' // will not be injected\n```\n\n**NOTE**\n\nDefault and named imports from CSS files (e.g `import style from './foo.css'`) are removed since Vite 5. Use the `?inline` query instead.\n\n### Lightning CSS\n\nStarting from Vite 4.4, there is experimental support for [Lightning CSS](https://lightningcss.dev/). You can opt into it by adding [`css.transformer: 'lightningcss'`](../config/shared-options#css-transformer) to your config file and install the optional [`lightningcss`](https://www.npmjs.com/package/lightningcss) dependency:\n\nbash\n\n``` javascript\nnpm add -D lightningcss\n```\n\nIf enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the [`css.lightningcss`](../config/shared-options#css-lightningcss) config option.\n\nTo configure CSS Modules, you'll use [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) instead of [`css.modules`](../config/shared-options#css-modules) (which configures the way PostCSS handles CSS modules).\n\nBy default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with [`build.cssMinify: 'lightningcss'`](../config/build-options#build-cssminify).\n\n**NOTE**\n\n[CSS Pre-processors](#css-pre-processors) aren't supported when using Lightning CSS.\n\n## Static Assets\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\n\n``` javascript\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nSpecial queries can modify how assets are loaded:\n\njs\n\n``` javascript\n// Explicitly load assets as URL\nimport assetAsURL from './asset.js?url'\n```\n\njs\n\n``` javascript\n// Load assets as strings\nimport assetAsString from './shader.glsl?raw'\n```\n\njs\n\n``` javascript\n// Load Web Workers\nimport Worker from './worker.js?worker'\n```\n\njs\n\n``` javascript\n// Web Workers inlined as base64 strings at build time\nimport InlineWorker from './worker.js?worker&inline'\n```\n\nMore details in [Static Asset Handling](assets).\n\n## JSON\n\nJSON files can be directly imported - named imports are also supported:\n\njs\n\n``` javascript\n// import the entire object\nimport json from './example.json'\n// import a root field as named exports - helps with tree-shaking!\nimport { field } from './example.json'\n```\n\n## Glob Import\n\nVite supports importing multiple modules from the file system via the special `import.meta.glob` function:\n\njs\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js')\n```\n\nThe above will be transformed into the following:\n\njs\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n  './dir/bar.js': () => import('./dir/bar.js'),\n}\n```\n\nYou can then iterate over the keys of the `modules` object to access the corresponding modules:\n\njs\n\n``` javascript\nfor (const path in modules) {\n  modules[path]().then((mod) => {\n    console.log(path, mod)\n  })\n}\n```\n\nMatched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass `{ eager: true }` as the second argument:\n\njs\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', { eager: true })\n```\n\nThe above will be transformed into the following:\n\njs\n\n``` javascript\n// code produced by vite\nimport * as __glob__0_0 from './dir/foo.js'\nimport * as __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\n### Multiple Patterns\n\nThe first argument can be an array of globs, for example\n\njs\n\n``` javascript\nconst modules = import.meta.glob(['./dir/*.js', './another/*.js'])\n```\n\n### Negative Patterns\n\nNegative glob patterns are also supported (prefixed with `!`). To ignore some files from the result, you can add exclude glob patterns to the first argument:\n\njs\n\n``` javascript\nconst modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])\n```\n\njs\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n}\n```\n\n#### Named Imports\n\nIt's possible to only import parts of the modules with the `import` options.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', { import: 'setup' })\n```\n\nts\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),\n  './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),\n}\n```\n\nWhen combined with `eager` it's even possible to have tree-shaking enabled for those modules.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'setup',\n  eager: true,\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nimport { setup as __glob__0_0 } from './dir/foo.js'\nimport { setup as __glob__0_1 } from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\nSet `import` to `default` to import the default export.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'default',\n  eager: true,\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nimport __glob__0_0 from './dir/foo.js'\nimport __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\n#### Custom Queries\n\nYou can also use the `query` option to provide queries to imports, for example, to import assets [as a string](assets#importing-asset-as-string) or [as a url](assets#importing-asset-as-url):\n\nts\n\n``` javascript\nconst moduleStrings = import.meta.glob('./dir/*.svg', {\n  query: '?raw',\n  import: 'default',\n})\nconst moduleUrls = import.meta.glob('./dir/*.svg', {\n  query: '?url',\n  import: 'default',\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nconst moduleStrings = {\n  './dir/foo.svg': () => import('./dir/foo.js?raw').then((m) => m['default']),\n  './dir/bar.svg': () => import('./dir/bar.js?raw').then((m) => m['default']),\n}\nconst moduleUrls = {\n  './dir/foo.svg': () => import('./dir/foo.js?url').then((m) => m['default']),\n  './dir/bar.svg': () => import('./dir/bar.js?url').then((m) => m['default']),\n}\n```\n\nYou can also provide custom queries for other plugins to consume:\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  query: { foo: 'bar', bar: true },\n})\n```\n\n### Glob Import Caveats\n\nNote that:\n\n- This is a Vite-only feature and is not a web or ES standard.\n- The glob patterns are treated like import specifiers: they must be either relative (start with `./`) or absolute (start with `/`, resolved relative to project root) or an alias path (see [`resolve.alias` option](../config/shared-options#resolve-alias)).\n- The glob matching is done via [`fast-glob`](https://github.com/mrmlnc/fast-glob) - check out its documentation for [supported glob patterns](https://github.com/mrmlnc/fast-glob#pattern-syntax).\n- You should also be aware that all the arguments in the `import.meta.glob` must be **passed as literals**. You can NOT use variables or expressions in them.\n\n## Dynamic Import\n\nSimilar to [glob import](#glob-import), Vite also supports dynamic import with variables.\n\nts\n\n``` javascript\nconst module = await import(`./dir/${file}.js`)\n```\n\nNote that variables only represent file names one level deep. If `file` is `'foo/bar'`, the import would fail. For more advanced usage, you can use the [glob import](#glob-import) feature.\n\n## WebAssembly\n\nPre-compiled `.wasm` files can be imported with `?init`. The default export will be an initialization function that returns a Promise of the [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance):\n\njs\n\n``` javascript\nimport init from './example.wasm?init'\n\ninit().then((instance) => {\n  instance.exports.test()\n})\n```\n\nThe init function can also take an importObject which is passed along to [`WebAssembly.instantiate`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate) as its second argument:\n\njs\n\n``` javascript\ninit({\n  imports: {\n    someFunc: () => {\n      /* ... */\n    },\n  },\n}).then(() => {\n  /* ... */\n})\n```\n\nIn the production build, `.wasm` files smaller than `assetInlineLimit` will be inlined as base64 strings. Otherwise, they will be treated as a [static asset](assets) and fetched on-demand.\n\n**NOTE**\n\n[ES Module Integration Proposal for WebAssembly](https://github.com/WebAssembly/esm-integration) is not currently supported. Use [`vite-plugin-wasm`](https://github.com/Menci/vite-plugin-wasm) or other community plugins to handle this.\n\n### Accessing the WebAssembly Module\n\nIf you need access to the `Module` object, e.g. to instantiate it multiple times, use an [explicit URL import](assets#explicit-url-imports) to resolve the asset, and then perform the instantiation:\n\njs\n\n``` javascript\nimport wasmUrl from 'foo.wasm?url'\n\nconst main = async () => {\n  const responsePromise = fetch(wasmUrl)\n  const { module, instance } =\n    await WebAssembly.instantiateStreaming(responsePromise)\n  /* ... */\n}\n\nmain()\n```\n\n### Fetching the module in Node.js\n\nIn SSR, the `fetch()` happening as part of the `?init` import, may fail with `TypeError: Invalid URL`. See the issue [Support wasm in SSR](https://github.com/vitejs/vite/issues/8882).\n\nHere is an alternative, assuming the project base is the current directory:\n\njs\n\n``` javascript\nimport wasmUrl from 'foo.wasm?url'\nimport { readFile } from 'node:fs/promises'\n\nconst main = async () => {\n  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default\n  const buffer = await readFile('.' + resolvedUrl)\n  const { instance } = await WebAssembly.instantiate(buffer, {\n    /* ... */\n  })\n  /* ... */\n}\n\nmain()\n```\n\n## Web Workers\n\n### Import with Constructors\n\nA web worker script can be imported using [`new Worker()`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) and [`new SharedWorker()`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker). Compared to the worker suffixes, this syntax leans closer to the standards and is the **recommended** way to create workers.\n\nts\n\n``` javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url))\n```\n\nThe worker constructor also accepts options, which can be used to create \"module\" workers:\n\nts\n\n``` javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url), {\n  type: 'module',\n})\n```\n\nThe worker detection will only work if the `new URL()` constructor is used directly inside the `new Worker()` declaration. Additionally, all options parameters must be static values (i.e. string literals).\n\n### Import with Query Suffixes\n\nA web worker script can be directly imported by appending `?worker` or `?sharedworker` to the import request. The default export will be a custom worker constructor:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker'\n\nconst worker = new MyWorker()\n```\n\nThe worker script can also use ESM `import` statements instead of `importScripts()`. **Note**: During development this relies on [browser native support](https://caniuse.com/?search=module%20worker), but for the production build it is compiled away.\n\nBy default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the `inline` query:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker&inline'\n```\n\nIf you wish to retrieve the worker as a URL, add the `url` query:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker&url'\n```\n\nSee [Worker Options](../config/worker-options) for details on configuring the bundling of all workers.\n\n## Content Security Policy (CSP)\n\nTo deploy CSP, certain directives or configs must be set due to Vite's internals.\n\n### [`'nonce-{RANDOM}'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value)\n\nWhen [`html.cspNonce`](../config/shared-options#html-cspnonce) is set, Vite adds a nonce attribute with the specified value to any `<script>` and `<style>` tags, as well as `<link>` tags for stylesheets and module preloading. Additionally, when this option is set, Vite will inject a meta tag (`<meta property=\"csp-nonce\" nonce=\"PLACEHOLDER\" />`).\n\nThe nonce value of a meta tag with `property=\"csp-nonce\"` will be used by Vite whenever necessary during both dev and after build.\n\n**WARNING**\n\nEnsure that you replace the placeholder with a unique value for each request. This is important to prevent bypassing a resource's policy, which can otherwise be easily done.\n\n### [`data:`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20(not%20recommended).-,data%3A,-Allows%20data%3A)\n\nBy default, during build, Vite inlines small assets as data URIs. Allowing `data:` for related directives (e.g. [`img-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src), [`font-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)), or, disabling it by setting [`build.assetsInlineLimit: 0`](../config/build-options#build-assetsinlinelimit) is necessary.\n\n**WARNING**\n\nDo not allow `data:` for [`script-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src). It will allow injection of arbitrary scripts.\n\n## Build Optimizations\n\n> Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.\n\n### CSS Code Splitting\n\nVite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a `<link>` tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.).\n\nIf you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting [`build.cssCodeSplit`](../config/build-options#build-csscodesplit) to `false`.\n\n### Preload Directives Generation\n\nVite automatically generates `<link rel=\"modulepreload\">` directives for entry chunks and their direct imports in the built HTML.\n\n### Async Chunk Loading Optimization\n\nIn real world applications, Rollup often generates \"common\" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:\n\nIn the non-optimized scenarios, when async chunk `A` is imported, the browser will have to request and parse `A` before it can figure out that it also needs the common chunk `C`. This results in an extra network roundtrip:\n\n``` javascript\nEntry ---> A ---> C\n```\n\nVite automatically rewrites code-split dynamic import calls with a preload step so that when `A` is requested, `C` is fetched **in parallel**:\n\n``` javascript\nEntry ---> (A + C)\n```\n\nIt is possible for `C` to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/features](https://vitejs.dev/guide/features)"
- name: 'Features: ''nonce-{RANDOM}'''
  id: guide/features#nonce-random
  summary: When html.cspNonce is set, Vite adds a nonce attribute with the specified value to any <script> and <style> tags, as well as <link> tags for stylesheets and module preloading
  belongs_to: Features
  description: |-
    ### [`'nonce-{RANDOM}'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value)

    When [`html.cspNonce`](../config/shared-options#html-cspnonce) is set, Vite adds a nonce attribute with the specified value to any `<script>` and `<style>` tags, as well as `<link>` tags for stylesheets and module preloading. Additionally, when this option is set, Vite will inject a meta tag (`<meta property="csp-nonce" nonce="PLACEHOLDER" />`).

    The nonce value of a meta tag with `property="csp-nonce"` will be used by Vite whenever necessary during both dev and after build.

    **WARNING**

    Ensure that you replace the placeholder with a unique value for each request. This is important to prevent bypassing a resource's policy, which can otherwise be easily done.
- name: 'Features: @import Inlining and Rebasing'
  id: guide/features#import-inlining-and-rebasing
  summary: Vite is pre-configured to support CSS @import inlining via postcss-import
  belongs_to: Features
  description: |-
    ### `@import` Inlining and Rebasing

    Vite is pre-configured to support CSS `@import` inlining via `postcss-import`. Vite aliases are also respected for CSS `@import`. In addition, all CSS `url()` references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.

    `@import` aliases and URL rebasing are also supported for Sass and Less files (see [CSS Pre-processors](#css-pre-processors)).
- name: 'Features: Accessing the WebAssembly Module'
  id: guide/features#accessing-the-webassembly-module
  summary: If you need access to the Module object, e.g
  belongs_to: Features
  description: |-
    ### Accessing the WebAssembly Module

    If you need access to the `Module` object, e.g. to instantiate it multiple times, use an [explicit URL import](assets#explicit-url-imports) to resolve the asset, and then perform the instantiation:

    js

    ``` javascript
    import wasmUrl from 'foo.wasm?url'

    const main = async () => {
      const responsePromise = fetch(wasmUrl)
      const { module, instance } =
        await WebAssembly.instantiateStreaming(responsePromise)
      /* ... */
    }

    main()
    ```
- name: 'Features: APIs'
  id: guide/features
  summary: At the very basic level, developing using Vite is not that different from using a static file server
  description: "# Features\n\nAt the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.\n\n## NPM Dependency Resolving and Pre-Bundling\n\nNative ES imports do not support bare module imports like the following:\n\njs\n\n``` javascript\nimport { someMethod } from 'my-dep'\n```\n\nThe above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:\n\n1.  [Pre-bundle](dep-pre-bundling) them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with [esbuild](http://esbuild.github.io/) and makes Vite's cold start time significantly faster than any JavaScript-based bundler.\n\n2.  Rewrite the imports to valid URLs like `/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd` so that the browser can import them properly.\n\n**Dependencies are Strongly Cached**\n\nVite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps [here](dep-pre-bundling#browser-cache).\n\n## Hot Module Replacement\n\nVite provides an [HMR API](api-hmr) over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for [Vue Single File Components](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) and [React Fast Refresh](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react). There are also official integrations for Preact via [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite).\n\nNote you don't need to manually set these up - when you [create an app via `create-vite`](index), the selected templates would have these pre-configured for you already.\n\n## TypeScript\n\nVite supports importing `.ts` files out of the box.\n\n### Transpile Only\n\nNote that Vite only performs transpilation on `.ts` files and does **NOT** perform type checking. It assumes type checking is taken care of by your IDE and build process.\n\nThe reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.\n\nVite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.\n\n- For production builds, you can run `tsc --noEmit` in addition to Vite's build command.\n\n- During development, if you need more than IDE hints, we recommend running `tsc --noEmit --watch` in a separate process, or use [vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker) if you prefer having type errors directly reported in the browser.\n\nVite uses [esbuild](https://github.com/evanw/esbuild) to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla `tsc`, and HMR updates can reflect in the browser in under 50ms.\n\nUse the [Type-Only Imports and Export](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:\n\nts\n\n``` javascript\nimport type { T } from 'only/types'\nexport type { T }\n```\n\n### TypeScript Compiler Options\n\nSome configuration fields under `compilerOptions` in `tsconfig.json` require special attention.\n\n#### `isolatedModules`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#isolatedModules)\n\nShould be set to `true`.\n\nIt is because `esbuild` only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.\n\nYou must set `\"isolatedModules\": true` in your `tsconfig.json` under `compilerOptions`, so that TS will warn you against the features that do not work with isolated transpilation.\n\nIf a dependency doesn't work well with `\"isolatedModules\": true`. You can use `\"skipLibCheck\": true` to temporarily suppress the errors until it is fixed upstream.\n\n#### `useDefineForClassFields`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n\nStarting from Vite 2.5.0, the default value will be `true` if the TypeScript target is `ESNext` or `ES2022` or newer. It is consistent with the [behavior of `tsc` 4.3.2 and later](https://github.com/microsoft/TypeScript/pull/42663). It is also the standard ECMAScript runtime behavior.\n\nOther TypeScript targets will default to `false`.\n\nBut it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the [TypeScript 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).\n\nIf you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.\n\nMost libraries expect `\"useDefineForClassFields\": true`, such as [MobX](https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties).\n\nBut a few libraries haven't transitioned to this new default yet, including [`lit-element`](https://github.com/lit/lit-element/issues/1030). Please explicitly set `useDefineForClassFields` to `false` in these cases.\n\n#### `target`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#target)\n\nVite does not transpile TypeScript with the configured `target` value by default, following the same behaviour as `esbuild`.\n\nThe [`esbuild.target`](../config/shared-options#esbuild) option can be used instead, which defaults to `esnext` for minimal transpilation. In builds, the [`build.target`](../config/build-options#build-target) option takes higher priority and can also be set if needed.\n\n**`useDefineForClassFields`**\n\nIf `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.\n\nAs such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.\n\n#### Other Compiler Options Affecting the Build Result\n\n- [`extends`](https://www.typescriptlang.org/tsconfig#extends)\n- [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)\n- [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n- [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax)\n- [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n- [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)\n- [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)\n\n**`skipLibCheck`**\n\nVite starter templates have `\"skipLibCheck\": \"true\"` by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at [vuejs/vue-cli#5688](https://github.com/vuejs/vue-cli/pull/5688).\n\n### Client Types\n\nVite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a `d.ts` declaration file:\n\ntypescript\n\n``` javascript\n/// <reference types=\"vite/client\" />\n```\n\nAlternatively, you can add `vite/client` to `compilerOptions.types` inside `tsconfig.json`:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\"vite/client\"]\n  }\n}\n```\n\nThis will provide the following type shims:\n\n- Asset imports (e.g. importing an `.svg` file)\n- Types for the Vite-injected [env variables](env-and-mode#env-variables) on `import.meta.env`\n- Types for the [HMR API](api-hmr) on `import.meta.hot`\n\n**TIP**\n\nTo override the default typing, add a type definition file that contains your typings. Then, add the type reference before `vite/client`.\n\nFor example, to make the default import of `*.svg` a React component:\n\n- `vite-env-override.d.ts` (the file that contains your typings):\n  ts\n  ``` javascript\n  declare module '*.svg' {\n    const content: React.FC<React.SVGProps<SVGElement>>\n    export default content\n  }\n  ```\n- The file containing the reference to `vite/client`:\n  ts\n  ``` javascript\n  /// <reference types=\"./vite-env-override.d.ts\" />\n  /// <reference types=\"vite/client\" />\n  ```\n\n## Vue\n\nVite provides first-class Vue support:\n\n- Vue 3 SFC support via [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)\n- Vue 3 JSX support via [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)\n- Vue 2.7 SFC support via [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2)\n- Vue 2.7 JSX support via [@vitejs/plugin-vue2-jsx](https://github.com/vitejs/vite-plugin-vue2-jsx)\n\n## JSX\n\n`.jsx` and `.tsx` files are also supported out of the box. JSX transpilation is also handled via [esbuild](https://esbuild.github.io).\n\nVue users should use the official [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.\n\nIf using JSX without React or Vue, custom `jsxFactory` and `jsxFragment` can be configured using the [`esbuild` option](../config/shared-options#esbuild). For example for Preact:\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n```\n\nMore details in [esbuild docs](https://esbuild.github.io/content-types/#jsx).\n\nYou can inject the JSX helpers using `jsxInject` (which is a Vite-only option) to avoid manual imports:\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n```\n\n## CSS\n\nImporting `.css` files will inject its content to the page via a `<style>` tag with HMR support.\n\n### `@import` Inlining and Rebasing\n\nVite is pre-configured to support CSS `@import` inlining via `postcss-import`. Vite aliases are also respected for CSS `@import`. In addition, all CSS `url()` references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.\n\n`@import` aliases and URL rebasing are also supported for Sass and Less files (see [CSS Pre-processors](#css-pre-processors)).\n\n### PostCSS\n\nIf the project contains valid PostCSS config (any format supported by [postcss-load-config](https://github.com/postcss/postcss-load-config), e.g. `postcss.config.js`), it will be automatically applied to all imported CSS.\n\nNote that CSS minification will run after PostCSS and will use [`build.cssTarget`](../config/build-options#build-csstarget) option.\n\n### CSS Modules\n\nAny CSS file ending with `.module.css` is considered a [CSS modules file](https://github.com/css-modules/css-modules). Importing such a file will return the corresponding module object:\n\ncss\n\n``` javascript\n/* example.module.css */\n.red {\n  color: red;\n}\n```\n\njs\n\n``` javascript\nimport classes from './example.module.css'\ndocument.getElementById('foo').className = classes.red\n```\n\nCSS modules behavior can be configured via the [`css.modules` option](../config/shared-options#css-modules).\n\nIf `css.modules.localsConvention` is set to enable camelCase locals (e.g. `localsConvention: 'camelCaseOnly'`), you can also use named imports:\n\njs\n\n``` javascript\n// .apply-color -> applyColor\nimport { applyColor } from './example.module.css'\ndocument.getElementById('foo').className = applyColor\n```\n\n### CSS Pre-processors\n\nBecause Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting)) and author plain, future-standards-compliant CSS.\n\nThat said, Vite does provide built-in support for `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:\n\nbash\n\n``` javascript\n# .scss and .sass\nnpm add -D sass\n\n# .less\nnpm add -D less\n\n# .styl and .stylus\nnpm add -D stylus\n```\n\nIf using Vue single file components, this also automatically enables `<style lang=\"sass\">` et al.\n\nVite improves `@import` resolving for Sass and Less so that Vite aliases are also respected. In addition, relative `url()` references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.\n\n`@import` alias and url rebasing are not supported for Stylus due to its API constraints.\n\nYou can also use CSS modules combined with pre-processors by prepending `.module` to the file extension, for example `style.module.scss`.\n\n### Disabling CSS injection into the page\n\nThe automatic injection of CSS contents can be turned off via the `?inline` query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.\n\njs\n\n``` javascript\nimport './foo.css' // will be injected into the page\nimport otherStyles from './bar.css?inline' // will not be injected\n```\n\n**NOTE**\n\nDefault and named imports from CSS files (e.g `import style from './foo.css'`) are removed since Vite 5. Use the `?inline` query instead.\n\n### Lightning CSS\n\nStarting from Vite 4.4, there is experimental support for [Lightning CSS](https://lightningcss.dev/). You can opt into it by adding [`css.transformer: 'lightningcss'`](../config/shared-options#css-transformer) to your config file and install the optional [`lightningcss`](https://www.npmjs.com/package/lightningcss) dependency:\n\nbash\n\n``` javascript\nnpm add -D lightningcss\n```\n\nIf enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the [`css.lightningcss`](../config/shared-options#css-lightningcss) config option.\n\nTo configure CSS Modules, you'll use [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) instead of [`css.modules`](../config/shared-options#css-modules) (which configures the way PostCSS handles CSS modules).\n\nBy default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with [`build.cssMinify: 'lightningcss'`](../config/build-options#build-cssminify).\n\n**NOTE**\n\n[CSS Pre-processors](#css-pre-processors) aren't supported when using Lightning CSS.\n\n## Static Assets\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\n\n``` javascript\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nSpecial queries can modify how assets are loaded:\n\njs\n\n``` javascript\n// Explicitly load assets as URL\nimport assetAsURL from './asset.js?url'\n```\n\njs\n\n``` javascript\n// Load assets as strings\nimport assetAsString from './shader.glsl?raw'\n```\n\njs\n\n``` javascript\n// Load Web Workers\nimport Worker from './worker.js?worker'\n```\n\njs\n\n``` javascript\n// Web Workers inlined as base64 strings at build time\nimport InlineWorker from './worker.js?worker&inline'\n```\n\nMore details in [Static Asset Handling](assets).\n\n## JSON\n\nJSON files can be directly imported - named imports are also supported:\n\njs\n\n``` javascript\n// import the entire object\nimport json from './example.json'\n// import a root field as named exports - helps with tree-shaking!\nimport { field } from './example.json'\n```\n\n## Glob Import\n\nVite supports importing multiple modules from the file system via the special `import.meta.glob` function:\n\njs\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js')\n```\n\nThe above will be transformed into the following:\n\njs\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n  './dir/bar.js': () => import('./dir/bar.js'),\n}\n```\n\nYou can then iterate over the keys of the `modules` object to access the corresponding modules:\n\njs\n\n``` javascript\nfor (const path in modules) {\n  modules[path]().then((mod) => {\n    console.log(path, mod)\n  })\n}\n```\n\nMatched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass `{ eager: true }` as the second argument:\n\njs\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', { eager: true })\n```\n\nThe above will be transformed into the following:\n\njs\n\n``` javascript\n// code produced by vite\nimport * as __glob__0_0 from './dir/foo.js'\nimport * as __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\n### Multiple Patterns\n\nThe first argument can be an array of globs, for example\n\njs\n\n``` javascript\nconst modules = import.meta.glob(['./dir/*.js', './another/*.js'])\n```\n\n### Negative Patterns\n\nNegative glob patterns are also supported (prefixed with `!`). To ignore some files from the result, you can add exclude glob patterns to the first argument:\n\njs\n\n``` javascript\nconst modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])\n```\n\njs\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n}\n```\n\n#### Named Imports\n\nIt's possible to only import parts of the modules with the `import` options.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', { import: 'setup' })\n```\n\nts\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),\n  './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),\n}\n```\n\nWhen combined with `eager` it's even possible to have tree-shaking enabled for those modules.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'setup',\n  eager: true,\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nimport { setup as __glob__0_0 } from './dir/foo.js'\nimport { setup as __glob__0_1 } from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\nSet `import` to `default` to import the default export.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'default',\n  eager: true,\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nimport __glob__0_0 from './dir/foo.js'\nimport __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\n#### Custom Queries\n\nYou can also use the `query` option to provide queries to imports, for example, to import assets [as a string](assets#importing-asset-as-string) or [as a url](assets#importing-asset-as-url):\n\nts\n\n``` javascript\nconst moduleStrings = import.meta.glob('./dir/*.svg', {\n  query: '?raw',\n  import: 'default',\n})\nconst moduleUrls = import.meta.glob('./dir/*.svg', {\n  query: '?url',\n  import: 'default',\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nconst moduleStrings = {\n  './dir/foo.svg': () => import('./dir/foo.js?raw').then((m) => m['default']),\n  './dir/bar.svg': () => import('./dir/bar.js?raw').then((m) => m['default']),\n}\nconst moduleUrls = {\n  './dir/foo.svg': () => import('./dir/foo.js?url').then((m) => m['default']),\n  './dir/bar.svg': () => import('./dir/bar.js?url').then((m) => m['default']),\n}\n```\n\nYou can also provide custom queries for other plugins to consume:\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  query: { foo: 'bar', bar: true },\n})\n```\n\n### Glob Import Caveats\n\nNote that:\n\n- This is a Vite-only feature and is not a web or ES standard.\n- The glob patterns are treated like import specifiers: they must be either relative (start with `./`) or absolute (start with `/`, resolved relative to project root) or an alias path (see [`resolve.alias` option](../config/shared-options#resolve-alias)).\n- The glob matching is done via [`fast-glob`](https://github.com/mrmlnc/fast-glob) - check out its documentation for [supported glob patterns](https://github.com/mrmlnc/fast-glob#pattern-syntax).\n- You should also be aware that all the arguments in the `import.meta.glob` must be **passed as literals**. You can NOT use variables or expressions in them.\n\n## Dynamic Import\n\nSimilar to [glob import](#glob-import), Vite also supports dynamic import with variables.\n\nts\n\n``` javascript\nconst module = await import(`./dir/${file}.js`)\n```\n\nNote that variables only represent file names one level deep. If `file` is `'foo/bar'`, the import would fail. For more advanced usage, you can use the [glob import](#glob-import) feature.\n\n## WebAssembly\n\nPre-compiled `.wasm` files can be imported with `?init`. The default export will be an initialization function that returns a Promise of the [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance):\n\njs\n\n``` javascript\nimport init from './example.wasm?init'\n\ninit().then((instance) => {\n  instance.exports.test()\n})\n```\n\nThe init function can also take an importObject which is passed along to [`WebAssembly.instantiate`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate) as its second argument:\n\njs\n\n``` javascript\ninit({\n  imports: {\n    someFunc: () => {\n      /* ... */\n    },\n  },\n}).then(() => {\n  /* ... */\n})\n```\n\nIn the production build, `.wasm` files smaller than `assetInlineLimit` will be inlined as base64 strings. Otherwise, they will be treated as a [static asset](assets) and fetched on-demand.\n\n**NOTE**\n\n[ES Module Integration Proposal for WebAssembly](https://github.com/WebAssembly/esm-integration) is not currently supported. Use [`vite-plugin-wasm`](https://github.com/Menci/vite-plugin-wasm) or other community plugins to handle this.\n\n### Accessing the WebAssembly Module\n\nIf you need access to the `Module` object, e.g. to instantiate it multiple times, use an [explicit URL import](assets#explicit-url-imports) to resolve the asset, and then perform the instantiation:\n\njs\n\n``` javascript\nimport wasmUrl from 'foo.wasm?url'\n\nconst main = async () => {\n  const responsePromise = fetch(wasmUrl)\n  const { module, instance } =\n    await WebAssembly.instantiateStreaming(responsePromise)\n  /* ... */\n}\n\nmain()\n```\n\n### Fetching the module in Node.js\n\nIn SSR, the `fetch()` happening as part of the `?init` import, may fail with `TypeError: Invalid URL`. See the issue [Support wasm in SSR](https://github.com/vitejs/vite/issues/8882).\n\nHere is an alternative, assuming the project base is the current directory:\n\njs\n\n``` javascript\nimport wasmUrl from 'foo.wasm?url'\nimport { readFile } from 'node:fs/promises'\n\nconst main = async () => {\n  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default\n  const buffer = await readFile('.' + resolvedUrl)\n  const { instance } = await WebAssembly.instantiate(buffer, {\n    /* ... */\n  })\n  /* ... */\n}\n\nmain()\n```\n\n## Web Workers\n\n### Import with Constructors\n\nA web worker script can be imported using [`new Worker()`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) and [`new SharedWorker()`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker). Compared to the worker suffixes, this syntax leans closer to the standards and is the **recommended** way to create workers.\n\nts\n\n``` javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url))\n```\n\nThe worker constructor also accepts options, which can be used to create \"module\" workers:\n\nts\n\n``` javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url), {\n  type: 'module',\n})\n```\n\nThe worker detection will only work if the `new URL()` constructor is used directly inside the `new Worker()` declaration. Additionally, all options parameters must be static values (i.e. string literals).\n\n### Import with Query Suffixes\n\nA web worker script can be directly imported by appending `?worker` or `?sharedworker` to the import request. The default export will be a custom worker constructor:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker'\n\nconst worker = new MyWorker()\n```\n\nThe worker script can also use ESM `import` statements instead of `importScripts()`. **Note**: During development this relies on [browser native support](https://caniuse.com/?search=module%20worker), but for the production build it is compiled away.\n\nBy default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the `inline` query:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker&inline'\n```\n\nIf you wish to retrieve the worker as a URL, add the `url` query:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker&url'\n```\n\nSee [Worker Options](../config/worker-options) for details on configuring the bundling of all workers.\n\n## Content Security Policy (CSP)\n\nTo deploy CSP, certain directives or configs must be set due to Vite's internals.\n\n### [`'nonce-{RANDOM}'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value)\n\nWhen [`html.cspNonce`](../config/shared-options#html-cspnonce) is set, Vite adds a nonce attribute with the specified value to any `<script>` and `<style>` tags, as well as `<link>` tags for stylesheets and module preloading. Additionally, when this option is set, Vite will inject a meta tag (`<meta property=\"csp-nonce\" nonce=\"PLACEHOLDER\" />`).\n\nThe nonce value of a meta tag with `property=\"csp-nonce\"` will be used by Vite whenever necessary during both dev and after build.\n\n**WARNING**\n\nEnsure that you replace the placeholder with a unique value for each request. This is important to prevent bypassing a resource's policy, which can otherwise be easily done.\n\n### [`data:`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20(not%20recommended).-,data%3A,-Allows%20data%3A)\n\nBy default, during build, Vite inlines small assets as data URIs. Allowing `data:` for related directives (e.g. [`img-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src), [`font-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)), or, disabling it by setting [`build.assetsInlineLimit: 0`](../config/build-options#build-assetsinlinelimit) is necessary.\n\n**WARNING**\n\nDo not allow `data:` for [`script-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src). It will allow injection of arbitrary scripts.\n\n## Build Optimizations\n\n> Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.\n\n### CSS Code Splitting\n\nVite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a `<link>` tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.).\n\nIf you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting [`build.cssCodeSplit`](../config/build-options#build-csscodesplit) to `false`.\n\n### Preload Directives Generation\n\nVite automatically generates `<link rel=\"modulepreload\">` directives for entry chunks and their direct imports in the built HTML.\n\n### Async Chunk Loading Optimization\n\nIn real world applications, Rollup often generates \"common\" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:\n\nIn the non-optimized scenarios, when async chunk `A` is imported, the browser will have to request and parse `A` before it can figure out that it also needs the common chunk `C`. This results in an extra network roundtrip:\n\n``` javascript\nEntry ---> A ---> C\n```\n\nVite automatically rewrites code-split dynamic import calls with a preload step so that when `A` is requested, `C` is fetched **in parallel**:\n\n``` javascript\nEntry ---> (A + C)\n```\n\nIt is possible for `C` to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/features](https://vitejs.dev/guide/features)"
- name: 'Features: Async Chunk Loading Optimization'
  id: guide/features#async-chunk-loading-optimization
  summary: In real world applications, Rollup often generates "common" chunks - code that is shared between two or more other chunks
  belongs_to: Features
  description: "### Async Chunk Loading Optimization\n\nIn real world applications, Rollup often generates \"common\" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:\n\nIn the non-optimized scenarios, when async chunk `A` is imported, the browser will have to request and parse `A` before it can figure out that it also needs the common chunk `C`. This results in an extra network roundtrip:\n\n``` javascript\nEntry ---> A ---> C\n```\n\nVite automatically rewrites code-split dynamic import calls with a preload step so that when `A` is requested, `C` is fetched **in parallel**:\n\n``` javascript\nEntry ---> (A + C)\n```\n\nIt is possible for `C` to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/features](https://vitejs.dev/guide/features)"
- name: 'Features: Build Optimizations'
  id: guide/features#build-optimizations
  summary: Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them
  belongs_to: Features
  description: |-
    ## Build Optimizations

    > Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.
- name: 'Features: Client Types'
  id: guide/features#client-types
  summary: Vite's default types are for its Node.js API
  belongs_to: Features
  description: |-
    ### Client Types

    Vite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a `d.ts` declaration file:

    typescript

    ``` javascript
    /// <reference types="vite/client" />
    ```

    Alternatively, you can add `vite/client` to `compilerOptions.types` inside `tsconfig.json`:

    json

    ``` javascript
    {
      "compilerOptions": {
        "types": ["vite/client"]
      }
    }
    ```

    This will provide the following type shims:

    - Asset imports (e.g. importing an `.svg` file)
    - Types for the Vite-injected [env variables](env-and-mode#env-variables) on `import.meta.env`
    - Types for the [HMR API](api-hmr) on `import.meta.hot`

    **TIP**

    To override the default typing, add a type definition file that contains your typings. Then, add the type reference before `vite/client`.

    For example, to make the default import of `*.svg` a React component:

    - `vite-env-override.d.ts` (the file that contains your typings):
      ts
      ``` javascript
      declare module '*.svg' {
        const content: React.FC<React.SVGProps<SVGElement>>
        export default content
      }
      ```
    - The file containing the reference to `vite/client`:
      ts
      ``` javascript
      /// <reference types="./vite-env-override.d.ts" />
      /// <reference types="vite/client" />
      ```
- name: 'Features: Content Security Policy (CSP)'
  id: guide/features#content-security-policy-csp
  summary: To deploy CSP, certain directives or configs must be set due to Vite's internals
  belongs_to: Features
  description: |-
    ## Content Security Policy (CSP)

    To deploy CSP, certain directives or configs must be set due to Vite's internals.
- name: 'Features: CSS'
  id: guide/features#css
  summary: Importing .css files will inject its content to the page via a <style> tag with HMR support
  belongs_to: Features
  description: |-
    ## CSS

    Importing `.css` files will inject its content to the page via a `<style>` tag with HMR support.
- name: 'Features: CSS Code Splitting'
  id: guide/features#css-code-splitting
  summary: Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it
  belongs_to: Features
  description: |-
    ### CSS Code Splitting

    Vite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a `<link>` tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.).

    If you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting [`build.cssCodeSplit`](../config/build-options#build-csscodesplit) to `false`.
- name: 'Features: CSS Modules'
  id: guide/features#css-modules
  summary: Any CSS file ending with .module.css is considered a CSS modules file
  belongs_to: Features
  description: |-
    ### CSS Modules

    Any CSS file ending with `.module.css` is considered a [CSS modules file](https://github.com/css-modules/css-modules). Importing such a file will return the corresponding module object:

    css

    ``` javascript
    /* example.module.css */
    .red {
      color: red;
    }
    ```

    js

    ``` javascript
    import classes from './example.module.css'
    document.getElementById('foo').className = classes.red
    ```

    CSS modules behavior can be configured via the [`css.modules` option](../config/shared-options#css-modules).

    If `css.modules.localsConvention` is set to enable camelCase locals (e.g. `localsConvention: 'camelCaseOnly'`), you can also use named imports:

    js

    ``` javascript
    // .apply-color -> applyColor
    import { applyColor } from './example.module.css'
    document.getElementById('foo').className = applyColor
    ```
- name: 'Features: CSS Pre-processors'
  id: guide/features#css-pre-processors
  summary: Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g
  belongs_to: Features
  description: |-
    ### CSS Pre-processors

    Because Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting)) and author plain, future-standards-compliant CSS.

    That said, Vite does provide built-in support for `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:

    bash

    ``` javascript
    # .scss and .sass
    npm add -D sass

    # .less
    npm add -D less

    # .styl and .stylus
    npm add -D stylus
    ```

    If using Vue single file components, this also automatically enables `<style lang="sass">` et al.

    Vite improves `@import` resolving for Sass and Less so that Vite aliases are also respected. In addition, relative `url()` references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.

    `@import` alias and url rebasing are not supported for Stylus due to its API constraints.

    You can also use CSS modules combined with pre-processors by prepending `.module` to the file extension, for example `style.module.scss`.
- name: 'Features: data:'
  id: guide/features#data
  summary: By default, during build, Vite inlines small assets as data URIs
  belongs_to: Features
  description: |-
    ### [`data:`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20(not%20recommended).-,data%3A,-Allows%20data%3A)

    By default, during build, Vite inlines small assets as data URIs. Allowing `data:` for related directives (e.g. [`img-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src), [`font-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)), or, disabling it by setting [`build.assetsInlineLimit: 0`](../config/build-options#build-assetsinlinelimit) is necessary.

    **WARNING**

    Do not allow `data:` for [`script-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src). It will allow injection of arbitrary scripts.
- name: 'Features: Disabling CSS injection into the page'
  id: guide/features#disabling-css-injection-into-the-page
  summary: The automatic injection of CSS contents can be turned off via the ?inline query parameter
  belongs_to: Features
  description: |-
    ### Disabling CSS injection into the page

    The automatic injection of CSS contents can be turned off via the `?inline` query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.

    js

    ``` javascript
    import './foo.css' // will be injected into the page
    import otherStyles from './bar.css?inline' // will not be injected
    ```

    **NOTE**

    Default and named imports from CSS files (e.g `import style from './foo.css'`) are removed since Vite 5. Use the `?inline` query instead.
- name: 'Features: Dynamic Import'
  id: guide/features#dynamic-import
  summary: Similar to glob import, Vite also supports dynamic import with variables
  belongs_to: Features
  description: |-
    ## Dynamic Import

    Similar to [glob import](#glob-import), Vite also supports dynamic import with variables.

    ts

    ``` javascript
    const module = await import(`./dir/${file}.js`)
    ```

    Note that variables only represent file names one level deep. If `file` is `'foo/bar'`, the import would fail. For more advanced usage, you can use the [glob import](#glob-import) feature.
- name: 'Features: Fetching the module in Node.js'
  id: guide/features#fetching-the-module-in-node-js
  summary: 'In SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL'
  belongs_to: Features
  description: |-
    ### Fetching the module in Node.js

    In SSR, the `fetch()` happening as part of the `?init` import, may fail with `TypeError: Invalid URL`. See the issue [Support wasm in SSR](https://github.com/vitejs/vite/issues/8882).

    Here is an alternative, assuming the project base is the current directory:

    js

    ``` javascript
    import wasmUrl from 'foo.wasm?url'
    import { readFile } from 'node:fs/promises'

    const main = async () => {
      const resolvedUrl = (await import('./test/boot.test.wasm?url')).default
      const buffer = await readFile('.' + resolvedUrl)
      const { instance } = await WebAssembly.instantiate(buffer, {
        /* ... */
      })
      /* ... */
    }

    main()
    ```
- name: 'Features: Glob Import'
  id: guide/features#glob-import
  summary: Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build
  belongs_to: Features
  description: |-
    ## Glob Import

    Vite supports importing multiple modules from the file system via the special `import.meta.glob` function:

    js

    ``` javascript
    const modules = import.meta.glob('./dir/*.js')
    ```

    The above will be transformed into the following:

    js

    ``` javascript
    // code produced by vite
    const modules = {
      './dir/foo.js': () => import('./dir/foo.js'),
      './dir/bar.js': () => import('./dir/bar.js'),
    }
    ```

    You can then iterate over the keys of the `modules` object to access the corresponding modules:

    js

    ``` javascript
    for (const path in modules) {
      modules[path]().then((mod) => {
        console.log(path, mod)
      })
    }
    ```

    Matched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass `{ eager: true }` as the second argument:

    js

    ``` javascript
    const modules = import.meta.glob('./dir/*.js', { eager: true })
    ```

    The above will be transformed into the following:

    js

    ``` javascript
    // code produced by vite
    import * as __glob__0_0 from './dir/foo.js'
    import * as __glob__0_1 from './dir/bar.js'
    const modules = {
      './dir/foo.js': __glob__0_0,
      './dir/bar.js': __glob__0_1,
    }
    ```
- name: 'Features: Glob Import Caveats'
  id: guide/features#glob-import-caveats
  summary: null
  belongs_to: Features
  description: |-
    ### Glob Import Caveats

    Note that:

    - This is a Vite-only feature and is not a web or ES standard.
    - The glob patterns are treated like import specifiers: they must be either relative (start with `./`) or absolute (start with `/`, resolved relative to project root) or an alias path (see [`resolve.alias` option](../config/shared-options#resolve-alias)).
    - The glob matching is done via [`fast-glob`](https://github.com/mrmlnc/fast-glob) - check out its documentation for [supported glob patterns](https://github.com/mrmlnc/fast-glob#pattern-syntax).
    - You should also be aware that all the arguments in the `import.meta.glob` must be **passed as literals**. You can NOT use variables or expressions in them.

    &nbsp;
- name: 'Features: Guide'
  id: guide/features
  summary: At the very basic level, developing using Vite is not that different from using a static file server
  description: "# Features\n\nAt the very basic level, developing using Vite is not that different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.\n\n## NPM Dependency Resolving and Pre-Bundling\n\nNative ES imports do not support bare module imports like the following:\n\njs\n\n``` javascript\nimport { someMethod } from 'my-dep'\n```\n\nThe above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:\n\n1.  [Pre-bundle](dep-pre-bundling) them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with [esbuild](http://esbuild.github.io/) and makes Vite's cold start time significantly faster than any JavaScript-based bundler.\n\n2.  Rewrite the imports to valid URLs like `/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd` so that the browser can import them properly.\n\n**Dependencies are Strongly Cached**\n\nVite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps [here](dep-pre-bundling#browser-cache).\n\n## Hot Module Replacement\n\nVite provides an [HMR API](api-hmr) over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for [Vue Single File Components](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) and [React Fast Refresh](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react). There are also official integrations for Preact via [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite).\n\nNote you don't need to manually set these up - when you [create an app via `create-vite`](index), the selected templates would have these pre-configured for you already.\n\n## TypeScript\n\nVite supports importing `.ts` files out of the box.\n\n### Transpile Only\n\nNote that Vite only performs transpilation on `.ts` files and does **NOT** perform type checking. It assumes type checking is taken care of by your IDE and build process.\n\nThe reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.\n\nVite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.\n\n- For production builds, you can run `tsc --noEmit` in addition to Vite's build command.\n\n- During development, if you need more than IDE hints, we recommend running `tsc --noEmit --watch` in a separate process, or use [vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker) if you prefer having type errors directly reported in the browser.\n\nVite uses [esbuild](https://github.com/evanw/esbuild) to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla `tsc`, and HMR updates can reflect in the browser in under 50ms.\n\nUse the [Type-Only Imports and Export](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:\n\nts\n\n``` javascript\nimport type { T } from 'only/types'\nexport type { T }\n```\n\n### TypeScript Compiler Options\n\nSome configuration fields under `compilerOptions` in `tsconfig.json` require special attention.\n\n#### `isolatedModules`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#isolatedModules)\n\nShould be set to `true`.\n\nIt is because `esbuild` only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.\n\nYou must set `\"isolatedModules\": true` in your `tsconfig.json` under `compilerOptions`, so that TS will warn you against the features that do not work with isolated transpilation.\n\nIf a dependency doesn't work well with `\"isolatedModules\": true`. You can use `\"skipLibCheck\": true` to temporarily suppress the errors until it is fixed upstream.\n\n#### `useDefineForClassFields`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)\n\nStarting from Vite 2.5.0, the default value will be `true` if the TypeScript target is `ESNext` or `ES2022` or newer. It is consistent with the [behavior of `tsc` 4.3.2 and later](https://github.com/microsoft/TypeScript/pull/42663). It is also the standard ECMAScript runtime behavior.\n\nOther TypeScript targets will default to `false`.\n\nBut it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the [TypeScript 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).\n\nIf you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.\n\nMost libraries expect `\"useDefineForClassFields\": true`, such as [MobX](https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties).\n\nBut a few libraries haven't transitioned to this new default yet, including [`lit-element`](https://github.com/lit/lit-element/issues/1030). Please explicitly set `useDefineForClassFields` to `false` in these cases.\n\n#### `target`\n\n- [TypeScript documentation](https://www.typescriptlang.org/tsconfig#target)\n\nVite does not transpile TypeScript with the configured `target` value by default, following the same behaviour as `esbuild`.\n\nThe [`esbuild.target`](../config/shared-options#esbuild) option can be used instead, which defaults to `esnext` for minimal transpilation. In builds, the [`build.target`](../config/build-options#build-target) option takes higher priority and can also be set if needed.\n\n**`useDefineForClassFields`**\n\nIf `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.\n\nAs such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.\n\n#### Other Compiler Options Affecting the Build Result\n\n- [`extends`](https://www.typescriptlang.org/tsconfig#extends)\n- [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)\n- [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)\n- [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax)\n- [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)\n- [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)\n- [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)\n- [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)\n- [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)\n- [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)\n\n**`skipLibCheck`**\n\nVite starter templates have `\"skipLibCheck\": \"true\"` by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at [vuejs/vue-cli#5688](https://github.com/vuejs/vue-cli/pull/5688).\n\n### Client Types\n\nVite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a `d.ts` declaration file:\n\ntypescript\n\n``` javascript\n/// <reference types=\"vite/client\" />\n```\n\nAlternatively, you can add `vite/client` to `compilerOptions.types` inside `tsconfig.json`:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\"vite/client\"]\n  }\n}\n```\n\nThis will provide the following type shims:\n\n- Asset imports (e.g. importing an `.svg` file)\n- Types for the Vite-injected [env variables](env-and-mode#env-variables) on `import.meta.env`\n- Types for the [HMR API](api-hmr) on `import.meta.hot`\n\n**TIP**\n\nTo override the default typing, add a type definition file that contains your typings. Then, add the type reference before `vite/client`.\n\nFor example, to make the default import of `*.svg` a React component:\n\n- `vite-env-override.d.ts` (the file that contains your typings):\n  ts\n  ``` javascript\n  declare module '*.svg' {\n    const content: React.FC<React.SVGProps<SVGElement>>\n    export default content\n  }\n  ```\n- The file containing the reference to `vite/client`:\n  ts\n  ``` javascript\n  /// <reference types=\"./vite-env-override.d.ts\" />\n  /// <reference types=\"vite/client\" />\n  ```\n\n## Vue\n\nVite provides first-class Vue support:\n\n- Vue 3 SFC support via [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)\n- Vue 3 JSX support via [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)\n- Vue 2.7 SFC support via [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2)\n- Vue 2.7 JSX support via [@vitejs/plugin-vue2-jsx](https://github.com/vitejs/vite-plugin-vue2-jsx)\n\n## JSX\n\n`.jsx` and `.tsx` files are also supported out of the box. JSX transpilation is also handled via [esbuild](https://esbuild.github.io).\n\nVue users should use the official [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.\n\nIf using JSX without React or Vue, custom `jsxFactory` and `jsxFragment` can be configured using the [`esbuild` option](../config/shared-options#esbuild). For example for Preact:\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n```\n\nMore details in [esbuild docs](https://esbuild.github.io/content-types/#jsx).\n\nYou can inject the JSX helpers using `jsxInject` (which is a Vite-only option) to avoid manual imports:\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n```\n\n## CSS\n\nImporting `.css` files will inject its content to the page via a `<style>` tag with HMR support.\n\n### `@import` Inlining and Rebasing\n\nVite is pre-configured to support CSS `@import` inlining via `postcss-import`. Vite aliases are also respected for CSS `@import`. In addition, all CSS `url()` references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.\n\n`@import` aliases and URL rebasing are also supported for Sass and Less files (see [CSS Pre-processors](#css-pre-processors)).\n\n### PostCSS\n\nIf the project contains valid PostCSS config (any format supported by [postcss-load-config](https://github.com/postcss/postcss-load-config), e.g. `postcss.config.js`), it will be automatically applied to all imported CSS.\n\nNote that CSS minification will run after PostCSS and will use [`build.cssTarget`](../config/build-options#build-csstarget) option.\n\n### CSS Modules\n\nAny CSS file ending with `.module.css` is considered a [CSS modules file](https://github.com/css-modules/css-modules). Importing such a file will return the corresponding module object:\n\ncss\n\n``` javascript\n/* example.module.css */\n.red {\n  color: red;\n}\n```\n\njs\n\n``` javascript\nimport classes from './example.module.css'\ndocument.getElementById('foo').className = classes.red\n```\n\nCSS modules behavior can be configured via the [`css.modules` option](../config/shared-options#css-modules).\n\nIf `css.modules.localsConvention` is set to enable camelCase locals (e.g. `localsConvention: 'camelCaseOnly'`), you can also use named imports:\n\njs\n\n``` javascript\n// .apply-color -> applyColor\nimport { applyColor } from './example.module.css'\ndocument.getElementById('foo').className = applyColor\n```\n\n### CSS Pre-processors\n\nBecause Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. [postcss-nesting](https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting)) and author plain, future-standards-compliant CSS.\n\nThat said, Vite does provide built-in support for `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:\n\nbash\n\n``` javascript\n# .scss and .sass\nnpm add -D sass\n\n# .less\nnpm add -D less\n\n# .styl and .stylus\nnpm add -D stylus\n```\n\nIf using Vue single file components, this also automatically enables `<style lang=\"sass\">` et al.\n\nVite improves `@import` resolving for Sass and Less so that Vite aliases are also respected. In addition, relative `url()` references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.\n\n`@import` alias and url rebasing are not supported for Stylus due to its API constraints.\n\nYou can also use CSS modules combined with pre-processors by prepending `.module` to the file extension, for example `style.module.scss`.\n\n### Disabling CSS injection into the page\n\nThe automatic injection of CSS contents can be turned off via the `?inline` query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.\n\njs\n\n``` javascript\nimport './foo.css' // will be injected into the page\nimport otherStyles from './bar.css?inline' // will not be injected\n```\n\n**NOTE**\n\nDefault and named imports from CSS files (e.g `import style from './foo.css'`) are removed since Vite 5. Use the `?inline` query instead.\n\n### Lightning CSS\n\nStarting from Vite 4.4, there is experimental support for [Lightning CSS](https://lightningcss.dev/). You can opt into it by adding [`css.transformer: 'lightningcss'`](../config/shared-options#css-transformer) to your config file and install the optional [`lightningcss`](https://www.npmjs.com/package/lightningcss) dependency:\n\nbash\n\n``` javascript\nnpm add -D lightningcss\n```\n\nIf enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the [`css.lightningcss`](../config/shared-options#css-lightningcss) config option.\n\nTo configure CSS Modules, you'll use [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) instead of [`css.modules`](../config/shared-options#css-modules) (which configures the way PostCSS handles CSS modules).\n\nBy default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with [`build.cssMinify: 'lightningcss'`](../config/build-options#build-cssminify).\n\n**NOTE**\n\n[CSS Pre-processors](#css-pre-processors) aren't supported when using Lightning CSS.\n\n## Static Assets\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\n\n``` javascript\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nSpecial queries can modify how assets are loaded:\n\njs\n\n``` javascript\n// Explicitly load assets as URL\nimport assetAsURL from './asset.js?url'\n```\n\njs\n\n``` javascript\n// Load assets as strings\nimport assetAsString from './shader.glsl?raw'\n```\n\njs\n\n``` javascript\n// Load Web Workers\nimport Worker from './worker.js?worker'\n```\n\njs\n\n``` javascript\n// Web Workers inlined as base64 strings at build time\nimport InlineWorker from './worker.js?worker&inline'\n```\n\nMore details in [Static Asset Handling](assets).\n\n## JSON\n\nJSON files can be directly imported - named imports are also supported:\n\njs\n\n``` javascript\n// import the entire object\nimport json from './example.json'\n// import a root field as named exports - helps with tree-shaking!\nimport { field } from './example.json'\n```\n\n## Glob Import\n\nVite supports importing multiple modules from the file system via the special `import.meta.glob` function:\n\njs\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js')\n```\n\nThe above will be transformed into the following:\n\njs\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n  './dir/bar.js': () => import('./dir/bar.js'),\n}\n```\n\nYou can then iterate over the keys of the `modules` object to access the corresponding modules:\n\njs\n\n``` javascript\nfor (const path in modules) {\n  modules[path]().then((mod) => {\n    console.log(path, mod)\n  })\n}\n```\n\nMatched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass `{ eager: true }` as the second argument:\n\njs\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', { eager: true })\n```\n\nThe above will be transformed into the following:\n\njs\n\n``` javascript\n// code produced by vite\nimport * as __glob__0_0 from './dir/foo.js'\nimport * as __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\n### Multiple Patterns\n\nThe first argument can be an array of globs, for example\n\njs\n\n``` javascript\nconst modules = import.meta.glob(['./dir/*.js', './another/*.js'])\n```\n\n### Negative Patterns\n\nNegative glob patterns are also supported (prefixed with `!`). To ignore some files from the result, you can add exclude glob patterns to the first argument:\n\njs\n\n``` javascript\nconst modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])\n```\n\njs\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n}\n```\n\n#### Named Imports\n\nIt's possible to only import parts of the modules with the `import` options.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', { import: 'setup' })\n```\n\nts\n\n``` javascript\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),\n  './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),\n}\n```\n\nWhen combined with `eager` it's even possible to have tree-shaking enabled for those modules.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'setup',\n  eager: true,\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nimport { setup as __glob__0_0 } from './dir/foo.js'\nimport { setup as __glob__0_1 } from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\nSet `import` to `default` to import the default export.\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'default',\n  eager: true,\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nimport __glob__0_0 from './dir/foo.js'\nimport __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n```\n\n#### Custom Queries\n\nYou can also use the `query` option to provide queries to imports, for example, to import assets [as a string](assets#importing-asset-as-string) or [as a url](assets#importing-asset-as-url):\n\nts\n\n``` javascript\nconst moduleStrings = import.meta.glob('./dir/*.svg', {\n  query: '?raw',\n  import: 'default',\n})\nconst moduleUrls = import.meta.glob('./dir/*.svg', {\n  query: '?url',\n  import: 'default',\n})\n```\n\nts\n\n``` javascript\n// code produced by vite:\nconst moduleStrings = {\n  './dir/foo.svg': () => import('./dir/foo.js?raw').then((m) => m['default']),\n  './dir/bar.svg': () => import('./dir/bar.js?raw').then((m) => m['default']),\n}\nconst moduleUrls = {\n  './dir/foo.svg': () => import('./dir/foo.js?url').then((m) => m['default']),\n  './dir/bar.svg': () => import('./dir/bar.js?url').then((m) => m['default']),\n}\n```\n\nYou can also provide custom queries for other plugins to consume:\n\nts\n\n``` javascript\nconst modules = import.meta.glob('./dir/*.js', {\n  query: { foo: 'bar', bar: true },\n})\n```\n\n### Glob Import Caveats\n\nNote that:\n\n- This is a Vite-only feature and is not a web or ES standard.\n- The glob patterns are treated like import specifiers: they must be either relative (start with `./`) or absolute (start with `/`, resolved relative to project root) or an alias path (see [`resolve.alias` option](../config/shared-options#resolve-alias)).\n- The glob matching is done via [`fast-glob`](https://github.com/mrmlnc/fast-glob) - check out its documentation for [supported glob patterns](https://github.com/mrmlnc/fast-glob#pattern-syntax).\n- You should also be aware that all the arguments in the `import.meta.glob` must be **passed as literals**. You can NOT use variables or expressions in them.\n\n## Dynamic Import\n\nSimilar to [glob import](#glob-import), Vite also supports dynamic import with variables.\n\nts\n\n``` javascript\nconst module = await import(`./dir/${file}.js`)\n```\n\nNote that variables only represent file names one level deep. If `file` is `'foo/bar'`, the import would fail. For more advanced usage, you can use the [glob import](#glob-import) feature.\n\n## WebAssembly\n\nPre-compiled `.wasm` files can be imported with `?init`. The default export will be an initialization function that returns a Promise of the [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance):\n\njs\n\n``` javascript\nimport init from './example.wasm?init'\n\ninit().then((instance) => {\n  instance.exports.test()\n})\n```\n\nThe init function can also take an importObject which is passed along to [`WebAssembly.instantiate`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate) as its second argument:\n\njs\n\n``` javascript\ninit({\n  imports: {\n    someFunc: () => {\n      /* ... */\n    },\n  },\n}).then(() => {\n  /* ... */\n})\n```\n\nIn the production build, `.wasm` files smaller than `assetInlineLimit` will be inlined as base64 strings. Otherwise, they will be treated as a [static asset](assets) and fetched on-demand.\n\n**NOTE**\n\n[ES Module Integration Proposal for WebAssembly](https://github.com/WebAssembly/esm-integration) is not currently supported. Use [`vite-plugin-wasm`](https://github.com/Menci/vite-plugin-wasm) or other community plugins to handle this.\n\n### Accessing the WebAssembly Module\n\nIf you need access to the `Module` object, e.g. to instantiate it multiple times, use an [explicit URL import](assets#explicit-url-imports) to resolve the asset, and then perform the instantiation:\n\njs\n\n``` javascript\nimport wasmUrl from 'foo.wasm?url'\n\nconst main = async () => {\n  const responsePromise = fetch(wasmUrl)\n  const { module, instance } =\n    await WebAssembly.instantiateStreaming(responsePromise)\n  /* ... */\n}\n\nmain()\n```\n\n### Fetching the module in Node.js\n\nIn SSR, the `fetch()` happening as part of the `?init` import, may fail with `TypeError: Invalid URL`. See the issue [Support wasm in SSR](https://github.com/vitejs/vite/issues/8882).\n\nHere is an alternative, assuming the project base is the current directory:\n\njs\n\n``` javascript\nimport wasmUrl from 'foo.wasm?url'\nimport { readFile } from 'node:fs/promises'\n\nconst main = async () => {\n  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default\n  const buffer = await readFile('.' + resolvedUrl)\n  const { instance } = await WebAssembly.instantiate(buffer, {\n    /* ... */\n  })\n  /* ... */\n}\n\nmain()\n```\n\n## Web Workers\n\n### Import with Constructors\n\nA web worker script can be imported using [`new Worker()`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) and [`new SharedWorker()`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker). Compared to the worker suffixes, this syntax leans closer to the standards and is the **recommended** way to create workers.\n\nts\n\n``` javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url))\n```\n\nThe worker constructor also accepts options, which can be used to create \"module\" workers:\n\nts\n\n``` javascript\nconst worker = new Worker(new URL('./worker.js', import.meta.url), {\n  type: 'module',\n})\n```\n\nThe worker detection will only work if the `new URL()` constructor is used directly inside the `new Worker()` declaration. Additionally, all options parameters must be static values (i.e. string literals).\n\n### Import with Query Suffixes\n\nA web worker script can be directly imported by appending `?worker` or `?sharedworker` to the import request. The default export will be a custom worker constructor:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker'\n\nconst worker = new MyWorker()\n```\n\nThe worker script can also use ESM `import` statements instead of `importScripts()`. **Note**: During development this relies on [browser native support](https://caniuse.com/?search=module%20worker), but for the production build it is compiled away.\n\nBy default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the `inline` query:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker&inline'\n```\n\nIf you wish to retrieve the worker as a URL, add the `url` query:\n\njs\n\n``` javascript\nimport MyWorker from './worker?worker&url'\n```\n\nSee [Worker Options](../config/worker-options) for details on configuring the bundling of all workers.\n\n## Content Security Policy (CSP)\n\nTo deploy CSP, certain directives or configs must be set due to Vite's internals.\n\n### [`'nonce-{RANDOM}'`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#nonce-base64-value)\n\nWhen [`html.cspNonce`](../config/shared-options#html-cspnonce) is set, Vite adds a nonce attribute with the specified value to any `<script>` and `<style>` tags, as well as `<link>` tags for stylesheets and module preloading. Additionally, when this option is set, Vite will inject a meta tag (`<meta property=\"csp-nonce\" nonce=\"PLACEHOLDER\" />`).\n\nThe nonce value of a meta tag with `property=\"csp-nonce\"` will be used by Vite whenever necessary during both dev and after build.\n\n**WARNING**\n\nEnsure that you replace the placeholder with a unique value for each request. This is important to prevent bypassing a resource's policy, which can otherwise be easily done.\n\n### [`data:`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#scheme-source:~:text=schemes%20(not%20recommended).-,data%3A,-Allows%20data%3A)\n\nBy default, during build, Vite inlines small assets as data URIs. Allowing `data:` for related directives (e.g. [`img-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/img-src), [`font-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/font-src)), or, disabling it by setting [`build.assetsInlineLimit: 0`](../config/build-options#build-assetsinlinelimit) is necessary.\n\n**WARNING**\n\nDo not allow `data:` for [`script-src`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src). It will allow injection of arbitrary scripts.\n\n## Build Optimizations\n\n> Features listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.\n\n### CSS Code Splitting\n\nVite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a `<link>` tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.).\n\nIf you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting [`build.cssCodeSplit`](../config/build-options#build-csscodesplit) to `false`.\n\n### Preload Directives Generation\n\nVite automatically generates `<link rel=\"modulepreload\">` directives for entry chunks and their direct imports in the built HTML.\n\n### Async Chunk Loading Optimization\n\nIn real world applications, Rollup often generates \"common\" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:\n\nIn the non-optimized scenarios, when async chunk `A` is imported, the browser will have to request and parse `A` before it can figure out that it also needs the common chunk `C`. This results in an extra network roundtrip:\n\n``` javascript\nEntry ---> A ---> C\n```\n\nVite automatically rewrites code-split dynamic import calls with a preload step so that when `A` is requested, `C` is fetched **in parallel**:\n\n``` javascript\nEntry ---> (A + C)\n```\n\nIt is possible for `C` to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/features](https://vitejs.dev/guide/features)"
- name: 'Features: Hot Module Replacement'
  id: guide/features#hot-module-replacement
  summary: Vite provides an HMR API over native ESM
  belongs_to: Features
  description: |-
    ## Hot Module Replacement

    Vite provides an [HMR API](api-hmr) over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for [Vue Single File Components](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue) and [React Fast Refresh](https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react). There are also official integrations for Preact via [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite).

    Note you don't need to manually set these up - when you [create an app via `create-vite`](index), the selected templates would have these pre-configured for you already.
- name: 'Features: Import with Constructors'
  id: guide/features#import-with-constructors
  summary: A web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers
  belongs_to: Features
  description: |-
    ### Import with Constructors

    A web worker script can be imported using [`new Worker()`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) and [`new SharedWorker()`](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker/SharedWorker). Compared to the worker suffixes, this syntax leans closer to the standards and is the **recommended** way to create workers.

    ts

    ``` javascript
    const worker = new Worker(new URL('./worker.js', import.meta.url))
    ```

    The worker constructor also accepts options, which can be used to create "module" workers:

    ts

    ``` javascript
    const worker = new Worker(new URL('./worker.js', import.meta.url), {
      type: 'module',
    })
    ```

    The worker detection will only work if the `new URL()` constructor is used directly inside the `new Worker()` declaration. Additionally, all options parameters must be static values (i.e. string literals).
- name: 'Features: Import with Query Suffixes'
  id: guide/features#import-with-query-suffixes
  summary: A web worker script can be directly imported by appending ?worker or ?sharedworker to the import request
  belongs_to: Features
  description: |-
    ### Import with Query Suffixes

    A web worker script can be directly imported by appending `?worker` or `?sharedworker` to the import request. The default export will be a custom worker constructor:

    js

    ``` javascript
    import MyWorker from './worker?worker'

    const worker = new MyWorker()
    ```

    The worker script can also use ESM `import` statements instead of `importScripts()`. **Note**: During development this relies on [browser native support](https://caniuse.com/?search=module%20worker), but for the production build it is compiled away.

    By default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the `inline` query:

    js

    ``` javascript
    import MyWorker from './worker?worker&inline'
    ```

    If you wish to retrieve the worker as a URL, add the `url` query:

    js

    ``` javascript
    import MyWorker from './worker?worker&url'
    ```

    See [Worker Options](../config/worker-options) for details on configuring the bundling of all workers.
- name: 'Features: JSON'
  id: guide/features#json
  summary: null
  belongs_to: Features
  description: |-
    ## JSON

    JSON files can be directly imported - named imports are also supported:

    js

    ``` javascript
    // import the entire object
    import json from './example.json'
    // import a root field as named exports - helps with tree-shaking!
    import { field } from './example.json'
    ```
- name: 'Features: JSX'
  id: guide/features#jsx
  summary: .jsx and .tsx files are also supported out of the box
  belongs_to: Features
  description: |-
    ## JSX

    `.jsx` and `.tsx` files are also supported out of the box. JSX transpilation is also handled via [esbuild](https://esbuild.github.io).

    Vue users should use the official [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx) plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.

    If using JSX without React or Vue, custom `jsxFactory` and `jsxFragment` can be configured using the [`esbuild` option](../config/shared-options#esbuild). For example for Preact:

    js

    ``` javascript
    // vite.config.js
    import { defineConfig } from 'vite'

    export default defineConfig({
      esbuild: {
        jsxFactory: 'h',
        jsxFragment: 'Fragment',
      },
    })
    ```

    More details in [esbuild docs](https://esbuild.github.io/content-types/#jsx).

    You can inject the JSX helpers using `jsxInject` (which is a Vite-only option) to avoid manual imports:

    js

    ``` javascript
    // vite.config.js
    import { defineConfig } from 'vite'

    export default defineConfig({
      esbuild: {
        jsxInject: `import React from 'react'`,
      },
    })
    ```
- name: 'Features: Lightning CSS'
  id: guide/features#lightning-css
  summary: Starting from Vite 4.4, there is experimental support for Lightning CSS
  belongs_to: Features
  description: |-
    ### Lightning CSS

    Starting from Vite 4.4, there is experimental support for [Lightning CSS](https://lightningcss.dev/). You can opt into it by adding [`css.transformer: 'lightningcss'`](../config/shared-options#css-transformer) to your config file and install the optional [`lightningcss`](https://www.npmjs.com/package/lightningcss) dependency:

    bash

    ``` javascript
    npm add -D lightningcss
    ```

    If enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the [`css.lightningcss`](../config/shared-options#css-lightningcss) config option.

    To configure CSS Modules, you'll use [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) instead of [`css.modules`](../config/shared-options#css-modules) (which configures the way PostCSS handles CSS modules).

    By default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with [`build.cssMinify: 'lightningcss'`](../config/build-options#build-cssminify).

    **NOTE**

    [CSS Pre-processors](#css-pre-processors) aren't supported when using Lightning CSS.
- name: 'Features: Multiple Patterns'
  id: guide/features#multiple-patterns
  summary: null
  belongs_to: Features
  description: |-
    ### Multiple Patterns

    The first argument can be an array of globs, for example

    js

    ``` javascript
    const modules = import.meta.glob(['./dir/*.js', './another/*.js'])
    ```
- name: 'Features: Negative Patterns'
  id: guide/features#negative-patterns
  summary: It's possible to only import parts of the modules with the import options
  belongs_to: Features
  description: |-
    ### Negative Patterns

    Negative glob patterns are also supported (prefixed with `!`). To ignore some files from the result, you can add exclude glob patterns to the first argument:

    js

    ``` javascript
    const modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])
    ```

    js

    ``` javascript
    // code produced by vite
    const modules = {
      './dir/foo.js': () => import('./dir/foo.js'),
    }
    ```

    #### Named Imports

    It's possible to only import parts of the modules with the `import` options.

    ts

    ``` javascript
    const modules = import.meta.glob('./dir/*.js', { import: 'setup' })
    ```

    ts

    ``` javascript
    // code produced by vite
    const modules = {
      './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),
      './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),
    }
    ```

    When combined with `eager` it's even possible to have tree-shaking enabled for those modules.

    ts

    ``` javascript
    const modules = import.meta.glob('./dir/*.js', {
      import: 'setup',
      eager: true,
    })
    ```

    ts

    ``` javascript
    // code produced by vite:
    import { setup as __glob__0_0 } from './dir/foo.js'
    import { setup as __glob__0_1 } from './dir/bar.js'
    const modules = {
      './dir/foo.js': __glob__0_0,
      './dir/bar.js': __glob__0_1,
    }
    ```

    Set `import` to `default` to import the default export.

    ts

    ``` javascript
    const modules = import.meta.glob('./dir/*.js', {
      import: 'default',
      eager: true,
    })
    ```

    ts

    ``` javascript
    // code produced by vite:
    import __glob__0_0 from './dir/foo.js'
    import __glob__0_1 from './dir/bar.js'
    const modules = {
      './dir/foo.js': __glob__0_0,
      './dir/bar.js': __glob__0_1,
    }
    ```

    #### Custom Queries

    You can also use the `query` option to provide queries to imports, for example, to import assets [as a string](assets#importing-asset-as-string) or [as a url](assets#importing-asset-as-url):

    ts

    ``` javascript
    const moduleStrings = import.meta.glob('./dir/*.svg', {
      query: '?raw',
      import: 'default',
    })
    const moduleUrls = import.meta.glob('./dir/*.svg', {
      query: '?url',
      import: 'default',
    })
    ```

    ts

    ``` javascript
    // code produced by vite:
    const moduleStrings = {
      './dir/foo.svg': () => import('./dir/foo.js?raw').then((m) => m['default']),
      './dir/bar.svg': () => import('./dir/bar.js?raw').then((m) => m['default']),
    }
    const moduleUrls = {
      './dir/foo.svg': () => import('./dir/foo.js?url').then((m) => m['default']),
      './dir/bar.svg': () => import('./dir/bar.js?url').then((m) => m['default']),
    }
    ```

    You can also provide custom queries for other plugins to consume:

    ts

    ``` javascript
    const modules = import.meta.glob('./dir/*.js', {
      query: { foo: 'bar', bar: true },
    })
    ```
- name: 'Features: NPM Dependency Resolving and Pre-Bundling'
  id: guide/features#npm-dependency-resolving-and-pre-bundling
  summary: The above will throw an error in the browser
  belongs_to: Features
  description: |-
    ## NPM Dependency Resolving and Pre-Bundling

    Native ES imports do not support bare module imports like the following:

    js

    ``` javascript
    import { someMethod } from 'my-dep'
    ```

    The above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:

    1.  [Pre-bundle](dep-pre-bundling) them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with [esbuild](http://esbuild.github.io/) and makes Vite's cold start time significantly faster than any JavaScript-based bundler.

    2.  Rewrite the imports to valid URLs like `/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd` so that the browser can import them properly.

    **Dependencies are Strongly Cached**

    Vite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps [here](dep-pre-bundling#browser-cache).
- name: 'Features: PostCSS'
  id: guide/features#postcss
  summary: If the project contains valid PostCSS config (any format supported by postcss-load-config, e.g
  belongs_to: Features
  description: |-
    ### PostCSS

    If the project contains valid PostCSS config (any format supported by [postcss-load-config](https://github.com/postcss/postcss-load-config), e.g. `postcss.config.js`), it will be automatically applied to all imported CSS.

    Note that CSS minification will run after PostCSS and will use [`build.cssTarget`](../config/build-options#build-csstarget) option.
- name: 'Features: Preload Directives Generation'
  id: guide/features#preload-directives-generation
  summary: Vite automatically generates <link rel="modulepreload"> directives for entry chunks and their direct imports in the built HTML
  belongs_to: Features
  description: |-
    ### Preload Directives Generation

    Vite automatically generates `<link rel="modulepreload">` directives for entry chunks and their direct imports in the built HTML.
- name: 'Features: Static Assets'
  id: guide/features#static-assets
  summary: More details in Static Asset Handling
  belongs_to: Features
  description: |-
    ## Static Assets

    Importing a static asset will return the resolved public URL when it is served:

    js

    ``` javascript
    import imgUrl from './img.png'
    document.getElementById('hero-img').src = imgUrl
    ```

    Special queries can modify how assets are loaded:

    js

    ``` javascript
    // Explicitly load assets as URL
    import assetAsURL from './asset.js?url'
    ```

    js

    ``` javascript
    // Load assets as strings
    import assetAsString from './shader.glsl?raw'
    ```

    js

    ``` javascript
    // Load Web Workers
    import Worker from './worker.js?worker'
    ```

    js

    ``` javascript
    // Web Workers inlined as base64 strings at build time
    import InlineWorker from './worker.js?worker&inline'
    ```

    More details in [Static Asset Handling](assets).
- name: 'Features: Transpile Only'
  id: guide/features#transpile-only
  summary: Note that Vite only performs transpilation on .ts files and does NOT perform type checking
  belongs_to: Features
  description: |-
    ### Transpile Only

    Note that Vite only performs transpilation on `.ts` files and does **NOT** perform type checking. It assumes type checking is taken care of by your IDE and build process.

    The reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.

    Vite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.

    - For production builds, you can run `tsc --noEmit` in addition to Vite's build command.

    - During development, if you need more than IDE hints, we recommend running `tsc --noEmit --watch` in a separate process, or use [vite-plugin-checker](https://github.com/fi3ework/vite-plugin-checker) if you prefer having type errors directly reported in the browser.

    Vite uses [esbuild](https://github.com/evanw/esbuild) to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla `tsc`, and HMR updates can reflect in the browser in under 50ms.

    Use the [Type-Only Imports and Export](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:

    ts

    ``` javascript
    import type { T } from 'only/types'
    export type { T }
    ```
- name: 'Features: TypeScript'
  id: guide/features#typescript
  summary: Vite supports importing .ts files out of the box
  belongs_to: Features
  description: |-
    ## TypeScript

    Vite supports importing `.ts` files out of the box.
- name: 'Features: TypeScript Compiler Options'
  id: guide/features#typescript-compiler-options
  summary: Some configuration fields under compilerOptions in tsconfig.json require special attention
  belongs_to: Features
  description: |-
    ### TypeScript Compiler Options

    Some configuration fields under `compilerOptions` in `tsconfig.json` require special attention.

    #### `isolatedModules`

    - [TypeScript documentation](https://www.typescriptlang.org/tsconfig#isolatedModules)

    Should be set to `true`.

    It is because `esbuild` only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.

    You must set `"isolatedModules": true` in your `tsconfig.json` under `compilerOptions`, so that TS will warn you against the features that do not work with isolated transpilation.

    If a dependency doesn't work well with `"isolatedModules": true`. You can use `"skipLibCheck": true` to temporarily suppress the errors until it is fixed upstream.

    #### `useDefineForClassFields`

    - [TypeScript documentation](https://www.typescriptlang.org/tsconfig#useDefineForClassFields)

    Starting from Vite 2.5.0, the default value will be `true` if the TypeScript target is `ESNext` or `ES2022` or newer. It is consistent with the [behavior of `tsc` 4.3.2 and later](https://github.com/microsoft/TypeScript/pull/42663). It is also the standard ECMAScript runtime behavior.

    Other TypeScript targets will default to `false`.

    But it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the [TypeScript 3.7 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier).

    If you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.

    Most libraries expect `"useDefineForClassFields": true`, such as [MobX](https://mobx.js.org/installation.html#use-spec-compliant-transpilation-for-class-properties).

    But a few libraries haven't transitioned to this new default yet, including [`lit-element`](https://github.com/lit/lit-element/issues/1030). Please explicitly set `useDefineForClassFields` to `false` in these cases.

    #### `target`

    - [TypeScript documentation](https://www.typescriptlang.org/tsconfig#target)

    Vite does not transpile TypeScript with the configured `target` value by default, following the same behaviour as `esbuild`.

    The [`esbuild.target`](../config/shared-options#esbuild) option can be used instead, which defaults to `esnext` for minimal transpilation. In builds, the [`build.target`](../config/build-options#build-target) option takes higher priority and can also be set if needed.

    **`useDefineForClassFields`**

    If `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.

    As such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.

    #### Other Compiler Options Affecting the Build Result

    - [`extends`](https://www.typescriptlang.org/tsconfig#extends)
    - [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues)
    - [`preserveValueImports`](https://www.typescriptlang.org/tsconfig#preserveValueImports)
    - [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax)
    - [`jsx`](https://www.typescriptlang.org/tsconfig#jsx)
    - [`jsxFactory`](https://www.typescriptlang.org/tsconfig#jsxFactory)
    - [`jsxFragmentFactory`](https://www.typescriptlang.org/tsconfig#jsxFragmentFactory)
    - [`jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource)
    - [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators)
    - [`alwaysStrict`](https://www.typescriptlang.org/tsconfig#alwaysStrict)

    **`skipLibCheck`**

    Vite starter templates have `"skipLibCheck": "true"` by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at [vuejs/vue-cli#5688](https://github.com/vuejs/vue-cli/pull/5688).
- name: 'Features: Vue'
  id: guide/features#vue
  summary: null
  belongs_to: Features
  description: |-
    ## Vue

    Vite provides first-class Vue support:

    - Vue 3 SFC support via [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue)
    - Vue 3 JSX support via [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue-jsx)
    - Vue 2.7 SFC support via [@vitejs/plugin-vue2](https://github.com/vitejs/vite-plugin-vue2)
    - Vue 2.7 JSX support via [@vitejs/plugin-vue2-jsx](https://github.com/vitejs/vite-plugin-vue2-jsx)
- name: 'Features: Web Workers'
  id: guide/features#web-workers
  summary: null
  belongs_to: Features
  description: '## Web Workers'
- name: 'Features: WebAssembly'
  id: guide/features#webassembly
  summary: Pre-compiled .wasm files can be imported with ?init
  belongs_to: Features
  description: |-
    ## WebAssembly

    Pre-compiled `.wasm` files can be imported with `?init`. The default export will be an initialization function that returns a Promise of the [`WebAssembly.Instance`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/Instance):

    js

    ``` javascript
    import init from './example.wasm?init'

    init().then((instance) => {
      instance.exports.test()
    })
    ```

    The init function can also take an importObject which is passed along to [`WebAssembly.instantiate`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate) as its second argument:

    js

    ``` javascript
    init({
      imports: {
        someFunc: () => {
          /* ... */
        },
      },
    }).then(() => {
      /* ... */
    })
    ```

    In the production build, `.wasm` files smaller than `assetInlineLimit` will be inlined as base64 strings. Otherwise, they will be treated as a [static asset](assets) and fetched on-demand.

    **NOTE**

    [ES Module Integration Proposal for WebAssembly](https://github.com/WebAssembly/esm-integration) is not currently supported. Use [`vite-plugin-wasm`](https://github.com/Menci/vite-plugin-wasm) or other community plugins to handle this.
- name: Getting Started
  id: guide/index
  summary: Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects
  description: "# Getting Started\n\n## Overview\n\nVite (French word for \"quick\", pronounced `/vit/`, like \"veet\") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:\n\n- A dev server that provides [rich feature enhancements](features) over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), for example extremely fast [Hot Module Replacement (HMR)](features#hot-module-replacement).\n\n- A build command that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.\n\nVite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the [Features Guide](features). Support for frameworks or integration with other tools is possible through [Plugins](using-plugins). The [Config Section](../config/index) explains how to adapt Vite to your project if needed.\n\nVite is also highly extensible via its [Plugin API](api-plugin) and [JavaScript API](api-javascript) with full typing support.\n\nYou can learn more about the rationale behind the project in the [Why Vite](why) section.\n\n## Browser Support\n\nDuring development, Vite sets [`esnext` as the transform target](https://esbuild.github.io/api/#target), because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.\n\nFor the production build, by default Vite targets browsers that support [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). Legacy browsers can be supported via the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy). See the [Building for Production](build) section for more details.\n\n## Trying Vite Online\n\nYou can try Vite online on [StackBlitz](https://vite.new/). It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to `vite.new/{template}` to select which framework to use.\n\nThe supported template presets are:\n\n|             JavaScript              |                TypeScript                 |\n|:-----------------------------------:|:-----------------------------------------:|\n| [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |\n|     [vue](https://vite.new/vue)     |     [vue-ts](https://vite.new/vue-ts)     |\n|   [react](https://vite.new/react)   |   [react-ts](https://vite.new/react-ts)   |\n|  [preact](https://vite.new/preact)  |  [preact-ts](https://vite.new/preact-ts)  |\n|     [lit](https://vite.new/lit)     |     [lit-ts](https://vite.new/lit-ts)     |\n|  [svelte](https://vite.new/svelte)  |  [svelte-ts](https://vite.new/svelte-ts)  |\n|   [solid](https://vite.new/solid)   |   [solid-ts](https://vite.new/solid-ts)   |\n|    [qwik](https://vite.new/qwik)    |    [qwik-ts](https://vite.new/qwik-ts)    |\n\n## Scaffolding Your First Vite Project\n\n**Compatibility Note**\n\nVite requires [Node.js](https://nodejs.org/en/) version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.\n\nNPMYarnPNPMBun\n\nbash\n\n``` javascript\n$ npm create vite@latest\n```\n\nbash\n\n``` javascript\n$ yarn create vite\n```\n\nbash\n\n``` javascript\n$ pnpm create vite\n```\n\nbash\n\n``` javascript\n$ bun create vite\n```\n\nThen follow the prompts!\n\nYou can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:\n\nbash\n\n``` javascript\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n```\n\nSee [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) for more details on each supported template: `vanilla`, `vanilla-ts`, `vue`, `vue-ts`, `react`, `react-ts`, `react-swc`, `react-swc-ts`, `preact`, `preact-ts`, `lit`, `lit-ts`, `svelte`, `svelte-ts`, `solid`, `solid-ts`, `qwik`, `qwik-ts`.\n\nYou can use `.` for the project name to scaffold in the current directory.\n\n## Community Templates\n\ncreate-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for [community maintained templates](https://github.com/vitejs/awesome-vite#templates) that include other tools or target different frameworks.\n\nFor a template at `https://github.com/user/project`, you can try it out online using `https://github.stackblitz.com/user/project` (adding `.stackblitz` after `github` to the URL of the project).\n\nYou can also use a tool like [degit](https://github.com/Rich-Harris/degit) to scaffold your project with one of the templates. Assuming the project is on GitHub and uses `main` as the default branch, you can create a local copy using:\n\nbash\n\n``` javascript\nnpx degit user/project#main my-project\ncd my-project\n\nnpm install\nnpm run dev\n```\n\n## `index.html` and Project Root\n\nOne thing you may have noticed is that in a Vite project, `index.html` is front-and-central instead of being tucked away inside `public`. This is intentional: during development Vite is a server, and `index.html` is the entry point to your application.\n\nVite treats `index.html` as source code and part of the module graph. It resolves `<script type=\"module\" src=\"...\">` that references your JavaScript source code. Even inline `<script type=\"module\">` and CSS referenced via `<link href>` also enjoy Vite-specific features. In addition, URLs inside `index.html` are automatically rebased so there's no need for special `%PUBLIC_URL%` placeholders.\n\nSimilar to static http servers, Vite has the concept of a \"root directory\" which your files are served from. You will see it referenced as `<root>` throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.\n\nVite also supports [multi-page apps](build#multi-page-app) with multiple `.html` entry points.\n\n#### Specifying Alternative Root\n\nRunning `vite` starts the dev server using the current working directory as root. You can specify an alternative root with `vite serve some/sub/dir`. Note that Vite will also resolve [its config file (i.e. `vite.config.js`)](../config/index#configuring-vite) inside the project root, so you'll need to move it if the root is changed.\n\n## Command Line Interface\n\nIn a project where Vite is installed, you can use the `vite` binary in your npm scripts, or run it directly with `npx vite`. Here are the default npm scripts in a scaffolded Vite project:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // start dev server, aliases: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // build for production\n    \"preview\": \"vite preview\" // locally preview production build\n  }\n}\n```\n\nYou can specify additional CLI options like `--port` or `--open`. For a full list of CLI options, run `npx vite --help` in your project.\n\nLearn more about the [Command Line Interface](cli)\n\n## Using Unreleased Commits\n\nIf you can't wait for a new release to test the latest features, you will need to clone the [vite repo](https://github.com/vitejs/vite) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):\n\nbash\n\n``` javascript\ngit clone https://github.com/vitejs/vite.git\ncd vite\npnpm install\ncd packages/vite\npnpm run build\npnpm link --global # use your preferred package manager for this step\n```\n\nThen go to your Vite based project and run `pnpm link --global vite` (or the package manager that you used to link `vite` globally). Now restart the development server to ride on the bleeding edge!\n\n## Community\n\nIf you have questions or need help, reach out to the community at [Discord](https://chat.vitejs.dev) and [GitHub Discussions](https://github.com/vitejs/vite/discussions).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/](https://vitejs.dev/guide/)"
- name: 'Getting Started: APIs'
  id: guide/index
  summary: Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects
  description: "# Getting Started\n\n## Overview\n\nVite (French word for \"quick\", pronounced `/vit/`, like \"veet\") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:\n\n- A dev server that provides [rich feature enhancements](features) over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), for example extremely fast [Hot Module Replacement (HMR)](features#hot-module-replacement).\n\n- A build command that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.\n\nVite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the [Features Guide](features). Support for frameworks or integration with other tools is possible through [Plugins](using-plugins). The [Config Section](../config/index) explains how to adapt Vite to your project if needed.\n\nVite is also highly extensible via its [Plugin API](api-plugin) and [JavaScript API](api-javascript) with full typing support.\n\nYou can learn more about the rationale behind the project in the [Why Vite](why) section.\n\n## Browser Support\n\nDuring development, Vite sets [`esnext` as the transform target](https://esbuild.github.io/api/#target), because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.\n\nFor the production build, by default Vite targets browsers that support [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). Legacy browsers can be supported via the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy). See the [Building for Production](build) section for more details.\n\n## Trying Vite Online\n\nYou can try Vite online on [StackBlitz](https://vite.new/). It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to `vite.new/{template}` to select which framework to use.\n\nThe supported template presets are:\n\n|             JavaScript              |                TypeScript                 |\n|:-----------------------------------:|:-----------------------------------------:|\n| [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |\n|     [vue](https://vite.new/vue)     |     [vue-ts](https://vite.new/vue-ts)     |\n|   [react](https://vite.new/react)   |   [react-ts](https://vite.new/react-ts)   |\n|  [preact](https://vite.new/preact)  |  [preact-ts](https://vite.new/preact-ts)  |\n|     [lit](https://vite.new/lit)     |     [lit-ts](https://vite.new/lit-ts)     |\n|  [svelte](https://vite.new/svelte)  |  [svelte-ts](https://vite.new/svelte-ts)  |\n|   [solid](https://vite.new/solid)   |   [solid-ts](https://vite.new/solid-ts)   |\n|    [qwik](https://vite.new/qwik)    |    [qwik-ts](https://vite.new/qwik-ts)    |\n\n## Scaffolding Your First Vite Project\n\n**Compatibility Note**\n\nVite requires [Node.js](https://nodejs.org/en/) version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.\n\nNPMYarnPNPMBun\n\nbash\n\n``` javascript\n$ npm create vite@latest\n```\n\nbash\n\n``` javascript\n$ yarn create vite\n```\n\nbash\n\n``` javascript\n$ pnpm create vite\n```\n\nbash\n\n``` javascript\n$ bun create vite\n```\n\nThen follow the prompts!\n\nYou can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:\n\nbash\n\n``` javascript\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n```\n\nSee [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) for more details on each supported template: `vanilla`, `vanilla-ts`, `vue`, `vue-ts`, `react`, `react-ts`, `react-swc`, `react-swc-ts`, `preact`, `preact-ts`, `lit`, `lit-ts`, `svelte`, `svelte-ts`, `solid`, `solid-ts`, `qwik`, `qwik-ts`.\n\nYou can use `.` for the project name to scaffold in the current directory.\n\n## Community Templates\n\ncreate-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for [community maintained templates](https://github.com/vitejs/awesome-vite#templates) that include other tools or target different frameworks.\n\nFor a template at `https://github.com/user/project`, you can try it out online using `https://github.stackblitz.com/user/project` (adding `.stackblitz` after `github` to the URL of the project).\n\nYou can also use a tool like [degit](https://github.com/Rich-Harris/degit) to scaffold your project with one of the templates. Assuming the project is on GitHub and uses `main` as the default branch, you can create a local copy using:\n\nbash\n\n``` javascript\nnpx degit user/project#main my-project\ncd my-project\n\nnpm install\nnpm run dev\n```\n\n## `index.html` and Project Root\n\nOne thing you may have noticed is that in a Vite project, `index.html` is front-and-central instead of being tucked away inside `public`. This is intentional: during development Vite is a server, and `index.html` is the entry point to your application.\n\nVite treats `index.html` as source code and part of the module graph. It resolves `<script type=\"module\" src=\"...\">` that references your JavaScript source code. Even inline `<script type=\"module\">` and CSS referenced via `<link href>` also enjoy Vite-specific features. In addition, URLs inside `index.html` are automatically rebased so there's no need for special `%PUBLIC_URL%` placeholders.\n\nSimilar to static http servers, Vite has the concept of a \"root directory\" which your files are served from. You will see it referenced as `<root>` throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.\n\nVite also supports [multi-page apps](build#multi-page-app) with multiple `.html` entry points.\n\n#### Specifying Alternative Root\n\nRunning `vite` starts the dev server using the current working directory as root. You can specify an alternative root with `vite serve some/sub/dir`. Note that Vite will also resolve [its config file (i.e. `vite.config.js`)](../config/index#configuring-vite) inside the project root, so you'll need to move it if the root is changed.\n\n## Command Line Interface\n\nIn a project where Vite is installed, you can use the `vite` binary in your npm scripts, or run it directly with `npx vite`. Here are the default npm scripts in a scaffolded Vite project:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // start dev server, aliases: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // build for production\n    \"preview\": \"vite preview\" // locally preview production build\n  }\n}\n```\n\nYou can specify additional CLI options like `--port` or `--open`. For a full list of CLI options, run `npx vite --help` in your project.\n\nLearn more about the [Command Line Interface](cli)\n\n## Using Unreleased Commits\n\nIf you can't wait for a new release to test the latest features, you will need to clone the [vite repo](https://github.com/vitejs/vite) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):\n\nbash\n\n``` javascript\ngit clone https://github.com/vitejs/vite.git\ncd vite\npnpm install\ncd packages/vite\npnpm run build\npnpm link --global # use your preferred package manager for this step\n```\n\nThen go to your Vite based project and run `pnpm link --global vite` (or the package manager that you used to link `vite` globally). Now restart the development server to ride on the bleeding edge!\n\n## Community\n\nIf you have questions or need help, reach out to the community at [Discord](https://chat.vitejs.dev) and [GitHub Discussions](https://github.com/vitejs/vite/discussions).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/](https://vitejs.dev/guide/)"
- name: 'Getting Started: Browser Support'
  id: guide/index#browser-support
  summary: During development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features
  belongs_to: Getting Started
  description: |-
    ## Browser Support

    During development, Vite sets [`esnext` as the transform target](https://esbuild.github.io/api/#target), because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.

    For the production build, by default Vite targets browsers that support [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). Legacy browsers can be supported via the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy). See the [Building for Production](build) section for more details.
- name: 'Getting Started: Command Line Interface'
  id: guide/index#command-line-interface
  summary: In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite
  belongs_to: Getting Started
  description: |-
    ## Command Line Interface

    In a project where Vite is installed, you can use the `vite` binary in your npm scripts, or run it directly with `npx vite`. Here are the default npm scripts in a scaffolded Vite project:

    json

    ``` javascript
    {
      "scripts": {
        "dev": "vite", // start dev server, aliases: `vite dev`, `vite serve`
        "build": "vite build", // build for production
        "preview": "vite preview" // locally preview production build
      }
    }
    ```

    You can specify additional CLI options like `--port` or `--open`. For a full list of CLI options, run `npx vite --help` in your project.

    Learn more about the [Command Line Interface](cli)
- name: 'Getting Started: Community'
  id: guide/index#community
  summary: If you have questions or need help, reach out to the community at Discord and GitHub Discussions
  belongs_to: Getting Started
  description: "## Community\n\nIf you have questions or need help, reach out to the community at [Discord](https://chat.vitejs.dev) and [GitHub Discussions](https://github.com/vitejs/vite/discussions).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/](https://vitejs.dev/guide/)"
- name: 'Getting Started: Community Templates'
  id: guide/index#community-templates
  summary: create-vite is a tool to quickly start a project from a basic template for popular frameworks
  belongs_to: Getting Started
  description: |-
    ## Community Templates

    create-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for [community maintained templates](https://github.com/vitejs/awesome-vite#templates) that include other tools or target different frameworks.

    For a template at `https://github.com/user/project`, you can try it out online using `https://github.stackblitz.com/user/project` (adding `.stackblitz` after `github` to the URL of the project).

    You can also use a tool like [degit](https://github.com/Rich-Harris/degit) to scaffold your project with one of the templates. Assuming the project is on GitHub and uses `main` as the default branch, you can create a local copy using:

    bash

    ``` javascript
    npx degit user/project#main my-project
    cd my-project

    npm install
    npm run dev
    ```
- name: 'Getting Started: Guide'
  id: guide/index
  summary: Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects
  description: "# Getting Started\n\n## Overview\n\nVite (French word for \"quick\", pronounced `/vit/`, like \"veet\") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:\n\n- A dev server that provides [rich feature enhancements](features) over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), for example extremely fast [Hot Module Replacement (HMR)](features#hot-module-replacement).\n\n- A build command that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.\n\nVite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the [Features Guide](features). Support for frameworks or integration with other tools is possible through [Plugins](using-plugins). The [Config Section](../config/index) explains how to adapt Vite to your project if needed.\n\nVite is also highly extensible via its [Plugin API](api-plugin) and [JavaScript API](api-javascript) with full typing support.\n\nYou can learn more about the rationale behind the project in the [Why Vite](why) section.\n\n## Browser Support\n\nDuring development, Vite sets [`esnext` as the transform target](https://esbuild.github.io/api/#target), because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.\n\nFor the production build, by default Vite targets browsers that support [native ES Modules](https://caniuse.com/es6-module), [native ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). Legacy browsers can be supported via the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy). See the [Building for Production](build) section for more details.\n\n## Trying Vite Online\n\nYou can try Vite online on [StackBlitz](https://vite.new/). It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to `vite.new/{template}` to select which framework to use.\n\nThe supported template presets are:\n\n|             JavaScript              |                TypeScript                 |\n|:-----------------------------------:|:-----------------------------------------:|\n| [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |\n|     [vue](https://vite.new/vue)     |     [vue-ts](https://vite.new/vue-ts)     |\n|   [react](https://vite.new/react)   |   [react-ts](https://vite.new/react-ts)   |\n|  [preact](https://vite.new/preact)  |  [preact-ts](https://vite.new/preact-ts)  |\n|     [lit](https://vite.new/lit)     |     [lit-ts](https://vite.new/lit-ts)     |\n|  [svelte](https://vite.new/svelte)  |  [svelte-ts](https://vite.new/svelte-ts)  |\n|   [solid](https://vite.new/solid)   |   [solid-ts](https://vite.new/solid-ts)   |\n|    [qwik](https://vite.new/qwik)    |    [qwik-ts](https://vite.new/qwik-ts)    |\n\n## Scaffolding Your First Vite Project\n\n**Compatibility Note**\n\nVite requires [Node.js](https://nodejs.org/en/) version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.\n\nNPMYarnPNPMBun\n\nbash\n\n``` javascript\n$ npm create vite@latest\n```\n\nbash\n\n``` javascript\n$ yarn create vite\n```\n\nbash\n\n``` javascript\n$ pnpm create vite\n```\n\nbash\n\n``` javascript\n$ bun create vite\n```\n\nThen follow the prompts!\n\nYou can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:\n\nbash\n\n``` javascript\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbun create vite my-vue-app --template vue\n```\n\nSee [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) for more details on each supported template: `vanilla`, `vanilla-ts`, `vue`, `vue-ts`, `react`, `react-ts`, `react-swc`, `react-swc-ts`, `preact`, `preact-ts`, `lit`, `lit-ts`, `svelte`, `svelte-ts`, `solid`, `solid-ts`, `qwik`, `qwik-ts`.\n\nYou can use `.` for the project name to scaffold in the current directory.\n\n## Community Templates\n\ncreate-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for [community maintained templates](https://github.com/vitejs/awesome-vite#templates) that include other tools or target different frameworks.\n\nFor a template at `https://github.com/user/project`, you can try it out online using `https://github.stackblitz.com/user/project` (adding `.stackblitz` after `github` to the URL of the project).\n\nYou can also use a tool like [degit](https://github.com/Rich-Harris/degit) to scaffold your project with one of the templates. Assuming the project is on GitHub and uses `main` as the default branch, you can create a local copy using:\n\nbash\n\n``` javascript\nnpx degit user/project#main my-project\ncd my-project\n\nnpm install\nnpm run dev\n```\n\n## `index.html` and Project Root\n\nOne thing you may have noticed is that in a Vite project, `index.html` is front-and-central instead of being tucked away inside `public`. This is intentional: during development Vite is a server, and `index.html` is the entry point to your application.\n\nVite treats `index.html` as source code and part of the module graph. It resolves `<script type=\"module\" src=\"...\">` that references your JavaScript source code. Even inline `<script type=\"module\">` and CSS referenced via `<link href>` also enjoy Vite-specific features. In addition, URLs inside `index.html` are automatically rebased so there's no need for special `%PUBLIC_URL%` placeholders.\n\nSimilar to static http servers, Vite has the concept of a \"root directory\" which your files are served from. You will see it referenced as `<root>` throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.\n\nVite also supports [multi-page apps](build#multi-page-app) with multiple `.html` entry points.\n\n#### Specifying Alternative Root\n\nRunning `vite` starts the dev server using the current working directory as root. You can specify an alternative root with `vite serve some/sub/dir`. Note that Vite will also resolve [its config file (i.e. `vite.config.js`)](../config/index#configuring-vite) inside the project root, so you'll need to move it if the root is changed.\n\n## Command Line Interface\n\nIn a project where Vite is installed, you can use the `vite` binary in your npm scripts, or run it directly with `npx vite`. Here are the default npm scripts in a scaffolded Vite project:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // start dev server, aliases: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // build for production\n    \"preview\": \"vite preview\" // locally preview production build\n  }\n}\n```\n\nYou can specify additional CLI options like `--port` or `--open`. For a full list of CLI options, run `npx vite --help` in your project.\n\nLearn more about the [Command Line Interface](cli)\n\n## Using Unreleased Commits\n\nIf you can't wait for a new release to test the latest features, you will need to clone the [vite repo](https://github.com/vitejs/vite) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):\n\nbash\n\n``` javascript\ngit clone https://github.com/vitejs/vite.git\ncd vite\npnpm install\ncd packages/vite\npnpm run build\npnpm link --global # use your preferred package manager for this step\n```\n\nThen go to your Vite based project and run `pnpm link --global vite` (or the package manager that you used to link `vite` globally). Now restart the development server to ride on the bleeding edge!\n\n## Community\n\nIf you have questions or need help, reach out to the community at [Discord](https://chat.vitejs.dev) and [GitHub Discussions](https://github.com/vitejs/vite/discussions).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/](https://vitejs.dev/guide/)"
- name: 'Getting Started: index.html and Project Root'
  id: guide/index#index-html-and-project-root
  summary: One thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public
  belongs_to: Getting Started
  description: |-
    ## `index.html` and Project Root

    One thing you may have noticed is that in a Vite project, `index.html` is front-and-central instead of being tucked away inside `public`. This is intentional: during development Vite is a server, and `index.html` is the entry point to your application.

    Vite treats `index.html` as source code and part of the module graph. It resolves `<script type="module" src="...">` that references your JavaScript source code. Even inline `<script type="module">` and CSS referenced via `<link href>` also enjoy Vite-specific features. In addition, URLs inside `index.html` are automatically rebased so there's no need for special `%PUBLIC_URL%` placeholders.

    Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as `<root>` throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.

    Vite also supports [multi-page apps](build#multi-page-app) with multiple `.html` entry points.

    #### Specifying Alternative Root

    Running `vite` starts the dev server using the current working directory as root. You can specify an alternative root with `vite serve some/sub/dir`. Note that Vite will also resolve [its config file (i.e. `vite.config.js`)](../config/index#configuring-vite) inside the project root, so you'll need to move it if the root is changed.
- name: 'Getting Started: Overview'
  id: guide/index#overview
  summary: Vite (French word for "quick", pronounced /vit/, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects
  belongs_to: Getting Started
  description: |-
    ## Overview

    Vite (French word for "quick", pronounced `/vit/`, like "veet") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:

    - A dev server that provides [rich feature enhancements](features) over [native ES modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), for example extremely fast [Hot Module Replacement (HMR)](features#hot-module-replacement).

    - A build command that bundles your code with [Rollup](https://rollupjs.org), pre-configured to output highly optimized static assets for production.

    Vite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the [Features Guide](features). Support for frameworks or integration with other tools is possible through [Plugins](using-plugins). The [Config Section](../config/index) explains how to adapt Vite to your project if needed.

    Vite is also highly extensible via its [Plugin API](api-plugin) and [JavaScript API](api-javascript) with full typing support.

    You can learn more about the rationale behind the project in the [Why Vite](why) section.
- name: 'Getting Started: Scaffolding Your First Vite Project'
  id: guide/index#scaffolding-your-first-vite-project
  summary: Vite requires Node.js version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it
  belongs_to: Getting Started
  description: |-
    ## Scaffolding Your First Vite Project

    **Compatibility Note**

    Vite requires [Node.js](https://nodejs.org/en/) version 18+ or 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.

    NPM Yarn PNPM Bun

    bash

    ``` javascript
    $ npm create vite@latest
    ```

    bash

    ``` javascript
    $ yarn create vite
    ```

    bash

    ``` javascript
    $ pnpm create vite
    ```

    bash

    ``` javascript
    $ bun create vite
    ```

    Then follow the prompts!

    You can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:

    bash

    ``` javascript
    # npm 7+, extra double-dash is needed:
    npm create vite@latest my-vue-app -- --template vue

    # yarn
    yarn create vite my-vue-app --template vue

    # pnpm
    pnpm create vite my-vue-app --template vue

    # bun
    bun create vite my-vue-app --template vue
    ```

    See [create-vite](https://github.com/vitejs/vite/tree/main/packages/create-vite) for more details on each supported template: `vanilla`, `vanilla-ts`, `vue`, `vue-ts`, `react`, `react-ts`, `react-swc`, `react-swc-ts`, `preact`, `preact-ts`, `lit`, `lit-ts`, `svelte`, `svelte-ts`, `solid`, `solid-ts`, `qwik`, `qwik-ts`.

    You can use `.` for the project name to scaffold in the current directory.
- name: 'Getting Started: Trying Vite Online'
  id: guide/index#trying-vite-online
  summary: You can try Vite online on StackBlitz
  belongs_to: Getting Started
  description: |-
    ## Trying Vite Online

    You can try Vite online on [StackBlitz](https://vite.new/). It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to `vite.new/{template}` to select which framework to use.

    The supported template presets are:

    |             JavaScript              |                TypeScript                 |
    |:-----------------------------------:|:-----------------------------------------:|
    | [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |
    |     [vue](https://vite.new/vue)     |     [vue-ts](https://vite.new/vue-ts)     |
    |   [react](https://vite.new/react)   |   [react-ts](https://vite.new/react-ts)   |
    |  [preact](https://vite.new/preact)  |  [preact-ts](https://vite.new/preact-ts)  |
    |     [lit](https://vite.new/lit)     |     [lit-ts](https://vite.new/lit-ts)     |
    |  [svelte](https://vite.new/svelte)  |  [svelte-ts](https://vite.new/svelte-ts)  |
    |   [solid](https://vite.new/solid)   |   [solid-ts](https://vite.new/solid-ts)   |
    |    [qwik](https://vite.new/qwik)    |    [qwik-ts](https://vite.new/qwik-ts)    |
- name: 'Getting Started: Using Unreleased Commits'
  id: guide/index#using-unreleased-commits
  summary: null
  belongs_to: Getting Started
  description: |-
    ## Using Unreleased Commits

    If you can't wait for a new release to test the latest features, you will need to clone the [vite repo](https://github.com/vitejs/vite) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):

    bash

    ``` javascript
    git clone https://github.com/vitejs/vite.git
    cd vite
    pnpm install
    cd packages/vite
    pnpm run build
    pnpm link --global # use your preferred package manager for this step
    ```

    Then go to your Vite based project and run `pnpm link --global vite` (or the package manager that you used to link `vite` globally). Now restart the development server to ride on the bleeding edge!
- name: HMR API
  id: guide/api-hmr
  summary: This is the client HMR API
  description: "# HMR API\n\n**Note**\n\nThis is the client HMR API. For handling HMR update in plugins, see [handleHotUpdate](api-plugin#handlehotupdate).\n\nThe manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.\n\nVite exposes its manual HMR API via the special `import.meta.hot` object:\n\nts\n\n``` javascript\ninterface ImportMeta {\n  readonly hot?: ViteHotContext\n}\n\ninterface ViteHotContext {\n  readonly data: any\n\n  accept(): void\n  accept(cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(\n    deps: readonly string[],\n    cb: (mods: Array<ModuleNamespace | undefined>) => void,\n  ): void\n\n  dispose(cb: (data: any) => void): void\n  prune(cb: (data: any) => void): void\n  invalidate(message?: string): void\n\n  on<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  off<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void\n}\n```\n\n## Required Conditional Guard\n\nFirst of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:\n\njs\n\n``` javascript\nif (import.meta.hot) {\n  // HMR code\n}\n```\n\n## IntelliSense for TypeScript\n\nVite provides type definitions for `import.meta.hot` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). You can create an `env.d.ts` in the `src` directory so TypeScript picks up the type definitions:\n\nts\n\n``` javascript\n/// <reference types=\"vite/client\" />\n```\n\n## `hot.accept(cb)`\n\nFor a module to self-accept, use `import.meta.hot.accept` with a callback which receives the updated module:\n\njs\n\n``` javascript\nexport const count = 1\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (newModule) {\n      // newModule is undefined when SyntaxError happened\n      console.log('updated: count is now ', newModule.count)\n    }\n  })\n}\n```\n\nA module that \"accepts\" hot updates is considered an **HMR boundary**.\n\nVite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using `let`). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.\n\nVite requires that the call to this function appears as `import.meta.hot.accept(` (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.\n\n## `hot.accept(deps, cb)`\n\nA module can also accept updates from direct dependencies without reloading itself:\n\njs\n\n``` javascript\nimport { foo } from './foo.js'\n\nfoo()\n\nif (import.meta.hot) {\n  import.meta.hot.accept('./foo.js', (newFoo) => {\n    // the callback receives the updated './foo.js' module\n    newFoo?.foo()\n  })\n\n  // Can also accept an array of dep modules:\n  import.meta.hot.accept(\n    ['./foo.js', './bar.js'],\n    ([newFooModule, newBarModule]) => {\n      // The callback receives an array where only the updated module is\n      // non null. If the update was not successful (syntax error for ex.),\n      // the array is empty\n    },\n  )\n}\n```\n\n## `hot.dispose(cb)`\n\nA self-accepting module or a module that expects to be accepted by others can use `hot.dispose` to clean-up any persistent side effects created by its updated copy:\n\njs\n\n``` javascript\nfunction setupSideEffect() {}\n\nsetupSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.dispose((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n## `hot.prune(cb)`\n\nRegister a callback that will call when the module is no longer imported on the page. Compared to `hot.dispose`, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for `.css` imports.\n\njs\n\n``` javascript\nfunction setupOrReuseSideEffect() {}\n\nsetupOrReuseSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.prune((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n## `hot.data`\n\nThe `import.meta.hot.data` object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.\n\nNote that re-assignment of `data` itself is not supported. Instead, you should mutate properties of the `data` object so information added from other handlers are preserved.\n\njs\n\n``` javascript\n// ok\nimport.meta.hot.data.someValue = 'hello'\n\n// not supported\nimport.meta.hot.data = { someValue: 'hello' }\n```\n\n## `hot.decline()`\n\nThis is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use `hot.invalidate()`.\n\n## `hot.invalidate(message?: string)`\n\nA self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling `import.meta.hot.invalidate()`, the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.\n\nNote that you should always call `import.meta.hot.accept` even if you plan to call `invalidate` immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling `invalidate` within the `accept` callback like so:\n\njs\n\n``` javascript\nimport.meta.hot.accept((module) => {\n  // You may use the new module instance to decide whether to invalidate.\n  if (cannotHandleUpdate(module)) {\n    import.meta.hot.invalidate()\n  }\n})\n```\n\n## `hot.on(event, cb)`\n\nListen to an HMR event.\n\nThe following HMR events are dispatched by Vite automatically:\n\n- `'vite:beforeUpdate'` when an update is about to be applied (e.g. a module will be replaced)\n- `'vite:afterUpdate'` when an update has just been applied (e.g. a module has been replaced)\n- `'vite:beforeFullReload'` when a full reload is about to occur\n- `'vite:beforePrune'` when modules that are no longer needed are about to be pruned\n- `'vite:invalidate'` when a module is invalidated with `import.meta.hot.invalidate()`\n- `'vite:error'` when an error occurs (e.g. syntax error)\n- `'vite:ws:disconnect'` when the WebSocket connection is lost\n- `'vite:ws:connect'` when the WebSocket connection is (re-)established\n\nCustom HMR events can also be sent from plugins. See [handleHotUpdate](api-plugin#handlehotupdate) for more details.\n\n## `hot.off(event, cb)`\n\nRemove callback from the event listeners.\n\n## `hot.send(event, data)`\n\nSend custom events back to Vite's dev server.\n\nIf called before connected, the data will be buffered and sent once the connection is established.\n\nSee [Client-server Communication](api-plugin#client-server-communication) for more details, including a section on [Typing Custom Events](api-plugin#typescript-for-custom-events).\n\n## Further Reading\n\nIf you'd like to learn more about how to use the HMR API and how it works under-the-hood. Check out these resources:\n\n- [Hot Module Replacement is Easy](https://bjornlu.com/blog/hot-module-replacement-is-easy)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-hmr](https://vitejs.dev/guide/api-hmr)"
- name: 'HMR API: APIs'
  id: guide/api-hmr
  summary: This is the client HMR API
  description: "# HMR API\n\n**Note**\n\nThis is the client HMR API. For handling HMR update in plugins, see [handleHotUpdate](api-plugin#handlehotupdate).\n\nThe manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.\n\nVite exposes its manual HMR API via the special `import.meta.hot` object:\n\nts\n\n``` javascript\ninterface ImportMeta {\n  readonly hot?: ViteHotContext\n}\n\ninterface ViteHotContext {\n  readonly data: any\n\n  accept(): void\n  accept(cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(\n    deps: readonly string[],\n    cb: (mods: Array<ModuleNamespace | undefined>) => void,\n  ): void\n\n  dispose(cb: (data: any) => void): void\n  prune(cb: (data: any) => void): void\n  invalidate(message?: string): void\n\n  on<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  off<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void\n}\n```\n\n## Required Conditional Guard\n\nFirst of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:\n\njs\n\n``` javascript\nif (import.meta.hot) {\n  // HMR code\n}\n```\n\n## IntelliSense for TypeScript\n\nVite provides type definitions for `import.meta.hot` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). You can create an `env.d.ts` in the `src` directory so TypeScript picks up the type definitions:\n\nts\n\n``` javascript\n/// <reference types=\"vite/client\" />\n```\n\n## `hot.accept(cb)`\n\nFor a module to self-accept, use `import.meta.hot.accept` with a callback which receives the updated module:\n\njs\n\n``` javascript\nexport const count = 1\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (newModule) {\n      // newModule is undefined when SyntaxError happened\n      console.log('updated: count is now ', newModule.count)\n    }\n  })\n}\n```\n\nA module that \"accepts\" hot updates is considered an **HMR boundary**.\n\nVite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using `let`). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.\n\nVite requires that the call to this function appears as `import.meta.hot.accept(` (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.\n\n## `hot.accept(deps, cb)`\n\nA module can also accept updates from direct dependencies without reloading itself:\n\njs\n\n``` javascript\nimport { foo } from './foo.js'\n\nfoo()\n\nif (import.meta.hot) {\n  import.meta.hot.accept('./foo.js', (newFoo) => {\n    // the callback receives the updated './foo.js' module\n    newFoo?.foo()\n  })\n\n  // Can also accept an array of dep modules:\n  import.meta.hot.accept(\n    ['./foo.js', './bar.js'],\n    ([newFooModule, newBarModule]) => {\n      // The callback receives an array where only the updated module is\n      // non null. If the update was not successful (syntax error for ex.),\n      // the array is empty\n    },\n  )\n}\n```\n\n## `hot.dispose(cb)`\n\nA self-accepting module or a module that expects to be accepted by others can use `hot.dispose` to clean-up any persistent side effects created by its updated copy:\n\njs\n\n``` javascript\nfunction setupSideEffect() {}\n\nsetupSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.dispose((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n## `hot.prune(cb)`\n\nRegister a callback that will call when the module is no longer imported on the page. Compared to `hot.dispose`, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for `.css` imports.\n\njs\n\n``` javascript\nfunction setupOrReuseSideEffect() {}\n\nsetupOrReuseSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.prune((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n## `hot.data`\n\nThe `import.meta.hot.data` object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.\n\nNote that re-assignment of `data` itself is not supported. Instead, you should mutate properties of the `data` object so information added from other handlers are preserved.\n\njs\n\n``` javascript\n// ok\nimport.meta.hot.data.someValue = 'hello'\n\n// not supported\nimport.meta.hot.data = { someValue: 'hello' }\n```\n\n## `hot.decline()`\n\nThis is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use `hot.invalidate()`.\n\n## `hot.invalidate(message?: string)`\n\nA self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling `import.meta.hot.invalidate()`, the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.\n\nNote that you should always call `import.meta.hot.accept` even if you plan to call `invalidate` immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling `invalidate` within the `accept` callback like so:\n\njs\n\n``` javascript\nimport.meta.hot.accept((module) => {\n  // You may use the new module instance to decide whether to invalidate.\n  if (cannotHandleUpdate(module)) {\n    import.meta.hot.invalidate()\n  }\n})\n```\n\n## `hot.on(event, cb)`\n\nListen to an HMR event.\n\nThe following HMR events are dispatched by Vite automatically:\n\n- `'vite:beforeUpdate'` when an update is about to be applied (e.g. a module will be replaced)\n- `'vite:afterUpdate'` when an update has just been applied (e.g. a module has been replaced)\n- `'vite:beforeFullReload'` when a full reload is about to occur\n- `'vite:beforePrune'` when modules that are no longer needed are about to be pruned\n- `'vite:invalidate'` when a module is invalidated with `import.meta.hot.invalidate()`\n- `'vite:error'` when an error occurs (e.g. syntax error)\n- `'vite:ws:disconnect'` when the WebSocket connection is lost\n- `'vite:ws:connect'` when the WebSocket connection is (re-)established\n\nCustom HMR events can also be sent from plugins. See [handleHotUpdate](api-plugin#handlehotupdate) for more details.\n\n## `hot.off(event, cb)`\n\nRemove callback from the event listeners.\n\n## `hot.send(event, data)`\n\nSend custom events back to Vite's dev server.\n\nIf called before connected, the data will be buffered and sent once the connection is established.\n\nSee [Client-server Communication](api-plugin#client-server-communication) for more details, including a section on [Typing Custom Events](api-plugin#typescript-for-custom-events).\n\n## Further Reading\n\nIf you'd like to learn more about how to use the HMR API and how it works under-the-hood. Check out these resources:\n\n- [Hot Module Replacement is Easy](https://bjornlu.com/blog/hot-module-replacement-is-easy)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-hmr](https://vitejs.dev/guide/api-hmr)"
- name: 'HMR API: Further Reading'
  id: guide/api-hmr#further-reading
  summary: If you'd like to learn more about how to use the HMR API and how it works under-the-hood
  belongs_to: HMR API
  description: "## Further Reading\n\nIf you'd like to learn more about how to use the HMR API and how it works under-the-hood. Check out these resources:\n\n- [Hot Module Replacement is Easy](https://bjornlu.com/blog/hot-module-replacement-is-easy)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-hmr](https://vitejs.dev/guide/api-hmr)"
- name: 'HMR API: Guide'
  id: guide/api-hmr
  summary: This is the client HMR API
  description: "# HMR API\n\n**Note**\n\nThis is the client HMR API. For handling HMR update in plugins, see [handleHotUpdate](api-plugin#handlehotupdate).\n\nThe manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.\n\nVite exposes its manual HMR API via the special `import.meta.hot` object:\n\nts\n\n``` javascript\ninterface ImportMeta {\n  readonly hot?: ViteHotContext\n}\n\ninterface ViteHotContext {\n  readonly data: any\n\n  accept(): void\n  accept(cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(\n    deps: readonly string[],\n    cb: (mods: Array<ModuleNamespace | undefined>) => void,\n  ): void\n\n  dispose(cb: (data: any) => void): void\n  prune(cb: (data: any) => void): void\n  invalidate(message?: string): void\n\n  on<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  off<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void\n}\n```\n\n## Required Conditional Guard\n\nFirst of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:\n\njs\n\n``` javascript\nif (import.meta.hot) {\n  // HMR code\n}\n```\n\n## IntelliSense for TypeScript\n\nVite provides type definitions for `import.meta.hot` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). You can create an `env.d.ts` in the `src` directory so TypeScript picks up the type definitions:\n\nts\n\n``` javascript\n/// <reference types=\"vite/client\" />\n```\n\n## `hot.accept(cb)`\n\nFor a module to self-accept, use `import.meta.hot.accept` with a callback which receives the updated module:\n\njs\n\n``` javascript\nexport const count = 1\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (newModule) {\n      // newModule is undefined when SyntaxError happened\n      console.log('updated: count is now ', newModule.count)\n    }\n  })\n}\n```\n\nA module that \"accepts\" hot updates is considered an **HMR boundary**.\n\nVite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using `let`). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.\n\nVite requires that the call to this function appears as `import.meta.hot.accept(` (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.\n\n## `hot.accept(deps, cb)`\n\nA module can also accept updates from direct dependencies without reloading itself:\n\njs\n\n``` javascript\nimport { foo } from './foo.js'\n\nfoo()\n\nif (import.meta.hot) {\n  import.meta.hot.accept('./foo.js', (newFoo) => {\n    // the callback receives the updated './foo.js' module\n    newFoo?.foo()\n  })\n\n  // Can also accept an array of dep modules:\n  import.meta.hot.accept(\n    ['./foo.js', './bar.js'],\n    ([newFooModule, newBarModule]) => {\n      // The callback receives an array where only the updated module is\n      // non null. If the update was not successful (syntax error for ex.),\n      // the array is empty\n    },\n  )\n}\n```\n\n## `hot.dispose(cb)`\n\nA self-accepting module or a module that expects to be accepted by others can use `hot.dispose` to clean-up any persistent side effects created by its updated copy:\n\njs\n\n``` javascript\nfunction setupSideEffect() {}\n\nsetupSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.dispose((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n## `hot.prune(cb)`\n\nRegister a callback that will call when the module is no longer imported on the page. Compared to `hot.dispose`, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for `.css` imports.\n\njs\n\n``` javascript\nfunction setupOrReuseSideEffect() {}\n\nsetupOrReuseSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.prune((data) => {\n    // cleanup side effect\n  })\n}\n```\n\n## `hot.data`\n\nThe `import.meta.hot.data` object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.\n\nNote that re-assignment of `data` itself is not supported. Instead, you should mutate properties of the `data` object so information added from other handlers are preserved.\n\njs\n\n``` javascript\n// ok\nimport.meta.hot.data.someValue = 'hello'\n\n// not supported\nimport.meta.hot.data = { someValue: 'hello' }\n```\n\n## `hot.decline()`\n\nThis is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use `hot.invalidate()`.\n\n## `hot.invalidate(message?: string)`\n\nA self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling `import.meta.hot.invalidate()`, the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.\n\nNote that you should always call `import.meta.hot.accept` even if you plan to call `invalidate` immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling `invalidate` within the `accept` callback like so:\n\njs\n\n``` javascript\nimport.meta.hot.accept((module) => {\n  // You may use the new module instance to decide whether to invalidate.\n  if (cannotHandleUpdate(module)) {\n    import.meta.hot.invalidate()\n  }\n})\n```\n\n## `hot.on(event, cb)`\n\nListen to an HMR event.\n\nThe following HMR events are dispatched by Vite automatically:\n\n- `'vite:beforeUpdate'` when an update is about to be applied (e.g. a module will be replaced)\n- `'vite:afterUpdate'` when an update has just been applied (e.g. a module has been replaced)\n- `'vite:beforeFullReload'` when a full reload is about to occur\n- `'vite:beforePrune'` when modules that are no longer needed are about to be pruned\n- `'vite:invalidate'` when a module is invalidated with `import.meta.hot.invalidate()`\n- `'vite:error'` when an error occurs (e.g. syntax error)\n- `'vite:ws:disconnect'` when the WebSocket connection is lost\n- `'vite:ws:connect'` when the WebSocket connection is (re-)established\n\nCustom HMR events can also be sent from plugins. See [handleHotUpdate](api-plugin#handlehotupdate) for more details.\n\n## `hot.off(event, cb)`\n\nRemove callback from the event listeners.\n\n## `hot.send(event, data)`\n\nSend custom events back to Vite's dev server.\n\nIf called before connected, the data will be buffered and sent once the connection is established.\n\nSee [Client-server Communication](api-plugin#client-server-communication) for more details, including a section on [Typing Custom Events](api-plugin#typescript-for-custom-events).\n\n## Further Reading\n\nIf you'd like to learn more about how to use the HMR API and how it works under-the-hood. Check out these resources:\n\n- [Hot Module Replacement is Easy](https://bjornlu.com/blog/hot-module-replacement-is-easy)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-hmr](https://vitejs.dev/guide/api-hmr)"
- name: 'HMR API: hot.accept(cb)'
  id: guide/api-hmr#hot-accept-cb
  summary: A module that "accepts" hot updates is considered an HMR boundary
  belongs_to: HMR API
  description: |-
    ## `hot.accept(cb)`

    For a module to self-accept, use `import.meta.hot.accept` with a callback which receives the updated module:

    js

    ``` javascript
    export const count = 1

    if (import.meta.hot) {
      import.meta.hot.accept((newModule) => {
        if (newModule) {
          // newModule is undefined when SyntaxError happened
          console.log('updated: count is now ', newModule.count)
        }
      })
    }
    ```

    A module that "accepts" hot updates is considered an **HMR boundary**.

    Vite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using `let`). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.

    Vite requires that the call to this function appears as `import.meta.hot.accept(` (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.
- name: 'HMR API: hot.accept(deps, cb)'
  id: guide/api-hmr#hot-accept-deps-cb
  summary: null
  belongs_to: HMR API
  description: |-
    ## `hot.accept(deps, cb)`

    A module can also accept updates from direct dependencies without reloading itself:

    js

    ``` javascript
    import { foo } from './foo.js'

    foo()

    if (import.meta.hot) {
      import.meta.hot.accept('./foo.js', (newFoo) => {
        // the callback receives the updated './foo.js' module
        newFoo?.foo()
      })

      // Can also accept an array of dep modules:
      import.meta.hot.accept(
        ['./foo.js', './bar.js'],
        ([newFooModule, newBarModule]) => {
          // The callback receives an array where only the updated module is
          // non null. If the update was not successful (syntax error for ex.),
          // the array is empty
        },
      )
    }
    ```
- name: 'HMR API: hot.data'
  id: guide/api-hmr#hot-data
  summary: The import.meta.hot.data object is persisted across different instances of the same updated module
  belongs_to: HMR API
  description: |-
    ## `hot.data`

    The `import.meta.hot.data` object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.

    Note that re-assignment of `data` itself is not supported. Instead, you should mutate properties of the `data` object so information added from other handlers are preserved.

    js

    ``` javascript
    // ok
    import.meta.hot.data.someValue = 'hello'

    // not supported
    import.meta.hot.data = { someValue: 'hello' }
    ```
- name: 'HMR API: hot.decline()'
  id: guide/api-hmr#hot-decline
  summary: This is currently a noop and is there for backward compatibility
  belongs_to: HMR API
  description: |-
    ## `hot.decline()`

    This is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use `hot.invalidate()`.
- name: 'HMR API: hot.dispose(cb)'
  id: guide/api-hmr#hot-dispose-cb
  summary: null
  belongs_to: HMR API
  description: |-
    ## `hot.dispose(cb)`

    A self-accepting module or a module that expects to be accepted by others can use `hot.dispose` to clean-up any persistent side effects created by its updated copy:

    js

    ``` javascript
    function setupSideEffect() {}

    setupSideEffect()

    if (import.meta.hot) {
      import.meta.hot.dispose((data) => {
        // cleanup side effect
      })
    }
    ```
- name: 'HMR API: hot.invalidate(message?: string)'
  id: guide/api-hmr#hot-invalidate-message-string
  summary: A self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers
  belongs_to: HMR API
  description: |-
    ## `hot.invalidate(message?: string)`

    A self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling `import.meta.hot.invalidate()`, the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.

    Note that you should always call `import.meta.hot.accept` even if you plan to call `invalidate` immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling `invalidate` within the `accept` callback like so:

    js

    ``` javascript
    import.meta.hot.accept((module) => {
      // You may use the new module instance to decide whether to invalidate.
      if (cannotHandleUpdate(module)) {
        import.meta.hot.invalidate()
      }
    })
    ```
- name: 'HMR API: hot.off(event, cb)'
  id: guide/api-hmr#hot-off-event-cb
  summary: Remove callback from the event listeners
  belongs_to: HMR API
  description: |-
    ## `hot.off(event, cb)`

    Remove callback from the event listeners.
- name: 'HMR API: hot.on(event, cb)'
  id: guide/api-hmr#hot-on-event-cb
  summary: Listen to an HMR event
  belongs_to: HMR API
  description: |-
    ## `hot.on(event, cb)`

    Listen to an HMR event.

    The following HMR events are dispatched by Vite automatically:

    - `'vite:beforeUpdate'` when an update is about to be applied (e.g. a module will be replaced)
    - `'vite:afterUpdate'` when an update has just been applied (e.g. a module has been replaced)
    - `'vite:beforeFullReload'` when a full reload is about to occur
    - `'vite:beforePrune'` when modules that are no longer needed are about to be pruned
    - `'vite:invalidate'` when a module is invalidated with `import.meta.hot.invalidate()`
    - `'vite:error'` when an error occurs (e.g. syntax error)
    - `'vite:ws:disconnect'` when the WebSocket connection is lost
    - `'vite:ws:connect'` when the WebSocket connection is (re-)established

    Custom HMR events can also be sent from plugins. See [handleHotUpdate](api-plugin#handlehotupdate) for more details.
- name: 'HMR API: hot.prune(cb)'
  id: guide/api-hmr#hot-prune-cb
  summary: Register a callback that will call when the module is no longer imported on the page
  belongs_to: HMR API
  description: |-
    ## `hot.prune(cb)`

    Register a callback that will call when the module is no longer imported on the page. Compared to `hot.dispose`, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for `.css` imports.

    js

    ``` javascript
    function setupOrReuseSideEffect() {}

    setupOrReuseSideEffect()

    if (import.meta.hot) {
      import.meta.hot.prune((data) => {
        // cleanup side effect
      })
    }
    ```
- name: 'HMR API: hot.send(event, data)'
  id: guide/api-hmr#hot-send-event-data
  summary: Send custom events back to Vite's dev server
  belongs_to: HMR API
  description: |-
    ## `hot.send(event, data)`

    Send custom events back to Vite's dev server.

    If called before connected, the data will be buffered and sent once the connection is established.

    See [Client-server Communication](api-plugin#client-server-communication) for more details, including a section on [Typing Custom Events](api-plugin#typescript-for-custom-events).
- name: 'HMR API: IntelliSense for TypeScript'
  id: guide/api-hmr#intellisense-for-typescript
  summary: Vite provides type definitions for import.meta.hot in vite/client.d.ts
  belongs_to: HMR API
  description: |-
    ## IntelliSense for TypeScript

    Vite provides type definitions for `import.meta.hot` in [`vite/client.d.ts`](https://github.com/vitejs/vite/blob/main/packages/vite/client.d.ts). You can create an `env.d.ts` in the `src` directory so TypeScript picks up the type definitions:

    ts

    ``` javascript
    /// <reference types="vite/client" />
    ```
- name: 'HMR API: Required Conditional Guard'
  id: guide/api-hmr#required-conditional-guard
  summary: null
  belongs_to: HMR API
  description: |-
    ## Required Conditional Guard

    First of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:

    js

    ``` javascript
    if (import.meta.hot) {
      // HMR code
    }
    ```
- name: JavaScript API
  id: guide/api-javascript
  summary: Vite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation
  description: "# JavaScript API\n\nVite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.\n\n## `createServer`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nconst server = await createServer({\n  // any valid user config options, plus `mode` and `configFile`\n  configFile: false,\n  root: __dirname,\n  server: {\n    port: 1337,\n  },\n})\nawait server.listen()\n\nserver.printUrls()\nserver.bindCLIShortcuts({ print: true })\n```\n\n**NOTE**\n\nWhen using `createServer` and `build` in the same Node.js process, both functions rely on `process.env.NODE_ENV` to work properly, which also depends on the `mode` config option. To prevent conflicting behavior, set `process.env.NODE_ENV` or the `mode` of the two APIs to `development`. Otherwise, you can spawn a child process to run the APIs separately.\n\n**NOTE**\n\nWhen using [middleware mode](../config/server-options#server-middlewaremode) combined with [proxy config for WebSocket](../config/server-options#server-proxy), the parent http server should be provided in `middlewareMode` to bind the proxy correctly.\n\nExample\n\nts\n\n``` javascript\nimport http from 'http'\nimport { createServer } from 'vite'\n\nconst parentServer = http.createServer() // or express, koa, etc.\n\nconst vite = await createServer({\n  server: {\n    // Enable middleware mode\n    middlewareMode: {\n      // Provide the parent http server for proxy WebSocket\n      server: parentServer,\n    },\n    proxy: {\n      '/ws': {\n        target: 'ws://localhost:3000',\n        // Proxying WebSocket\n        ws: true,\n      },\n    },\n  },\n})\n\nparentServer.use(vite.middlewares)\n```\n\n## `InlineConfig`\n\nThe `InlineConfig` interface extends `UserConfig` with additional properties:\n\n- `configFile`: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to `false` to disable auto resolving.\n- `envFile`: Set to `false` to disable `.env` files.\n\n## `ResolvedConfig`\n\nThe `ResolvedConfig` interface has all the same properties of a `UserConfig`, except most properties are resolved and non-undefined. It also contains utilities like:\n\n- `config.assetsInclude`: A function to check if an `id` is considered an asset.\n- `config.logger`: Vite's internal logger object.\n\n## `ViteDevServer`\n\nts\n\n``` javascript\ninterface ViteDevServer {\n  /**\n   * The resolved Vite config object.\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks.\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * Native Node http server instance.\n   * Will be null in middleware mode.\n   */\n  httpServer: http.Server | null\n  /**\n   * Chokidar watcher instance. If `config.server.watch` is set to `null`,\n   * returns a noop event emitter.\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * Web socket server with `send(payload)` method.\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file.\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Apply Vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise<string>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    options?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Fix ssr error stacktrace.\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n  /**\n   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports\n   * are processed. If called from a load or transform plugin hook, the id needs to be\n   * passed as a parameter to avoid deadlocks. Calling this function after the first\n   * static imports section of the module graph has been processed will resolve immediately.\n   * @experimental\n   */\n  waitForRequestsIdle: (ignoredId?: string) => Promise<void>\n}\n```\n\n**INFO**\n\n`waitForRequestsIdle` is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server. It can be used during startup by tools like Tailwind to delay generating the app CSS classes until the app code has been seen, avoiding flashes of style changes. When this function is used in a load or transform hook, and the default HTTP1 server is used, one of the six http channels will be blocked until the server processes all static imports. Vite's dependency optimizer currently uses this function to avoid full-page reloads on missing dependencies by delaying loading of pre-bundled dependencies until all imported dependencies have been collected from static imported sources. Vite may switch to a different strategy in a future major release, setting `optimizeDeps.crawlUntilStaticImports: false` by default to avoid the performance hit in large applications during cold start.\n\n## `build`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function build(\n  inlineConfig?: InlineConfig,\n): Promise<RollupOutput | RollupOutput[]>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { build } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nawait build({\n  root: path.resolve(__dirname, './project'),\n  base: '/foo/',\n  build: {\n    rollupOptions: {\n      // ...\n    },\n  },\n})\n```\n\n## `preview`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport { preview } from 'vite'\n\nconst previewServer = await preview({\n  // any valid user config options, plus `mode` and `configFile`\n  preview: {\n    port: 8080,\n    open: true,\n  },\n})\n\npreviewServer.printUrls()\npreviewServer.bindCLIShortcuts({ print: true })\n```\n\n## `PreviewServer`\n\nts\n\n``` javascript\ninterface PreviewServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the preview server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   */\n  httpServer: http.Server\n  /**\n   * The resolved urls Vite prints on the CLI.\n   * null before server is listening.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void\n}\n```\n\n## `resolveConfig`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function resolveConfig(\n  inlineConfig: InlineConfig,\n  command: 'build' | 'serve',\n  defaultMode = 'development',\n  defaultNodeEnv = 'development',\n  isPreview = false,\n): Promise<ResolvedConfig>\n```\n\nThe `command` value is `serve` in dev and preview, and `build` in build.\n\n## `mergeConfig`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction mergeConfig(\n  defaults: Record<string, any>,\n  overrides: Record<string, any>,\n  isRoot = true,\n): Record<string, any>\n```\n\nDeeply merge two Vite configs. `isRoot` represents the level within the Vite config which is being merged. For example, set `false` if you're merging two `build` options.\n\n**NOTE**\n\n`mergeConfig` accepts only config in object form. If you have a config in callback form, you should call it before passing into `mergeConfig`.\n\nYou can use the `defineConfig` helper to merge a config in callback form with another config:\n\nts\n\n``` javascript\nexport default defineConfig((configEnv) =>\n  mergeConfig(configAsCallback(configEnv), configAsObject),\n)\n```\n\n## `searchForWorkspaceRoot`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction searchForWorkspaceRoot(\n  current: string,\n  root = searchForPackageRoot(current),\n): string\n```\n\n**Related:** [server.fs.allow](../config/server-options#server-fs-allow)\n\nSearch for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to `root`:\n\n- contains `workspaces` field in `package.json`\n- contains one of the following file\n  - `lerna.json`\n  - `pnpm-workspace.yaml`\n\n## `loadEnv`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction loadEnv(\n  mode: string,\n  envDir: string,\n  prefixes: string | string[] = 'VITE_',\n): Record<string, string>\n```\n\n**Related:** [`.env` Files](env-and-mode#env-files)\n\nLoad `.env` files within the `envDir`. By default, only env variables prefixed with `VITE_` are loaded, unless `prefixes` is changed.\n\n## `normalizePath`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction normalizePath(id: string): string\n```\n\n**Related:** [Path Normalization](api-plugin#path-normalization)\n\nNormalizes a path to interoperate between Vite plugins.\n\n## `transformWithEsbuild`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function transformWithEsbuild(\n  code: string,\n  filename: string,\n  options?: EsbuildTransformOptions,\n  inMap?: object,\n): Promise<ESBuildTransformResult>\n```\n\nTransform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.\n\n## `loadConfigFromFile`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function loadConfigFromFile(\n  configEnv: ConfigEnv,\n  configFile?: string,\n  configRoot: string = process.cwd(),\n  logLevel?: LogLevel,\n  customLogger?: Logger,\n): Promise<{\n  path: string\n  config: UserConfig\n  dependencies: string[]\n} | null>\n```\n\nLoad a Vite config file manually with esbuild.\n\n## `preprocessCSS`\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13815)\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preprocessCSS(\n  code: string,\n  filename: string,\n  config: ResolvedConfig,\n): Promise<PreprocessCSSResult>\n\ninterface PreprocessCSSResult {\n  code: string\n  map?: SourceMapInput\n  modules?: Record<string, string>\n  deps?: Set<string>\n}\n```\n\nPre-processes `.css`, `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files to plain CSS so it can be used in browsers or parsed by other tools. Similar to the [built-in CSS pre-processing support](features#css-pre-processors), the corresponding pre-processor must be installed if used.\n\nThe pre-processor used is inferred from the `filename` extension. If the `filename` ends with `.module.{ext}`, it is inferred as a [CSS module](https://github.com/css-modules/css-modules) and the returned result will include a `modules` object mapping the original class names to the transformed ones.\n\nNote that pre-processing will not resolve URLs in `url()` or `image-set()`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-javascript](https://vitejs.dev/guide/api-javascript)"
- name: 'JavaScript API: APIs'
  id: guide/api-javascript
  summary: Vite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation
  description: "# JavaScript API\n\nVite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.\n\n## `createServer`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nconst server = await createServer({\n  // any valid user config options, plus `mode` and `configFile`\n  configFile: false,\n  root: __dirname,\n  server: {\n    port: 1337,\n  },\n})\nawait server.listen()\n\nserver.printUrls()\nserver.bindCLIShortcuts({ print: true })\n```\n\n**NOTE**\n\nWhen using `createServer` and `build` in the same Node.js process, both functions rely on `process.env.NODE_ENV` to work properly, which also depends on the `mode` config option. To prevent conflicting behavior, set `process.env.NODE_ENV` or the `mode` of the two APIs to `development`. Otherwise, you can spawn a child process to run the APIs separately.\n\n**NOTE**\n\nWhen using [middleware mode](../config/server-options#server-middlewaremode) combined with [proxy config for WebSocket](../config/server-options#server-proxy), the parent http server should be provided in `middlewareMode` to bind the proxy correctly.\n\nExample\n\nts\n\n``` javascript\nimport http from 'http'\nimport { createServer } from 'vite'\n\nconst parentServer = http.createServer() // or express, koa, etc.\n\nconst vite = await createServer({\n  server: {\n    // Enable middleware mode\n    middlewareMode: {\n      // Provide the parent http server for proxy WebSocket\n      server: parentServer,\n    },\n    proxy: {\n      '/ws': {\n        target: 'ws://localhost:3000',\n        // Proxying WebSocket\n        ws: true,\n      },\n    },\n  },\n})\n\nparentServer.use(vite.middlewares)\n```\n\n## `InlineConfig`\n\nThe `InlineConfig` interface extends `UserConfig` with additional properties:\n\n- `configFile`: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to `false` to disable auto resolving.\n- `envFile`: Set to `false` to disable `.env` files.\n\n## `ResolvedConfig`\n\nThe `ResolvedConfig` interface has all the same properties of a `UserConfig`, except most properties are resolved and non-undefined. It also contains utilities like:\n\n- `config.assetsInclude`: A function to check if an `id` is considered an asset.\n- `config.logger`: Vite's internal logger object.\n\n## `ViteDevServer`\n\nts\n\n``` javascript\ninterface ViteDevServer {\n  /**\n   * The resolved Vite config object.\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks.\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * Native Node http server instance.\n   * Will be null in middleware mode.\n   */\n  httpServer: http.Server | null\n  /**\n   * Chokidar watcher instance. If `config.server.watch` is set to `null`,\n   * returns a noop event emitter.\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * Web socket server with `send(payload)` method.\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file.\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Apply Vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise<string>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    options?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Fix ssr error stacktrace.\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n  /**\n   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports\n   * are processed. If called from a load or transform plugin hook, the id needs to be\n   * passed as a parameter to avoid deadlocks. Calling this function after the first\n   * static imports section of the module graph has been processed will resolve immediately.\n   * @experimental\n   */\n  waitForRequestsIdle: (ignoredId?: string) => Promise<void>\n}\n```\n\n**INFO**\n\n`waitForRequestsIdle` is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server. It can be used during startup by tools like Tailwind to delay generating the app CSS classes until the app code has been seen, avoiding flashes of style changes. When this function is used in a load or transform hook, and the default HTTP1 server is used, one of the six http channels will be blocked until the server processes all static imports. Vite's dependency optimizer currently uses this function to avoid full-page reloads on missing dependencies by delaying loading of pre-bundled dependencies until all imported dependencies have been collected from static imported sources. Vite may switch to a different strategy in a future major release, setting `optimizeDeps.crawlUntilStaticImports: false` by default to avoid the performance hit in large applications during cold start.\n\n## `build`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function build(\n  inlineConfig?: InlineConfig,\n): Promise<RollupOutput | RollupOutput[]>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { build } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nawait build({\n  root: path.resolve(__dirname, './project'),\n  base: '/foo/',\n  build: {\n    rollupOptions: {\n      // ...\n    },\n  },\n})\n```\n\n## `preview`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport { preview } from 'vite'\n\nconst previewServer = await preview({\n  // any valid user config options, plus `mode` and `configFile`\n  preview: {\n    port: 8080,\n    open: true,\n  },\n})\n\npreviewServer.printUrls()\npreviewServer.bindCLIShortcuts({ print: true })\n```\n\n## `PreviewServer`\n\nts\n\n``` javascript\ninterface PreviewServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the preview server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   */\n  httpServer: http.Server\n  /**\n   * The resolved urls Vite prints on the CLI.\n   * null before server is listening.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void\n}\n```\n\n## `resolveConfig`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function resolveConfig(\n  inlineConfig: InlineConfig,\n  command: 'build' | 'serve',\n  defaultMode = 'development',\n  defaultNodeEnv = 'development',\n  isPreview = false,\n): Promise<ResolvedConfig>\n```\n\nThe `command` value is `serve` in dev and preview, and `build` in build.\n\n## `mergeConfig`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction mergeConfig(\n  defaults: Record<string, any>,\n  overrides: Record<string, any>,\n  isRoot = true,\n): Record<string, any>\n```\n\nDeeply merge two Vite configs. `isRoot` represents the level within the Vite config which is being merged. For example, set `false` if you're merging two `build` options.\n\n**NOTE**\n\n`mergeConfig` accepts only config in object form. If you have a config in callback form, you should call it before passing into `mergeConfig`.\n\nYou can use the `defineConfig` helper to merge a config in callback form with another config:\n\nts\n\n``` javascript\nexport default defineConfig((configEnv) =>\n  mergeConfig(configAsCallback(configEnv), configAsObject),\n)\n```\n\n## `searchForWorkspaceRoot`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction searchForWorkspaceRoot(\n  current: string,\n  root = searchForPackageRoot(current),\n): string\n```\n\n**Related:** [server.fs.allow](../config/server-options#server-fs-allow)\n\nSearch for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to `root`:\n\n- contains `workspaces` field in `package.json`\n- contains one of the following file\n  - `lerna.json`\n  - `pnpm-workspace.yaml`\n\n## `loadEnv`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction loadEnv(\n  mode: string,\n  envDir: string,\n  prefixes: string | string[] = 'VITE_',\n): Record<string, string>\n```\n\n**Related:** [`.env` Files](env-and-mode#env-files)\n\nLoad `.env` files within the `envDir`. By default, only env variables prefixed with `VITE_` are loaded, unless `prefixes` is changed.\n\n## `normalizePath`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction normalizePath(id: string): string\n```\n\n**Related:** [Path Normalization](api-plugin#path-normalization)\n\nNormalizes a path to interoperate between Vite plugins.\n\n## `transformWithEsbuild`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function transformWithEsbuild(\n  code: string,\n  filename: string,\n  options?: EsbuildTransformOptions,\n  inMap?: object,\n): Promise<ESBuildTransformResult>\n```\n\nTransform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.\n\n## `loadConfigFromFile`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function loadConfigFromFile(\n  configEnv: ConfigEnv,\n  configFile?: string,\n  configRoot: string = process.cwd(),\n  logLevel?: LogLevel,\n  customLogger?: Logger,\n): Promise<{\n  path: string\n  config: UserConfig\n  dependencies: string[]\n} | null>\n```\n\nLoad a Vite config file manually with esbuild.\n\n## `preprocessCSS`\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13815)\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preprocessCSS(\n  code: string,\n  filename: string,\n  config: ResolvedConfig,\n): Promise<PreprocessCSSResult>\n\ninterface PreprocessCSSResult {\n  code: string\n  map?: SourceMapInput\n  modules?: Record<string, string>\n  deps?: Set<string>\n}\n```\n\nPre-processes `.css`, `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files to plain CSS so it can be used in browsers or parsed by other tools. Similar to the [built-in CSS pre-processing support](features#css-pre-processors), the corresponding pre-processor must be installed if used.\n\nThe pre-processor used is inferred from the `filename` extension. If the `filename` ends with `.module.{ext}`, it is inferred as a [CSS module](https://github.com/css-modules/css-modules) and the returned result will include a `modules` object mapping the original class names to the transformed ones.\n\nNote that pre-processing will not resolve URLs in `url()` or `image-set()`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-javascript](https://vitejs.dev/guide/api-javascript)"
- name: 'JavaScript API: build'
  id: guide/api-javascript#build
  summary: null
  belongs_to: JavaScript API
  description: |-
    ## `build`

    **Type Signature:**

    ts

    ``` javascript
    async function build(
      inlineConfig?: InlineConfig,
    ): Promise<RollupOutput | RollupOutput[]>
    ```

    **Example Usage:**

    ts

    ``` javascript
    import path from 'node:path'
    import { fileURLToPath } from 'node:url'
    import { build } from 'vite'

    const __dirname = fileURLToPath(new URL('.', import.meta.url))

    await build({
      root: path.resolve(__dirname, './project'),
      base: '/foo/',
      build: {
        rollupOptions: {
          // ...
        },
      },
    })
    ```
- name: 'JavaScript API: createServer'
  id: guide/api-javascript#createserver
  summary: When using createServer and build in the same Node.js process, both functions rely on process.env.NODE_ENV to work properly, which also depends on the mode config option
  belongs_to: JavaScript API
  description: |-
    ## `createServer`

    **Type Signature:**

    ts

    ``` javascript
    async function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>
    ```

    **Example Usage:**

    ts

    ``` javascript
    import { fileURLToPath } from 'node:url'
    import { createServer } from 'vite'

    const __dirname = fileURLToPath(new URL('.', import.meta.url))

    const server = await createServer({
      // any valid user config options, plus `mode` and `configFile`
      configFile: false,
      root: __dirname,
      server: {
        port: 1337,
      },
    })
    await server.listen()

    server.printUrls()
    server.bindCLIShortcuts({ print: true })
    ```

    **NOTE**

    When using `createServer` and `build` in the same Node.js process, both functions rely on `process.env.NODE_ENV` to work properly, which also depends on the `mode` config option. To prevent conflicting behavior, set `process.env.NODE_ENV` or the `mode` of the two APIs to `development`. Otherwise, you can spawn a child process to run the APIs separately.

    **NOTE**

    When using [middleware mode](../config/server-options#server-middlewaremode) combined with [proxy config for WebSocket](../config/server-options#server-proxy), the parent http server should be provided in `middlewareMode` to bind the proxy correctly.

    Example

    ts

    ``` javascript
    import http from 'http'
    import { createServer } from 'vite'

    const parentServer = http.createServer() // or express, koa, etc.

    const vite = await createServer({
      server: {
        // Enable middleware mode
        middlewareMode: {
          // Provide the parent http server for proxy WebSocket
          server: parentServer,
        },
        proxy: {
          '/ws': {
            target: 'ws://localhost:3000',
            // Proxying WebSocket
            ws: true,
          },
        },
      },
    })

    parentServer.use(vite.middlewares)
    ```
- name: 'JavaScript API: Guide'
  id: guide/api-javascript
  summary: Vite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation
  description: "# JavaScript API\n\nVite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.\n\n## `createServer`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport { fileURLToPath } from 'node:url'\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nconst server = await createServer({\n  // any valid user config options, plus `mode` and `configFile`\n  configFile: false,\n  root: __dirname,\n  server: {\n    port: 1337,\n  },\n})\nawait server.listen()\n\nserver.printUrls()\nserver.bindCLIShortcuts({ print: true })\n```\n\n**NOTE**\n\nWhen using `createServer` and `build` in the same Node.js process, both functions rely on `process.env.NODE_ENV` to work properly, which also depends on the `mode` config option. To prevent conflicting behavior, set `process.env.NODE_ENV` or the `mode` of the two APIs to `development`. Otherwise, you can spawn a child process to run the APIs separately.\n\n**NOTE**\n\nWhen using [middleware mode](../config/server-options#server-middlewaremode) combined with [proxy config for WebSocket](../config/server-options#server-proxy), the parent http server should be provided in `middlewareMode` to bind the proxy correctly.\n\nExample\n\nts\n\n``` javascript\nimport http from 'http'\nimport { createServer } from 'vite'\n\nconst parentServer = http.createServer() // or express, koa, etc.\n\nconst vite = await createServer({\n  server: {\n    // Enable middleware mode\n    middlewareMode: {\n      // Provide the parent http server for proxy WebSocket\n      server: parentServer,\n    },\n    proxy: {\n      '/ws': {\n        target: 'ws://localhost:3000',\n        // Proxying WebSocket\n        ws: true,\n      },\n    },\n  },\n})\n\nparentServer.use(vite.middlewares)\n```\n\n## `InlineConfig`\n\nThe `InlineConfig` interface extends `UserConfig` with additional properties:\n\n- `configFile`: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to `false` to disable auto resolving.\n- `envFile`: Set to `false` to disable `.env` files.\n\n## `ResolvedConfig`\n\nThe `ResolvedConfig` interface has all the same properties of a `UserConfig`, except most properties are resolved and non-undefined. It also contains utilities like:\n\n- `config.assetsInclude`: A function to check if an `id` is considered an asset.\n- `config.logger`: Vite's internal logger object.\n\n## `ViteDevServer`\n\nts\n\n``` javascript\ninterface ViteDevServer {\n  /**\n   * The resolved Vite config object.\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks.\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * Native Node http server instance.\n   * Will be null in middleware mode.\n   */\n  httpServer: http.Server | null\n  /**\n   * Chokidar watcher instance. If `config.server.watch` is set to `null`,\n   * returns a noop event emitter.\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * Web socket server with `send(payload)` method.\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file.\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Apply Vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(\n    url: string,\n    html: string,\n    originalUrl?: string,\n  ): Promise<string>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    options?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Fix ssr error stacktrace.\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n  /**\n   * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports\n   * are processed. If called from a load or transform plugin hook, the id needs to be\n   * passed as a parameter to avoid deadlocks. Calling this function after the first\n   * static imports section of the module graph has been processed will resolve immediately.\n   * @experimental\n   */\n  waitForRequestsIdle: (ignoredId?: string) => Promise<void>\n}\n```\n\n**INFO**\n\n`waitForRequestsIdle` is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server. It can be used during startup by tools like Tailwind to delay generating the app CSS classes until the app code has been seen, avoiding flashes of style changes. When this function is used in a load or transform hook, and the default HTTP1 server is used, one of the six http channels will be blocked until the server processes all static imports. Vite's dependency optimizer currently uses this function to avoid full-page reloads on missing dependencies by delaying loading of pre-bundled dependencies until all imported dependencies have been collected from static imported sources. Vite may switch to a different strategy in a future major release, setting `optimizeDeps.crawlUntilStaticImports: false` by default to avoid the performance hit in large applications during cold start.\n\n## `build`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function build(\n  inlineConfig?: InlineConfig,\n): Promise<RollupOutput | RollupOutput[]>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport { build } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\nawait build({\n  root: path.resolve(__dirname, './project'),\n  base: '/foo/',\n  build: {\n    rollupOptions: {\n      // ...\n    },\n  },\n})\n```\n\n## `preview`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>\n```\n\n**Example Usage:**\n\nts\n\n``` javascript\nimport { preview } from 'vite'\n\nconst previewServer = await preview({\n  // any valid user config options, plus `mode` and `configFile`\n  preview: {\n    port: 8080,\n    open: true,\n  },\n})\n\npreviewServer.printUrls()\npreviewServer.bindCLIShortcuts({ print: true })\n```\n\n## `PreviewServer`\n\nts\n\n``` javascript\ninterface PreviewServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the preview server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   */\n  httpServer: http.Server\n  /**\n   * The resolved urls Vite prints on the CLI.\n   * null before server is listening.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void\n}\n```\n\n## `resolveConfig`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function resolveConfig(\n  inlineConfig: InlineConfig,\n  command: 'build' | 'serve',\n  defaultMode = 'development',\n  defaultNodeEnv = 'development',\n  isPreview = false,\n): Promise<ResolvedConfig>\n```\n\nThe `command` value is `serve` in dev and preview, and `build` in build.\n\n## `mergeConfig`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction mergeConfig(\n  defaults: Record<string, any>,\n  overrides: Record<string, any>,\n  isRoot = true,\n): Record<string, any>\n```\n\nDeeply merge two Vite configs. `isRoot` represents the level within the Vite config which is being merged. For example, set `false` if you're merging two `build` options.\n\n**NOTE**\n\n`mergeConfig` accepts only config in object form. If you have a config in callback form, you should call it before passing into `mergeConfig`.\n\nYou can use the `defineConfig` helper to merge a config in callback form with another config:\n\nts\n\n``` javascript\nexport default defineConfig((configEnv) =>\n  mergeConfig(configAsCallback(configEnv), configAsObject),\n)\n```\n\n## `searchForWorkspaceRoot`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction searchForWorkspaceRoot(\n  current: string,\n  root = searchForPackageRoot(current),\n): string\n```\n\n**Related:** [server.fs.allow](../config/server-options#server-fs-allow)\n\nSearch for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to `root`:\n\n- contains `workspaces` field in `package.json`\n- contains one of the following file\n  - `lerna.json`\n  - `pnpm-workspace.yaml`\n\n## `loadEnv`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction loadEnv(\n  mode: string,\n  envDir: string,\n  prefixes: string | string[] = 'VITE_',\n): Record<string, string>\n```\n\n**Related:** [`.env` Files](env-and-mode#env-files)\n\nLoad `.env` files within the `envDir`. By default, only env variables prefixed with `VITE_` are loaded, unless `prefixes` is changed.\n\n## `normalizePath`\n\n**Type Signature:**\n\nts\n\n``` javascript\nfunction normalizePath(id: string): string\n```\n\n**Related:** [Path Normalization](api-plugin#path-normalization)\n\nNormalizes a path to interoperate between Vite plugins.\n\n## `transformWithEsbuild`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function transformWithEsbuild(\n  code: string,\n  filename: string,\n  options?: EsbuildTransformOptions,\n  inMap?: object,\n): Promise<ESBuildTransformResult>\n```\n\nTransform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.\n\n## `loadConfigFromFile`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function loadConfigFromFile(\n  configEnv: ConfigEnv,\n  configFile?: string,\n  configRoot: string = process.cwd(),\n  logLevel?: LogLevel,\n  customLogger?: Logger,\n): Promise<{\n  path: string\n  config: UserConfig\n  dependencies: string[]\n} | null>\n```\n\nLoad a Vite config file manually with esbuild.\n\n## `preprocessCSS`\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13815)\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preprocessCSS(\n  code: string,\n  filename: string,\n  config: ResolvedConfig,\n): Promise<PreprocessCSSResult>\n\ninterface PreprocessCSSResult {\n  code: string\n  map?: SourceMapInput\n  modules?: Record<string, string>\n  deps?: Set<string>\n}\n```\n\nPre-processes `.css`, `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files to plain CSS so it can be used in browsers or parsed by other tools. Similar to the [built-in CSS pre-processing support](features#css-pre-processors), the corresponding pre-processor must be installed if used.\n\nThe pre-processor used is inferred from the `filename` extension. If the `filename` ends with `.module.{ext}`, it is inferred as a [CSS module](https://github.com/css-modules/css-modules) and the returned result will include a `modules` object mapping the original class names to the transformed ones.\n\nNote that pre-processing will not resolve URLs in `url()` or `image-set()`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-javascript](https://vitejs.dev/guide/api-javascript)"
- name: 'JavaScript API: InlineConfig'
  id: guide/api-javascript#inlineconfig
  summary: null
  belongs_to: JavaScript API
  description: |-
    ## `InlineConfig`

    The `InlineConfig` interface extends `UserConfig` with additional properties:

    - `configFile`: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to `false` to disable auto resolving.
    - `envFile`: Set to `false` to disable `.env` files.
- name: 'JavaScript API: loadConfigFromFile'
  id: guide/api-javascript#loadconfigfromfile
  summary: Load a Vite config file manually with esbuild
  belongs_to: JavaScript API
  description: |-
    ## `loadConfigFromFile`

    **Type Signature:**

    ts

    ``` javascript
    async function loadConfigFromFile(
      configEnv: ConfigEnv,
      configFile?: string,
      configRoot: string = process.cwd(),
      logLevel?: LogLevel,
      customLogger?: Logger,
    ): Promise<{
      path: string
      config: UserConfig
      dependencies: string[]
    } | null>
    ```

    Load a Vite config file manually with esbuild.
- name: 'JavaScript API: loadEnv'
  id: guide/api-javascript#loadenv
  summary: Load .env files within the envDir
  belongs_to: JavaScript API
  description: |-
    ## `loadEnv`

    **Type Signature:**

    ts

    ``` javascript
    function loadEnv(
      mode: string,
      envDir: string,
      prefixes: string | string[] = 'VITE_',
    ): Record<string, string>
    ```

    **Related:** [`.env` Files](env-and-mode#env-files)

    Load `.env` files within the `envDir`. By default, only env variables prefixed with `VITE_` are loaded, unless `prefixes` is changed.
- name: 'JavaScript API: mergeConfig'
  id: guide/api-javascript#mergeconfig
  summary: Deeply merge two Vite configs
  belongs_to: JavaScript API
  description: |-
    ## `mergeConfig`

    **Type Signature:**

    ts

    ``` javascript
    function mergeConfig(
      defaults: Record<string, any>,
      overrides: Record<string, any>,
      isRoot = true,
    ): Record<string, any>
    ```

    Deeply merge two Vite configs. `isRoot` represents the level within the Vite config which is being merged. For example, set `false` if you're merging two `build` options.

    **NOTE**

    `mergeConfig` accepts only config in object form. If you have a config in callback form, you should call it before passing into `mergeConfig`.

    You can use the `defineConfig` helper to merge a config in callback form with another config:

    ts

    ``` javascript
    export default defineConfig((configEnv) =>
      mergeConfig(configAsCallback(configEnv), configAsObject),
    )
    ```
- name: 'JavaScript API: normalizePath'
  id: guide/api-javascript#normalizepath
  summary: Normalizes a path to interoperate between Vite plugins
  belongs_to: JavaScript API
  description: |-
    ## `normalizePath`

    **Type Signature:**

    ts

    ``` javascript
    function normalizePath(id: string): string
    ```

    **Related:** [Path Normalization](api-plugin#path-normalization)

    Normalizes a path to interoperate between Vite plugins.
- name: 'JavaScript API: preprocessCSS'
  id: guide/api-javascript#preprocesscss
  summary: Pre-processes .css, .scss, .sass, .less, .styl and .stylus files to plain CSS so it can be used in browsers or parsed by other tools
  belongs_to: JavaScript API
  description: "## `preprocessCSS`\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13815)\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function preprocessCSS(\n  code: string,\n  filename: string,\n  config: ResolvedConfig,\n): Promise<PreprocessCSSResult>\n\ninterface PreprocessCSSResult {\n  code: string\n  map?: SourceMapInput\n  modules?: Record<string, string>\n  deps?: Set<string>\n}\n```\n\nPre-processes `.css`, `.scss`, `.sass`, `.less`, `.styl` and `.stylus` files to plain CSS so it can be used in browsers or parsed by other tools. Similar to the [built-in CSS pre-processing support](features#css-pre-processors), the corresponding pre-processor must be installed if used.\n\nThe pre-processor used is inferred from the `filename` extension. If the `filename` ends with `.module.{ext}`, it is inferred as a [CSS module](https://github.com/css-modules/css-modules) and the returned result will include a `modules` object mapping the original class names to the transformed ones.\n\nNote that pre-processing will not resolve URLs in `url()` or `image-set()`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-javascript](https://vitejs.dev/guide/api-javascript)"
- name: 'JavaScript API: preview'
  id: guide/api-javascript#preview
  summary: null
  belongs_to: JavaScript API
  description: |-
    ## `preview`

    **Type Signature:**

    ts

    ``` javascript
    async function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>
    ```

    **Example Usage:**

    ts

    ``` javascript
    import { preview } from 'vite'

    const previewServer = await preview({
      // any valid user config options, plus `mode` and `configFile`
      preview: {
        port: 8080,
        open: true,
      },
    })

    previewServer.printUrls()
    previewServer.bindCLIShortcuts({ print: true })
    ```
- name: 'JavaScript API: PreviewServer'
  id: guide/api-javascript#previewserver
  summary: null
  belongs_to: JavaScript API
  description: |-
    ## `PreviewServer`

    ts

    ``` javascript
    interface PreviewServer {
      /**
       * The resolved vite config object
       */
      config: ResolvedConfig
      /**
       * A connect app instance.
       * - Can be used to attach custom middlewares to the preview server.
       * - Can also be used as the handler function of a custom http server
       *   or as a middleware in any connect-style Node.js frameworks
       *
       * https://github.com/senchalabs/connect#use-middleware
       */
      middlewares: Connect.Server
      /**
       * native Node http server instance
       */
      httpServer: http.Server
      /**
       * The resolved urls Vite prints on the CLI.
       * null before server is listening.
       */
      resolvedUrls: ResolvedServerUrls | null
      /**
       * Print server urls
       */
      printUrls(): void
      /**
       * Bind CLI shortcuts
       */
      bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void
    }
    ```
- name: 'JavaScript API: resolveConfig'
  id: guide/api-javascript#resolveconfig
  summary: The command value is serve in dev and preview, and build in build
  belongs_to: JavaScript API
  description: |-
    ## `resolveConfig`

    **Type Signature:**

    ts

    ``` javascript
    async function resolveConfig(
      inlineConfig: InlineConfig,
      command: 'build' | 'serve',
      defaultMode = 'development',
      defaultNodeEnv = 'development',
      isPreview = false,
    ): Promise<ResolvedConfig>
    ```

    The `command` value is `serve` in dev and preview, and `build` in build.
- name: 'JavaScript API: ResolvedConfig'
  id: guide/api-javascript#resolvedconfig
  summary: The ResolvedConfig interface has all the same properties of a UserConfig, except most properties are resolved and non-undefined
  belongs_to: JavaScript API
  description: |-
    ## `ResolvedConfig`

    The `ResolvedConfig` interface has all the same properties of a `UserConfig`, except most properties are resolved and non-undefined. It also contains utilities like:

    - `config.assetsInclude`: A function to check if an `id` is considered an asset.
    - `config.logger`: Vite's internal logger object.

    &nbsp;
- name: 'JavaScript API: searchForWorkspaceRoot'
  id: guide/api-javascript#searchforworkspaceroot
  summary: null
  belongs_to: JavaScript API
  description: |-
    ## `searchForWorkspaceRoot`

    **Type Signature:**

    ts

    ``` javascript
    function searchForWorkspaceRoot(
      current: string,
      root = searchForPackageRoot(current),
    ): string
    ```

    **Related:** [server.fs.allow](../config/server-options#server-fs-allow)

    Search for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to `root`:

    - contains `workspaces` field in `package.json`
    - contains one of the following file
      - `lerna.json`
      - `pnpm-workspace.yaml`

    &nbsp;
- name: 'JavaScript API: transformWithEsbuild'
  id: guide/api-javascript#transformwithesbuild
  summary: Transform JavaScript or TypeScript with esbuild
  belongs_to: JavaScript API
  description: |-
    ## `transformWithEsbuild`

    **Type Signature:**

    ts

    ``` javascript
    async function transformWithEsbuild(
      code: string,
      filename: string,
      options?: EsbuildTransformOptions,
      inMap?: object,
    ): Promise<ESBuildTransformResult>
    ```

    Transform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.
- name: 'JavaScript API: ViteDevServer'
  id: guide/api-javascript#vitedevserver
  summary: waitForRequestsIdle is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server
  belongs_to: JavaScript API
  description: |-
    ## `ViteDevServer`

    ts

    ``` javascript
    interface ViteDevServer {
      /**
       * The resolved Vite config object.
       */
      config: ResolvedConfig
      /**
       * A connect app instance
       * - Can be used to attach custom middlewares to the dev server.
       * - Can also be used as the handler function of a custom http server
       *   or as a middleware in any connect-style Node.js frameworks.
       *
       * https://github.com/senchalabs/connect#use-middleware
       */
      middlewares: Connect.Server
      /**
       * Native Node http server instance.
       * Will be null in middleware mode.
       */
      httpServer: http.Server | null
      /**
       * Chokidar watcher instance. If `config.server.watch` is set to `null`,
       * returns a noop event emitter.
       * https://github.com/paulmillr/chokidar#api
       */
      watcher: FSWatcher
      /**
       * Web socket server with `send(payload)` method.
       */
      ws: WebSocketServer
      /**
       * Rollup plugin container that can run plugin hooks on a given file.
       */
      pluginContainer: PluginContainer
      /**
       * Module graph that tracks the import relationships, url to file mapping
       * and hmr state.
       */
      moduleGraph: ModuleGraph
      /**
       * The resolved urls Vite prints on the CLI. null in middleware mode or
       * before `server.listen` is called.
       */
      resolvedUrls: ResolvedServerUrls | null
      /**
       * Programmatically resolve, load and transform a URL and get the result
       * without going through the http request pipeline.
       */
      transformRequest(
        url: string,
        options?: TransformOptions,
      ): Promise<TransformResult | null>
      /**
       * Apply Vite built-in HTML transforms and any plugin HTML transforms.
       */
      transformIndexHtml(
        url: string,
        html: string,
        originalUrl?: string,
      ): Promise<string>
      /**
       * Load a given URL as an instantiated module for SSR.
       */
      ssrLoadModule(
        url: string,
        options?: { fixStacktrace?: boolean },
      ): Promise<Record<string, any>>
      /**
       * Fix ssr error stacktrace.
       */
      ssrFixStacktrace(e: Error): void
      /**
       * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`
       * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.
       */
      reloadModule(module: ModuleNode): Promise<void>
      /**
       * Start the server.
       */
      listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>
      /**
       * Restart the server.
       *
       * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag
       */
      restart(forceOptimize?: boolean): Promise<void>
      /**
       * Stop the server.
       */
      close(): Promise<void>
      /**
       * Bind CLI shortcuts
       */
      bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void
      /**
       * Calling `await server.waitForRequestsIdle(id)` will wait until all static imports
       * are processed. If called from a load or transform plugin hook, the id needs to be
       * passed as a parameter to avoid deadlocks. Calling this function after the first
       * static imports section of the module graph has been processed will resolve immediately.
       * @experimental
       */
      waitForRequestsIdle: (ignoredId?: string) => Promise<void>
    }
    ```

    **INFO**

    `waitForRequestsIdle` is meant to be used as a escape hatch to improve DX for features that can't be implemented following the on-demand nature of the Vite dev server. It can be used during startup by tools like Tailwind to delay generating the app CSS classes until the app code has been seen, avoiding flashes of style changes. When this function is used in a load or transform hook, and the default HTTP1 server is used, one of the six http channels will be blocked until the server processes all static imports. Vite's dependency optimizer currently uses this function to avoid full-page reloads on missing dependencies by delaying loading of pre-bundled dependencies until all imported dependencies have been collected from static imported sources. Vite may switch to a different strategy in a future major release, setting `optimizeDeps.crawlUntilStaticImports: false` by default to avoid the performance hit in large applications during cold start.
- name: Migration from v4
  id: guide/migration
  summary: Vite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL
  description: "# Migration from v4\n\n## Node.js Support\n\nVite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL. Node.js 18 / 20+ is now required.\n\n## Rollup 4\n\nVite is now using Rollup 4 which also brings along its breaking changes, in particular:\n\n- Import assertions (`assertions` prop) has been renamed to import attributes (`attributes` prop).\n- Acorn plugins are no longer supported.\n- For Vite plugins, `this.resolve` `skipSelf` option is now `true` by default.\n- For Vite plugins, `this.parse` now only supports the `allowReturnOutsideFunction` option for now.\n\nRead the full breaking changes in [Rollup's release notes](https://github.com/rollup/rollup/releases/tag/v4.0.0) for build-related changes in [`build.rollupOptions`](../config/build-options#build-rollupoptions).\n\nIf you are using TypeScript, make sure to set `moduleResolution: 'bundler'` (or `node16`/`nodenext`) as Rollup 4 requires it. Or you can set `skipLibCheck: true` instead.\n\n## Deprecate CJS Node API\n\nThe CJS Node API of Vite is deprecated. When calling `require('vite')`, a deprecation warning is now logged. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\n1.  The `vite.config.js` file content is using the ESM syntax.\n2.  The closest `package.json` file has `\"type\": \"module\"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.\n\nFor other projects, there are a few general approaches:\n\n- **Configure ESM as default, opt-in to CJS if needed:** Add `\"type\": \"module\"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.\n- **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `\"type\": \"module\"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.\n- **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.\n\nSee the [troubleshooting guide](troubleshooting#vite-cjs-node-api-deprecated) for more information.\n\n## Rework `define` and `import.meta.env.*` replacement strategy\n\nIn Vite 4, the [`define`](../config/shared-options#define) and [`import.meta.env.*`](env-and-mode#env-variables) features use different replacement strategies in dev and build:\n\n- In dev, both features are injected as global variables to `globalThis` and `import.meta` respectively.\n- In build, both features are statically replaced with a regex.\n\nThis results in a dev and build inconsistency when trying to access the variables, and sometimes even caused failed builds. For example:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('1.0.0'),\n  },\n})\n```\n\njs\n\n``` javascript\nconst data = { __APP_VERSION__ }\n// dev: { __APP_VERSION__: \"1.0.0\" } ✅\n// build: { \"1.0.0\" } ❌\n\nconst docs = 'I like import.meta.env.MODE'\n// dev: \"I like import.meta.env.MODE\" ✅\n// build: \"I like \"production\"\" ❌\n```\n\nVite 5 fixes this by using `esbuild` to handle the replacements in builds, aligning with the dev behaviour.\n\nThis change should not affect most setups, as it's already documented that `define` values should follow esbuild's syntax:\n\n> To be consistent with esbuild behavior, expressions must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier.\n\nHowever, if you prefer to keep statically replacing values directly, you can use [`@rollup/plugin-replace`](https://github.com/rollup/plugins/tree/master/packages/replace).\n\n## General Changes\n\n### SSR externalized modules value now matches production\n\nIn Vite 4, SSR externalized modules are wrapped with `.default` and `.__esModule` handling for better interoperability, but it doesn't match the production behaviour when loaded by the runtime environment (e.g. Node.js), causing hard-to-catch inconsistencies. By default, all direct project dependencies are SSR externalized.\n\nVite 5 now removes the `.default` and `.__esModule` handling to match the production behaviour. In practice, this shouldn't affect properly-packaged dependencies, but if you encounter new issues loading modules, you can try these refactors:\n\njs\n\n``` javascript\n// Before:\nimport { foo } from 'bar'\n\n// After:\nimport _bar from 'bar'\nconst { foo } = _bar\n```\n\njs\n\n``` javascript\n// Before:\nimport foo from 'bar'\n\n// After:\nimport * as _foo from 'bar'\nconst foo = _foo.default\n```\n\nNote that these changes matches the Node.js behaviour, so you can also run the imports in Node.js to test it out. If you prefer to stick with the previous behaviour, you can set `legacy.proxySsrExternalModules` to `true`.\n\n### `worker.plugins` is now a function\n\nIn Vite 4, [`worker.plugins`](../config/worker-options#worker-plugins) accepted an array of plugins (`(Plugin | Plugin[])[]`). From Vite 5, it needs to be configured as a function that returns an array of plugins (`() => (Plugin | Plugin[])[]`). This change is required so parallel worker builds run more consistently and predictably.\n\n### Allow path containing `.` to fallback to index.html\n\nIn Vite 4, accessing a path in dev containing `.` did not fallback to index.html even if [`appType`](../config/shared-options#apptype) is set to `'spa'` (default). From Vite 5, it will fallback to index.html.\n\nNote that the browser will no longer show a 404 error message in the console if you point the image path to a non-existent file (e.g. `<img src=\"./file-does-not-exist.png\">`).\n\n### Align dev and preview HTML serving behaviour\n\nIn Vite 4, the dev and preview servers serve HTML based on its directory structure and trailing slash differently. This causes inconsistencies when testing your built app. Vite 5 refactors into a single behaviour like below, given the following file structure:\n\n``` javascript\n├── index.html\n├── file.html\n└── dir\n    └── index.html\n```\n\n| Request           | Before (dev)                 | Before (preview)  | After (dev & preview)        |\n|-------------------|------------------------------|-------------------|------------------------------|\n| `/dir/index.html` | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |\n| `/dir`            | `/index.html` (SPA fallback) | `/dir/index.html` | `/index.html` (SPA fallback) |\n| `/dir/`           | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |\n| `/file.html`      | `/file.html`                 | `/file.html`      | `/file.html`                 |\n| `/file`           | `/index.html` (SPA fallback) | `/file.html`      | `/file.html`                 |\n| `/file/`          | `/index.html` (SPA fallback) | `/file.html`      | `/index.html` (SPA fallback) |\n\n### Manifest files are now generated in `.vite` directory by default\n\nIn Vite 4, the manifest files ([`build.manifest`](../config/build-options#build-manifest) and [`build.ssrManifest`](../config/build-options#build-ssrmanifest)) were generated in the root of [`build.outDir`](../config/build-options#build-outdir) by default.\n\nFrom Vite 5, they will be generated in the `.vite` directory in the `build.outDir` by default. This change helps deconflict public files with the same manifest file names when they are copied to the `build.outDir`.\n\n### Corresponding CSS files are not listed as top level entry in manifest.json file\n\nIn Vite 4, the corresponding CSS file for a JavaScript entry point was also listed as a top-level entry in the manifest file ([`build.manifest`](../config/build-options#build-manifest)). These entries were unintentionally added and only worked for simple cases.\n\nIn Vite 5, corresponding CSS files can only be found within the JavaScript entry file section. When injecting the JS file, the corresponding CSS files [should be injected](#). When the CSS should be injected separately, it must be added as a separate entry point.\n\n### CLI shortcuts require an additional `Enter` press\n\nCLI shortcuts, like `r` to restart the dev server, now require an additional `Enter` press to trigger the shortcut. For example, `r + Enter` to restart the dev server.\n\nThis change prevents Vite from swallowing and controlling OS-specific shortcuts, allowing better compatibility when combining the Vite dev server with other processes, and avoids the [previous caveats](https://github.com/vitejs/vite/pull/14342).\n\n### Update `experimentalDecorators` and `useDefineForClassFields` TypeScript behaviour\n\nVite 5 uses esbuild 0.19 and removes the compatibility layer for esbuild 0.18, which changes how [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) and [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) are handled.\n\n- **`experimentalDecorators` is not enabled by default**\n\n  You need to set `compilerOptions.experimentalDecorators` to `true` in `tsconfig.json` to use decorators.\n\n- **`useDefineForClassFields` defaults depend on the TypeScript `target` value**\n\n  If `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.\n\n  As such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.\n\njsonc\n\n``` javascript\n{\n  \"compilerOptions\": {\n    // Set true if you use decorators\n    \"experimentalDecorators\": true,\n    // Set true if you see parsing errors in your browser\n    \"useDefineForClassFields\": true,\n  },\n}\n```\n\n### Remove `--https` flag and `https: true`\n\nThe `--https` flag sets `server.https: true` and `preview.https: true` internally. This config was meant to be used together with the automatic https certification generation feature which [was dropped in Vite 3](https://v3.vitejs.dev/guide/migration#automatic-https-certificate-generation). Hence, this config is no longer useful as it will start a Vite HTTPS server without a certificate.\n\nIf you use [`@vitejs/plugin-basic-ssl`](https://github.com/vitejs/vite-plugin-basic-ssl) or [`vite-plugin-mkcert`](https://github.com/liuweiGL/vite-plugin-mkcert), they will already set the `https` config internally, so you can remove `--https`, `server.https: true`, and `preview.https: true` in your setup.\n\n### Remove `resolvePackageEntry` and `resolvePackageData` APIs\n\nThe `resolvePackageEntry` and `resolvePackageData` APIs are removed as they exposed Vite's internals and blocked potential Vite 4.3 optimizations in the past. These APIs can be replaced with third-party packages, for example:\n\n- `resolvePackageEntry`: [`import.meta.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve) or the [`import-meta-resolve`](https://github.com/wooorm/import-meta-resolve) package.\n- `resolvePackageData`: Same as above, and crawl up the package directory to get the root `package.json`. Or use the community [`vitefu`](https://github.com/svitejs/vitefu) package.\n\njs\n\n``` javascript\nimport { resolve } from 'import-meta-env'\nimport { findDepPkgJsonPath } from 'vitefu'\nimport fs from 'node:fs'\n\nconst pkg = 'my-lib'\nconst basedir = process.cwd()\n\n// `resolvePackageEntry`:\nconst packageEntry = resolve(pkg, basedir)\n\n// `resolvePackageData`:\nconst packageJsonPath = findDepPkgJsonPath(pkg, basedir)\nconst packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))\n```\n\n## Removed Deprecated APIs\n\n- Default exports of CSS files (e.g `import style from './foo.css'`): Use the `?inline` query instead\n- `import.meta.globEager`: Use `import.meta.glob('*', { eager: true })` instead\n- `ssr.format: 'cjs'` and `legacy.buildSsrCjsExternalHeuristics` ([\\#13816](https://github.com/vitejs/vite/discussions/13816))\n- `server.middlewareMode: 'ssr'` and `server.middlewareMode: 'html'`: Use [`appType`](../config/shared-options#apptype) + [`server.middlewareMode: true`](../config/server-options#server-middlewaremode) instead ([\\#8452](https://github.com/vitejs/vite/pull/8452))\n\n## Advanced\n\nThere are some changes which only affect plugin/tool creators.\n\n- [\\[#14119\\] refactor!: merge `PreviewServerForHook` into `PreviewServer` type](https://github.com/vitejs/vite/pull/14119)\n  - The `configurePreviewServer` hook now accepts the `PreviewServer` type instead of `PreviewServerForHook` type.\n- [\\[#14818\\] refactor(preview)!: use base middleware](https://github.com/vitejs/vite/pull/14818)\n  - Middlewares added from the returned function in `configurePreviewServer` now does not have access to the `base` when comparing the `req.url` value. This aligns the behaviour with the dev server. You can check the `base` from the `configResolved` hook if needed.\n- [\\[#14834\\] fix(types)!: expose httpServer with Http2SecureServer union](https://github.com/vitejs/vite/pull/14834)\n  - `http.Server | http2.Http2SecureServer` is now used instead of `http.Server` where appropriate.\n\nAlso there are other breaking changes which only affect few users.\n\n- [\\[#14098\\] fix!: avoid rewriting this (reverts \\#5312)](https://github.com/vitejs/vite/pull/14098)\n  - Top level `this` was rewritten to `globalThis` by default when building. This behavior is now removed.\n- [\\[#14231\\] feat!: add extension to internal virtual modules](https://github.com/vitejs/vite/pull/14231)\n  - Internal virtual modules' id now has an extension (`.js`).\n- [\\[#14583\\] refactor!: remove exporting internal APIs](https://github.com/vitejs/vite/pull/14583)\n  - Removed accidentally exported internal APIs: `isDepsOptimizerEnabled` and `getDepOptimizationConfig`\n  - Removed exported internal types: `DepOptimizationResult`, `DepOptimizationProcessing`, and `DepsOptimizer`\n  - Renamed `ResolveWorkerOptions` type to `ResolvedWorkerOptions`\n- [\\[#5657\\] fix: return 404 for resources requests outside the base path](https://github.com/vitejs/vite/pull/5657)\n  - In the past, Vite responded to requests outside the base path without `Accept: text/html`, as if they were requested with the base path. Vite no longer does that and responds with 404 instead.\n- [\\[#14723\\] fix(resolve)!: remove special .mjs handling](https://github.com/vitejs/vite/pull/14723)\n  - In the past, when a library `\"exports\"` field maps to an `.mjs` file, Vite will still try to match the `\"browser\"` and `\"module\"` fields to fix compatibility with certain libraries. This behavior is now removed to align with the exports resolution algorithm.\n- [\\[#14733\\] feat(resolve)!: remove `resolve.browserField`](https://github.com/vitejs/vite/pull/14733)\n  - `resolve.browserField` has been deprecated since Vite 3 in favour of an updated default of `['browser', 'module', 'jsnext:main', 'jsnext']` for [`resolve.mainFields`](../config/shared-options#resolve-mainfields).\n- [\\[#14855\\] feat!: add isPreview to ConfigEnv and resolveConfig](https://github.com/vitejs/vite/pull/14855)\n  - Renamed `ssrBuild` to `isSsrBuild` in the `ConfigEnv` object.\n- [\\[#14945\\] fix(css): correctly set manifest source name and emit CSS file](https://github.com/vitejs/vite/pull/14945)\n  - CSS file names are now generated based on the chunk name.\n\n## Migration from v3\n\nCheck the [Migration from v3 Guide](https://v4.vitejs.dev/guide/migration) in the Vite v4 docs first to see the needed changes to port your app to Vite v4, and then proceed with the changes on this page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/migration](https://vitejs.dev/guide/migration)"
- name: 'Migration from v4: Advanced'
  id: guide/migration#advanced
  summary: There are some changes which only affect plugin/tool creators
  belongs_to: Migration from v4
  description: |-
    ## Advanced

    There are some changes which only affect plugin/tool creators.

    - [\[#14119\] refactor!: merge `PreviewServerForHook` into `PreviewServer` type](https://github.com/vitejs/vite/pull/14119)
      - The `configurePreviewServer` hook now accepts the `PreviewServer` type instead of `PreviewServerForHook` type.
    - [\[#14818\] refactor(preview)!: use base middleware](https://github.com/vitejs/vite/pull/14818)
      - Middlewares added from the returned function in `configurePreviewServer` now does not have access to the `base` when comparing the `req.url` value. This aligns the behaviour with the dev server. You can check the `base` from the `configResolved` hook if needed.
    - [\[#14834\] fix(types)!: expose httpServer with Http2SecureServer union](https://github.com/vitejs/vite/pull/14834)
      - `http.Server | http2.Http2SecureServer` is now used instead of `http.Server` where appropriate.

    Also there are other breaking changes which only affect few users.

    - [\[#14098\] fix!: avoid rewriting this (reverts \#5312)](https://github.com/vitejs/vite/pull/14098)
      - Top level `this` was rewritten to `globalThis` by default when building. This behavior is now removed.
    - [\[#14231\] feat!: add extension to internal virtual modules](https://github.com/vitejs/vite/pull/14231)
      - Internal virtual modules' id now has an extension (`.js`).
    - [\[#14583\] refactor!: remove exporting internal APIs](https://github.com/vitejs/vite/pull/14583)
      - Removed accidentally exported internal APIs: `isDepsOptimizerEnabled` and `getDepOptimizationConfig`
      - Removed exported internal types: `DepOptimizationResult`, `DepOptimizationProcessing`, and `DepsOptimizer`
      - Renamed `ResolveWorkerOptions` type to `ResolvedWorkerOptions`
    - [\[#5657\] fix: return 404 for resources requests outside the base path](https://github.com/vitejs/vite/pull/5657)
      - In the past, Vite responded to requests outside the base path without `Accept: text/html`, as if they were requested with the base path. Vite no longer does that and responds with 404 instead.
    - [\[#14723\] fix(resolve)!: remove special .mjs handling](https://github.com/vitejs/vite/pull/14723)
      - In the past, when a library `"exports"` field maps to an `.mjs` file, Vite will still try to match the `"browser"` and `"module"` fields to fix compatibility with certain libraries. This behavior is now removed to align with the exports resolution algorithm.
    - [\[#14733\] feat(resolve)!: remove `resolve.browserField`](https://github.com/vitejs/vite/pull/14733)
      - `resolve.browserField` has been deprecated since Vite 3 in favour of an updated default of `['browser', 'module', 'jsnext:main', 'jsnext']` for [`resolve.mainFields`](../config/shared-options#resolve-mainfields).
    - [\[#14855\] feat!: add isPreview to ConfigEnv and resolveConfig](https://github.com/vitejs/vite/pull/14855)
      - Renamed `ssrBuild` to `isSsrBuild` in the `ConfigEnv` object.
    - [\[#14945\] fix(css): correctly set manifest source name and emit CSS file](https://github.com/vitejs/vite/pull/14945)
      - CSS file names are now generated based on the chunk name.

    &nbsp;
- name: 'Migration from v4: Align dev and preview HTML serving behaviour'
  id: guide/migration#align-dev-and-preview-html-serving-behaviour
  summary: In Vite 4, the dev and preview servers serve HTML based on its directory structure and trailing slash differently
  belongs_to: Migration from v4
  description: |-
    ### Align dev and preview HTML serving behaviour

    In Vite 4, the dev and preview servers serve HTML based on its directory structure and trailing slash differently. This causes inconsistencies when testing your built app. Vite 5 refactors into a single behaviour like below, given the following file structure:

    ``` javascript
    ├── index.html
    ├── file.html
    └── dir
        └── index.html
    ```

    | Request           | Before (dev)                 | Before (preview)  | After (dev & preview)        |
    |-------------------|------------------------------|-------------------|------------------------------|
    | `/dir/index.html` | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |
    | `/dir`            | `/index.html` (SPA fallback) | `/dir/index.html` | `/index.html` (SPA fallback) |
    | `/dir/`           | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |
    | `/file.html`      | `/file.html`                 | `/file.html`      | `/file.html`                 |
    | `/file`           | `/index.html` (SPA fallback) | `/file.html`      | `/file.html`                 |
    | `/file/`          | `/index.html` (SPA fallback) | `/file.html`      | `/index.html` (SPA fallback) |
- name: 'Migration from v4: Allow path containing . to fallback to index.html'
  id: guide/migration#allow-path-containing-to-fallback-to-index-html
  summary: In Vite 4, accessing a path in dev containing . did not fallback to index.html even if appType is set to 'spa' (default). From Vite 5, it will fallback to index.html
  belongs_to: Migration from v4
  description: |-
    ### Allow path containing `.` to fallback to index.html

    In Vite 4, accessing a path in dev containing `.` did not fallback to index.html even if [`appType`](../config/shared-options#apptype) is set to `'spa'` (default). From Vite 5, it will fallback to index.html.

    Note that the browser will no longer show a 404 error message in the console if you point the image path to a non-existent file (e.g. `<img src="./file-does-not-exist.png">`).
- name: 'Migration from v4: APIs'
  id: guide/migration
  summary: Vite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL
  description: "# Migration from v4\n\n## Node.js Support\n\nVite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL. Node.js 18 / 20+ is now required.\n\n## Rollup 4\n\nVite is now using Rollup 4 which also brings along its breaking changes, in particular:\n\n- Import assertions (`assertions` prop) has been renamed to import attributes (`attributes` prop).\n- Acorn plugins are no longer supported.\n- For Vite plugins, `this.resolve` `skipSelf` option is now `true` by default.\n- For Vite plugins, `this.parse` now only supports the `allowReturnOutsideFunction` option for now.\n\nRead the full breaking changes in [Rollup's release notes](https://github.com/rollup/rollup/releases/tag/v4.0.0) for build-related changes in [`build.rollupOptions`](../config/build-options#build-rollupoptions).\n\nIf you are using TypeScript, make sure to set `moduleResolution: 'bundler'` (or `node16`/`nodenext`) as Rollup 4 requires it. Or you can set `skipLibCheck: true` instead.\n\n## Deprecate CJS Node API\n\nThe CJS Node API of Vite is deprecated. When calling `require('vite')`, a deprecation warning is now logged. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\n1.  The `vite.config.js` file content is using the ESM syntax.\n2.  The closest `package.json` file has `\"type\": \"module\"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.\n\nFor other projects, there are a few general approaches:\n\n- **Configure ESM as default, opt-in to CJS if needed:** Add `\"type\": \"module\"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.\n- **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `\"type\": \"module\"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.\n- **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.\n\nSee the [troubleshooting guide](troubleshooting#vite-cjs-node-api-deprecated) for more information.\n\n## Rework `define` and `import.meta.env.*` replacement strategy\n\nIn Vite 4, the [`define`](../config/shared-options#define) and [`import.meta.env.*`](env-and-mode#env-variables) features use different replacement strategies in dev and build:\n\n- In dev, both features are injected as global variables to `globalThis` and `import.meta` respectively.\n- In build, both features are statically replaced with a regex.\n\nThis results in a dev and build inconsistency when trying to access the variables, and sometimes even caused failed builds. For example:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('1.0.0'),\n  },\n})\n```\n\njs\n\n``` javascript\nconst data = { __APP_VERSION__ }\n// dev: { __APP_VERSION__: \"1.0.0\" } ✅\n// build: { \"1.0.0\" } ❌\n\nconst docs = 'I like import.meta.env.MODE'\n// dev: \"I like import.meta.env.MODE\" ✅\n// build: \"I like \"production\"\" ❌\n```\n\nVite 5 fixes this by using `esbuild` to handle the replacements in builds, aligning with the dev behaviour.\n\nThis change should not affect most setups, as it's already documented that `define` values should follow esbuild's syntax:\n\n> To be consistent with esbuild behavior, expressions must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier.\n\nHowever, if you prefer to keep statically replacing values directly, you can use [`@rollup/plugin-replace`](https://github.com/rollup/plugins/tree/master/packages/replace).\n\n## General Changes\n\n### SSR externalized modules value now matches production\n\nIn Vite 4, SSR externalized modules are wrapped with `.default` and `.__esModule` handling for better interoperability, but it doesn't match the production behaviour when loaded by the runtime environment (e.g. Node.js), causing hard-to-catch inconsistencies. By default, all direct project dependencies are SSR externalized.\n\nVite 5 now removes the `.default` and `.__esModule` handling to match the production behaviour. In practice, this shouldn't affect properly-packaged dependencies, but if you encounter new issues loading modules, you can try these refactors:\n\njs\n\n``` javascript\n// Before:\nimport { foo } from 'bar'\n\n// After:\nimport _bar from 'bar'\nconst { foo } = _bar\n```\n\njs\n\n``` javascript\n// Before:\nimport foo from 'bar'\n\n// After:\nimport * as _foo from 'bar'\nconst foo = _foo.default\n```\n\nNote that these changes matches the Node.js behaviour, so you can also run the imports in Node.js to test it out. If you prefer to stick with the previous behaviour, you can set `legacy.proxySsrExternalModules` to `true`.\n\n### `worker.plugins` is now a function\n\nIn Vite 4, [`worker.plugins`](../config/worker-options#worker-plugins) accepted an array of plugins (`(Plugin | Plugin[])[]`). From Vite 5, it needs to be configured as a function that returns an array of plugins (`() => (Plugin | Plugin[])[]`). This change is required so parallel worker builds run more consistently and predictably.\n\n### Allow path containing `.` to fallback to index.html\n\nIn Vite 4, accessing a path in dev containing `.` did not fallback to index.html even if [`appType`](../config/shared-options#apptype) is set to `'spa'` (default). From Vite 5, it will fallback to index.html.\n\nNote that the browser will no longer show a 404 error message in the console if you point the image path to a non-existent file (e.g. `<img src=\"./file-does-not-exist.png\">`).\n\n### Align dev and preview HTML serving behaviour\n\nIn Vite 4, the dev and preview servers serve HTML based on its directory structure and trailing slash differently. This causes inconsistencies when testing your built app. Vite 5 refactors into a single behaviour like below, given the following file structure:\n\n``` javascript\n├── index.html\n├── file.html\n└── dir\n    └── index.html\n```\n\n| Request           | Before (dev)                 | Before (preview)  | After (dev & preview)        |\n|-------------------|------------------------------|-------------------|------------------------------|\n| `/dir/index.html` | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |\n| `/dir`            | `/index.html` (SPA fallback) | `/dir/index.html` | `/index.html` (SPA fallback) |\n| `/dir/`           | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |\n| `/file.html`      | `/file.html`                 | `/file.html`      | `/file.html`                 |\n| `/file`           | `/index.html` (SPA fallback) | `/file.html`      | `/file.html`                 |\n| `/file/`          | `/index.html` (SPA fallback) | `/file.html`      | `/index.html` (SPA fallback) |\n\n### Manifest files are now generated in `.vite` directory by default\n\nIn Vite 4, the manifest files ([`build.manifest`](../config/build-options#build-manifest) and [`build.ssrManifest`](../config/build-options#build-ssrmanifest)) were generated in the root of [`build.outDir`](../config/build-options#build-outdir) by default.\n\nFrom Vite 5, they will be generated in the `.vite` directory in the `build.outDir` by default. This change helps deconflict public files with the same manifest file names when they are copied to the `build.outDir`.\n\n### Corresponding CSS files are not listed as top level entry in manifest.json file\n\nIn Vite 4, the corresponding CSS file for a JavaScript entry point was also listed as a top-level entry in the manifest file ([`build.manifest`](../config/build-options#build-manifest)). These entries were unintentionally added and only worked for simple cases.\n\nIn Vite 5, corresponding CSS files can only be found within the JavaScript entry file section. When injecting the JS file, the corresponding CSS files [should be injected](#). When the CSS should be injected separately, it must be added as a separate entry point.\n\n### CLI shortcuts require an additional `Enter` press\n\nCLI shortcuts, like `r` to restart the dev server, now require an additional `Enter` press to trigger the shortcut. For example, `r + Enter` to restart the dev server.\n\nThis change prevents Vite from swallowing and controlling OS-specific shortcuts, allowing better compatibility when combining the Vite dev server with other processes, and avoids the [previous caveats](https://github.com/vitejs/vite/pull/14342).\n\n### Update `experimentalDecorators` and `useDefineForClassFields` TypeScript behaviour\n\nVite 5 uses esbuild 0.19 and removes the compatibility layer for esbuild 0.18, which changes how [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) and [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) are handled.\n\n- **`experimentalDecorators` is not enabled by default**\n\n  You need to set `compilerOptions.experimentalDecorators` to `true` in `tsconfig.json` to use decorators.\n\n- **`useDefineForClassFields` defaults depend on the TypeScript `target` value**\n\n  If `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.\n\n  As such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.\n\njsonc\n\n``` javascript\n{\n  \"compilerOptions\": {\n    // Set true if you use decorators\n    \"experimentalDecorators\": true,\n    // Set true if you see parsing errors in your browser\n    \"useDefineForClassFields\": true,\n  },\n}\n```\n\n### Remove `--https` flag and `https: true`\n\nThe `--https` flag sets `server.https: true` and `preview.https: true` internally. This config was meant to be used together with the automatic https certification generation feature which [was dropped in Vite 3](https://v3.vitejs.dev/guide/migration#automatic-https-certificate-generation). Hence, this config is no longer useful as it will start a Vite HTTPS server without a certificate.\n\nIf you use [`@vitejs/plugin-basic-ssl`](https://github.com/vitejs/vite-plugin-basic-ssl) or [`vite-plugin-mkcert`](https://github.com/liuweiGL/vite-plugin-mkcert), they will already set the `https` config internally, so you can remove `--https`, `server.https: true`, and `preview.https: true` in your setup.\n\n### Remove `resolvePackageEntry` and `resolvePackageData` APIs\n\nThe `resolvePackageEntry` and `resolvePackageData` APIs are removed as they exposed Vite's internals and blocked potential Vite 4.3 optimizations in the past. These APIs can be replaced with third-party packages, for example:\n\n- `resolvePackageEntry`: [`import.meta.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve) or the [`import-meta-resolve`](https://github.com/wooorm/import-meta-resolve) package.\n- `resolvePackageData`: Same as above, and crawl up the package directory to get the root `package.json`. Or use the community [`vitefu`](https://github.com/svitejs/vitefu) package.\n\njs\n\n``` javascript\nimport { resolve } from 'import-meta-env'\nimport { findDepPkgJsonPath } from 'vitefu'\nimport fs from 'node:fs'\n\nconst pkg = 'my-lib'\nconst basedir = process.cwd()\n\n// `resolvePackageEntry`:\nconst packageEntry = resolve(pkg, basedir)\n\n// `resolvePackageData`:\nconst packageJsonPath = findDepPkgJsonPath(pkg, basedir)\nconst packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))\n```\n\n## Removed Deprecated APIs\n\n- Default exports of CSS files (e.g `import style from './foo.css'`): Use the `?inline` query instead\n- `import.meta.globEager`: Use `import.meta.glob('*', { eager: true })` instead\n- `ssr.format: 'cjs'` and `legacy.buildSsrCjsExternalHeuristics` ([\\#13816](https://github.com/vitejs/vite/discussions/13816))\n- `server.middlewareMode: 'ssr'` and `server.middlewareMode: 'html'`: Use [`appType`](../config/shared-options#apptype) + [`server.middlewareMode: true`](../config/server-options#server-middlewaremode) instead ([\\#8452](https://github.com/vitejs/vite/pull/8452))\n\n## Advanced\n\nThere are some changes which only affect plugin/tool creators.\n\n- [\\[#14119\\] refactor!: merge `PreviewServerForHook` into `PreviewServer` type](https://github.com/vitejs/vite/pull/14119)\n  - The `configurePreviewServer` hook now accepts the `PreviewServer` type instead of `PreviewServerForHook` type.\n- [\\[#14818\\] refactor(preview)!: use base middleware](https://github.com/vitejs/vite/pull/14818)\n  - Middlewares added from the returned function in `configurePreviewServer` now does not have access to the `base` when comparing the `req.url` value. This aligns the behaviour with the dev server. You can check the `base` from the `configResolved` hook if needed.\n- [\\[#14834\\] fix(types)!: expose httpServer with Http2SecureServer union](https://github.com/vitejs/vite/pull/14834)\n  - `http.Server | http2.Http2SecureServer` is now used instead of `http.Server` where appropriate.\n\nAlso there are other breaking changes which only affect few users.\n\n- [\\[#14098\\] fix!: avoid rewriting this (reverts \\#5312)](https://github.com/vitejs/vite/pull/14098)\n  - Top level `this` was rewritten to `globalThis` by default when building. This behavior is now removed.\n- [\\[#14231\\] feat!: add extension to internal virtual modules](https://github.com/vitejs/vite/pull/14231)\n  - Internal virtual modules' id now has an extension (`.js`).\n- [\\[#14583\\] refactor!: remove exporting internal APIs](https://github.com/vitejs/vite/pull/14583)\n  - Removed accidentally exported internal APIs: `isDepsOptimizerEnabled` and `getDepOptimizationConfig`\n  - Removed exported internal types: `DepOptimizationResult`, `DepOptimizationProcessing`, and `DepsOptimizer`\n  - Renamed `ResolveWorkerOptions` type to `ResolvedWorkerOptions`\n- [\\[#5657\\] fix: return 404 for resources requests outside the base path](https://github.com/vitejs/vite/pull/5657)\n  - In the past, Vite responded to requests outside the base path without `Accept: text/html`, as if they were requested with the base path. Vite no longer does that and responds with 404 instead.\n- [\\[#14723\\] fix(resolve)!: remove special .mjs handling](https://github.com/vitejs/vite/pull/14723)\n  - In the past, when a library `\"exports\"` field maps to an `.mjs` file, Vite will still try to match the `\"browser\"` and `\"module\"` fields to fix compatibility with certain libraries. This behavior is now removed to align with the exports resolution algorithm.\n- [\\[#14733\\] feat(resolve)!: remove `resolve.browserField`](https://github.com/vitejs/vite/pull/14733)\n  - `resolve.browserField` has been deprecated since Vite 3 in favour of an updated default of `['browser', 'module', 'jsnext:main', 'jsnext']` for [`resolve.mainFields`](../config/shared-options#resolve-mainfields).\n- [\\[#14855\\] feat!: add isPreview to ConfigEnv and resolveConfig](https://github.com/vitejs/vite/pull/14855)\n  - Renamed `ssrBuild` to `isSsrBuild` in the `ConfigEnv` object.\n- [\\[#14945\\] fix(css): correctly set manifest source name and emit CSS file](https://github.com/vitejs/vite/pull/14945)\n  - CSS file names are now generated based on the chunk name.\n\n## Migration from v3\n\nCheck the [Migration from v3 Guide](https://v4.vitejs.dev/guide/migration) in the Vite v4 docs first to see the needed changes to port your app to Vite v4, and then proceed with the changes on this page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/migration](https://vitejs.dev/guide/migration)"
- name: 'Migration from v4: CLI shortcuts require an additional Enter press'
  id: guide/migration#cli-shortcuts-require-an-additional-enter-press
  summary: CLI shortcuts, like r to restart the dev server, now require an additional Enter press to trigger the shortcut
  belongs_to: Migration from v4
  description: |-
    ### CLI shortcuts require an additional `Enter` press

    CLI shortcuts, like `r` to restart the dev server, now require an additional `Enter` press to trigger the shortcut. For example, `r + Enter` to restart the dev server.

    This change prevents Vite from swallowing and controlling OS-specific shortcuts, allowing better compatibility when combining the Vite dev server with other processes, and avoids the [previous caveats](https://github.com/vitejs/vite/pull/14342).
- name: 'Migration from v4: Corresponding CSS files are not listed as top level entry in manifest.json file'
  id: guide/migration#corresponding-css-files-are-not-listed-as-top-level-entry-in-manifest-json-file
  summary: In Vite 4, the corresponding CSS file for a JavaScript entry point was also listed as a top-level entry in the manifest file (build.manifest). These entries were unintentionally added and only worked for simple cases
  belongs_to: Migration from v4
  description: |-
    ### Corresponding CSS files are not listed as top level entry in manifest.json file

    In Vite 4, the corresponding CSS file for a JavaScript entry point was also listed as a top-level entry in the manifest file ([`build.manifest`](../config/build-options#build-manifest)). These entries were unintentionally added and only worked for simple cases.

    In Vite 5, corresponding CSS files can only be found within the JavaScript entry file section. When injecting the JS file, the corresponding CSS files [should be injected](#). When the CSS should be injected separately, it must be added as a separate entry point.
- name: 'Migration from v4: Deprecate CJS Node API'
  id: guide/migration#deprecate-cjs-node-api
  summary: The CJS Node API of Vite is deprecated
  belongs_to: Migration from v4
  description: |-
    ## Deprecate CJS Node API

    The CJS Node API of Vite is deprecated. When calling `require('vite')`, a deprecation warning is now logged. You should update your files or frameworks to import the ESM build of Vite instead.

    In a basic Vite project, make sure:

    1.  The `vite.config.js` file content is using the ESM syntax.
    2.  The closest `package.json` file has `"type": "module"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.

    For other projects, there are a few general approaches:

    - **Configure ESM as default, opt-in to CJS if needed:** Add `"type": "module"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.
    - **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `"type": "module"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.
    - **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.

    See the [troubleshooting guide](troubleshooting#vite-cjs-node-api-deprecated) for more information.
- name: 'Migration from v4: General Changes'
  id: guide/migration#general-changes
  summary: null
  belongs_to: Migration from v4
  description: '## General Changes'
- name: 'Migration from v4: Guide'
  id: guide/migration
  summary: Vite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL
  description: "# Migration from v4\n\n## Node.js Support\n\nVite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL. Node.js 18 / 20+ is now required.\n\n## Rollup 4\n\nVite is now using Rollup 4 which also brings along its breaking changes, in particular:\n\n- Import assertions (`assertions` prop) has been renamed to import attributes (`attributes` prop).\n- Acorn plugins are no longer supported.\n- For Vite plugins, `this.resolve` `skipSelf` option is now `true` by default.\n- For Vite plugins, `this.parse` now only supports the `allowReturnOutsideFunction` option for now.\n\nRead the full breaking changes in [Rollup's release notes](https://github.com/rollup/rollup/releases/tag/v4.0.0) for build-related changes in [`build.rollupOptions`](../config/build-options#build-rollupoptions).\n\nIf you are using TypeScript, make sure to set `moduleResolution: 'bundler'` (or `node16`/`nodenext`) as Rollup 4 requires it. Or you can set `skipLibCheck: true` instead.\n\n## Deprecate CJS Node API\n\nThe CJS Node API of Vite is deprecated. When calling `require('vite')`, a deprecation warning is now logged. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\n1.  The `vite.config.js` file content is using the ESM syntax.\n2.  The closest `package.json` file has `\"type\": \"module\"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.\n\nFor other projects, there are a few general approaches:\n\n- **Configure ESM as default, opt-in to CJS if needed:** Add `\"type\": \"module\"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.\n- **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `\"type\": \"module\"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.\n- **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.\n\nSee the [troubleshooting guide](troubleshooting#vite-cjs-node-api-deprecated) for more information.\n\n## Rework `define` and `import.meta.env.*` replacement strategy\n\nIn Vite 4, the [`define`](../config/shared-options#define) and [`import.meta.env.*`](env-and-mode#env-variables) features use different replacement strategies in dev and build:\n\n- In dev, both features are injected as global variables to `globalThis` and `import.meta` respectively.\n- In build, both features are statically replaced with a regex.\n\nThis results in a dev and build inconsistency when trying to access the variables, and sometimes even caused failed builds. For example:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('1.0.0'),\n  },\n})\n```\n\njs\n\n``` javascript\nconst data = { __APP_VERSION__ }\n// dev: { __APP_VERSION__: \"1.0.0\" } ✅\n// build: { \"1.0.0\" } ❌\n\nconst docs = 'I like import.meta.env.MODE'\n// dev: \"I like import.meta.env.MODE\" ✅\n// build: \"I like \"production\"\" ❌\n```\n\nVite 5 fixes this by using `esbuild` to handle the replacements in builds, aligning with the dev behaviour.\n\nThis change should not affect most setups, as it's already documented that `define` values should follow esbuild's syntax:\n\n> To be consistent with esbuild behavior, expressions must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier.\n\nHowever, if you prefer to keep statically replacing values directly, you can use [`@rollup/plugin-replace`](https://github.com/rollup/plugins/tree/master/packages/replace).\n\n## General Changes\n\n### SSR externalized modules value now matches production\n\nIn Vite 4, SSR externalized modules are wrapped with `.default` and `.__esModule` handling for better interoperability, but it doesn't match the production behaviour when loaded by the runtime environment (e.g. Node.js), causing hard-to-catch inconsistencies. By default, all direct project dependencies are SSR externalized.\n\nVite 5 now removes the `.default` and `.__esModule` handling to match the production behaviour. In practice, this shouldn't affect properly-packaged dependencies, but if you encounter new issues loading modules, you can try these refactors:\n\njs\n\n``` javascript\n// Before:\nimport { foo } from 'bar'\n\n// After:\nimport _bar from 'bar'\nconst { foo } = _bar\n```\n\njs\n\n``` javascript\n// Before:\nimport foo from 'bar'\n\n// After:\nimport * as _foo from 'bar'\nconst foo = _foo.default\n```\n\nNote that these changes matches the Node.js behaviour, so you can also run the imports in Node.js to test it out. If you prefer to stick with the previous behaviour, you can set `legacy.proxySsrExternalModules` to `true`.\n\n### `worker.plugins` is now a function\n\nIn Vite 4, [`worker.plugins`](../config/worker-options#worker-plugins) accepted an array of plugins (`(Plugin | Plugin[])[]`). From Vite 5, it needs to be configured as a function that returns an array of plugins (`() => (Plugin | Plugin[])[]`). This change is required so parallel worker builds run more consistently and predictably.\n\n### Allow path containing `.` to fallback to index.html\n\nIn Vite 4, accessing a path in dev containing `.` did not fallback to index.html even if [`appType`](../config/shared-options#apptype) is set to `'spa'` (default). From Vite 5, it will fallback to index.html.\n\nNote that the browser will no longer show a 404 error message in the console if you point the image path to a non-existent file (e.g. `<img src=\"./file-does-not-exist.png\">`).\n\n### Align dev and preview HTML serving behaviour\n\nIn Vite 4, the dev and preview servers serve HTML based on its directory structure and trailing slash differently. This causes inconsistencies when testing your built app. Vite 5 refactors into a single behaviour like below, given the following file structure:\n\n``` javascript\n├── index.html\n├── file.html\n└── dir\n    └── index.html\n```\n\n| Request           | Before (dev)                 | Before (preview)  | After (dev & preview)        |\n|-------------------|------------------------------|-------------------|------------------------------|\n| `/dir/index.html` | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |\n| `/dir`            | `/index.html` (SPA fallback) | `/dir/index.html` | `/index.html` (SPA fallback) |\n| `/dir/`           | `/dir/index.html`            | `/dir/index.html` | `/dir/index.html`            |\n| `/file.html`      | `/file.html`                 | `/file.html`      | `/file.html`                 |\n| `/file`           | `/index.html` (SPA fallback) | `/file.html`      | `/file.html`                 |\n| `/file/`          | `/index.html` (SPA fallback) | `/file.html`      | `/index.html` (SPA fallback) |\n\n### Manifest files are now generated in `.vite` directory by default\n\nIn Vite 4, the manifest files ([`build.manifest`](../config/build-options#build-manifest) and [`build.ssrManifest`](../config/build-options#build-ssrmanifest)) were generated in the root of [`build.outDir`](../config/build-options#build-outdir) by default.\n\nFrom Vite 5, they will be generated in the `.vite` directory in the `build.outDir` by default. This change helps deconflict public files with the same manifest file names when they are copied to the `build.outDir`.\n\n### Corresponding CSS files are not listed as top level entry in manifest.json file\n\nIn Vite 4, the corresponding CSS file for a JavaScript entry point was also listed as a top-level entry in the manifest file ([`build.manifest`](../config/build-options#build-manifest)). These entries were unintentionally added and only worked for simple cases.\n\nIn Vite 5, corresponding CSS files can only be found within the JavaScript entry file section. When injecting the JS file, the corresponding CSS files [should be injected](#). When the CSS should be injected separately, it must be added as a separate entry point.\n\n### CLI shortcuts require an additional `Enter` press\n\nCLI shortcuts, like `r` to restart the dev server, now require an additional `Enter` press to trigger the shortcut. For example, `r + Enter` to restart the dev server.\n\nThis change prevents Vite from swallowing and controlling OS-specific shortcuts, allowing better compatibility when combining the Vite dev server with other processes, and avoids the [previous caveats](https://github.com/vitejs/vite/pull/14342).\n\n### Update `experimentalDecorators` and `useDefineForClassFields` TypeScript behaviour\n\nVite 5 uses esbuild 0.19 and removes the compatibility layer for esbuild 0.18, which changes how [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) and [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) are handled.\n\n- **`experimentalDecorators` is not enabled by default**\n\n  You need to set `compilerOptions.experimentalDecorators` to `true` in `tsconfig.json` to use decorators.\n\n- **`useDefineForClassFields` defaults depend on the TypeScript `target` value**\n\n  If `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.\n\n  As such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.\n\njsonc\n\n``` javascript\n{\n  \"compilerOptions\": {\n    // Set true if you use decorators\n    \"experimentalDecorators\": true,\n    // Set true if you see parsing errors in your browser\n    \"useDefineForClassFields\": true,\n  },\n}\n```\n\n### Remove `--https` flag and `https: true`\n\nThe `--https` flag sets `server.https: true` and `preview.https: true` internally. This config was meant to be used together with the automatic https certification generation feature which [was dropped in Vite 3](https://v3.vitejs.dev/guide/migration#automatic-https-certificate-generation). Hence, this config is no longer useful as it will start a Vite HTTPS server without a certificate.\n\nIf you use [`@vitejs/plugin-basic-ssl`](https://github.com/vitejs/vite-plugin-basic-ssl) or [`vite-plugin-mkcert`](https://github.com/liuweiGL/vite-plugin-mkcert), they will already set the `https` config internally, so you can remove `--https`, `server.https: true`, and `preview.https: true` in your setup.\n\n### Remove `resolvePackageEntry` and `resolvePackageData` APIs\n\nThe `resolvePackageEntry` and `resolvePackageData` APIs are removed as they exposed Vite's internals and blocked potential Vite 4.3 optimizations in the past. These APIs can be replaced with third-party packages, for example:\n\n- `resolvePackageEntry`: [`import.meta.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve) or the [`import-meta-resolve`](https://github.com/wooorm/import-meta-resolve) package.\n- `resolvePackageData`: Same as above, and crawl up the package directory to get the root `package.json`. Or use the community [`vitefu`](https://github.com/svitejs/vitefu) package.\n\njs\n\n``` javascript\nimport { resolve } from 'import-meta-env'\nimport { findDepPkgJsonPath } from 'vitefu'\nimport fs from 'node:fs'\n\nconst pkg = 'my-lib'\nconst basedir = process.cwd()\n\n// `resolvePackageEntry`:\nconst packageEntry = resolve(pkg, basedir)\n\n// `resolvePackageData`:\nconst packageJsonPath = findDepPkgJsonPath(pkg, basedir)\nconst packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))\n```\n\n## Removed Deprecated APIs\n\n- Default exports of CSS files (e.g `import style from './foo.css'`): Use the `?inline` query instead\n- `import.meta.globEager`: Use `import.meta.glob('*', { eager: true })` instead\n- `ssr.format: 'cjs'` and `legacy.buildSsrCjsExternalHeuristics` ([\\#13816](https://github.com/vitejs/vite/discussions/13816))\n- `server.middlewareMode: 'ssr'` and `server.middlewareMode: 'html'`: Use [`appType`](../config/shared-options#apptype) + [`server.middlewareMode: true`](../config/server-options#server-middlewaremode) instead ([\\#8452](https://github.com/vitejs/vite/pull/8452))\n\n## Advanced\n\nThere are some changes which only affect plugin/tool creators.\n\n- [\\[#14119\\] refactor!: merge `PreviewServerForHook` into `PreviewServer` type](https://github.com/vitejs/vite/pull/14119)\n  - The `configurePreviewServer` hook now accepts the `PreviewServer` type instead of `PreviewServerForHook` type.\n- [\\[#14818\\] refactor(preview)!: use base middleware](https://github.com/vitejs/vite/pull/14818)\n  - Middlewares added from the returned function in `configurePreviewServer` now does not have access to the `base` when comparing the `req.url` value. This aligns the behaviour with the dev server. You can check the `base` from the `configResolved` hook if needed.\n- [\\[#14834\\] fix(types)!: expose httpServer with Http2SecureServer union](https://github.com/vitejs/vite/pull/14834)\n  - `http.Server | http2.Http2SecureServer` is now used instead of `http.Server` where appropriate.\n\nAlso there are other breaking changes which only affect few users.\n\n- [\\[#14098\\] fix!: avoid rewriting this (reverts \\#5312)](https://github.com/vitejs/vite/pull/14098)\n  - Top level `this` was rewritten to `globalThis` by default when building. This behavior is now removed.\n- [\\[#14231\\] feat!: add extension to internal virtual modules](https://github.com/vitejs/vite/pull/14231)\n  - Internal virtual modules' id now has an extension (`.js`).\n- [\\[#14583\\] refactor!: remove exporting internal APIs](https://github.com/vitejs/vite/pull/14583)\n  - Removed accidentally exported internal APIs: `isDepsOptimizerEnabled` and `getDepOptimizationConfig`\n  - Removed exported internal types: `DepOptimizationResult`, `DepOptimizationProcessing`, and `DepsOptimizer`\n  - Renamed `ResolveWorkerOptions` type to `ResolvedWorkerOptions`\n- [\\[#5657\\] fix: return 404 for resources requests outside the base path](https://github.com/vitejs/vite/pull/5657)\n  - In the past, Vite responded to requests outside the base path without `Accept: text/html`, as if they were requested with the base path. Vite no longer does that and responds with 404 instead.\n- [\\[#14723\\] fix(resolve)!: remove special .mjs handling](https://github.com/vitejs/vite/pull/14723)\n  - In the past, when a library `\"exports\"` field maps to an `.mjs` file, Vite will still try to match the `\"browser\"` and `\"module\"` fields to fix compatibility with certain libraries. This behavior is now removed to align with the exports resolution algorithm.\n- [\\[#14733\\] feat(resolve)!: remove `resolve.browserField`](https://github.com/vitejs/vite/pull/14733)\n  - `resolve.browserField` has been deprecated since Vite 3 in favour of an updated default of `['browser', 'module', 'jsnext:main', 'jsnext']` for [`resolve.mainFields`](../config/shared-options#resolve-mainfields).\n- [\\[#14855\\] feat!: add isPreview to ConfigEnv and resolveConfig](https://github.com/vitejs/vite/pull/14855)\n  - Renamed `ssrBuild` to `isSsrBuild` in the `ConfigEnv` object.\n- [\\[#14945\\] fix(css): correctly set manifest source name and emit CSS file](https://github.com/vitejs/vite/pull/14945)\n  - CSS file names are now generated based on the chunk name.\n\n## Migration from v3\n\nCheck the [Migration from v3 Guide](https://v4.vitejs.dev/guide/migration) in the Vite v4 docs first to see the needed changes to port your app to Vite v4, and then proceed with the changes on this page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/migration](https://vitejs.dev/guide/migration)"
- name: 'Migration from v4: Manifest files are now generated in .vite directory by default'
  id: guide/migration#manifest-files-are-now-generated-in-vite-directory-by-default
  summary: In Vite 4, the manifest files (build.manifest and build.ssrManifest) were generated in the root of build.outDir by default
  belongs_to: Migration from v4
  description: |-
    ### Manifest files are now generated in `.vite` directory by default

    In Vite 4, the manifest files ([`build.manifest`](../config/build-options#build-manifest) and [`build.ssrManifest`](../config/build-options#build-ssrmanifest)) were generated in the root of [`build.outDir`](../config/build-options#build-outdir) by default.

    From Vite 5, they will be generated in the `.vite` directory in the `build.outDir` by default. This change helps deconflict public files with the same manifest file names when they are copied to the `build.outDir`.
- name: 'Migration from v4: Migration from v3'
  id: guide/migration#migration-from-v3
  summary: Check the Migration from v3 Guide in the Vite v4 docs first to see the needed changes to port your app to Vite v4, and then proceed with the changes on this page
  belongs_to: Migration from v4
  description: "## Migration from v3\n\nCheck the [Migration from v3 Guide](https://v4.vitejs.dev/guide/migration) in the Vite v4 docs first to see the needed changes to port your app to Vite v4, and then proceed with the changes on this page.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/migration](https://vitejs.dev/guide/migration)"
- name: 'Migration from v4: Node.js Support'
  id: guide/migration#node-js-support
  summary: Vite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL
  belongs_to: Migration from v4
  description: |-
    ## Node.js Support

    Vite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL. Node.js 18 / 20+ is now required.
- name: 'Migration from v4: Remove --https flag and https: true'
  id: guide/migration#remove-https-flag-and-https-true
  summary: 'The --https flag sets server.https: true and preview.https: true internally'
  belongs_to: Migration from v4
  description: |-
    ### Remove `--https` flag and `https: true`

    The `--https` flag sets `server.https: true` and `preview.https: true` internally. This config was meant to be used together with the automatic https certification generation feature which [was dropped in Vite 3](https://v3.vitejs.dev/guide/migration#automatic-https-certificate-generation). Hence, this config is no longer useful as it will start a Vite HTTPS server without a certificate.

    If you use [`@vitejs/plugin-basic-ssl`](https://github.com/vitejs/vite-plugin-basic-ssl) or [`vite-plugin-mkcert`](https://github.com/liuweiGL/vite-plugin-mkcert), they will already set the `https` config internally, so you can remove `--https`, `server.https: true`, and `preview.https: true` in your setup.
- name: 'Migration from v4: Remove resolvePackageEntry and resolvePackageData APIs'
  id: guide/migration#remove-resolvepackageentry-and-resolvepackagedata-apis
  summary: The resolvePackageEntry and resolvePackageData APIs are removed as they exposed Vite's internals and blocked potential Vite 4.3 optimizations in the past
  belongs_to: Migration from v4
  description: |-
    ### Remove `resolvePackageEntry` and `resolvePackageData` APIs

    The `resolvePackageEntry` and `resolvePackageData` APIs are removed as they exposed Vite's internals and blocked potential Vite 4.3 optimizations in the past. These APIs can be replaced with third-party packages, for example:

    - `resolvePackageEntry`: [`import.meta.resolve`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta/resolve) or the [`import-meta-resolve`](https://github.com/wooorm/import-meta-resolve) package.
    - `resolvePackageData`: Same as above, and crawl up the package directory to get the root `package.json`. Or use the community [`vitefu`](https://github.com/svitejs/vitefu) package.

    js

    ``` javascript
    import { resolve } from 'import-meta-env'
    import { findDepPkgJsonPath } from 'vitefu'
    import fs from 'node:fs'

    const pkg = 'my-lib'
    const basedir = process.cwd()

    // `resolvePackageEntry`:
    const packageEntry = resolve(pkg, basedir)

    // `resolvePackageData`:
    const packageJsonPath = findDepPkgJsonPath(pkg, basedir)
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))
    ```
- name: 'Migration from v4: Removed Deprecated APIs'
  id: guide/migration#removed-deprecated-apis
  summary: null
  belongs_to: Migration from v4
  description: |-
    ## Removed Deprecated APIs

    - Default exports of CSS files (e.g `import style from './foo.css'`): Use the `?inline` query instead
    - `import.meta.globEager`: Use `import.meta.glob('*', { eager: true })` instead
    - `ssr.format: 'cjs'` and `legacy.buildSsrCjsExternalHeuristics` ([\#13816](https://github.com/vitejs/vite/discussions/13816))
    - `server.middlewareMode: 'ssr'` and `server.middlewareMode: 'html'`: Use [`appType`](../config/shared-options#apptype) + [`server.middlewareMode: true`](../config/server-options#server-middlewaremode) instead ([\#8452](https://github.com/vitejs/vite/pull/8452))
- name: 'Migration from v4: Rework define and import.meta.env.* replacement strategy'
  id: guide/migration#rework-define-and-import-meta-env-replacement-strategy
  summary: This results in a dev and build inconsistency when trying to access the variables, and sometimes even caused failed builds
  belongs_to: Migration from v4
  description: |-
    ## Rework `define` and `import.meta.env.*` replacement strategy

    In Vite 4, the [`define`](../config/shared-options#define) and [`import.meta.env.*`](env-and-mode#env-variables) features use different replacement strategies in dev and build:

    - In dev, both features are injected as global variables to `globalThis` and `import.meta` respectively.
    - In build, both features are statically replaced with a regex.

    This results in a dev and build inconsistency when trying to access the variables, and sometimes even caused failed builds. For example:

    js

    ``` javascript
    // vite.config.js
    export default defineConfig({
      define: {
        __APP_VERSION__: JSON.stringify('1.0.0'),
      },
    })
    ```

    js

    ``` javascript
    const data = { __APP_VERSION__ }
    // dev: { __APP_VERSION__: "1.0.0" } ✅
    // build: { "1.0.0" } ❌

    const docs = 'I like import.meta.env.MODE'
    // dev: "I like import.meta.env.MODE" ✅
    // build: "I like "production"" ❌
    ```

    Vite 5 fixes this by using `esbuild` to handle the replacements in builds, aligning with the dev behaviour.

    This change should not affect most setups, as it's already documented that `define` values should follow esbuild's syntax:

    > To be consistent with esbuild behavior, expressions must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier.

    However, if you prefer to keep statically replacing values directly, you can use [`@rollup/plugin-replace`](https://github.com/rollup/plugins/tree/master/packages/replace).
- name: 'Migration from v4: Rollup 4'
  id: guide/migration#rollup-4
  summary: Read the full breaking changes in Rollup's release notes for build-related changes in build.rollupOptions
  belongs_to: Migration from v4
  description: |-
    ## Rollup 4

    Vite is now using Rollup 4 which also brings along its breaking changes, in particular:

    - Import assertions (`assertions` prop) has been renamed to import attributes (`attributes` prop).
    - Acorn plugins are no longer supported.
    - For Vite plugins, `this.resolve` `skipSelf` option is now `true` by default.
    - For Vite plugins, `this.parse` now only supports the `allowReturnOutsideFunction` option for now.

    Read the full breaking changes in [Rollup's release notes](https://github.com/rollup/rollup/releases/tag/v4.0.0) for build-related changes in [`build.rollupOptions`](../config/build-options#build-rollupoptions).

    If you are using TypeScript, make sure to set `moduleResolution: 'bundler'` (or `node16`/`nodenext`) as Rollup 4 requires it. Or you can set `skipLibCheck: true` instead.
- name: 'Migration from v4: SSR externalized modules value now matches production'
  id: guide/migration#ssr-externalized-modules-value-now-matches-production
  summary: In Vite 4, SSR externalized modules are wrapped with .default and .__esModule handling for better interoperability, but it doesn't match the production behaviour when loaded by the runtime environment (e.g
  belongs_to: Migration from v4
  description: |-
    ### SSR externalized modules value now matches production

    In Vite 4, SSR externalized modules are wrapped with `.default` and `.__esModule` handling for better interoperability, but it doesn't match the production behaviour when loaded by the runtime environment (e.g. Node.js), causing hard-to-catch inconsistencies. By default, all direct project dependencies are SSR externalized.

    Vite 5 now removes the `.default` and `.__esModule` handling to match the production behaviour. In practice, this shouldn't affect properly-packaged dependencies, but if you encounter new issues loading modules, you can try these refactors:

    js

    ``` javascript
    // Before:
    import { foo } from 'bar'

    // After:
    import _bar from 'bar'
    const { foo } = _bar
    ```

    js

    ``` javascript
    // Before:
    import foo from 'bar'

    // After:
    import * as _foo from 'bar'
    const foo = _foo.default
    ```

    Note that these changes matches the Node.js behaviour, so you can also run the imports in Node.js to test it out. If you prefer to stick with the previous behaviour, you can set `legacy.proxySsrExternalModules` to `true`.
- name: 'Migration from v4: Update experimentalDecorators and useDefineForClassFields TypeScript behaviour'
  id: guide/migration#update-experimentaldecorators-and-usedefineforclassfields-typescript-behaviour
  summary: Vite 5 uses esbuild 0.19 and removes the compatibility layer for esbuild 0.18, which changes how experimentalDecorators and useDefineForClassFields are handled
  belongs_to: Migration from v4
  description: |-
    ### Update `experimentalDecorators` and `useDefineForClassFields` TypeScript behaviour

    Vite 5 uses esbuild 0.19 and removes the compatibility layer for esbuild 0.18, which changes how [`experimentalDecorators`](https://www.typescriptlang.org/tsconfig#experimentalDecorators) and [`useDefineForClassFields`](https://www.typescriptlang.org/tsconfig#useDefineForClassFields) are handled.

    - **`experimentalDecorators` is not enabled by default**

      You need to set `compilerOptions.experimentalDecorators` to `true` in `tsconfig.json` to use decorators.

    - **`useDefineForClassFields` defaults depend on the TypeScript `target` value**

      If `target` is not `ESNext` or `ES2022` or newer, or if there's no `tsconfig.json` file, `useDefineForClassFields` will default to `false` which can be problematic with the default `esbuild.target` value of `esnext`. It may transpile to [static initialization blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks#browser_compatibility) which may not be supported in your browser.

      As such, it is recommended to set `target` to `ESNext` or `ES2022` or newer, or set `useDefineForClassFields` to `true` explicitly when configuring `tsconfig.json`.

    jsonc

    ``` javascript
    {
      "compilerOptions": {
        // Set true if you use decorators
        "experimentalDecorators": true,
        // Set true if you see parsing errors in your browser
        "useDefineForClassFields": true,
      },
    }
    ```
- name: 'Migration from v4: worker.plugins is now a function'
  id: guide/migration#worker-plugins-is-now-a-function
  summary: In Vite 4, worker.plugins accepted an array of plugins ((Plugin | Plugin[])[]). From Vite 5, it needs to be configured as a function that returns an array of plugins (() => (Plugin | Plugin[])[]). This change is required so parallel worker builds run more consistently and predictably
  belongs_to: Migration from v4
  description: |-
    ### `worker.plugins` is now a function

    In Vite 4, [`worker.plugins`](../config/worker-options#worker-plugins) accepted an array of plugins (`(Plugin | Plugin[])[]`). From Vite 5, it needs to be configured as a function that returns an array of plugins (`() => (Plugin | Plugin[])[]`). This change is required so parallel worker builds run more consistently and predictably.
- name: Performance
  id: guide/performance
  summary: While Vite is fast by default, performance issues can creep in as the project's requirements grow
  description: "# Performance\n\nWhile Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:\n\n- Slow server starts\n- Slow page loads\n- Slow builds\n\n## Review your Browser Setup\n\nSome browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools. We recommend creating a dev-only profile without extensions, or switch to incognito mode, while using Vite's dev server in these cases. Incognito mode should also be faster than a regular profile without extensions.\n\nThe Vite dev server does hard caching of pre-bundled dependencies and implements fast 304 responses for source code. Disabling the cache while the Browser Dev Tools are open can have a big impact in startup and full-page reload times. Please check that \"Disable Cache\" isn't enabled while you work with the Vite server.\n\n## Audit Configured Vite Plugins\n\nVite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.\n\nHowever, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:\n\n1.  Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: [vite-plugin-react#212](https://github.com/vitejs/vite-plugin-react/pull/212) and [vite-plugin-pwa#224](https://github.com/vite-pwa/vite-plugin-pwa/pull/244).\n\n2.  The `buildStart`, `config`, and `configResolved` hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.\n\n3.  The `resolveId`, `load`, and `transform` hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the `code` contains a specific keyword, or the `id` matches a specific extension, before doing the full transformation.\n\n    The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.\n\n    You can inspect the duration it takes to transform a file using `vite --debug plugin-transform` or [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect). Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.\n\n**Profiling**\n\nYou can run `vite --profile`, visit the site, and press `p + enter` in your terminal to record a `.cpuprofile`. A tool like [speedscope](https://www.speedscope.app) can then be used to inspect the profile and identify the bottlenecks. You can also [share the profiles](https://chat.vitejs.dev) with the Vite team to help us identify performance issues.\n\n## Reduce Resolve Operations\n\nResolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports \"guessing\" import paths with the [`resolve.extensions`](../config/shared-options#resolve-extensions) option, which defaults to `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`.\n\nWhen you try to import `./Component.jsx` with `import './Component'`, Vite will run these steps to resolve it:\n\n1.  Check if `./Component` exists, no.\n2.  Check if `./Component.mjs` exists, no.\n3.  Check if `./Component.js` exists, no.\n4.  Check if `./Component.mts` exists, no.\n5.  Check if `./Component.ts` exists, no.\n6.  Check if `./Component.jsx` exists, yes!\n\nAs shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.\n\nHence, it's usually better to be explicit with your import paths, e.g. `import './Component.jsx'`. You can also narrow down the list for `resolve.extensions` to reduce the general filesystem checks, but you have to make sure it works for files in `node_modules` too.\n\nIf you're a plugin author, make sure to only call [`this.resolve`](https://rollupjs.org/plugin-development/#this-resolve) when needed to reduce the number of checks above.\n\n**TypeScript**\n\nIf you are using TypeScript, enable `\"moduleResolution\": \"bundler\"` and `\"allowImportingTsExtensions\": true` in your `tsconfig.json`'s `compilerOptions` to use `.ts` and `.tsx` extensions directly in your code.\n\n## Avoid Barrel Files\n\nBarrel files are files that re-export the APIs of other files in the same directory. For example:\n\njs\n\n``` javascript\n// src/utils/index.js\nexport * from './color.js'\nexport * from './dom.js'\nexport * from './slash.js'\n```\n\nWhen you only import an individual API, e.g. `import { slash } from './utils'`, all the files in that barrel file need to be fetched and transformed as they may contain the `slash` API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.\n\nIf possible, you should avoid barrel files and import the individual APIs directly, e.g. `import { slash } from './utils/slash.js'`. You can read [issue \\#8237](https://github.com/vitejs/vite/issues/8237) for more information.\n\n## Warm Up Frequently Used Files\n\nThe Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:\n\nGiven an import graph where the left file imports the right file:\n\n``` javascript\nmain.js -> BigComponent.vue -> big-utils.js -> large-data.json\n```\n\nThe import relationship can only be known after the file is transformed. If `BigComponent.vue` takes some time to transform, `big-utils.js` has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.\n\nVite allows you to warm up files that you know are frequently used, e.g. `big-utils.js`, using the [`server.warmup`](../config/server-options#server-warmup) option. This way `big-utils.js` will be ready and cached to be served immediately when requested.\n\nYou can find files that are frequently used by running `vite --debug transform` and inspect the logs:\n\nbash\n\n``` javascript\nvite:transform 28.72ms /@vite/client +1ms\nvite:transform 62.95ms /src/components/BigComponent.vue +1ms\nvite:transform 102.54ms /src/utils/big-utils.js +1ms\n```\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: [\n        './src/components/BigComponent.vue',\n        './src/utils/big-utils.js',\n      ],\n    },\n  },\n})\n```\n\nNote that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the [`server.warmup`](../config/server-options#server-warmup) option for more information.\n\nUsing [`--open` or `server.open`](../config/server-options#server-open) also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.\n\n## Use Lesser or Native Tooling\n\nKeeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).\n\nExamples of doing less work:\n\n- Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)\n- Don't transform SVGs into UI framework components (React, Vue, etc). Import them as strings or URLs instead.\n- When using `@vitejs/plugin-react`, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).\n\nExamples of using native tooling:\n\nUsing native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.\n\n- Try out the experimental support for [LightningCSS](https://github.com/vitejs/vite/discussions/13835)\n- Use [`@vitejs/plugin-react-swc`](https://github.com/vitejs/vite-plugin-react-swc) in place of `@vitejs/plugin-react`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/performance](https://vitejs.dev/guide/performance)"
- name: 'Performance: APIs'
  id: guide/performance
  summary: While Vite is fast by default, performance issues can creep in as the project's requirements grow
  description: "# Performance\n\nWhile Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:\n\n- Slow server starts\n- Slow page loads\n- Slow builds\n\n## Review your Browser Setup\n\nSome browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools. We recommend creating a dev-only profile without extensions, or switch to incognito mode, while using Vite's dev server in these cases. Incognito mode should also be faster than a regular profile without extensions.\n\nThe Vite dev server does hard caching of pre-bundled dependencies and implements fast 304 responses for source code. Disabling the cache while the Browser Dev Tools are open can have a big impact in startup and full-page reload times. Please check that \"Disable Cache\" isn't enabled while you work with the Vite server.\n\n## Audit Configured Vite Plugins\n\nVite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.\n\nHowever, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:\n\n1.  Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: [vite-plugin-react#212](https://github.com/vitejs/vite-plugin-react/pull/212) and [vite-plugin-pwa#224](https://github.com/vite-pwa/vite-plugin-pwa/pull/244).\n\n2.  The `buildStart`, `config`, and `configResolved` hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.\n\n3.  The `resolveId`, `load`, and `transform` hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the `code` contains a specific keyword, or the `id` matches a specific extension, before doing the full transformation.\n\n    The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.\n\n    You can inspect the duration it takes to transform a file using `vite --debug plugin-transform` or [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect). Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.\n\n**Profiling**\n\nYou can run `vite --profile`, visit the site, and press `p + enter` in your terminal to record a `.cpuprofile`. A tool like [speedscope](https://www.speedscope.app) can then be used to inspect the profile and identify the bottlenecks. You can also [share the profiles](https://chat.vitejs.dev) with the Vite team to help us identify performance issues.\n\n## Reduce Resolve Operations\n\nResolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports \"guessing\" import paths with the [`resolve.extensions`](../config/shared-options#resolve-extensions) option, which defaults to `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`.\n\nWhen you try to import `./Component.jsx` with `import './Component'`, Vite will run these steps to resolve it:\n\n1.  Check if `./Component` exists, no.\n2.  Check if `./Component.mjs` exists, no.\n3.  Check if `./Component.js` exists, no.\n4.  Check if `./Component.mts` exists, no.\n5.  Check if `./Component.ts` exists, no.\n6.  Check if `./Component.jsx` exists, yes!\n\nAs shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.\n\nHence, it's usually better to be explicit with your import paths, e.g. `import './Component.jsx'`. You can also narrow down the list for `resolve.extensions` to reduce the general filesystem checks, but you have to make sure it works for files in `node_modules` too.\n\nIf you're a plugin author, make sure to only call [`this.resolve`](https://rollupjs.org/plugin-development/#this-resolve) when needed to reduce the number of checks above.\n\n**TypeScript**\n\nIf you are using TypeScript, enable `\"moduleResolution\": \"bundler\"` and `\"allowImportingTsExtensions\": true` in your `tsconfig.json`'s `compilerOptions` to use `.ts` and `.tsx` extensions directly in your code.\n\n## Avoid Barrel Files\n\nBarrel files are files that re-export the APIs of other files in the same directory. For example:\n\njs\n\n``` javascript\n// src/utils/index.js\nexport * from './color.js'\nexport * from './dom.js'\nexport * from './slash.js'\n```\n\nWhen you only import an individual API, e.g. `import { slash } from './utils'`, all the files in that barrel file need to be fetched and transformed as they may contain the `slash` API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.\n\nIf possible, you should avoid barrel files and import the individual APIs directly, e.g. `import { slash } from './utils/slash.js'`. You can read [issue \\#8237](https://github.com/vitejs/vite/issues/8237) for more information.\n\n## Warm Up Frequently Used Files\n\nThe Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:\n\nGiven an import graph where the left file imports the right file:\n\n``` javascript\nmain.js -> BigComponent.vue -> big-utils.js -> large-data.json\n```\n\nThe import relationship can only be known after the file is transformed. If `BigComponent.vue` takes some time to transform, `big-utils.js` has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.\n\nVite allows you to warm up files that you know are frequently used, e.g. `big-utils.js`, using the [`server.warmup`](../config/server-options#server-warmup) option. This way `big-utils.js` will be ready and cached to be served immediately when requested.\n\nYou can find files that are frequently used by running `vite --debug transform` and inspect the logs:\n\nbash\n\n``` javascript\nvite:transform 28.72ms /@vite/client +1ms\nvite:transform 62.95ms /src/components/BigComponent.vue +1ms\nvite:transform 102.54ms /src/utils/big-utils.js +1ms\n```\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: [\n        './src/components/BigComponent.vue',\n        './src/utils/big-utils.js',\n      ],\n    },\n  },\n})\n```\n\nNote that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the [`server.warmup`](../config/server-options#server-warmup) option for more information.\n\nUsing [`--open` or `server.open`](../config/server-options#server-open) also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.\n\n## Use Lesser or Native Tooling\n\nKeeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).\n\nExamples of doing less work:\n\n- Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)\n- Don't transform SVGs into UI framework components (React, Vue, etc). Import them as strings or URLs instead.\n- When using `@vitejs/plugin-react`, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).\n\nExamples of using native tooling:\n\nUsing native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.\n\n- Try out the experimental support for [LightningCSS](https://github.com/vitejs/vite/discussions/13835)\n- Use [`@vitejs/plugin-react-swc`](https://github.com/vitejs/vite-plugin-react-swc) in place of `@vitejs/plugin-react`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/performance](https://vitejs.dev/guide/performance)"
- name: 'Performance: Audit Configured Vite Plugins'
  id: guide/performance#audit-configured-vite-plugins
  summary: Vite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem
  belongs_to: Performance
  description: |-
    ## Audit Configured Vite Plugins

    Vite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.

    However, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:

    1.  Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: [vite-plugin-react#212](https://github.com/vitejs/vite-plugin-react/pull/212) and [vite-plugin-pwa#224](https://github.com/vite-pwa/vite-plugin-pwa/pull/244).

    2.  The `buildStart`, `config`, and `configResolved` hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.

    3.  The `resolveId`, `load`, and `transform` hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the `code` contains a specific keyword, or the `id` matches a specific extension, before doing the full transformation.

        The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.

        You can inspect the duration it takes to transform a file using `vite --debug plugin-transform` or [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect). Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.

    **Profiling**

    You can run `vite --profile`, visit the site, and press `p + enter` in your terminal to record a `.cpuprofile`. A tool like [speedscope](https://www.speedscope.app) can then be used to inspect the profile and identify the bottlenecks. You can also [share the profiles](https://chat.vitejs.dev) with the Vite team to help us identify performance issues.
- name: 'Performance: Avoid Barrel Files'
  id: guide/performance#avoid-barrel-files
  summary: Barrel files are files that re-export the APIs of other files in the same directory
  belongs_to: Performance
  description: |-
    ## Avoid Barrel Files

    Barrel files are files that re-export the APIs of other files in the same directory. For example:

    js

    ``` javascript
    // src/utils/index.js
    export * from './color.js'
    export * from './dom.js'
    export * from './slash.js'
    ```

    When you only import an individual API, e.g. `import { slash } from './utils'`, all the files in that barrel file need to be fetched and transformed as they may contain the `slash` API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.

    If possible, you should avoid barrel files and import the individual APIs directly, e.g. `import { slash } from './utils/slash.js'`. You can read [issue \#8237](https://github.com/vitejs/vite/issues/8237) for more information.
- name: 'Performance: Guide'
  id: guide/performance
  summary: While Vite is fast by default, performance issues can creep in as the project's requirements grow
  description: "# Performance\n\nWhile Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:\n\n- Slow server starts\n- Slow page loads\n- Slow builds\n\n## Review your Browser Setup\n\nSome browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools. We recommend creating a dev-only profile without extensions, or switch to incognito mode, while using Vite's dev server in these cases. Incognito mode should also be faster than a regular profile without extensions.\n\nThe Vite dev server does hard caching of pre-bundled dependencies and implements fast 304 responses for source code. Disabling the cache while the Browser Dev Tools are open can have a big impact in startup and full-page reload times. Please check that \"Disable Cache\" isn't enabled while you work with the Vite server.\n\n## Audit Configured Vite Plugins\n\nVite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.\n\nHowever, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:\n\n1.  Large dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: [vite-plugin-react#212](https://github.com/vitejs/vite-plugin-react/pull/212) and [vite-plugin-pwa#224](https://github.com/vite-pwa/vite-plugin-pwa/pull/244).\n\n2.  The `buildStart`, `config`, and `configResolved` hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.\n\n3.  The `resolveId`, `load`, and `transform` hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the `code` contains a specific keyword, or the `id` matches a specific extension, before doing the full transformation.\n\n    The longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.\n\n    You can inspect the duration it takes to transform a file using `vite --debug plugin-transform` or [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect). Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.\n\n**Profiling**\n\nYou can run `vite --profile`, visit the site, and press `p + enter` in your terminal to record a `.cpuprofile`. A tool like [speedscope](https://www.speedscope.app) can then be used to inspect the profile and identify the bottlenecks. You can also [share the profiles](https://chat.vitejs.dev) with the Vite team to help us identify performance issues.\n\n## Reduce Resolve Operations\n\nResolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports \"guessing\" import paths with the [`resolve.extensions`](../config/shared-options#resolve-extensions) option, which defaults to `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`.\n\nWhen you try to import `./Component.jsx` with `import './Component'`, Vite will run these steps to resolve it:\n\n1.  Check if `./Component` exists, no.\n2.  Check if `./Component.mjs` exists, no.\n3.  Check if `./Component.js` exists, no.\n4.  Check if `./Component.mts` exists, no.\n5.  Check if `./Component.ts` exists, no.\n6.  Check if `./Component.jsx` exists, yes!\n\nAs shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.\n\nHence, it's usually better to be explicit with your import paths, e.g. `import './Component.jsx'`. You can also narrow down the list for `resolve.extensions` to reduce the general filesystem checks, but you have to make sure it works for files in `node_modules` too.\n\nIf you're a plugin author, make sure to only call [`this.resolve`](https://rollupjs.org/plugin-development/#this-resolve) when needed to reduce the number of checks above.\n\n**TypeScript**\n\nIf you are using TypeScript, enable `\"moduleResolution\": \"bundler\"` and `\"allowImportingTsExtensions\": true` in your `tsconfig.json`'s `compilerOptions` to use `.ts` and `.tsx` extensions directly in your code.\n\n## Avoid Barrel Files\n\nBarrel files are files that re-export the APIs of other files in the same directory. For example:\n\njs\n\n``` javascript\n// src/utils/index.js\nexport * from './color.js'\nexport * from './dom.js'\nexport * from './slash.js'\n```\n\nWhen you only import an individual API, e.g. `import { slash } from './utils'`, all the files in that barrel file need to be fetched and transformed as they may contain the `slash` API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.\n\nIf possible, you should avoid barrel files and import the individual APIs directly, e.g. `import { slash } from './utils/slash.js'`. You can read [issue \\#8237](https://github.com/vitejs/vite/issues/8237) for more information.\n\n## Warm Up Frequently Used Files\n\nThe Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:\n\nGiven an import graph where the left file imports the right file:\n\n``` javascript\nmain.js -> BigComponent.vue -> big-utils.js -> large-data.json\n```\n\nThe import relationship can only be known after the file is transformed. If `BigComponent.vue` takes some time to transform, `big-utils.js` has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.\n\nVite allows you to warm up files that you know are frequently used, e.g. `big-utils.js`, using the [`server.warmup`](../config/server-options#server-warmup) option. This way `big-utils.js` will be ready and cached to be served immediately when requested.\n\nYou can find files that are frequently used by running `vite --debug transform` and inspect the logs:\n\nbash\n\n``` javascript\nvite:transform 28.72ms /@vite/client +1ms\nvite:transform 62.95ms /src/components/BigComponent.vue +1ms\nvite:transform 102.54ms /src/utils/big-utils.js +1ms\n```\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: [\n        './src/components/BigComponent.vue',\n        './src/utils/big-utils.js',\n      ],\n    },\n  },\n})\n```\n\nNote that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the [`server.warmup`](../config/server-options#server-warmup) option for more information.\n\nUsing [`--open` or `server.open`](../config/server-options#server-open) also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.\n\n## Use Lesser or Native Tooling\n\nKeeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).\n\nExamples of doing less work:\n\n- Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)\n- Don't transform SVGs into UI framework components (React, Vue, etc). Import them as strings or URLs instead.\n- When using `@vitejs/plugin-react`, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).\n\nExamples of using native tooling:\n\nUsing native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.\n\n- Try out the experimental support for [LightningCSS](https://github.com/vitejs/vite/discussions/13835)\n- Use [`@vitejs/plugin-react-swc`](https://github.com/vitejs/vite-plugin-react-swc) in place of `@vitejs/plugin-react`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/performance](https://vitejs.dev/guide/performance)"
- name: 'Performance: Reduce Resolve Operations'
  id: guide/performance#reduce-resolve-operations
  summary: Resolving import paths can be an expensive operation when hitting its worst case often
  belongs_to: Performance
  description: |-
    ## Reduce Resolve Operations

    Resolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports "guessing" import paths with the [`resolve.extensions`](../config/shared-options#resolve-extensions) option, which defaults to `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`.

    When you try to import `./Component.jsx` with `import './Component'`, Vite will run these steps to resolve it:

    1.  Check if `./Component` exists, no.
    2.  Check if `./Component.mjs` exists, no.
    3.  Check if `./Component.js` exists, no.
    4.  Check if `./Component.mts` exists, no.
    5.  Check if `./Component.ts` exists, no.
    6.  Check if `./Component.jsx` exists, yes!

    As shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.

    Hence, it's usually better to be explicit with your import paths, e.g. `import './Component.jsx'`. You can also narrow down the list for `resolve.extensions` to reduce the general filesystem checks, but you have to make sure it works for files in `node_modules` too.

    If you're a plugin author, make sure to only call [`this.resolve`](https://rollupjs.org/plugin-development/#this-resolve) when needed to reduce the number of checks above.

    **TypeScript**

    If you are using TypeScript, enable `"moduleResolution": "bundler"` and `"allowImportingTsExtensions": true` in your `tsconfig.json`'s `compilerOptions` to use `.ts` and `.tsx` extensions directly in your code.
- name: 'Performance: Review your Browser Setup'
  id: guide/performance#review-your-browser-setup
  summary: Some browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools
  belongs_to: Performance
  description: |-
    ## Review your Browser Setup

    Some browser extensions may interfere with requests and slow down startup and reload times for large apps, especially when using browser dev tools. We recommend creating a dev-only profile without extensions, or switch to incognito mode, while using Vite's dev server in these cases. Incognito mode should also be faster than a regular profile without extensions.

    The Vite dev server does hard caching of pre-bundled dependencies and implements fast 304 responses for source code. Disabling the cache while the Browser Dev Tools are open can have a big impact in startup and full-page reload times. Please check that "Disable Cache" isn't enabled while you work with the Vite server.
- name: 'Performance: Use Lesser or Native Tooling'
  id: guide/performance#use-lesser-or-native-tooling
  summary: Using native tooling often brings larger installation size and as so is not the default when starting a new Vite project
  belongs_to: Performance
  description: "## Use Lesser or Native Tooling\n\nKeeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).\n\nExamples of doing less work:\n\n- Use CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)\n- Don't transform SVGs into UI framework components (React, Vue, etc). Import them as strings or URLs instead.\n- When using `@vitejs/plugin-react`, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).\n\nExamples of using native tooling:\n\nUsing native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.\n\n- Try out the experimental support for [LightningCSS](https://github.com/vitejs/vite/discussions/13835)\n- Use [`@vitejs/plugin-react-swc`](https://github.com/vitejs/vite-plugin-react-swc) in place of `@vitejs/plugin-react`.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/performance](https://vitejs.dev/guide/performance)"
- name: 'Performance: Warm Up Frequently Used Files'
  id: guide/performance#warm-up-frequently-used-files
  summary: The Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files
  belongs_to: Performance
  description: |-
    ## Warm Up Frequently Used Files

    The Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:

    Given an import graph where the left file imports the right file:

    ``` javascript
    main.js -> BigComponent.vue -> big-utils.js -> large-data.json
    ```

    The import relationship can only be known after the file is transformed. If `BigComponent.vue` takes some time to transform, `big-utils.js` has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.

    Vite allows you to warm up files that you know are frequently used, e.g. `big-utils.js`, using the [`server.warmup`](../config/server-options#server-warmup) option. This way `big-utils.js` will be ready and cached to be served immediately when requested.

    You can find files that are frequently used by running `vite --debug transform` and inspect the logs:

    bash

    ``` javascript
    vite:transform 28.72ms /@vite/client +1ms
    vite:transform 62.95ms /src/components/BigComponent.vue +1ms
    vite:transform 102.54ms /src/utils/big-utils.js +1ms
    ```

    js

    ``` javascript
    export default defineConfig({
      server: {
        warmup: {
          clientFiles: [
            './src/components/BigComponent.vue',
            './src/utils/big-utils.js',
          ],
        },
      },
    })
    ```

    Note that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the [`server.warmup`](../config/server-options#server-warmup) option for more information.

    Using [`--open` or `server.open`](../config/server-options#server-open) also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.
- name: Plugin API
  id: guide/api-plugin
  summary: Vite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options
  description: "# Plugin API\n\nVite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options. As a result, you can write a Vite plugin once and have it work for both dev and build.\n\n**It is recommended to go through [Rollup's plugin documentation](https://rollupjs.org/plugin-development/) first before reading the sections below.**\n\n## Authoring a Plugin\n\nVite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the [Features guide](features) to see if your need is covered. Also review available community plugins, both in the form of a [compatible Rollup plugin](https://github.com/rollup/awesome) and [Vite Specific plugins](https://github.com/vitejs/awesome-vite#plugins)\n\nWhen creating a plugin, you can inline it in your `vite.config.js`. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others [in the ecosystem](https://chat.vitejs.dev).\n\n**TIP**\n\nWhen learning, debugging, or authoring plugins, we suggest including [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit `localhost:5173/__inspect/` to inspect the modules and transformation stack of your project. Check out install instructions in the [vite-plugin-inspect docs](https://github.com/antfu/vite-plugin-inspect).\n\n## Conventions\n\nIf the plugin doesn't use Vite specific hooks and can be implemented as a [Compatible Rollup Plugin](#rollup-plugin-compatibility), then it is recommended to use the [Rollup Plugin naming conventions](https://rollupjs.org/plugin-development/#conventions).\n\n- Rollup Plugins should have a clear name with `rollup-plugin-` prefix.\n- Include `rollup-plugin` and `vite-plugin` keywords in package.json.\n\nThis exposes the plugin to be also used in pure Rollup or WMR based projects\n\nFor Vite only plugins\n\n- Vite Plugins should have a clear name with `vite-plugin-` prefix.\n- Include `vite-plugin` keyword in package.json.\n- Include a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).\n\nIf your plugin is only going to work for a particular framework, its name should be included as part of the prefix\n\n- `vite-plugin-vue-` prefix for Vue Plugins\n- `vite-plugin-react-` prefix for React Plugins\n- `vite-plugin-svelte-` prefix for Svelte Plugins\n\nSee also [Virtual Modules Convention](#virtual-modules-convention).\n\n## Plugins config\n\nUsers will add plugins to the project `devDependencies` and configure them using the `plugins` array option.\n\njs\n\n``` javascript\n// vite.config.js\nimport vitePlugin from 'vite-plugin-feature'\nimport rollupPlugin from 'rollup-plugin-feature'\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()],\n})\n```\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\n`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\njs\n\n``` javascript\n// framework-plugin\nimport frameworkRefresh from 'vite-plugin-framework-refresh'\nimport frameworkDevtools from 'vite-plugin-framework-devtools'\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}\n```\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport framework from 'vite-plugin-framework'\n\nexport default defineConfig({\n  plugins: [framework()],\n})\n```\n\n## Simple Examples\n\n**TIP**\n\nIt is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.\n\n### Transforming Custom File Types\n\njs\n\n``` javascript\nconst fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: 'transform-file',\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null, // provide source map if available\n        }\n      }\n    },\n  }\n}\n```\n\n### Importing a Virtual File\n\nSee the example in the [next section](#virtual-modules-convention).\n\n## Virtual Modules Convention\n\nVirtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.\n\njs\n\n``` javascript\nexport default function myPlugin() {\n  const virtualModuleId = 'virtual:my-module'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'my-plugin', // required, will show up in warnings and errors\n    resolveId(id) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id) {\n      if (id === resolvedVirtualModuleId) {\n        return `export const msg = \"from virtual module\"`\n      }\n    },\n  }\n}\n```\n\nWhich allows importing the module in JavaScript:\n\njs\n\n``` javascript\nimport { msg } from 'virtual:my-module'\n\nconsole.log(msg)\n```\n\nVirtual modules in Vite (and Rollup) are prefixed with `virtual:` for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a `vite-plugin-posts` could ask users to import a `virtual:posts` or `virtual:posts/helpers` virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with `\\0` while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. `\\0` is not a permitted char in import URLs so we have to replace them during import analysis. A `\\0{id}` virtual id ends up encoded as `/@id/__x00__{id}` during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.\n\nNote that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using `\\0` for these submodules would prevent sourcemaps from working correctly.\n\n## Universal Hooks\n\nDuring dev, the Vite dev server creates a plugin container that invokes [Rollup Build Hooks](https://rollupjs.org/plugin-development/#build-hooks) the same way Rollup does it.\n\nThe following hooks are called once on server start:\n\n- [`options`](https://rollupjs.org/plugin-development/#options)\n- [`buildStart`](https://rollupjs.org/plugin-development/#buildstart)\n\nThe following hooks are called on each incoming module request:\n\n- [`resolveId`](https://rollupjs.org/plugin-development/#resolveid)\n- [`load`](https://rollupjs.org/plugin-development/#load)\n- [`transform`](https://rollupjs.org/plugin-development/#transform)\n\nThese hooks also have an extended `options` parameter with additional Vite-specific properties. You can read more in the [SSR documentation](ssr#ssr-specific-plugin-logic).\n\nSome `resolveId` calls' `importer` value may be an absolute path for a generic `index.html` at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct `importer` value.\n\nThe following hooks are called when the server is closed:\n\n- [`buildEnd`](https://rollupjs.org/plugin-development/#buildend)\n- [`closeBundle`](https://rollupjs.org/plugin-development/#closebundle)\n\nNote that the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook is **not** called during dev, because Vite avoids full AST parses for better performance.\n\n[Output Generation Hooks](https://rollupjs.org/plugin-development/#output-generation-hooks) (except `closeBundle`) are **not** called during dev. You can think of Vite's dev server as only calling `rollup.rollup()` without calling `bundle.generate()`.\n\n## Vite Specific Hooks\n\nVite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.\n\n### `config`\n\n- **Type:** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`\n\n- **Kind:** `async`, `sequential`\n\n  Modify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the `mode` and `command` being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).\n\n  **Example:**\n\n  js\n  ``` javascript\n  // return partial config (recommended)\n  const partialConfigPlugin = () => ({\n    name: 'return-partial',\n    config: () => ({\n      resolve: {\n        alias: {\n          foo: 'bar',\n        },\n      },\n    }),\n  })\n\n  // mutate the config directly (use only when merging doesn't work)\n  const mutateConfigPlugin = () => ({\n    name: 'mutate-config',\n    config(config, { command }) {\n      if (command === 'build') {\n        config.root = 'foo'\n      }\n    },\n  })\n  ```\n\n  **Note**\n  User plugins are resolved before running this hook so injecting other plugins inside the `config` hook will have no effect.\n\n### `configResolved`\n\n- **Type:** `(config: ResolvedConfig) => void | Promise<void>`\n\n- **Kind:** `async`, `parallel`\n\n  Called after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.\n\n  **Example:**\n\n  js\n  ``` javascript\n  const examplePlugin = () => {\n    let config\n\n    return {\n      name: 'read-config',\n\n      configResolved(resolvedConfig) {\n        // store the resolved config\n        config = resolvedConfig\n      },\n\n      // use stored config in other hooks\n      transform(code, id) {\n        if (config.command === 'serve') {\n          // dev: plugin invoked by dev server\n        } else {\n          // build: plugin invoked by Rollup\n        }\n      },\n    }\n  }\n  ```\n\n  Note that the `command` value is `serve` in dev (in the cli `vite`, `vite dev`, and `vite serve` are aliases).\n\n### `configureServer`\n\n- **Type:** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`\n\n- **Kind:** `async`, `sequential`\n\n- **See also:** [ViteDevServer](api-javascript#vitedevserver)\n\n  Hook for configuring the dev server. The most common use case is adding custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-server',\n    configureServer(server) {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    },\n  })\n  ```\n\n  **Injecting Post Middleware**\n\n  The `configureServer` hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware **after** internal middlewares, you can return a function from `configureServer`, which will be called after internal middlewares are installed:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-server',\n    configureServer(server) {\n      // return a post hook that is called after internal middlewares are\n      // installed\n      return () => {\n        server.middlewares.use((req, res, next) => {\n          // custom handle request...\n        })\n      }\n    },\n  })\n  ```\n\n  **Storing Server Access**\n\n  In some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:\n\n  js\n  ``` javascript\n  const myPlugin = () => {\n    let server\n    return {\n      name: 'configure-server',\n      configureServer(_server) {\n        server = _server\n      },\n      transform(code, id) {\n        if (server) {\n          // use server...\n        }\n      },\n    }\n  }\n  ```\n\n  Note `configureServer` is not called when running the production build so your other hooks need to guard against its absence.\n\n### `configurePreviewServer`\n\n- **Type:** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`\n\n- **Kind:** `async`, `sequential`\n\n- **See also:** [PreviewServer](api-javascript#previewserver)\n\n  Same as [`configureServer`](api-plugin#configureserver) but for the preview server. Similarly to `configureServer`, the `configurePreviewServer` hook is called before other middlewares are installed. If you want to inject a middleware **after** other middlewares, you can return a function from `configurePreviewServer`, which will be called after internal middlewares are installed:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-preview-server',\n    configurePreviewServer(server) {\n      // return a post hook that is called after other middlewares are\n      // installed\n      return () => {\n        server.middlewares.use((req, res, next) => {\n          // custom handle request...\n        })\n      }\n    },\n  })\n  ```\n\n### `transformIndexHtml`\n\n- **Type:** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`\n\n- **Kind:** `async`, `sequential`\n\n  Dedicated hook for transforming HTML entry point files such as `index.html`. The hook receives the current HTML string and a transform context. The context exposes the [`ViteDevServer`](api-javascript#vitedevserver) instance during dev, and exposes the Rollup output bundle during build.\n\n  The hook can be async and can return one of the following:\n\n  - Transformed HTML string\n  - An array of tag descriptor objects (`{ tag, attrs, children }`) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to `<head>`)\n  - An object containing both as `{ html, tags }`\n\n  By default `order` is `undefined`, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, `order: 'pre'` will apply the hook before processing the HTML. `order: 'post'` applies the hook after all hooks with `order` undefined are applied.\n\n  **Basic Example:**\n\n  js\n  ``` javascript\n  const htmlPlugin = () => {\n    return {\n      name: 'html-transform',\n      transformIndexHtml(html) {\n        return html.replace(\n          /<title>(.*?)<\\/title>/,\n          `<title>Title replaced!</title>`,\n        )\n      },\n    }\n  }\n  ```\n\n  **Full Hook Signature:**\n\n  ts\n  ``` javascript\n  type IndexHtmlTransformHook = (\n    html: string,\n    ctx: {\n      path: string\n      filename: string\n      server?: ViteDevServer\n      bundle?: import('rollup').OutputBundle\n      chunk?: import('rollup').OutputChunk\n    },\n  ) =>\n    | IndexHtmlTransformResult\n    | void\n    | Promise<IndexHtmlTransformResult | void>\n\n  type IndexHtmlTransformResult =\n    | string\n    | HtmlTagDescriptor[]\n    | {\n        html: string\n        tags: HtmlTagDescriptor[]\n      }\n\n  interface HtmlTagDescriptor {\n    tag: string\n    attrs?: Record<string, string | boolean>\n    children?: string | HtmlTagDescriptor[]\n    /**\n     * default: 'head-prepend'\n     */\n    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'\n  }\n  ```\n\n### `handleHotUpdate`\n\n- **Type:** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`\n\n- **See also:** [HMR API](api-hmr)\n\n  Perform custom HMR update handling. The hook receives a context object with the following signature:\n\n  ts\n  ``` javascript\n  interface HmrContext {\n    file: string\n    timestamp: number\n    modules: Array<ModuleNode>\n    read: () => string | Promise<string>\n    server: ViteDevServer\n  }\n  ```\n\n  - `modules` is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).\n\n  - `read` is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct `fs.readFile` will return empty content. The read function passed in normalizes this behavior.\n\n  The hook can choose to:\n\n  - Filter and narrow down the affected module list so that the HMR is more accurate.\n\n  - Return an empty array and perform a full reload:\n\n    js\n    ``` javascript\n    handleHotUpdate({ server, modules, timestamp }) {\n      server.ws.send({ type: 'full-reload' })\n      // Invalidate modules manually\n      const invalidatedModules = new Set()\n      for (const mod of modules) {\n        server.moduleGraph.invalidateModule(\n          mod,\n          invalidatedModules,\n          timestamp,\n          true\n        )\n      }\n      return []\n    }\n    ```\n\n  - Return an empty array and perform complete custom HMR handling by sending custom events to the client:\n\n    js\n    ``` javascript\n    handleHotUpdate({ server }) {\n      server.ws.send({\n        type: 'custom',\n        event: 'special-update',\n        data: {}\n      })\n      return []\n    }\n    ```\n\n    Client code should register corresponding handler using the [HMR API](api-hmr) (this could be injected by the same plugin's `transform` hook):\n\n    js\n    ``` javascript\n    if (import.meta.hot) {\n      import.meta.hot.on('special-update', (data) => {\n        // perform custom update\n      })\n    }\n    ```\n\n## Plugin Ordering\n\nA Vite plugin can additionally specify an `enforce` property (similar to webpack loaders) to adjust its application order. The value of `enforce` can be either `\"pre\"` or `\"post\"`. The resolved plugins will be in the following order:\n\n- Alias\n- User plugins with `enforce: 'pre'`\n- Vite core plugins\n- User plugins without enforce value\n- Vite build plugins\n- User plugins with `enforce: 'post'`\n- Vite post build plugins (minify, manifest, reporting)\n\nNote that this is separate from hooks ordering, those are still separately subject to their `order` attribute [as usual for Rollup hooks](https://rollupjs.org/plugin-development/#build-hooks).\n\n## Conditional Application\n\nBy default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:\n\njs\n\n``` javascript\nfunction myPlugin() {\n  return {\n    name: 'build-only',\n    apply: 'build', // or 'serve'\n  }\n}\n```\n\nA function can also be used for more precise control:\n\njs\n\n``` javascript\napply(config, { command }) {\n  // apply only on build but not for SSR\n  return command === 'build' && !config.build.ssr\n}\n```\n\n## Rollup Plugin Compatibility\n\nA fair number of Rollup plugins will work directly as a Vite plugin (e.g. `@rollup/plugin-alias` or `@rollup/plugin-json`), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.\n\nIn general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:\n\n- It doesn't use the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook.\n- It doesn't have strong coupling between bundle-phase hooks and output-phase hooks.\n\nIf a Rollup plugin only makes sense for the build phase, then it can be specified under `build.rollupOptions.plugins` instead. It will work the same as a Vite plugin with `enforce: 'post'` and `apply: 'build'`.\n\nYou can also augment an existing Rollup plugin with Vite-only properties:\n\njs\n\n``` javascript\n// vite.config.js\nimport example from 'rollup-plugin-example'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: 'post',\n      apply: 'build',\n    },\n  ],\n})\n```\n\n## Path Normalization\n\nVite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\\\ ) in Windows. However, Rollup plugins use a [`normalizePath` utility function](https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath) from `@rollup/pluginutils` internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the `include` and `exclude` config pattern and other similar paths against resolved ids comparisons work correctly.\n\nSo, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent `normalizePath` utility function is exported from the `vite` module.\n\njs\n\n``` javascript\nimport { normalizePath } from 'vite'\n\nnormalizePath('foo\\\\bar') // 'foo/bar'\nnormalizePath('foo/bar') // 'foo/bar'\n```\n\n## Filtering, include/exclude pattern\n\nVite exposes [`@rollup/pluginutils`'s `createFilter`](https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter) function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.\n\n## Client-server Communication\n\nSince Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.\n\n### Server to Client\n\nOn the plugin side, we could use `server.ws.send` to broadcast events to the client:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('connection', () => {\n          server.ws.send('my:greetings', { msg: 'hello' })\n        })\n      },\n    },\n  ],\n})\n```\n\n**NOTE**\n\nWe recommend **always prefixing** your event names to avoid collisions with other plugins.\n\nOn the client side, use [`hot.on`](api-hmr#hot-on-event-cb) to listen to the events:\n\nts\n\n``` javascript\n// client side\nif (import.meta.hot) {\n  import.meta.hot.on('my:greetings', (data) => {\n    console.log(data.msg) // hello\n  })\n}\n```\n\n### Client to Server\n\nTo send events from the client to the server, we can use [`hot.send`](api-hmr#hot-send-event-payload):\n\nts\n\n``` javascript\n// client side\nif (import.meta.hot) {\n  import.meta.hot.send('my:from-client', { msg: 'Hey!' })\n}\n```\n\nThen use `server.ws.on` and listen to the events on the server side:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('my:from-client', (data, client) => {\n          console.log('Message from client:', data.msg) // Hey!\n          // reply only to the client (if needed)\n          client.send('my:ack', { msg: 'Hi! I got your message!' })\n        })\n      },\n    },\n  ],\n})\n```\n\n### TypeScript for Custom Events\n\nInternally, vite infers the type of a payload from the `CustomEventMap` interface, it is possible to type custom events by extending the interface:\n\n**Note**\n\nMake sure to include the `.d.ts` extension when specifying TypeScript declaration files. Otherwise, Typescript may not know which file the module is trying to extend.\n\nts\n\n``` javascript\n// events.d.ts\nimport 'vite/types/customEvent.d.ts'\n\ndeclare module 'vite/types/customEvent.d.ts' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}\n```\n\nThis interface extension is utilized by `InferCustomEventPayload<T>` to infer the payload type for event `T`. For more information on how this interface is utilized, refer to the [HMR API Documentation](api-hmr#hmr-api).\n\nts\n\n``` javascript\ntype CustomFooPayload = InferCustomEventPayload<'custom:foo'>\nimport.meta.hot?.on('custom:foo', (payload) => {\n  // The type of payload will be { msg: string }\n})\nimport.meta.hot?.on('unknown:event', (payload) => {\n  // The type of payload will be any\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-plugin](https://vitejs.dev/guide/api-plugin)"
- name: 'Plugin API: APIs'
  id: guide/api-plugin
  summary: Vite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options
  description: "# Plugin API\n\nVite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options. As a result, you can write a Vite plugin once and have it work for both dev and build.\n\n**It is recommended to go through [Rollup's plugin documentation](https://rollupjs.org/plugin-development/) first before reading the sections below.**\n\n## Authoring a Plugin\n\nVite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the [Features guide](features) to see if your need is covered. Also review available community plugins, both in the form of a [compatible Rollup plugin](https://github.com/rollup/awesome) and [Vite Specific plugins](https://github.com/vitejs/awesome-vite#plugins)\n\nWhen creating a plugin, you can inline it in your `vite.config.js`. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others [in the ecosystem](https://chat.vitejs.dev).\n\n**TIP**\n\nWhen learning, debugging, or authoring plugins, we suggest including [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit `localhost:5173/__inspect/` to inspect the modules and transformation stack of your project. Check out install instructions in the [vite-plugin-inspect docs](https://github.com/antfu/vite-plugin-inspect).\n\n## Conventions\n\nIf the plugin doesn't use Vite specific hooks and can be implemented as a [Compatible Rollup Plugin](#rollup-plugin-compatibility), then it is recommended to use the [Rollup Plugin naming conventions](https://rollupjs.org/plugin-development/#conventions).\n\n- Rollup Plugins should have a clear name with `rollup-plugin-` prefix.\n- Include `rollup-plugin` and `vite-plugin` keywords in package.json.\n\nThis exposes the plugin to be also used in pure Rollup or WMR based projects\n\nFor Vite only plugins\n\n- Vite Plugins should have a clear name with `vite-plugin-` prefix.\n- Include `vite-plugin` keyword in package.json.\n- Include a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).\n\nIf your plugin is only going to work for a particular framework, its name should be included as part of the prefix\n\n- `vite-plugin-vue-` prefix for Vue Plugins\n- `vite-plugin-react-` prefix for React Plugins\n- `vite-plugin-svelte-` prefix for Svelte Plugins\n\nSee also [Virtual Modules Convention](#virtual-modules-convention).\n\n## Plugins config\n\nUsers will add plugins to the project `devDependencies` and configure them using the `plugins` array option.\n\njs\n\n``` javascript\n// vite.config.js\nimport vitePlugin from 'vite-plugin-feature'\nimport rollupPlugin from 'rollup-plugin-feature'\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()],\n})\n```\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\n`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\njs\n\n``` javascript\n// framework-plugin\nimport frameworkRefresh from 'vite-plugin-framework-refresh'\nimport frameworkDevtools from 'vite-plugin-framework-devtools'\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}\n```\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport framework from 'vite-plugin-framework'\n\nexport default defineConfig({\n  plugins: [framework()],\n})\n```\n\n## Simple Examples\n\n**TIP**\n\nIt is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.\n\n### Transforming Custom File Types\n\njs\n\n``` javascript\nconst fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: 'transform-file',\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null, // provide source map if available\n        }\n      }\n    },\n  }\n}\n```\n\n### Importing a Virtual File\n\nSee the example in the [next section](#virtual-modules-convention).\n\n## Virtual Modules Convention\n\nVirtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.\n\njs\n\n``` javascript\nexport default function myPlugin() {\n  const virtualModuleId = 'virtual:my-module'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'my-plugin', // required, will show up in warnings and errors\n    resolveId(id) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id) {\n      if (id === resolvedVirtualModuleId) {\n        return `export const msg = \"from virtual module\"`\n      }\n    },\n  }\n}\n```\n\nWhich allows importing the module in JavaScript:\n\njs\n\n``` javascript\nimport { msg } from 'virtual:my-module'\n\nconsole.log(msg)\n```\n\nVirtual modules in Vite (and Rollup) are prefixed with `virtual:` for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a `vite-plugin-posts` could ask users to import a `virtual:posts` or `virtual:posts/helpers` virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with `\\0` while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. `\\0` is not a permitted char in import URLs so we have to replace them during import analysis. A `\\0{id}` virtual id ends up encoded as `/@id/__x00__{id}` during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.\n\nNote that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using `\\0` for these submodules would prevent sourcemaps from working correctly.\n\n## Universal Hooks\n\nDuring dev, the Vite dev server creates a plugin container that invokes [Rollup Build Hooks](https://rollupjs.org/plugin-development/#build-hooks) the same way Rollup does it.\n\nThe following hooks are called once on server start:\n\n- [`options`](https://rollupjs.org/plugin-development/#options)\n- [`buildStart`](https://rollupjs.org/plugin-development/#buildstart)\n\nThe following hooks are called on each incoming module request:\n\n- [`resolveId`](https://rollupjs.org/plugin-development/#resolveid)\n- [`load`](https://rollupjs.org/plugin-development/#load)\n- [`transform`](https://rollupjs.org/plugin-development/#transform)\n\nThese hooks also have an extended `options` parameter with additional Vite-specific properties. You can read more in the [SSR documentation](ssr#ssr-specific-plugin-logic).\n\nSome `resolveId` calls' `importer` value may be an absolute path for a generic `index.html` at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct `importer` value.\n\nThe following hooks are called when the server is closed:\n\n- [`buildEnd`](https://rollupjs.org/plugin-development/#buildend)\n- [`closeBundle`](https://rollupjs.org/plugin-development/#closebundle)\n\nNote that the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook is **not** called during dev, because Vite avoids full AST parses for better performance.\n\n[Output Generation Hooks](https://rollupjs.org/plugin-development/#output-generation-hooks) (except `closeBundle`) are **not** called during dev. You can think of Vite's dev server as only calling `rollup.rollup()` without calling `bundle.generate()`.\n\n## Vite Specific Hooks\n\nVite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.\n\n### `config`\n\n- **Type:** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`\n\n- **Kind:** `async`, `sequential`\n\n  Modify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the `mode` and `command` being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).\n\n  **Example:**\n\n  js\n  ``` javascript\n  // return partial config (recommended)\n  const partialConfigPlugin = () => ({\n    name: 'return-partial',\n    config: () => ({\n      resolve: {\n        alias: {\n          foo: 'bar',\n        },\n      },\n    }),\n  })\n\n  // mutate the config directly (use only when merging doesn't work)\n  const mutateConfigPlugin = () => ({\n    name: 'mutate-config',\n    config(config, { command }) {\n      if (command === 'build') {\n        config.root = 'foo'\n      }\n    },\n  })\n  ```\n\n  **Note**\n  User plugins are resolved before running this hook so injecting other plugins inside the `config` hook will have no effect.\n\n### `configResolved`\n\n- **Type:** `(config: ResolvedConfig) => void | Promise<void>`\n\n- **Kind:** `async`, `parallel`\n\n  Called after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.\n\n  **Example:**\n\n  js\n  ``` javascript\n  const examplePlugin = () => {\n    let config\n\n    return {\n      name: 'read-config',\n\n      configResolved(resolvedConfig) {\n        // store the resolved config\n        config = resolvedConfig\n      },\n\n      // use stored config in other hooks\n      transform(code, id) {\n        if (config.command === 'serve') {\n          // dev: plugin invoked by dev server\n        } else {\n          // build: plugin invoked by Rollup\n        }\n      },\n    }\n  }\n  ```\n\n  Note that the `command` value is `serve` in dev (in the cli `vite`, `vite dev`, and `vite serve` are aliases).\n\n### `configureServer`\n\n- **Type:** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`\n\n- **Kind:** `async`, `sequential`\n\n- **See also:** [ViteDevServer](api-javascript#vitedevserver)\n\n  Hook for configuring the dev server. The most common use case is adding custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-server',\n    configureServer(server) {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    },\n  })\n  ```\n\n  **Injecting Post Middleware**\n\n  The `configureServer` hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware **after** internal middlewares, you can return a function from `configureServer`, which will be called after internal middlewares are installed:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-server',\n    configureServer(server) {\n      // return a post hook that is called after internal middlewares are\n      // installed\n      return () => {\n        server.middlewares.use((req, res, next) => {\n          // custom handle request...\n        })\n      }\n    },\n  })\n  ```\n\n  **Storing Server Access**\n\n  In some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:\n\n  js\n  ``` javascript\n  const myPlugin = () => {\n    let server\n    return {\n      name: 'configure-server',\n      configureServer(_server) {\n        server = _server\n      },\n      transform(code, id) {\n        if (server) {\n          // use server...\n        }\n      },\n    }\n  }\n  ```\n\n  Note `configureServer` is not called when running the production build so your other hooks need to guard against its absence.\n\n### `configurePreviewServer`\n\n- **Type:** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`\n\n- **Kind:** `async`, `sequential`\n\n- **See also:** [PreviewServer](api-javascript#previewserver)\n\n  Same as [`configureServer`](api-plugin#configureserver) but for the preview server. Similarly to `configureServer`, the `configurePreviewServer` hook is called before other middlewares are installed. If you want to inject a middleware **after** other middlewares, you can return a function from `configurePreviewServer`, which will be called after internal middlewares are installed:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-preview-server',\n    configurePreviewServer(server) {\n      // return a post hook that is called after other middlewares are\n      // installed\n      return () => {\n        server.middlewares.use((req, res, next) => {\n          // custom handle request...\n        })\n      }\n    },\n  })\n  ```\n\n### `transformIndexHtml`\n\n- **Type:** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`\n\n- **Kind:** `async`, `sequential`\n\n  Dedicated hook for transforming HTML entry point files such as `index.html`. The hook receives the current HTML string and a transform context. The context exposes the [`ViteDevServer`](api-javascript#vitedevserver) instance during dev, and exposes the Rollup output bundle during build.\n\n  The hook can be async and can return one of the following:\n\n  - Transformed HTML string\n  - An array of tag descriptor objects (`{ tag, attrs, children }`) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to `<head>`)\n  - An object containing both as `{ html, tags }`\n\n  By default `order` is `undefined`, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, `order: 'pre'` will apply the hook before processing the HTML. `order: 'post'` applies the hook after all hooks with `order` undefined are applied.\n\n  **Basic Example:**\n\n  js\n  ``` javascript\n  const htmlPlugin = () => {\n    return {\n      name: 'html-transform',\n      transformIndexHtml(html) {\n        return html.replace(\n          /<title>(.*?)<\\/title>/,\n          `<title>Title replaced!</title>`,\n        )\n      },\n    }\n  }\n  ```\n\n  **Full Hook Signature:**\n\n  ts\n  ``` javascript\n  type IndexHtmlTransformHook = (\n    html: string,\n    ctx: {\n      path: string\n      filename: string\n      server?: ViteDevServer\n      bundle?: import('rollup').OutputBundle\n      chunk?: import('rollup').OutputChunk\n    },\n  ) =>\n    | IndexHtmlTransformResult\n    | void\n    | Promise<IndexHtmlTransformResult | void>\n\n  type IndexHtmlTransformResult =\n    | string\n    | HtmlTagDescriptor[]\n    | {\n        html: string\n        tags: HtmlTagDescriptor[]\n      }\n\n  interface HtmlTagDescriptor {\n    tag: string\n    attrs?: Record<string, string | boolean>\n    children?: string | HtmlTagDescriptor[]\n    /**\n     * default: 'head-prepend'\n     */\n    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'\n  }\n  ```\n\n### `handleHotUpdate`\n\n- **Type:** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`\n\n- **See also:** [HMR API](api-hmr)\n\n  Perform custom HMR update handling. The hook receives a context object with the following signature:\n\n  ts\n  ``` javascript\n  interface HmrContext {\n    file: string\n    timestamp: number\n    modules: Array<ModuleNode>\n    read: () => string | Promise<string>\n    server: ViteDevServer\n  }\n  ```\n\n  - `modules` is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).\n\n  - `read` is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct `fs.readFile` will return empty content. The read function passed in normalizes this behavior.\n\n  The hook can choose to:\n\n  - Filter and narrow down the affected module list so that the HMR is more accurate.\n\n  - Return an empty array and perform a full reload:\n\n    js\n    ``` javascript\n    handleHotUpdate({ server, modules, timestamp }) {\n      server.ws.send({ type: 'full-reload' })\n      // Invalidate modules manually\n      const invalidatedModules = new Set()\n      for (const mod of modules) {\n        server.moduleGraph.invalidateModule(\n          mod,\n          invalidatedModules,\n          timestamp,\n          true\n        )\n      }\n      return []\n    }\n    ```\n\n  - Return an empty array and perform complete custom HMR handling by sending custom events to the client:\n\n    js\n    ``` javascript\n    handleHotUpdate({ server }) {\n      server.ws.send({\n        type: 'custom',\n        event: 'special-update',\n        data: {}\n      })\n      return []\n    }\n    ```\n\n    Client code should register corresponding handler using the [HMR API](api-hmr) (this could be injected by the same plugin's `transform` hook):\n\n    js\n    ``` javascript\n    if (import.meta.hot) {\n      import.meta.hot.on('special-update', (data) => {\n        // perform custom update\n      })\n    }\n    ```\n\n## Plugin Ordering\n\nA Vite plugin can additionally specify an `enforce` property (similar to webpack loaders) to adjust its application order. The value of `enforce` can be either `\"pre\"` or `\"post\"`. The resolved plugins will be in the following order:\n\n- Alias\n- User plugins with `enforce: 'pre'`\n- Vite core plugins\n- User plugins without enforce value\n- Vite build plugins\n- User plugins with `enforce: 'post'`\n- Vite post build plugins (minify, manifest, reporting)\n\nNote that this is separate from hooks ordering, those are still separately subject to their `order` attribute [as usual for Rollup hooks](https://rollupjs.org/plugin-development/#build-hooks).\n\n## Conditional Application\n\nBy default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:\n\njs\n\n``` javascript\nfunction myPlugin() {\n  return {\n    name: 'build-only',\n    apply: 'build', // or 'serve'\n  }\n}\n```\n\nA function can also be used for more precise control:\n\njs\n\n``` javascript\napply(config, { command }) {\n  // apply only on build but not for SSR\n  return command === 'build' && !config.build.ssr\n}\n```\n\n## Rollup Plugin Compatibility\n\nA fair number of Rollup plugins will work directly as a Vite plugin (e.g. `@rollup/plugin-alias` or `@rollup/plugin-json`), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.\n\nIn general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:\n\n- It doesn't use the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook.\n- It doesn't have strong coupling between bundle-phase hooks and output-phase hooks.\n\nIf a Rollup plugin only makes sense for the build phase, then it can be specified under `build.rollupOptions.plugins` instead. It will work the same as a Vite plugin with `enforce: 'post'` and `apply: 'build'`.\n\nYou can also augment an existing Rollup plugin with Vite-only properties:\n\njs\n\n``` javascript\n// vite.config.js\nimport example from 'rollup-plugin-example'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: 'post',\n      apply: 'build',\n    },\n  ],\n})\n```\n\n## Path Normalization\n\nVite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\\\ ) in Windows. However, Rollup plugins use a [`normalizePath` utility function](https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath) from `@rollup/pluginutils` internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the `include` and `exclude` config pattern and other similar paths against resolved ids comparisons work correctly.\n\nSo, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent `normalizePath` utility function is exported from the `vite` module.\n\njs\n\n``` javascript\nimport { normalizePath } from 'vite'\n\nnormalizePath('foo\\\\bar') // 'foo/bar'\nnormalizePath('foo/bar') // 'foo/bar'\n```\n\n## Filtering, include/exclude pattern\n\nVite exposes [`@rollup/pluginutils`'s `createFilter`](https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter) function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.\n\n## Client-server Communication\n\nSince Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.\n\n### Server to Client\n\nOn the plugin side, we could use `server.ws.send` to broadcast events to the client:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('connection', () => {\n          server.ws.send('my:greetings', { msg: 'hello' })\n        })\n      },\n    },\n  ],\n})\n```\n\n**NOTE**\n\nWe recommend **always prefixing** your event names to avoid collisions with other plugins.\n\nOn the client side, use [`hot.on`](api-hmr#hot-on-event-cb) to listen to the events:\n\nts\n\n``` javascript\n// client side\nif (import.meta.hot) {\n  import.meta.hot.on('my:greetings', (data) => {\n    console.log(data.msg) // hello\n  })\n}\n```\n\n### Client to Server\n\nTo send events from the client to the server, we can use [`hot.send`](api-hmr#hot-send-event-payload):\n\nts\n\n``` javascript\n// client side\nif (import.meta.hot) {\n  import.meta.hot.send('my:from-client', { msg: 'Hey!' })\n}\n```\n\nThen use `server.ws.on` and listen to the events on the server side:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('my:from-client', (data, client) => {\n          console.log('Message from client:', data.msg) // Hey!\n          // reply only to the client (if needed)\n          client.send('my:ack', { msg: 'Hi! I got your message!' })\n        })\n      },\n    },\n  ],\n})\n```\n\n### TypeScript for Custom Events\n\nInternally, vite infers the type of a payload from the `CustomEventMap` interface, it is possible to type custom events by extending the interface:\n\n**Note**\n\nMake sure to include the `.d.ts` extension when specifying TypeScript declaration files. Otherwise, Typescript may not know which file the module is trying to extend.\n\nts\n\n``` javascript\n// events.d.ts\nimport 'vite/types/customEvent.d.ts'\n\ndeclare module 'vite/types/customEvent.d.ts' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}\n```\n\nThis interface extension is utilized by `InferCustomEventPayload<T>` to infer the payload type for event `T`. For more information on how this interface is utilized, refer to the [HMR API Documentation](api-hmr#hmr-api).\n\nts\n\n``` javascript\ntype CustomFooPayload = InferCustomEventPayload<'custom:foo'>\nimport.meta.hot?.on('custom:foo', (payload) => {\n  // The type of payload will be { msg: string }\n})\nimport.meta.hot?.on('unknown:event', (payload) => {\n  // The type of payload will be any\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-plugin](https://vitejs.dev/guide/api-plugin)"
- name: 'Plugin API: Authoring a Plugin'
  id: guide/api-plugin#authoring-a-plugin
  summary: Vite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the Features guide to see if your need is covered
  belongs_to: Plugin API
  description: |-
    ## Authoring a Plugin

    Vite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the [Features guide](features) to see if your need is covered. Also review available community plugins, both in the form of a [compatible Rollup plugin](https://github.com/rollup/awesome) and [Vite Specific plugins](https://github.com/vitejs/awesome-vite#plugins)

    When creating a plugin, you can inline it in your `vite.config.js`. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others [in the ecosystem](https://chat.vitejs.dev).

    **TIP**

    When learning, debugging, or authoring plugins, we suggest including [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit `localhost:5173/__inspect/` to inspect the modules and transformation stack of your project. Check out install instructions in the [vite-plugin-inspect docs](https://github.com/antfu/vite-plugin-inspect).
- name: 'Plugin API: Client to Server'
  id: guide/api-plugin#client-to-server
  summary: null
  belongs_to: Plugin API
  description: |-
    ### Client to Server

    To send events from the client to the server, we can use [`hot.send`](api-hmr#hot-send-event-payload):

    ts

    ``` javascript
    // client side
    if (import.meta.hot) {
      import.meta.hot.send('my:from-client', { msg: 'Hey!' })
    }
    ```

    Then use `server.ws.on` and listen to the events on the server side:

    js

    ``` javascript
    // vite.config.js
    export default defineConfig({
      plugins: [
        {
          // ...
          configureServer(server) {
            server.ws.on('my:from-client', (data, client) => {
              console.log('Message from client:', data.msg) // Hey!
              // reply only to the client (if needed)
              client.send('my:ack', { msg: 'Hi! I got your message!' })
            })
          },
        },
      ],
    })
    ```
- name: 'Plugin API: Client-server Communication'
  id: guide/api-plugin#client-server-communication
  summary: Since Vite 2.9, we provide some utilities for plugins to help handle the communication with clients
  belongs_to: Plugin API
  description: |-
    ## Client-server Communication

    Since Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.
- name: 'Plugin API: Conditional Application'
  id: guide/api-plugin#conditional-application
  summary: By default plugins are invoked for both serve and build
  belongs_to: Plugin API
  description: |-
    ## Conditional Application

    By default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:

    js

    ``` javascript
    function myPlugin() {
      return {
        name: 'build-only',
        apply: 'build', // or 'serve'
      }
    }
    ```

    A function can also be used for more precise control:

    js

    ``` javascript
    apply(config, { command }) {
      // apply only on build but not for SSR
      return command === 'build' && !config.build.ssr
    }
    ```
- name: 'Plugin API: config'
  id: guide/api-plugin#config
  summary: Modify Vite config before it's resolved
  belongs_to: Plugin API
  description: |-
    ### `config`

    - **Type:** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`

    - **Kind:**`async`, `sequential`

      Modify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the `mode` and `command` being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).

      **Example:**

      js
      ``` javascript
      // return partial config (recommended)
      const partialConfigPlugin = () => ({
        name: 'return-partial',
        config: () => ({
          resolve: {
            alias: {
              foo: 'bar',
            },
          },
        }),
      })

      // mutate the config directly (use only when merging doesn't work)
      const mutateConfigPlugin = () => ({
        name: 'mutate-config',
        config(config, { command }) {
          if (command === 'build') {
            config.root = 'foo'
          }
        },
      })
      ```

      **Note**
      User plugins are resolved before running this hook so injecting other plugins inside the `config` hook will have no effect.
- name: 'Plugin API: configResolved'
  id: guide/api-plugin#configresolved
  summary: Called after the Vite config is resolved
  belongs_to: Plugin API
  description: |-
    ### `configResolved`

    - **Type:** `(config: ResolvedConfig) => void | Promise<void>`

    - **Kind:**`async`, `parallel`

      Called after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.

      **Example:**

      js
      ``` javascript
      const examplePlugin = () => {
        let config

        return {
          name: 'read-config',

          configResolved(resolvedConfig) {
            // store the resolved config
            config = resolvedConfig
          },

          // use stored config in other hooks
          transform(code, id) {
            if (config.command === 'serve') {
              // dev: plugin invoked by dev server
            } else {
              // build: plugin invoked by Rollup
            }
          },
        }
      }
      ```

      Note that the `command` value is `serve` in dev (in the cli `vite`, `vite dev`, and `vite serve` are aliases).

    &nbsp;
- name: 'Plugin API: configurePreviewServer'
  id: guide/api-plugin#configurepreviewserver
  summary: Same as configureServer but for the preview server
  belongs_to: Plugin API
  description: |-
    ### `configurePreviewServer`

    - **Type:** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`

    - **Kind:**`async`, `sequential`

    - **See also:** [PreviewServer](api-javascript#previewserver)

      Same as [`configureServer`](api-plugin#configureserver) but for the preview server. Similarly to `configureServer`, the `configurePreviewServer` hook is called before other middlewares are installed. If you want to inject a middleware **after** other middlewares, you can return a function from `configurePreviewServer`, which will be called after internal middlewares are installed:

      js
      ``` javascript
      const myPlugin = () => ({
        name: 'configure-preview-server',
        configurePreviewServer(server) {
          // return a post hook that is called after other middlewares are
          // installed
          return () => {
            server.middlewares.use((req, res, next) => {
              // custom handle request...
            })
          }
        },
      })
      ```

    &nbsp;
- name: 'Plugin API: configureServer'
  id: guide/api-plugin#configureserver
  summary: Hook for configuring the dev server
  belongs_to: Plugin API
  description: |-
    ### `configureServer`

    - **Type:** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`

    - **Kind:**`async`, `sequential`

    - **See also:** [ViteDevServer](api-javascript#vitedevserver)

      Hook for configuring the dev server. The most common use case is adding custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app:

      js
      ``` javascript
      const myPlugin = () => ({
        name: 'configure-server',
        configureServer(server) {
          server.middlewares.use((req, res, next) => {
            // custom handle request...
          })
        },
      })
      ```

      **Injecting Post Middleware**

      The `configureServer` hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware **after** internal middlewares, you can return a function from `configureServer`, which will be called after internal middlewares are installed:

      js
      ``` javascript
      const myPlugin = () => ({
        name: 'configure-server',
        configureServer(server) {
          // return a post hook that is called after internal middlewares are
          // installed
          return () => {
            server.middlewares.use((req, res, next) => {
              // custom handle request...
            })
          }
        },
      })
      ```

      **Storing Server Access**

      In some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:

      js
      ``` javascript
      const myPlugin = () => {
        let server
        return {
          name: 'configure-server',
          configureServer(_server) {
            server = _server
          },
          transform(code, id) {
            if (server) {
              // use server...
            }
          },
        }
      }
      ```

      Note `configureServer` is not called when running the production build so your other hooks need to guard against its absence.

    &nbsp;
- name: 'Plugin API: Conventions'
  id: guide/api-plugin#conventions
  summary: If the plugin doesn't use Vite specific hooks and can be implemented as a Compatible Rollup Plugin, then it is recommended to use the Rollup Plugin naming conventions
  belongs_to: Plugin API
  description: |-
    ## Conventions

    If the plugin doesn't use Vite specific hooks and can be implemented as a [Compatible Rollup Plugin](#rollup-plugin-compatibility), then it is recommended to use the [Rollup Plugin naming conventions](https://rollupjs.org/plugin-development/#conventions).

    - Rollup Plugins should have a clear name with `rollup-plugin-` prefix.
    - Include `rollup-plugin` and `vite-plugin` keywords in package.json.

    This exposes the plugin to be also used in pure Rollup or WMR based projects

    For Vite only plugins

    - Vite Plugins should have a clear name with `vite-plugin-` prefix.
    - Include `vite-plugin` keyword in package.json.
    - Include a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).

    If your plugin is only going to work for a particular framework, its name should be included as part of the prefix

    - `vite-plugin-vue-` prefix for Vue Plugins
    - `vite-plugin-react-` prefix for React Plugins
    - `vite-plugin-svelte-` prefix for Svelte Plugins

    See also [Virtual Modules Convention](#virtual-modules-convention).
- name: 'Plugin API: Filtering, include/exclude pattern'
  id: guide/api-plugin#filtering-include-exclude-pattern
  summary: Vite exposes @rollup/pluginutils's createFilter function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself
  belongs_to: Plugin API
  description: |-
    ## Filtering, include/exclude pattern

    Vite exposes [`@rollup/pluginutils`'s `createFilter`](https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter) function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.
- name: 'Plugin API: Guide'
  id: guide/api-plugin
  summary: Vite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options
  description: "# Plugin API\n\nVite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options. As a result, you can write a Vite plugin once and have it work for both dev and build.\n\n**It is recommended to go through [Rollup's plugin documentation](https://rollupjs.org/plugin-development/) first before reading the sections below.**\n\n## Authoring a Plugin\n\nVite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the [Features guide](features) to see if your need is covered. Also review available community plugins, both in the form of a [compatible Rollup plugin](https://github.com/rollup/awesome) and [Vite Specific plugins](https://github.com/vitejs/awesome-vite#plugins)\n\nWhen creating a plugin, you can inline it in your `vite.config.js`. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others [in the ecosystem](https://chat.vitejs.dev).\n\n**TIP**\n\nWhen learning, debugging, or authoring plugins, we suggest including [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect) in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit `localhost:5173/__inspect/` to inspect the modules and transformation stack of your project. Check out install instructions in the [vite-plugin-inspect docs](https://github.com/antfu/vite-plugin-inspect).\n\n## Conventions\n\nIf the plugin doesn't use Vite specific hooks and can be implemented as a [Compatible Rollup Plugin](#rollup-plugin-compatibility), then it is recommended to use the [Rollup Plugin naming conventions](https://rollupjs.org/plugin-development/#conventions).\n\n- Rollup Plugins should have a clear name with `rollup-plugin-` prefix.\n- Include `rollup-plugin` and `vite-plugin` keywords in package.json.\n\nThis exposes the plugin to be also used in pure Rollup or WMR based projects\n\nFor Vite only plugins\n\n- Vite Plugins should have a clear name with `vite-plugin-` prefix.\n- Include `vite-plugin` keyword in package.json.\n- Include a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).\n\nIf your plugin is only going to work for a particular framework, its name should be included as part of the prefix\n\n- `vite-plugin-vue-` prefix for Vue Plugins\n- `vite-plugin-react-` prefix for React Plugins\n- `vite-plugin-svelte-` prefix for Svelte Plugins\n\nSee also [Virtual Modules Convention](#virtual-modules-convention).\n\n## Plugins config\n\nUsers will add plugins to the project `devDependencies` and configure them using the `plugins` array option.\n\njs\n\n``` javascript\n// vite.config.js\nimport vitePlugin from 'vite-plugin-feature'\nimport rollupPlugin from 'rollup-plugin-feature'\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()],\n})\n```\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\n`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\njs\n\n``` javascript\n// framework-plugin\nimport frameworkRefresh from 'vite-plugin-framework-refresh'\nimport frameworkDevtools from 'vite-plugin-framework-devtools'\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}\n```\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport framework from 'vite-plugin-framework'\n\nexport default defineConfig({\n  plugins: [framework()],\n})\n```\n\n## Simple Examples\n\n**TIP**\n\nIt is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.\n\n### Transforming Custom File Types\n\njs\n\n``` javascript\nconst fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: 'transform-file',\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null, // provide source map if available\n        }\n      }\n    },\n  }\n}\n```\n\n### Importing a Virtual File\n\nSee the example in the [next section](#virtual-modules-convention).\n\n## Virtual Modules Convention\n\nVirtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.\n\njs\n\n``` javascript\nexport default function myPlugin() {\n  const virtualModuleId = 'virtual:my-module'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'my-plugin', // required, will show up in warnings and errors\n    resolveId(id) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id) {\n      if (id === resolvedVirtualModuleId) {\n        return `export const msg = \"from virtual module\"`\n      }\n    },\n  }\n}\n```\n\nWhich allows importing the module in JavaScript:\n\njs\n\n``` javascript\nimport { msg } from 'virtual:my-module'\n\nconsole.log(msg)\n```\n\nVirtual modules in Vite (and Rollup) are prefixed with `virtual:` for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a `vite-plugin-posts` could ask users to import a `virtual:posts` or `virtual:posts/helpers` virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with `\\0` while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. `\\0` is not a permitted char in import URLs so we have to replace them during import analysis. A `\\0{id}` virtual id ends up encoded as `/@id/__x00__{id}` during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.\n\nNote that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using `\\0` for these submodules would prevent sourcemaps from working correctly.\n\n## Universal Hooks\n\nDuring dev, the Vite dev server creates a plugin container that invokes [Rollup Build Hooks](https://rollupjs.org/plugin-development/#build-hooks) the same way Rollup does it.\n\nThe following hooks are called once on server start:\n\n- [`options`](https://rollupjs.org/plugin-development/#options)\n- [`buildStart`](https://rollupjs.org/plugin-development/#buildstart)\n\nThe following hooks are called on each incoming module request:\n\n- [`resolveId`](https://rollupjs.org/plugin-development/#resolveid)\n- [`load`](https://rollupjs.org/plugin-development/#load)\n- [`transform`](https://rollupjs.org/plugin-development/#transform)\n\nThese hooks also have an extended `options` parameter with additional Vite-specific properties. You can read more in the [SSR documentation](ssr#ssr-specific-plugin-logic).\n\nSome `resolveId` calls' `importer` value may be an absolute path for a generic `index.html` at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct `importer` value.\n\nThe following hooks are called when the server is closed:\n\n- [`buildEnd`](https://rollupjs.org/plugin-development/#buildend)\n- [`closeBundle`](https://rollupjs.org/plugin-development/#closebundle)\n\nNote that the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook is **not** called during dev, because Vite avoids full AST parses for better performance.\n\n[Output Generation Hooks](https://rollupjs.org/plugin-development/#output-generation-hooks) (except `closeBundle`) are **not** called during dev. You can think of Vite's dev server as only calling `rollup.rollup()` without calling `bundle.generate()`.\n\n## Vite Specific Hooks\n\nVite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.\n\n### `config`\n\n- **Type:** `(config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void`\n\n- **Kind:** `async`, `sequential`\n\n  Modify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the `mode` and `command` being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).\n\n  **Example:**\n\n  js\n  ``` javascript\n  // return partial config (recommended)\n  const partialConfigPlugin = () => ({\n    name: 'return-partial',\n    config: () => ({\n      resolve: {\n        alias: {\n          foo: 'bar',\n        },\n      },\n    }),\n  })\n\n  // mutate the config directly (use only when merging doesn't work)\n  const mutateConfigPlugin = () => ({\n    name: 'mutate-config',\n    config(config, { command }) {\n      if (command === 'build') {\n        config.root = 'foo'\n      }\n    },\n  })\n  ```\n\n  **Note**\n  User plugins are resolved before running this hook so injecting other plugins inside the `config` hook will have no effect.\n\n### `configResolved`\n\n- **Type:** `(config: ResolvedConfig) => void | Promise<void>`\n\n- **Kind:** `async`, `parallel`\n\n  Called after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.\n\n  **Example:**\n\n  js\n  ``` javascript\n  const examplePlugin = () => {\n    let config\n\n    return {\n      name: 'read-config',\n\n      configResolved(resolvedConfig) {\n        // store the resolved config\n        config = resolvedConfig\n      },\n\n      // use stored config in other hooks\n      transform(code, id) {\n        if (config.command === 'serve') {\n          // dev: plugin invoked by dev server\n        } else {\n          // build: plugin invoked by Rollup\n        }\n      },\n    }\n  }\n  ```\n\n  Note that the `command` value is `serve` in dev (in the cli `vite`, `vite dev`, and `vite serve` are aliases).\n\n### `configureServer`\n\n- **Type:** `(server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>`\n\n- **Kind:** `async`, `sequential`\n\n- **See also:** [ViteDevServer](api-javascript#vitedevserver)\n\n  Hook for configuring the dev server. The most common use case is adding custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-server',\n    configureServer(server) {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    },\n  })\n  ```\n\n  **Injecting Post Middleware**\n\n  The `configureServer` hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware **after** internal middlewares, you can return a function from `configureServer`, which will be called after internal middlewares are installed:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-server',\n    configureServer(server) {\n      // return a post hook that is called after internal middlewares are\n      // installed\n      return () => {\n        server.middlewares.use((req, res, next) => {\n          // custom handle request...\n        })\n      }\n    },\n  })\n  ```\n\n  **Storing Server Access**\n\n  In some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:\n\n  js\n  ``` javascript\n  const myPlugin = () => {\n    let server\n    return {\n      name: 'configure-server',\n      configureServer(_server) {\n        server = _server\n      },\n      transform(code, id) {\n        if (server) {\n          // use server...\n        }\n      },\n    }\n  }\n  ```\n\n  Note `configureServer` is not called when running the production build so your other hooks need to guard against its absence.\n\n### `configurePreviewServer`\n\n- **Type:** `(server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>`\n\n- **Kind:** `async`, `sequential`\n\n- **See also:** [PreviewServer](api-javascript#previewserver)\n\n  Same as [`configureServer`](api-plugin#configureserver) but for the preview server. Similarly to `configureServer`, the `configurePreviewServer` hook is called before other middlewares are installed. If you want to inject a middleware **after** other middlewares, you can return a function from `configurePreviewServer`, which will be called after internal middlewares are installed:\n\n  js\n  ``` javascript\n  const myPlugin = () => ({\n    name: 'configure-preview-server',\n    configurePreviewServer(server) {\n      // return a post hook that is called after other middlewares are\n      // installed\n      return () => {\n        server.middlewares.use((req, res, next) => {\n          // custom handle request...\n        })\n      }\n    },\n  })\n  ```\n\n### `transformIndexHtml`\n\n- **Type:** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`\n\n- **Kind:** `async`, `sequential`\n\n  Dedicated hook for transforming HTML entry point files such as `index.html`. The hook receives the current HTML string and a transform context. The context exposes the [`ViteDevServer`](api-javascript#vitedevserver) instance during dev, and exposes the Rollup output bundle during build.\n\n  The hook can be async and can return one of the following:\n\n  - Transformed HTML string\n  - An array of tag descriptor objects (`{ tag, attrs, children }`) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to `<head>`)\n  - An object containing both as `{ html, tags }`\n\n  By default `order` is `undefined`, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, `order: 'pre'` will apply the hook before processing the HTML. `order: 'post'` applies the hook after all hooks with `order` undefined are applied.\n\n  **Basic Example:**\n\n  js\n  ``` javascript\n  const htmlPlugin = () => {\n    return {\n      name: 'html-transform',\n      transformIndexHtml(html) {\n        return html.replace(\n          /<title>(.*?)<\\/title>/,\n          `<title>Title replaced!</title>`,\n        )\n      },\n    }\n  }\n  ```\n\n  **Full Hook Signature:**\n\n  ts\n  ``` javascript\n  type IndexHtmlTransformHook = (\n    html: string,\n    ctx: {\n      path: string\n      filename: string\n      server?: ViteDevServer\n      bundle?: import('rollup').OutputBundle\n      chunk?: import('rollup').OutputChunk\n    },\n  ) =>\n    | IndexHtmlTransformResult\n    | void\n    | Promise<IndexHtmlTransformResult | void>\n\n  type IndexHtmlTransformResult =\n    | string\n    | HtmlTagDescriptor[]\n    | {\n        html: string\n        tags: HtmlTagDescriptor[]\n      }\n\n  interface HtmlTagDescriptor {\n    tag: string\n    attrs?: Record<string, string | boolean>\n    children?: string | HtmlTagDescriptor[]\n    /**\n     * default: 'head-prepend'\n     */\n    injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'\n  }\n  ```\n\n### `handleHotUpdate`\n\n- **Type:** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`\n\n- **See also:** [HMR API](api-hmr)\n\n  Perform custom HMR update handling. The hook receives a context object with the following signature:\n\n  ts\n  ``` javascript\n  interface HmrContext {\n    file: string\n    timestamp: number\n    modules: Array<ModuleNode>\n    read: () => string | Promise<string>\n    server: ViteDevServer\n  }\n  ```\n\n  - `modules` is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).\n\n  - `read` is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct `fs.readFile` will return empty content. The read function passed in normalizes this behavior.\n\n  The hook can choose to:\n\n  - Filter and narrow down the affected module list so that the HMR is more accurate.\n\n  - Return an empty array and perform a full reload:\n\n    js\n    ``` javascript\n    handleHotUpdate({ server, modules, timestamp }) {\n      server.ws.send({ type: 'full-reload' })\n      // Invalidate modules manually\n      const invalidatedModules = new Set()\n      for (const mod of modules) {\n        server.moduleGraph.invalidateModule(\n          mod,\n          invalidatedModules,\n          timestamp,\n          true\n        )\n      }\n      return []\n    }\n    ```\n\n  - Return an empty array and perform complete custom HMR handling by sending custom events to the client:\n\n    js\n    ``` javascript\n    handleHotUpdate({ server }) {\n      server.ws.send({\n        type: 'custom',\n        event: 'special-update',\n        data: {}\n      })\n      return []\n    }\n    ```\n\n    Client code should register corresponding handler using the [HMR API](api-hmr) (this could be injected by the same plugin's `transform` hook):\n\n    js\n    ``` javascript\n    if (import.meta.hot) {\n      import.meta.hot.on('special-update', (data) => {\n        // perform custom update\n      })\n    }\n    ```\n\n## Plugin Ordering\n\nA Vite plugin can additionally specify an `enforce` property (similar to webpack loaders) to adjust its application order. The value of `enforce` can be either `\"pre\"` or `\"post\"`. The resolved plugins will be in the following order:\n\n- Alias\n- User plugins with `enforce: 'pre'`\n- Vite core plugins\n- User plugins without enforce value\n- Vite build plugins\n- User plugins with `enforce: 'post'`\n- Vite post build plugins (minify, manifest, reporting)\n\nNote that this is separate from hooks ordering, those are still separately subject to their `order` attribute [as usual for Rollup hooks](https://rollupjs.org/plugin-development/#build-hooks).\n\n## Conditional Application\n\nBy default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:\n\njs\n\n``` javascript\nfunction myPlugin() {\n  return {\n    name: 'build-only',\n    apply: 'build', // or 'serve'\n  }\n}\n```\n\nA function can also be used for more precise control:\n\njs\n\n``` javascript\napply(config, { command }) {\n  // apply only on build but not for SSR\n  return command === 'build' && !config.build.ssr\n}\n```\n\n## Rollup Plugin Compatibility\n\nA fair number of Rollup plugins will work directly as a Vite plugin (e.g. `@rollup/plugin-alias` or `@rollup/plugin-json`), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.\n\nIn general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:\n\n- It doesn't use the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook.\n- It doesn't have strong coupling between bundle-phase hooks and output-phase hooks.\n\nIf a Rollup plugin only makes sense for the build phase, then it can be specified under `build.rollupOptions.plugins` instead. It will work the same as a Vite plugin with `enforce: 'post'` and `apply: 'build'`.\n\nYou can also augment an existing Rollup plugin with Vite-only properties:\n\njs\n\n``` javascript\n// vite.config.js\nimport example from 'rollup-plugin-example'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: 'post',\n      apply: 'build',\n    },\n  ],\n})\n```\n\n## Path Normalization\n\nVite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\\\ ) in Windows. However, Rollup plugins use a [`normalizePath` utility function](https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath) from `@rollup/pluginutils` internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the `include` and `exclude` config pattern and other similar paths against resolved ids comparisons work correctly.\n\nSo, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent `normalizePath` utility function is exported from the `vite` module.\n\njs\n\n``` javascript\nimport { normalizePath } from 'vite'\n\nnormalizePath('foo\\\\bar') // 'foo/bar'\nnormalizePath('foo/bar') // 'foo/bar'\n```\n\n## Filtering, include/exclude pattern\n\nVite exposes [`@rollup/pluginutils`'s `createFilter`](https://github.com/rollup/plugins/tree/master/packages/pluginutils#createfilter) function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.\n\n## Client-server Communication\n\nSince Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.\n\n### Server to Client\n\nOn the plugin side, we could use `server.ws.send` to broadcast events to the client:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('connection', () => {\n          server.ws.send('my:greetings', { msg: 'hello' })\n        })\n      },\n    },\n  ],\n})\n```\n\n**NOTE**\n\nWe recommend **always prefixing** your event names to avoid collisions with other plugins.\n\nOn the client side, use [`hot.on`](api-hmr#hot-on-event-cb) to listen to the events:\n\nts\n\n``` javascript\n// client side\nif (import.meta.hot) {\n  import.meta.hot.on('my:greetings', (data) => {\n    console.log(data.msg) // hello\n  })\n}\n```\n\n### Client to Server\n\nTo send events from the client to the server, we can use [`hot.send`](api-hmr#hot-send-event-payload):\n\nts\n\n``` javascript\n// client side\nif (import.meta.hot) {\n  import.meta.hot.send('my:from-client', { msg: 'Hey!' })\n}\n```\n\nThen use `server.ws.on` and listen to the events on the server side:\n\njs\n\n``` javascript\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('my:from-client', (data, client) => {\n          console.log('Message from client:', data.msg) // Hey!\n          // reply only to the client (if needed)\n          client.send('my:ack', { msg: 'Hi! I got your message!' })\n        })\n      },\n    },\n  ],\n})\n```\n\n### TypeScript for Custom Events\n\nInternally, vite infers the type of a payload from the `CustomEventMap` interface, it is possible to type custom events by extending the interface:\n\n**Note**\n\nMake sure to include the `.d.ts` extension when specifying TypeScript declaration files. Otherwise, Typescript may not know which file the module is trying to extend.\n\nts\n\n``` javascript\n// events.d.ts\nimport 'vite/types/customEvent.d.ts'\n\ndeclare module 'vite/types/customEvent.d.ts' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}\n```\n\nThis interface extension is utilized by `InferCustomEventPayload<T>` to infer the payload type for event `T`. For more information on how this interface is utilized, refer to the [HMR API Documentation](api-hmr#hmr-api).\n\nts\n\n``` javascript\ntype CustomFooPayload = InferCustomEventPayload<'custom:foo'>\nimport.meta.hot?.on('custom:foo', (payload) => {\n  // The type of payload will be { msg: string }\n})\nimport.meta.hot?.on('unknown:event', (payload) => {\n  // The type of payload will be any\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-plugin](https://vitejs.dev/guide/api-plugin)"
- name: 'Plugin API: handleHotUpdate'
  id: guide/api-plugin#handlehotupdate
  summary: Perform custom HMR update handling
  belongs_to: Plugin API
  description: |-
    ### `handleHotUpdate`

    - **Type:** `(ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>`

    - **See also:** [HMR API](api-hmr)

      Perform custom HMR update handling. The hook receives a context object with the following signature:

      ts
      ``` javascript
      interface HmrContext {
        file: string
        timestamp: number
        modules: Array<ModuleNode>
        read: () => string | Promise<string>
        server: ViteDevServer
      }
      ```

      - `modules` is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).

      - `read` is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct `fs.readFile` will return empty content. The read function passed in normalizes this behavior.

      The hook can choose to:

      - Filter and narrow down the affected module list so that the HMR is more accurate.

      - Return an empty array and perform a full reload:

        js
        ``` javascript
        handleHotUpdate({ server, modules, timestamp }) {
          server.ws.send({ type: 'full-reload' })
          // Invalidate modules manually
          const invalidatedModules = new Set()
          for (const mod of modules) {
            server.moduleGraph.invalidateModule(
              mod,
              invalidatedModules,
              timestamp,
              true
            )
          }
          return []
        }
        ```

      - Return an empty array and perform complete custom HMR handling by sending custom events to the client:

        js
        ``` javascript
        handleHotUpdate({ server }) {
          server.ws.send({
            type: 'custom',
            event: 'special-update',
            data: {}
          })
          return []
        }
        ```

        Client code should register corresponding handler using the [HMR API](api-hmr) (this could be injected by the same plugin's `transform` hook):

        js
        ``` javascript
        if (import.meta.hot) {
          import.meta.hot.on('special-update', (data) => {
            // perform custom update
          })
        }
        ```

    &nbsp;
- name: 'Plugin API: Importing a Virtual File'
  id: guide/api-plugin#importing-a-virtual-file
  summary: See the example in the next section
  belongs_to: Plugin API
  description: |-
    ### Importing a Virtual File

    See the example in the [next section](#virtual-modules-convention).
- name: 'Plugin API: Path Normalization'
  id: guide/api-plugin#path-normalization
  summary: Vite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows
  belongs_to: Plugin API
  description: |-
    ## Path Normalization

    Vite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\ ) in Windows. However, Rollup plugins use a [`normalizePath` utility function](https://github.com/rollup/plugins/tree/master/packages/pluginutils#normalizepath) from `@rollup/pluginutils` internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the `include` and `exclude` config pattern and other similar paths against resolved ids comparisons work correctly.

    So, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent `normalizePath` utility function is exported from the `vite` module.

    js

    ``` javascript
    import { normalizePath } from 'vite'

    normalizePath('foo\\bar') // 'foo/bar'
    normalizePath('foo/bar') // 'foo/bar'
    ```
- name: 'Plugin API: Plugin Ordering'
  id: guide/api-plugin#plugin-ordering
  summary: A Vite plugin can additionally specify an enforce property (similar to webpack loaders) to adjust its application order
  belongs_to: Plugin API
  description: |-
    ## Plugin Ordering

    A Vite plugin can additionally specify an `enforce` property (similar to webpack loaders) to adjust its application order. The value of `enforce` can be either `"pre"` or `"post"`. The resolved plugins will be in the following order:

    - Alias
    - User plugins with `enforce: 'pre'`
    - Vite core plugins
    - User plugins without enforce value
    - Vite build plugins
    - User plugins with `enforce: 'post'`
    - Vite post build plugins (minify, manifest, reporting)

    Note that this is separate from hooks ordering, those are still separately subject to their `order` attribute [as usual for Rollup hooks](https://rollupjs.org/plugin-development/#build-hooks).
- name: 'Plugin API: Plugins config'
  id: guide/api-plugin#plugins-config
  summary: Users will add plugins to the project devDependencies and configure them using the plugins array option
  belongs_to: Plugin API
  description: |-
    ## Plugins config

    Users will add plugins to the project `devDependencies` and configure them using the `plugins` array option.

    js

    ``` javascript
    // vite.config.js
    import vitePlugin from 'vite-plugin-feature'
    import rollupPlugin from 'rollup-plugin-feature'

    export default defineConfig({
      plugins: [vitePlugin(), rollupPlugin()],
    })
    ```

    Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins.

    `plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.

    js

    ``` javascript
    // framework-plugin
    import frameworkRefresh from 'vite-plugin-framework-refresh'
    import frameworkDevtools from 'vite-plugin-framework-devtools'

    export default function framework(config) {
      return [frameworkRefresh(config), frameworkDevTools(config)]
    }
    ```

    js

    ``` javascript
    // vite.config.js
    import { defineConfig } from 'vite'
    import framework from 'vite-plugin-framework'

    export default defineConfig({
      plugins: [framework()],
    })
    ```
- name: 'Plugin API: Rollup Plugin Compatibility'
  id: guide/api-plugin#rollup-plugin-compatibility
  summary: A fair number of Rollup plugins will work directly as a Vite plugin (e.g
  belongs_to: Plugin API
  description: |-
    ## Rollup Plugin Compatibility

    A fair number of Rollup plugins will work directly as a Vite plugin (e.g. `@rollup/plugin-alias` or `@rollup/plugin-json`), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.

    In general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:

    - It doesn't use the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook.
    - It doesn't have strong coupling between bundle-phase hooks and output-phase hooks.

    If a Rollup plugin only makes sense for the build phase, then it can be specified under `build.rollupOptions.plugins` instead. It will work the same as a Vite plugin with `enforce: 'post'` and `apply: 'build'`.

    You can also augment an existing Rollup plugin with Vite-only properties:

    js

    ``` javascript
    // vite.config.js
    import example from 'rollup-plugin-example'
    import { defineConfig } from 'vite'

    export default defineConfig({
      plugins: [
        {
          ...example(),
          enforce: 'post',
          apply: 'build',
        },
      ],
    })
    ```
- name: 'Plugin API: Server to Client'
  id: guide/api-plugin#server-to-client
  summary: We recommend always prefixing your event names to avoid collisions with other plugins
  belongs_to: Plugin API
  description: |-
    ### Server to Client

    On the plugin side, we could use `server.ws.send` to broadcast events to the client:

    js

    ``` javascript
    // vite.config.js
    export default defineConfig({
      plugins: [
        {
          // ...
          configureServer(server) {
            server.ws.on('connection', () => {
              server.ws.send('my:greetings', { msg: 'hello' })
            })
          },
        },
      ],
    })
    ```

    **NOTE**

    We recommend **always prefixing** your event names to avoid collisions with other plugins.

    On the client side, use [`hot.on`](api-hmr#hot-on-event-cb) to listen to the events:

    ts

    ``` javascript
    // client side
    if (import.meta.hot) {
      import.meta.hot.on('my:greetings', (data) => {
        console.log(data.msg) // hello
      })
    }
    ```
- name: 'Plugin API: Simple Examples'
  id: guide/api-plugin#simple-examples
  summary: It is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object
  belongs_to: Plugin API
  description: |-
    ## Simple Examples

    **TIP**

    It is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.
- name: 'Plugin API: transformIndexHtml'
  id: guide/api-plugin#transformindexhtml
  summary: Dedicated hook for transforming HTML entry point files such as index.html
  belongs_to: Plugin API
  description: |-
    ### `transformIndexHtml`

    - **Type:** `IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }`

    - **Kind:**`async`, `sequential`

      Dedicated hook for transforming HTML entry point files such as `index.html`. The hook receives the current HTML string and a transform context. The context exposes the [`ViteDevServer`](api-javascript#vitedevserver) instance during dev, and exposes the Rollup output bundle during build.

      The hook can be async and can return one of the following:

      - Transformed HTML string
      - An array of tag descriptor objects (`{ tag, attrs, children }`) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to `<head>`)
      - An object containing both as `{ html, tags }`

      By default `order` is `undefined`, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, `order: 'pre'` will apply the hook before processing the HTML. `order: 'post'` applies the hook after all hooks with `order` undefined are applied.

      **Basic Example:**

      js
      ``` javascript
      const htmlPlugin = () => {
        return {
          name: 'html-transform',
          transformIndexHtml(html) {
            return html.replace(
              /<title>(.*?)<\/title>/,
              `<title>Title replaced!</title>`,
            )
          },
        }
      }
      ```

      **Full Hook Signature:**

      ts
      ``` javascript
      type IndexHtmlTransformHook = (
        html: string,
        ctx: {
          path: string
          filename: string
          server?: ViteDevServer
          bundle?: import('rollup').OutputBundle
          chunk?: import('rollup').OutputChunk
        },
      ) =>
        | IndexHtmlTransformResult
        | void
        | Promise<IndexHtmlTransformResult | void>

      type IndexHtmlTransformResult =
        | string
        | HtmlTagDescriptor[]
        | {
            html: string
            tags: HtmlTagDescriptor[]
          }

      interface HtmlTagDescriptor {
        tag: string
        attrs?: Record<string, string | boolean>
        children?: string | HtmlTagDescriptor[]
        /**
         * default: 'head-prepend'
         */
        injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'
      }
      ```

    &nbsp;
- name: 'Plugin API: Transforming Custom File Types'
  id: guide/api-plugin#transforming-custom-file-types
  summary: null
  belongs_to: Plugin API
  description: |-
    ### Transforming Custom File Types

    js

    ``` javascript
    const fileRegex = /\.(my-file-ext)$/

    export default function myPlugin() {
      return {
        name: 'transform-file',

        transform(src, id) {
          if (fileRegex.test(id)) {
            return {
              code: compileFileToJS(src),
              map: null, // provide source map if available
            }
          }
        },
      }
    }
    ```
- name: 'Plugin API: TypeScript for Custom Events'
  id: guide/api-plugin#typescript-for-custom-events
  summary: Make sure to include the .d.ts extension when specifying TypeScript declaration files
  belongs_to: Plugin API
  description: "### TypeScript for Custom Events\n\nInternally, vite infers the type of a payload from the `CustomEventMap` interface, it is possible to type custom events by extending the interface:\n\n**Note**\n\nMake sure to include the `.d.ts` extension when specifying TypeScript declaration files. Otherwise, Typescript may not know which file the module is trying to extend.\n\nts\n\n``` javascript\n// events.d.ts\nimport 'vite/types/customEvent.d.ts'\n\ndeclare module 'vite/types/customEvent.d.ts' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}\n```\n\nThis interface extension is utilized by `InferCustomEventPayload<T>` to infer the payload type for event `T`. For more information on how this interface is utilized, refer to the [HMR API Documentation](api-hmr#hmr-api).\n\nts\n\n``` javascript\ntype CustomFooPayload = InferCustomEventPayload<'custom:foo'>\nimport.meta.hot?.on('custom:foo', (payload) => {\n  // The type of payload will be { msg: string }\n})\nimport.meta.hot?.on('unknown:event', (payload) => {\n  // The type of payload will be any\n})\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-plugin](https://vitejs.dev/guide/api-plugin)"
- name: 'Plugin API: Universal Hooks'
  id: guide/api-plugin#universal-hooks
  summary: During dev, the Vite dev server creates a plugin container that invokes Rollup Build Hooks the same way Rollup does it
  belongs_to: Plugin API
  description: |-
    ## Universal Hooks

    During dev, the Vite dev server creates a plugin container that invokes [Rollup Build Hooks](https://rollupjs.org/plugin-development/#build-hooks) the same way Rollup does it.

    The following hooks are called once on server start:

    - [`options`](https://rollupjs.org/plugin-development/#options)
    - [`buildStart`](https://rollupjs.org/plugin-development/#buildstart)

    The following hooks are called on each incoming module request:

    - [`resolveId`](https://rollupjs.org/plugin-development/#resolveid)
    - [`load`](https://rollupjs.org/plugin-development/#load)
    - [`transform`](https://rollupjs.org/plugin-development/#transform)

    These hooks also have an extended `options` parameter with additional Vite-specific properties. You can read more in the [SSR documentation](ssr#ssr-specific-plugin-logic).

    Some `resolveId` calls' `importer` value may be an absolute path for a generic `index.html` at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct `importer` value.

    The following hooks are called when the server is closed:

    - [`buildEnd`](https://rollupjs.org/plugin-development/#buildend)
    - [`closeBundle`](https://rollupjs.org/plugin-development/#closebundle)

    Note that the [`moduleParsed`](https://rollupjs.org/plugin-development/#moduleparsed) hook is **not** called during dev, because Vite avoids full AST parses for better performance.

    [Output Generation Hooks](https://rollupjs.org/plugin-development/#output-generation-hooks) (except `closeBundle`) are **not** called during dev. You can think of Vite's dev server as only calling `rollup.rollup()` without calling `bundle.generate()`.
- name: 'Plugin API: Virtual Modules Convention'
  id: guide/api-plugin#virtual-modules-convention
  summary: Virtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax
  belongs_to: Plugin API
  description: |-
    ## Virtual Modules Convention

    Virtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.

    js

    ``` javascript
    export default function myPlugin() {
      const virtualModuleId = 'virtual:my-module'
      const resolvedVirtualModuleId = '\0' + virtualModuleId

      return {
        name: 'my-plugin', // required, will show up in warnings and errors
        resolveId(id) {
          if (id === virtualModuleId) {
            return resolvedVirtualModuleId
          }
        },
        load(id) {
          if (id === resolvedVirtualModuleId) {
            return `export const msg = "from virtual module"`
          }
        },
      }
    }
    ```

    Which allows importing the module in JavaScript:

    js

    ``` javascript
    import { msg } from 'virtual:my-module'

    console.log(msg)
    ```

    Virtual modules in Vite (and Rollup) are prefixed with `virtual:` for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a `vite-plugin-posts` could ask users to import a `virtual:posts` or `virtual:posts/helpers` virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with `\0` while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. `\0` is not a permitted char in import URLs so we have to replace them during import analysis. A `\0{id}` virtual id ends up encoded as `/@id/__x00__{id}` during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.

    Note that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using `\0` for these submodules would prevent sourcemaps from working correctly.
- name: 'Plugin API: Vite Specific Hooks'
  id: guide/api-plugin#vite-specific-hooks
  summary: Vite plugins can also provide hooks that serve Vite-specific purposes
  belongs_to: Plugin API
  description: |-
    ## Vite Specific Hooks

    Vite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.
- name: Preview Options
  id: config/preview-options
  summary: Specify which IP addresses the server should listen on
  description: "# Preview Options\n\n## preview.host\n\n- **Type:** `string | boolean`\n- **Default:** [`server.host`](server-options#server-host)\n\nSpecify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.\n\nThis can be set via the CLI using `--host 0.0.0.0` or `--host`.\n\n**NOTE**\n\nThere are cases when other servers might respond instead of Vite. See [`server.host`](server-options#server-host) for more details.\n\n## preview.port\n\n- **Type:** `number`\n- **Default:** `4173`\n\nSpecify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    port: 3030,\n  },\n  preview: {\n    port: 8080,\n  },\n})\n```\n\n## preview.strictPort\n\n- **Type:** `boolean`\n- **Default:** [`server.strictPort`](server-options#server-strictport)\n\nSet to `true` to exit if port is already in use, instead of automatically trying the next available port.\n\n## preview.https\n\n- **Type:** `boolean | https.ServerOptions`\n- **Default:** [`server.https`](server-options#server-https)\n\nEnable TLS + HTTP/2. Note this downgrades to TLS only when the [`server.proxy` option](server-options#server-proxy) is also used.\n\nThe value can also be an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.\n\n## preview.open\n\n- **Type:** `boolean | string`\n- **Default:** [`server.open`](server-options#server-open)\n\nAutomatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).\n\n`BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.\n\n## preview.proxy\n\n- **Type:** `Record<string, string | ProxyOptions>`\n- **Default:** [`server.proxy`](server-options#server-proxy)\n\nConfigure custom proxy rules for the preview server. Expects an object of `{ key: options }` pairs. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.\n\nUses [`http-proxy`](https://github.com/http-party/node-http-proxy). Full options [here](https://github.com/http-party/node-http-proxy#options).\n\n## preview.cors\n\n- **Type:** `boolean | CorsOptions`\n- **Default:** [`server.cors`](server-options#server-cors)\n\nConfigure CORS for the preview server. This is enabled by default and allows any origin. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `false` to disable.\n\n## preview.headers\n\n- **Type:** `OutgoingHttpHeaders`\n\nSpecify server response headers.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/preview-options](https://vitejs.dev/config/preview-options)"
- name: 'Preview Options: Config'
  id: config/preview-options
  summary: Specify which IP addresses the server should listen on
  description: "# Preview Options\n\n## preview.host\n\n- **Type:** `string | boolean`\n- **Default:** [`server.host`](server-options#server-host)\n\nSpecify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.\n\nThis can be set via the CLI using `--host 0.0.0.0` or `--host`.\n\n**NOTE**\n\nThere are cases when other servers might respond instead of Vite. See [`server.host`](server-options#server-host) for more details.\n\n## preview.port\n\n- **Type:** `number`\n- **Default:** `4173`\n\nSpecify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    port: 3030,\n  },\n  preview: {\n    port: 8080,\n  },\n})\n```\n\n## preview.strictPort\n\n- **Type:** `boolean`\n- **Default:** [`server.strictPort`](server-options#server-strictport)\n\nSet to `true` to exit if port is already in use, instead of automatically trying the next available port.\n\n## preview.https\n\n- **Type:** `boolean | https.ServerOptions`\n- **Default:** [`server.https`](server-options#server-https)\n\nEnable TLS + HTTP/2. Note this downgrades to TLS only when the [`server.proxy` option](server-options#server-proxy) is also used.\n\nThe value can also be an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.\n\n## preview.open\n\n- **Type:** `boolean | string`\n- **Default:** [`server.open`](server-options#server-open)\n\nAutomatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).\n\n`BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.\n\n## preview.proxy\n\n- **Type:** `Record<string, string | ProxyOptions>`\n- **Default:** [`server.proxy`](server-options#server-proxy)\n\nConfigure custom proxy rules for the preview server. Expects an object of `{ key: options }` pairs. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.\n\nUses [`http-proxy`](https://github.com/http-party/node-http-proxy). Full options [here](https://github.com/http-party/node-http-proxy#options).\n\n## preview.cors\n\n- **Type:** `boolean | CorsOptions`\n- **Default:** [`server.cors`](server-options#server-cors)\n\nConfigure CORS for the preview server. This is enabled by default and allows any origin. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `false` to disable.\n\n## preview.headers\n\n- **Type:** `OutgoingHttpHeaders`\n\nSpecify server response headers.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/preview-options](https://vitejs.dev/config/preview-options)"
- name: 'Preview Options: preview.cors'
  id: config/preview-options#preview-cors
  summary: Configure CORS for the preview server
  belongs_to: Preview Options
  description: |-
    ## preview.cors

    - **Type:** `boolean | CorsOptions`
    - **Default:** [`server.cors`](server-options#server-cors)

    Configure CORS for the preview server. This is enabled by default and allows any origin. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `false` to disable.
- name: 'Preview Options: preview.headers'
  id: config/preview-options#preview-headers
  summary: Specify server response headers
  belongs_to: Preview Options
  description: "## preview.headers\n\n- **Type:** `OutgoingHttpHeaders`\n\nSpecify server response headers.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/preview-options](https://vitejs.dev/config/preview-options)"
- name: 'Preview Options: preview.host'
  id: config/preview-options#preview-host
  summary: Specify which IP addresses the server should listen on
  belongs_to: Preview Options
  description: |-
    ## preview.host

    - **Type:** `string | boolean`
    - **Default:** [`server.host`](server-options#server-host)

    Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.

    This can be set via the CLI using `--host 0.0.0.0` or `--host`.

    **NOTE**

    There are cases when other servers might respond instead of Vite. See [`server.host`](server-options#server-host) for more details.
- name: 'Preview Options: preview.https'
  id: config/preview-options#preview-https
  summary: Enable TLS + HTTP/2
  belongs_to: Preview Options
  description: |-
    ## preview.https

    - **Type:** `boolean | https.ServerOptions`
    - **Default:** [`server.https`](server-options#server-https)

    Enable TLS + HTTP/2. Note this downgrades to TLS only when the [`server.proxy` option](server-options#server-proxy) is also used.

    The value can also be an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.
- name: 'Preview Options: preview.open'
  id: config/preview-options#preview-open
  summary: Automatically open the app in the browser on server start
  belongs_to: Preview Options
  description: |-
    ## preview.open

    - **Type:** `boolean | string`
    - **Default:** [`server.open`](server-options#server-open)

    Automatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).

    `BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.
- name: 'Preview Options: preview.port'
  id: config/preview-options#preview-port
  summary: Specify server port
  belongs_to: Preview Options
  description: |-
    ## preview.port

    - **Type:** `number`
    - **Default:** `4173`

    Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      server: {
        port: 3030,
      },
      preview: {
        port: 8080,
      },
    })
    ```
- name: 'Preview Options: preview.proxy'
  id: config/preview-options#preview-proxy
  summary: Configure custom proxy rules for the preview server
  belongs_to: Preview Options
  description: |-
    ## preview.proxy

    - **Type:** `Record<string, string | ProxyOptions>`
    - **Default:** [`server.proxy`](server-options#server-proxy)

    Configure custom proxy rules for the preview server. Expects an object of `{ key: options }` pairs. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.

    Uses [`http-proxy`](https://github.com/http-party/node-http-proxy). Full options [here](https://github.com/http-party/node-http-proxy#options).
- name: 'Preview Options: preview.strictPort'
  id: config/preview-options#preview-strictport
  summary: Set to true to exit if port is already in use, instead of automatically trying the next available port
  belongs_to: Preview Options
  description: |-
    ## preview.strictPort

    - **Type:** `boolean`
    - **Default:** [`server.strictPort`](server-options#server-strictport)

    Set to `true` to exit if port is already in use, instead of automatically trying the next available port.
- name: Project Philosophy
  id: guide/philosophy
  summary: Vite doesn't intend to cover every use case for every user
  description: "# Project Philosophy\n\n## Lean Extendable Core\n\nVite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but [Vite core](https://github.com/vitejs/vite) must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to [Vite's rollup-based plugin system](api-plugin). Features that can be implemented as external plugins will generally not be added to Vite core. [vite-plugin-pwa](https://vite-pwa-org.netlify.app/) is a great example of what can be achieved out of Vite core, and there are a lot of [well maintained plugins](https://github.com/vitejs/awesome-vite#plugins) to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.\n\n## Pushing the Modern Web\n\nVite provides opinionated features that pushes writing modern code. For example:\n\n- The source code can only be written in ESM, where non-ESM dependencies needs to be [pre-bundled as ESM](dep-pre-bundling) in order to work.\n- Web workers are encouraged to be written with the [`new Worker` syntax](features#web-workers) to follow modern standards.\n- Node.js modules cannot be used in the browser.\n\nWhen adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.\n\n## A Pragmatic Approach to Performance\n\nVite has been focused on performance since its [origins](why). Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like [esbuild](https://esbuild.github.io/) and [SWC](https://github.com/vitejs/vite-plugin-react-swc) to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into [Babel](https://babeljs.io/) to compile user code. And during build time Vite currently uses [Rollup](https://rollupjs.org/) where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.\n\n## Building Frameworks on top of Vite\n\nAlthough Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI frameworks. Its [JS API](api-javascript) allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for [SSR primitives](ssr), usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with [Backend frameworks](backend-integration) like [Ruby](https://vite-ruby.netlify.app/) and [Laravel](https://laravel.com/docs/10.x/vite).\n\n## An Active Ecosystem\n\nVite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci). It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join [Vite's Discord](https://chat.vitejs.dev) and get involved in the project too.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/philosophy](https://vitejs.dev/guide/philosophy)"
- name: 'Project Philosophy: A Pragmatic Approach to Performance'
  id: guide/philosophy#a-pragmatic-approach-to-performance
  summary: Vite has been focused on performance since its origins
  belongs_to: Project Philosophy
  description: |-
    ## A Pragmatic Approach to Performance

    Vite has been focused on performance since its [origins](why). Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like [esbuild](https://esbuild.github.io/) and [SWC](https://github.com/vitejs/vite-plugin-react-swc) to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into [Babel](https://babeljs.io/) to compile user code. And during build time Vite currently uses [Rollup](https://rollupjs.org/) where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.
- name: 'Project Philosophy: An Active Ecosystem'
  id: guide/philosophy#an-active-ecosystem
  summary: Vite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team
  belongs_to: Project Philosophy
  description: "## An Active Ecosystem\n\nVite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci). It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join [Vite's Discord](https://chat.vitejs.dev) and get involved in the project too.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/philosophy](https://vitejs.dev/guide/philosophy)"
- name: 'Project Philosophy: APIs'
  id: guide/philosophy
  summary: Vite doesn't intend to cover every use case for every user
  description: "# Project Philosophy\n\n## Lean Extendable Core\n\nVite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but [Vite core](https://github.com/vitejs/vite) must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to [Vite's rollup-based plugin system](api-plugin). Features that can be implemented as external plugins will generally not be added to Vite core. [vite-plugin-pwa](https://vite-pwa-org.netlify.app/) is a great example of what can be achieved out of Vite core, and there are a lot of [well maintained plugins](https://github.com/vitejs/awesome-vite#plugins) to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.\n\n## Pushing the Modern Web\n\nVite provides opinionated features that pushes writing modern code. For example:\n\n- The source code can only be written in ESM, where non-ESM dependencies needs to be [pre-bundled as ESM](dep-pre-bundling) in order to work.\n- Web workers are encouraged to be written with the [`new Worker` syntax](features#web-workers) to follow modern standards.\n- Node.js modules cannot be used in the browser.\n\nWhen adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.\n\n## A Pragmatic Approach to Performance\n\nVite has been focused on performance since its [origins](why). Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like [esbuild](https://esbuild.github.io/) and [SWC](https://github.com/vitejs/vite-plugin-react-swc) to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into [Babel](https://babeljs.io/) to compile user code. And during build time Vite currently uses [Rollup](https://rollupjs.org/) where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.\n\n## Building Frameworks on top of Vite\n\nAlthough Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI frameworks. Its [JS API](api-javascript) allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for [SSR primitives](ssr), usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with [Backend frameworks](backend-integration) like [Ruby](https://vite-ruby.netlify.app/) and [Laravel](https://laravel.com/docs/10.x/vite).\n\n## An Active Ecosystem\n\nVite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci). It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join [Vite's Discord](https://chat.vitejs.dev) and get involved in the project too.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/philosophy](https://vitejs.dev/guide/philosophy)"
- name: 'Project Philosophy: Building Frameworks on top of Vite'
  id: guide/philosophy#building-frameworks-on-top-of-vite
  summary: Although Vite can be used by users directly, it shines as a tool to create frameworks
  belongs_to: Project Philosophy
  description: |-
    ## Building Frameworks on top of Vite

    Although Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI frameworks. Its [JS API](api-javascript) allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for [SSR primitives](ssr), usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with [Backend frameworks](backend-integration) like [Ruby](https://vite-ruby.netlify.app/) and [Laravel](https://laravel.com/docs/10.x/vite).
- name: 'Project Philosophy: Guide'
  id: guide/philosophy
  summary: Vite doesn't intend to cover every use case for every user
  description: "# Project Philosophy\n\n## Lean Extendable Core\n\nVite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but [Vite core](https://github.com/vitejs/vite) must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to [Vite's rollup-based plugin system](api-plugin). Features that can be implemented as external plugins will generally not be added to Vite core. [vite-plugin-pwa](https://vite-pwa-org.netlify.app/) is a great example of what can be achieved out of Vite core, and there are a lot of [well maintained plugins](https://github.com/vitejs/awesome-vite#plugins) to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.\n\n## Pushing the Modern Web\n\nVite provides opinionated features that pushes writing modern code. For example:\n\n- The source code can only be written in ESM, where non-ESM dependencies needs to be [pre-bundled as ESM](dep-pre-bundling) in order to work.\n- Web workers are encouraged to be written with the [`new Worker` syntax](features#web-workers) to follow modern standards.\n- Node.js modules cannot be used in the browser.\n\nWhen adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.\n\n## A Pragmatic Approach to Performance\n\nVite has been focused on performance since its [origins](why). Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like [esbuild](https://esbuild.github.io/) and [SWC](https://github.com/vitejs/vite-plugin-react-swc) to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into [Babel](https://babeljs.io/) to compile user code. And during build time Vite currently uses [Rollup](https://rollupjs.org/) where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.\n\n## Building Frameworks on top of Vite\n\nAlthough Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI frameworks. Its [JS API](api-javascript) allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for [SSR primitives](ssr), usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with [Backend frameworks](backend-integration) like [Ruby](https://vite-ruby.netlify.app/) and [Laravel](https://laravel.com/docs/10.x/vite).\n\n## An Active Ecosystem\n\nVite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like [vite-ecosystem-ci](https://github.com/vitejs/vite-ecosystem-ci). It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join [Vite's Discord](https://chat.vitejs.dev) and get involved in the project too.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/philosophy](https://vitejs.dev/guide/philosophy)"
- name: 'Project Philosophy: Lean Extendable Core'
  id: guide/philosophy#lean-extendable-core
  summary: Vite doesn't intend to cover every use case for every user
  belongs_to: Project Philosophy
  description: |-
    ## Lean Extendable Core

    Vite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but [Vite core](https://github.com/vitejs/vite) must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to [Vite's rollup-based plugin system](api-plugin). Features that can be implemented as external plugins will generally not be added to Vite core. [vite-plugin-pwa](https://vite-pwa-org.netlify.app/) is a great example of what can be achieved out of Vite core, and there are a lot of [well maintained plugins](https://github.com/vitejs/awesome-vite#plugins) to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.
- name: 'Project Philosophy: Pushing the Modern Web'
  id: guide/philosophy#pushing-the-modern-web
  summary: Vite provides opinionated features that pushes writing modern code
  belongs_to: Project Philosophy
  description: |-
    ## Pushing the Modern Web

    Vite provides opinionated features that pushes writing modern code. For example:

    - The source code can only be written in ESM, where non-ESM dependencies needs to be [pre-bundled as ESM](dep-pre-bundling) in order to work.
    - Web workers are encouraged to be written with the [`new Worker` syntax](features#web-workers) to follow modern standards.
    - Node.js modules cannot be used in the browser.

    When adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.
- name: Releases
  id: releases
  summary: Vite releases follow Semantic Versioning
  description: "# Releases\n\nVite releases follow [Semantic Versioning](https://semver.org/). You can see the latest stable version of Vite in the [Vite npm package page](https://www.npmjs.com/package/vite).\n\nA full changelog of past releases is [available on GitHub](https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md).\n\n## Release Cycle\n\nVite does not have a fixed release cycle.\n\n- **Patch** releases are released as needed.\n- **Minor** releases always contain new features and are also released as needed. Minor releases always go through a beta pre-release phase.\n- **Major** releases generally align with [Node.js EOL schedule](https://endoflife.date/nodejs), and will be announced ahead of time. These releases will go through an early discussion phase, and both alpha and beta pre-release phases.\n\nThe previous Vite Major will keep receiving important fixes and security patches. After that, it would only get updates if there are security concerns. We recommend updating Vite regularly. Check out the [Migration Guides](guide/migration) when you update to each Major.\n\nThe Vite team partners with the main projects in the ecosystem to test new Vite versions before they are released through the [vite-ecosystem-ci project](https://github.com/vitejs/vite-ecosystem-ci). Most projects using Vite should be able to quickly offer support or migrate to new versions as soon as they are released.\n\n## Semantic Versioning Edge Cases\n\n### TypeScript Definitions\n\nWe may ship incompatible changes to TypeScript definitions between minor versions. This is because:\n\n- Sometimes TypeScript itself ships incompatible changes between minor versions, and we may have to adjust types to support newer versions of TypeScript.\n- Occasionally we may need to adopt features that are only available in a newer version of TypeScript, raising the minimum required version of TypeScript.\n- If you are using TypeScript, you can use a semver range that locks the current minor and manually upgrade when a new minor version of Vite is released.\n\n### esbuild\n\n[esbuild](https://esbuild.github.io/) is pre-1.0.0 and sometimes it has a breaking change we may need to include to have access to newer features and performance improvements. We may bump the esbuild's version in a Vite Minor.\n\n### Node.js non-LTS versions\n\nNon-LTS Node.js versions (odd-numbered) are not tested as part of Vite's CI, but they should still work before their [EOL](https://endoflife.date/nodejs).\n\n## Pre Releases\n\nMinor releases typically go through a non-fixed number of beta releases. Major releases will go through an alpha phase and a beta phase.\n\nPre-releases allow early adopters and maintainers from the Ecosystem to do integration and stability testing, and provide feedback. Do not use pre-releases in production. All pre-releases are considered unstable and may ship breaking changes in between. Always pin to exact versions when using pre-releases.\n\n## Deprecations\n\nWe periodically deprecate features that have been superseded by better alternatives in Minor releases. Deprecated features will continue to work with a type or logged warning. They will be removed in the next major release after entering deprecated status. The [Migration Guide](guide/migration) for each major will list these removals and document an upgrade path for them.\n\n## Experimental Features\n\nSome features are marked as experimental when released in a stable version of Vite. Experimental features allows us to gather real-world experience to influence their final design. The goal is to let users provide feedback by testing them in production. Experimental features themselves are considered unstable, and should only be used in a controlled manner. These features may change between Minors, so users must pin their Vite version when they rely on them. We will create [a GitHub discussion](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=is%3Aopen+label%3Aexperimental+category%3AFeedback) for each experimental feature.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/releases](https://vitejs.dev/releases)"
- name: 'Releases: Deprecations'
  id: releases#deprecations
  summary: We periodically deprecate features that have been superseded by better alternatives in Minor releases
  belongs_to: Releases
  description: |-
    ## Deprecations

    We periodically deprecate features that have been superseded by better alternatives in Minor releases. Deprecated features will continue to work with a type or logged warning. They will be removed in the next major release after entering deprecated status. The [Migration Guide](guide/migration) for each major will list these removals and document an upgrade path for them.
- name: 'Releases: esbuild'
  id: releases#esbuild
  summary: esbuild is pre-1.0.0 and sometimes it has a breaking change we may need to include to have access to newer features and performance improvements
  belongs_to: Releases
  description: |-
    ### esbuild

    [esbuild](https://esbuild.github.io/) is pre-1.0.0 and sometimes it has a breaking change we may need to include to have access to newer features and performance improvements. We may bump the esbuild's version in a Vite Minor.
- name: 'Releases: Experimental Features'
  id: releases#experimental-features
  summary: Some features are marked as experimental when released in a stable version of Vite
  belongs_to: Releases
  description: "## Experimental Features\n\nSome features are marked as experimental when released in a stable version of Vite. Experimental features allows us to gather real-world experience to influence their final design. The goal is to let users provide feedback by testing them in production. Experimental features themselves are considered unstable, and should only be used in a controlled manner. These features may change between Minors, so users must pin their Vite version when they rely on them. We will create [a GitHub discussion](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=is%3Aopen+label%3Aexperimental+category%3AFeedback) for each experimental feature.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/releases](https://vitejs.dev/releases)"
- name: 'Releases: Node.js non-LTS versions'
  id: releases#node-js-non-lts-versions
  summary: Non-LTS Node.js versions (odd-numbered) are not tested as part of Vite's CI, but they should still work before their EOL
  belongs_to: Releases
  description: |-
    ### Node.js non-LTS versions

    Non-LTS Node.js versions (odd-numbered) are not tested as part of Vite's CI, but they should still work before their [EOL](https://endoflife.date/nodejs).
- name: 'Releases: Pre Releases'
  id: releases#pre-releases
  summary: Minor releases typically go through a non-fixed number of beta releases
  belongs_to: Releases
  description: |-
    ## Pre Releases

    Minor releases typically go through a non-fixed number of beta releases. Major releases will go through an alpha phase and a beta phase.

    Pre-releases allow early adopters and maintainers from the Ecosystem to do integration and stability testing, and provide feedback. Do not use pre-releases in production. All pre-releases are considered unstable and may ship breaking changes in between. Always pin to exact versions when using pre-releases.
- name: 'Releases: Release Cycle'
  id: releases#release-cycle
  summary: Vite does not have a fixed release cycle
  belongs_to: Releases
  description: |-
    ## Release Cycle

    Vite does not have a fixed release cycle.

    - **Patch** releases are released as needed.
    - **Minor** releases always contain new features and are also released as needed. Minor releases always go through a beta pre-release phase.
    - **Major** releases generally align with [Node.js EOL schedule](https://endoflife.date/nodejs), and will be announced ahead of time. These releases will go through an early discussion phase, and both alpha and beta pre-release phases.

    The previous Vite Major will keep receiving important fixes and security patches. After that, it would only get updates if there are security concerns. We recommend updating Vite regularly. Check out the [Migration Guides](guide/migration) when you update to each Major.

    The Vite team partners with the main projects in the ecosystem to test new Vite versions before they are released through the [vite-ecosystem-ci project](https://github.com/vitejs/vite-ecosystem-ci). Most projects using Vite should be able to quickly offer support or migrate to new versions as soon as they are released.
- name: 'Releases: Semantic Versioning Edge Cases'
  id: releases#semantic-versioning-edge-cases
  summary: null
  belongs_to: Releases
  description: '## Semantic Versioning Edge Cases'
- name: 'Releases: TypeScript Definitions'
  id: releases#typescript-definitions
  summary: We may ship incompatible changes to TypeScript definitions between minor versions
  belongs_to: Releases
  description: |-
    ### TypeScript Definitions

    We may ship incompatible changes to TypeScript definitions between minor versions. This is because:

    - Sometimes TypeScript itself ships incompatible changes between minor versions, and we may have to adjust types to support newer versions of TypeScript.
    - Occasionally we may need to adopt features that are only available in a newer version of TypeScript, raising the minimum required version of TypeScript.
    - If you are using TypeScript, you can use a semver range that locks the current minor and manually upgrade when a new minor version of Vite is released.
- name: Server Options
  id: config/server-options
  summary: Specify which IP addresses the server should listen on
  description: "# Server Options\n\n## server.host\n\n- **Type:** `string | boolean`\n- **Default:** `'localhost'`\n\nSpecify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.\n\nThis can be set via the CLI using `--host 0.0.0.0` or `--host`.\n\n**NOTE**\n\nThere are cases when other servers might respond instead of Vite.\n\nThe first case is when `localhost` is used. Node.js under v17 reorders the result of DNS-resolved addresses by default. When accessing `localhost`, browsers use DNS to resolve the address and that address might differ from the address which Vite is listening to. Vite prints the resolved address when it differs.\n\nYou can set [`dns.setDefaultResultOrder('verbatim')`](https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order) to disable the reordering behavior. Vite will then print the address as `localhost`.\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport dns from 'node:dns'\n\ndns.setDefaultResultOrder('verbatim')\n\nexport default defineConfig({\n  // omit\n})\n```\n\nThe second case is when wildcard hosts (e.g. `0.0.0.0`) are used. This is because servers listening on non-wildcard hosts take priority over those listening on wildcard hosts.\n\n**Accessing the server on WSL2 from your LAN**\n\nWhen running Vite on WSL2, it is not sufficient to set `host: true` to access the server from your LAN. See [the WSL document](https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan) for more details.\n\n## server.port\n\n- **Type:** `number`\n- **Default:** `5173`\n\nSpecify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.\n\n## server.strictPort\n\n- **Type:** `boolean`\n\nSet to `true` to exit if port is already in use, instead of automatically trying the next available port.\n\n## server.https\n\n- **Type:** `https.ServerOptions`\n\nEnable TLS + HTTP/2. Note this downgrades to TLS only when the [`server.proxy` option](#server-proxy) is also used.\n\nThe value can also be an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.\n\nA valid certificate is needed. For a basic setup, you can add [@vitejs/plugin-basic-ssl](https://github.com/vitejs/vite-plugin-basic-ssl) to the project plugins, which will automatically create and cache a self-signed certificate. But we recommend creating your own certificates.\n\n## server.open\n\n- **Type:** `boolean | string`\n\nAutomatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).\n\n`BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    open: '/docs/index.html',\n  },\n})\n```\n\n## server.proxy\n\n- **Type:** `Record<string, string | ProxyOptions>`\n\nConfigure custom proxy rules for the dev server. Expects an object of `{ key: options }` pairs. Any requests that request path starts with that key will be proxied to that specified target. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.\n\nNote that if you are using non-relative [`base`](shared-options#base), you must prefix each key with that `base`.\n\nExtends [`http-proxy`](https://github.com/http-party/node-http-proxy#options). Additional options are [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/middlewares/proxy.ts#L13). Note that [unlike http-proxy](https://github.com/http-party/node-http-proxy/issues/1669), the `changeOrigin` option will change both host and origin headers to match the target.\n\nIn some cases, you might also want to configure the underlying dev server (e.g. to add custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app). In order to do that, you need to write your own [plugin](../guide/using-plugins) and use [configureServer](../guide/api-plugin#configureserver) function.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    proxy: {\n      // string shorthand: http://localhost:5173/foo -> http://localhost:4567/foo\n      '/foo': 'http://localhost:4567',\n      // with options: http://localhost:5173/api/bar-> http://jsonplaceholder.typicode.com/bar\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, ''),\n      },\n      // with RegEx: http://localhost:5173/fallback/ -> http://jsonplaceholder.typicode.com/\n      '^/fallback/.*': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/fallback/, ''),\n      },\n      // Using the proxy instance\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        configure: (proxy, options) => {\n          // proxy will be an instance of 'http-proxy'\n        },\n      },\n      // Proxying websockets or socket.io: ws://localhost:5173/socket.io -> ws://localhost:5174/socket.io\n      '/socket.io': {\n        target: 'ws://localhost:5174',\n        ws: true,\n      },\n    },\n  },\n})\n```\n\n## server.cors\n\n- **Type:** `boolean | CorsOptions`\n\nConfigure CORS for the dev server. This is enabled by default and allows any origin. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `false` to disable.\n\n## server.headers\n\n- **Type:** `OutgoingHttpHeaders`\n\nSpecify server response headers.\n\n## server.hmr\n\n- **Type:** `boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }`\n\nDisable or configure HMR connection (in cases where the HMR websocket must use a different address from the http server).\n\nSet `server.hmr.overlay` to `false` to disable the server error overlay.\n\n`protocol` sets the WebSocket protocol used for the HMR connection: `ws` (WebSocket) or `wss` (WebSocket Secure).\n\n`clientPort` is an advanced option that overrides the port only on the client side, allowing you to serve the websocket on a different port than the client code looks for it on.\n\nWhen `server.hmr.server` is defined, Vite will process the HMR connection requests through the provided server. If not in middleware mode, Vite will attempt to process HMR connection requests through the existing server. This can be helpful when using self-signed certificates or when you want to expose Vite over a network on a single port.\n\nCheck out [`vite-setup-catalogue`](https://github.com/sapphi-red/vite-setup-catalogue) for some examples.\n\n**NOTE**\n\nWith the default configuration, reverse proxies in front of Vite are expected to support proxying WebSocket. If the Vite HMR client fails to connect WebSocket, the client will fall back to connecting the WebSocket directly to the Vite HMR server bypassing the reverse proxies:\n\n``` javascript\nDirect websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.\n```\n\nThe error that appears in the Browser when the fallback happens can be ignored. To avoid the error by directly bypassing reverse proxies, you could either:\n\n- configure the reverse proxy to proxy WebSocket too\n- set [`server.strictPort = true`](#server-strictport) and set `server.hmr.clientPort` to the same value with `server.port`\n- set `server.hmr.port` to a different value from [`server.port`](#server-port)\n\n## server.warmup\n\n- **Type:** `{ clientFiles?: string[], ssrFiles?: string[] }`\n- **Related:** [Warm Up Frequently Used Files](../guide/performance#warm-up-frequently-used-files)\n\nWarm up files to transform and cache the results in advance. This improves the initial page load during server starts and prevents transform waterfalls.\n\n`clientFiles` are files that are used in the client only, while `ssrFiles` are files that are used in SSR only. They accept an array of file paths or [`fast-glob`](https://github.com/mrmlnc/fast-glob) patterns relative to the `root`.\n\nMake sure to only add files that are frequently used to not overload the Vite dev server on startup.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],\n      ssrFiles: ['./src/server/modules/*.js'],\n    },\n  },\n})\n```\n\n## server.watch\n\n- **Type:** `object | null`\n\nFile system watcher options to pass on to [chokidar](https://github.com/paulmillr/chokidar#api).\n\nThe Vite server watcher watches the `root` and skips the `.git/`, `node_modules/`, and Vite's `cacheDir` and `build.outDir` directories by default. When updating a watched file, Vite will apply HMR and update the page only if needed.\n\nIf set to `null`, no files will be watched. `server.watcher` will provide a compatible event emitter, but calling `add` or `unwatch` will have no effect.\n\n**Watching files in `node_modules`**\n\nIt's currently not possible to watch files and packages in `node_modules`. For further progress and workarounds, you can follow [issue \\#8619](https://github.com/vitejs/vite/issues/8619).\n\n**Using Vite on Windows Subsystem for Linux (WSL) 2**\n\nWhen running Vite on WSL2, file system watching does not work when a file is edited by Windows applications (non-WSL2 process). This is due to [a WSL2 limitation](https://github.com/microsoft/WSL/issues/4739). This also applies to running on Docker with a WSL2 backend.\n\nTo fix it, you could either:\n\n- **Recommended**: Use WSL2 applications to edit your files.\n  - It is also recommended to move the project folder outside of a Windows filesystem. Accessing Windows filesystem from WSL2 is slow. Removing that overhead will improve performance.\n- Set `{ usePolling: true }`.\n  - Note that [`usePolling` leads to high CPU utilization](https://github.com/paulmillr/chokidar#performance).\n\n## server.middlewareMode\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nCreate Vite server in middleware mode.\n\n- **Related:** [appType](shared-options#apptype), [SSR - Setting Up the Dev Server](../guide/ssr#setting-up-the-dev-server)\n\n- **Example:**\n\njs\n\n``` javascript\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom', // don't include Vite's default HTML handling middlewares\n  })\n  // Use vite's connect instance as middleware\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) => {\n    // Since `appType` is `'custom'`, should serve response here.\n    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares to handle\n    // HTML requests and 404s so user middlewares should be added\n    // before Vite's middlewares to take effect instead\n  })\n}\n\ncreateServer()\n```\n\n## server.fs.strict\n\n- **Type:** `boolean`\n- **Default:** `true` (enabled by default since Vite 2.7)\n\nRestrict serving files outside of workspace root.\n\n## server.fs.allow\n\n- **Type:** `string[]`\n\nRestrict files that could be served via `/@fs/`. When `server.fs.strict` is set to `true`, accessing files outside this directory list that aren't imported from an allowed file will result in a 403.\n\nBoth directories and files can be provided.\n\nVite will search for the root of the potential workspace and use it as default. A valid workspace met the following conditions, otherwise will fall back to the [project root](../guide/index#index-html-and-project-root).\n\n- contains `workspaces` field in `package.json`\n- contains one of the following file\n  - `lerna.json`\n  - `pnpm-workspace.yaml`\n\nAccepts a path to specify the custom workspace root. Could be a absolute path or a path relative to [project root](../guide/index#index-html-and-project-root). For example:\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    fs: {\n      // Allow serving files from one level up to the project root\n      allow: ['..'],\n    },\n  },\n})\n```\n\nWhen `server.fs.allow` is specified, the auto workspace root detection will be disabled. To extend the original behavior, a utility `searchForWorkspaceRoot` is exposed:\n\njs\n\n``` javascript\nimport { defineConfig, searchForWorkspaceRoot } from 'vite'\n\nexport default defineConfig({\n  server: {\n    fs: {\n      allow: [\n        // search up for workspace root\n        searchForWorkspaceRoot(process.cwd()),\n        // your custom rules\n        '/path/to/custom/allow_directory',\n        '/path/to/custom/allow_file.demo',\n      ],\n    },\n  },\n})\n```\n\n## server.fs.deny\n\n- **Type:** `string[]`\n- **Default:** `['.env', '.env.*', '*.{crt,pem}']`\n\nBlocklist for sensitive files being restricted to be served by Vite dev server. This will have higher priority than [`server.fs.allow`](#server-fs-allow). [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) are supported.\n\n## server.origin\n\n- **Type:** `string`\n\nDefines the origin of the generated asset URLs during development.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    origin: 'http://127.0.0.1:8080',\n  },\n})\n```\n\n## server.sourcemapIgnoreList\n\n- **Type:** `false | (sourcePath: string, sourcemapPath: string) => boolean`\n- **Default:** `(sourcePath) => sourcePath.includes('node_modules')`\n\nWhether or not to ignore source files in the server sourcemap, used to populate the [`x_google_ignoreList` source map extension](https://developer.chrome.com/articles/x-google-ignore-list/).\n\n`server.sourcemapIgnoreList` is the equivalent of [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) for the dev server. A difference between the two config options is that the rollup function is called with a relative path for `sourcePath` while `server.sourcemapIgnoreList` is called with an absolute path. During dev, most modules have the map and the source in the same folder, so the relative path for `sourcePath` is the file name itself. In these cases, absolute paths makes it convenient to be used instead.\n\nBy default, it excludes all paths containing `node_modules`. You can pass `false` to disable this behavior, or, for full control, a function that takes the source path and sourcemap path and returns whether to ignore the source path.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    // This is the default value, and will add all files with node_modules\n    // in their paths to the ignore list.\n    sourcemapIgnoreList(sourcePath, sourcemapPath) {\n      return sourcePath.includes('node_modules')\n    },\n  },\n})\n```\n\n**Note**\n\n[`server.sourcemapIgnoreList`](#server-sourcemapignorelist) and [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) need to be set independently. `server.sourcemapIgnoreList` is a server only config and doesn't get its default value from the defined rollup options.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/server-options](https://vitejs.dev/config/server-options)"
- name: 'Server Options: Config'
  id: config/server-options
  summary: Specify which IP addresses the server should listen on
  description: "# Server Options\n\n## server.host\n\n- **Type:** `string | boolean`\n- **Default:** `'localhost'`\n\nSpecify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.\n\nThis can be set via the CLI using `--host 0.0.0.0` or `--host`.\n\n**NOTE**\n\nThere are cases when other servers might respond instead of Vite.\n\nThe first case is when `localhost` is used. Node.js under v17 reorders the result of DNS-resolved addresses by default. When accessing `localhost`, browsers use DNS to resolve the address and that address might differ from the address which Vite is listening to. Vite prints the resolved address when it differs.\n\nYou can set [`dns.setDefaultResultOrder('verbatim')`](https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order) to disable the reordering behavior. Vite will then print the address as `localhost`.\n\njs\n\n``` javascript\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport dns from 'node:dns'\n\ndns.setDefaultResultOrder('verbatim')\n\nexport default defineConfig({\n  // omit\n})\n```\n\nThe second case is when wildcard hosts (e.g. `0.0.0.0`) are used. This is because servers listening on non-wildcard hosts take priority over those listening on wildcard hosts.\n\n**Accessing the server on WSL2 from your LAN**\n\nWhen running Vite on WSL2, it is not sufficient to set `host: true` to access the server from your LAN. See [the WSL document](https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan) for more details.\n\n## server.port\n\n- **Type:** `number`\n- **Default:** `5173`\n\nSpecify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.\n\n## server.strictPort\n\n- **Type:** `boolean`\n\nSet to `true` to exit if port is already in use, instead of automatically trying the next available port.\n\n## server.https\n\n- **Type:** `https.ServerOptions`\n\nEnable TLS + HTTP/2. Note this downgrades to TLS only when the [`server.proxy` option](#server-proxy) is also used.\n\nThe value can also be an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.\n\nA valid certificate is needed. For a basic setup, you can add [@vitejs/plugin-basic-ssl](https://github.com/vitejs/vite-plugin-basic-ssl) to the project plugins, which will automatically create and cache a self-signed certificate. But we recommend creating your own certificates.\n\n## server.open\n\n- **Type:** `boolean | string`\n\nAutomatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).\n\n`BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    open: '/docs/index.html',\n  },\n})\n```\n\n## server.proxy\n\n- **Type:** `Record<string, string | ProxyOptions>`\n\nConfigure custom proxy rules for the dev server. Expects an object of `{ key: options }` pairs. Any requests that request path starts with that key will be proxied to that specified target. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.\n\nNote that if you are using non-relative [`base`](shared-options#base), you must prefix each key with that `base`.\n\nExtends [`http-proxy`](https://github.com/http-party/node-http-proxy#options). Additional options are [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/middlewares/proxy.ts#L13). Note that [unlike http-proxy](https://github.com/http-party/node-http-proxy/issues/1669), the `changeOrigin` option will change both host and origin headers to match the target.\n\nIn some cases, you might also want to configure the underlying dev server (e.g. to add custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app). In order to do that, you need to write your own [plugin](../guide/using-plugins) and use [configureServer](../guide/api-plugin#configureserver) function.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    proxy: {\n      // string shorthand: http://localhost:5173/foo -> http://localhost:4567/foo\n      '/foo': 'http://localhost:4567',\n      // with options: http://localhost:5173/api/bar-> http://jsonplaceholder.typicode.com/bar\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, ''),\n      },\n      // with RegEx: http://localhost:5173/fallback/ -> http://jsonplaceholder.typicode.com/\n      '^/fallback/.*': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/fallback/, ''),\n      },\n      // Using the proxy instance\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        configure: (proxy, options) => {\n          // proxy will be an instance of 'http-proxy'\n        },\n      },\n      // Proxying websockets or socket.io: ws://localhost:5173/socket.io -> ws://localhost:5174/socket.io\n      '/socket.io': {\n        target: 'ws://localhost:5174',\n        ws: true,\n      },\n    },\n  },\n})\n```\n\n## server.cors\n\n- **Type:** `boolean | CorsOptions`\n\nConfigure CORS for the dev server. This is enabled by default and allows any origin. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `false` to disable.\n\n## server.headers\n\n- **Type:** `OutgoingHttpHeaders`\n\nSpecify server response headers.\n\n## server.hmr\n\n- **Type:** `boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }`\n\nDisable or configure HMR connection (in cases where the HMR websocket must use a different address from the http server).\n\nSet `server.hmr.overlay` to `false` to disable the server error overlay.\n\n`protocol` sets the WebSocket protocol used for the HMR connection: `ws` (WebSocket) or `wss` (WebSocket Secure).\n\n`clientPort` is an advanced option that overrides the port only on the client side, allowing you to serve the websocket on a different port than the client code looks for it on.\n\nWhen `server.hmr.server` is defined, Vite will process the HMR connection requests through the provided server. If not in middleware mode, Vite will attempt to process HMR connection requests through the existing server. This can be helpful when using self-signed certificates or when you want to expose Vite over a network on a single port.\n\nCheck out [`vite-setup-catalogue`](https://github.com/sapphi-red/vite-setup-catalogue) for some examples.\n\n**NOTE**\n\nWith the default configuration, reverse proxies in front of Vite are expected to support proxying WebSocket. If the Vite HMR client fails to connect WebSocket, the client will fall back to connecting the WebSocket directly to the Vite HMR server bypassing the reverse proxies:\n\n``` javascript\nDirect websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.\n```\n\nThe error that appears in the Browser when the fallback happens can be ignored. To avoid the error by directly bypassing reverse proxies, you could either:\n\n- configure the reverse proxy to proxy WebSocket too\n- set [`server.strictPort = true`](#server-strictport) and set `server.hmr.clientPort` to the same value with `server.port`\n- set `server.hmr.port` to a different value from [`server.port`](#server-port)\n\n## server.warmup\n\n- **Type:** `{ clientFiles?: string[], ssrFiles?: string[] }`\n- **Related:** [Warm Up Frequently Used Files](../guide/performance#warm-up-frequently-used-files)\n\nWarm up files to transform and cache the results in advance. This improves the initial page load during server starts and prevents transform waterfalls.\n\n`clientFiles` are files that are used in the client only, while `ssrFiles` are files that are used in SSR only. They accept an array of file paths or [`fast-glob`](https://github.com/mrmlnc/fast-glob) patterns relative to the `root`.\n\nMake sure to only add files that are frequently used to not overload the Vite dev server on startup.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],\n      ssrFiles: ['./src/server/modules/*.js'],\n    },\n  },\n})\n```\n\n## server.watch\n\n- **Type:** `object | null`\n\nFile system watcher options to pass on to [chokidar](https://github.com/paulmillr/chokidar#api).\n\nThe Vite server watcher watches the `root` and skips the `.git/`, `node_modules/`, and Vite's `cacheDir` and `build.outDir` directories by default. When updating a watched file, Vite will apply HMR and update the page only if needed.\n\nIf set to `null`, no files will be watched. `server.watcher` will provide a compatible event emitter, but calling `add` or `unwatch` will have no effect.\n\n**Watching files in `node_modules`**\n\nIt's currently not possible to watch files and packages in `node_modules`. For further progress and workarounds, you can follow [issue \\#8619](https://github.com/vitejs/vite/issues/8619).\n\n**Using Vite on Windows Subsystem for Linux (WSL) 2**\n\nWhen running Vite on WSL2, file system watching does not work when a file is edited by Windows applications (non-WSL2 process). This is due to [a WSL2 limitation](https://github.com/microsoft/WSL/issues/4739). This also applies to running on Docker with a WSL2 backend.\n\nTo fix it, you could either:\n\n- **Recommended**: Use WSL2 applications to edit your files.\n  - It is also recommended to move the project folder outside of a Windows filesystem. Accessing Windows filesystem from WSL2 is slow. Removing that overhead will improve performance.\n- Set `{ usePolling: true }`.\n  - Note that [`usePolling` leads to high CPU utilization](https://github.com/paulmillr/chokidar#performance).\n\n## server.middlewareMode\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nCreate Vite server in middleware mode.\n\n- **Related:** [appType](shared-options#apptype), [SSR - Setting Up the Dev Server](../guide/ssr#setting-up-the-dev-server)\n\n- **Example:**\n\njs\n\n``` javascript\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom', // don't include Vite's default HTML handling middlewares\n  })\n  // Use vite's connect instance as middleware\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) => {\n    // Since `appType` is `'custom'`, should serve response here.\n    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares to handle\n    // HTML requests and 404s so user middlewares should be added\n    // before Vite's middlewares to take effect instead\n  })\n}\n\ncreateServer()\n```\n\n## server.fs.strict\n\n- **Type:** `boolean`\n- **Default:** `true` (enabled by default since Vite 2.7)\n\nRestrict serving files outside of workspace root.\n\n## server.fs.allow\n\n- **Type:** `string[]`\n\nRestrict files that could be served via `/@fs/`. When `server.fs.strict` is set to `true`, accessing files outside this directory list that aren't imported from an allowed file will result in a 403.\n\nBoth directories and files can be provided.\n\nVite will search for the root of the potential workspace and use it as default. A valid workspace met the following conditions, otherwise will fall back to the [project root](../guide/index#index-html-and-project-root).\n\n- contains `workspaces` field in `package.json`\n- contains one of the following file\n  - `lerna.json`\n  - `pnpm-workspace.yaml`\n\nAccepts a path to specify the custom workspace root. Could be a absolute path or a path relative to [project root](../guide/index#index-html-and-project-root). For example:\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    fs: {\n      // Allow serving files from one level up to the project root\n      allow: ['..'],\n    },\n  },\n})\n```\n\nWhen `server.fs.allow` is specified, the auto workspace root detection will be disabled. To extend the original behavior, a utility `searchForWorkspaceRoot` is exposed:\n\njs\n\n``` javascript\nimport { defineConfig, searchForWorkspaceRoot } from 'vite'\n\nexport default defineConfig({\n  server: {\n    fs: {\n      allow: [\n        // search up for workspace root\n        searchForWorkspaceRoot(process.cwd()),\n        // your custom rules\n        '/path/to/custom/allow_directory',\n        '/path/to/custom/allow_file.demo',\n      ],\n    },\n  },\n})\n```\n\n## server.fs.deny\n\n- **Type:** `string[]`\n- **Default:** `['.env', '.env.*', '*.{crt,pem}']`\n\nBlocklist for sensitive files being restricted to be served by Vite dev server. This will have higher priority than [`server.fs.allow`](#server-fs-allow). [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) are supported.\n\n## server.origin\n\n- **Type:** `string`\n\nDefines the origin of the generated asset URLs during development.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    origin: 'http://127.0.0.1:8080',\n  },\n})\n```\n\n## server.sourcemapIgnoreList\n\n- **Type:** `false | (sourcePath: string, sourcemapPath: string) => boolean`\n- **Default:** `(sourcePath) => sourcePath.includes('node_modules')`\n\nWhether or not to ignore source files in the server sourcemap, used to populate the [`x_google_ignoreList` source map extension](https://developer.chrome.com/articles/x-google-ignore-list/).\n\n`server.sourcemapIgnoreList` is the equivalent of [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) for the dev server. A difference between the two config options is that the rollup function is called with a relative path for `sourcePath` while `server.sourcemapIgnoreList` is called with an absolute path. During dev, most modules have the map and the source in the same folder, so the relative path for `sourcePath` is the file name itself. In these cases, absolute paths makes it convenient to be used instead.\n\nBy default, it excludes all paths containing `node_modules`. You can pass `false` to disable this behavior, or, for full control, a function that takes the source path and sourcemap path and returns whether to ignore the source path.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    // This is the default value, and will add all files with node_modules\n    // in their paths to the ignore list.\n    sourcemapIgnoreList(sourcePath, sourcemapPath) {\n      return sourcePath.includes('node_modules')\n    },\n  },\n})\n```\n\n**Note**\n\n[`server.sourcemapIgnoreList`](#server-sourcemapignorelist) and [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) need to be set independently. `server.sourcemapIgnoreList` is a server only config and doesn't get its default value from the defined rollup options.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/server-options](https://vitejs.dev/config/server-options)"
- name: 'Server Options: server.cors'
  id: config/server-options#server-cors
  summary: Configure CORS for the dev server
  belongs_to: Server Options
  description: |-
    ## server.cors

    - **Type:** `boolean | CorsOptions`

    Configure CORS for the dev server. This is enabled by default and allows any origin. Pass an [options object](https://github.com/expressjs/cors#configuration-options) to fine tune the behavior or `false` to disable.
- name: 'Server Options: server.fs.allow'
  id: config/server-options#server-fs-allow
  summary: Restrict files that could be served via /@fs/. When server.fs.strict is set to true, accessing files outside this directory list that aren't imported from an allowed file will result in a 403
  belongs_to: Server Options
  description: |-
    ## server.fs.allow

    - **Type:** `string[]`

    Restrict files that could be served via `/@fs/`. When `server.fs.strict` is set to `true`, accessing files outside this directory list that aren't imported from an allowed file will result in a 403.

    Both directories and files can be provided.

    Vite will search for the root of the potential workspace and use it as default. A valid workspace met the following conditions, otherwise will fall back to the [project root](../guide/index#index-html-and-project-root).

    - contains `workspaces` field in `package.json`
    - contains one of the following file
      - `lerna.json`
      - `pnpm-workspace.yaml`

    Accepts a path to specify the custom workspace root. Could be a absolute path or a path relative to [project root](../guide/index#index-html-and-project-root). For example:

    js

    ``` javascript
    export default defineConfig({
      server: {
        fs: {
          // Allow serving files from one level up to the project root
          allow: ['..'],
        },
      },
    })
    ```

    When `server.fs.allow` is specified, the auto workspace root detection will be disabled. To extend the original behavior, a utility `searchForWorkspaceRoot` is exposed:

    js

    ``` javascript
    import { defineConfig, searchForWorkspaceRoot } from 'vite'

    export default defineConfig({
      server: {
        fs: {
          allow: [
            // search up for workspace root
            searchForWorkspaceRoot(process.cwd()),
            // your custom rules
            '/path/to/custom/allow_directory',
            '/path/to/custom/allow_file.demo',
          ],
        },
      },
    })
    ```
- name: 'Server Options: server.fs.deny'
  id: config/server-options#server-fs-deny
  summary: Blocklist for sensitive files being restricted to be served by Vite dev server
  belongs_to: Server Options
  description: |-
    ## server.fs.deny

    - **Type:** `string[]`
    - **Default:** `['.env', '.env.*', '*.{crt,pem}']`

    Blocklist for sensitive files being restricted to be served by Vite dev server. This will have higher priority than [`server.fs.allow`](#server-fs-allow). [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) are supported.
- name: 'Server Options: server.fs.strict'
  id: config/server-options#server-fs-strict
  summary: Restrict serving files outside of workspace root
  belongs_to: Server Options
  description: |-
    ## server.fs.strict

    - **Type:** `boolean`
    - **Default:**`true` (enabled by default since Vite 2.7)

    Restrict serving files outside of workspace root.
- name: 'Server Options: server.headers'
  id: config/server-options#server-headers
  summary: Specify server response headers
  belongs_to: Server Options
  description: |-
    ## server.headers

    - **Type:** `OutgoingHttpHeaders`

    Specify server response headers.
- name: 'Server Options: server.hmr'
  id: config/server-options#server-hmr
  summary: Set server.hmr.overlay to false to disable the server error overlay
  belongs_to: Server Options
  description: |-
    ## server.hmr

    - **Type:** `boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }`

    Disable or configure HMR connection (in cases where the HMR websocket must use a different address from the http server).

    Set `server.hmr.overlay` to `false` to disable the server error overlay.

    `protocol` sets the WebSocket protocol used for the HMR connection: `ws` (WebSocket) or `wss` (WebSocket Secure).

    `clientPort` is an advanced option that overrides the port only on the client side, allowing you to serve the websocket on a different port than the client code looks for it on.

    When `server.hmr.server` is defined, Vite will process the HMR connection requests through the provided server. If not in middleware mode, Vite will attempt to process HMR connection requests through the existing server. This can be helpful when using self-signed certificates or when you want to expose Vite over a network on a single port.

    Check out [`vite-setup-catalogue`](https://github.com/sapphi-red/vite-setup-catalogue) for some examples.

    **NOTE**

    With the default configuration, reverse proxies in front of Vite are expected to support proxying WebSocket. If the Vite HMR client fails to connect WebSocket, the client will fall back to connecting the WebSocket directly to the Vite HMR server bypassing the reverse proxies:

    ``` javascript
    Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.
    ```

    The error that appears in the Browser when the fallback happens can be ignored. To avoid the error by directly bypassing reverse proxies, you could either:

    - configure the reverse proxy to proxy WebSocket too
    - set [`server.strictPort = true`](#server-strictport) and set `server.hmr.clientPort` to the same value with `server.port`
    - set `server.hmr.port` to a different value from [`server.port`](#server-port)
- name: 'Server Options: server.host'
  id: config/server-options#server-host
  summary: Specify which IP addresses the server should listen on
  belongs_to: Server Options
  description: |-
    ## server.host

    - **Type:** `string | boolean`
    - **Default:** `'localhost'`

    Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses.

    This can be set via the CLI using `--host 0.0.0.0` or `--host`.

    **NOTE**

    There are cases when other servers might respond instead of Vite.

    The first case is when `localhost` is used. Node.js under v17 reorders the result of DNS-resolved addresses by default. When accessing `localhost`, browsers use DNS to resolve the address and that address might differ from the address which Vite is listening to. Vite prints the resolved address when it differs.

    You can set [`dns.setDefaultResultOrder('verbatim')`](https://nodejs.org/api/dns.html#dns_dns_setdefaultresultorder_order) to disable the reordering behavior. Vite will then print the address as `localhost`.

    js

    ``` javascript
    // vite.config.js
    import { defineConfig } from 'vite'
    import dns from 'node:dns'

    dns.setDefaultResultOrder('verbatim')

    export default defineConfig({
      // omit
    })
    ```

    The second case is when wildcard hosts (e.g. `0.0.0.0`) are used. This is because servers listening on non-wildcard hosts take priority over those listening on wildcard hosts.

    **Accessing the server on WSL2 from your LAN**

    When running Vite on WSL2, it is not sufficient to set `host: true` to access the server from your LAN. See [the WSL document](https://learn.microsoft.com/en-us/windows/wsl/networking#accessing-a-wsl-2-distribution-from-your-local-area-network-lan) for more details.
- name: 'Server Options: server.https'
  id: config/server-options#server-https
  summary: Enable TLS + HTTP/2
  belongs_to: Server Options
  description: |-
    ## server.https

    - **Type:** `https.ServerOptions`

    Enable TLS + HTTP/2. Note this downgrades to TLS only when the [`server.proxy` option](#server-proxy) is also used.

    The value can also be an [options object](https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener) passed to `https.createServer()`.

    A valid certificate is needed. For a basic setup, you can add [@vitejs/plugin-basic-ssl](https://github.com/vitejs/vite-plugin-basic-ssl) to the project plugins, which will automatically create and cache a self-signed certificate. But we recommend creating your own certificates.
- name: 'Server Options: server.middlewareMode'
  id: config/server-options#server-middlewaremode
  summary: Create Vite server in middleware mode
  belongs_to: Server Options
  description: |-
    ## server.middlewareMode

    - **Type:** `boolean`
    - **Default:** `false`

    Create Vite server in middleware mode.

    - **Related:**[appType](shared-options#apptype), [SSR - Setting Up the Dev Server](../guide/ssr#setting-up-the-dev-server)

    - **Example:**

    js

    ``` javascript
    import express from 'express'
    import { createServer as createViteServer } from 'vite'

    async function createServer() {
      const app = express()

      // Create Vite server in middleware mode
      const vite = await createViteServer({
        server: { middlewareMode: true },
        appType: 'custom', // don't include Vite's default HTML handling middlewares
      })
      // Use vite's connect instance as middleware
      app.use(vite.middlewares)

      app.use('*', async (req, res) => {
        // Since `appType` is `'custom'`, should serve response here.
        // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares to handle
        // HTML requests and 404s so user middlewares should be added
        // before Vite's middlewares to take effect instead
      })
    }

    createServer()
    ```
- name: 'Server Options: server.open'
  id: config/server-options#server-open
  summary: Automatically open the app in the browser on server start
  belongs_to: Server Options
  description: |-
    ## server.open

    - **Type:** `boolean | string`

    Automatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env `process.env.BROWSER` (e.g. `firefox`). You can also set `process.env.BROWSER_ARGS` to pass additional arguments (e.g. `--incognito`).

    `BROWSER` and `BROWSER_ARGS` are also special environment variables you can set in the `.env` file to configure it. See [the `open` package](https://github.com/sindresorhus/open#app) for more details.

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      server: {
        open: '/docs/index.html',
      },
    })
    ```
- name: 'Server Options: server.origin'
  id: config/server-options#server-origin
  summary: Defines the origin of the generated asset URLs during development
  belongs_to: Server Options
  description: |-
    ## server.origin

    - **Type:** `string`

    Defines the origin of the generated asset URLs during development.

    js

    ``` javascript
    export default defineConfig({
      server: {
        origin: 'http://127.0.0.1:8080',
      },
    })
    ```
- name: 'Server Options: server.port'
  id: config/server-options#server-port
  summary: Specify server port
  belongs_to: Server Options
  description: |-
    ## server.port

    - **Type:** `number`
    - **Default:** `5173`

    Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.
- name: 'Server Options: server.proxy'
  id: config/server-options#server-proxy
  summary: Configure custom proxy rules for the dev server
  belongs_to: Server Options
  description: |-
    ## server.proxy

    - **Type:** `Record<string, string | ProxyOptions>`

    Configure custom proxy rules for the dev server. Expects an object of `{ key: options }` pairs. Any requests that request path starts with that key will be proxied to that specified target. If the key starts with `^`, it will be interpreted as a `RegExp`. The `configure` option can be used to access the proxy instance.

    Note that if you are using non-relative [`base`](shared-options#base), you must prefix each key with that `base`.

    Extends [`http-proxy`](https://github.com/http-party/node-http-proxy#options). Additional options are [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/middlewares/proxy.ts#L13). Note that [unlike http-proxy](https://github.com/http-party/node-http-proxy/issues/1669), the `changeOrigin` option will change both host and origin headers to match the target.

    In some cases, you might also want to configure the underlying dev server (e.g. to add custom middlewares to the internal [connect](https://github.com/senchalabs/connect) app). In order to do that, you need to write your own [plugin](../guide/using-plugins) and use [configureServer](../guide/api-plugin#configureserver) function.

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      server: {
        proxy: {
          // string shorthand: http://localhost:5173/foo -> http://localhost:4567/foo
          '/foo': 'http://localhost:4567',
          // with options: http://localhost:5173/api/bar-> http://jsonplaceholder.typicode.com/bar
          '/api': {
            target: 'http://jsonplaceholder.typicode.com',
            changeOrigin: true,
            rewrite: (path) => path.replace(/^\/api/, ''),
          },
          // with RegEx: http://localhost:5173/fallback/ -> http://jsonplaceholder.typicode.com/
          '^/fallback/.*': {
            target: 'http://jsonplaceholder.typicode.com',
            changeOrigin: true,
            rewrite: (path) => path.replace(/^\/fallback/, ''),
          },
          // Using the proxy instance
          '/api': {
            target: 'http://jsonplaceholder.typicode.com',
            changeOrigin: true,
            configure: (proxy, options) => {
              // proxy will be an instance of 'http-proxy'
            },
          },
          // Proxying websockets or socket.io: ws://localhost:5173/socket.io -> ws://localhost:5174/socket.io
          '/socket.io': {
            target: 'ws://localhost:5174',
            ws: true,
          },
        },
      },
    })
    ```
- name: 'Server Options: server.sourcemapIgnoreList'
  id: config/server-options#server-sourcemapignorelist
  summary: Whether or not to ignore source files in the server sourcemap, used to populate the x_google_ignoreList source map extension
  belongs_to: Server Options
  description: "## server.sourcemapIgnoreList\n\n- **Type:** `false | (sourcePath: string, sourcemapPath: string) => boolean`\n- **Default:** `(sourcePath) => sourcePath.includes('node_modules')`\n\nWhether or not to ignore source files in the server sourcemap, used to populate the [`x_google_ignoreList` source map extension](https://developer.chrome.com/articles/x-google-ignore-list/).\n\n`server.sourcemapIgnoreList` is the equivalent of [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) for the dev server. A difference between the two config options is that the rollup function is called with a relative path for `sourcePath` while `server.sourcemapIgnoreList` is called with an absolute path. During dev, most modules have the map and the source in the same folder, so the relative path for `sourcePath` is the file name itself. In these cases, absolute paths makes it convenient to be used instead.\n\nBy default, it excludes all paths containing `node_modules`. You can pass `false` to disable this behavior, or, for full control, a function that takes the source path and sourcemap path and returns whether to ignore the source path.\n\njs\n\n``` javascript\nexport default defineConfig({\n  server: {\n    // This is the default value, and will add all files with node_modules\n    // in their paths to the ignore list.\n    sourcemapIgnoreList(sourcePath, sourcemapPath) {\n      return sourcePath.includes('node_modules')\n    },\n  },\n})\n```\n\n**Note**\n\n[`server.sourcemapIgnoreList`](#server-sourcemapignorelist) and [`build.rollupOptions.output.sourcemapIgnoreList`](https://rollupjs.org/configuration-options/#output-sourcemapignorelist) need to be set independently. `server.sourcemapIgnoreList` is a server only config and doesn't get its default value from the defined rollup options.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/server-options](https://vitejs.dev/config/server-options)"
- name: 'Server Options: server.strictPort'
  id: config/server-options#server-strictport
  summary: Set to true to exit if port is already in use, instead of automatically trying the next available port
  belongs_to: Server Options
  description: |-
    ## server.strictPort

    - **Type:** `boolean`

    Set to `true` to exit if port is already in use, instead of automatically trying the next available port.
- name: 'Server Options: server.warmup'
  id: config/server-options#server-warmup
  summary: Warm up files to transform and cache the results in advance
  belongs_to: Server Options
  description: |-
    ## server.warmup

    - **Type:** `{ clientFiles?: string[], ssrFiles?: string[] }`
    - **Related:** [Warm Up Frequently Used Files](../guide/performance#warm-up-frequently-used-files)

    Warm up files to transform and cache the results in advance. This improves the initial page load during server starts and prevents transform waterfalls.

    `clientFiles` are files that are used in the client only, while `ssrFiles` are files that are used in SSR only. They accept an array of file paths or [`fast-glob`](https://github.com/mrmlnc/fast-glob) patterns relative to the `root`.

    Make sure to only add files that are frequently used to not overload the Vite dev server on startup.

    js

    ``` javascript
    export default defineConfig({
      server: {
        warmup: {
          clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],
          ssrFiles: ['./src/server/modules/*.js'],
        },
      },
    })
    ```
- name: 'Server Options: server.watch'
  id: config/server-options#server-watch
  summary: File system watcher options to pass on to chokidar
  belongs_to: Server Options
  description: |-
    ## server.watch

    - **Type:** `object | null`

    File system watcher options to pass on to [chokidar](https://github.com/paulmillr/chokidar#api).

    The Vite server watcher watches the `root` and skips the `.git/`, `node_modules/`, and Vite's `cacheDir` and `build.outDir` directories by default. When updating a watched file, Vite will apply HMR and update the page only if needed.

    If set to `null`, no files will be watched. `server.watcher` will provide a compatible event emitter, but calling `add` or `unwatch` will have no effect.

    **Watching files in `node_modules`**

    It's currently not possible to watch files and packages in `node_modules`. For further progress and workarounds, you can follow [issue \#8619](https://github.com/vitejs/vite/issues/8619).

    **Using Vite on Windows Subsystem for Linux (WSL) 2**

    When running Vite on WSL2, file system watching does not work when a file is edited by Windows applications (non-WSL2 process). This is due to [a WSL2 limitation](https://github.com/microsoft/WSL/issues/4739). This also applies to running on Docker with a WSL2 backend.

    To fix it, you could either:

    - **Recommended**: Use WSL2 applications to edit your files.
      - It is also recommended to move the project folder outside of a Windows filesystem. Accessing Windows filesystem from WSL2 is slow. Removing that overhead will improve performance.
    - Set `{ usePolling: true }`.
      - Note that [`usePolling` leads to high CPU utilization](https://github.com/paulmillr/chokidar#performance).
- name: Server-Side Rendering
  id: guide/ssr
  summary: SSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client
  description: "# Server-Side Rendering\n\n**Note**\n\nSSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](backend-integration) instead.\n\nThe following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.\n\n**Low-level API**\n\nThis is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first. That said, many applications are successfully built directly on top of Vite's native low-level API.\n\nCurrently, Vite is working on an improved SSR API with the [Environment API](https://github.com/vitejs/vite/discussions/16358). Check out the link for more details.\n\n**Help**\n\nIf you have questions, the community is usually helpful at [Vite Discord's \\#ssr channel](https://discord.gg/PkbxgzPhJv).\n\n## Example Projects\n\nVite provides built-in support for server-side rendering (SSR). [`create-vite-extra`](https://github.com/bluwy/create-vite-extra) contains example SSR setups you can use as references for this guide:\n\n- [Vanilla](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla)\n- [Vue](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue)\n- [React](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react)\n- [Preact](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact)\n- [Svelte](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte)\n- [Solid](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid)\n\nYou can also scaffold these projects locally by [running `create-vite`](index#scaffolding-your-first-vite-project) and choose `Others > create-vite-extra` under the framework option.\n\n## Source Structure\n\nA typical SSR application will have the following source file structure:\n\n``` javascript\n- index.html\n- server.js # main application server\n- src/\n  - main.js          # exports env-agnostic (universal) app code\n  - entry-client.js  # mounts the app to a DOM element\n  - entry-server.js  # renders the app using the framework's SSR API\n```\n\nThe `index.html` will need to reference `entry-client.js` and include a placeholder where the server-rendered markup should be injected:\n\nhtml\n\n``` javascript\n<div id=\"app\"><!--ssr-outlet--></div>\n<script type=\"module\" src=\"/src/entry-client.js\"></script>\n```\n\nYou can use any placeholder you prefer instead of `<!--ssr-outlet-->`, as long as it can be precisely replaced.\n\n## Conditional Logic\n\nIf you need to perform conditional logic based on SSR vs. client, you can use\n\njs\n\n``` javascript\nif (import.meta.env.SSR) {\n  // ... server only logic\n}\n```\n\nThis is statically replaced during build so it will allow tree-shaking of unused branches.\n\n## Setting Up the Dev Server\n\nWhen building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with [express](https://expressjs.com/):\n\n**server.js**\n\njs\n\n``` javascript\nimport fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode and configure the app type as\n  // 'custom', disabling Vite's own HTML serving logic so parent server\n  // can take control\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom'\n  })\n\n  // Use vite's connect instance as middleware. If you use your own\n  // express router (express.Router()), you should use router.use\n  // When the server restarts (for example after the user modifies\n  // vite.config.js), `vite.middlewares` is still going to be the same\n  // reference (with a new internal stack of Vite and plugin-injected\n  // middlewares). The following is valid even after restarts.\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) => {\n    // serve index.html - we will tackle this next\n  })\n\n  app.listen(5173)\n}\n\ncreateServer()\n```\n\nHere `vite` is an instance of [ViteDevServer](api-javascript#vitedevserver). `vite.middlewares` is a [Connect](https://github.com/senchalabs/connect) instance which can be used as a middleware in any connect-compatible Node.js framework.\n\nThe next step is implementing the `*` handler to serve server-rendered HTML:\n\njs\n\n``` javascript\napp.use('*', async (req, res, next) => {\n  const url = req.originalUrl\n\n  try {\n    // 1. Read index.html\n    let template = fs.readFileSync(\n      path.resolve(__dirname, 'index.html'),\n      'utf-8',\n    )\n\n    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n    //    and also applies HTML transforms from Vite plugins, e.g. global\n    //    preambles from @vitejs/plugin-react\n    template = await vite.transformIndexHtml(url, template)\n\n    // 3. Load the server entry. ssrLoadModule automatically transforms\n    //    ESM source code to be usable in Node.js! There is no bundling\n    //    required, and provides efficient invalidation similar to HMR.\n    const { render } = await vite.ssrLoadModule('/src/entry-server.js')\n\n    // 4. render the app HTML. This assumes entry-server.js's exported\n    //     `render` function calls appropriate framework SSR APIs,\n    //    e.g. ReactDOMServer.renderToString()\n    const appHtml = await render(url)\n\n    // 5. Inject the app-rendered HTML into the template.\n    const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n\n    // 6. Send the rendered HTML back.\n    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n  } catch (e) {\n    // If an error is caught, let Vite fix the stack trace so it maps back\n    // to your actual source code.\n    vite.ssrFixStacktrace(e)\n    next(e)\n  }\n})\n```\n\nThe `dev` script in `package.json` should also be changed to use the server script instead:\n\ndiff\n\n``` javascript\n\"scripts\": {\n-   \"dev\": \"vite\"\n+   \"dev\": \"node server\"\n  }\n```\n\n## Building for Production\n\nTo ship an SSR project for production, we need to:\n\n1.  Produce a client build as normal;\n2.  Produce an SSR build, which can be directly loaded via `import()` so that we don't have to go through Vite's `ssrLoadModule`;\n\nOur scripts in `package.json` will look like this:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"dev\": \"node server\",\n    \"build:client\": \"vite build --outDir dist/client\",\n    \"build:server\": \"vite build --outDir dist/server --ssr src/entry-server.js\"\n  }\n}\n```\n\nNote the `--ssr` flag which indicates this is an SSR build. It should also specify the SSR entry.\n\nThen, in `server.js` we need to add some production specific logic by checking `process.env.NODE_ENV`:\n\n- Instead of reading the root `index.html`, use the `dist/client/index.html` as the template, since it contains the correct asset links to the client build.\n\n- Instead of `await vite.ssrLoadModule('/src/entry-server.js')`, use `import('./dist/server/entry-server.js')` (this file is the result of the SSR build).\n\n- Move the creation and all usage of the `vite` dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from `dist/client`.\n\nRefer to the [example projects](#example-projects) for a working setup.\n\n## Generating Preload Directives\n\n`vite build` supports the `--ssrManifest` flag which will generate `.vite/ssr-manifest.json` in build output directory:\n\ndiff\n\n``` javascript\n- \"build:client\": \"vite build --outDir dist/client\",\n+ \"build:client\": \"vite build --outDir dist/client --ssrManifest\",\n```\n\nThe above script will now generate `dist/client/.vite/ssr-manifest.json` for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.\n\nTo leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.\n\n`@vitejs/plugin-vue` supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:\n\njs\n\n``` javascript\n// src/entry-server.js\nconst ctx = {}\nconst html = await vueServerRenderer.renderToString(app, ctx)\n// ctx.modules is now a Set of module IDs that were used during the render\n```\n\nIn the production branch of `server.js` we need to read and pass the manifest to the `render` function exported by `src/entry-server.js`. This would provide us with enough information to render preload directives for files used by async routes! See [demo source](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js) for a full example. You can also use this information for [103 Early Hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).\n\n## Pre-Rendering / SSG\n\nIf the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See [demo pre-render script](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js) for working example.\n\n## SSR Externals\n\nDependencies are \"externalized\" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.\n\nIf a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to [`ssr.noExternal`](../config/ssr-options#ssr-noexternal).\n\nFor linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to [`ssr.external`](../config/ssr-options#ssr-external).\n\n**Working with Aliases**\n\nIf you have configured aliases that redirect one package to another, you may want to alias the actual `node_modules` packages instead to make it work for SSR externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.\n\n## SSR-specific Plugin Logic\n\nSome frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional `ssr` property in the `options` object of the following plugin hooks:\n\n- `resolveId`\n- `load`\n- `transform`\n\n**Example:**\n\njs\n\n``` javascript\nexport function mySSRPlugin() {\n  return {\n    name: 'my-ssr',\n    transform(code, id, options) {\n      if (options?.ssr) {\n        // perform ssr-specific transform...\n      }\n    },\n  }\n}\n```\n\nThe options object in `load` and `transform` is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.\n\n**Note**\n\nBefore Vite 2.7, this was informed to plugin hooks with a positional `ssr` param instead of using the `options` object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.\n\n## SSR Target\n\nThe default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the `ssr.target` set to `'webworker'`.\n\n## SSR Bundle\n\nIn some cases like `webworker` runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting `ssr.noExternal` to `true`. This will do two things:\n\n- Treat all dependencies as `noExternal`\n- Throw an error if any Node.js built-ins are imported\n\n## SSR Resolve Conditions\n\nBy default package entry resolution will use the conditions set in [`resolve.conditions`](../config/shared-options#resolve-conditions) for the SSR build. You can use [`ssr.resolve.conditions`](../config/ssr-options#ssr-resolve-conditions) and [`ssr.resolve.externalConditions`](../config/ssr-options#ssr-resolve-externalconditions) to customize this behavior.\n\n## Vite CLI\n\nThe CLI commands `$ vite dev` and `$ vite preview` can also be used for SSR apps. You can add your SSR middlewares to the development server with [`configureServer`](api-plugin#configureserver) and to the preview server with [`configurePreviewServer`](api-plugin#configurepreviewserver).\n\n**Note**\n\nUse a post hook so that your SSR middleware runs *after* Vite's middlewares.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)"
- name: 'Server-Side Rendering: APIs'
  id: guide/ssr
  summary: SSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client
  description: "# Server-Side Rendering\n\n**Note**\n\nSSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](backend-integration) instead.\n\nThe following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.\n\n**Low-level API**\n\nThis is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first. That said, many applications are successfully built directly on top of Vite's native low-level API.\n\nCurrently, Vite is working on an improved SSR API with the [Environment API](https://github.com/vitejs/vite/discussions/16358). Check out the link for more details.\n\n**Help**\n\nIf you have questions, the community is usually helpful at [Vite Discord's \\#ssr channel](https://discord.gg/PkbxgzPhJv).\n\n## Example Projects\n\nVite provides built-in support for server-side rendering (SSR). [`create-vite-extra`](https://github.com/bluwy/create-vite-extra) contains example SSR setups you can use as references for this guide:\n\n- [Vanilla](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla)\n- [Vue](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue)\n- [React](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react)\n- [Preact](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact)\n- [Svelte](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte)\n- [Solid](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid)\n\nYou can also scaffold these projects locally by [running `create-vite`](index#scaffolding-your-first-vite-project) and choose `Others > create-vite-extra` under the framework option.\n\n## Source Structure\n\nA typical SSR application will have the following source file structure:\n\n``` javascript\n- index.html\n- server.js # main application server\n- src/\n  - main.js          # exports env-agnostic (universal) app code\n  - entry-client.js  # mounts the app to a DOM element\n  - entry-server.js  # renders the app using the framework's SSR API\n```\n\nThe `index.html` will need to reference `entry-client.js` and include a placeholder where the server-rendered markup should be injected:\n\nhtml\n\n``` javascript\n<div id=\"app\"><!--ssr-outlet--></div>\n<script type=\"module\" src=\"/src/entry-client.js\"></script>\n```\n\nYou can use any placeholder you prefer instead of `<!--ssr-outlet-->`, as long as it can be precisely replaced.\n\n## Conditional Logic\n\nIf you need to perform conditional logic based on SSR vs. client, you can use\n\njs\n\n``` javascript\nif (import.meta.env.SSR) {\n  // ... server only logic\n}\n```\n\nThis is statically replaced during build so it will allow tree-shaking of unused branches.\n\n## Setting Up the Dev Server\n\nWhen building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with [express](https://expressjs.com/):\n\n**server.js**\n\njs\n\n``` javascript\nimport fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode and configure the app type as\n  // 'custom', disabling Vite's own HTML serving logic so parent server\n  // can take control\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom'\n  })\n\n  // Use vite's connect instance as middleware. If you use your own\n  // express router (express.Router()), you should use router.use\n  // When the server restarts (for example after the user modifies\n  // vite.config.js), `vite.middlewares` is still going to be the same\n  // reference (with a new internal stack of Vite and plugin-injected\n  // middlewares). The following is valid even after restarts.\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) => {\n    // serve index.html - we will tackle this next\n  })\n\n  app.listen(5173)\n}\n\ncreateServer()\n```\n\nHere `vite` is an instance of [ViteDevServer](api-javascript#vitedevserver). `vite.middlewares` is a [Connect](https://github.com/senchalabs/connect) instance which can be used as a middleware in any connect-compatible Node.js framework.\n\nThe next step is implementing the `*` handler to serve server-rendered HTML:\n\njs\n\n``` javascript\napp.use('*', async (req, res, next) => {\n  const url = req.originalUrl\n\n  try {\n    // 1. Read index.html\n    let template = fs.readFileSync(\n      path.resolve(__dirname, 'index.html'),\n      'utf-8',\n    )\n\n    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n    //    and also applies HTML transforms from Vite plugins, e.g. global\n    //    preambles from @vitejs/plugin-react\n    template = await vite.transformIndexHtml(url, template)\n\n    // 3. Load the server entry. ssrLoadModule automatically transforms\n    //    ESM source code to be usable in Node.js! There is no bundling\n    //    required, and provides efficient invalidation similar to HMR.\n    const { render } = await vite.ssrLoadModule('/src/entry-server.js')\n\n    // 4. render the app HTML. This assumes entry-server.js's exported\n    //     `render` function calls appropriate framework SSR APIs,\n    //    e.g. ReactDOMServer.renderToString()\n    const appHtml = await render(url)\n\n    // 5. Inject the app-rendered HTML into the template.\n    const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n\n    // 6. Send the rendered HTML back.\n    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n  } catch (e) {\n    // If an error is caught, let Vite fix the stack trace so it maps back\n    // to your actual source code.\n    vite.ssrFixStacktrace(e)\n    next(e)\n  }\n})\n```\n\nThe `dev` script in `package.json` should also be changed to use the server script instead:\n\ndiff\n\n``` javascript\n\"scripts\": {\n-   \"dev\": \"vite\"\n+   \"dev\": \"node server\"\n  }\n```\n\n## Building for Production\n\nTo ship an SSR project for production, we need to:\n\n1.  Produce a client build as normal;\n2.  Produce an SSR build, which can be directly loaded via `import()` so that we don't have to go through Vite's `ssrLoadModule`;\n\nOur scripts in `package.json` will look like this:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"dev\": \"node server\",\n    \"build:client\": \"vite build --outDir dist/client\",\n    \"build:server\": \"vite build --outDir dist/server --ssr src/entry-server.js\"\n  }\n}\n```\n\nNote the `--ssr` flag which indicates this is an SSR build. It should also specify the SSR entry.\n\nThen, in `server.js` we need to add some production specific logic by checking `process.env.NODE_ENV`:\n\n- Instead of reading the root `index.html`, use the `dist/client/index.html` as the template, since it contains the correct asset links to the client build.\n\n- Instead of `await vite.ssrLoadModule('/src/entry-server.js')`, use `import('./dist/server/entry-server.js')` (this file is the result of the SSR build).\n\n- Move the creation and all usage of the `vite` dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from `dist/client`.\n\nRefer to the [example projects](#example-projects) for a working setup.\n\n## Generating Preload Directives\n\n`vite build` supports the `--ssrManifest` flag which will generate `.vite/ssr-manifest.json` in build output directory:\n\ndiff\n\n``` javascript\n- \"build:client\": \"vite build --outDir dist/client\",\n+ \"build:client\": \"vite build --outDir dist/client --ssrManifest\",\n```\n\nThe above script will now generate `dist/client/.vite/ssr-manifest.json` for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.\n\nTo leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.\n\n`@vitejs/plugin-vue` supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:\n\njs\n\n``` javascript\n// src/entry-server.js\nconst ctx = {}\nconst html = await vueServerRenderer.renderToString(app, ctx)\n// ctx.modules is now a Set of module IDs that were used during the render\n```\n\nIn the production branch of `server.js` we need to read and pass the manifest to the `render` function exported by `src/entry-server.js`. This would provide us with enough information to render preload directives for files used by async routes! See [demo source](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js) for a full example. You can also use this information for [103 Early Hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).\n\n## Pre-Rendering / SSG\n\nIf the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See [demo pre-render script](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js) for working example.\n\n## SSR Externals\n\nDependencies are \"externalized\" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.\n\nIf a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to [`ssr.noExternal`](../config/ssr-options#ssr-noexternal).\n\nFor linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to [`ssr.external`](../config/ssr-options#ssr-external).\n\n**Working with Aliases**\n\nIf you have configured aliases that redirect one package to another, you may want to alias the actual `node_modules` packages instead to make it work for SSR externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.\n\n## SSR-specific Plugin Logic\n\nSome frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional `ssr` property in the `options` object of the following plugin hooks:\n\n- `resolveId`\n- `load`\n- `transform`\n\n**Example:**\n\njs\n\n``` javascript\nexport function mySSRPlugin() {\n  return {\n    name: 'my-ssr',\n    transform(code, id, options) {\n      if (options?.ssr) {\n        // perform ssr-specific transform...\n      }\n    },\n  }\n}\n```\n\nThe options object in `load` and `transform` is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.\n\n**Note**\n\nBefore Vite 2.7, this was informed to plugin hooks with a positional `ssr` param instead of using the `options` object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.\n\n## SSR Target\n\nThe default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the `ssr.target` set to `'webworker'`.\n\n## SSR Bundle\n\nIn some cases like `webworker` runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting `ssr.noExternal` to `true`. This will do two things:\n\n- Treat all dependencies as `noExternal`\n- Throw an error if any Node.js built-ins are imported\n\n## SSR Resolve Conditions\n\nBy default package entry resolution will use the conditions set in [`resolve.conditions`](../config/shared-options#resolve-conditions) for the SSR build. You can use [`ssr.resolve.conditions`](../config/ssr-options#ssr-resolve-conditions) and [`ssr.resolve.externalConditions`](../config/ssr-options#ssr-resolve-externalconditions) to customize this behavior.\n\n## Vite CLI\n\nThe CLI commands `$ vite dev` and `$ vite preview` can also be used for SSR apps. You can add your SSR middlewares to the development server with [`configureServer`](api-plugin#configureserver) and to the preview server with [`configurePreviewServer`](api-plugin#configurepreviewserver).\n\n**Note**\n\nUse a post hook so that your SSR middleware runs *after* Vite's middlewares.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)"
- name: 'Server-Side Rendering: Building for Production'
  id: guide/ssr#building-for-production
  summary: Note the --ssr flag which indicates this is an SSR build
  belongs_to: Server-Side Rendering
  description: |-
    ## Building for Production

    To ship an SSR project for production, we need to:

    1.  Produce a client build as normal;
    2.  Produce an SSR build, which can be directly loaded via `import()` so that we don't have to go through Vite's `ssrLoadModule`;

    Our scripts in `package.json` will look like this:

    json

    ``` javascript
    {
      "scripts": {
        "dev": "node server",
        "build:client": "vite build --outDir dist/client",
        "build:server": "vite build --outDir dist/server --ssr src/entry-server.js"
      }
    }
    ```

    Note the `--ssr` flag which indicates this is an SSR build. It should also specify the SSR entry.

    Then, in `server.js` we need to add some production specific logic by checking `process.env.NODE_ENV`:

    - Instead of reading the root `index.html`, use the `dist/client/index.html` as the template, since it contains the correct asset links to the client build.

    - Instead of `await vite.ssrLoadModule('/src/entry-server.js')`, use `import('./dist/server/entry-server.js')` (this file is the result of the SSR build).

    - Move the creation and all usage of the `vite` dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from `dist/client`.

    Refer to the [example projects](#example-projects) for a working setup.
- name: 'Server-Side Rendering: Conditional Logic'
  id: guide/ssr#conditional-logic
  summary: If you need to perform conditional logic based on SSR vs
  belongs_to: Server-Side Rendering
  description: |-
    ## Conditional Logic

    If you need to perform conditional logic based on SSR vs. client, you can use

    js

    ``` javascript
    if (import.meta.env.SSR) {
      // ... server only logic
    }
    ```

    This is statically replaced during build so it will allow tree-shaking of unused branches.
- name: 'Server-Side Rendering: Example Projects'
  id: guide/ssr#example-projects
  summary: You can also scaffold these projects locally by running create-vite and choose Others > create-vite-extra under the framework option
  belongs_to: Server-Side Rendering
  description: |-
    ## Example Projects

    Vite provides built-in support for server-side rendering (SSR). [`create-vite-extra`](https://github.com/bluwy/create-vite-extra) contains example SSR setups you can use as references for this guide:

    - [Vanilla](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla)
    - [Vue](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue)
    - [React](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react)
    - [Preact](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact)
    - [Svelte](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte)
    - [Solid](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid)

    You can also scaffold these projects locally by [running `create-vite`](index#scaffolding-your-first-vite-project) and choose `Others > create-vite-extra` under the framework option.
- name: 'Server-Side Rendering: Generating Preload Directives'
  id: guide/ssr#generating-preload-directives
  summary: The above script will now generate dist/client/.vite/ssr-manifest.json for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files
  belongs_to: Server-Side Rendering
  description: |-
    ## Generating Preload Directives

    `vite build` supports the `--ssrManifest` flag which will generate `.vite/ssr-manifest.json` in build output directory:

    diff

    ``` javascript
    - "build:client": "vite build --outDir dist/client",
    + "build:client": "vite build --outDir dist/client --ssrManifest",
    ```

    The above script will now generate `dist/client/.vite/ssr-manifest.json` for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.

    To leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.

    `@vitejs/plugin-vue` supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:

    js

    ``` javascript
    // src/entry-server.js
    const ctx = {}
    const html = await vueServerRenderer.renderToString(app, ctx)
    // ctx.modules is now a Set of module IDs that were used during the render
    ```

    In the production branch of `server.js` we need to read and pass the manifest to the `render` function exported by `src/entry-server.js`. This would provide us with enough information to render preload directives for files used by async routes! See [demo source](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js) for a full example. You can also use this information for [103 Early Hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).
- name: 'Server-Side Rendering: Guide'
  id: guide/ssr
  summary: SSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client
  description: "# Server-Side Rendering\n\n**Note**\n\nSSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the [Backend Integration guide](backend-integration) instead.\n\nThe following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.\n\n**Low-level API**\n\nThis is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first. That said, many applications are successfully built directly on top of Vite's native low-level API.\n\nCurrently, Vite is working on an improved SSR API with the [Environment API](https://github.com/vitejs/vite/discussions/16358). Check out the link for more details.\n\n**Help**\n\nIf you have questions, the community is usually helpful at [Vite Discord's \\#ssr channel](https://discord.gg/PkbxgzPhJv).\n\n## Example Projects\n\nVite provides built-in support for server-side rendering (SSR). [`create-vite-extra`](https://github.com/bluwy/create-vite-extra) contains example SSR setups you can use as references for this guide:\n\n- [Vanilla](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vanilla)\n- [Vue](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-vue)\n- [React](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-react)\n- [Preact](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-preact)\n- [Svelte](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-svelte)\n- [Solid](https://github.com/bluwy/create-vite-extra/tree/master/template-ssr-solid)\n\nYou can also scaffold these projects locally by [running `create-vite`](index#scaffolding-your-first-vite-project) and choose `Others > create-vite-extra` under the framework option.\n\n## Source Structure\n\nA typical SSR application will have the following source file structure:\n\n``` javascript\n- index.html\n- server.js # main application server\n- src/\n  - main.js          # exports env-agnostic (universal) app code\n  - entry-client.js  # mounts the app to a DOM element\n  - entry-server.js  # renders the app using the framework's SSR API\n```\n\nThe `index.html` will need to reference `entry-client.js` and include a placeholder where the server-rendered markup should be injected:\n\nhtml\n\n``` javascript\n<div id=\"app\"><!--ssr-outlet--></div>\n<script type=\"module\" src=\"/src/entry-client.js\"></script>\n```\n\nYou can use any placeholder you prefer instead of `<!--ssr-outlet-->`, as long as it can be precisely replaced.\n\n## Conditional Logic\n\nIf you need to perform conditional logic based on SSR vs. client, you can use\n\njs\n\n``` javascript\nif (import.meta.env.SSR) {\n  // ... server only logic\n}\n```\n\nThis is statically replaced during build so it will allow tree-shaking of unused branches.\n\n## Setting Up the Dev Server\n\nWhen building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with [express](https://expressjs.com/):\n\n**server.js**\n\njs\n\n``` javascript\nimport fs from 'node:fs'\nimport path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode and configure the app type as\n  // 'custom', disabling Vite's own HTML serving logic so parent server\n  // can take control\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom'\n  })\n\n  // Use vite's connect instance as middleware. If you use your own\n  // express router (express.Router()), you should use router.use\n  // When the server restarts (for example after the user modifies\n  // vite.config.js), `vite.middlewares` is still going to be the same\n  // reference (with a new internal stack of Vite and plugin-injected\n  // middlewares). The following is valid even after restarts.\n  app.use(vite.middlewares)\n\n  app.use('*', async (req, res) => {\n    // serve index.html - we will tackle this next\n  })\n\n  app.listen(5173)\n}\n\ncreateServer()\n```\n\nHere `vite` is an instance of [ViteDevServer](api-javascript#vitedevserver). `vite.middlewares` is a [Connect](https://github.com/senchalabs/connect) instance which can be used as a middleware in any connect-compatible Node.js framework.\n\nThe next step is implementing the `*` handler to serve server-rendered HTML:\n\njs\n\n``` javascript\napp.use('*', async (req, res, next) => {\n  const url = req.originalUrl\n\n  try {\n    // 1. Read index.html\n    let template = fs.readFileSync(\n      path.resolve(__dirname, 'index.html'),\n      'utf-8',\n    )\n\n    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n    //    and also applies HTML transforms from Vite plugins, e.g. global\n    //    preambles from @vitejs/plugin-react\n    template = await vite.transformIndexHtml(url, template)\n\n    // 3. Load the server entry. ssrLoadModule automatically transforms\n    //    ESM source code to be usable in Node.js! There is no bundling\n    //    required, and provides efficient invalidation similar to HMR.\n    const { render } = await vite.ssrLoadModule('/src/entry-server.js')\n\n    // 4. render the app HTML. This assumes entry-server.js's exported\n    //     `render` function calls appropriate framework SSR APIs,\n    //    e.g. ReactDOMServer.renderToString()\n    const appHtml = await render(url)\n\n    // 5. Inject the app-rendered HTML into the template.\n    const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n\n    // 6. Send the rendered HTML back.\n    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n  } catch (e) {\n    // If an error is caught, let Vite fix the stack trace so it maps back\n    // to your actual source code.\n    vite.ssrFixStacktrace(e)\n    next(e)\n  }\n})\n```\n\nThe `dev` script in `package.json` should also be changed to use the server script instead:\n\ndiff\n\n``` javascript\n\"scripts\": {\n-   \"dev\": \"vite\"\n+   \"dev\": \"node server\"\n  }\n```\n\n## Building for Production\n\nTo ship an SSR project for production, we need to:\n\n1.  Produce a client build as normal;\n2.  Produce an SSR build, which can be directly loaded via `import()` so that we don't have to go through Vite's `ssrLoadModule`;\n\nOur scripts in `package.json` will look like this:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"dev\": \"node server\",\n    \"build:client\": \"vite build --outDir dist/client\",\n    \"build:server\": \"vite build --outDir dist/server --ssr src/entry-server.js\"\n  }\n}\n```\n\nNote the `--ssr` flag which indicates this is an SSR build. It should also specify the SSR entry.\n\nThen, in `server.js` we need to add some production specific logic by checking `process.env.NODE_ENV`:\n\n- Instead of reading the root `index.html`, use the `dist/client/index.html` as the template, since it contains the correct asset links to the client build.\n\n- Instead of `await vite.ssrLoadModule('/src/entry-server.js')`, use `import('./dist/server/entry-server.js')` (this file is the result of the SSR build).\n\n- Move the creation and all usage of the `vite` dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from `dist/client`.\n\nRefer to the [example projects](#example-projects) for a working setup.\n\n## Generating Preload Directives\n\n`vite build` supports the `--ssrManifest` flag which will generate `.vite/ssr-manifest.json` in build output directory:\n\ndiff\n\n``` javascript\n- \"build:client\": \"vite build --outDir dist/client\",\n+ \"build:client\": \"vite build --outDir dist/client --ssrManifest\",\n```\n\nThe above script will now generate `dist/client/.vite/ssr-manifest.json` for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.\n\nTo leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.\n\n`@vitejs/plugin-vue` supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:\n\njs\n\n``` javascript\n// src/entry-server.js\nconst ctx = {}\nconst html = await vueServerRenderer.renderToString(app, ctx)\n// ctx.modules is now a Set of module IDs that were used during the render\n```\n\nIn the production branch of `server.js` we need to read and pass the manifest to the `render` function exported by `src/entry-server.js`. This would provide us with enough information to render preload directives for files used by async routes! See [demo source](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/src/entry-server.js) for a full example. You can also use this information for [103 Early Hints](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).\n\n## Pre-Rendering / SSG\n\nIf the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See [demo pre-render script](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js) for working example.\n\n## SSR Externals\n\nDependencies are \"externalized\" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.\n\nIf a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to [`ssr.noExternal`](../config/ssr-options#ssr-noexternal).\n\nFor linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to [`ssr.external`](../config/ssr-options#ssr-external).\n\n**Working with Aliases**\n\nIf you have configured aliases that redirect one package to another, you may want to alias the actual `node_modules` packages instead to make it work for SSR externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.\n\n## SSR-specific Plugin Logic\n\nSome frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional `ssr` property in the `options` object of the following plugin hooks:\n\n- `resolveId`\n- `load`\n- `transform`\n\n**Example:**\n\njs\n\n``` javascript\nexport function mySSRPlugin() {\n  return {\n    name: 'my-ssr',\n    transform(code, id, options) {\n      if (options?.ssr) {\n        // perform ssr-specific transform...\n      }\n    },\n  }\n}\n```\n\nThe options object in `load` and `transform` is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.\n\n**Note**\n\nBefore Vite 2.7, this was informed to plugin hooks with a positional `ssr` param instead of using the `options` object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.\n\n## SSR Target\n\nThe default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the `ssr.target` set to `'webworker'`.\n\n## SSR Bundle\n\nIn some cases like `webworker` runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting `ssr.noExternal` to `true`. This will do two things:\n\n- Treat all dependencies as `noExternal`\n- Throw an error if any Node.js built-ins are imported\n\n## SSR Resolve Conditions\n\nBy default package entry resolution will use the conditions set in [`resolve.conditions`](../config/shared-options#resolve-conditions) for the SSR build. You can use [`ssr.resolve.conditions`](../config/ssr-options#ssr-resolve-conditions) and [`ssr.resolve.externalConditions`](../config/ssr-options#ssr-resolve-externalconditions) to customize this behavior.\n\n## Vite CLI\n\nThe CLI commands `$ vite dev` and `$ vite preview` can also be used for SSR apps. You can add your SSR middlewares to the development server with [`configureServer`](api-plugin#configureserver) and to the preview server with [`configurePreviewServer`](api-plugin#configurepreviewserver).\n\n**Note**\n\nUse a post hook so that your SSR middleware runs *after* Vite's middlewares.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)"
- name: 'Server-Side Rendering: Pre-Rendering / SSG'
  id: guide/ssr#pre-rendering-ssg
  summary: If the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR
  belongs_to: Server-Side Rendering
  description: |-
    ## Pre-Rendering / SSG

    If the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See [demo pre-render script](https://github.com/vitejs/vite-plugin-vue/blob/main/playground/ssr-vue/prerender.js) for working example.
- name: 'Server-Side Rendering: Setting Up the Dev Server'
  id: guide/ssr#setting-up-the-dev-server
  summary: When building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment
  belongs_to: Server-Side Rendering
  description: |-
    ## Setting Up the Dev Server

    When building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with [express](https://expressjs.com/):

    **server.js**

    js

    ``` javascript
    import fs from 'node:fs'
    import path from 'node:path'
    import { fileURLToPath } from 'node:url'
    import express from 'express'
    import { createServer as createViteServer } from 'vite'

    const __dirname = path.dirname(fileURLToPath(import.meta.url))

    async function createServer() {
      const app = express()

      // Create Vite server in middleware mode and configure the app type as
      // 'custom', disabling Vite's own HTML serving logic so parent server
      // can take control
      const vite = await createViteServer({
        server: { middlewareMode: true },
        appType: 'custom'
      })

      // Use vite's connect instance as middleware. If you use your own
      // express router (express.Router()), you should use router.use
      // When the server restarts (for example after the user modifies
      // vite.config.js), `vite.middlewares` is still going to be the same
      // reference (with a new internal stack of Vite and plugin-injected
      // middlewares). The following is valid even after restarts.
      app.use(vite.middlewares)

      app.use('*', async (req, res) => {
        // serve index.html - we will tackle this next
      })

      app.listen(5173)
    }

    createServer()
    ```

    Here `vite` is an instance of [ViteDevServer](api-javascript#vitedevserver). `vite.middlewares` is a [Connect](https://github.com/senchalabs/connect) instance which can be used as a middleware in any connect-compatible Node.js framework.

    The next step is implementing the `*` handler to serve server-rendered HTML:

    js

    ``` javascript
    app.use('*', async (req, res, next) => {
      const url = req.originalUrl

      try {
        // 1. Read index.html
        let template = fs.readFileSync(
          path.resolve(__dirname, 'index.html'),
          'utf-8',
        )

        // 2. Apply Vite HTML transforms. This injects the Vite HMR client,
        //    and also applies HTML transforms from Vite plugins, e.g. global
        //    preambles from @vitejs/plugin-react
        template = await vite.transformIndexHtml(url, template)

        // 3. Load the server entry. ssrLoadModule automatically transforms
        //    ESM source code to be usable in Node.js! There is no bundling
        //    required, and provides efficient invalidation similar to HMR.
        const { render } = await vite.ssrLoadModule('/src/entry-server.js')

        // 4. render the app HTML. This assumes entry-server.js's exported
        //     `render` function calls appropriate framework SSR APIs,
        //    e.g. ReactDOMServer.renderToString()
        const appHtml = await render(url)

        // 5. Inject the app-rendered HTML into the template.
        const html = template.replace(`<!--ssr-outlet-->`, appHtml)

        // 6. Send the rendered HTML back.
        res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
      } catch (e) {
        // If an error is caught, let Vite fix the stack trace so it maps back
        // to your actual source code.
        vite.ssrFixStacktrace(e)
        next(e)
      }
    })
    ```

    The `dev` script in `package.json` should also be changed to use the server script instead:

    diff

    ``` javascript
    "scripts": {
    -   "dev": "vite"
    +   "dev": "node server"
      }
    ```
- name: 'Server-Side Rendering: Source Structure'
  id: guide/ssr#source-structure
  summary: You can use any placeholder you prefer instead of <!--ssr-outlet-->, as long as it can be precisely replaced
  belongs_to: Server-Side Rendering
  description: |-
    ## Source Structure

    A typical SSR application will have the following source file structure:

    ``` javascript
    - index.html
    - server.js # main application server
    - src/
      - main.js          # exports env-agnostic (universal) app code
      - entry-client.js  # mounts the app to a DOM element
      - entry-server.js  # renders the app using the framework's SSR API
    ```

    The `index.html` will need to reference `entry-client.js` and include a placeholder where the server-rendered markup should be injected:

    html

    ``` javascript
    <div id="app"><!--ssr-outlet--></div>
    <script type="module" src="/src/entry-client.js"></script>
    ```

    You can use any placeholder you prefer instead of `<!--ssr-outlet-->`, as long as it can be precisely replaced.
- name: 'Server-Side Rendering: SSR Bundle'
  id: guide/ssr#ssr-bundle
  summary: In some cases like webworker runtimes, you might want to bundle your SSR build into a single JavaScript file
  belongs_to: Server-Side Rendering
  description: |-
    ## SSR Bundle

    In some cases like `webworker` runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting `ssr.noExternal` to `true`. This will do two things:

    - Treat all dependencies as `noExternal`
    - Throw an error if any Node.js built-ins are imported
- name: 'Server-Side Rendering: SSR Externals'
  id: guide/ssr#ssr-externals
  summary: Dependencies are "externalized" from Vite's SSR transform module system by default when running SSR
  belongs_to: Server-Side Rendering
  description: |-
    ## SSR Externals

    Dependencies are "externalized" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.

    If a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to [`ssr.noExternal`](../config/ssr-options#ssr-noexternal).

    For linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to [`ssr.external`](../config/ssr-options#ssr-external).

    **Working with Aliases**

    If you have configured aliases that redirect one package to another, you may want to alias the actual `node_modules` packages instead to make it work for SSR externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.
- name: 'Server-Side Rendering: SSR Resolve Conditions'
  id: guide/ssr#ssr-resolve-conditions
  summary: By default package entry resolution will use the conditions set in resolve.conditions for the SSR build
  belongs_to: Server-Side Rendering
  description: |-
    ## SSR Resolve Conditions

    By default package entry resolution will use the conditions set in [`resolve.conditions`](../config/shared-options#resolve-conditions) for the SSR build. You can use [`ssr.resolve.conditions`](../config/ssr-options#ssr-resolve-conditions) and [`ssr.resolve.externalConditions`](../config/ssr-options#ssr-resolve-externalconditions) to customize this behavior.
- name: 'Server-Side Rendering: SSR Target'
  id: guide/ssr#ssr-target
  summary: The default target for the SSR build is a node environment, but you can also run the server in a Web Worker
  belongs_to: Server-Side Rendering
  description: |-
    ## SSR Target

    The default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the `ssr.target` set to `'webworker'`.
- name: 'Server-Side Rendering: SSR-specific Plugin Logic'
  id: guide/ssr#ssr-specific-plugin-logic
  summary: Some frameworks such as Vue or Svelte compile components into different formats based on client vs
  belongs_to: Server-Side Rendering
  description: |-
    ## SSR-specific Plugin Logic

    Some frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional `ssr` property in the `options` object of the following plugin hooks:

    - `resolveId`
    - `load`
    - `transform`

    **Example:**

    js

    ``` javascript
    export function mySSRPlugin() {
      return {
        name: 'my-ssr',
        transform(code, id, options) {
          if (options?.ssr) {
            // perform ssr-specific transform...
          }
        },
      }
    }
    ```

    The options object in `load` and `transform` is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.

    **Note**

    Before Vite 2.7, this was informed to plugin hooks with a positional `ssr` param instead of using the `options` object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.
- name: 'Server-Side Rendering: Vite CLI'
  id: guide/ssr#vite-cli
  summary: The CLI commands $ vite dev and $ vite preview can also be used for SSR apps
  belongs_to: Server-Side Rendering
  description: "## Vite CLI\n\nThe CLI commands `$ vite dev` and `$ vite preview` can also be used for SSR apps. You can add your SSR middlewares to the development server with [`configureServer`](api-plugin#configureserver) and to the preview server with [`configurePreviewServer`](api-plugin#configurepreviewserver).\n\n**Note**\n\nUse a post hook so that your SSR middleware runs *after* Vite's middlewares.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/ssr](https://vitejs.dev/guide/ssr)"
- name: Shared Options
  id: config/shared-options
  summary: Project root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory
  description: "# Shared Options\n\n## root\n\n- **Type:** `string`\n- **Default:** `process.cwd()`\n\nProject root directory (where `index.html` is located). Can be an absolute path, or a path relative to the current working directory.\n\nSee [Project Root](../guide/index#index-html-and-project-root) for more details.\n\n## base\n\n- **Type:** `string`\n- **Default:** `/`\n- **Related:** [`server.origin`](server-options#server-origin)\n\nBase public path when served in development or production. Valid values include:\n\n- Absolute URL pathname, e.g. `/foo/`\n- Full URL, e.g. `https://foo.com/` (The origin part won't be used in development)\n- Empty string or `./` (for embedded deployment)\n\nSee [Public Base Path](../guide/build#public-base-path) for more details.\n\n## mode\n\n- **Type:** `string`\n- **Default:** `'development'` for serve, `'production'` for build\n\nSpecifying this in config will override the default mode for **both serve and build**. This value can also be overridden via the command line `--mode` option.\n\nSee [Env Variables and Modes](../guide/env-and-mode) for more details.\n\n## define\n\n- **Type:** `Record<string, any>`\n\nDefine global constant replacements. Entries will be defined as globals during dev and statically replaced during build.\n\nVite uses [esbuild defines](https://esbuild.github.io/api/#define) to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with `JSON.stringify`.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('v1.0.0'),\n    __API_URL__: 'window.__backend_api_url',\n  },\n})\n```\n\n**NOTE**\n\nFor TypeScript users, make sure to add the type declarations in the `env.d.ts` or `vite-env.d.ts` file to get type checks and Intellisense.\n\nExample:\n\nts\n\n``` javascript\n// vite-env.d.ts\ndeclare const __APP_VERSION__: string\n```\n\n## plugins\n\n- **Type:** `(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[]`\n\nArray of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See [Plugin API](../guide/api-plugin) for more details on Vite plugins.\n\n## publicDir\n\n- **Type:** `string | false`\n- **Default:** `\"public\"`\n\nDirectory to serve as plain static assets. Files in this directory are served at `/` during dev and copied to the root of `outDir` during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.\n\nDefining `publicDir` as `false` disables this feature.\n\nSee [The `public` Directory](../guide/assets#the-public-directory) for more details.\n\n## cacheDir\n\n- **Type:** `string`\n- **Default:** `\"node_modules/.vite\"`\n\nDirectory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use `--force` flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to `.vite` when no package.json is detected.\n\n## resolve.alias\n\n- **Type:**`Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`\n\nWill be passed to `@rollup/plugin-alias` as its [entries option](https://github.com/rollup/plugins/tree/master/packages/alias#entries). Can either be an object, or an array of `{ find, replacement, customResolver }` pairs.\n\nWhen aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.\n\nMore advanced custom resolution can be achieved through [plugins](../guide/api-plugin).\n\n**Using with SSR**\n\nIf you have configured aliases for [SSR externalized dependencies](../guide/ssr#ssr-externals), you may want to alias the actual `node_modules` packages. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.\n\n## resolve.dedupe\n\n- **Type:** `string[]`\n\nIf you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).\n\n**SSR + ESM**\n\nFor SSR builds, deduplication does not work for ESM build outputs configured from `build.rollupOptions.output`. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.\n\n## resolve.conditions\n\n- **Type:** `string[]`\n\nAdditional allowed conditions when resolving [Conditional Exports](https://nodejs.org/api/packages.html#packages_conditional_exports) from a package.\n\nA package with conditional exports may have the following `exports` field in its `package.json`:\n\njson\n\n``` javascript\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.js\"\n    }\n  }\n}\n```\n\nHere, `import` and `require` are \"conditions\". Conditions can be nested and should be specified from most specific to least specific.\n\nVite has a list of \"allowed conditions\" and will match the first condition that is in the allowed list. The default allowed conditions are: `import`, `module`, `browser`, `default`, and `production/development` based on current mode. The `resolve.conditions` config option allows specifying additional allowed conditions.\n\n**Resolving subpath exports**\n\nExport keys ending with \"/\" is deprecated by Node and may not work well. Please contact the package author to use [`*` subpath patterns](https://nodejs.org/api/packages.html#package-entry-points) instead.\n\n## resolve.mainFields\n\n- **Type:** `string[]`\n- **Default:** `['browser', 'module', 'jsnext:main', 'jsnext']`\n\nList of fields in `package.json` to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the `exports` field: if an entry point is successfully resolved from `exports`, the main field will be ignored.\n\n## resolve.extensions\n\n- **Type:** `string[]`\n- **Default:** `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`\n\nList of file extensions to try for imports that omit extensions. Note it is **NOT** recommended to omit extensions for custom import types (e.g. `.vue`) since it can interfere with IDE and type support.\n\n## resolve.preserveSymlinks\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nEnabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).\n\n- **Related:** [esbuild#preserve-symlinks](https://esbuild.github.io/api/#preserve-symlinks), [webpack#resolve.symlinks](https://webpack.js.org/configuration/resolve/#resolvesymlinks)\n\n## html.cspNonce\n\n- **Type:** `string`\n- **Related:** [Content Security Policy (CSP)](../guide/features#content-security-policy-csp)\n\nA nonce value placeholder that will be used when generating script / style tags. Setting this value will also generate a meta tag with nonce value.\n\n## css.modules\n\n- **Type:**\n  ts\n  ``` javascript\n  interface CSSModulesOptions {\n    getJSON?: (\n      cssFileName: string,\n      json: Record<string, string>,\n      outputFileName: string,\n    ) => void\n    scopeBehaviour?: 'global' | 'local'\n    globalModulePaths?: RegExp[]\n    exportGlobals?: boolean\n    generateScopedName?:\n      | string\n      | ((name: string, filename: string, css: string) => string)\n    hashPrefix?: string\n    /**\n     * default: undefined\n     */\n    localsConvention?:\n      | 'camelCase'\n      | 'camelCaseOnly'\n      | 'dashes'\n      | 'dashesOnly'\n      | ((\n          originalClassName: string,\n          generatedClassName: string,\n          inputFile: string,\n        ) => string)\n  }\n  ```\n\nConfigure CSS modules behavior. The options are passed on to [postcss-modules](https://github.com/css-modules/postcss-modules).\n\nThis option doesn't have any effect when using [Lightning CSS](../guide/features#lightning-css). If enabled, [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) should be used instead.\n\n## css.postcss\n\n- **Type:** `string | (postcss.ProcessOptions & { plugins?: postcss.AcceptedPlugin[] })`\n\nInline PostCSS config or a custom directory to search PostCSS config from (default is project root).\n\nFor inline PostCSS config, it expects the same format as `postcss.config.js`. But for `plugins` property, only [array format](https://github.com/postcss/postcss-load-config/blob/main/README.md#array) can be used.\n\nThe search is done using [postcss-load-config](https://github.com/postcss/postcss-load-config) and only the supported config file names are loaded.\n\nNote if an inline config is provided, Vite will not search for other PostCSS config sources.\n\n## css.preprocessorOptions\n\n- **Type:** `Record<string, object>`\n\nSpecify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:\n\n- `sass`/`scss` - [Options](https://sass-lang.com/documentation/js-api/interfaces/LegacyStringOptions).\n- `less` - [Options](https://lesscss.org/usage/#less-options).\n- `styl`/`stylus` - Only [`define`](https://stylus-lang.com/docs/js.html#define-name-node) is supported, which can be passed as an object.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      less: {\n        math: 'parens-division',\n      },\n      styl: {\n        define: {\n          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),\n        },\n      },\n    },\n  },\n})\n```\n\n### css.preprocessorOptions\\[extension\\].additionalData\n\n- **Type:** `string | ((source: string, filename: string) => (string | { content: string; map?: SourceMap }))`\n\nThis option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `$injectedColor: orange;`,\n      },\n    },\n  },\n})\n```\n\n## css.preprocessorMaxWorkers\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15835)\n- **Type:** `number | true`\n- **Default:** `0` (does not create any workers and run in the main thread)\n\nIf this option is set, CSS preprocessors will run in workers when possible. `true` means the number of CPUs minus 1.\n\n## css.devSourcemap\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13845)\n- **Type:** `boolean`\n- **Default:** `false`\n\nWhether to enable sourcemaps during dev.\n\n## css.transformer\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)\n- **Type:** `'postcss' | 'lightningcss'`\n- **Default:** `'postcss'`\n\nSelects the engine used for CSS processing. Check out [Lightning CSS](../guide/features#lightning-css) for more information.\n\n**Duplicate `@import`s**\n\nNote that postcss (postcss-import) has a different behavior with duplicated `@import` from browsers. See [postcss/postcss-import#462](https://github.com/postcss/postcss-import/issues/462).\n\n## css.lightningcss\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)\n- **Type:**\n\njs\n\n``` javascript\nimport type {\n  CSSModulesConfig,\n  Drafts,\n  Features,\n  NonStandard,\n  PseudoClasses,\n  Targets,\n} from 'lightningcss'\n```\n\njs\n\n``` javascript\n{\n  targets?: Targets\n  include?: Features\n  exclude?: Features\n  drafts?: Drafts\n  nonStandard?: NonStandard\n  pseudoClasses?: PseudoClasses\n  unusedSymbols?: string[]\n  cssModules?: CSSModulesConfig,\n  // ...\n}\n```\n\nConfigures Lightning CSS. Full transform options can be found in [the Lightning CSS repo](https://github.com/parcel-bundler/lightningcss/blob/master/node/index.d.ts).\n\n## json.namedExports\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nWhether to support named imports from `.json` files.\n\n## json.stringify\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nIf set to `true`, imported JSON will be transformed into `export default JSON.parse(\"...\")` which is significantly more performant than Object literals, especially when the JSON file is large.\n\nEnabling this disables named imports.\n\n## esbuild\n\n- **Type:** `ESBuildOptions | false`\n\n`ESBuildOptions` extends [esbuild's own transform options](https://esbuild.github.io/api/#transform). The most common use case is customizing JSX:\n\njs\n\n``` javascript\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n```\n\nBy default, esbuild is applied to `ts`, `jsx` and `tsx` files. You can customize this with `esbuild.include` and `esbuild.exclude`, which can be a regex, a [picomatch](https://github.com/micromatch/picomatch#globbing-features) pattern, or an array of either.\n\nIn addition, you can also use `esbuild.jsxInject` to automatically inject JSX helper imports for every file transformed by esbuild:\n\njs\n\n``` javascript\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n```\n\nWhen [`build.minify`](build-options#build-minify) is `true`, all minify optimizations are applied by default. To disable [certain aspects](https://esbuild.github.io/api/#minify) of it, set any of `esbuild.minifyIdentifiers`, `esbuild.minifySyntax`, or `esbuild.minifyWhitespace` options to `false`. Note the `esbuild.minify` option can't be used to override `build.minify`.\n\nSet to `false` to disable esbuild transforms.\n\n## assetsInclude\n\n- **Type:** `string | RegExp | (string | RegExp)[]`\n- **Related:** [Static Asset Handling](../guide/assets)\n\nSpecify additional [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) to be treated as static assets so that:\n\n- They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over `fetch` or XHR.\n\n- Importing them from JS will return their resolved URL string (this can be overwritten if you have a `enforce: 'pre'` plugin to handle the asset type differently).\n\nThe built-in asset type list can be found [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts).\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  assetsInclude: ['**/*.gltf'],\n})\n```\n\n## logLevel\n\n- **Type:** `'info' | 'warn' | 'error' | 'silent'`\n\nAdjust console output verbosity. Default is `'info'`.\n\n## customLogger\n\n- **Type:**\n  ts\n  ``` javascript\n  interface Logger {\n    info(msg: string, options?: LogOptions): void\n    warn(msg: string, options?: LogOptions): void\n    warnOnce(msg: string, options?: LogOptions): void\n    error(msg: string, options?: LogErrorOptions): void\n    clearScreen(type: LogType): void\n    hasErrorLogged(error: Error | RollupError): boolean\n    hasWarned: boolean\n  }\n  ```\n\nUse a custom logger to log messages. You can use Vite's `createLogger` API to get the default logger and customize it to, for example, change the message or filter out certain warnings.\n\nts\n\n``` javascript\nimport { createLogger, defineConfig } from 'vite'\n\nconst logger = createLogger()\nconst loggerWarn = logger.warn\n\nlogger.warn = (msg, options) => {\n  // Ignore empty CSS files warning\n  if (msg.includes('vite:css') && msg.includes(' is empty')) return\n  loggerWarn(msg, options)\n}\n\nexport default defineConfig({\n  customLogger: logger,\n})\n```\n\n## clearScreen\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nSet to `false` to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use `--clearScreen false`.\n\n## envDir\n\n- **Type:** `string`\n- **Default:** `root`\n\nThe directory from which `.env` files are loaded. Can be an absolute path, or a path relative to the project root.\n\nSee [here](../guide/env-and-mode#env-files) for more about environment files.\n\n## envPrefix\n\n- **Type:** `string | string[]`\n- **Default:** `VITE_`\n\nEnv variables starting with `envPrefix` will be exposed to your client source code via import.meta.env.\n\n**SECURITY NOTES**\n\n`envPrefix` should not be set as `''`, which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting `''`.\n\nIf you would like to expose an unprefixed variable, you can use [define](#define) to expose it:\n\njs\n\n``` javascript\ndefine: {\n  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)\n}\n```\n\n## appType\n\n- **Type:** `'spa' | 'mpa' | 'custom'`\n- **Default:** `'spa'`\n\nWhether your application is a Single Page Application (SPA), a [Multi Page Application (MPA)](../guide/build#multi-page-app), or Custom Application (SSR and frameworks with custom HTML handling):\n\n- `'spa'`: include HTML middlewares and use SPA fallback. Configure [sirv](https://github.com/lukeed/sirv) with `single: true` in preview\n- `'mpa'`: include HTML middlewares\n- `'custom'`: don't include HTML middlewares\n\nLearn more in Vite's [SSR guide](../guide/ssr#vite-cli). Related: [`server.middlewareMode`](server-options#server-middlewaremode).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/shared-options](https://vitejs.dev/config/shared-options)"
- name: 'Shared Options: appType'
  id: config/shared-options#apptype
  summary: Learn more in Vite's SSR guide
  belongs_to: Shared Options
  description: "## appType\n\n- **Type:** `'spa' | 'mpa' | 'custom'`\n- **Default:** `'spa'`\n\nWhether your application is a Single Page Application (SPA), a [Multi Page Application (MPA)](../guide/build#multi-page-app), or Custom Application (SSR and frameworks with custom HTML handling):\n\n- `'spa'`: include HTML middlewares and use SPA fallback. Configure [sirv](https://github.com/lukeed/sirv) with `single: true` in preview\n- `'mpa'`: include HTML middlewares\n- `'custom'`: don't include HTML middlewares\n\nLearn more in Vite's [SSR guide](../guide/ssr#vite-cli). Related: [`server.middlewareMode`](server-options#server-middlewaremode).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/shared-options](https://vitejs.dev/config/shared-options)"
- name: 'Shared Options: assetsInclude'
  id: config/shared-options#assetsinclude
  summary: They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over fetch or XHR
  belongs_to: Shared Options
  description: |-
    ## assetsInclude

    - **Type:** `string | RegExp | (string | RegExp)[]`
    - **Related:** [Static Asset Handling](../guide/assets)

    Specify additional [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) to be treated as static assets so that:

    - They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over `fetch` or XHR.

    - Importing them from JS will return their resolved URL string (this can be overwritten if you have a `enforce: 'pre'` plugin to handle the asset type differently).

    The built-in asset type list can be found [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts).

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      assetsInclude: ['**/*.gltf'],
    })
    ```
- name: 'Shared Options: base'
  id: config/shared-options#base
  summary: Base public path when served in development or production
  belongs_to: Shared Options
  description: |-
    ## base

    - **Type:** `string`
    - **Default:** `/`
    - **Related:** [`server.origin`](server-options#server-origin)

    Base public path when served in development or production. Valid values include:

    - Absolute URL pathname, e.g. `/foo/`
    - Full URL, e.g. `https://foo.com/` (The origin part won't be used in development)
    - Empty string or `./` (for embedded deployment)

    See [Public Base Path](../guide/build#public-base-path) for more details.
- name: 'Shared Options: cacheDir'
  id: config/shared-options#cachedir
  summary: Directory to save cache files
  belongs_to: Shared Options
  description: |-
    ## cacheDir

    - **Type:** `string`
    - **Default:** `"node_modules/.vite"`

    Directory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use `--force` flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to `.vite` when no package.json is detected.
- name: 'Shared Options: clearScreen'
  id: config/shared-options#clearscreen
  summary: Set to false to prevent Vite from clearing the terminal screen when logging certain messages
  belongs_to: Shared Options
  description: |-
    ## clearScreen

    - **Type:** `boolean`
    - **Default:** `true`

    Set to `false` to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use `--clearScreen false`.
- name: 'Shared Options: Config'
  id: config/shared-options
  summary: Project root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory
  description: "# Shared Options\n\n## root\n\n- **Type:** `string`\n- **Default:** `process.cwd()`\n\nProject root directory (where `index.html` is located). Can be an absolute path, or a path relative to the current working directory.\n\nSee [Project Root](../guide/index#index-html-and-project-root) for more details.\n\n## base\n\n- **Type:** `string`\n- **Default:** `/`\n- **Related:** [`server.origin`](server-options#server-origin)\n\nBase public path when served in development or production. Valid values include:\n\n- Absolute URL pathname, e.g. `/foo/`\n- Full URL, e.g. `https://foo.com/` (The origin part won't be used in development)\n- Empty string or `./` (for embedded deployment)\n\nSee [Public Base Path](../guide/build#public-base-path) for more details.\n\n## mode\n\n- **Type:** `string`\n- **Default:** `'development'` for serve, `'production'` for build\n\nSpecifying this in config will override the default mode for **both serve and build**. This value can also be overridden via the command line `--mode` option.\n\nSee [Env Variables and Modes](../guide/env-and-mode) for more details.\n\n## define\n\n- **Type:** `Record<string, any>`\n\nDefine global constant replacements. Entries will be defined as globals during dev and statically replaced during build.\n\nVite uses [esbuild defines](https://esbuild.github.io/api/#define) to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with `JSON.stringify`.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('v1.0.0'),\n    __API_URL__: 'window.__backend_api_url',\n  },\n})\n```\n\n**NOTE**\n\nFor TypeScript users, make sure to add the type declarations in the `env.d.ts` or `vite-env.d.ts` file to get type checks and Intellisense.\n\nExample:\n\nts\n\n``` javascript\n// vite-env.d.ts\ndeclare const __APP_VERSION__: string\n```\n\n## plugins\n\n- **Type:** `(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[]`\n\nArray of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See [Plugin API](../guide/api-plugin) for more details on Vite plugins.\n\n## publicDir\n\n- **Type:** `string | false`\n- **Default:** `\"public\"`\n\nDirectory to serve as plain static assets. Files in this directory are served at `/` during dev and copied to the root of `outDir` during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.\n\nDefining `publicDir` as `false` disables this feature.\n\nSee [The `public` Directory](../guide/assets#the-public-directory) for more details.\n\n## cacheDir\n\n- **Type:** `string`\n- **Default:** `\"node_modules/.vite\"`\n\nDirectory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use `--force` flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to `.vite` when no package.json is detected.\n\n## resolve.alias\n\n- **Type:**`Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`\n\nWill be passed to `@rollup/plugin-alias` as its [entries option](https://github.com/rollup/plugins/tree/master/packages/alias#entries). Can either be an object, or an array of `{ find, replacement, customResolver }` pairs.\n\nWhen aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.\n\nMore advanced custom resolution can be achieved through [plugins](../guide/api-plugin).\n\n**Using with SSR**\n\nIf you have configured aliases for [SSR externalized dependencies](../guide/ssr#ssr-externals), you may want to alias the actual `node_modules` packages. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.\n\n## resolve.dedupe\n\n- **Type:** `string[]`\n\nIf you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).\n\n**SSR + ESM**\n\nFor SSR builds, deduplication does not work for ESM build outputs configured from `build.rollupOptions.output`. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.\n\n## resolve.conditions\n\n- **Type:** `string[]`\n\nAdditional allowed conditions when resolving [Conditional Exports](https://nodejs.org/api/packages.html#packages_conditional_exports) from a package.\n\nA package with conditional exports may have the following `exports` field in its `package.json`:\n\njson\n\n``` javascript\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.js\"\n    }\n  }\n}\n```\n\nHere, `import` and `require` are \"conditions\". Conditions can be nested and should be specified from most specific to least specific.\n\nVite has a list of \"allowed conditions\" and will match the first condition that is in the allowed list. The default allowed conditions are: `import`, `module`, `browser`, `default`, and `production/development` based on current mode. The `resolve.conditions` config option allows specifying additional allowed conditions.\n\n**Resolving subpath exports**\n\nExport keys ending with \"/\" is deprecated by Node and may not work well. Please contact the package author to use [`*` subpath patterns](https://nodejs.org/api/packages.html#package-entry-points) instead.\n\n## resolve.mainFields\n\n- **Type:** `string[]`\n- **Default:** `['browser', 'module', 'jsnext:main', 'jsnext']`\n\nList of fields in `package.json` to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the `exports` field: if an entry point is successfully resolved from `exports`, the main field will be ignored.\n\n## resolve.extensions\n\n- **Type:** `string[]`\n- **Default:** `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`\n\nList of file extensions to try for imports that omit extensions. Note it is **NOT** recommended to omit extensions for custom import types (e.g. `.vue`) since it can interfere with IDE and type support.\n\n## resolve.preserveSymlinks\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nEnabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).\n\n- **Related:** [esbuild#preserve-symlinks](https://esbuild.github.io/api/#preserve-symlinks), [webpack#resolve.symlinks](https://webpack.js.org/configuration/resolve/#resolvesymlinks)\n\n## html.cspNonce\n\n- **Type:** `string`\n- **Related:** [Content Security Policy (CSP)](../guide/features#content-security-policy-csp)\n\nA nonce value placeholder that will be used when generating script / style tags. Setting this value will also generate a meta tag with nonce value.\n\n## css.modules\n\n- **Type:**\n  ts\n  ``` javascript\n  interface CSSModulesOptions {\n    getJSON?: (\n      cssFileName: string,\n      json: Record<string, string>,\n      outputFileName: string,\n    ) => void\n    scopeBehaviour?: 'global' | 'local'\n    globalModulePaths?: RegExp[]\n    exportGlobals?: boolean\n    generateScopedName?:\n      | string\n      | ((name: string, filename: string, css: string) => string)\n    hashPrefix?: string\n    /**\n     * default: undefined\n     */\n    localsConvention?:\n      | 'camelCase'\n      | 'camelCaseOnly'\n      | 'dashes'\n      | 'dashesOnly'\n      | ((\n          originalClassName: string,\n          generatedClassName: string,\n          inputFile: string,\n        ) => string)\n  }\n  ```\n\nConfigure CSS modules behavior. The options are passed on to [postcss-modules](https://github.com/css-modules/postcss-modules).\n\nThis option doesn't have any effect when using [Lightning CSS](../guide/features#lightning-css). If enabled, [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) should be used instead.\n\n## css.postcss\n\n- **Type:** `string | (postcss.ProcessOptions & { plugins?: postcss.AcceptedPlugin[] })`\n\nInline PostCSS config or a custom directory to search PostCSS config from (default is project root).\n\nFor inline PostCSS config, it expects the same format as `postcss.config.js`. But for `plugins` property, only [array format](https://github.com/postcss/postcss-load-config/blob/main/README.md#array) can be used.\n\nThe search is done using [postcss-load-config](https://github.com/postcss/postcss-load-config) and only the supported config file names are loaded.\n\nNote if an inline config is provided, Vite will not search for other PostCSS config sources.\n\n## css.preprocessorOptions\n\n- **Type:** `Record<string, object>`\n\nSpecify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:\n\n- `sass`/`scss` - [Options](https://sass-lang.com/documentation/js-api/interfaces/LegacyStringOptions).\n- `less` - [Options](https://lesscss.org/usage/#less-options).\n- `styl`/`stylus` - Only [`define`](https://stylus-lang.com/docs/js.html#define-name-node) is supported, which can be passed as an object.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      less: {\n        math: 'parens-division',\n      },\n      styl: {\n        define: {\n          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),\n        },\n      },\n    },\n  },\n})\n```\n\n### css.preprocessorOptions\\[extension\\].additionalData\n\n- **Type:** `string | ((source: string, filename: string) => (string | { content: string; map?: SourceMap }))`\n\nThis option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `$injectedColor: orange;`,\n      },\n    },\n  },\n})\n```\n\n## css.preprocessorMaxWorkers\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15835)\n- **Type:** `number | true`\n- **Default:** `0` (does not create any workers and run in the main thread)\n\nIf this option is set, CSS preprocessors will run in workers when possible. `true` means the number of CPUs minus 1.\n\n## css.devSourcemap\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13845)\n- **Type:** `boolean`\n- **Default:** `false`\n\nWhether to enable sourcemaps during dev.\n\n## css.transformer\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)\n- **Type:** `'postcss' | 'lightningcss'`\n- **Default:** `'postcss'`\n\nSelects the engine used for CSS processing. Check out [Lightning CSS](../guide/features#lightning-css) for more information.\n\n**Duplicate `@import`s**\n\nNote that postcss (postcss-import) has a different behavior with duplicated `@import` from browsers. See [postcss/postcss-import#462](https://github.com/postcss/postcss-import/issues/462).\n\n## css.lightningcss\n\n- **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)\n- **Type:**\n\njs\n\n``` javascript\nimport type {\n  CSSModulesConfig,\n  Drafts,\n  Features,\n  NonStandard,\n  PseudoClasses,\n  Targets,\n} from 'lightningcss'\n```\n\njs\n\n``` javascript\n{\n  targets?: Targets\n  include?: Features\n  exclude?: Features\n  drafts?: Drafts\n  nonStandard?: NonStandard\n  pseudoClasses?: PseudoClasses\n  unusedSymbols?: string[]\n  cssModules?: CSSModulesConfig,\n  // ...\n}\n```\n\nConfigures Lightning CSS. Full transform options can be found in [the Lightning CSS repo](https://github.com/parcel-bundler/lightningcss/blob/master/node/index.d.ts).\n\n## json.namedExports\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nWhether to support named imports from `.json` files.\n\n## json.stringify\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nIf set to `true`, imported JSON will be transformed into `export default JSON.parse(\"...\")` which is significantly more performant than Object literals, especially when the JSON file is large.\n\nEnabling this disables named imports.\n\n## esbuild\n\n- **Type:** `ESBuildOptions | false`\n\n`ESBuildOptions` extends [esbuild's own transform options](https://esbuild.github.io/api/#transform). The most common use case is customizing JSX:\n\njs\n\n``` javascript\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n```\n\nBy default, esbuild is applied to `ts`, `jsx` and `tsx` files. You can customize this with `esbuild.include` and `esbuild.exclude`, which can be a regex, a [picomatch](https://github.com/micromatch/picomatch#globbing-features) pattern, or an array of either.\n\nIn addition, you can also use `esbuild.jsxInject` to automatically inject JSX helper imports for every file transformed by esbuild:\n\njs\n\n``` javascript\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n```\n\nWhen [`build.minify`](build-options#build-minify) is `true`, all minify optimizations are applied by default. To disable [certain aspects](https://esbuild.github.io/api/#minify) of it, set any of `esbuild.minifyIdentifiers`, `esbuild.minifySyntax`, or `esbuild.minifyWhitespace` options to `false`. Note the `esbuild.minify` option can't be used to override `build.minify`.\n\nSet to `false` to disable esbuild transforms.\n\n## assetsInclude\n\n- **Type:** `string | RegExp | (string | RegExp)[]`\n- **Related:** [Static Asset Handling](../guide/assets)\n\nSpecify additional [picomatch patterns](https://github.com/micromatch/picomatch#globbing-features) to be treated as static assets so that:\n\n- They will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over `fetch` or XHR.\n\n- Importing them from JS will return their resolved URL string (this can be overwritten if you have a `enforce: 'pre'` plugin to handle the asset type differently).\n\nThe built-in asset type list can be found [here](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts).\n\n**Example:**\n\njs\n\n``` javascript\nexport default defineConfig({\n  assetsInclude: ['**/*.gltf'],\n})\n```\n\n## logLevel\n\n- **Type:** `'info' | 'warn' | 'error' | 'silent'`\n\nAdjust console output verbosity. Default is `'info'`.\n\n## customLogger\n\n- **Type:**\n  ts\n  ``` javascript\n  interface Logger {\n    info(msg: string, options?: LogOptions): void\n    warn(msg: string, options?: LogOptions): void\n    warnOnce(msg: string, options?: LogOptions): void\n    error(msg: string, options?: LogErrorOptions): void\n    clearScreen(type: LogType): void\n    hasErrorLogged(error: Error | RollupError): boolean\n    hasWarned: boolean\n  }\n  ```\n\nUse a custom logger to log messages. You can use Vite's `createLogger` API to get the default logger and customize it to, for example, change the message or filter out certain warnings.\n\nts\n\n``` javascript\nimport { createLogger, defineConfig } from 'vite'\n\nconst logger = createLogger()\nconst loggerWarn = logger.warn\n\nlogger.warn = (msg, options) => {\n  // Ignore empty CSS files warning\n  if (msg.includes('vite:css') && msg.includes(' is empty')) return\n  loggerWarn(msg, options)\n}\n\nexport default defineConfig({\n  customLogger: logger,\n})\n```\n\n## clearScreen\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nSet to `false` to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use `--clearScreen false`.\n\n## envDir\n\n- **Type:** `string`\n- **Default:** `root`\n\nThe directory from which `.env` files are loaded. Can be an absolute path, or a path relative to the project root.\n\nSee [here](../guide/env-and-mode#env-files) for more about environment files.\n\n## envPrefix\n\n- **Type:** `string | string[]`\n- **Default:** `VITE_`\n\nEnv variables starting with `envPrefix` will be exposed to your client source code via import.meta.env.\n\n**SECURITY NOTES**\n\n`envPrefix` should not be set as `''`, which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting `''`.\n\nIf you would like to expose an unprefixed variable, you can use [define](#define) to expose it:\n\njs\n\n``` javascript\ndefine: {\n  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)\n}\n```\n\n## appType\n\n- **Type:** `'spa' | 'mpa' | 'custom'`\n- **Default:** `'spa'`\n\nWhether your application is a Single Page Application (SPA), a [Multi Page Application (MPA)](../guide/build#multi-page-app), or Custom Application (SSR and frameworks with custom HTML handling):\n\n- `'spa'`: include HTML middlewares and use SPA fallback. Configure [sirv](https://github.com/lukeed/sirv) with `single: true` in preview\n- `'mpa'`: include HTML middlewares\n- `'custom'`: don't include HTML middlewares\n\nLearn more in Vite's [SSR guide](../guide/ssr#vite-cli). Related: [`server.middlewareMode`](server-options#server-middlewaremode).\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/shared-options](https://vitejs.dev/config/shared-options)"
- name: 'Shared Options: css.devSourcemap'
  id: config/shared-options#css-devsourcemap
  summary: Whether to enable sourcemaps during dev
  belongs_to: Shared Options
  description: |-
    ## css.devSourcemap

    - **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13845)
    - **Type:** `boolean`
    - **Default:** `false`

    Whether to enable sourcemaps during dev.
- name: 'Shared Options: css.lightningcss'
  id: config/shared-options#css-lightningcss
  summary: Configures Lightning CSS
  belongs_to: Shared Options
  description: |-
    ## css.lightningcss

    - **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)
    - **Type:**

    js

    ``` javascript
    import type {
      CSSModulesConfig,
      Drafts,
      Features,
      NonStandard,
      PseudoClasses,
      Targets,
    } from 'lightningcss'
    ```

    js

    ``` javascript
    {
      targets?: Targets
      include?: Features
      exclude?: Features
      drafts?: Drafts
      nonStandard?: NonStandard
      pseudoClasses?: PseudoClasses
      unusedSymbols?: string[]
      cssModules?: CSSModulesConfig,
      // ...
    }
    ```

    Configures Lightning CSS. Full transform options can be found in [the Lightning CSS repo](https://github.com/parcel-bundler/lightningcss/blob/master/node/index.d.ts).
- name: 'Shared Options: css.modules'
  id: config/shared-options#css-modules
  summary: Configure CSS modules behavior
  belongs_to: Shared Options
  description: |-
    ## css.modules

    - **Type:**
      ts
      ``` javascript
      interface CSSModulesOptions {
        getJSON?: (
          cssFileName: string,
          json: Record<string, string>,
          outputFileName: string,
        ) => void
        scopeBehaviour?: 'global' | 'local'
        globalModulePaths?: RegExp[]
        exportGlobals?: boolean
        generateScopedName?:
          | string
          | ((name: string, filename: string, css: string) => string)
        hashPrefix?: string
        /**
         * default: undefined
         */
        localsConvention?:
          | 'camelCase'
          | 'camelCaseOnly'
          | 'dashes'
          | 'dashesOnly'
          | ((
              originalClassName: string,
              generatedClassName: string,
              inputFile: string,
            ) => string)
      }
      ```

    Configure CSS modules behavior. The options are passed on to [postcss-modules](https://github.com/css-modules/postcss-modules).

    This option doesn't have any effect when using [Lightning CSS](../guide/features#lightning-css). If enabled, [`css.lightningcss.cssModules`](https://lightningcss.dev/css-modules.html) should be used instead.
- name: 'Shared Options: css.postcss'
  id: config/shared-options#css-postcss
  summary: For inline PostCSS config, it expects the same format as postcss.config.js
  belongs_to: Shared Options
  description: |-
    ## css.postcss

    - **Type:** `string | (postcss.ProcessOptions & { plugins?: postcss.AcceptedPlugin[] })`

    Inline PostCSS config or a custom directory to search PostCSS config from (default is project root).

    For inline PostCSS config, it expects the same format as `postcss.config.js`. But for `plugins` property, only [array format](https://github.com/postcss/postcss-load-config/blob/main/README.md#array) can be used.

    The search is done using [postcss-load-config](https://github.com/postcss/postcss-load-config) and only the supported config file names are loaded.

    Note if an inline config is provided, Vite will not search for other PostCSS config sources.
- name: 'Shared Options: css.preprocessorMaxWorkers'
  id: config/shared-options#css-preprocessormaxworkers
  summary: If this option is set, CSS preprocessors will run in workers when possible
  belongs_to: Shared Options
  description: |-
    ## css.preprocessorMaxWorkers

    - **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/15835)
    - **Type:** `number | true`
    - **Default:**`0` (does not create any workers and run in the main thread)

    If this option is set, CSS preprocessors will run in workers when possible. `true` means the number of CPUs minus 1.
- name: 'Shared Options: css.preprocessorOptions'
  id: config/shared-options#css-preprocessoroptions
  summary: Specify options to pass to CSS pre-processors
  belongs_to: Shared Options
  description: |-
    ## css.preprocessorOptions

    - **Type:** `Record<string, object>`

    Specify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:

    - `sass`/`scss` - [Options](https://sass-lang.com/documentation/js-api/interfaces/LegacyStringOptions).
    - `less` - [Options](https://lesscss.org/usage/#less-options).
    - `styl`/`stylus` - Only [`define`](https://stylus-lang.com/docs/js.html#define-name-node) is supported, which can be passed as an object.

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      css: {
        preprocessorOptions: {
          less: {
            math: 'parens-division',
          },
          styl: {
            define: {
              $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),
            },
          },
        },
      },
    })
    ```
- name: 'Shared Options: css.preprocessorOptions[extension].additionalData'
  id: config/shared-options#css-preprocessoroptions-extension-additionaldata
  summary: This option can be used to inject extra code for each style content
  belongs_to: Shared Options
  description: |-
    ### css.preprocessorOptions\[extension\].additionalData

    - **Type:** `string | ((source: string, filename: string) => (string | { content: string; map?: SourceMap }))`

    This option can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      css: {
        preprocessorOptions: {
          scss: {
            additionalData: `$injectedColor: orange;`,
          },
        },
      },
    })
    ```
- name: 'Shared Options: css.transformer'
  id: config/shared-options#css-transformer
  summary: Selects the engine used for CSS processing
  belongs_to: Shared Options
  description: |-
    ## css.transformer

    - **Experimental:** [Give Feedback](https://github.com/vitejs/vite/discussions/13835)
    - **Type:** `'postcss' | 'lightningcss'`
    - **Default:** `'postcss'`

    Selects the engine used for CSS processing. Check out [Lightning CSS](../guide/features#lightning-css) for more information.

    **Duplicate `@import`s**

    Note that postcss (postcss-import) has a different behavior with duplicated `@import` from browsers. See [postcss/postcss-import#462](https://github.com/postcss/postcss-import/issues/462).
- name: 'Shared Options: customLogger'
  id: config/shared-options#customlogger
  summary: Use a custom logger to log messages
  belongs_to: Shared Options
  description: |-
    ## customLogger

    - **Type:**
      ts
      ``` javascript
      interface Logger {
        info(msg: string, options?: LogOptions): void
        warn(msg: string, options?: LogOptions): void
        warnOnce(msg: string, options?: LogOptions): void
        error(msg: string, options?: LogErrorOptions): void
        clearScreen(type: LogType): void
        hasErrorLogged(error: Error | RollupError): boolean
        hasWarned: boolean
      }
      ```

    Use a custom logger to log messages. You can use Vite's `createLogger` API to get the default logger and customize it to, for example, change the message or filter out certain warnings.

    ts

    ``` javascript
    import { createLogger, defineConfig } from 'vite'

    const logger = createLogger()
    const loggerWarn = logger.warn

    logger.warn = (msg, options) => {
      // Ignore empty CSS files warning
      if (msg.includes('vite:css') && msg.includes(' is empty')) return
      loggerWarn(msg, options)
    }

    export default defineConfig({
      customLogger: logger,
    })
    ```
- name: 'Shared Options: define'
  id: config/shared-options#define
  summary: Define global constant replacements
  belongs_to: Shared Options
  description: |-
    ## define

    - **Type:** `Record<string, any>`

    Define global constant replacements. Entries will be defined as globals during dev and statically replaced during build.

    Vite uses [esbuild defines](https://esbuild.github.io/api/#define) to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with `JSON.stringify`.

    **Example:**

    js

    ``` javascript
    export default defineConfig({
      define: {
        __APP_VERSION__: JSON.stringify('v1.0.0'),
        __API_URL__: 'window.__backend_api_url',
      },
    })
    ```

    **NOTE**

    For TypeScript users, make sure to add the type declarations in the `env.d.ts` or `vite-env.d.ts` file to get type checks and Intellisense.

    Example:

    ts

    ``` javascript
    // vite-env.d.ts
    declare const __APP_VERSION__: string
    ```
- name: 'Shared Options: envDir'
  id: config/shared-options#envdir
  summary: The directory from which .env files are loaded
  belongs_to: Shared Options
  description: |-
    ## envDir

    - **Type:** `string`
    - **Default:** `root`

    The directory from which `.env` files are loaded. Can be an absolute path, or a path relative to the project root.

    See [here](../guide/env-and-mode#env-files) for more about environment files.
- name: 'Shared Options: envPrefix'
  id: config/shared-options#envprefix
  summary: Env variables starting with envPrefix will be exposed to your client source code via import.meta.env
  belongs_to: Shared Options
  description: |-
    ## envPrefix

    - **Type:** `string | string[]`
    - **Default:** `VITE_`

    Env variables starting with `envPrefix` will be exposed to your client source code via import.meta.env.

    **SECURITY NOTES**

    `envPrefix` should not be set as `''`, which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting `''`.

    If you would like to expose an unprefixed variable, you can use [define](#define) to expose it:

    js

    ``` javascript
    define: {
      'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)
    }
    ```
- name: 'Shared Options: esbuild'
  id: config/shared-options#esbuild
  summary: ESBuildOptions extends esbuild's own transform options
  belongs_to: Shared Options
  description: |-
    ## esbuild

    - **Type:** `ESBuildOptions | false`

    `ESBuildOptions` extends [esbuild's own transform options](https://esbuild.github.io/api/#transform). The most common use case is customizing JSX:

    js

    ``` javascript
    export default defineConfig({
      esbuild: {
        jsxFactory: 'h',
        jsxFragment: 'Fragment',
      },
    })
    ```

    By default, esbuild is applied to `ts`, `jsx` and `tsx` files. You can customize this with `esbuild.include` and `esbuild.exclude`, which can be a regex, a [picomatch](https://github.com/micromatch/picomatch#globbing-features) pattern, or an array of either.

    In addition, you can also use `esbuild.jsxInject` to automatically inject JSX helper imports for every file transformed by esbuild:

    js

    ``` javascript
    export default defineConfig({
      esbuild: {
        jsxInject: `import React from 'react'`,
      },
    })
    ```

    When [`build.minify`](build-options#build-minify) is `true`, all minify optimizations are applied by default. To disable [certain aspects](https://esbuild.github.io/api/#minify) of it, set any of `esbuild.minifyIdentifiers`, `esbuild.minifySyntax`, or `esbuild.minifyWhitespace` options to `false`. Note the `esbuild.minify` option can't be used to override `build.minify`.

    Set to `false` to disable esbuild transforms.
- name: 'Shared Options: html.cspNonce'
  id: config/shared-options#html-cspnonce
  summary: A nonce value placeholder that will be used when generating script / style tags
  belongs_to: Shared Options
  description: |-
    ## html.cspNonce

    - **Type:** `string`
    - **Related:** [Content Security Policy (CSP)](../guide/features#content-security-policy-csp)

    A nonce value placeholder that will be used when generating script / style tags. Setting this value will also generate a meta tag with nonce value.
- name: 'Shared Options: json.namedExports'
  id: config/shared-options#json-namedexports
  summary: Whether to support named imports from .json files
  belongs_to: Shared Options
  description: |-
    ## json.namedExports

    - **Type:** `boolean`
    - **Default:** `true`

    Whether to support named imports from `.json` files.
- name: 'Shared Options: json.stringify'
  id: config/shared-options#json-stringify
  summary: If set to true, imported JSON will be transformed into export default JSON.parse("...") which is significantly more performant than Object literals, especially when the JSON file is large
  belongs_to: Shared Options
  description: |-
    ## json.stringify

    - **Type:** `boolean`
    - **Default:** `false`

    If set to `true`, imported JSON will be transformed into `export default JSON.parse("...")` which is significantly more performant than Object literals, especially when the JSON file is large.

    Enabling this disables named imports.
- name: 'Shared Options: logLevel'
  id: config/shared-options#loglevel
  summary: Adjust console output verbosity
  belongs_to: Shared Options
  description: |-
    ## logLevel

    - **Type:** `'info' | 'warn' | 'error' | 'silent'`

    Adjust console output verbosity. Default is `'info'`.
- name: 'Shared Options: mode'
  id: config/shared-options#mode
  summary: Specifying this in config will override the default mode for both serve and build
  belongs_to: Shared Options
  description: |-
    ## mode

    - **Type:** `string`
    - **Default:**`'development'` for serve, `'production'` for build

    Specifying this in config will override the default mode for **both serve and build**. This value can also be overridden via the command line `--mode` option.

    See [Env Variables and Modes](../guide/env-and-mode) for more details.
- name: 'Shared Options: plugins'
  id: config/shared-options#plugins
  summary: Array of plugins to use
  belongs_to: Shared Options
  description: |-
    ## plugins

    - **Type:** `(Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[]`

    Array of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See [Plugin API](../guide/api-plugin) for more details on Vite plugins.
- name: 'Shared Options: publicDir'
  id: config/shared-options#publicdir
  summary: Directory to serve as plain static assets
  belongs_to: Shared Options
  description: |-
    ## publicDir

    - **Type:** `string | false`
    - **Default:** `"public"`

    Directory to serve as plain static assets. Files in this directory are served at `/` during dev and copied to the root of `outDir` during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.

    Defining `publicDir` as `false` disables this feature.

    See [The `public` Directory](../guide/assets#the-public-directory) for more details.
- name: 'Shared Options: resolve.alias'
  id: config/shared-options#resolve-alias
  summary: Will be passed to @rollup/plugin-alias as its entries option
  belongs_to: Shared Options
  description: |-
    ## resolve.alias

    - **Type:** `Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`

    Will be passed to `@rollup/plugin-alias` as its [entries option](https://github.com/rollup/plugins/tree/master/packages/alias#entries). Can either be an object, or an array of `{ find, replacement, customResolver }` pairs.

    When aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.

    More advanced custom resolution can be achieved through [plugins](../guide/api-plugin).

    **Using with SSR**

    If you have configured aliases for [SSR externalized dependencies](../guide/ssr#ssr-externals), you may want to alias the actual `node_modules` packages. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.
- name: 'Shared Options: resolve.conditions'
  id: config/shared-options#resolve-conditions
  summary: Additional allowed conditions when resolving Conditional Exports from a package
  belongs_to: Shared Options
  description: |-
    ## resolve.conditions

    - **Type:** `string[]`

    Additional allowed conditions when resolving [Conditional Exports](https://nodejs.org/api/packages.html#packages_conditional_exports) from a package.

    A package with conditional exports may have the following `exports` field in its `package.json`:

    json

    ``` javascript
    {
      "exports": {
        ".": {
          "import": "./index.mjs",
          "require": "./index.js"
        }
      }
    }
    ```

    Here, `import` and `require` are "conditions". Conditions can be nested and should be specified from most specific to least specific.

    Vite has a list of "allowed conditions" and will match the first condition that is in the allowed list. The default allowed conditions are: `import`, `module`, `browser`, `default`, and `production/development` based on current mode. The `resolve.conditions` config option allows specifying additional allowed conditions.

    **Resolving subpath exports**

    Export keys ending with "/" is deprecated by Node and may not work well. Please contact the package author to use [`*` subpath patterns](https://nodejs.org/api/packages.html#package-entry-points) instead.
- name: 'Shared Options: resolve.dedupe'
  id: config/shared-options#resolve-dedupe
  summary: For SSR builds, deduplication does not work for ESM build outputs configured from build.rollupOptions.output
  belongs_to: Shared Options
  description: |-
    ## resolve.dedupe

    - **Type:** `string[]`

    If you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).

    **SSR + ESM**

    For SSR builds, deduplication does not work for ESM build outputs configured from `build.rollupOptions.output`. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.
- name: 'Shared Options: resolve.extensions'
  id: config/shared-options#resolve-extensions
  summary: List of file extensions to try for imports that omit extensions
  belongs_to: Shared Options
  description: |-
    ## resolve.extensions

    - **Type:** `string[]`
    - **Default:** `['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']`

    List of file extensions to try for imports that omit extensions. Note it is **NOT** recommended to omit extensions for custom import types (e.g. `.vue`) since it can interfere with IDE and type support.
- name: 'Shared Options: resolve.mainFields'
  id: config/shared-options#resolve-mainfields
  summary: List of fields in package.json to try when resolving a package's entry point
  belongs_to: Shared Options
  description: |-
    ## resolve.mainFields

    - **Type:** `string[]`
    - **Default:** `['browser', 'module', 'jsnext:main', 'jsnext']`

    List of fields in `package.json` to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the `exports` field: if an entry point is successfully resolved from `exports`, the main field will be ignored.
- name: 'Shared Options: resolve.preserveSymlinks'
  id: config/shared-options#resolve-preservesymlinks
  summary: Enabling this setting causes vite to determine file identity by the original file path (i.e
  belongs_to: Shared Options
  description: |-
    ## resolve.preserveSymlinks

    - **Type:** `boolean`
    - **Default:** `false`

    Enabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).

    - **Related:**[esbuild#preserve-symlinks](https://esbuild.github.io/api/#preserve-symlinks), [webpack#resolve.symlinks](https://webpack.js.org/configuration/resolve/#resolvesymlinks)
- name: 'Shared Options: root'
  id: config/shared-options#root
  summary: Project root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory
  belongs_to: Shared Options
  description: |-
    ## root

    - **Type:** `string`
    - **Default:** `process.cwd()`

    Project root directory (where `index.html` is located). Can be an absolute path, or a path relative to the current working directory.

    See [Project Root](../guide/index#index-html-and-project-root) for more details.
- name: SSR Options
  id: config/ssr-options
  summary: Externalize the given dependencies and their transitive dependencies for SSR
  description: "# SSR Options\n\n## ssr.external\n\n- **Type:** `string[] | true`\n- **Related:** [SSR Externals](../guide/ssr#ssr-externals)\n\nExternalize the given dependencies and their transitive dependencies for SSR. By default, all dependencies are externalized except for linked dependencies (for HMR). If you prefer to externalize the linked dependency, you can pass its name to this option.\n\nIf `true`, all dependencies including linked dependencies are externalized.\n\nNote that the explicitly listed dependencies (using `string[]` type) will always take priority if they're also listed in `ssr.noExternal` (using any type).\n\n## ssr.noExternal\n\n- **Type:** `string | RegExp | (string | RegExp)[] | true`\n- **Related:** [SSR Externals](../guide/ssr#ssr-externals)\n\nPrevent listed dependencies from being externalized for SSR, which they will get bundled in build. By default, only linked dependencies are not externalized (for HMR). If you prefer to externalize the linked dependency, you can pass its name to the `ssr.external` option.\n\nIf `true`, no dependencies are externalized. However, dependencies explicitly listed in `ssr.external` (using `string[]` type) can take priority and still be externalized. If `ssr.target: 'node'` is set, Node.js built-ins will also be externalized by default.\n\nNote that if both `ssr.noExternal: true` and `ssr.external: true` are configured, `ssr.noExternal` takes priority and no dependencies are externalized.\n\n## ssr.target\n\n- **Type:** `'node' | 'webworker'`\n- **Default:** `node`\n\nBuild target for the SSR server.\n\n## ssr.resolve.conditions\n\n- **Type:** `string[]`\n- **Related:** [Resolve Conditions](shared-options#resolve-conditions)\n\nDefaults to the the root [`resolve.conditions`](shared-options#resolve-conditions).\n\nThese conditions are used in the plugin pipeline, and only affect non-externalized dependencies during the SSR build. Use `ssr.resolve.externalConditions` to affect externalized imports.\n\n## ssr.resolve.externalConditions\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nConditions that are used during ssr import (including `ssrLoadModule`) of externalized dependencies.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/ssr-options](https://vitejs.dev/config/ssr-options)"
- name: 'SSR Options: Config'
  id: config/ssr-options
  summary: Externalize the given dependencies and their transitive dependencies for SSR
  description: "# SSR Options\n\n## ssr.external\n\n- **Type:** `string[] | true`\n- **Related:** [SSR Externals](../guide/ssr#ssr-externals)\n\nExternalize the given dependencies and their transitive dependencies for SSR. By default, all dependencies are externalized except for linked dependencies (for HMR). If you prefer to externalize the linked dependency, you can pass its name to this option.\n\nIf `true`, all dependencies including linked dependencies are externalized.\n\nNote that the explicitly listed dependencies (using `string[]` type) will always take priority if they're also listed in `ssr.noExternal` (using any type).\n\n## ssr.noExternal\n\n- **Type:** `string | RegExp | (string | RegExp)[] | true`\n- **Related:** [SSR Externals](../guide/ssr#ssr-externals)\n\nPrevent listed dependencies from being externalized for SSR, which they will get bundled in build. By default, only linked dependencies are not externalized (for HMR). If you prefer to externalize the linked dependency, you can pass its name to the `ssr.external` option.\n\nIf `true`, no dependencies are externalized. However, dependencies explicitly listed in `ssr.external` (using `string[]` type) can take priority and still be externalized. If `ssr.target: 'node'` is set, Node.js built-ins will also be externalized by default.\n\nNote that if both `ssr.noExternal: true` and `ssr.external: true` are configured, `ssr.noExternal` takes priority and no dependencies are externalized.\n\n## ssr.target\n\n- **Type:** `'node' | 'webworker'`\n- **Default:** `node`\n\nBuild target for the SSR server.\n\n## ssr.resolve.conditions\n\n- **Type:** `string[]`\n- **Related:** [Resolve Conditions](shared-options#resolve-conditions)\n\nDefaults to the the root [`resolve.conditions`](shared-options#resolve-conditions).\n\nThese conditions are used in the plugin pipeline, and only affect non-externalized dependencies during the SSR build. Use `ssr.resolve.externalConditions` to affect externalized imports.\n\n## ssr.resolve.externalConditions\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nConditions that are used during ssr import (including `ssrLoadModule`) of externalized dependencies.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/ssr-options](https://vitejs.dev/config/ssr-options)"
- name: 'SSR Options: ssr.external'
  id: config/ssr-options#ssr-external
  summary: Externalize the given dependencies and their transitive dependencies for SSR
  belongs_to: SSR Options
  description: |-
    ## ssr.external

    - **Type:** `string[] | true`
    - **Related:** [SSR Externals](../guide/ssr#ssr-externals)

    Externalize the given dependencies and their transitive dependencies for SSR. By default, all dependencies are externalized except for linked dependencies (for HMR). If you prefer to externalize the linked dependency, you can pass its name to this option.

    If `true`, all dependencies including linked dependencies are externalized.

    Note that the explicitly listed dependencies (using `string[]` type) will always take priority if they're also listed in `ssr.noExternal` (using any type).
- name: 'SSR Options: ssr.noExternal'
  id: config/ssr-options#ssr-noexternal
  summary: Prevent listed dependencies from being externalized for SSR, which they will get bundled in build
  belongs_to: SSR Options
  description: |-
    ## ssr.noExternal

    - **Type:** `string | RegExp | (string | RegExp)[] | true`
    - **Related:** [SSR Externals](../guide/ssr#ssr-externals)

    Prevent listed dependencies from being externalized for SSR, which they will get bundled in build. By default, only linked dependencies are not externalized (for HMR). If you prefer to externalize the linked dependency, you can pass its name to the `ssr.external` option.

    If `true`, no dependencies are externalized. However, dependencies explicitly listed in `ssr.external` (using `string[]` type) can take priority and still be externalized. If `ssr.target: 'node'` is set, Node.js built-ins will also be externalized by default.

    Note that if both `ssr.noExternal: true` and `ssr.external: true` are configured, `ssr.noExternal` takes priority and no dependencies are externalized.
- name: 'SSR Options: ssr.resolve.conditions'
  id: config/ssr-options#ssr-resolve-conditions
  summary: Defaults to the the root resolve.conditions
  belongs_to: SSR Options
  description: |-
    ## ssr.resolve.conditions

    - **Type:** `string[]`
    - **Related:** [Resolve Conditions](shared-options#resolve-conditions)

    Defaults to the the root [`resolve.conditions`](shared-options#resolve-conditions).

    These conditions are used in the plugin pipeline, and only affect non-externalized dependencies during the SSR build. Use `ssr.resolve.externalConditions` to affect externalized imports.
- name: 'SSR Options: ssr.resolve.externalConditions'
  id: config/ssr-options#ssr-resolve-externalconditions
  summary: Conditions that are used during ssr import (including ssrLoadModule) of externalized dependencies
  belongs_to: SSR Options
  description: "## ssr.resolve.externalConditions\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nConditions that are used during ssr import (including `ssrLoadModule`) of externalized dependencies.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/ssr-options](https://vitejs.dev/config/ssr-options)"
- name: 'SSR Options: ssr.target'
  id: config/ssr-options#ssr-target
  summary: Build target for the SSR server
  belongs_to: SSR Options
  description: |-
    ## ssr.target

    - **Type:** `'node' | 'webworker'`
    - **Default:** `node`

    Build target for the SSR server.
- name: Static Asset Handling
  id: guide/assets
  summary: For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build
  description: "# Static Asset Handling\n\n- Related: [Public Base Path](build#public-base-path)\n- Related: [`assetsInclude` config option](../config/shared-options#assetsinclude)\n\n## Importing Asset as URL\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\n\n``` javascript\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nFor example, `imgUrl` will be `/img.png` during development, and become `/assets/img.2d8efhg.png` in the production build.\n\nThe behavior is similar to webpack's `file-loader`. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.\n\n- `url()` references in CSS are handled the same way.\n\n- If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.\n\n- Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the [`assetsInclude` option](../config/shared-options#assetsinclude).\n\n- Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.\n\n- Assets smaller in bytes than the [`assetsInlineLimit` option](../config/build-options#build-assetsinlinelimit) will be inlined as base64 data URLs.\n\n- Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.\n\n- TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include [`vite/client`](features#client-types).\n\n**Inlining SVGs through `url()`**\n\nWhen passing a URL of SVG to a manually constructed `url()` by JS, the variable should be wrapped within double quotes.\n\njs\n\n``` javascript\nimport imgUrl from './img.svg'\ndocument.getElementById('hero-img').style.background = `url(\"${imgUrl}\")`\n```\n\n### Explicit URL Imports\n\nAssets that are not included in the internal list or in `assetsInclude`, can be explicitly imported as a URL using the `?url` suffix. This is useful, for example, to import [Houdini Paint Worklets](https://houdini.how/usage).\n\njs\n\n``` javascript\nimport workletURL from 'extra-scalloped-border/worklet.js?url'\nCSS.paintWorklet.addModule(workletURL)\n```\n\n### Importing Asset as String\n\nAssets can be imported as strings using the `?raw` suffix.\n\njs\n\n``` javascript\nimport shaderString from './shader.glsl?raw'\n```\n\n### Importing Script as a Worker\n\nScripts can be imported as web workers with the `?worker` or `?sharedworker` suffix.\n\njs\n\n``` javascript\n// Separate chunk in the production build\nimport Worker from './shader.js?worker'\nconst worker = new Worker()\n```\n\njs\n\n``` javascript\n// sharedworker\nimport SharedWorker from './shader.js?sharedworker'\nconst sharedWorker = new SharedWorker()\n```\n\njs\n\n``` javascript\n// Inlined as base64 strings\nimport InlineWorker from './shader.js?worker&inline'\n```\n\nCheck out the [Web Worker section](features#web-workers) for more details.\n\n## The `public` Directory\n\nIf you have assets that are:\n\n- Never referenced in source code (e.g. `robots.txt`)\n- Must retain the exact same file name (without hashing)\n- ...or you simply don't want to have to import an asset first just to get its URL\n\nThen you can place the asset in a special `public` directory under your project root. Assets in this directory will be served at root path `/` during dev, and copied to the root of the dist directory as-is.\n\nThe directory defaults to `<root>/public`, but can be configured via the [`publicDir` option](../config/shared-options#publicdir).\n\nNote that:\n\n- You should always reference `public` assets using root absolute path - for example, `public/icon.png` should be referenced in source code as `/icon.png`.\n- Assets in `public` cannot be imported from JavaScript.\n\n## new URL(url, import.meta.url)\n\n[import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) is a native ESM feature that exposes the current module's URL. Combining it with the native [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL), we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:\n\njs\n\n``` javascript\nconst imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nThis works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!\n\nThis pattern also supports dynamic URLs via template literals:\n\njs\n\n``` javascript\nfunction getImageUrl(name) {\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n```\n\nDuring the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if `build.target` does not support `import.meta.url`\n\njs\n\n``` javascript\n// Vite will not transform this\nconst imgUrl = new URL(imagePath, import.meta.url).href\n```\n\n**Does not work with SSR**\n\nThis pattern does not work if you are using Vite for Server-Side Rendering, because `import.meta.url` have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/assets](https://vitejs.dev/guide/assets)"
- name: 'Static Asset Handling: APIs'
  id: guide/assets
  summary: For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build
  description: "# Static Asset Handling\n\n- Related: [Public Base Path](build#public-base-path)\n- Related: [`assetsInclude` config option](../config/shared-options#assetsinclude)\n\n## Importing Asset as URL\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\n\n``` javascript\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nFor example, `imgUrl` will be `/img.png` during development, and become `/assets/img.2d8efhg.png` in the production build.\n\nThe behavior is similar to webpack's `file-loader`. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.\n\n- `url()` references in CSS are handled the same way.\n\n- If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.\n\n- Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the [`assetsInclude` option](../config/shared-options#assetsinclude).\n\n- Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.\n\n- Assets smaller in bytes than the [`assetsInlineLimit` option](../config/build-options#build-assetsinlinelimit) will be inlined as base64 data URLs.\n\n- Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.\n\n- TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include [`vite/client`](features#client-types).\n\n**Inlining SVGs through `url()`**\n\nWhen passing a URL of SVG to a manually constructed `url()` by JS, the variable should be wrapped within double quotes.\n\njs\n\n``` javascript\nimport imgUrl from './img.svg'\ndocument.getElementById('hero-img').style.background = `url(\"${imgUrl}\")`\n```\n\n### Explicit URL Imports\n\nAssets that are not included in the internal list or in `assetsInclude`, can be explicitly imported as a URL using the `?url` suffix. This is useful, for example, to import [Houdini Paint Worklets](https://houdini.how/usage).\n\njs\n\n``` javascript\nimport workletURL from 'extra-scalloped-border/worklet.js?url'\nCSS.paintWorklet.addModule(workletURL)\n```\n\n### Importing Asset as String\n\nAssets can be imported as strings using the `?raw` suffix.\n\njs\n\n``` javascript\nimport shaderString from './shader.glsl?raw'\n```\n\n### Importing Script as a Worker\n\nScripts can be imported as web workers with the `?worker` or `?sharedworker` suffix.\n\njs\n\n``` javascript\n// Separate chunk in the production build\nimport Worker from './shader.js?worker'\nconst worker = new Worker()\n```\n\njs\n\n``` javascript\n// sharedworker\nimport SharedWorker from './shader.js?sharedworker'\nconst sharedWorker = new SharedWorker()\n```\n\njs\n\n``` javascript\n// Inlined as base64 strings\nimport InlineWorker from './shader.js?worker&inline'\n```\n\nCheck out the [Web Worker section](features#web-workers) for more details.\n\n## The `public` Directory\n\nIf you have assets that are:\n\n- Never referenced in source code (e.g. `robots.txt`)\n- Must retain the exact same file name (without hashing)\n- ...or you simply don't want to have to import an asset first just to get its URL\n\nThen you can place the asset in a special `public` directory under your project root. Assets in this directory will be served at root path `/` during dev, and copied to the root of the dist directory as-is.\n\nThe directory defaults to `<root>/public`, but can be configured via the [`publicDir` option](../config/shared-options#publicdir).\n\nNote that:\n\n- You should always reference `public` assets using root absolute path - for example, `public/icon.png` should be referenced in source code as `/icon.png`.\n- Assets in `public` cannot be imported from JavaScript.\n\n## new URL(url, import.meta.url)\n\n[import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) is a native ESM feature that exposes the current module's URL. Combining it with the native [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL), we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:\n\njs\n\n``` javascript\nconst imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nThis works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!\n\nThis pattern also supports dynamic URLs via template literals:\n\njs\n\n``` javascript\nfunction getImageUrl(name) {\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n```\n\nDuring the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if `build.target` does not support `import.meta.url`\n\njs\n\n``` javascript\n// Vite will not transform this\nconst imgUrl = new URL(imagePath, import.meta.url).href\n```\n\n**Does not work with SSR**\n\nThis pattern does not work if you are using Vite for Server-Side Rendering, because `import.meta.url` have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/assets](https://vitejs.dev/guide/assets)"
- name: 'Static Asset Handling: Explicit URL Imports'
  id: guide/assets#explicit-url-imports
  summary: Assets that are not included in the internal list or in assetsInclude, can be explicitly imported as a URL using the ?url suffix
  belongs_to: Static Asset Handling
  description: |-
    ### Explicit URL Imports

    Assets that are not included in the internal list or in `assetsInclude`, can be explicitly imported as a URL using the `?url` suffix. This is useful, for example, to import [Houdini Paint Worklets](https://houdini.how/usage).

    js

    ``` javascript
    import workletURL from 'extra-scalloped-border/worklet.js?url'
    CSS.paintWorklet.addModule(workletURL)
    ```
- name: 'Static Asset Handling: Guide'
  id: guide/assets
  summary: For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build
  description: "# Static Asset Handling\n\n- Related: [Public Base Path](build#public-base-path)\n- Related: [`assetsInclude` config option](../config/shared-options#assetsinclude)\n\n## Importing Asset as URL\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\n\n``` javascript\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nFor example, `imgUrl` will be `/img.png` during development, and become `/assets/img.2d8efhg.png` in the production build.\n\nThe behavior is similar to webpack's `file-loader`. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.\n\n- `url()` references in CSS are handled the same way.\n\n- If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.\n\n- Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the [`assetsInclude` option](../config/shared-options#assetsinclude).\n\n- Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.\n\n- Assets smaller in bytes than the [`assetsInlineLimit` option](../config/build-options#build-assetsinlinelimit) will be inlined as base64 data URLs.\n\n- Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.\n\n- TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include [`vite/client`](features#client-types).\n\n**Inlining SVGs through `url()`**\n\nWhen passing a URL of SVG to a manually constructed `url()` by JS, the variable should be wrapped within double quotes.\n\njs\n\n``` javascript\nimport imgUrl from './img.svg'\ndocument.getElementById('hero-img').style.background = `url(\"${imgUrl}\")`\n```\n\n### Explicit URL Imports\n\nAssets that are not included in the internal list or in `assetsInclude`, can be explicitly imported as a URL using the `?url` suffix. This is useful, for example, to import [Houdini Paint Worklets](https://houdini.how/usage).\n\njs\n\n``` javascript\nimport workletURL from 'extra-scalloped-border/worklet.js?url'\nCSS.paintWorklet.addModule(workletURL)\n```\n\n### Importing Asset as String\n\nAssets can be imported as strings using the `?raw` suffix.\n\njs\n\n``` javascript\nimport shaderString from './shader.glsl?raw'\n```\n\n### Importing Script as a Worker\n\nScripts can be imported as web workers with the `?worker` or `?sharedworker` suffix.\n\njs\n\n``` javascript\n// Separate chunk in the production build\nimport Worker from './shader.js?worker'\nconst worker = new Worker()\n```\n\njs\n\n``` javascript\n// sharedworker\nimport SharedWorker from './shader.js?sharedworker'\nconst sharedWorker = new SharedWorker()\n```\n\njs\n\n``` javascript\n// Inlined as base64 strings\nimport InlineWorker from './shader.js?worker&inline'\n```\n\nCheck out the [Web Worker section](features#web-workers) for more details.\n\n## The `public` Directory\n\nIf you have assets that are:\n\n- Never referenced in source code (e.g. `robots.txt`)\n- Must retain the exact same file name (without hashing)\n- ...or you simply don't want to have to import an asset first just to get its URL\n\nThen you can place the asset in a special `public` directory under your project root. Assets in this directory will be served at root path `/` during dev, and copied to the root of the dist directory as-is.\n\nThe directory defaults to `<root>/public`, but can be configured via the [`publicDir` option](../config/shared-options#publicdir).\n\nNote that:\n\n- You should always reference `public` assets using root absolute path - for example, `public/icon.png` should be referenced in source code as `/icon.png`.\n- Assets in `public` cannot be imported from JavaScript.\n\n## new URL(url, import.meta.url)\n\n[import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) is a native ESM feature that exposes the current module's URL. Combining it with the native [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL), we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:\n\njs\n\n``` javascript\nconst imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nThis works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!\n\nThis pattern also supports dynamic URLs via template literals:\n\njs\n\n``` javascript\nfunction getImageUrl(name) {\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n```\n\nDuring the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if `build.target` does not support `import.meta.url`\n\njs\n\n``` javascript\n// Vite will not transform this\nconst imgUrl = new URL(imagePath, import.meta.url).href\n```\n\n**Does not work with SSR**\n\nThis pattern does not work if you are using Vite for Server-Side Rendering, because `import.meta.url` have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/assets](https://vitejs.dev/guide/assets)"
- name: 'Static Asset Handling: Importing Asset as String'
  id: guide/assets#importing-asset-as-string
  summary: Assets can be imported as strings using the ?raw suffix
  belongs_to: Static Asset Handling
  description: |-
    ### Importing Asset as String

    Assets can be imported as strings using the `?raw` suffix.

    js

    ``` javascript
    import shaderString from './shader.glsl?raw'
    ```
- name: 'Static Asset Handling: Importing Asset as URL'
  id: guide/assets#importing-asset-as-url
  summary: For example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build
  belongs_to: Static Asset Handling
  description: |-
    ## Importing Asset as URL

    Importing a static asset will return the resolved public URL when it is served:

    js

    ``` javascript
    import imgUrl from './img.png'
    document.getElementById('hero-img').src = imgUrl
    ```

    For example, `imgUrl` will be `/img.png` during development, and become `/assets/img.2d8efhg.png` in the production build.

    The behavior is similar to webpack's `file-loader`. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.

    - `url()` references in CSS are handled the same way.

    - If using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.

    - Common image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the [`assetsInclude` option](../config/shared-options#assetsinclude).

    - Referenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.

    - Assets smaller in bytes than the [`assetsInlineLimit` option](../config/build-options#build-assetsinlinelimit) will be inlined as base64 data URLs.

    - Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.

    - TypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include [`vite/client`](features#client-types).

    **Inlining SVGs through `url()`**

    When passing a URL of SVG to a manually constructed `url()` by JS, the variable should be wrapped within double quotes.

    js

    ``` javascript
    import imgUrl from './img.svg'
    document.getElementById('hero-img').style.background = `url("${imgUrl}")`
    ```
- name: 'Static Asset Handling: Importing Script as a Worker'
  id: guide/assets#importing-script-as-a-worker
  summary: Scripts can be imported as web workers with the ?worker or ?sharedworker suffix
  belongs_to: Static Asset Handling
  description: |-
    ### Importing Script as a Worker

    Scripts can be imported as web workers with the `?worker` or `?sharedworker` suffix.

    js

    ``` javascript
    // Separate chunk in the production build
    import Worker from './shader.js?worker'
    const worker = new Worker()
    ```

    js

    ``` javascript
    // sharedworker
    import SharedWorker from './shader.js?sharedworker'
    const sharedWorker = new SharedWorker()
    ```

    js

    ``` javascript
    // Inlined as base64 strings
    import InlineWorker from './shader.js?worker&inline'
    ```

    Check out the [Web Worker section](features#web-workers) for more details.
- name: 'Static Asset Handling: new URL(url, import.meta.url)'
  id: guide/assets#new-url-url-import-meta-url
  summary: import.meta.url is a native ESM feature that exposes the current module's URL
  belongs_to: Static Asset Handling
  description: "## new URL(url, import.meta.url)\n\n[import.meta.url](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import.meta) is a native ESM feature that exposes the current module's URL. Combining it with the native [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL), we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:\n\njs\n\n``` javascript\nconst imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl\n```\n\nThis works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!\n\nThis pattern also supports dynamic URLs via template literals:\n\njs\n\n``` javascript\nfunction getImageUrl(name) {\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n```\n\nDuring the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if `build.target` does not support `import.meta.url`\n\njs\n\n``` javascript\n// Vite will not transform this\nconst imgUrl = new URL(imagePath, import.meta.url).href\n```\n\n**Does not work with SSR**\n\nThis pattern does not work if you are using Vite for Server-Side Rendering, because `import.meta.url` have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/assets](https://vitejs.dev/guide/assets)"
- name: 'Static Asset Handling: The public Directory'
  id: guide/assets#the-public-directory
  summary: Then you can place the asset in a special public directory under your project root
  belongs_to: Static Asset Handling
  description: |-
    ## The `public` Directory

    If you have assets that are:

    - Never referenced in source code (e.g. `robots.txt`)
    - Must retain the exact same file name (without hashing)
    - ...or you simply don't want to have to import an asset first just to get its URL

    Then you can place the asset in a special `public` directory under your project root. Assets in this directory will be served at root path `/` during dev, and copied to the root of the dist directory as-is.

    The directory defaults to `<root>/public`, but can be configured via the [`publicDir` option](../config/shared-options#publicdir).

    Note that:

    - You should always reference `public` assets using root absolute path - for example, `public/icon.png` should be referenced in source code as `/icon.png`.
    - Assets in `public` cannot be imported from JavaScript.

    &nbsp;
- name: Troubleshooting
  id: guide/troubleshooting
  summary: See Rollup's troubleshooting guide for more information too
  description: "# Troubleshooting\n\nSee [Rollup's troubleshooting guide](https://rollupjs.org/troubleshooting/) for more information too.\n\nIf the suggestions here don't work, please try posting questions on [GitHub Discussions](https://github.com/vitejs/vite/discussions) or in the `#help` channel of [Vite Land Discord](https://chat.vitejs.dev).\n\n## CJS\n\n### Vite CJS Node API deprecated\n\nThe CJS build of Vite's Node API is deprecated and will be removed in Vite 6. See the [GitHub discussion](https://github.com/vitejs/vite/discussions/13928) for more context. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\n1.  The `vite.config.js` file content is using the ESM syntax.\n2.  The closest `package.json` file has `\"type\": \"module\"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.\n\nFor other projects, there are a few general approaches:\n\n- **Configure ESM as default, opt-in to CJS if needed:** Add `\"type\": \"module\"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.\n- **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `\"type\": \"module\"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.\n- **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.\n\nIf you're unsure where the warning is coming from, you can run your script with the `VITE_CJS_TRACE=true` flag to log the stack trace:\n\nbash\n\n``` javascript\nVITE_CJS_TRACE=true vite dev\n```\n\nIf you'd like to temporarily ignore the warning, you can run your script with the `VITE_CJS_IGNORE_WARNING=true` flag:\n\nbash\n\n``` javascript\nVITE_CJS_IGNORE_WARNING=true vite dev\n```\n\nNote that postcss config files does not support ESM + TypeScript (`.mts` or `.ts` in `\"type\": \"module\"`) yet. If you have postcss configs with `.ts` and added `\"type\": \"module\"` to package.json, you'll also need to rename the postcss config to use `.cts`.\n\n## CLI\n\n### `Error: Cannot find module 'C:\\foo\\bar&baz\\vite\\bin\\vite.js'`\n\nThe path to your project folder may include `&`, which doesn't work with `npm` on Windows ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45)).\n\nYou will need to either:\n\n- Switch to another package manager (e.g. `pnpm`, `yarn`)\n- Remove `&` from the path to your project\n\n## Config\n\n### This package is ESM only\n\nWhen importing a ESM only package by `require`, the following error happens.\n\n> Failed to resolve \"foo\". This package is ESM only but it was tried to load by `require`.\n\n> \"foo\" resolved to an ESM file. ESM file cannot be loaded by `require`.\n\nESM files cannot be loaded by [`require`](https://nodejs.org/docs/latest-v18.x/api/esm.html#require:~:text=Using%20require%20to%20load%20an%20ES%20module%20is%20not%20supported%20because%20ES%20modules%20have%20asynchronous%20execution.%20Instead%2C%20use%20import()%20to%20load%20an%20ES%20module%20from%20a%20CommonJS%20module.).\n\nWe recommend converting your config to ESM by either:\n\n- adding `\"type\": \"module\"` to the nearest `package.json`\n- renaming `vite.config.js`/`vite.config.ts` to `vite.config.mjs`/`vite.config.mts`\n\n## Dev Server\n\n### Requests are stalled forever\n\nIf you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.\n\nTo solve this:\n\n- Increase file descriptor limit by `ulimit`\n\n  shell\n  ``` javascript\n  # Check current limit\n  $ ulimit -Sn\n  # Change limit (temporary)\n  $ ulimit -Sn 10000 # You might need to change the hard limit too\n  # Restart your browser\n  ```\n\n- Increase the following inotify related limits by `sysctl`\n\n  shell\n  ``` javascript\n  # Check current limits\n  $ sysctl fs.inotify\n  # Change limits (temporary)\n  $ sudo sysctl fs.inotify.max_queued_events=16384\n  $ sudo sysctl fs.inotify.max_user_instances=8192\n  $ sudo sysctl fs.inotify.max_user_watches=524288\n  ```\n\nIf the above steps don't work, you can try adding `DefaultLimitNOFILE=65536` as an un-commented config to the following files:\n\n- /etc/systemd/system.conf\n- /etc/systemd/user.conf\n\nFor Ubuntu Linux, you may need to add the line `* - nofile 65536` to the file `/etc/security/limits.conf` instead of updating systemd config files.\n\nNote that these settings persist but a **restart is required**.\n\n### Network requests stop loading\n\nWhen using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.\n\nTo resolve the problem use a trusted SSL cert.\n\nSee: [Cache problems](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html), [Chrome issue](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)\n\n#### macOS\n\nYou can install a trusted cert via the CLI with this command:\n\n``` javascript\nsecurity add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer\n```\n\nOr, by importing it into the Keychain Access app and updating the trust of your cert to \"Always Trust.\"\n\n### 431 Request Header Fields Too Large\n\nWhen the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.\n\n> Server responded with status code 431. See [https://vitejs.dev/guide/troubleshooting.html#\\_431-request-header-fields-too-large](troubleshooting#_431-request-header-fields-too-large).\n\nThis is because Node.js limits request header size to mitigate [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121).\n\nTo avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize) to change max header size.\n\n## HMR\n\n### Vite detects a file change but the HMR is not working\n\nYou may be importing a file with a different case. For example, `src/foo.js` exists and `src/bar.js` contains:\n\njs\n\n``` javascript\nimport './Foo.js' // should be './foo.js'\n```\n\nRelated issue: [\\#964](https://github.com/vitejs/vite/issues/964)\n\n### Vite does not detect a file change\n\nIf you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See [`server.watch` option](../config/server-options#server-watch).\n\n### A full reload happens instead of HMR\n\nIf HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.\n\nIf HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run `vite --debug hmr` to log the circular dependency path if a file change triggered it.\n\n## Build\n\n### Built file does not work because of CORS error\n\nIf the HTML file output was opened with `file` protocol, the scripts won't run with the following error.\n\n> Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.\n\n> Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).\n\nSee [Reason: CORS request not HTTP - HTTP \\| MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) for more information about why this happens.\n\nYou will need to access the file with `http` protocol. The easiest way to achieve this is to run `npx vite preview`.\n\n## Optimized Dependencies\n\n### Outdated pre-bundled deps when linking to a local package\n\nThe hash key used to invalidate optimized dependencies depend on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link). In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using `vite --force`. We recommend using overrides instead, which are supported now by every package manager (see also [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides) and [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)).\n\n## Performance bottlenecks\n\nIf you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:\n\ndev serverbuild\n\nbash\n\n``` javascript\nvite --profile --open\n```\n\nbash\n\n``` javascript\nvite build --profile\n```\n\n**Vite Dev Server**\n\nOnce your application is opened in the browser, just await finish loading it and then go back to the terminal and press `p` key (will stop the Node.js inspector) then press `q` key to stop the dev server.\n\nNode.js inspector will generate `vite-profile-0.cpuprofile` in the root folder, go to [https://www.speedscope.app/](https://www.speedscope.app/), and upload the CPU profile using the `BROWSE` button to inspect the result.\n\nYou can install [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect), which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.\n\n## Others\n\n### Module externalized for browser compatibility\n\nWhen you use a Node.js module in the browser, Vite will output the following warning.\n\n> Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.readFile\" in client code.\n\nThis is because Vite does not automatically polyfill Node.js modules.\n\nWe recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.\n\n### Syntax Error / Type Error happens\n\nVite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) inside ESM.\n\nFor example, you might see these errors.\n\n> \\[ERROR\\] With statements cannot be used with the \"esm\" output format due to strict mode\n\n> TypeError: Cannot create property 'foo' on boolean 'false'\n\nIf these code are used inside dependencies, you could use [`patch-package`](https://github.com/ds300/patch-package) (or [`yarn patch`](https://yarnpkg.com/cli/patch) or [`pnpm patch`](https://pnpm.io/cli/patch)) for an escape hatch.\n\n### Browser extensions\n\nSome browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.\n\n### Cross drive links on Windows\n\nIf there's a cross drive links in your project on Windows, Vite may not work.\n\nAn example of cross drive links are:\n\n- a virtual drive linked to a folder by `subst` command\n- a symlink/junction to a different drive by `mklink` command (e.g. Yarn global cache)\n\nRelated issue: [\\#10802](https://github.com/vitejs/vite/issues/10802)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/troubleshooting](https://vitejs.dev/guide/troubleshooting)"
- name: 'Troubleshooting: 431 Request Header Fields Too Large'
  id: guide/troubleshooting#_431-request-header-fields-too-large
  summary: When the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown
  belongs_to: Troubleshooting
  description: |-
    ### 431 Request Header Fields Too Large

    When the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.

    > Server responded with status code 431. See [https://vitejs.dev/guide/troubleshooting.html#\_431-request-header-fields-too-large](troubleshooting#_431-request-header-fields-too-large).

    This is because Node.js limits request header size to mitigate [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121).

    To avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize) to change max header size.
- name: 'Troubleshooting: A full reload happens instead of HMR'
  id: guide/troubleshooting#a-full-reload-happens-instead-of-hmr
  summary: If HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state
  belongs_to: Troubleshooting
  description: |-
    ### A full reload happens instead of HMR

    If HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.

    If HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run `vite --debug hmr` to log the circular dependency path if a file change triggered it.
- name: 'Troubleshooting: APIs'
  id: guide/troubleshooting
  summary: See Rollup's troubleshooting guide for more information too
  description: "# Troubleshooting\n\nSee [Rollup's troubleshooting guide](https://rollupjs.org/troubleshooting/) for more information too.\n\nIf the suggestions here don't work, please try posting questions on [GitHub Discussions](https://github.com/vitejs/vite/discussions) or in the `#help` channel of [Vite Land Discord](https://chat.vitejs.dev).\n\n## CJS\n\n### Vite CJS Node API deprecated\n\nThe CJS build of Vite's Node API is deprecated and will be removed in Vite 6. See the [GitHub discussion](https://github.com/vitejs/vite/discussions/13928) for more context. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\n1.  The `vite.config.js` file content is using the ESM syntax.\n2.  The closest `package.json` file has `\"type\": \"module\"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.\n\nFor other projects, there are a few general approaches:\n\n- **Configure ESM as default, opt-in to CJS if needed:** Add `\"type\": \"module\"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.\n- **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `\"type\": \"module\"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.\n- **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.\n\nIf you're unsure where the warning is coming from, you can run your script with the `VITE_CJS_TRACE=true` flag to log the stack trace:\n\nbash\n\n``` javascript\nVITE_CJS_TRACE=true vite dev\n```\n\nIf you'd like to temporarily ignore the warning, you can run your script with the `VITE_CJS_IGNORE_WARNING=true` flag:\n\nbash\n\n``` javascript\nVITE_CJS_IGNORE_WARNING=true vite dev\n```\n\nNote that postcss config files does not support ESM + TypeScript (`.mts` or `.ts` in `\"type\": \"module\"`) yet. If you have postcss configs with `.ts` and added `\"type\": \"module\"` to package.json, you'll also need to rename the postcss config to use `.cts`.\n\n## CLI\n\n### `Error: Cannot find module 'C:\\foo\\bar&baz\\vite\\bin\\vite.js'`\n\nThe path to your project folder may include `&`, which doesn't work with `npm` on Windows ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45)).\n\nYou will need to either:\n\n- Switch to another package manager (e.g. `pnpm`, `yarn`)\n- Remove `&` from the path to your project\n\n## Config\n\n### This package is ESM only\n\nWhen importing a ESM only package by `require`, the following error happens.\n\n> Failed to resolve \"foo\". This package is ESM only but it was tried to load by `require`.\n\n> \"foo\" resolved to an ESM file. ESM file cannot be loaded by `require`.\n\nESM files cannot be loaded by [`require`](https://nodejs.org/docs/latest-v18.x/api/esm.html#require:~:text=Using%20require%20to%20load%20an%20ES%20module%20is%20not%20supported%20because%20ES%20modules%20have%20asynchronous%20execution.%20Instead%2C%20use%20import()%20to%20load%20an%20ES%20module%20from%20a%20CommonJS%20module.).\n\nWe recommend converting your config to ESM by either:\n\n- adding `\"type\": \"module\"` to the nearest `package.json`\n- renaming `vite.config.js`/`vite.config.ts` to `vite.config.mjs`/`vite.config.mts`\n\n## Dev Server\n\n### Requests are stalled forever\n\nIf you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.\n\nTo solve this:\n\n- Increase file descriptor limit by `ulimit`\n\n  shell\n  ``` javascript\n  # Check current limit\n  $ ulimit -Sn\n  # Change limit (temporary)\n  $ ulimit -Sn 10000 # You might need to change the hard limit too\n  # Restart your browser\n  ```\n\n- Increase the following inotify related limits by `sysctl`\n\n  shell\n  ``` javascript\n  # Check current limits\n  $ sysctl fs.inotify\n  # Change limits (temporary)\n  $ sudo sysctl fs.inotify.max_queued_events=16384\n  $ sudo sysctl fs.inotify.max_user_instances=8192\n  $ sudo sysctl fs.inotify.max_user_watches=524288\n  ```\n\nIf the above steps don't work, you can try adding `DefaultLimitNOFILE=65536` as an un-commented config to the following files:\n\n- /etc/systemd/system.conf\n- /etc/systemd/user.conf\n\nFor Ubuntu Linux, you may need to add the line `* - nofile 65536` to the file `/etc/security/limits.conf` instead of updating systemd config files.\n\nNote that these settings persist but a **restart is required**.\n\n### Network requests stop loading\n\nWhen using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.\n\nTo resolve the problem use a trusted SSL cert.\n\nSee: [Cache problems](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html), [Chrome issue](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)\n\n#### macOS\n\nYou can install a trusted cert via the CLI with this command:\n\n``` javascript\nsecurity add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer\n```\n\nOr, by importing it into the Keychain Access app and updating the trust of your cert to \"Always Trust.\"\n\n### 431 Request Header Fields Too Large\n\nWhen the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.\n\n> Server responded with status code 431. See [https://vitejs.dev/guide/troubleshooting.html#\\_431-request-header-fields-too-large](troubleshooting#_431-request-header-fields-too-large).\n\nThis is because Node.js limits request header size to mitigate [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121).\n\nTo avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize) to change max header size.\n\n## HMR\n\n### Vite detects a file change but the HMR is not working\n\nYou may be importing a file with a different case. For example, `src/foo.js` exists and `src/bar.js` contains:\n\njs\n\n``` javascript\nimport './Foo.js' // should be './foo.js'\n```\n\nRelated issue: [\\#964](https://github.com/vitejs/vite/issues/964)\n\n### Vite does not detect a file change\n\nIf you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See [`server.watch` option](../config/server-options#server-watch).\n\n### A full reload happens instead of HMR\n\nIf HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.\n\nIf HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run `vite --debug hmr` to log the circular dependency path if a file change triggered it.\n\n## Build\n\n### Built file does not work because of CORS error\n\nIf the HTML file output was opened with `file` protocol, the scripts won't run with the following error.\n\n> Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.\n\n> Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).\n\nSee [Reason: CORS request not HTTP - HTTP \\| MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) for more information about why this happens.\n\nYou will need to access the file with `http` protocol. The easiest way to achieve this is to run `npx vite preview`.\n\n## Optimized Dependencies\n\n### Outdated pre-bundled deps when linking to a local package\n\nThe hash key used to invalidate optimized dependencies depend on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link). In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using `vite --force`. We recommend using overrides instead, which are supported now by every package manager (see also [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides) and [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)).\n\n## Performance bottlenecks\n\nIf you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:\n\ndev serverbuild\n\nbash\n\n``` javascript\nvite --profile --open\n```\n\nbash\n\n``` javascript\nvite build --profile\n```\n\n**Vite Dev Server**\n\nOnce your application is opened in the browser, just await finish loading it and then go back to the terminal and press `p` key (will stop the Node.js inspector) then press `q` key to stop the dev server.\n\nNode.js inspector will generate `vite-profile-0.cpuprofile` in the root folder, go to [https://www.speedscope.app/](https://www.speedscope.app/), and upload the CPU profile using the `BROWSE` button to inspect the result.\n\nYou can install [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect), which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.\n\n## Others\n\n### Module externalized for browser compatibility\n\nWhen you use a Node.js module in the browser, Vite will output the following warning.\n\n> Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.readFile\" in client code.\n\nThis is because Vite does not automatically polyfill Node.js modules.\n\nWe recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.\n\n### Syntax Error / Type Error happens\n\nVite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) inside ESM.\n\nFor example, you might see these errors.\n\n> \\[ERROR\\] With statements cannot be used with the \"esm\" output format due to strict mode\n\n> TypeError: Cannot create property 'foo' on boolean 'false'\n\nIf these code are used inside dependencies, you could use [`patch-package`](https://github.com/ds300/patch-package) (or [`yarn patch`](https://yarnpkg.com/cli/patch) or [`pnpm patch`](https://pnpm.io/cli/patch)) for an escape hatch.\n\n### Browser extensions\n\nSome browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.\n\n### Cross drive links on Windows\n\nIf there's a cross drive links in your project on Windows, Vite may not work.\n\nAn example of cross drive links are:\n\n- a virtual drive linked to a folder by `subst` command\n- a symlink/junction to a different drive by `mklink` command (e.g. Yarn global cache)\n\nRelated issue: [\\#10802](https://github.com/vitejs/vite/issues/10802)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/troubleshooting](https://vitejs.dev/guide/troubleshooting)"
- name: 'Troubleshooting: Browser extensions'
  id: guide/troubleshooting#browser-extensions
  summary: Some browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server
  belongs_to: Troubleshooting
  description: |-
    ### Browser extensions

    Some browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.
- name: 'Troubleshooting: Build'
  id: guide/troubleshooting#build
  summary: null
  belongs_to: Troubleshooting
  description: '## Build'
- name: 'Troubleshooting: Built file does not work because of CORS error'
  id: guide/troubleshooting#built-file-does-not-work-because-of-cors-error
  summary: If the HTML file output was opened with file protocol, the scripts won't run with the following error
  belongs_to: Troubleshooting
  description: |-
    ### Built file does not work because of CORS error

    If the HTML file output was opened with `file` protocol, the scripts won't run with the following error.

    > Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.

    > Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).

    See [Reason: CORS request not HTTP - HTTP \| MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) for more information about why this happens.

    You will need to access the file with `http` protocol. The easiest way to achieve this is to run `npx vite preview`.
- name: 'Troubleshooting: CJS'
  id: guide/troubleshooting#cjs
  summary: null
  belongs_to: Troubleshooting
  description: '## CJS'
- name: 'Troubleshooting: CLI'
  id: guide/troubleshooting#cli
  summary: null
  belongs_to: Troubleshooting
  description: '## CLI'
- name: 'Troubleshooting: Config'
  id: guide/troubleshooting#config
  summary: null
  belongs_to: Troubleshooting
  description: '## Config'
- name: 'Troubleshooting: Cross drive links on Windows'
  id: guide/troubleshooting#cross-drive-links-on-windows
  summary: If there's a cross drive links in your project on Windows, Vite may not work
  belongs_to: Troubleshooting
  description: "### Cross drive links on Windows\n\nIf there's a cross drive links in your project on Windows, Vite may not work.\n\nAn example of cross drive links are:\n\n- a virtual drive linked to a folder by `subst` command\n- a symlink/junction to a different drive by `mklink` command (e.g. Yarn global cache)\n\nRelated issue: [\\#10802](https://github.com/vitejs/vite/issues/10802)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/troubleshooting](https://vitejs.dev/guide/troubleshooting)"
- name: 'Troubleshooting: Dev Server'
  id: guide/troubleshooting#dev-server
  summary: null
  belongs_to: Troubleshooting
  description: '## Dev Server'
- name: 'Troubleshooting: Error: Cannot find module ''C:\foo\bar&baz\vite\bin\vite.js'''
  id: guide/troubleshooting#error-cannot-find-module-c-foo-bar-baz-vite-bin-vite-js
  summary: null
  belongs_to: Troubleshooting
  description: |-
    ### `Error: Cannot find module 'C:\foo\bar&baz\vite\bin\vite.js'`

    The path to your project folder may include `&`, which doesn't work with `npm` on Windows ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45)).

    You will need to either:

    - Switch to another package manager (e.g. `pnpm`, `yarn`)
    - Remove `&` from the path to your project
- name: 'Troubleshooting: Guide'
  id: guide/troubleshooting
  summary: See Rollup's troubleshooting guide for more information too
  description: "# Troubleshooting\n\nSee [Rollup's troubleshooting guide](https://rollupjs.org/troubleshooting/) for more information too.\n\nIf the suggestions here don't work, please try posting questions on [GitHub Discussions](https://github.com/vitejs/vite/discussions) or in the `#help` channel of [Vite Land Discord](https://chat.vitejs.dev).\n\n## CJS\n\n### Vite CJS Node API deprecated\n\nThe CJS build of Vite's Node API is deprecated and will be removed in Vite 6. See the [GitHub discussion](https://github.com/vitejs/vite/discussions/13928) for more context. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\n1.  The `vite.config.js` file content is using the ESM syntax.\n2.  The closest `package.json` file has `\"type\": \"module\"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.\n\nFor other projects, there are a few general approaches:\n\n- **Configure ESM as default, opt-in to CJS if needed:** Add `\"type\": \"module\"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.\n- **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `\"type\": \"module\"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.\n- **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.\n\nIf you're unsure where the warning is coming from, you can run your script with the `VITE_CJS_TRACE=true` flag to log the stack trace:\n\nbash\n\n``` javascript\nVITE_CJS_TRACE=true vite dev\n```\n\nIf you'd like to temporarily ignore the warning, you can run your script with the `VITE_CJS_IGNORE_WARNING=true` flag:\n\nbash\n\n``` javascript\nVITE_CJS_IGNORE_WARNING=true vite dev\n```\n\nNote that postcss config files does not support ESM + TypeScript (`.mts` or `.ts` in `\"type\": \"module\"`) yet. If you have postcss configs with `.ts` and added `\"type\": \"module\"` to package.json, you'll also need to rename the postcss config to use `.cts`.\n\n## CLI\n\n### `Error: Cannot find module 'C:\\foo\\bar&baz\\vite\\bin\\vite.js'`\n\nThe path to your project folder may include `&`, which doesn't work with `npm` on Windows ([npm/cmd-shim#45](https://github.com/npm/cmd-shim/issues/45)).\n\nYou will need to either:\n\n- Switch to another package manager (e.g. `pnpm`, `yarn`)\n- Remove `&` from the path to your project\n\n## Config\n\n### This package is ESM only\n\nWhen importing a ESM only package by `require`, the following error happens.\n\n> Failed to resolve \"foo\". This package is ESM only but it was tried to load by `require`.\n\n> \"foo\" resolved to an ESM file. ESM file cannot be loaded by `require`.\n\nESM files cannot be loaded by [`require`](https://nodejs.org/docs/latest-v18.x/api/esm.html#require:~:text=Using%20require%20to%20load%20an%20ES%20module%20is%20not%20supported%20because%20ES%20modules%20have%20asynchronous%20execution.%20Instead%2C%20use%20import()%20to%20load%20an%20ES%20module%20from%20a%20CommonJS%20module.).\n\nWe recommend converting your config to ESM by either:\n\n- adding `\"type\": \"module\"` to the nearest `package.json`\n- renaming `vite.config.js`/`vite.config.ts` to `vite.config.mjs`/`vite.config.mts`\n\n## Dev Server\n\n### Requests are stalled forever\n\nIf you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.\n\nTo solve this:\n\n- Increase file descriptor limit by `ulimit`\n\n  shell\n  ``` javascript\n  # Check current limit\n  $ ulimit -Sn\n  # Change limit (temporary)\n  $ ulimit -Sn 10000 # You might need to change the hard limit too\n  # Restart your browser\n  ```\n\n- Increase the following inotify related limits by `sysctl`\n\n  shell\n  ``` javascript\n  # Check current limits\n  $ sysctl fs.inotify\n  # Change limits (temporary)\n  $ sudo sysctl fs.inotify.max_queued_events=16384\n  $ sudo sysctl fs.inotify.max_user_instances=8192\n  $ sudo sysctl fs.inotify.max_user_watches=524288\n  ```\n\nIf the above steps don't work, you can try adding `DefaultLimitNOFILE=65536` as an un-commented config to the following files:\n\n- /etc/systemd/system.conf\n- /etc/systemd/user.conf\n\nFor Ubuntu Linux, you may need to add the line `* - nofile 65536` to the file `/etc/security/limits.conf` instead of updating systemd config files.\n\nNote that these settings persist but a **restart is required**.\n\n### Network requests stop loading\n\nWhen using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.\n\nTo resolve the problem use a trusted SSL cert.\n\nSee: [Cache problems](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html), [Chrome issue](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)\n\n#### macOS\n\nYou can install a trusted cert via the CLI with this command:\n\n``` javascript\nsecurity add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer\n```\n\nOr, by importing it into the Keychain Access app and updating the trust of your cert to \"Always Trust.\"\n\n### 431 Request Header Fields Too Large\n\nWhen the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.\n\n> Server responded with status code 431. See [https://vitejs.dev/guide/troubleshooting.html#\\_431-request-header-fields-too-large](troubleshooting#_431-request-header-fields-too-large).\n\nThis is because Node.js limits request header size to mitigate [CVE-2018-12121](https://www.cve.org/CVERecord?id=CVE-2018-12121).\n\nTo avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use [`--max-http-header-size`](https://nodejs.org/api/cli.html#--max-http-header-sizesize) to change max header size.\n\n## HMR\n\n### Vite detects a file change but the HMR is not working\n\nYou may be importing a file with a different case. For example, `src/foo.js` exists and `src/bar.js` contains:\n\njs\n\n``` javascript\nimport './Foo.js' // should be './foo.js'\n```\n\nRelated issue: [\\#964](https://github.com/vitejs/vite/issues/964)\n\n### Vite does not detect a file change\n\nIf you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See [`server.watch` option](../config/server-options#server-watch).\n\n### A full reload happens instead of HMR\n\nIf HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.\n\nIf HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run `vite --debug hmr` to log the circular dependency path if a file change triggered it.\n\n## Build\n\n### Built file does not work because of CORS error\n\nIf the HTML file output was opened with `file` protocol, the scripts won't run with the following error.\n\n> Access to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.\n\n> Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).\n\nSee [Reason: CORS request not HTTP - HTTP \\| MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS/Errors/CORSRequestNotHttp) for more information about why this happens.\n\nYou will need to access the file with `http` protocol. The easiest way to achieve this is to run `npx vite preview`.\n\n## Optimized Dependencies\n\n### Outdated pre-bundled deps when linking to a local package\n\nThe hash key used to invalidate optimized dependencies depend on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link). In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using `vite --force`. We recommend using overrides instead, which are supported now by every package manager (see also [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides) and [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)).\n\n## Performance bottlenecks\n\nIf you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:\n\ndev serverbuild\n\nbash\n\n``` javascript\nvite --profile --open\n```\n\nbash\n\n``` javascript\nvite build --profile\n```\n\n**Vite Dev Server**\n\nOnce your application is opened in the browser, just await finish loading it and then go back to the terminal and press `p` key (will stop the Node.js inspector) then press `q` key to stop the dev server.\n\nNode.js inspector will generate `vite-profile-0.cpuprofile` in the root folder, go to [https://www.speedscope.app/](https://www.speedscope.app/), and upload the CPU profile using the `BROWSE` button to inspect the result.\n\nYou can install [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect), which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.\n\n## Others\n\n### Module externalized for browser compatibility\n\nWhen you use a Node.js module in the browser, Vite will output the following warning.\n\n> Module \"fs\" has been externalized for browser compatibility. Cannot access \"fs.readFile\" in client code.\n\nThis is because Vite does not automatically polyfill Node.js modules.\n\nWe recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.\n\n### Syntax Error / Type Error happens\n\nVite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) inside ESM.\n\nFor example, you might see these errors.\n\n> \\[ERROR\\] With statements cannot be used with the \"esm\" output format due to strict mode\n\n> TypeError: Cannot create property 'foo' on boolean 'false'\n\nIf these code are used inside dependencies, you could use [`patch-package`](https://github.com/ds300/patch-package) (or [`yarn patch`](https://yarnpkg.com/cli/patch) or [`pnpm patch`](https://pnpm.io/cli/patch)) for an escape hatch.\n\n### Browser extensions\n\nSome browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.\n\n### Cross drive links on Windows\n\nIf there's a cross drive links in your project on Windows, Vite may not work.\n\nAn example of cross drive links are:\n\n- a virtual drive linked to a folder by `subst` command\n- a symlink/junction to a different drive by `mklink` command (e.g. Yarn global cache)\n\nRelated issue: [\\#10802](https://github.com/vitejs/vite/issues/10802)\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/troubleshooting](https://vitejs.dev/guide/troubleshooting)"
- name: 'Troubleshooting: HMR'
  id: guide/troubleshooting#hmr
  summary: null
  belongs_to: Troubleshooting
  description: '## HMR'
- name: 'Troubleshooting: Module externalized for browser compatibility'
  id: guide/troubleshooting#module-externalized-for-browser-compatibility
  summary: When you use a Node.js module in the browser, Vite will output the following warning
  belongs_to: Troubleshooting
  description: |-
    ### Module externalized for browser compatibility

    When you use a Node.js module in the browser, Vite will output the following warning.

    > Module "fs" has been externalized for browser compatibility. Cannot access "fs.readFile" in client code.

    This is because Vite does not automatically polyfill Node.js modules.

    We recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.
- name: 'Troubleshooting: Network requests stop loading'
  id: guide/troubleshooting#network-requests-stop-loading
  summary: When using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content
  belongs_to: Troubleshooting
  description: |-
    ### Network requests stop loading

    When using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.

    To resolve the problem use a trusted SSL cert.

    See: [Cache problems](https://helpx.adobe.com/mt/experience-manager/kb/cache-problems-on-chrome-with-SSL-certificate-errors.html), [Chrome issue](https://bugs.chromium.org/p/chromium/issues/detail?id=110649#c8)

    #### macOS

    You can install a trusted cert via the CLI with this command:

    ``` javascript
    security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer
    ```

    Or, by importing it into the Keychain Access app and updating the trust of your cert to "Always Trust."
- name: 'Troubleshooting: Optimized Dependencies'
  id: guide/troubleshooting#optimized-dependencies
  summary: null
  belongs_to: Troubleshooting
  description: '## Optimized Dependencies'
- name: 'Troubleshooting: Others'
  id: guide/troubleshooting#others
  summary: null
  belongs_to: Troubleshooting
  description: '## Others'
- name: 'Troubleshooting: Outdated pre-bundled deps when linking to a local package'
  id: guide/troubleshooting#outdated-pre-bundled-deps-when-linking-to-a-local-package
  summary: The hash key used to invalidate optimized dependencies depend on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules
  belongs_to: Troubleshooting
  description: |-
    ### Outdated pre-bundled deps when linking to a local package

    The hash key used to invalidate optimized dependencies depend on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as [npm overrides](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like [npm link](https://docs.npmjs.com/cli/v9/commands/npm-link). In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using `vite --force`. We recommend using overrides instead, which are supported now by every package manager (see also [pnpm overrides](https://pnpm.io/package_json#pnpmoverrides) and [yarn resolutions](https://yarnpkg.com/configuration/manifest/#resolutions)).
- name: 'Troubleshooting: Performance bottlenecks'
  id: guide/troubleshooting#performance-bottlenecks
  summary: Once your application is opened in the browser, just await finish loading it and then go back to the terminal and press p key (will stop the Node.js inspector) then press q key to stop the dev server
  belongs_to: Troubleshooting
  description: |-
    ## Performance bottlenecks

    If you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:

    dev server build

    bash

    ``` javascript
    vite --profile --open
    ```

    bash

    ``` javascript
    vite build --profile
    ```

    **Vite Dev Server**

    Once your application is opened in the browser, just await finish loading it and then go back to the terminal and press `p` key (will stop the Node.js inspector) then press `q` key to stop the dev server.

    Node.js inspector will generate `vite-profile-0.cpuprofile` in the root folder, go to [https://www.speedscope.app/](https://www.speedscope.app/), and upload the CPU profile using the `BROWSE` button to inspect the result.

    You can install [vite-plugin-inspect](https://github.com/antfu/vite-plugin-inspect), which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.
- name: 'Troubleshooting: Requests are stalled forever'
  id: guide/troubleshooting#requests-are-stalled-forever
  summary: If you are using Linux, file descriptor limits and inotify limits may be causing the issue
  belongs_to: Troubleshooting
  description: |-
    ### Requests are stalled forever

    If you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.

    To solve this:

    - Increase file descriptor limit by `ulimit`

      shell
      ``` javascript
      # Check current limit
      $ ulimit -Sn
      # Change limit (temporary)
      $ ulimit -Sn 10000 # You might need to change the hard limit too
      # Restart your browser
      ```

    - Increase the following inotify related limits by `sysctl`

      shell
      ``` javascript
      # Check current limits
      $ sysctl fs.inotify
      # Change limits (temporary)
      $ sudo sysctl fs.inotify.max_queued_events=16384
      $ sudo sysctl fs.inotify.max_user_instances=8192
      $ sudo sysctl fs.inotify.max_user_watches=524288
      ```

    If the above steps don't work, you can try adding `DefaultLimitNOFILE=65536` as an un-commented config to the following files:

    - /etc/systemd/system.conf
    - /etc/systemd/user.conf

    For Ubuntu Linux, you may need to add the line `* - nofile 65536` to the file `/etc/security/limits.conf` instead of updating systemd config files.

    Note that these settings persist but a **restart is required**.
- name: 'Troubleshooting: Syntax Error / Type Error happens'
  id: guide/troubleshooting#syntax-error-type-error-happens
  summary: Vite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always strict mode inside ESM
  belongs_to: Troubleshooting
  description: |-
    ### Syntax Error / Type Error happens

    Vite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) inside ESM.

    For example, you might see these errors.

    > \[ERROR\] With statements cannot be used with the "esm" output format due to strict mode

    > TypeError: Cannot create property 'foo' on boolean 'false'

    If these code are used inside dependencies, you could use [`patch-package`](https://github.com/ds300/patch-package) (or [`yarn patch`](https://yarnpkg.com/cli/patch) or [`pnpm patch`](https://pnpm.io/cli/patch)) for an escape hatch.
- name: 'Troubleshooting: This package is ESM only'
  id: guide/troubleshooting#this-package-is-esm-only
  summary: When importing a ESM only package by require, the following error happens
  belongs_to: Troubleshooting
  description: |-
    ### This package is ESM only

    When importing a ESM only package by `require`, the following error happens.

    > Failed to resolve "foo". This package is ESM only but it was tried to load by `require`.

    > "foo" resolved to an ESM file. ESM file cannot be loaded by `require`.

    ESM files cannot be loaded by [`require`](https://nodejs.org/docs/latest-v18.x/api/esm.html#require:~:text=Using%20require%20to%20load%20an%20ES%20module%20is%20not%20supported%20because%20ES%20modules%20have%20asynchronous%20execution.%20Instead%2C%20use%20import()%20to%20load%20an%20ES%20module%20from%20a%20CommonJS%20module.).

    We recommend converting your config to ESM by either:

    - adding `"type": "module"` to the nearest `package.json`
    - renaming `vite.config.js`/`vite.config.ts` to `vite.config.mjs`/`vite.config.mts`

    &nbsp;
- name: 'Troubleshooting: Vite CJS Node API deprecated'
  id: guide/troubleshooting#vite-cjs-node-api-deprecated
  summary: The CJS build of Vite's Node API is deprecated and will be removed in Vite 6
  belongs_to: Troubleshooting
  description: |-
    ### Vite CJS Node API deprecated

    The CJS build of Vite's Node API is deprecated and will be removed in Vite 6. See the [GitHub discussion](https://github.com/vitejs/vite/discussions/13928) for more context. You should update your files or frameworks to import the ESM build of Vite instead.

    In a basic Vite project, make sure:

    1.  The `vite.config.js` file content is using the ESM syntax.
    2.  The closest `package.json` file has `"type": "module"`, or use the `.mjs`/`.mts` extension, e.g. `vite.config.mjs` or `vite.config.mts`.

    For other projects, there are a few general approaches:

    - **Configure ESM as default, opt-in to CJS if needed:** Add `"type": "module"` in the project `package.json`. All `*.js` files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the `.cjs` extension to keep using CJS instead.
    - **Keep CJS as default, opt-in to ESM if needed:** If the project `package.json` does not have `"type": "module"`, all `*.js` files are interpreted as CJS. You can rename a file with the `.mjs` extension to use ESM instead.
    - **Dynamically import Vite:** If you need to keep using CJS, you can dynamically import Vite using `import('vite')` instead. This requires your code to be written in an `async` context, but should still be manageable as Vite's API is mostly asynchronous.

    If you're unsure where the warning is coming from, you can run your script with the `VITE_CJS_TRACE=true` flag to log the stack trace:

    bash

    ``` javascript
    VITE_CJS_TRACE=true vite dev
    ```

    If you'd like to temporarily ignore the warning, you can run your script with the `VITE_CJS_IGNORE_WARNING=true` flag:

    bash

    ``` javascript
    VITE_CJS_IGNORE_WARNING=true vite dev
    ```

    Note that postcss config files does not support ESM + TypeScript (`.mts` or `.ts` in `"type": "module"`) yet. If you have postcss configs with `.ts` and added `"type": "module"` to package.json, you'll also need to rename the postcss config to use `.cts`.
- name: 'Troubleshooting: Vite detects a file change but the HMR is not working'
  id: guide/troubleshooting#vite-detects-a-file-change-but-the-hmr-is-not-working
  summary: You may be importing a file with a different case
  belongs_to: Troubleshooting
  description: |-
    ### Vite detects a file change but the HMR is not working

    You may be importing a file with a different case. For example, `src/foo.js` exists and `src/bar.js` contains:

    js

    ``` javascript
    import './Foo.js' // should be './foo.js'
    ```

    Related issue: [\#964](https://github.com/vitejs/vite/issues/964)
- name: 'Troubleshooting: Vite does not detect a file change'
  id: guide/troubleshooting#vite-does-not-detect-a-file-change
  summary: If you are running Vite with WSL2, Vite cannot watch file changes in some conditions
  belongs_to: Troubleshooting
  description: |-
    ### Vite does not detect a file change

    If you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See [`server.watch` option](../config/server-options#server-watch).
- name: Using Plugins
  id: guide/using-plugins
  summary: Vite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options
  description: "# Using Plugins\n\nVite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options. This means that Vite users can rely on the mature ecosystem of Rollup plugins, while also being able to extend the dev server and SSR functionality as needed.\n\n## Adding a Plugin\n\nTo use a plugin, it needs to be added to the `devDependencies` of the project and included in the `plugins` array in the `vite.config.js` config file. For example, to provide support for legacy browsers, the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) can be used:\n\n``` javascript\n$ npm add -D @vitejs/plugin-legacy\n```\n\njs\n\n``` javascript\n// vite.config.js\nimport legacy from '@vitejs/plugin-legacy'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: ['defaults', 'not IE 11'],\n    }),\n  ],\n})\n```\n\n`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\n## Finding Plugins\n\n**NOTE**\n\nVite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the [Features Guide](features). A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.\n\nCheck out the [Plugins section](https://vitejs.dev/plugins/) for information about official plugins. Community plugins are listed in [awesome-vite](https://github.com/vitejs/awesome-vite#plugins).\n\nYou can also find plugins that follow the [recommended conventions](api-plugin#conventions) using a [npm search for vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) for Vite plugins or a [npm search for rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) for Rollup plugins.\n\n## Enforcing Plugin Ordering\n\nFor compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the `enforce` modifier:\n\n- `pre`: invoke plugin before Vite core plugins\n- default: invoke plugin after Vite core plugins\n- `post`: invoke plugin after Vite build plugins\n\njs\n\n``` javascript\n// vite.config.js\nimport image from '@rollup/plugin-image'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...image(),\n      enforce: 'pre',\n    },\n  ],\n})\n```\n\nCheck out [Plugins API Guide](api-plugin#plugin-ordering) for detailed information.\n\n## Conditional Application\n\nBy default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:\n\njs\n\n``` javascript\n// vite.config.js\nimport typescript2 from 'rollup-plugin-typescript2'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...typescript2(),\n      apply: 'build',\n    },\n  ],\n})\n```\n\n## Building Plugins\n\nCheck out the [Plugins API Guide](api-plugin) for documentation about creating plugins.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/using-plugins](https://vitejs.dev/guide/using-plugins)"
- name: 'Using Plugins: Adding a Plugin'
  id: guide/using-plugins#adding-a-plugin
  summary: To use a plugin, it needs to be added to the devDependencies of the project and included in the plugins array in the vite.config.js config file
  belongs_to: Using Plugins
  description: |-
    ## Adding a Plugin

    To use a plugin, it needs to be added to the `devDependencies` of the project and included in the `plugins` array in the `vite.config.js` config file. For example, to provide support for legacy browsers, the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) can be used:

    ``` javascript
    $ npm add -D @vitejs/plugin-legacy
    ```

    js

    ``` javascript
    // vite.config.js
    import legacy from '@vitejs/plugin-legacy'
    import { defineConfig } from 'vite'

    export default defineConfig({
      plugins: [
        legacy({
          targets: ['defaults', 'not IE 11'],
        }),
      ],
    })
    ```

    `plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.

    Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins.
- name: 'Using Plugins: APIs'
  id: guide/using-plugins
  summary: Vite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options
  description: "# Using Plugins\n\nVite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options. This means that Vite users can rely on the mature ecosystem of Rollup plugins, while also being able to extend the dev server and SSR functionality as needed.\n\n## Adding a Plugin\n\nTo use a plugin, it needs to be added to the `devDependencies` of the project and included in the `plugins` array in the `vite.config.js` config file. For example, to provide support for legacy browsers, the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) can be used:\n\n``` javascript\n$ npm add -D @vitejs/plugin-legacy\n```\n\njs\n\n``` javascript\n// vite.config.js\nimport legacy from '@vitejs/plugin-legacy'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: ['defaults', 'not IE 11'],\n    }),\n  ],\n})\n```\n\n`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\n## Finding Plugins\n\n**NOTE**\n\nVite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the [Features Guide](features). A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.\n\nCheck out the [Plugins section](https://vitejs.dev/plugins/) for information about official plugins. Community plugins are listed in [awesome-vite](https://github.com/vitejs/awesome-vite#plugins).\n\nYou can also find plugins that follow the [recommended conventions](api-plugin#conventions) using a [npm search for vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) for Vite plugins or a [npm search for rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) for Rollup plugins.\n\n## Enforcing Plugin Ordering\n\nFor compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the `enforce` modifier:\n\n- `pre`: invoke plugin before Vite core plugins\n- default: invoke plugin after Vite core plugins\n- `post`: invoke plugin after Vite build plugins\n\njs\n\n``` javascript\n// vite.config.js\nimport image from '@rollup/plugin-image'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...image(),\n      enforce: 'pre',\n    },\n  ],\n})\n```\n\nCheck out [Plugins API Guide](api-plugin#plugin-ordering) for detailed information.\n\n## Conditional Application\n\nBy default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:\n\njs\n\n``` javascript\n// vite.config.js\nimport typescript2 from 'rollup-plugin-typescript2'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...typescript2(),\n      apply: 'build',\n    },\n  ],\n})\n```\n\n## Building Plugins\n\nCheck out the [Plugins API Guide](api-plugin) for documentation about creating plugins.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/using-plugins](https://vitejs.dev/guide/using-plugins)"
- name: 'Using Plugins: Building Plugins'
  id: guide/using-plugins#building-plugins
  summary: Check out the Plugins API Guide for documentation about creating plugins
  belongs_to: Using Plugins
  description: "## Building Plugins\n\nCheck out the [Plugins API Guide](api-plugin) for documentation about creating plugins.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/using-plugins](https://vitejs.dev/guide/using-plugins)"
- name: 'Using Plugins: Conditional Application'
  id: guide/using-plugins#conditional-application
  summary: By default, plugins are invoked for both serve and build
  belongs_to: Using Plugins
  description: |-
    ## Conditional Application

    By default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:

    js

    ``` javascript
    // vite.config.js
    import typescript2 from 'rollup-plugin-typescript2'
    import { defineConfig } from 'vite'

    export default defineConfig({
      plugins: [
        {
          ...typescript2(),
          apply: 'build',
        },
      ],
    })
    ```
- name: 'Using Plugins: Enforcing Plugin Ordering'
  id: guide/using-plugins#enforcing-plugin-ordering
  summary: For compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time
  belongs_to: Using Plugins
  description: |-
    ## Enforcing Plugin Ordering

    For compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the `enforce` modifier:

    - `pre`: invoke plugin before Vite core plugins
    - default: invoke plugin after Vite core plugins
    - `post`: invoke plugin after Vite build plugins

    js

    ``` javascript
    // vite.config.js
    import image from '@rollup/plugin-image'
    import { defineConfig } from 'vite'

    export default defineConfig({
      plugins: [
        {
          ...image(),
          enforce: 'pre',
        },
      ],
    })
    ```

    Check out [Plugins API Guide](api-plugin#plugin-ordering) for detailed information.
- name: 'Using Plugins: Finding Plugins'
  id: guide/using-plugins#finding-plugins
  summary: Vite aims to provide out-of-the-box support for common web development patterns
  belongs_to: Using Plugins
  description: |-
    ## Finding Plugins

    **NOTE**

    Vite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the [Features Guide](features). A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.

    Check out the [Plugins section](https://vitejs.dev/plugins/) for information about official plugins. Community plugins are listed in [awesome-vite](https://github.com/vitejs/awesome-vite#plugins).

    You can also find plugins that follow the [recommended conventions](api-plugin#conventions) using a [npm search for vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) for Vite plugins or a [npm search for rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) for Rollup plugins.
- name: 'Using Plugins: Guide'
  id: guide/using-plugins
  summary: Vite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options
  description: "# Using Plugins\n\nVite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options. This means that Vite users can rely on the mature ecosystem of Rollup plugins, while also being able to extend the dev server and SSR functionality as needed.\n\n## Adding a Plugin\n\nTo use a plugin, it needs to be added to the `devDependencies` of the project and included in the `plugins` array in the `vite.config.js` config file. For example, to provide support for legacy browsers, the official [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) can be used:\n\n``` javascript\n$ npm add -D @vitejs/plugin-legacy\n```\n\njs\n\n``` javascript\n// vite.config.js\nimport legacy from '@vitejs/plugin-legacy'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: ['defaults', 'not IE 11'],\n    }),\n  ],\n})\n```\n\n`plugins` also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\n## Finding Plugins\n\n**NOTE**\n\nVite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the [Features Guide](features). A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.\n\nCheck out the [Plugins section](https://vitejs.dev/plugins/) for information about official plugins. Community plugins are listed in [awesome-vite](https://github.com/vitejs/awesome-vite#plugins).\n\nYou can also find plugins that follow the [recommended conventions](api-plugin#conventions) using a [npm search for vite-plugin](https://www.npmjs.com/search?q=vite-plugin&ranking=popularity) for Vite plugins or a [npm search for rollup-plugin](https://www.npmjs.com/search?q=rollup-plugin&ranking=popularity) for Rollup plugins.\n\n## Enforcing Plugin Ordering\n\nFor compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the `enforce` modifier:\n\n- `pre`: invoke plugin before Vite core plugins\n- default: invoke plugin after Vite core plugins\n- `post`: invoke plugin after Vite build plugins\n\njs\n\n``` javascript\n// vite.config.js\nimport image from '@rollup/plugin-image'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...image(),\n      enforce: 'pre',\n    },\n  ],\n})\n```\n\nCheck out [Plugins API Guide](api-plugin#plugin-ordering) for detailed information.\n\n## Conditional Application\n\nBy default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the `apply` property to only invoke them during `'build'` or `'serve'`:\n\njs\n\n``` javascript\n// vite.config.js\nimport typescript2 from 'rollup-plugin-typescript2'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...typescript2(),\n      apply: 'build',\n    },\n  ],\n})\n```\n\n## Building Plugins\n\nCheck out the [Plugins API Guide](api-plugin) for documentation about creating plugins.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/using-plugins](https://vitejs.dev/guide/using-plugins)"
- name: Vite Runtime API
  id: guide/api-vite-runtime
  summary: This API was introduced in Vite 5.1 as an experimental feature
  description: "# Vite Runtime API\n\n**Low-level API**\n\nThis API was introduced in Vite 5.1 as an experimental feature. It was added to [gather feedback](https://github.com/vitejs/vite/discussions/15774). There will likely be breaking changes, so make sure to pin the Vite version to `~5.1.0` when using it. This is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first.\n\nCurrently, the API is being revised as the [Environment API](https://github.com/vitejs/vite/discussions/16358) which is released at `^6.0.0-alpha.0`.\n\nThe \"Vite Runtime\" is a tool that allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runtime implementation is decoupled from the server. This allows library and framework authors to implement their own layer of communication between the server and the runtime.\n\nOne of the goals of this feature is to provide a customizable API to process and run the code. Vite provides enough tools to use Vite Runtime out of the box, but users can build upon it if their needs do not align with Vite's built-in implementation.\n\nAll APIs can be imported from `vite/runtime` unless stated otherwise.\n\n## `ViteRuntime`\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport class ViteRuntime {\n  constructor(\n    public options: ViteRuntimeOptions,\n    public runner: ViteModuleRunner,\n    private debug?: ViteRuntimeDebugger,\n  ) {}\n  /**\n   * URL to execute. Accepts file path, server path, or id relative to the root.\n   */\n  public async executeUrl<T = any>(url: string): Promise<T>\n  /**\n   * Entry point URL to execute. Accepts file path, server path or id relative to the root.\n   * In the case of a full reload triggered by HMR, this is the module that will be reloaded.\n   * If this method is called multiple times, all entry points will be reloaded one at a time.\n   */\n  public async executeEntrypoint<T = any>(url: string): Promise<T>\n  /**\n   * Clear all caches including HMR listeners.\n   */\n  public clearCache(): void\n  /**\n   * Clears all caches, removes all HMR listeners, and resets source map support.\n   * This method doesn't stop the HMR connection.\n   */\n  public async destroy(): Promise<void>\n  /**\n   * Returns `true` if the runtime has been destroyed by calling `destroy()` method.\n   */\n  public isDestroyed(): boolean\n}\n```\n\n**Advanced Usage**\n\nIf you are just migrating from `server.ssrLoadModule` and want to support HMR, consider using [`createViteRuntime`](#createviteruntime) instead.\n\nThe `ViteRuntime` class requires `root` and `fetchModule` options when initiated. Vite exposes `ssrFetchModule` on the [`server`](api-javascript) instance for easier integration with Vite SSR. Vite also exports `fetchModule` from its main entry point - it doesn't make any assumptions about how the code is running unlike `ssrFetchModule` that expects the code to run using `new Function`. This can be seen in source maps that these functions return.\n\nRunner in `ViteRuntime` is responsible for executing the code. Vite exports `ESModulesRunner` out of the box, it uses `new AsyncFunction` to run the code. You can provide your own implementation if your JavaScript runtime doesn't support unsafe evaluation.\n\nThe two main methods that runtime exposes are `executeUrl` and `executeEntrypoint`. The only difference between them is that all modules executed by `executeEntrypoint` will be reexecuted if HMR triggers `full-reload` event. Be aware that Vite Runtime doesn't update `exports` object when this happens (it overrides it), you would need to run `executeUrl` or get the module from `moduleCache` again if you rely on having the latest `exports` object.\n\n**Example Usage:**\n\njs\n\n``` javascript\nimport { ViteRuntime, ESModulesRunner } from 'vite/runtime'\nimport { root, fetchModule } from './rpc-implementation.js'\n\nconst runtime = new ViteRuntime(\n  {\n    root,\n    fetchModule,\n    // you can also provide hmr.connection to support HMR\n  },\n  new ESModulesRunner(),\n)\n\nawait runtime.executeEntrypoint('/src/entry-point.js')\n```\n\n## `ViteRuntimeOptions`\n\nts\n\n``` javascript\nexport interface ViteRuntimeOptions {\n  /**\n   * Root of the project\n   */\n  root: string\n  /**\n   * A method to get the information about the module.\n   * For SSR, Vite exposes `server.ssrFetchModule` function that you can use here.\n   * For other runtime use cases, Vite also exposes `fetchModule` from its main entry point.\n   */\n  fetchModule: FetchFunction\n  /**\n   * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.\n   * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.\n   * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.\n   */\n  sourcemapInterceptor?:\n    | false\n    | 'node'\n    | 'prepareStackTrace'\n    | InterceptorOptions\n  /**\n   * Disable HMR or configure HMR options.\n   */\n  hmr?:\n    | false\n    | {\n        /**\n         * Configure how HMR communicates between the client and the server.\n         */\n        connection: HMRRuntimeConnection\n        /**\n         * Configure HMR logger.\n         */\n        logger?: false | HMRLogger\n      }\n  /**\n   * Custom module cache. If not provided, it creates a separate module cache for each ViteRuntime instance.\n   */\n  moduleCache?: ModuleCacheMap\n}\n```\n\n## `ViteModuleRunner`\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport interface ViteModuleRunner {\n  /**\n   * Run code that was transformed by Vite.\n   * @param context Function context\n   * @param code Transformed code\n   * @param id ID that was used to fetch the module\n   */\n  runViteModule(\n    context: ViteRuntimeModuleContext,\n    code: string,\n    id: string,\n  ): Promise<any>\n  /**\n   * Run externalized module.\n   * @param file File URL to the external module\n   */\n  runExternalModule(file: string): Promise<any>\n}\n```\n\nVite exports `ESModulesRunner` that implements this interface by default. It uses `new AsyncFunction` to run code, so if the code has inlined source map it should contain an [offset of 2 lines](https://tc39.es/ecma262/#sec-createdynamicfunction) to accommodate for new lines added. This is done automatically by `server.ssrFetchModule`. If your runner implementation doesn't have this constraint, you should use `fetchModule` (exported from `vite`) directly.\n\n## HMRRuntimeConnection\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport interface HMRRuntimeConnection {\n  /**\n   * Checked before sending messages to the client.\n   */\n  isReady(): boolean\n  /**\n   * Send message to the client.\n   */\n  send(message: string): void\n  /**\n   * Configure how HMR is handled when this connection triggers an update.\n   * This method expects that connection will start listening for HMR updates and call this callback when it's received.\n   */\n  onUpdate(callback: (payload: HMRPayload) => void): void\n}\n```\n\nThis interface defines how HMR communication is established. Vite exports `ServerHMRConnector` from the main entry point to support HMR during Vite SSR. The `isReady` and `send` methods are usually called when the custom event is triggered (like, `import.meta.hot.send(\"my-event\")`).\n\n`onUpdate` is called only once when the new runtime is initiated. It passed down a method that should be called when connection triggers the HMR event. The implementation depends on the type of connection (as an example, it can be `WebSocket`/`EventEmitter`/`MessageChannel`), but it usually looks something like this:\n\njs\n\n``` javascript\nfunction onUpdate(callback) {\n  this.connection.on('hmr', (event) => callback(event.data))\n}\n```\n\nThe callback is queued and it will wait for the current update to be resolved before processing the next update. Unlike the browser implementation, HMR updates in Vite Runtime wait until all listeners (like, `vite:beforeUpdate`/`vite:beforeFullReload`) are finished before updating the modules.\n\n## `createViteRuntime`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function createViteRuntime(\n  server: ViteDevServer,\n  options?: MainThreadRuntimeOptions,\n): Promise<ViteRuntime>\n```\n\n**Example Usage:**\n\njs\n\n``` javascript\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\n;(async () => {\n  const server = await createServer({\n    root: __dirname,\n  })\n  await server.listen()\n\n  const runtime = await createViteRuntime(server)\n  await runtime.executeEntrypoint('/src/entry-point.js')\n})()\n```\n\nThis method serves as an easy replacement for `server.ssrLoadModule`. Unlike `ssrLoadModule`, `createViteRuntime` provides HMR support out of the box. You can pass down [`options`](#mainthreadruntimeoptions) to customize how SSR runtime behaves to suit your needs.\n\n## `MainThreadRuntimeOptions`\n\nts\n\n``` javascript\nexport interface MainThreadRuntimeOptions\n  extends Omit<ViteRuntimeOptions, 'root' | 'fetchModule' | 'hmr'> {\n  /**\n   * Disable HMR or configure HMR logger.\n   */\n  hmr?:\n    | false\n    | {\n        logger?: false | HMRLogger\n      }\n  /**\n   * Provide a custom module runner. This controls how the code is executed.\n   */\n  runner?: ViteModuleRunner\n}\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-vite-runtime](https://vitejs.dev/guide/api-vite-runtime)"
- name: 'Vite Runtime API: APIs'
  id: guide/api-vite-runtime
  summary: This API was introduced in Vite 5.1 as an experimental feature
  description: "# Vite Runtime API\n\n**Low-level API**\n\nThis API was introduced in Vite 5.1 as an experimental feature. It was added to [gather feedback](https://github.com/vitejs/vite/discussions/15774). There will likely be breaking changes, so make sure to pin the Vite version to `~5.1.0` when using it. This is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first.\n\nCurrently, the API is being revised as the [Environment API](https://github.com/vitejs/vite/discussions/16358) which is released at `^6.0.0-alpha.0`.\n\nThe \"Vite Runtime\" is a tool that allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runtime implementation is decoupled from the server. This allows library and framework authors to implement their own layer of communication between the server and the runtime.\n\nOne of the goals of this feature is to provide a customizable API to process and run the code. Vite provides enough tools to use Vite Runtime out of the box, but users can build upon it if their needs do not align with Vite's built-in implementation.\n\nAll APIs can be imported from `vite/runtime` unless stated otherwise.\n\n## `ViteRuntime`\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport class ViteRuntime {\n  constructor(\n    public options: ViteRuntimeOptions,\n    public runner: ViteModuleRunner,\n    private debug?: ViteRuntimeDebugger,\n  ) {}\n  /**\n   * URL to execute. Accepts file path, server path, or id relative to the root.\n   */\n  public async executeUrl<T = any>(url: string): Promise<T>\n  /**\n   * Entry point URL to execute. Accepts file path, server path or id relative to the root.\n   * In the case of a full reload triggered by HMR, this is the module that will be reloaded.\n   * If this method is called multiple times, all entry points will be reloaded one at a time.\n   */\n  public async executeEntrypoint<T = any>(url: string): Promise<T>\n  /**\n   * Clear all caches including HMR listeners.\n   */\n  public clearCache(): void\n  /**\n   * Clears all caches, removes all HMR listeners, and resets source map support.\n   * This method doesn't stop the HMR connection.\n   */\n  public async destroy(): Promise<void>\n  /**\n   * Returns `true` if the runtime has been destroyed by calling `destroy()` method.\n   */\n  public isDestroyed(): boolean\n}\n```\n\n**Advanced Usage**\n\nIf you are just migrating from `server.ssrLoadModule` and want to support HMR, consider using [`createViteRuntime`](#createviteruntime) instead.\n\nThe `ViteRuntime` class requires `root` and `fetchModule` options when initiated. Vite exposes `ssrFetchModule` on the [`server`](api-javascript) instance for easier integration with Vite SSR. Vite also exports `fetchModule` from its main entry point - it doesn't make any assumptions about how the code is running unlike `ssrFetchModule` that expects the code to run using `new Function`. This can be seen in source maps that these functions return.\n\nRunner in `ViteRuntime` is responsible for executing the code. Vite exports `ESModulesRunner` out of the box, it uses `new AsyncFunction` to run the code. You can provide your own implementation if your JavaScript runtime doesn't support unsafe evaluation.\n\nThe two main methods that runtime exposes are `executeUrl` and `executeEntrypoint`. The only difference between them is that all modules executed by `executeEntrypoint` will be reexecuted if HMR triggers `full-reload` event. Be aware that Vite Runtime doesn't update `exports` object when this happens (it overrides it), you would need to run `executeUrl` or get the module from `moduleCache` again if you rely on having the latest `exports` object.\n\n**Example Usage:**\n\njs\n\n``` javascript\nimport { ViteRuntime, ESModulesRunner } from 'vite/runtime'\nimport { root, fetchModule } from './rpc-implementation.js'\n\nconst runtime = new ViteRuntime(\n  {\n    root,\n    fetchModule,\n    // you can also provide hmr.connection to support HMR\n  },\n  new ESModulesRunner(),\n)\n\nawait runtime.executeEntrypoint('/src/entry-point.js')\n```\n\n## `ViteRuntimeOptions`\n\nts\n\n``` javascript\nexport interface ViteRuntimeOptions {\n  /**\n   * Root of the project\n   */\n  root: string\n  /**\n   * A method to get the information about the module.\n   * For SSR, Vite exposes `server.ssrFetchModule` function that you can use here.\n   * For other runtime use cases, Vite also exposes `fetchModule` from its main entry point.\n   */\n  fetchModule: FetchFunction\n  /**\n   * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.\n   * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.\n   * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.\n   */\n  sourcemapInterceptor?:\n    | false\n    | 'node'\n    | 'prepareStackTrace'\n    | InterceptorOptions\n  /**\n   * Disable HMR or configure HMR options.\n   */\n  hmr?:\n    | false\n    | {\n        /**\n         * Configure how HMR communicates between the client and the server.\n         */\n        connection: HMRRuntimeConnection\n        /**\n         * Configure HMR logger.\n         */\n        logger?: false | HMRLogger\n      }\n  /**\n   * Custom module cache. If not provided, it creates a separate module cache for each ViteRuntime instance.\n   */\n  moduleCache?: ModuleCacheMap\n}\n```\n\n## `ViteModuleRunner`\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport interface ViteModuleRunner {\n  /**\n   * Run code that was transformed by Vite.\n   * @param context Function context\n   * @param code Transformed code\n   * @param id ID that was used to fetch the module\n   */\n  runViteModule(\n    context: ViteRuntimeModuleContext,\n    code: string,\n    id: string,\n  ): Promise<any>\n  /**\n   * Run externalized module.\n   * @param file File URL to the external module\n   */\n  runExternalModule(file: string): Promise<any>\n}\n```\n\nVite exports `ESModulesRunner` that implements this interface by default. It uses `new AsyncFunction` to run code, so if the code has inlined source map it should contain an [offset of 2 lines](https://tc39.es/ecma262/#sec-createdynamicfunction) to accommodate for new lines added. This is done automatically by `server.ssrFetchModule`. If your runner implementation doesn't have this constraint, you should use `fetchModule` (exported from `vite`) directly.\n\n## HMRRuntimeConnection\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport interface HMRRuntimeConnection {\n  /**\n   * Checked before sending messages to the client.\n   */\n  isReady(): boolean\n  /**\n   * Send message to the client.\n   */\n  send(message: string): void\n  /**\n   * Configure how HMR is handled when this connection triggers an update.\n   * This method expects that connection will start listening for HMR updates and call this callback when it's received.\n   */\n  onUpdate(callback: (payload: HMRPayload) => void): void\n}\n```\n\nThis interface defines how HMR communication is established. Vite exports `ServerHMRConnector` from the main entry point to support HMR during Vite SSR. The `isReady` and `send` methods are usually called when the custom event is triggered (like, `import.meta.hot.send(\"my-event\")`).\n\n`onUpdate` is called only once when the new runtime is initiated. It passed down a method that should be called when connection triggers the HMR event. The implementation depends on the type of connection (as an example, it can be `WebSocket`/`EventEmitter`/`MessageChannel`), but it usually looks something like this:\n\njs\n\n``` javascript\nfunction onUpdate(callback) {\n  this.connection.on('hmr', (event) => callback(event.data))\n}\n```\n\nThe callback is queued and it will wait for the current update to be resolved before processing the next update. Unlike the browser implementation, HMR updates in Vite Runtime wait until all listeners (like, `vite:beforeUpdate`/`vite:beforeFullReload`) are finished before updating the modules.\n\n## `createViteRuntime`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function createViteRuntime(\n  server: ViteDevServer,\n  options?: MainThreadRuntimeOptions,\n): Promise<ViteRuntime>\n```\n\n**Example Usage:**\n\njs\n\n``` javascript\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\n;(async () => {\n  const server = await createServer({\n    root: __dirname,\n  })\n  await server.listen()\n\n  const runtime = await createViteRuntime(server)\n  await runtime.executeEntrypoint('/src/entry-point.js')\n})()\n```\n\nThis method serves as an easy replacement for `server.ssrLoadModule`. Unlike `ssrLoadModule`, `createViteRuntime` provides HMR support out of the box. You can pass down [`options`](#mainthreadruntimeoptions) to customize how SSR runtime behaves to suit your needs.\n\n## `MainThreadRuntimeOptions`\n\nts\n\n``` javascript\nexport interface MainThreadRuntimeOptions\n  extends Omit<ViteRuntimeOptions, 'root' | 'fetchModule' | 'hmr'> {\n  /**\n   * Disable HMR or configure HMR logger.\n   */\n  hmr?:\n    | false\n    | {\n        logger?: false | HMRLogger\n      }\n  /**\n   * Provide a custom module runner. This controls how the code is executed.\n   */\n  runner?: ViteModuleRunner\n}\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-vite-runtime](https://vitejs.dev/guide/api-vite-runtime)"
- name: 'Vite Runtime API: createViteRuntime'
  id: guide/api-vite-runtime#createviteruntime
  summary: This method serves as an easy replacement for server.ssrLoadModule
  belongs_to: Vite Runtime API
  description: |-
    ## `createViteRuntime`

    **Type Signature:**

    ts

    ``` javascript
    async function createViteRuntime(
      server: ViteDevServer,
      options?: MainThreadRuntimeOptions,
    ): Promise<ViteRuntime>
    ```

    **Example Usage:**

    js

    ``` javascript
    import { createServer } from 'vite'

    const __dirname = fileURLToPath(new URL('.', import.meta.url))

    ;(async () => {
      const server = await createServer({
        root: __dirname,
      })
      await server.listen()

      const runtime = await createViteRuntime(server)
      await runtime.executeEntrypoint('/src/entry-point.js')
    })()
    ```

    This method serves as an easy replacement for `server.ssrLoadModule`. Unlike `ssrLoadModule`, `createViteRuntime` provides HMR support out of the box. You can pass down [`options`](#mainthreadruntimeoptions) to customize how SSR runtime behaves to suit your needs.
- name: 'Vite Runtime API: Guide'
  id: guide/api-vite-runtime
  summary: This API was introduced in Vite 5.1 as an experimental feature
  description: "# Vite Runtime API\n\n**Low-level API**\n\nThis API was introduced in Vite 5.1 as an experimental feature. It was added to [gather feedback](https://github.com/vitejs/vite/discussions/15774). There will likely be breaking changes, so make sure to pin the Vite version to `~5.1.0` when using it. This is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at [Awesome Vite SSR section](https://github.com/vitejs/awesome-vite#ssr) first.\n\nCurrently, the API is being revised as the [Environment API](https://github.com/vitejs/vite/discussions/16358) which is released at `^6.0.0-alpha.0`.\n\nThe \"Vite Runtime\" is a tool that allows running any code by processing it with Vite plugins first. It is different from `server.ssrLoadModule` because the runtime implementation is decoupled from the server. This allows library and framework authors to implement their own layer of communication between the server and the runtime.\n\nOne of the goals of this feature is to provide a customizable API to process and run the code. Vite provides enough tools to use Vite Runtime out of the box, but users can build upon it if their needs do not align with Vite's built-in implementation.\n\nAll APIs can be imported from `vite/runtime` unless stated otherwise.\n\n## `ViteRuntime`\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport class ViteRuntime {\n  constructor(\n    public options: ViteRuntimeOptions,\n    public runner: ViteModuleRunner,\n    private debug?: ViteRuntimeDebugger,\n  ) {}\n  /**\n   * URL to execute. Accepts file path, server path, or id relative to the root.\n   */\n  public async executeUrl<T = any>(url: string): Promise<T>\n  /**\n   * Entry point URL to execute. Accepts file path, server path or id relative to the root.\n   * In the case of a full reload triggered by HMR, this is the module that will be reloaded.\n   * If this method is called multiple times, all entry points will be reloaded one at a time.\n   */\n  public async executeEntrypoint<T = any>(url: string): Promise<T>\n  /**\n   * Clear all caches including HMR listeners.\n   */\n  public clearCache(): void\n  /**\n   * Clears all caches, removes all HMR listeners, and resets source map support.\n   * This method doesn't stop the HMR connection.\n   */\n  public async destroy(): Promise<void>\n  /**\n   * Returns `true` if the runtime has been destroyed by calling `destroy()` method.\n   */\n  public isDestroyed(): boolean\n}\n```\n\n**Advanced Usage**\n\nIf you are just migrating from `server.ssrLoadModule` and want to support HMR, consider using [`createViteRuntime`](#createviteruntime) instead.\n\nThe `ViteRuntime` class requires `root` and `fetchModule` options when initiated. Vite exposes `ssrFetchModule` on the [`server`](api-javascript) instance for easier integration with Vite SSR. Vite also exports `fetchModule` from its main entry point - it doesn't make any assumptions about how the code is running unlike `ssrFetchModule` that expects the code to run using `new Function`. This can be seen in source maps that these functions return.\n\nRunner in `ViteRuntime` is responsible for executing the code. Vite exports `ESModulesRunner` out of the box, it uses `new AsyncFunction` to run the code. You can provide your own implementation if your JavaScript runtime doesn't support unsafe evaluation.\n\nThe two main methods that runtime exposes are `executeUrl` and `executeEntrypoint`. The only difference between them is that all modules executed by `executeEntrypoint` will be reexecuted if HMR triggers `full-reload` event. Be aware that Vite Runtime doesn't update `exports` object when this happens (it overrides it), you would need to run `executeUrl` or get the module from `moduleCache` again if you rely on having the latest `exports` object.\n\n**Example Usage:**\n\njs\n\n``` javascript\nimport { ViteRuntime, ESModulesRunner } from 'vite/runtime'\nimport { root, fetchModule } from './rpc-implementation.js'\n\nconst runtime = new ViteRuntime(\n  {\n    root,\n    fetchModule,\n    // you can also provide hmr.connection to support HMR\n  },\n  new ESModulesRunner(),\n)\n\nawait runtime.executeEntrypoint('/src/entry-point.js')\n```\n\n## `ViteRuntimeOptions`\n\nts\n\n``` javascript\nexport interface ViteRuntimeOptions {\n  /**\n   * Root of the project\n   */\n  root: string\n  /**\n   * A method to get the information about the module.\n   * For SSR, Vite exposes `server.ssrFetchModule` function that you can use here.\n   * For other runtime use cases, Vite also exposes `fetchModule` from its main entry point.\n   */\n  fetchModule: FetchFunction\n  /**\n   * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.\n   * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.\n   * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.\n   */\n  sourcemapInterceptor?:\n    | false\n    | 'node'\n    | 'prepareStackTrace'\n    | InterceptorOptions\n  /**\n   * Disable HMR or configure HMR options.\n   */\n  hmr?:\n    | false\n    | {\n        /**\n         * Configure how HMR communicates between the client and the server.\n         */\n        connection: HMRRuntimeConnection\n        /**\n         * Configure HMR logger.\n         */\n        logger?: false | HMRLogger\n      }\n  /**\n   * Custom module cache. If not provided, it creates a separate module cache for each ViteRuntime instance.\n   */\n  moduleCache?: ModuleCacheMap\n}\n```\n\n## `ViteModuleRunner`\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport interface ViteModuleRunner {\n  /**\n   * Run code that was transformed by Vite.\n   * @param context Function context\n   * @param code Transformed code\n   * @param id ID that was used to fetch the module\n   */\n  runViteModule(\n    context: ViteRuntimeModuleContext,\n    code: string,\n    id: string,\n  ): Promise<any>\n  /**\n   * Run externalized module.\n   * @param file File URL to the external module\n   */\n  runExternalModule(file: string): Promise<any>\n}\n```\n\nVite exports `ESModulesRunner` that implements this interface by default. It uses `new AsyncFunction` to run code, so if the code has inlined source map it should contain an [offset of 2 lines](https://tc39.es/ecma262/#sec-createdynamicfunction) to accommodate for new lines added. This is done automatically by `server.ssrFetchModule`. If your runner implementation doesn't have this constraint, you should use `fetchModule` (exported from `vite`) directly.\n\n## HMRRuntimeConnection\n\n**Type Signature:**\n\nts\n\n``` javascript\nexport interface HMRRuntimeConnection {\n  /**\n   * Checked before sending messages to the client.\n   */\n  isReady(): boolean\n  /**\n   * Send message to the client.\n   */\n  send(message: string): void\n  /**\n   * Configure how HMR is handled when this connection triggers an update.\n   * This method expects that connection will start listening for HMR updates and call this callback when it's received.\n   */\n  onUpdate(callback: (payload: HMRPayload) => void): void\n}\n```\n\nThis interface defines how HMR communication is established. Vite exports `ServerHMRConnector` from the main entry point to support HMR during Vite SSR. The `isReady` and `send` methods are usually called when the custom event is triggered (like, `import.meta.hot.send(\"my-event\")`).\n\n`onUpdate` is called only once when the new runtime is initiated. It passed down a method that should be called when connection triggers the HMR event. The implementation depends on the type of connection (as an example, it can be `WebSocket`/`EventEmitter`/`MessageChannel`), but it usually looks something like this:\n\njs\n\n``` javascript\nfunction onUpdate(callback) {\n  this.connection.on('hmr', (event) => callback(event.data))\n}\n```\n\nThe callback is queued and it will wait for the current update to be resolved before processing the next update. Unlike the browser implementation, HMR updates in Vite Runtime wait until all listeners (like, `vite:beforeUpdate`/`vite:beforeFullReload`) are finished before updating the modules.\n\n## `createViteRuntime`\n\n**Type Signature:**\n\nts\n\n``` javascript\nasync function createViteRuntime(\n  server: ViteDevServer,\n  options?: MainThreadRuntimeOptions,\n): Promise<ViteRuntime>\n```\n\n**Example Usage:**\n\njs\n\n``` javascript\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\n;(async () => {\n  const server = await createServer({\n    root: __dirname,\n  })\n  await server.listen()\n\n  const runtime = await createViteRuntime(server)\n  await runtime.executeEntrypoint('/src/entry-point.js')\n})()\n```\n\nThis method serves as an easy replacement for `server.ssrLoadModule`. Unlike `ssrLoadModule`, `createViteRuntime` provides HMR support out of the box. You can pass down [`options`](#mainthreadruntimeoptions) to customize how SSR runtime behaves to suit your needs.\n\n## `MainThreadRuntimeOptions`\n\nts\n\n``` javascript\nexport interface MainThreadRuntimeOptions\n  extends Omit<ViteRuntimeOptions, 'root' | 'fetchModule' | 'hmr'> {\n  /**\n   * Disable HMR or configure HMR logger.\n   */\n  hmr?:\n    | false\n    | {\n        logger?: false | HMRLogger\n      }\n  /**\n   * Provide a custom module runner. This controls how the code is executed.\n   */\n  runner?: ViteModuleRunner\n}\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-vite-runtime](https://vitejs.dev/guide/api-vite-runtime)"
- name: 'Vite Runtime API: HMRRuntimeConnection'
  id: guide/api-vite-runtime#hmrruntimeconnection
  summary: This interface defines how HMR communication is established
  belongs_to: Vite Runtime API
  description: |-
    ## HMRRuntimeConnection

    **Type Signature:**

    ts

    ``` javascript
    export interface HMRRuntimeConnection {
      /**
       * Checked before sending messages to the client.
       */
      isReady(): boolean
      /**
       * Send message to the client.
       */
      send(message: string): void
      /**
       * Configure how HMR is handled when this connection triggers an update.
       * This method expects that connection will start listening for HMR updates and call this callback when it's received.
       */
      onUpdate(callback: (payload: HMRPayload) => void): void
    }
    ```

    This interface defines how HMR communication is established. Vite exports `ServerHMRConnector` from the main entry point to support HMR during Vite SSR. The `isReady` and `send` methods are usually called when the custom event is triggered (like, `import.meta.hot.send("my-event")`).

    `onUpdate` is called only once when the new runtime is initiated. It passed down a method that should be called when connection triggers the HMR event. The implementation depends on the type of connection (as an example, it can be `WebSocket`/`EventEmitter`/`MessageChannel`), but it usually looks something like this:

    js

    ``` javascript
    function onUpdate(callback) {
      this.connection.on('hmr', (event) => callback(event.data))
    }
    ```

    The callback is queued and it will wait for the current update to be resolved before processing the next update. Unlike the browser implementation, HMR updates in Vite Runtime wait until all listeners (like, `vite:beforeUpdate`/`vite:beforeFullReload`) are finished before updating the modules.
- name: 'Vite Runtime API: MainThreadRuntimeOptions'
  id: guide/api-vite-runtime#mainthreadruntimeoptions
  summary: © 2019–present, Yuxi (Evan) You and Vite contributors Licensed under the MIT License
  belongs_to: Vite Runtime API
  description: "## `MainThreadRuntimeOptions`\n\nts\n\n``` javascript\nexport interface MainThreadRuntimeOptions\n  extends Omit<ViteRuntimeOptions, 'root' | 'fetchModule' | 'hmr'> {\n  /**\n   * Disable HMR or configure HMR logger.\n   */\n  hmr?:\n    | false\n    | {\n        logger?: false | HMRLogger\n      }\n  /**\n   * Provide a custom module runner. This controls how the code is executed.\n   */\n  runner?: ViteModuleRunner\n}\n```\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/api-vite-runtime](https://vitejs.dev/guide/api-vite-runtime)"
- name: 'Vite Runtime API: ViteModuleRunner'
  id: guide/api-vite-runtime#vitemodulerunner
  summary: Vite exports ESModulesRunner that implements this interface by default
  belongs_to: Vite Runtime API
  description: |-
    ## `ViteModuleRunner`

    **Type Signature:**

    ts

    ``` javascript
    export interface ViteModuleRunner {
      /**
       * Run code that was transformed by Vite.
       * @param context Function context
       * @param code Transformed code
       * @param id ID that was used to fetch the module
       */
      runViteModule(
        context: ViteRuntimeModuleContext,
        code: string,
        id: string,
      ): Promise<any>
      /**
       * Run externalized module.
       * @param file File URL to the external module
       */
      runExternalModule(file: string): Promise<any>
    }
    ```

    Vite exports `ESModulesRunner` that implements this interface by default. It uses `new AsyncFunction` to run code, so if the code has inlined source map it should contain an [offset of 2 lines](https://tc39.es/ecma262/#sec-createdynamicfunction) to accommodate for new lines added. This is done automatically by `server.ssrFetchModule`. If your runner implementation doesn't have this constraint, you should use `fetchModule` (exported from `vite`) directly.
- name: 'Vite Runtime API: ViteRuntime'
  id: guide/api-vite-runtime#viteruntime
  summary: If you are just migrating from server.ssrLoadModule and want to support HMR, consider using createViteRuntime instead
  belongs_to: Vite Runtime API
  description: |-
    ## `ViteRuntime`

    **Type Signature:**

    ts

    ``` javascript
    export class ViteRuntime {
      constructor(
        public options: ViteRuntimeOptions,
        public runner: ViteModuleRunner,
        private debug?: ViteRuntimeDebugger,
      ) {}
      /**
       * URL to execute. Accepts file path, server path, or id relative to the root.
       */
      public async executeUrl<T = any>(url: string): Promise<T>
      /**
       * Entry point URL to execute. Accepts file path, server path or id relative to the root.
       * In the case of a full reload triggered by HMR, this is the module that will be reloaded.
       * If this method is called multiple times, all entry points will be reloaded one at a time.
       */
      public async executeEntrypoint<T = any>(url: string): Promise<T>
      /**
       * Clear all caches including HMR listeners.
       */
      public clearCache(): void
      /**
       * Clears all caches, removes all HMR listeners, and resets source map support.
       * This method doesn't stop the HMR connection.
       */
      public async destroy(): Promise<void>
      /**
       * Returns `true` if the runtime has been destroyed by calling `destroy()` method.
       */
      public isDestroyed(): boolean
    }
    ```

    **Advanced Usage**

    If you are just migrating from `server.ssrLoadModule` and want to support HMR, consider using [`createViteRuntime`](#createviteruntime) instead.

    The `ViteRuntime` class requires `root` and `fetchModule` options when initiated. Vite exposes `ssrFetchModule` on the [`server`](api-javascript) instance for easier integration with Vite SSR. Vite also exports `fetchModule` from its main entry point - it doesn't make any assumptions about how the code is running unlike `ssrFetchModule` that expects the code to run using `new Function`. This can be seen in source maps that these functions return.

    Runner in `ViteRuntime` is responsible for executing the code. Vite exports `ESModulesRunner` out of the box, it uses `new AsyncFunction` to run the code. You can provide your own implementation if your JavaScript runtime doesn't support unsafe evaluation.

    The two main methods that runtime exposes are `executeUrl` and `executeEntrypoint`. The only difference between them is that all modules executed by `executeEntrypoint` will be reexecuted if HMR triggers `full-reload` event. Be aware that Vite Runtime doesn't update `exports` object when this happens (it overrides it), you would need to run `executeUrl` or get the module from `moduleCache` again if you rely on having the latest `exports` object.

    **Example Usage:**

    js

    ``` javascript
    import { ViteRuntime, ESModulesRunner } from 'vite/runtime'
    import { root, fetchModule } from './rpc-implementation.js'

    const runtime = new ViteRuntime(
      {
        root,
        fetchModule,
        // you can also provide hmr.connection to support HMR
      },
      new ESModulesRunner(),
    )

    await runtime.executeEntrypoint('/src/entry-point.js')
    ```
- name: 'Vite Runtime API: ViteRuntimeOptions'
  id: guide/api-vite-runtime#viteruntimeoptions
  summary: null
  belongs_to: Vite Runtime API
  description: |-
    ## `ViteRuntimeOptions`

    ts

    ``` javascript
    export interface ViteRuntimeOptions {
      /**
       * Root of the project
       */
      root: string
      /**
       * A method to get the information about the module.
       * For SSR, Vite exposes `server.ssrFetchModule` function that you can use here.
       * For other runtime use cases, Vite also exposes `fetchModule` from its main entry point.
       */
      fetchModule: FetchFunction
      /**
       * Configure how source maps are resolved. Prefers `node` if `process.setSourceMapsEnabled` is available.
       * Otherwise it will use `prepareStackTrace` by default which overrides `Error.prepareStackTrace` method.
       * You can provide an object to configure how file contents and source maps are resolved for files that were not processed by Vite.
       */
      sourcemapInterceptor?:
        | false
        | 'node'
        | 'prepareStackTrace'
        | InterceptorOptions
      /**
       * Disable HMR or configure HMR options.
       */
      hmr?:
        | false
        | {
            /**
             * Configure how HMR communicates between the client and the server.
             */
            connection: HMRRuntimeConnection
            /**
             * Configure HMR logger.
             */
            logger?: false | HMRLogger
          }
      /**
       * Custom module cache. If not provided, it creates a separate module cache for each ViteRuntime instance.
       */
      moduleCache?: ModuleCacheMap
    }
    ```
- name: Why Vite
  id: guide/why
  summary: Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion
  description: "# Why Vite\n\n## The Problems\n\nBefore ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of \"bundling\": using tools that crawl, process and concatenate our source modules into files that can run in the browser.\n\nOver time we have seen tools like [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) and [Parcel](https://parceljs.org/), which greatly improved the development experience for frontend developers.\n\nHowever, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.\n\nVite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.\n\n### Slow Server Start\n\nWhen cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.\n\nVite improves the dev server start time by first dividing the modules in an application into two categories: **dependencies** and **source code**.\n\n- **Dependencies** are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).\n\n  Vite [pre-bundles dependencies](dep-pre-bundling) using [esbuild](https://esbuild.github.io/). esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.\n\n- **Source code** often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).\n\n  Vite serves source code over [native ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.\n\n### Slow Updates\n\nWhen a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.\n\nIn some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to \"hot replace\" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.\n\nIn Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.\n\nVite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via `304 Not Modified`, and dependency module requests are strongly cached via `Cache-Control: max-age=31536000,immutable` so they don't hit the server again once cached.\n\nOnce you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.\n\n## Why Bundle for Production\n\nEven though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).\n\nEnsuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured [build command](build) that bakes in many [performance optimizations](features#build-optimizations) out of the box.\n\n## Why Not Bundle with esbuild?\n\nVite's current plugin API isn't compatible with using `esbuild` as a bundler. In spite of `esbuild` being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.\n\nRollup has also been working on performance improvements, [switching its parser to SWC in v4](https://github.com/rollup/rollup/pull/5073). And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch [Evan You's ViteConf 2023 keynote for more details](https://youtu.be/hrdwQHoAp0M).\n\n## How is Vite Different from X?\n\nYou can check out the [Comparisons](comparisons) section for more details on how Vite differs from other similar tools.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/why](https://vitejs.dev/guide/why)"
- name: 'Why Vite: APIs'
  id: guide/why
  summary: Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion
  description: "# Why Vite\n\n## The Problems\n\nBefore ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of \"bundling\": using tools that crawl, process and concatenate our source modules into files that can run in the browser.\n\nOver time we have seen tools like [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) and [Parcel](https://parceljs.org/), which greatly improved the development experience for frontend developers.\n\nHowever, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.\n\nVite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.\n\n### Slow Server Start\n\nWhen cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.\n\nVite improves the dev server start time by first dividing the modules in an application into two categories: **dependencies** and **source code**.\n\n- **Dependencies** are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).\n\n  Vite [pre-bundles dependencies](dep-pre-bundling) using [esbuild](https://esbuild.github.io/). esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.\n\n- **Source code** often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).\n\n  Vite serves source code over [native ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.\n\n### Slow Updates\n\nWhen a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.\n\nIn some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to \"hot replace\" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.\n\nIn Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.\n\nVite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via `304 Not Modified`, and dependency module requests are strongly cached via `Cache-Control: max-age=31536000,immutable` so they don't hit the server again once cached.\n\nOnce you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.\n\n## Why Bundle for Production\n\nEven though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).\n\nEnsuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured [build command](build) that bakes in many [performance optimizations](features#build-optimizations) out of the box.\n\n## Why Not Bundle with esbuild?\n\nVite's current plugin API isn't compatible with using `esbuild` as a bundler. In spite of `esbuild` being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.\n\nRollup has also been working on performance improvements, [switching its parser to SWC in v4](https://github.com/rollup/rollup/pull/5073). And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch [Evan You's ViteConf 2023 keynote for more details](https://youtu.be/hrdwQHoAp0M).\n\n## How is Vite Different from X?\n\nYou can check out the [Comparisons](comparisons) section for more details on how Vite differs from other similar tools.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/why](https://vitejs.dev/guide/why)"
- name: 'Why Vite: Guide'
  id: guide/why
  summary: Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion
  description: "# Why Vite\n\n## The Problems\n\nBefore ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of \"bundling\": using tools that crawl, process and concatenate our source modules into files that can run in the browser.\n\nOver time we have seen tools like [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) and [Parcel](https://parceljs.org/), which greatly improved the development experience for frontend developers.\n\nHowever, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.\n\nVite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.\n\n### Slow Server Start\n\nWhen cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.\n\nVite improves the dev server start time by first dividing the modules in an application into two categories: **dependencies** and **source code**.\n\n- **Dependencies** are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).\n\n  Vite [pre-bundles dependencies](dep-pre-bundling) using [esbuild](https://esbuild.github.io/). esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.\n\n- **Source code** often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).\n\n  Vite serves source code over [native ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.\n\n### Slow Updates\n\nWhen a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.\n\nIn some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to \"hot replace\" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.\n\nIn Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.\n\nVite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via `304 Not Modified`, and dependency module requests are strongly cached via `Cache-Control: max-age=31536000,immutable` so they don't hit the server again once cached.\n\nOnce you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.\n\n## Why Bundle for Production\n\nEven though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).\n\nEnsuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured [build command](build) that bakes in many [performance optimizations](features#build-optimizations) out of the box.\n\n## Why Not Bundle with esbuild?\n\nVite's current plugin API isn't compatible with using `esbuild` as a bundler. In spite of `esbuild` being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.\n\nRollup has also been working on performance improvements, [switching its parser to SWC in v4](https://github.com/rollup/rollup/pull/5073). And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch [Evan You's ViteConf 2023 keynote for more details](https://youtu.be/hrdwQHoAp0M).\n\n## How is Vite Different from X?\n\nYou can check out the [Comparisons](comparisons) section for more details on how Vite differs from other similar tools.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/why](https://vitejs.dev/guide/why)"
- name: 'Why Vite: How is Vite Different from X?'
  id: guide/why#how-is-vite-different-from-x
  summary: You can check out the Comparisons section for more details on how Vite differs from other similar tools
  belongs_to: Why Vite
  description: "## How is Vite Different from X?\n\nYou can check out the [Comparisons](comparisons) section for more details on how Vite differs from other similar tools.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/guide/why](https://vitejs.dev/guide/why)"
- name: 'Why Vite: Slow Server Start'
  id: guide/why#slow-server-start
  summary: When cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served
  belongs_to: Why Vite
  description: |-
    ### Slow Server Start

    When cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.

    Vite improves the dev server start time by first dividing the modules in an application into two categories: **dependencies** and **source code**.

    - **Dependencies** are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).

      Vite [pre-bundles dependencies](dep-pre-bundling) using [esbuild](https://esbuild.github.io/). esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.

    - **Source code** often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).

      Vite serves source code over [native ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules). This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.
- name: 'Why Vite: Slow Updates'
  id: guide/why#slow-updates
  summary: 'When a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app'
  belongs_to: Why Vite
  description: |-
    ### Slow Updates

    When a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.

    In some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to "hot replace" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.

    In Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.

    Vite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via `304 Not Modified`, and dependency module requests are strongly cached via `Cache-Control: max-age=31536000,immutable` so they don't hit the server again once cached.

    Once you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.
- name: 'Why Vite: The Problems'
  id: guide/why#the-problems
  summary: Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion
  belongs_to: Why Vite
  description: |-
    ## The Problems

    Before ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of "bundling": using tools that crawl, process and concatenate our source modules into files that can run in the browser.

    Over time we have seen tools like [webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org) and [Parcel](https://parceljs.org/), which greatly improved the development experience for frontend developers.

    However, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.

    Vite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.
- name: 'Why Vite: Why Bundle for Production'
  id: guide/why#why-bundle-for-production
  summary: Even though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports
  belongs_to: Why Vite
  description: |-
    ## Why Bundle for Production

    Even though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).

    Ensuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured [build command](build) that bakes in many [performance optimizations](features#build-optimizations) out of the box.
- name: 'Why Vite: Why Not Bundle with esbuild?'
  id: guide/why#why-not-bundle-with-esbuild
  summary: Vite's current plugin API isn't compatible with using esbuild as a bundler
  belongs_to: Why Vite
  description: |-
    ## Why Not Bundle with esbuild?

    Vite's current plugin API isn't compatible with using `esbuild` as a bundler. In spite of `esbuild` being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.

    Rollup has also been working on performance improvements, [switching its parser to SWC in v4](https://github.com/rollup/rollup/pull/5073). And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch [Evan You's ViteConf 2023 keynote for more details](https://youtu.be/hrdwQHoAp0M).
- name: Worker Options
  id: config/worker-options
  summary: Options related to Web Workers
  description: "# Worker Options\n\nOptions related to Web Workers.\n\n## worker.format\n\n- **Type:** `'es' | 'iife'`\n- **Default:** `'iife'`\n\nOutput format for worker bundle.\n\n## worker.plugins\n\n- **Type:** [`() => (Plugin | Plugin[])[]`](shared-options#plugins)\n\nVite plugins that apply to the worker bundles. Note that [config.plugins](shared-options#plugins) only applies to workers in dev, it should be configured here instead for build. The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying `config.worker` options in the `config` hook will be ignored.\n\n## worker.rollupOptions\n\n- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)\n\nRollup options to build worker bundle.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/worker-options](https://vitejs.dev/config/worker-options)"
- name: 'Worker Options: Config'
  id: config/worker-options
  summary: Options related to Web Workers
  description: "# Worker Options\n\nOptions related to Web Workers.\n\n## worker.format\n\n- **Type:** `'es' | 'iife'`\n- **Default:** `'iife'`\n\nOutput format for worker bundle.\n\n## worker.plugins\n\n- **Type:** [`() => (Plugin | Plugin[])[]`](shared-options#plugins)\n\nVite plugins that apply to the worker bundles. Note that [config.plugins](shared-options#plugins) only applies to workers in dev, it should be configured here instead for build. The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying `config.worker` options in the `config` hook will be ignored.\n\n## worker.rollupOptions\n\n- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)\n\nRollup options to build worker bundle.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/worker-options](https://vitejs.dev/config/worker-options)"
- name: 'Worker Options: worker.format'
  id: config/worker-options#worker-format
  summary: Output format for worker bundle
  belongs_to: Worker Options
  description: |-
    ## worker.format

    - **Type:** `'es' | 'iife'`
    - **Default:** `'iife'`

    Output format for worker bundle.
- name: 'Worker Options: worker.plugins'
  id: config/worker-options#worker-plugins
  summary: Vite plugins that apply to the worker bundles
  belongs_to: Worker Options
  description: |-
    ## worker.plugins

    - **Type:** [`() => (Plugin | Plugin[])[]`](shared-options#plugins)

    Vite plugins that apply to the worker bundles. Note that [config.plugins](shared-options#plugins) only applies to workers in dev, it should be configured here instead for build. The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying `config.worker` options in the `config` hook will be ignored.
- name: 'Worker Options: worker.rollupOptions'
  id: config/worker-options#worker-rollupoptions
  summary: Rollup options to build worker bundle
  belongs_to: Worker Options
  description: "## worker.rollupOptions\n\n- **Type:** [`RollupOptions`](https://rollupjs.org/configuration-options/)\n\nRollup options to build worker bundle.\n\n© 2019–present, Yuxi (Evan) You and Vite contributors  \nLicensed under the MIT License.  \n[https://vitejs.dev/config/worker-options](https://vitejs.dev/config/worker-options)"
