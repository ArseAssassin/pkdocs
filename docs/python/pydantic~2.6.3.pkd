---
name: pydantic
text_format: rst
generator: src:python
generator_command: src:python use "pydantic"
version: 2.6.3
summary: Data validation using Python type hints
description: |-
  Pydantic

  [CI] [Coverage] [pypi] [CondaForge] [downloads] [versions] [license]
  [Pydantic v2]

  Data validation using Python type hints.

  Fast and extensible, Pydantic plays nicely with your linters/IDE/brain.
  Define how data should be in pure, canonical Python 3.8+; validate it
  with Pydantic.

  Pydantic Company ðŸš€

  We've started a company based on the principles that I believe have led
  to Pydantic's success. Learning more from the Company Announcement.

  Pydantic V1.10 vs. V2

  Pydantic V2 is a ground-up rewrite that offers many new features,
  performance improvements, and some breaking changes compared to Pydantic
  V1.

  If you're using Pydantic V1 you may want to look at the pydantic V1.10
  Documentation or, 1.10.X-fixes git branch. Pydantic V2 also ships with
  the latest version of Pydantic V1 built in so that you can incrementally
  upgrade your code base and projects:
  from pydantic import v1 as pydantic_v1.

  Help

  See documentation for more details.

  Installation

  Install using pip install -U pydantic or
  conda install pydantic -c conda-forge. For more installation options to
  make Pydantic even faster, see the Install section in the documentation.

  A Simple Example

      from datetime import datetime
      from typing import List, Optional
      from pydantic import BaseModel

      class User(BaseModel):
          id: int
          name: str = 'John Doe'
          signup_ts: Optional[datetime] = None
          friends: List[int] = []

      external_data = {'id': '123', 'signup_ts': '2017-06-01 12:22', 'friends': [1, '2', b'3']}
      user = User(**external_data)
      print(user)
      #> User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]
      print(user.id)
      #> 123

  Contributing

  For guidance on setting up a development environment and how to make a
  contribution to Pydantic, see Contributing to Pydantic.

  Reporting a Security Vulnerability

  See our security policy.

  Changelog

  v2.6.3 (2024-02-27)

  GitHub release

  What's Changed

  Packaging

  -   Update pydantic-settings version in the docs by @hramezani in #8906

  Fixes

  -   Fix discriminated union schema gen bug by @sydney-runkle in #8904

  v2.6.2 (2024-02-23)

  GitHub release

  What's Changed

  Packaging

  -   Upgrade to pydantic-core 2.16.3 by @sydney-runkle in #8879

  Fixes

  -   'YYYY-MM-DD' date string coerced to datetime shouldn't infer
      timezone by @sydney-runkle in pydantic/pydantic-core#1193

  v2.6.1 (2024-02-05)

  GitHub release

  What's Changed

  Packaging

  -   Upgrade to pydantic-core 2.16.2 by @sydney-runkle in #8717

  Fixes

  -   Fix bug with mypy plugin and no_strict_optional = True by @dmontagu
      in #8666
  -   Fix ByteSize error type change by @sydney-runkle in #8681
  -   Fix inheriting Field annotations in dataclasses by @sydney-runkle in
      #8679
  -   Fix regression in core schema generation for indirect definition
      references by @dmontagu in #8702
  -   Fix unsupported types bug with PlainValidator by @sydney-runkle in
      #8710
  -   Reverting problematic fix from 2.6 release, fixing schema building
      bug by @sydney-runkle in #8718
  -   Fix warning for tuple of wrong size in Union by @davidhewitt in
      pydantic/pydantic-core#1174
  -   Fix computed_field JSON serializer exclude_none behavior by
      @sydney-runkle in pydantic/pydantic-core#1187

  v2.6.0 (2024-01-29)

  GitHub release

  The code released in v2.6.0 is practically identical to that of
  v2.6.0b1.

  What's Changed

  Packaging

  -   Check for email-validator version >= 2.0 by @commonism in #6033
  -   Upgrade `ruff`` target version to Python 3.8 by @Elkiwa in #8341
  -   Update to pydantic-extra-types==2.4.1 by @yezz123 in #8478
  -   Update to pyright==1.1.345 by @Viicos in #8453
  -   Update pydantic-core from 2.14.6 to 2.16.1, significant changes from
      these updates are described below, full changelog here

  New Features

  -   Add NatsDsn by @ekeew in #6874
  -   Add ConfigDict.ser_json_inf_nan by @davidhewitt in #8159
  -   Add types.OnErrorOmit by @adriangb in #8222
  -   Support AliasGenerator usage by @sydney-runkle in #8282
  -   Add Pydantic People Page to docs by @sydney-runkle in #8345
  -   Support yyyy-MM-DD datetime parsing by @sydney-runkle in #8404
  -   Added bits conversions to the ByteSize class #8415 by @luca-matei in
      #8507
  -   Enable json schema creation with type ByteSize by @geospackle in
      #8537
  -   Add eval_type_backport to handle union operator and builtin generic
      subscripting in older Pythons by @alexmojaki in #8209
  -   Add support for dataclass fields init by @dmontagu in #8552
  -   Implement pickling for ValidationError by @davidhewitt in
      pydantic/pydantic-core#1119
  -   Add unified tuple validator that can handle "variadic" tuples via
      PEP-646 by @dmontagu in pydantic/pydantic-core#865

  Changes

  -   Drop Python3.7 support by @hramezani in #7188
  -   Drop Python 3.7, and PyPy 3.7 and 3.8 by @davidhewitt in
      pydantic/pydantic-core#1129
  -   Use positional-only self in BaseModel constructor, so no field name
      can ever conflict with it by @ariebovenberg in #8072
  -   Make @validate_call return a function instead of a custom
      descriptor - fixes binding issue with inheritance and adds self/cls
      argument to validation errors by @alexmojaki in #8268
  -   Exclude BaseModel docstring from JSON schema description by
      @sydney-runkle in #8352
  -   Introducing classproperty decorator for model_computed_fields by
      @Jocelyn-Gas in #8437
  -   Explicitly raise an error if field names clashes with types by
      @Viicos in #8243
  -   Use stricter serializer for unions of simple types by @alexdrydew
      pydantic/pydantic-core#1132

  Performance

  -   Add Codspeed profiling Actions workflow by @lambertsbennett in #8054
  -   Improve int extraction by @samuelcolvin in
      pydantic/pydantic-core#1155
  -   Improve performance of recursion guard by @samuelcolvin in
      pydantic/pydantic-core#1156
  -   dataclass serialization speedups by @samuelcolvin in
      pydantic/pydantic-core#1162
  -   Avoid HashMap creation when looking up small JSON objects in
      LazyIndexMaps by @samuelcolvin in pydantic/jiter#55
  -   use hashbrown to speedup python string caching by @davidhewitt in
      pydantic/jiter#51
  -   Replace Peak with more efficient Peek by @davidhewitt in
      pydantic/jiter#48

  Fixes

  -   Move getattr warning in deprecated BaseConfig by @tlambert03 in
      #7183
  -   Only hash model_fields, not whole __dict__ by @alexmojaki in #7786
  -   Fix mishandling of unions while freezing types in the mypy plugin by
      @dmontagu in #7411
  -   Fix mypy error on untyped ClassVar by @vincent-hachin-wmx in #8138
  -   Only compare pydantic fields in BaseModel.__eq__ instead of whole
      __dict__ by @QuentinSoubeyranAqemia in #7825
  -   Update strict docstring in model_validate method. by @LukeTonin in
      #8223
  -   Fix overload position of computed_field by @Viicos in #8227
  -   Fix custom type type casting used in multiple attributes by @ianhfc
      in #8066
  -   Fix issue not allowing validate_call decorator to be dynamically
      assigned to a class method by @jusexton in #8249
  -   Fix issue unittest.mock deprecation warnings by @ibleedicare in
      #8262
  -   Added tests for the case JsonValue contains subclassed primitive
      values by @jusexton in #8286
  -   Fix mypy error on free before validator (classmethod) by
      @sydney-runkle in #8285
  -   Fix to_snake conversion by @jevins09 in #8316
  -   Fix type annotation of ModelMetaclass.__prepare__ by @slanzmich in
      #8305
  -   Disallow config specification when initializing a TypeAdapter when
      the annotated type has config already by @sydney-runkle in #8365
  -   Fix a naming issue with JSON schema for generics parametrized by
      recursive type aliases by @dmontagu in #8389
  -   Fix type annotation in pydantic people script by @shenxiangzhuang in
      #8402
  -   Add support for field alias in dataclass signature by @NeevCohen in
      #8387
  -   Fix bug with schema generation with Field(...) in a forward ref by
      @dmontagu in #8494
  -   Fix ordering of keys in __dict__ with model_construct call by
      @sydney-runkle in #8500
  -   Fix module path_type creation when globals does not contain __name__
      by @hramezani in #8470
  -   Fix for namespace issue with dataclasses with
      from __future__ import annotations by @sydney-runkle in #8513
  -   Fix: make function validator types positional-only by @pmmmwh in
      #8479
  -   Fix usage of @deprecated by @Viicos in #8294
  -   Add more support for private attributes in model_construct call by
      @sydney-runkle in #8525
  -   Use a stack for the types namespace by @dmontagu in #8378
  -   Fix schema-building bug with TypeAliasType for types with refs by
      @dmontagu in #8526
  -   Support pydantic.Field(repr=False) in dataclasses by @tigeryy2 in
      #8511
  -   Override dataclass_transform behavior for RootModel by @Viicos in
      #8163
  -   Refactor signature generation for simplicity by @sydney-runkle in
      #8572
  -   Fix ordering bug of PlainValidator annotation by @Anvil in #8567
  -   Fix exclude_none for json serialization of computed_fields by
      @sydney-runkle in pydantic/pydantic-core#1098
  -   Support yyyy-MM-DD string for datetimes by @sydney-runkle in
      pydantic/pydantic-core#1124
  -   Tweak ordering of definitions in generated schemas by
      @StrawHatDrag0n in #8583

  New Contributors

  pydantic

  -   @ekeew made their first contribution in #6874
  -   @lambertsbennett made their first contribution in #8054
  -   @vincent-hachin-wmx made their first contribution in #8138
  -   @QuentinSoubeyranAqemia made their first contribution in #7825
  -   @ariebovenberg made their first contribution in #8072
  -   @LukeTonin made their first contribution in #8223
  -   @denisart made their first contribution in #8231
  -   @ianhfc made their first contribution in #8066
  -   @eonu made their first contribution in #8255
  -   @amandahla made their first contribution in #8263
  -   @ibleedicare made their first contribution in #8262
  -   @jevins09 made their first contribution in #8316
  -   @cuu508 made their first contribution in #8322
  -   @slanzmich made their first contribution in #8305
  -   @jensenbox made their first contribution in #8331
  -   @szepeviktor made their first contribution in #8356
  -   @Elkiwa made their first contribution in #8341
  -   @parhamfh made their first contribution in #8395
  -   @shenxiangzhuang made their first contribution in #8402
  -   @NeevCohen made their first contribution in #8387
  -   @zby made their first contribution in #8497
  -   @patelnets made their first contribution in #8491
  -   @edwardwli made their first contribution in #8503
  -   @luca-matei made their first contribution in #8507
  -   @Jocelyn-Gas made their first contribution in #8437
  -   @bL34cHig0 made their first contribution in #8501
  -   @tigeryy2 made their first contribution in #8511
  -   @geospackle made their first contribution in #8537
  -   @Anvil made their first contribution in #8567
  -   @hungtsetse made their first contribution in #8546
  -   @StrawHatDrag0n made their first contribution in #8583

  pydantic-core

  -   @mariuswinger made their first contribution in
      pydantic/pydantic-core#1087
  -   @adamchainz made their first contribution in
      pydantic/pydantic-core#1090
  -   @akx made their first contribution in pydantic/pydantic-core#1123

  v2.6.0b1 (2024-01-19)

  Pre-release, see the GitHub release for details.

  v2.5.3 (2023-12-22)

  GitHub release

  What's Changed

  Packaging

  -   uprev pydantic-core to 2.14.6

  Fixes

  -   Fix memory leak with recursive definitions creating reference cycles
      by @davidhewitt in pydantic/pydantic-core#1125

  v2.5.2 (2023-11-22)

  GitHub release

  What's Changed

  Packaging

  -   uprev pydantic-core to 2.14.5

  New Features

  -   Add ConfigDict.ser_json_inf_nan by @davidhewitt in #8159

  Fixes

  -   Fix validation of Literal from JSON keys when used as dict key by
      @sydney-runkle in pydantic/pydantic-core#1075
  -   Fix bug re custom_init on members of Union by @sydney-runkle in
      pydantic/pydantic-core#1076
  -   Fix JsonValue bool serialization by @sydney-runkle in #8190
  -   Fix handling of unhashable inputs with Literal in Unions by
      @sydney-runkle in pydantic/pydantic-core#1089

  v2.5.1 (2023-11-15)

  GitHub release

  What's Changed

  Packaging

  -   uprev pydantic-core to 2.14.3 by @samuelcolvin in #8120

  Fixes

  -   Fix package description limit by @dmontagu in #8097
  -   Fix ValidateCallWrapper error when creating a model which has a
      @validate_call wrapped field annotation by @sydney-runkle in #8110

  v2.5.0 (2023-11-13)

  GitHub release

  The code released in v2.5.0 is functionally identical to that of
  v2.5.0b1.

  What's Changed

  Packaging

  -   Update pydantic-core from 2.10.1 to 2.14.1, significant changes from
      these updates are described below, full changelog here
  -   Update to pyright==1.1.335 by @Viicos in #8075

  New Features

  -   Allow plugins to catch non ValidationError errors by @adriangb in
      #7806
  -   Support __doc__ argument in create_model() by @chris-spann in #7863
  -   Expose regex_engine flag - meaning you can use with the Rust or
      Python regex libraries in constraints by @utkini in #7768
  -   Save return type generated from type annotation in ComputedFieldInfo
      by @alexmojaki in #7889
  -   Adopting ruff formatter by @Luca-Blight in #7930
  -   Added validation_error_cause to config by @zakstucke in #7626
  -   Make path of the item to validate available in plugin by @hramezani
      in #7861
  -   Add CallableDiscriminator and Tag by @dmontagu in #7983
      -   CallableDiscriminator renamed to Discriminator by @dmontagu in
          #8047
  -   Make union case tags affect union error messages by @dmontagu in
      #8001
  -   Add examples and json_schema_extra to @computed_field by @alexmojaki
      in #8013
  -   Add JsonValue type by @dmontagu in #7998
  -   Allow str as argument to Discriminator by @dmontagu in #8047
  -   Add SchemaSerializer.__reduce__ method to enable pickle
      serialization by @edoakes in pydantic/pydantic-core#1006

  Changes

  -   Significant Change: replace ultra_strict with new smart union
      implementation, the way unions are validated has changed
      significantly to improve performance and correctness, we have worked
      hard to absolutely minimise the number of cases where behaviour has
      changed, see the PR for details - by @davidhewitt in
      pydantic/pydantic-core#867
  -   Add support for instance method reassignment when extra='allow' by
      @sydney-runkle in #7683
  -   Support JSON schema generation for Enum types with no cases by
      @sydney-runkle in #7927
  -   Warn if a class inherits from Generic before BaseModel by
      @alexmojaki in #7891

  Performance

  -   New custom JSON parser, jiter by @samuelcolvin in
      pydantic/pydantic-core#974
  -   PGO build for MacOS M1 by @samuelcolvin in
      pydantic/pydantic-core#1063
  -   Use __getattr__ for all package imports, improve import time by
      @samuelcolvin in #7947

  Fixes

  -   Fix mypy issue with subclasses of RootModel by @sydney-runkle in
      #7677
  -   Properly rebuild the FieldInfo when a forward ref gets evaluated by
      @dmontagu in #7698
  -   Fix failure to load SecretStr from JSON (regression in v2.4) by
      @sydney-runkle in #7729
  -   Fix defer_build behavior with TypeAdapter by @sydney-runkle in #7736
  -   Improve compatibility with legacy mypy versions by @dmontagu in
      #7742
  -   Fix: update TypeVar handling when default is not set by @pmmmwh in
      #7719
  -   Support specification of strict on Enum type fields by
      @sydney-runkle in #7761
  -   Wrap weakref.ref instead of subclassing to fix cloudpickle
      serialization by @edoakes in #7780
  -   Keep values of private attributes set within model_post_init in
      subclasses by @alexmojaki in #7775
  -   Add more specific type for non-callable json_schema_extra by
      @alexmojaki in #7803
  -   Raise an error when deleting frozen (model) fields by @alexmojaki in
      #7800
  -   Fix schema sorting bug with default values by @sydney-runkle in
      #7817
  -   Use generated alias for aliases that are not specified otherwise by
      @alexmojaki in #7802
  -   Support strict specification for UUID types by @sydney-runkle in
      #7865
  -   JSON schema: fix extra parameter handling by @me-and in #7810
  -   Fix: support pydantic.Field(kw_only=True) with inherited dataclasses
      by @PrettyWood in #7827
  -   Support validate_call decorator for methods in classes with
      __slots__ by @sydney-runkle in #7883
  -   Fix pydantic dataclass problem with dataclasses.field default by
      @hramezani in #7898
  -   Fix schema generation for generics with union type bounds by
      @sydney-runkle in #7899
  -   Fix version for importlib_metadata on python 3.7 by @sydney-runkle
      in #7904
  -   Support | operator (Union) in PydanticRecursiveRef by @alexmojaki in
      #7892
  -   Fix display_as_type for TypeAliasType in python 3.12 by @dmontagu in
      #7929
  -   Add support for NotRequired generics in TypedDict by @sydney-runkle
      in #7932
  -   Make generic TypeAliasType specifications produce different schema
      definitions by @alexdrydew in #7893
  -   Added fix for signature of inherited dataclass by @howsunjow in
      #7925
  -   Make the model name generation more robust in JSON schema by
      @joakimnordling in #7881
  -   Fix plurals in validation error messages (in tests) by @Iipin in
      #7972
  -   PrivateAttr is passed from Annotated default position by @tabassco
      in #8004
  -   Don't decode bytes (which may not be UTF8) when displaying
      SecretBytes by @alexmojaki in #8012
  -   Use classmethod instead of classmethod[Any, Any, Any] by @Mr-Pepe in
      #7979
  -   Clearer error on invalid Plugin by @samuelcolvin in #8023
  -   Correct pydantic dataclasses import by @samuelcolvin in #8027
  -   Fix misbehavior for models referencing redefined type aliases by
      @dmontagu in #8050
  -   Fix Optional field with validate_default only performing one field
      validation by @sydney-runkle in pydantic/pydantic-core#1002
  -   Fix definition-ref bug with Dict keys by @sydney-runkle in
      pydantic/pydantic-core#1014
  -   Fix bug allowing validation of bool types with
      coerce_numbers_to_str=True by @sydney-runkle in
      pydantic/pydantic-core#1017
  -   Don't accept NaN in float and decimal constraints by @davidhewitt in
      pydantic/pydantic-core#1037
  -   Add lax_str and lax_int support for enum values not inherited from
      str/int by @michaelhly in pydantic/pydantic-core#1015
  -   Support subclasses in lists in Union of List types by @sydney-runkle
      in pydantic/pydantic-core#1039
  -   Allow validation against max_digits and decimals to pass if
      normalized or non-normalized input is valid by @sydney-runkle in
      pydantic/pydantic-core#1049
  -   Fix: proper pluralization in ValidationError messages by @Iipin in
      pydantic/pydantic-core#1050
  -   Disallow the string '-' as datetime input by @davidhewitt in
      pydantic/speedate#52 & pydantic/pydantic-core#1060
  -   Fix: NaN and Inf float serialization by @davidhewitt in
      pydantic/pydantic-core#1062
  -   Restore manylinux-compatible PGO builds by @davidhewitt in
      pydantic/pydantic-core#1068

  New Contributors

  pydantic

  -   @schneebuzz made their first contribution in #7699
  -   @edoakes made their first contribution in #7780
  -   @alexmojaki made their first contribution in #7775
  -   @NickG123 made their first contribution in #7751
  -   @gowthamgts made their first contribution in #7830
  -   @jamesbraza made their first contribution in #7848
  -   @laundmo made their first contribution in #7850
  -   @rahmatnazali made their first contribution in #7870
  -   @waterfountain1996 made their first contribution in #7878
  -   @chris-spann made their first contribution in #7863
  -   @me-and made their first contribution in #7810
  -   @utkini made their first contribution in #7768
  -   @bn-l made their first contribution in #7744
  -   @alexdrydew made their first contribution in #7893
  -   @Luca-Blight made their first contribution in #7930
  -   @howsunjow made their first contribution in #7925
  -   @joakimnordling made their first contribution in #7881
  -   @icfly2 made their first contribution in #7976
  -   @Yummy-Yums made their first contribution in #8003
  -   @Iipin made their first contribution in #7972
  -   @tabassco made their first contribution in #8004
  -   @Mr-Pepe made their first contribution in #7979
  -   @0x00cl made their first contribution in #8010
  -   @barraponto made their first contribution in #8032

  pydantic-core

  -   @sisp made their first contribution in pydantic/pydantic-core#995
  -   @michaelhly made their first contribution in
      pydantic/pydantic-core#1015

  v2.5.0b1 (2023-11-09)

  Pre-release, see the GitHub release for details.

  v2.4.2 (2023-09-27)

  GitHub release

  What's Changed

  Fixes

  -   Fix bug with JSON schema for sequence of discriminated union by
      @dmontagu in #7647
  -   Fix schema references in discriminated unions by @adriangb in #7646
  -   Fix json schema generation for recursive models by @adriangb in
      #7653
  -   Fix models_json_schema for generic models by @adriangb in #7654
  -   Fix xfailed test for generic model signatures by @adriangb in #7658

  New Contributors

  -   @austinorr made their first contribution in #7657
  -   @peterHoburg made their first contribution in #7670

  v2.4.1 (2023-09-26)

  GitHub release

  What's Changed

  Packaging

  -   Update pydantic-core to 2.10.1 by @davidhewitt in #7633

  Fixes

  -   Serialize unsubstituted type vars as Any by @adriangb in #7606
  -   Remove schema building caches by @adriangb in #7624
  -   Fix an issue where JSON schema extras weren't JSON encoded by
      @dmontagu in #7625

  v2.4.0 (2023-09-22)

  GitHub release

  What's Changed

  Packaging

  -   Update pydantic-core to 2.10.0 by @samuelcolvin in #7542

  New Features

  -   Add Base64Url types by @dmontagu in #7286
  -   Implement optional number to str coercion by @lig in #7508
  -   Allow access to field_name and data in all validators if there is
      data and a field name by @samuelcolvin in #7542
  -   Add BaseModel.model_validate_strings and
      TypeAdapter.validate_strings by @hramezani in #7552
  -   Add Pydantic plugins experimental implementation by @lig
      @samuelcolvin and @Kludex in #6820

  Changes

  -   Do not override model_post_init in subclass with private attrs by
      @Viicos in #7302
  -   Make fields with defaults not required in the serialization schema
      by default by @dmontagu in #7275
  -   Mark Extra as deprecated by @disrupted in #7299
  -   Make EncodedStr a dataclass by @Kludex in #7396
  -   Move annotated_handlers to be public by @samuelcolvin in #7569

  Performance

  -   Simplify flattening and inlining of CoreSchema by @adriangb in #7523
  -   Remove unused copies in CoreSchema walking by @adriangb in #7528
  -   Add caches for collecting definitions and invalid schemas from a
      CoreSchema by @adriangb in #7527
  -   Eagerly resolve discriminated unions and cache cases where we can't
      by @adriangb in #7529
  -   Replace dict.get and dict.setdefault with more verbose versions in
      CoreSchema building hot paths by @adriangb in #7536
  -   Cache invalid CoreSchema discovery by @adriangb in #7535
  -   Allow disabling CoreSchema validation for faster startup times by
      @adriangb in #7565

  Fixes

  -   Fix config detection for TypedDict from grandparent classes by
      @dmontagu in #7272
  -   Fix hash function generation for frozen models with unusual MRO by
      @dmontagu in #7274
  -   Make strict config overridable in field for Path by @hramezani in
      #7281
  -   Use ser_json_<timedelta|bytes> on default in GenerateJsonSchema by
      @Kludex in #7269
  -   Adding a check that alias is validated as an identifier for Python
      by @andree0 in #7319
  -   Raise an error when computed field overrides field by @sydney-runkle
      in #7346
  -   Fix applying SkipValidation to referenced schemas by @adriangb in
      #7381
  -   Enforce behavior of private attributes having double leading
      underscore by @lig in #7265
  -   Standardize __get_pydantic_core_schema__ signature by @hramezani in
      #7415
  -   Fix generic dataclass fields mutation bug (when using TypeAdapter)
      by @sydney-runkle in #7435
  -   Fix TypeError on model_validator in wrap mode by @pmmmwh in #7496
  -   Improve enum error message by @hramezani in #7506
  -   Make repr work for instances that failed initialization when
      handling ValidationErrors by @dmontagu in #7439
  -   Fixed a regular expression denial of service issue by limiting
      whitespaces by @prodigysml in #7360
  -   Fix handling of UUID values having UUID.version=None by @lig in
      #7566
  -   Fix __iter__ returning private cached_property info by
      @sydney-runkle in #7570
  -   Improvements to version info message by @samuelcolvin in #7594

  New Contributors

  -   @15498th made their first contribution in #7238
  -   @GabrielCappelli made their first contribution in #7213
  -   @tobni made their first contribution in #7184
  -   @redruin1 made their first contribution in #7282
  -   @FacerAin made their first contribution in #7288
  -   @acdha made their first contribution in #7297
  -   @andree0 made their first contribution in #7319
  -   @gordonhart made their first contribution in #7375
  -   @pmmmwh made their first contribution in #7496
  -   @disrupted made their first contribution in #7299
  -   @prodigysml made their first contribution in #7360

  v2.3.0 (2023-08-23)

  GitHub release

  -   ðŸ”¥ Remove orphaned changes file from repo by @lig in #7168
  -   Add copy button on documentation by @Kludex in #7190
  -   Fix docs on JSON type by @Kludex in #7189
  -   Update mypy 1.5.0 to 1.5.1 in CI by @hramezani in #7191
  -   fix download links badge by @samuelcolvin in #7200
  -   add 2.2.1 to changelog by @samuelcolvin in #7212
  -   Make ModelWrapValidator protocols generic by @dmontagu in #7154
  -   Correct Field(..., exclude: bool) docs by @samuelcolvin in #7214
  -   Make shadowing attributes a warning instead of an error by @adriangb
      in #7193
  -   Document Base64Str and Base64Bytes by @Kludex in #7192
  -   Fix config.defer_build for serialization first cases by
      @samuelcolvin in #7024
  -   clean Model docstrings in JSON Schema by @samuelcolvin in #7210
  -   fix #7228 (typo): docs in validators.md to correct validate_default
      kwarg by @lmmx in #7229
  -   âœ… Implement tzinfo.fromutc method for TzInfo in pydantic-core by
      @lig in #7019
  -   Support __get_validators__ by @hramezani in #7197

  v2.2.1 (2023-08-18)

  GitHub release

  -   Make xfailing test for root model extra stop xfailing by @dmontagu
      in #6937
  -   Optimize recursion detection by stopping on the second visit for the
      same object by @mciucu in #7160
  -   fix link in docs by @tlambert03 in #7166
  -   Replace MiMalloc w/ default allocator by @adriangb in
      pydantic/pydantic-core#900
  -   Bump pydantic-core to 2.6.1 and prepare 2.2.1 release by @adriangb
      in #7176

  v2.2.0 (2023-08-17)

  GitHub release

  -   Split "pipx install" setup command into two commands on the
      documentation site by @nomadmtb in #6869
  -   Deprecate Field.include by @hramezani in #6852
  -   Fix typo in default factory error msg by @hramezani in #6880
  -   Simplify handling of typing.Annotated in GenerateSchema by @dmontagu
      in #6887
  -   Re-enable fastapi tests in CI by @dmontagu in #6883
  -   Make it harder to hit collisions with json schema defrefs by
      @dmontagu in #6566
  -   Cleaner error for invalid input to Path fields by @samuelcolvin in
      #6903
  -   ðŸ“ support Coordinate Type by @yezz123 in #6906
  -   Fix ForwardRef wrapper for py 3.10.0 (shim until bpo-45166) by
      @randomir in #6919
  -   Fix misbehavior related to copying of RootModel by @dmontagu in
      #6918
  -   Fix issue with recursion error caused by ParamSpec by @dmontagu in
      #6923
  -   Add section about Constrained classes to the Migration Guide by
      @Kludex in #6924
  -   Use main branch for badge links by @Viicos in #6925
  -   Add test for v1/v2 Annotated discrepancy by @carlbordum in #6926
  -   Make the v1 mypy plugin work with both v1 and v2 by @dmontagu in
      #6921
  -   Fix issue where generic models couldn't be parametrized with
      BaseModel by @dmontagu in #6933
  -   Remove xfail for discriminated union with alias by @dmontagu in
      #6938
  -   add field_serializer to computed_field by @andresliszt in #6965
  -   Use union_schema with Type[Union[...]] by @JeanArhancet in #6952
  -   Fix inherited typeddict attributes / config by @adriangb in #6981
  -   fix dataclass annotated before validator called twice by
      @davidhewitt in #6998
  -   Update test-fastapi deselected tests by @hramezani in #7014
  -   Fix validator doc format by @hramezani in #7015
  -   Fix typo in docstring of model_json_schema by @AdamVinch-Federated
      in #7032
  -   remove unused "type ignores" with pyright by @samuelcolvin in #7026
  -   Add benchmark representing FastAPI startup time by @adriangb in
      #7030
  -   Fix json_encoders for Enum subclasses by @adriangb in #7029
  -   Update docstring of ser_json_bytes regarding base64 encoding by
      @Viicos in #7052
  -   Allow @validate_call to work on async methods by @adriangb in #7046
  -   Fix: mypy error with Settings and SettingsConfigDict by
      @JeanArhancet in #7002
  -   Fix some typos (repeated words and it's/its) by @eumiro in #7063
  -   Fix the typo in docstring by @harunyasar in #7062
  -   Docs: Fix broken URL in the pydantic-settings package recommendation
      by @swetjen in #6995
  -   Handle constraints being applied to schemas that don't accept it by
      @adriangb in #6951
  -   Replace almost_equal_floats with math.isclose by @eumiro in #7082
  -   bump pydantic-core to 2.5.0 by @davidhewitt in #7077
  -   Add short_version and use it in links by @hramezani in #7115
  -   ðŸ“ Add usage link to RootModel by @Kludex in #7113
  -   Revert "Fix default port for mongosrv DSNs (#6827)" by @Kludex in
      #7116
  -   Clarify validate_default and _Unset handling in usage docs and
      migration guide by @benbenbang in #6950
  -   Tweak documentation of Field.exclude by @Viicos in #7086
  -   Do not require validate_assignment to use Field.frozen by @Viicos in
      #7103
  -   tweaks to _core_utils by @samuelcolvin in #7040
  -   Make DefaultDict working with set by @hramezani in #7126
  -   Don't always require typing.Generic as a base for partially
      parametrized models by @dmontagu in #7119
  -   Fix issue with JSON schema incorrectly using parent class core
      schema by @dmontagu in #7020
  -   Fix xfailed test related to TypedDict and alias_generator by
      @dmontagu in #6940
  -   Improve error message for NameEmail by @dmontagu in #6939
  -   Fix generic computed fields by @dmontagu in #6988
  -   Reflect namedtuple default values during validation by @dmontagu in
      #7144
  -   Update dependencies, fix pydantic-core usage, fix CI issues by
      @dmontagu in #7150
  -   Add mypy 1.5.0 by @hramezani in #7118
  -   Handle non-json native enum values by @adriangb in #7056
  -   document round_trip in Json type documentation by @jc-louis in #7137
  -   Relax signature checks to better support builtins and C extension
      functions as validators by @adriangb in #7101
  -   add union_mode='left_to_right' by @davidhewitt in #7151
  -   Include an error message hint for inherited ordering by @yvalencia91
      in #7124
  -   Fix one docs link and resolve some warnings for two others by
      @dmontagu in #7153
  -   Include Field extra keys name in warning by @hramezani in #7136

  v2.1.1 (2023-07-25)

  GitHub release

  -   Skip FieldInfo merging when unnecessary by @dmontagu in #6862

  v2.1.0 (2023-07-25)

  GitHub release

  -   Add StringConstraints for use as Annotated metadata by @adriangb in
      #6605
  -   Try to fix intermittently failing CI by @adriangb in #6683
  -   Remove redundant example of optional vs default. by
      @ehiggs-deliverect in #6676
  -   Docs update by @samuelcolvin in #6692
  -   Remove the Validate always section in validator docs by @adriangb in
      #6679
  -   Fix recursion error in json schema generation by @adriangb in #6720
  -   Fix incorrect subclass check for secretstr by @AlexVndnblcke in
      #6730
  -   update pdm / pdm lockfile to 2.8.0 by @davidhewitt in #6714
  -   unpin pdm on more CI jobs by @davidhewitt in #6755
  -   improve source locations for auxiliary packages in docs by
      @davidhewitt in #6749
  -   Assume builtins don't accept an info argument by @adriangb in #6754
  -   Fix bug where calling help(BaseModelSubclass) raises errors by
      @hramezani in #6758
  -   Fix mypy plugin handling of @model_validator(mode="after") by
      @ljodal in #6753
  -   update pydantic-core to 2.3.1 by @davidhewitt in #6756
  -   Mypy plugin for settings by @hramezani in #6760
  -   Use contentSchema keyword for JSON schema by @dmontagu in #6715
  -   fast-path checking finite decimals by @davidhewitt in #6769
  -   Docs update by @samuelcolvin in #6771
  -   Improve json schema doc by @hramezani in #6772
  -   Update validator docs by @adriangb in #6695
  -   Fix typehint for wrap validator by @dmontagu in #6788
  -   ðŸ› Fix validation warning for unions of Literal and other type by
      @lig in #6628
  -   Update documentation for generics support in V2 by @tpdorsey in
      #6685
  -   add pydantic-core build info to version_info() by @samuelcolvin in
      #6785
  -   Fix pydantic dataclasses that use slots with default values by
      @dmontagu in #6796
  -   Fix inheritance of hash function for frozen models by @dmontagu in
      #6789
  -   âœ¨ Add SkipJsonSchema annotation by @Kludex in #6653
  -   Error if an invalid field name is used with Field by @dmontagu in
      #6797
  -   Add GenericModel to MOVED_IN_V2 by @adriangb in #6776
  -   Remove unused code from docs/usage/types/custom.md by @hramezani in
      #6803
  -   Fix float -> Decimal coercion precision loss by @adriangb in #6810
  -   remove email validation from the north star benchmark by
      @davidhewitt in #6816
  -   Fix link to mypy by @progsmile in #6824
  -   Improve initialization hooks example by @hramezani in #6822
  -   Fix default port for mongosrv DSNs by @dmontagu in #6827
  -   Improve API documentation, in particular more links between usage
      and API docs by @samuelcolvin in #6780
  -   update pydantic-core to 2.4.0 by @davidhewitt in #6831
  -   Fix annotated_types.MaxLen validator for custom sequence types by
      @ImogenBits in #6809
  -   Update V1 by @hramezani in #6833
  -   Make it so callable JSON schema extra works by @dmontagu in #6798
  -   Fix serialization issue with InstanceOf by @dmontagu in #6829
  -   Add back support for json_encoders by @adriangb in #6811
  -   Update field annotations when building the schema by @dmontagu in
      #6838
  -   Use WeakValueDictionary to fix generic memory leak by @dmontagu in
      #6681
  -   Add config.defer_build to optionally make model building lazy by
      @samuelcolvin in #6823
  -   delegate UUID serialization to pydantic-core by @davidhewitt in
      #6850
  -   Update json_encoders docs by @adriangb in #6848
  -   Fix error message for staticmethod/classmethod order with
      validate_call by @dmontagu in #6686
  -   Improve documentation for Config by @samuelcolvin in #6847
  -   Update serialization doc to mention Field.exclude takes priority
      over call-time include/exclude by @hramezani in #6851
  -   Allow customizing core schema generation by making GenerateSchema
      public by @adriangb in #6737

  v2.0.3 (2023-07-05)

  GitHub release

  -   Mention PyObject (v1) moving to ImportString (v2) in migration doc
      by @slafs in #6456
  -   Fix release-tweet CI by @Kludex in #6461
  -   Revise the section on required / optional / nullable fields. by
      @ybressler in #6468
  -   Warn if a type hint is not in fact a type by @adriangb in #6479
  -   Replace TransformSchema with GetPydanticSchema by @dmontagu in #6484
  -   Fix the un-hashability of various annotation types, for use in
      caching generic containers by @dmontagu in #6480
  -   PYD-164: Rework custom types docs by @adriangb in #6490
  -   Fix ci by @adriangb in #6507
  -   Fix forward ref in generic by @adriangb in #6511
  -   Fix generation of serialization JSON schemas for
      core_schema.ChainSchema by @dmontagu in #6515
  -   Document the change in Field.alias behavior in Pydantic V2 by
      @hramezani in #6508
  -   Give better error message attempting to compute the json schema of a
      model with undefined fields by @dmontagu in #6519
  -   Document alias_priority by @tpdorsey in #6520
  -   Add redirect for types documentation by @tpdorsey in #6513
  -   Allow updating docs without release by @samuelcolvin in #6551
  -   Ensure docs tests always run in the right folder by @dmontagu in
      #6487
  -   Defer evaluation of return type hints for serializer functions by
      @dmontagu in #6516
  -   Disable E501 from Ruff and rely on just Black by @adriangb in #6552
  -   Update JSON Schema documentation for V2 by @tpdorsey in #6492
  -   Add documentation of cyclic reference handling by @dmontagu in #6493
  -   Remove the need for change files by @samuelcolvin in #6556
  -   add "north star" benchmark by @davidhewitt in #6547
  -   Update Dataclasses docs by @tpdorsey in #6470
  -   â™»ï¸ Use different error message on v1 redirects by @Kludex in #6595
  -   â¬† Upgrade pydantic-core to v2.2.0 by @lig in #6589
  -   Fix serialization for IPvAny by @dmontagu in #6572
  -   Improve CI by using PDM instead of pip to install typing-extensions
      by @adriangb in #6602
  -   Add enum error type docs by @lig in #6603
  -   ðŸ› Fix max_length for unicode strings by @lig in #6559
  -   Add documentation for accessing features via pydantic.v1 by
      @tpdorsey in #6604
  -   Include extra when iterating over a model by @adriangb in #6562
  -   Fix typing of model_validator by @adriangb in #6514
  -   Touch up Decimal validator by @adriangb in #6327
  -   Fix various docstrings using fixed pytest-examples by @dmontagu in
      #6607
  -   Handle function validators in a discriminated union by @dmontagu in
      #6570
  -   Review json_schema.md by @tpdorsey in #6608
  -   Make validate_call work on basemodel methods by @dmontagu in #6569
  -   add test for big int json serde by @davidhewitt in #6614
  -   Fix pydantic dataclass problem with dataclasses.field
      default_factory by @hramezani in #6616
  -   Fixed mypy type inference for TypeAdapter by @zakstucke in #6617
  -   Make it work to use None as a generic parameter by @dmontagu in
      #6609
  -   Make it work to use $ref as an alias by @dmontagu in #6568
  -   add note to migration guide about changes to AnyUrl etc by
      @davidhewitt in #6618
  -   ðŸ› Support defining json_schema_extra on RootModel using Field by
      @lig in #6622
  -   Update pre-commit to prevent commits to main branch on accident by
      @dmontagu in #6636
  -   Fix PDM CI for python 3.7 on MacOS/windows by @dmontagu in #6627
  -   Produce more accurate signatures for pydantic dataclasses by
      @dmontagu in #6633
  -   Updates to Url types for Pydantic V2 by @tpdorsey in #6638
  -   Fix list markdown in transform docstring by @StefanBRas in #6649
  -   simplify slots_dataclass construction to appease mypy by
      @davidhewitt in #6639
  -   Update TypedDict schema generation docstring by @adriangb in #6651
  -   Detect and lint-error for prints by @dmontagu in #6655
  -   Add xfailing test for pydantic-core PR 766 by @dmontagu in #6641
  -   Ignore unrecognized fields from dataclasses metadata by @dmontagu in
      #6634
  -   Make non-existent class getattr a mypy error by @dmontagu in #6658
  -   Update pydantic-core to 2.3.0 by @hramezani in #6648
  -   Use OrderedDict from typing_extensions by @dmontagu in #6664
  -   Fix typehint for JSON schema extra callable by @dmontagu in #6659

  v2.0.2 (2023-07-05)

  GitHub release

  -   Fix bug where round-trip pickling/unpickling a RootModel would
      change the value of __dict__, #6457 by @dmontagu
  -   Allow single-item discriminated unions, #6405 by @dmontagu
  -   Fix issue with union parsing of enums, #6440 by @dmontagu
  -   Docs: Fixed constr documentation, renamed old regex to new pattern,
      #6452 by @miili
  -   Change GenerateJsonSchema.generate_definitions signature, #6436 by
      @dmontagu

  See the full changelog here

  v2.0.1 (2023-07-04)

  GitHub release

  First patch release of Pydantic V2

  -   Extra fields added via setattr (i.e.
      m.some_extra_field = 'extra_value') are added to .model_extra if
      model_config extra='allowed'. Fixed #6333, #6365 by @aaraney
  -   Automatically unpack JSON schema '$ref' for custom types, #6343 by
      @adriangb
  -   Fix tagged unions multiple processing in submodels, #6340 by
      @suharnikov

  See the full changelog here

  v2.0 (2023-06-30)

  GitHub release

  Pydantic V2 is here! ðŸŽ‰

  See this post for more details.

  v2.0b3 (2023-06-16)

  Third beta pre-release of Pydantic V2

  See the full changelog here

  v2.0b2 (2023-06-03)

  Add from_attributes runtime flag to TypeAdapter.validate_python and
  BaseModel.model_validate.

  See the full changelog here

  v2.0b1 (2023-06-01)

  First beta pre-release of Pydantic V2

  See the full changelog here

  v2.0a4 (2023-05-05)

  Fourth pre-release of Pydantic V2

  See the full changelog here

  v2.0a3 (2023-04-20)

  Third pre-release of Pydantic V2

  See the full changelog here

  v2.0a2 (2023-04-12)

  Second pre-release of Pydantic V2

  See the full changelog here

  v2.0a1 (2023-04-03)

  First pre-release of Pydantic V2!

  See this post for more details.

  ... see here for earlier changes.
homepage: null
license: MIT

---
- name: pydantic
  kind: module
  ns: null
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: dataclasses
  kind: module
  ns: pydantic
  description: Provide an enhanced dataclass that performs validation.
  summary: Provide an enhanced dataclass that performs validation
  signatures: null
  inherits_from: null
- name: dataclass
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/dataclasses/

    A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,
    but with added validation.

    This function should be used similarly to `dataclasses.dataclass`.

    Args:
        _cls: The target `dataclass`.
        init: Included for signature compatibility with `dataclasses.dataclass`, and is passed through to
            `dataclasses.dataclass` when appropriate. If specified, must be set to `False`, as pydantic inserts its
            own  `__init__` function.
        repr: A boolean indicating whether to include the field in the `__repr__` output.
        eq: Determines if a `__eq__` method should be generated for the class.
        order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.
        unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.
        frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its
            attributes to be modified after it has been initialized.
        config: The Pydantic config to use for the `dataclass`.
        validate_on_init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses
            are validated on init.
        kw_only: Determines if `__init__` method parameters must be specified by keyword only. Defaults to `False`.
        slots: Determines if the generated class should be a 'slots' `dataclass`, which does not allow the addition of
            new attributes after instantiation.

    Returns:
        A decorator that accepts a class as its argument and returns a Pydantic `dataclass`.

    Raises:
        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: _cls
    default: None
    rest: false
  - name: init
    default: 'False'
    rest: false
    kind: kw-only
  - name: repr
    default: 'True'
    rest: false
    kind: kw-only
  - name: eq
    default: 'True'
    rest: false
    kind: kw-only
  - name: order
    default: 'False'
    rest: false
    kind: kw-only
  - name: unsafe_hash
    default: 'False'
    rest: false
    kind: kw-only
  - name: frozen
    default: 'False'
    rest: false
    kind: kw-only
  - name: config
    default: None
    rest: false
    kind: kw-only
  - name: validate_on_init
    default: None
    rest: false
    kind: kw-only
  - name: kw_only
    default: 'False'
    rest: false
    kind: kw-only
  - name: slots
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: rebuild_dataclass
  kind: function
  ns: pydantic
  description: |-
    Try to rebuild the pydantic-core schema for the dataclass.

    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
    the initial attempt to build the schema, and automatic rebuilding fails.

    This is analogous to `BaseModel.model_rebuild`.

    Args:
        cls: The class to rebuild the pydantic-core schema for.
        force: Whether to force the rebuilding of the schema, defaults to `False`.
        raise_errors: Whether to raise errors, defaults to `True`.
        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
        _types_namespace: The types namespace, defaults to `None`.

    Returns:
        Returns `None` if the schema is already "complete" and rebuilding was not required.
        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
  summary: Try to rebuild the pydantic-core schema for the dataclass
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: force
    default: 'False'
    rest: false
    kind: kw-only
  - name: raise_errors
    default: 'True'
    rest: false
    kind: kw-only
  - name: _parent_namespace_depth
    default: '2'
    rest: false
    kind: kw-only
  - name: _types_namespace
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: field_validator
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#field-validators

    Decorate methods on the class indicating that they should be used to validate fields.

    Example usage:
    ```py
    from typing import Any

    from pydantic import (
        BaseModel,
        ValidationError,
        field_validator,
    )

    class Model(BaseModel):
        a: str

        @field_validator('a')
        @classmethod
        def ensure_foobar(cls, v: Any):
            if 'foobar' not in v:
                raise ValueError('"foobar" not found in a')
            return v

    print(repr(Model(a='this is foobar good')))
    #> Model(a='this is foobar good')

    try:
        Model(a='snap')
    except ValidationError as exc_info:
        print(exc_info)
        '''
        1 validation error for Model
        a
          Value error, "foobar" not found in a [type=value_error, input_value='snap', input_type=str]
        '''
    ```

    For more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).

    Args:
        __field: The first field the `field_validator` should be called on; this is separate
            from `fields` to ensure an error is raised if you don't pass at least one.
        *fields: Additional field(s) the `field_validator` should be called on.
        mode: Specifies whether to validate the fields before or after validation.
        check_fields: Whether to check that the fields actually exist on the model.

    Returns:
        A decorator that can be used to decorate a function to be used as a field_validator.

    Raises:
        PydanticUserError:
            - If `@field_validator` is used bare (with no fields).
            - If the args passed to `@field_validator` as fields are not strings.
            - If `@field_validator` applied to instance methods.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __field
    default: null
    rest: false
  - name: mode
    default: after
    rest: false
    kind: kw-only
  - name: check_fields
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: model_validator
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#model-validators

    Decorate model methods for validation purposes.

    Example usage:
    ```py
    from typing_extensions import Self

    from pydantic import BaseModel, ValidationError, model_validator

    class Square(BaseModel):
        width: float
        height: float

        @model_validator(mode='after')
        def verify_square(self) -> Self:
            if self.width != self.height:
                raise ValueError('width and height do not match')
            return self

    s = Square(width=1, height=1)
    print(repr(s))
    #> Square(width=1.0, height=1.0)

    try:
        Square(width=1, height=2)
    except ValidationError as e:
        print(e)
        '''
        1 validation error for Square
          Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]
        '''
    ```

    For more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).

    Args:
        mode: A required string literal that specifies the validation mode.
            It can be one of the following: 'wrap', 'before', or 'after'.

    Returns:
        A decorator that can be used to decorate a function to be used as a model validator.
  summary: 'Usage docs: https://docs'
  signatures:
  - name: mode
    default: null
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: AfterValidator
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#annotated-validators

    A metadata class that indicates that a validation should be applied **after** the inner validation logic.

    Attributes:
        func: The validator function.

    Example:
        ```py
        from typing_extensions import Annotated

        from pydantic import AfterValidator, BaseModel, ValidationError

        MyInt = Annotated[int, AfterValidator(lambda v: v + 1)]

        class Model(BaseModel):
            a: MyInt

        print(Model(a=1).a)
        #> 2

        try:
            Model(a='a')
        except ValidationError as e:
            print(e.json(indent=2))
            '''
            [
              {
                "type": "int_parsing",
                "loc": [
                  "a"
                ],
                "msg": "Input should be a valid integer, unable to parse string as an integer",
                "input": "a",
                "url": "https://errors.pydantic.dev/2/v/int_parsing"
              }
            ]
            '''
        ```
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - type: AfterValidator
  inherits_from: null
- name: AfterValidator.func
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BeforeValidator
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#annotated-validators

    A metadata class that indicates that a validation should be applied **before** the inner validation logic.

    Attributes:
        func: The validator function.

    Example:
        ```py
        from typing_extensions import Annotated

        from pydantic import BaseModel, BeforeValidator

        MyInt = Annotated[int, BeforeValidator(lambda v: v + 1)]

        class Model(BaseModel):
            a: MyInt

        print(Model(a=1).a)
        #> 2

        try:
            Model(a='a')
        except TypeError as e:
            print(e)
            #> can only concatenate str (not "int") to str
        ```
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - type: BeforeValidator
  inherits_from: null
- name: BeforeValidator.func
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PlainValidator
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#annotated-validators

    A metadata class that indicates that a validation should be applied **instead** of the inner validation logic.

    Attributes:
        func: The validator function.

    Example:
        ```py
        from typing_extensions import Annotated

        from pydantic import BaseModel, PlainValidator

        MyInt = Annotated[int, PlainValidator(lambda v: int(v) + 1)]

        class Model(BaseModel):
            a: MyInt

        print(Model(a='1').a)
        #> 2
        ```
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - type: PlainValidator
  inherits_from: null
- name: PlainValidator.func
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: WrapValidator
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#annotated-validators

    A metadata class that indicates that a validation should be applied **around** the inner validation logic.

    Attributes:
        func: The validator function.

    ```py
    from datetime import datetime

    from typing_extensions import Annotated

    from pydantic import BaseModel, ValidationError, WrapValidator

    def validate_timestamp(v, handler):
        if v == 'now':
            # we don't want to bother with further validation, just return the new value
            return datetime.now()
        try:
            return handler(v)
        except ValidationError:
            # validation failed, in this case we want to return a default value
            return datetime(2000, 1, 1)

    MyTimestamp = Annotated[datetime, WrapValidator(validate_timestamp)]

    class Model(BaseModel):
        a: MyTimestamp

    print(Model(a='now').a)
    #> 2032-01-02 03:04:05.000006
    print(Model(a='invalid').a)
    #> 2000-01-01 00:00:00
    ```
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - type: WrapValidator
  inherits_from: null
- name: WrapValidator.func
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SkipValidation
  kind: class
  ns: pydantic
  description: |-
    If this is applied as an annotation (e.g., via `x: Annotated[int, SkipValidation]`), validation will be
        skipped. You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]`.

    This can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,
    and know that it is safe to skip validation for one or more of the fields.

    Because this converts the validation schema to `any_schema`, subsequent annotation-applied transformations
    may not have the expected effects. Therefore, when used, this annotation should generally be the final
    annotation applied to a type.
  summary: If this is applied as an annotation (e
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: SkipValidation
  inherits_from: null
- name: InstanceOf
  kind: class
  ns: pydantic
  description: |-
    Generic type for annotating a type that is an instance of a given class.

    Example:
        ```py
        from pydantic import BaseModel, InstanceOf

        class Foo:
            ...

        class Bar(BaseModel):
            foo: InstanceOf[Foo]

        Bar(foo=Foo())
        try:
            Bar(foo=42)
        except ValidationError as e:
            print(e)
            """
            [
            â”‚   {
            â”‚   â”‚   'type': 'is_instance_of',
            â”‚   â”‚   'loc': ('foo',),
            â”‚   â”‚   'msg': 'Input should be an instance of Foo',
            â”‚   â”‚   'input': 42,
            â”‚   â”‚   'ctx': {'class': 'Foo'},
            â”‚   â”‚   'url': 'https://errors.pydantic.dev/0.38.0/v/is_instance_of'
            â”‚   }
            ]
            """
        ```
  summary: Generic type for annotating a type that is an instance of a given class
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: InstanceOf
  inherits_from: null
- name: WithJsonSchema
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json_schema/#withjsonschema-annotation

    Add this as an annotation on a field to override the (base) JSON schema that would be generated for that field.
    This provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema,
    such as Callable, or types that have an is-instance core schema, without needing to go so far as creating a
    custom subclass of pydantic.json_schema.GenerateJsonSchema.
    Note that any _modifications_ to the schema that would normally be made (such as setting the title for model fields)
    will still be performed.

    If `mode` is set this will only apply to that schema generation mode, allowing you
    to set different json schemas for validation and serialization.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: json_schema
    default: null
    rest: false
  - kind: positional
    name: mode
    default: None
    rest: false
  - type: WithJsonSchema
  inherits_from: null
- name: WithJsonSchema.json_schema
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: WithJsonSchema.mode
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: root_validator
  kind: function
  ns: pydantic
  description: |-
    Decorate methods on a model indicating that they should be used to validate (and perhaps
    modify) data either before or after standard model parsing/validation is performed.

    Args:
        pre (bool, optional): Whether this validator should be called before the standard
            validators (else after). Defaults to False.
        skip_on_failure (bool, optional): Whether to stop validation and return as soon as a
            failure is encountered. Defaults to False.
        allow_reuse (bool, optional): Whether to track and raise an error if another validator
            refers to the decorated function. Defaults to False.

    Returns:
        Any: A decorator that can be used to decorate a function to be used as a root_validator.
  summary: Decorate methods on a model indicating that they should be used to validate (and perhaps
  signatures:
  - name: pre
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_on_failure
    default: 'False'
    rest: false
    kind: kw-only
  - name: allow_reuse
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: validator
  kind: function
  ns: pydantic
  description: |-
    Decorate methods on the class indicating that they should be used to validate fields.

    Args:
        __field (str): The first field the validator should be called on; this is separate
            from `fields` to ensure an error is raised if you don't pass at least one.
        *fields (str): Additional field(s) the validator should be called on.
        pre (bool, optional): Whether this validator should be called before the standard
            validators (else after). Defaults to False.
        each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate
            individual elements rather than the whole object. Defaults to False.
        always (bool, optional): Whether this method and other validators should be called even if
            the value is missing. Defaults to False.
        check_fields (bool | None, optional): Whether to check that the fields actually exist on the model.
            Defaults to None.
        allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to
            the decorated function. Defaults to False.

    Returns:
        Callable: A decorator that can be used to decorate a
            function to be used as a validator.
  summary: Decorate methods on the class indicating that they should be used to validate fields
  signatures:
  - kind: positional
    name: __field
    default: null
    rest: false
  - name: pre
    default: 'False'
    rest: false
    kind: kw-only
  - name: each_item
    default: 'False'
    rest: false
    kind: kw-only
  - name: always
    default: 'False'
    rest: false
    kind: kw-only
  - name: check_fields
    default: None
    rest: false
    kind: kw-only
  - name: allow_reuse
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: field_serializer
  kind: function
  ns: pydantic
  description: |-
    Decorator that enables custom field serialization.

    In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.

    ```python
    from typing import Set

    from pydantic import BaseModel, field_serializer

    class StudentModel(BaseModel):
        name: str = 'Jane'
        courses: Set[str]

        @field_serializer('courses', when_used='json')
        def serialize_courses_in_order(courses: Set[str]):
            return sorted(courses)

    student = StudentModel(courses={'Math', 'Chemistry', 'English'})
    print(student.model_dump_json())
    #> {"name":"Jane","courses":["Chemistry","English","Math"]}
    ```

    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.

    Four signatures are supported:

    - `(self, value: Any, info: FieldSerializationInfo)`
    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`
    - `(value: Any, info: SerializationInfo)`
    - `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`

    Args:
        fields: Which field(s) the method should be called on.
        mode: The serialization mode.

            - `plain` means the function will be called instead of the default serialization logic,
            - `wrap` means the function will be called with an argument to optionally call the
               default serialization logic.
        return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.
        when_used: Determines the serializer will be used for serialization.
        check_fields: Whether to check that the fields actually exist on the model.

    Returns:
        The decorator function.
  summary: Decorator that enables custom field serialization
  signatures:
  - name: mode
    default: plain
    rest: false
    kind: kw-only
  - name: return_type
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: when_used
    default: always
    rest: false
    kind: kw-only
  - name: check_fields
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: model_serializer
  kind: function
  ns: pydantic
  description: |-
    Decorator that enables custom model serialization.

    This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.

    An example would be to serialize temperature to the same temperature scale, such as degrees Celsius.

    ```python
    from typing import Literal

    from pydantic import BaseModel, model_serializer

    class TemperatureModel(BaseModel):
        unit: Literal['C', 'F']
        value: int

        @model_serializer()
        def serialize_model(self):
            if self.unit == 'F':
                return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}
            return {'unit': self.unit, 'value': self.value}

    temperature = TemperatureModel(unit='F', value=212)
    print(temperature.model_dump())
    #> {'unit': 'C', 'value': 100}
    ```

    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.

    Args:
        __f: The function to be decorated.
        mode: The serialization mode.

            - `'plain'` means the function will be called instead of the default serialization logic
            - `'wrap'` means the function will be called with an argument to optionally call the default
                serialization logic.
        when_used: Determines when this serializer should be used.
        return_type: The return type for the function. If omitted it will be inferred from the type annotation.

    Returns:
        The decorator function.
  summary: Decorator that enables custom model serialization
  signatures:
  - kind: positional
    name: __f
    default: None
    rest: false
  - name: mode
    default: plain
    rest: false
    kind: kw-only
  - name: when_used
    default: always
    rest: false
    kind: kw-only
  - name: return_type
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PlainSerializer
  kind: class
  ns: pydantic
  description: |-
    Plain serializers use a function to modify the output of serialization.

    This is particularly helpful when you want to customize the serialization for annotated types.
    Consider an input of `list`, which will be serialized into a space-delimited string.

    ```python
    from typing import List

    from typing_extensions import Annotated

    from pydantic import BaseModel, PlainSerializer

    CustomStr = Annotated[
        List, PlainSerializer(lambda x: ' '.join(x), return_type=str)
    ]

    class StudentModel(BaseModel):
        courses: CustomStr

    student = StudentModel(courses=['Math', 'Chemistry', 'English'])
    print(student.model_dump())
    #> {'courses': 'Math Chemistry English'}
    ```

    Attributes:
        func: The serializer function.
        return_type: The return type for the function. If omitted it will be inferred from the type annotation.
        when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,
            `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.
  summary: Plain serializers use a function to modify the output of serialization
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - kind: positional
    name: return_type
    default: PydanticUndefined
    rest: false
  - kind: positional
    name: when_used
    default: always
    rest: false
  - type: PlainSerializer
  inherits_from: null
- name: PlainSerializer.func
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PlainSerializer.return_type
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PlainSerializer.when_used
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializeAsAny
  kind: class
  ns: pydantic
  description: SerializeAsAny()
  summary: SerializeAsAny()
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: SerializeAsAny
  inherits_from: null
- name: WrapSerializer
  kind: class
  ns: pydantic
  description: |-
    Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization
    logic, and can modify the resulting value before returning it as the final output of serialization.

    For example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic.

    ```python
    from datetime import datetime, timezone
    from typing import Any, Dict

    from typing_extensions import Annotated

    from pydantic import BaseModel, WrapSerializer

    class EventDatetime(BaseModel):
        start: datetime
        end: datetime

    def convert_to_utc(value: Any, handler, info) -> Dict[str, datetime]:
        # Note that `helper` can actually help serialize the `value` for further custom serialization in case it's a subclass.
        partial_result = handler(value, info)
        if info.mode == 'json':
            return {
                k: datetime.fromisoformat(v).astimezone(timezone.utc)
                for k, v in partial_result.items()
            }
        return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()}

    UTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)]

    class EventModel(BaseModel):
        event_datetime: UTCEventDatetime

    dt = EventDatetime(
        start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00'
    )
    event = EventModel(event_datetime=dt)
    print(event.model_dump())
    '''
    {
        'event_datetime': {
            'start': datetime.datetime(
                2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc
            ),
            'end': datetime.datetime(
                2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc
            ),
        }
    }
    '''

    print(event.model_dump_json())
    '''
    {"event_datetime":{"start":"2024-01-01T15:00:00Z","end":"2024-01-03T14:00:00Z"}}
    '''
    ```

    Attributes:
        func: The serializer function to be wrapped.
        return_type: The return type for the function. If omitted it will be inferred from the type annotation.
        when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,
            `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.
  summary: Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - kind: positional
    name: return_type
    default: PydanticUndefined
    rest: false
  - kind: positional
    name: when_used
    default: always
    rest: false
  - type: WrapSerializer
  inherits_from: null
- name: WrapSerializer.func
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: WrapSerializer.return_type
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: WrapSerializer.when_used
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConfigDict
  kind: class
  ns: pydantic
  description: A TypedDict for configuring Pydantic behaviour.
  summary: A TypedDict for configuring Pydantic behaviour
  signatures: null
  inherits_from:
  - <class 'dict'>
- name: ConfigDict.clear
  kind: callable
  ns: pydantic
  description: D.clear() -> None.  Remove all items from D.
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.copy
  kind: callable
  ns: pydantic
  description: D.copy() -> a shallow copy of D
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.get
  kind: callable
  ns: pydantic
  description: Return the value for key if key is in the dictionary, else default.
  summary: Return the value for key if key is in the dictionary, else default
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConfigDict.items
  kind: callable
  ns: pydantic
  description: D.items() -> a set-like object providing a view on D's items
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.keys
  kind: callable
  ns: pydantic
  description: D.keys() -> a set-like object providing a view on D's keys
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.pop
  kind: callable
  ns: pydantic
  description: |-
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

    If the key is not found, return the default if given; otherwise,
    raise a KeyError.
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.popitem
  kind: callable
  ns: pydantic
  description: |-
    Remove and return a (key, value) pair as a 2-tuple.

    Pairs are returned in LIFO (last-in, first-out) order.
    Raises KeyError if the dict is empty.
  summary: Remove and return a (key, value) pair as a 2-tuple
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConfigDict.setdefault
  kind: callable
  ns: pydantic
  description: |-
    Insert key with a value of default if key is not in the dictionary.

    Return the value for key if key is in the dictionary, else default.
  summary: Insert key with a value of default if key is not in the dictionary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConfigDict.update
  kind: callable
  ns: pydantic
  description: |-
    D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
    If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
    In either case, this is followed by: for k in F:  D[k] = F[k]
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.values
  kind: callable
  ns: pydantic
  description: D.values() -> an object providing a view on D's values
  summary: D
  signatures: null
  inherits_from: null
- name: BaseConfig
  kind: class
  ns: pydantic
  description: |-
    This class is only retained for backwards compatibility.

    !!! Warning "Deprecated"
        BaseConfig is deprecated. Use the [`pydantic.ConfigDict`][pydantic.ConfigDict] instead.
  summary: This class is only retained for backwards compatibility
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: BaseConfig
  inherits_from: null
- name: Extra
  kind: class
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: Extra
  inherits_from: null
- name: Extra.allow
  kind: property
  ns: pydantic
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: Extra.forbid
  kind: property
  ns: pydantic
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: Extra.ignore
  kind: property
  ns: pydantic
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: validate_call
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validation_decorator/

    Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.

    Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.

    Args:
        __func: The function to be decorated.
        config: The configuration dictionary.
        validate_return: Whether to validate the return value.

    Returns:
        The decorated function.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __func
    default: None
    rest: false
  - name: config
    default: None
    rest: false
    kind: kw-only
  - name: validate_return
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PydanticErrorCodes
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PydanticUserError
  kind: class
  ns: pydantic
  description: An error raised due to incorrect use of Pydantic.
  summary: An error raised due to incorrect use of Pydantic
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - name: code
    default: null
    rest: false
    kind: kw-only
  - type: PydanticUserError
  inherits_from:
  - <class 'pydantic.errors.PydanticErrorMixin'>
  - <class 'TypeError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticUserError.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticUserError.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticUserError.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticSchemaGenerationError
  kind: class
  ns: pydantic
  description: |-
    An error raised during failures to generate a `CoreSchema` for some type.

    Attributes:
        message: Description of the error.
  summary: An error raised during failures to generate a `CoreSchema` for some type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - type: PydanticSchemaGenerationError
  inherits_from:
  - <class 'pydantic.errors.PydanticUserError'>
  - <class 'pydantic.errors.PydanticErrorMixin'>
  - <class 'TypeError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticSchemaGenerationError.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticSchemaGenerationError.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticSchemaGenerationError.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticImportError
  kind: class
  ns: pydantic
  description: |-
    An error raised when an import fails due to module changes between V1 and V2.

    Attributes:
        message: Description of the error.
  summary: An error raised when an import fails due to module changes between V1 and V2
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - type: PydanticImportError
  inherits_from:
  - <class 'pydantic.errors.PydanticErrorMixin'>
  - <class 'ImportError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticImportError.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticImportError.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticImportError.msg
  kind: property
  ns: pydantic
  description: exception message
  summary: exception message
  signatures: null
  inherits_from: null
- name: PydanticImportError.name
  kind: property
  ns: pydantic
  description: module name
  summary: module name
  signatures: null
  inherits_from: null
- name: PydanticImportError.path
  kind: property
  ns: pydantic
  description: module path
  summary: module path
  signatures: null
  inherits_from: null
- name: PydanticImportError.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticUndefinedAnnotation
  kind: class
  ns: pydantic
  description: |-
    A subclass of `NameError` raised when handling undefined annotations during `CoreSchema` generation.

    Attributes:
        name: Name of the error.
        message: Description of the error.
  summary: A subclass of `NameError` raised when handling undefined annotations during `CoreSchema` generation
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - type: PydanticUndefinedAnnotation
  inherits_from:
  - <class 'pydantic.errors.PydanticErrorMixin'>
  - <class 'NameError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticUndefinedAnnotation.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticUndefinedAnnotation.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticUndefinedAnnotation.from_name_error
  kind: function
  ns: pydantic
  description: |-
    Convert a `NameError` to a `PydanticUndefinedAnnotation` error.

    Args:
        name_error: `NameError` to be converted.

    Returns:
        Converted `PydanticUndefinedAnnotation` error.
  summary: Convert a `NameError` to a `PydanticUndefinedAnnotation` error
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: name_error
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PydanticUndefinedAnnotation.name
  kind: property
  ns: pydantic
  description: name
  summary: name
  signatures: null
  inherits_from: null
- name: PydanticUndefinedAnnotation.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticInvalidForJsonSchema
  kind: class
  ns: pydantic
  description: |-
    An error raised during failures to generate a JSON schema for some `CoreSchema`.

    Attributes:
        message: Description of the error.
  summary: An error raised during failures to generate a JSON schema for some `CoreSchema`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - type: PydanticInvalidForJsonSchema
  inherits_from:
  - <class 'pydantic.errors.PydanticUserError'>
  - <class 'pydantic.errors.PydanticErrorMixin'>
  - <class 'TypeError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticInvalidForJsonSchema.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticInvalidForJsonSchema.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticInvalidForJsonSchema.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: Field
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/fields

    Create a field for objects that can be configured.

    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
    apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.

    Note:
        - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`

    Args:
        default: Default value if the field is not set.
        default_factory: A callable to generate the default value, such as :func:`~datetime.utcnow`.
        alias: The name to use for the attribute when validating or serializing by alias.
            This is often used for things like converting between snake and camel case.
        alias_priority: Priority of the alias. This affects whether an alias generator is used.
        validation_alias: Like `alias`, but only affects validation, not serialization.
        serialization_alias: Like `alias`, but only affects serialization, not validation.
        title: Human-readable title.
        description: Human-readable description.
        examples: Example values for this field.
        exclude: Whether to exclude the field from the model serialization.
        discriminator: Field name or Discriminator for discriminating the type in a tagged union.
        json_schema_extra: A dict or callable to provide extra JSON schema properties.
        frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.
        validate_default: If `True`, apply validation to the default value every time you create an instance.
            Otherwise, for performance reasons, the default value of the field is trusted and not validated.
        repr: A boolean indicating whether to include the field in the `__repr__` output.
        init: Whether the field should be included in the constructor of the dataclass.
            (Only applies to dataclasses.)
        init_var: Whether the field should _only_ be included in the constructor of the dataclass.
            (Only applies to dataclasses.)
        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.
            (Only applies to dataclasses.)
        strict: If `True`, strict validation is applied to the field.
            See [Strict Mode](../concepts/strict_mode.md) for details.
        gt: Greater than. If set, value must be greater than this. Only applicable to numbers.
        ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.
        lt: Less than. If set, value must be less than this. Only applicable to numbers.
        le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.
        multiple_of: Value must be a multiple of this. Only applicable to numbers.
        min_length: Minimum length for strings.
        max_length: Maximum length for strings.
        pattern: Pattern for strings (a regular expression).
        allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
        max_digits: Maximum number of allow digits for strings.
        decimal_places: Maximum number of decimal places allowed for numbers.
        union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.
            See [Union Mode](standard_library_types.md#union-mode) for details.
        extra: (Deprecated) Extra fields that will be included in the JSON schema.

            !!! warning Deprecated
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.

    Returns:
        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on
            type-annotated fields without causing a type error.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: alias
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: alias_priority
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: validation_alias
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: serialization_alias
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: title
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: description
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: examples
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: exclude
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: discriminator
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: json_schema_extra
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: frozen
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: validate_default
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: repr
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: init
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: init_var
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: kw_only
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: pattern
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: strict
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: gt
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: ge
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: lt
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: le
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: multiple_of
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: max_digits
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: decimal_places
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: min_length
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: max_length
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: union_mode
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: computed_field
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/fields#the-computed_field-decorator

    Decorator to include `property` and `cached_property` when serializing models or dataclasses.

    This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.

    ```py
    from pydantic import BaseModel, computed_field

    class Rectangle(BaseModel):
        width: int
        length: int

        @computed_field
        @property
        def area(self) -> int:
            return self.width * self.length

    print(Rectangle(width=3, length=2).model_dump())
    #> {'width': 3, 'length': 2, 'area': 6}
    ```

    If applied to functions not yet decorated with `@property` or `@cached_property`, the function is
    automatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,
    and confuse static type checkers, thus explicit use of `@property` is recommended.

    !!! warning "Mypy Warning"
        Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,
        mypy may throw a `Decorated property not supported` error.
        See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.
        To avoid this error message, add `# type: ignore[misc]` to the `@computed_field` line.

        [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.

    ```py
    import random

    from pydantic import BaseModel, computed_field

    class Square(BaseModel):
        width: float

        @computed_field
        def area(self) -> float:  # converted to a `property` by `computed_field`
            return round(self.width**2, 2)

        @area.setter
        def area(self, new_area: float) -> None:
            self.width = new_area**0.5

        @computed_field(alias='the magic number', repr=False)
        def random_number(self) -> int:
            return random.randint(0, 1_000)

    square = Square(width=1.3)

    # `random_number` does not appear in representation
    print(repr(square))
    #> Square(width=1.3, area=1.69)

    print(square.random_number)
    #> 3

    square.area = 4

    print(square.model_dump_json(by_alias=True))
    #> {"width":2.0,"area":4.0,"the magic number":3}
    ```

    !!! warning "Overriding with `computed_field`"
        You can't override a field from a parent class with a `computed_field` in the child class.
        `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.
        See the example below:

    ```py
    from pydantic import BaseModel, computed_field

    class Parent(BaseModel):
        a: str

    try:

        class Child(Parent):
            @computed_field
            @property
            def a(self) -> str:
                return 'new a'

    except ValueError as e:
        print(repr(e))
        #> ValueError("you can't override a field with a computed field")
    ```

    Private properties decorated with `@computed_field` have `repr=False` by default.

    ```py
    from functools import cached_property

    from pydantic import BaseModel, computed_field

    class Model(BaseModel):
        foo: int

        @computed_field
        @cached_property
        def _private_cached_property(self) -> int:
            return -self.foo

        @computed_field
        @property
        def _private_property(self) -> int:
            return -self.foo

    m = Model(foo=1)
    print(repr(m))
    #> M(foo=1)
    ```

    Args:
        __f: the function to wrap.
        alias: alias to use when serializing this computed field, only used when `by_alias=True`
        alias_priority: priority of the alias. This affects whether an alias generator is used
        title: Title to use when including this computed field in JSON Schema
        description: Description to use when including this computed field in JSON Schema, defaults to the function's
            docstring
        examples: Example values to use when including this computed field in JSON Schema
        json_schema_extra: A dict or callable to provide extra JSON schema properties.
        repr: whether to include this computed field in model repr.
            Default is `False` for private properties and `True` for public properties.
        return_type: optional return for serialization logic to expect when serializing to JSON, if included
            this must be correct, otherwise a `TypeError` is raised.
            If you don't include a return type Any is used, which does runtime introspection to handle arbitrary
            objects.

    Returns:
        A proxy wrapper for the property.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __f
    default: None
    rest: false
  - name: alias
    default: None
    rest: false
    kind: kw-only
  - name: alias_priority
    default: None
    rest: false
    kind: kw-only
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: description
    default: None
    rest: false
    kind: kw-only
  - name: examples
    default: None
    rest: false
    kind: kw-only
  - name: json_schema_extra
    default: None
    rest: false
    kind: kw-only
  - name: repr
    default: None
    rest: false
    kind: kw-only
  - name: return_type
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PrivateAttr
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/models/#private-model-attributes

    Indicates that an attribute is intended for private use and not handled during normal validation/serialization.

    Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.

    Private attributes are stored in `__private_attributes__` on the model.

    Args:
        default: The attribute's default value. Defaults to Undefined.
        default_factory: Callable that will be
            called when a default value is needed for this attribute.
            If both `default` and `default_factory` are set, an error will be raised.

    Returns:
        An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.

    Raises:
        ValueError: If both `default` and `default_factory` are set.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: AliasChoices
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/alias#aliaspath-and-aliaschoices

    A data class used by `validation_alias` as a convenience to create aliases.

    Attributes:
        choices: A list containing a string or `AliasPath`.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: first_choice
    default: null
    rest: false
  - type: AliasChoices
  inherits_from: null
- name: AliasChoices.choices
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AliasChoices.convert_to_aliases
  kind: method
  ns: pydantic
  description: |-
    Converts arguments to a list of lists containing string or integer aliases.

    Returns:
        The list of aliases.
  summary: Converts arguments to a list of lists containing string or integer aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AliasGenerator
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/alias#using-an-aliasgenerator

    A data class used by `alias_generator` as a convenience to create various aliases.

    Attributes:
        alias: A callable that takes a field name and returns an alias for it.
        validation_alias: A callable that takes a field name and returns a validation alias for it.
        serialization_alias: A callable that takes a field name and returns a serialization alias for it.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: alias
    default: None
    rest: false
  - kind: positional
    name: validation_alias
    default: None
    rest: false
  - kind: positional
    name: serialization_alias
    default: None
    rest: false
  - type: AliasGenerator
  inherits_from: null
- name: AliasGenerator.alias
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AliasGenerator.generate_aliases
  kind: method
  ns: pydantic
  description: |-
    Generate `alias`, `validation_alias`, and `serialization_alias` for a field.

    Returns:
        A tuple of three aliases - validation, alias, and serialization.
  summary: Generate `alias`, `validation_alias`, and `serialization_alias` for a field
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: field_name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AliasGenerator.serialization_alias
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AliasGenerator.validation_alias
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AliasPath
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/alias#aliaspath-and-aliaschoices

    A data class used by `validation_alias` as a convenience to create aliases.

    Attributes:
        path: A list of string or integer aliases.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: first_arg
    default: null
    rest: false
  - type: AliasPath
  inherits_from: null
- name: AliasPath.convert_to_aliases
  kind: method
  ns: pydantic
  description: |-
    Converts arguments to a list of string or integer aliases.

    Returns:
        The list of aliases.
  summary: Converts arguments to a list of string or integer aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AliasPath.path
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseModel
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/models/

    A base class for creating Pydantic models.

    Attributes:
        __class_vars__: The names of classvars defined on the model.
        __private_attributes__: Metadata about the private attributes of the model.
        __signature__: The signature for instantiating the model.

        __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.
        __pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.
        __pydantic_custom_init__: Whether the model has a custom `__init__` function.
        __pydantic_decorators__: Metadata containing the decorators defined on the model.
            This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.
        __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to
            __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.
        __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.
        __pydantic_post_init__: The name of the post-init method for the model, if defined.
        __pydantic_root_model__: Whether the model is a `RootModel`.
        __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.
        __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.

        __pydantic_extra__: An instance attribute with the values of extra fields from validation when
            `model_config['extra'] == 'allow'`.
        __pydantic_fields_set__: An instance attribute with the names of fields explicitly set.
        __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: BaseModel
  inherits_from: null
- name: BaseModel.construct
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: _fields_set
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.copy
  kind: method
  ns: pydantic
  description: |-
    Returns a copy of the model.

    !!! warning "Deprecated"
        This method is now deprecated; use `model_copy` instead.

    If you need `include` or `exclude`, use:

    ```py
    data = self.model_dump(include=include, exclude=exclude, round_trip=True)
    data = {**data, **(update or {})}
    copied = self.model_validate(data)
    ```

    Args:
        include: Optional set or mapping specifying which fields to include in the copied model.
        exclude: Optional set or mapping specifying which fields to exclude in the copied model.
        update: Optional dictionary of field-value pairs to override field values in the copied model.
        deep: If True, the values of fields that are Pydantic models will be deep-copied.

    Returns:
        A copy of the model with included, excluded and updated fields as specified.
  summary: Returns a copy of the model
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: update
    default: None
    rest: false
    kind: kw-only
  - name: deep
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.dict
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.from_orm
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.json
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: encoder
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: models_as_dict
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_computed_fields
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseModel.model_config
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseModel.model_construct
  kind: function
  ns: pydantic
  description: |-
    Creates a new instance of the `Model` class with validated data.

    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.
    Default values are respected, but no other validation is performed.
    Behaves as if `Config.extra = 'allow'` was set since it adds all passed values

    Args:
        _fields_set: The set of field names accepted for the Model instance.
        values: Trusted or pre-validated data dictionary.

    Returns:
        A new instance of the `Model` class with validated data.
  summary: Creates a new instance of the `Model` class with validated data
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: _fields_set
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.model_copy
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/serialization/#model_copy

    Returns a copy of the model.

    Args:
        update: Values to change/add in the new model. Note: the data is not validated
            before creating the new model. You should trust this data.
        deep: Set to `True` to make a deep copy of the model.

    Returns:
        New model instance.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: update
    default: None
    rest: false
    kind: kw-only
  - name: deep
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_dump
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/serialization/#modelmodel_dump

    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

    Args:
        mode: The mode in which `to_python` should run.
            If mode is 'json', the output will only contain JSON serializable types.
            If mode is 'python', the output may contain non-JSON-serializable Python objects.
        include: A list of fields to include in the output.
        exclude: A list of fields to exclude from the output.
        by_alias: Whether to use the field's alias in the dictionary key if defined.
        exclude_unset: Whether to exclude fields that have not been explicitly set.
        exclude_defaults: Whether to exclude fields that are set to their default value.
        exclude_none: Whether to exclude fields that have a value of `None`.
        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
        warnings: Whether to log warnings when invalid fields are encountered.

    Returns:
        A dictionary representation of the model.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: mode
    default: python
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_dump_json
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/serialization/#modelmodel_dump_json

    Generates a JSON representation of the model using Pydantic's `to_json` method.

    Args:
        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
        include: Field(s) to include in the JSON output.
        exclude: Field(s) to exclude from the JSON output.
        by_alias: Whether to serialize using field aliases.
        exclude_unset: Whether to exclude fields that have not been explicitly set.
        exclude_defaults: Whether to exclude fields that are set to their default value.
        exclude_none: Whether to exclude fields that have a value of `None`.
        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
        warnings: Whether to log warnings when invalid fields are encountered.

    Returns:
        A JSON string representation of the model.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_extra
  kind: property
  ns: pydantic
  description: |-
    Get extra fields set during validation.

    Returns:
        A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
  summary: Get extra fields set during validation
  signatures: null
  inherits_from: null
- name: BaseModel.model_fields
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseModel.model_fields_set
  kind: property
  ns: pydantic
  description: |-
    Returns the set of fields that have been explicitly set on this model instance.

    Returns:
        A set of strings representing the fields that have been set,
            i.e. that were not filled from defaults.
  summary: Returns the set of fields that have been explicitly set on this model instance
  signatures: null
  inherits_from: null
- name: BaseModel.model_json_schema
  kind: function
  ns: pydantic
  description: |-
    Generates a JSON schema for a model class.

    Args:
        by_alias: Whether to use attribute aliases or not.
        ref_template: The reference template.
        schema_generator: To override the logic used to generate the JSON schema, as a subclass of
            `GenerateJsonSchema` with your desired modifications
        mode: The mode in which to generate the schema.

    Returns:
        The JSON schema for the given model class.
  summary: Generates a JSON schema for a model class
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/$defs/{model}'
    rest: false
  - kind: positional
    name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
  - kind: positional
    name: mode
    default: validation
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.model_parametrized_name
  kind: function
  ns: pydantic
  description: |-
    Compute the class name for parametrizations of generic classes.

    This method can be overridden to achieve a custom naming scheme for generic BaseModels.

    Args:
        params: Tuple of types of the class. Given a generic class
            `Model` with 2 type variables and a concrete model `Model[str, int]`,
            the value `(str, int)` would be passed to `params`.

    Returns:
        String representing the new class where `params` are passed to `cls` as type variables.

    Raises:
        TypeError: Raised when trying to generate concrete names for non-generic models.
  summary: Compute the class name for parametrizations of generic classes
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: params
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.model_post_init
  kind: method
  ns: pydantic
  description: |-
    Override this method to perform additional initialization after `__init__` and `model_construct`.
    This is useful if you want to do some validation that requires the entire model to be initialized.
  summary: Override this method to perform additional initialization after `__init__` and `model_construct`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _BaseModel__context
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.model_rebuild
  kind: function
  ns: pydantic
  description: |-
    Try to rebuild the pydantic-core schema for the model.

    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
    the initial attempt to build the schema, and automatic rebuilding fails.

    Args:
        force: Whether to force the rebuilding of the model schema, defaults to `False`.
        raise_errors: Whether to raise errors, defaults to `True`.
        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
        _types_namespace: The types namespace, defaults to `None`.

    Returns:
        Returns `None` if the schema is already "complete" and rebuilding was not required.
        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
  summary: Try to rebuild the pydantic-core schema for the model
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: force
    default: 'False'
    rest: false
    kind: kw-only
  - name: raise_errors
    default: 'True'
    rest: false
    kind: kw-only
  - name: _parent_namespace_depth
    default: '2'
    rest: false
    kind: kw-only
  - name: _types_namespace
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_validate
  kind: function
  ns: pydantic
  description: |-
    Validate a pydantic model instance.

    Args:
        obj: The object to validate.
        strict: Whether to enforce types strictly.
        from_attributes: Whether to extract data from object attributes.
        context: Additional context to pass to the validator.

    Raises:
        ValidationError: If the object could not be validated.

    Returns:
        The validated model instance.
  summary: Validate a pydantic model instance
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_validate_json
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json/#json-parsing

    Validate the given JSON data against the Pydantic model.

    Args:
        json_data: The JSON data to validate.
        strict: Whether to enforce types strictly.
        context: Extra variables to pass to the validator.

    Returns:
        The validated Pydantic model.

    Raises:
        ValueError: If `json_data` is not a JSON string.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: json_data
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.model_validate_strings
  kind: function
  ns: pydantic
  description: |-
    Validate the given object contains string data against the Pydantic model.

    Args:
        obj: The object contains string data to validate.
        strict: Whether to enforce types strictly.
        context: Extra variables to pass to the validator.

    Returns:
        The validated Pydantic model.
  summary: Validate the given object contains string data against the Pydantic model
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.parse_file
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: path
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.parse_obj
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.parse_raw
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.schema
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/$defs/{model}'
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.schema_json
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.update_forward_refs
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.validate
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: create_model
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/models/#dynamic-model-creation

    Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a
    subclass of [`BaseModel`][pydantic.BaseModel].

    Args:
        __model_name: The name of the newly created model.
        __config__: The configuration of the new model.
        __doc__: The docstring of the new model.
        __base__: The base class or classes for the new model.
        __module__: The name of the module that the model belongs to;
            if `None`, the value is taken from `sys._getframe(1)`
        __validators__: A dictionary of methods that validate fields.
        __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.
        __slots__: Deprecated. Should not be passed to `create_model`.
        **field_definitions: Attributes of the new model. They should be passed in the format:
            `<name>=(<type>, <default value>)` or `<name>=(<type>, <FieldInfo>)`.

    Returns:
        The new [model][pydantic.BaseModel].

    Raises:
        PydanticUserError: If `__base__` and `__config__` are both passed.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __model_name
    default: null
    rest: false
  - name: __config__
    default: None
    rest: false
    kind: kw-only
  - name: __doc__
    default: None
    rest: false
    kind: kw-only
  - name: __base__
    default: None
    rest: false
    kind: kw-only
  - name: __module__
    default: None
    rest: false
    kind: kw-only
  - name: __validators__
    default: None
    rest: false
    kind: kw-only
  - name: __cls_kwargs__
    default: None
    rest: false
    kind: kw-only
  - name: __slots__
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: AnyUrl
  kind: class
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: url
    default: null
    rest: false
  - type: Url
  inherits_from: null
- name: AnyUrl.fragment
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.host
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.password
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.path
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.port
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.query
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.query_params
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.scheme
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.unicode_host
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.unicode_string
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.username
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UrlConstraints
  kind: class
  ns: pydantic
  description: |-
    Url constraints.

    Attributes:
        max_length: The maximum length of the url. Defaults to `None`.
        allowed_schemes: The allowed schemes. Defaults to `None`.
        host_required: Whether the host is required. Defaults to `None`.
        default_host: The default host. Defaults to `None`.
        default_port: The default port. Defaults to `None`.
        default_path: The default path. Defaults to `None`.
  summary: Url constraints
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: max_length
    default: None
    rest: false
  - kind: positional
    name: allowed_schemes
    default: None
    rest: false
  - kind: positional
    name: host_required
    default: None
    rest: false
  - kind: positional
    name: default_host
    default: None
    rest: false
  - kind: positional
    name: default_port
    default: None
    rest: false
  - kind: positional
    name: default_path
    default: None
    rest: false
  - type: UrlConstraints
  inherits_from:
  - <class 'pydantic._internal._fields.PydanticMetadata'>
  - <class 'pydantic._internal._repr.Representation'>
- name: UrlConstraints.allowed_schemes
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UrlConstraints.default_host
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UrlConstraints.default_path
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UrlConstraints.default_port
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UrlConstraints.host_required
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UrlConstraints.max_length
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: EmailStr
  kind: class
  ns: pydantic
  description: |-
    Info:
        To use this type, you need to install the optional
        [`email-validator`](https://github.com/JoshData/python-email-validator) package:

        ```bash
        pip install email-validator
        ```

    Validate email addresses.

    ```py
    from pydantic import BaseModel, EmailStr

    class Model(BaseModel):
        email: EmailStr

    print(Model(email='contact@mail.com'))
    #> email='contact@mail.com'
    ```
  summary: 'Info:'
  signatures:
  - type: EmailStr
  inherits_from: null
- name: NameEmail
  kind: class
  ns: pydantic
  description: |-
    Info:
        To use this type, you need to install the optional
        [`email-validator`](https://github.com/JoshData/python-email-validator) package:

        ```bash
        pip install email-validator
        ```

    Validate a name and email address combination, as specified by
    [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).

    The `NameEmail` has two properties: `name` and `email`.
    In case the `name` is not provided, it's inferred from the email address.

    ```py
    from pydantic import BaseModel, NameEmail

    class User(BaseModel):
        email: NameEmail

    user = User(email='Fred Bloggs <fred.bloggs@example.com>')
    print(user.email)
    #> Fred Bloggs <fred.bloggs@example.com>
    print(user.email.name)
    #> Fred Bloggs

    user = User(email='fred.bloggs@example.com')
    print(user.email)
    #> fred.bloggs <fred.bloggs@example.com>
    print(user.email.name)
    #> fred.bloggs
    ```
  summary: 'Info:'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - kind: positional
    name: email
    default: null
    rest: false
  - type: NameEmail
  inherits_from:
  - <class 'pydantic._internal._repr.Representation'>
- name: NameEmail.email
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NameEmail.name
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyAddress
  kind: class
  ns: pydantic
  description: |-
    Validate an IPv4 or IPv6 address.

    ```py
    from pydantic import BaseModel
    from pydantic.networks import IPvAnyAddress

    class IpModel(BaseModel):
        ip: IPvAnyAddress

    print(IpModel(ip='127.0.0.1'))
    #> ip=IPv4Address('127.0.0.1')

    try:
        IpModel(ip='http://www.example.com')
    except ValueError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'ip_any_address',
                'loc': ('ip',),
                'msg': 'value is not a valid IPv4 or IPv6 address',
                'input': 'http://www.example.com',
            }
        ]
        '''
    ```
  summary: Validate an IPv4 or IPv6 address
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: IPvAnyAddress
  inherits_from: null
- name: IPvAnyInterface
  kind: class
  ns: pydantic
  description: Validate an IPv4 or IPv6 interface.
  summary: Validate an IPv4 or IPv6 interface
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: IPvAnyInterface
  inherits_from: null
- name: IPvAnyNetwork
  kind: class
  ns: pydantic
  description: Validate an IPv4 or IPv6 network.
  summary: Validate an IPv4 or IPv6 network
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: IPvAnyNetwork
  inherits_from: null
- name: PostgresDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NatsDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MySQLDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MariaDBDsn
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: validate_email
  kind: function
  ns: pydantic
  description: |-
    Email address validation using [email-validator](https://pypi.org/project/email-validator/).

    Note:
        Note that:

        * Raw IP address (literal) domain parts are not allowed.
        * `"John Doe <local_part@domain.com>"` style "pretty" email addresses are processed.
        * Spaces are striped from the beginning and end of addresses, but no error is raised.
  summary: Email address validation using [email-validator](https://pypi
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/models/#rootmodel-and-custom-root-types

    A Pydantic `BaseModel` for the root object of the model.

    Attributes:
        root: The root object of the model.
        __pydantic_root_model__: Whether the model is a RootModel.
        __pydantic_private__: Private fields in the model.
        __pydantic_extra__: Extra fields in the model.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: root
    default: PydanticUndefined
    rest: false
  - type: RootModel
  inherits_from:
  - <class 'pydantic.main.BaseModel'>
  - <class 'typing.Generic'>
- name: RootModel.construct
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: _fields_set
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.copy
  kind: method
  ns: pydantic
  description: |-
    Returns a copy of the model.

    !!! warning "Deprecated"
        This method is now deprecated; use `model_copy` instead.

    If you need `include` or `exclude`, use:

    ```py
    data = self.model_dump(include=include, exclude=exclude, round_trip=True)
    data = {**data, **(update or {})}
    copied = self.model_validate(data)
    ```

    Args:
        include: Optional set or mapping specifying which fields to include in the copied model.
        exclude: Optional set or mapping specifying which fields to exclude in the copied model.
        update: Optional dictionary of field-value pairs to override field values in the copied model.
        deep: If True, the values of fields that are Pydantic models will be deep-copied.

    Returns:
        A copy of the model with included, excluded and updated fields as specified.
  summary: Returns a copy of the model
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: update
    default: None
    rest: false
    kind: kw-only
  - name: deep
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.dict
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.from_orm
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.json
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: encoder
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: models_as_dict
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_computed_fields
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: RootModel.model_config
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: RootModel.model_construct
  kind: function
  ns: pydantic
  description: |-
    Create a new model using the provided root object and update fields set.

    Args:
        root: The root object of the model.
        _fields_set: The set of fields to be updated.

    Returns:
        The new model.

    Raises:
        NotImplemented: If the model is not a subclass of `RootModel`.
  summary: Create a new model using the provided root object and update fields set
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: root
    default: null
    rest: false
  - kind: positional
    name: _fields_set
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.model_copy
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/serialization/#model_copy

    Returns a copy of the model.

    Args:
        update: Values to change/add in the new model. Note: the data is not validated
            before creating the new model. You should trust this data.
        deep: Set to `True` to make a deep copy of the model.

    Returns:
        New model instance.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: update
    default: None
    rest: false
    kind: kw-only
  - name: deep
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_dump
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/serialization/#modelmodel_dump

    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

    Args:
        mode: The mode in which `to_python` should run.
            If mode is 'json', the output will only contain JSON serializable types.
            If mode is 'python', the output may contain non-JSON-serializable Python objects.
        include: A list of fields to include in the output.
        exclude: A list of fields to exclude from the output.
        by_alias: Whether to use the field's alias in the dictionary key if defined.
        exclude_unset: Whether to exclude fields that have not been explicitly set.
        exclude_defaults: Whether to exclude fields that are set to their default value.
        exclude_none: Whether to exclude fields that have a value of `None`.
        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
        warnings: Whether to log warnings when invalid fields are encountered.

    Returns:
        A dictionary representation of the model.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: mode
    default: python
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_dump_json
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/serialization/#modelmodel_dump_json

    Generates a JSON representation of the model using Pydantic's `to_json` method.

    Args:
        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
        include: Field(s) to include in the JSON output.
        exclude: Field(s) to exclude from the JSON output.
        by_alias: Whether to serialize using field aliases.
        exclude_unset: Whether to exclude fields that have not been explicitly set.
        exclude_defaults: Whether to exclude fields that are set to their default value.
        exclude_none: Whether to exclude fields that have a value of `None`.
        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].
        warnings: Whether to log warnings when invalid fields are encountered.

    Returns:
        A JSON string representation of the model.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_extra
  kind: property
  ns: pydantic
  description: |-
    Get extra fields set during validation.

    Returns:
        A dictionary of extra fields, or `None` if `config.extra` is not set to `"allow"`.
  summary: Get extra fields set during validation
  signatures: null
  inherits_from: null
- name: RootModel.model_fields
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: RootModel.model_fields_set
  kind: property
  ns: pydantic
  description: |-
    Returns the set of fields that have been explicitly set on this model instance.

    Returns:
        A set of strings representing the fields that have been set,
            i.e. that were not filled from defaults.
  summary: Returns the set of fields that have been explicitly set on this model instance
  signatures: null
  inherits_from: null
- name: RootModel.model_json_schema
  kind: function
  ns: pydantic
  description: |-
    Generates a JSON schema for a model class.

    Args:
        by_alias: Whether to use attribute aliases or not.
        ref_template: The reference template.
        schema_generator: To override the logic used to generate the JSON schema, as a subclass of
            `GenerateJsonSchema` with your desired modifications
        mode: The mode in which to generate the schema.

    Returns:
        The JSON schema for the given model class.
  summary: Generates a JSON schema for a model class
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/$defs/{model}'
    rest: false
  - kind: positional
    name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
  - kind: positional
    name: mode
    default: validation
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.model_parametrized_name
  kind: function
  ns: pydantic
  description: |-
    Compute the class name for parametrizations of generic classes.

    This method can be overridden to achieve a custom naming scheme for generic BaseModels.

    Args:
        params: Tuple of types of the class. Given a generic class
            `Model` with 2 type variables and a concrete model `Model[str, int]`,
            the value `(str, int)` would be passed to `params`.

    Returns:
        String representing the new class where `params` are passed to `cls` as type variables.

    Raises:
        TypeError: Raised when trying to generate concrete names for non-generic models.
  summary: Compute the class name for parametrizations of generic classes
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: params
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.model_post_init
  kind: method
  ns: pydantic
  description: |-
    Override this method to perform additional initialization after `__init__` and `model_construct`.
    This is useful if you want to do some validation that requires the entire model to be initialized.
  summary: Override this method to perform additional initialization after `__init__` and `model_construct`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _BaseModel__context
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.model_rebuild
  kind: function
  ns: pydantic
  description: |-
    Try to rebuild the pydantic-core schema for the model.

    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
    the initial attempt to build the schema, and automatic rebuilding fails.

    Args:
        force: Whether to force the rebuilding of the model schema, defaults to `False`.
        raise_errors: Whether to raise errors, defaults to `True`.
        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
        _types_namespace: The types namespace, defaults to `None`.

    Returns:
        Returns `None` if the schema is already "complete" and rebuilding was not required.
        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
  summary: Try to rebuild the pydantic-core schema for the model
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: force
    default: 'False'
    rest: false
    kind: kw-only
  - name: raise_errors
    default: 'True'
    rest: false
    kind: kw-only
  - name: _parent_namespace_depth
    default: '2'
    rest: false
    kind: kw-only
  - name: _types_namespace
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_validate
  kind: function
  ns: pydantic
  description: |-
    Validate a pydantic model instance.

    Args:
        obj: The object to validate.
        strict: Whether to enforce types strictly.
        from_attributes: Whether to extract data from object attributes.
        context: Additional context to pass to the validator.

    Raises:
        ValidationError: If the object could not be validated.

    Returns:
        The validated model instance.
  summary: Validate a pydantic model instance
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_validate_json
  kind: function
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json/#json-parsing

    Validate the given JSON data against the Pydantic model.

    Args:
        json_data: The JSON data to validate.
        strict: Whether to enforce types strictly.
        context: Extra variables to pass to the validator.

    Returns:
        The validated Pydantic model.

    Raises:
        ValueError: If `json_data` is not a JSON string.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: json_data
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.model_validate_strings
  kind: function
  ns: pydantic
  description: |-
    Validate the given object contains string data against the Pydantic model.

    Args:
        obj: The object contains string data to validate.
        strict: Whether to enforce types strictly.
        context: Extra variables to pass to the validator.

    Returns:
        The validated Pydantic model.
  summary: Validate the given object contains string data against the Pydantic model
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.parse_file
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: path
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.parse_obj
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.parse_raw
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.schema
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/$defs/{model}'
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.schema_json
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RootModel.update_forward_refs
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RootModel.validate
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_obj_as
  kind: function
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - kind: positional
    name: type_name
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: schema_of
  kind: function
  ns: pydantic
  description: Generate a JSON schema (as dict) for the passed model or dynamically generated one.
  summary: Generate a JSON schema (as dict) for the passed model or dynamically generated one
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: schema_json_of
  kind: function
  ns: pydantic
  description: Generate a JSON schema (as JSON) for the passed model or dynamically generated one.
  summary: Generate a JSON schema (as JSON) for the passed model or dynamically generated one
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Strict
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/strict_mode/#strict-mode-with-annotated-strict

    A field metadata class to indicate that a field should be validated in strict mode.

    Attributes:
        strict: Whether to validate the field in strict mode.

    Example:
        ```python
        from typing_extensions import Annotated

        from pydantic.types import Strict

        StrictBool = Annotated[bool, Strict()]
        ```
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: strict
    default: 'True'
    rest: false
  - type: Strict
  inherits_from:
  - <class 'pydantic._internal._fields.PydanticMetadata'>
  - <class 'pydantic._internal._repr.Representation'>
  - <class 'annotated_types.BaseMetadata'>
- name: Strict.strict
  kind: property
  ns: pydantic
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictStr
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: conbytes
  kind: function
  ns: pydantic
  description: |-
    A wrapper around `bytes` that allows for additional constraints.

    Args:
        min_length: The minimum length of the bytes.
        max_length: The maximum length of the bytes.
        strict: Whether to validate the bytes in strict mode.

    Returns:
        The wrapped bytes type.
  summary: A wrapper around `bytes` that allows for additional constraints
  signatures:
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: conlist
  kind: function
  ns: pydantic
  description: |-
    A wrapper around typing.List that adds validation.

    Args:
        item_type: The type of the items in the list.
        min_length: The minimum length of the list. Defaults to None.
        max_length: The maximum length of the list. Defaults to None.
        unique_items: Whether the items in the list must be unique. Defaults to None.
            !!! warning Deprecated
                The `unique_items` parameter is deprecated, use `Set` instead.
                See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details.

    Returns:
        The wrapped list type.
  summary: A wrapper around typing
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: unique_items
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: conset
  kind: function
  ns: pydantic
  description: |-
    A wrapper around `typing.Set` that allows for additional constraints.

    Args:
        item_type: The type of the items in the set.
        min_length: The minimum length of the set.
        max_length: The maximum length of the set.

    Returns:
        The wrapped set type.
  summary: A wrapper around `typing
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: confrozenset
  kind: function
  ns: pydantic
  description: |-
    A wrapper around `typing.FrozenSet` that allows for additional constraints.

    Args:
        item_type: The type of the items in the frozenset.
        min_length: The minimum length of the frozenset.
        max_length: The maximum length of the frozenset.

    Returns:
        The wrapped frozenset type.
  summary: A wrapper around `typing
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: constr
  kind: function
  ns: pydantic
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`StringConstraints`][pydantic.types.StringConstraints] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `constr` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, constr

            class Foo(BaseModel):
                bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')
            ```

        === ":white_check_mark: Do this"
            ```py
            from typing_extensions import Annotated

            from pydantic import BaseModel, StringConstraints

            class Foo(BaseModel):
                bar: Annotated[str, StringConstraints(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')]
            ```

    A wrapper around `str` that allows for additional constraints.

    ```py
    from pydantic import BaseModel, constr

    class Foo(BaseModel):
        bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')


    foo = Foo(bar='  hello  ')
    print(foo)
    #> bar='HELLO'
    ```

    Args:
        strip_whitespace: Whether to remove leading and trailing whitespace.
        to_upper: Whether to turn all characters to uppercase.
        to_lower: Whether to turn all characters to lowercase.
        strict: Whether to validate the string in strict mode.
        min_length: The minimum length of the string.
        max_length: The maximum length of the string.
        pattern: A regex pattern to validate the string against.

    Returns:
        The wrapped string type.
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strip_whitespace
    default: None
    rest: false
    kind: kw-only
  - name: to_upper
    default: None
    rest: false
    kind: kw-only
  - name: to_lower
    default: None
    rest: false
    kind: kw-only
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: pattern
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: StringConstraints
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/fields/#string-constraints

    Apply constraints to `str` types.

    Attributes:
        strip_whitespace: Whether to strip whitespace from the string.
        to_upper: Whether to convert the string to uppercase.
        to_lower: Whether to convert the string to lowercase.
        strict: Whether to validate the string in strict mode.
        min_length: The minimum length of the string.
        max_length: The maximum length of the string.
        pattern: A regex pattern that the string must match.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: strip_whitespace
    default: None
    rest: false
  - kind: positional
    name: to_upper
    default: None
    rest: false
  - kind: positional
    name: to_lower
    default: None
    rest: false
  - kind: positional
    name: strict
    default: None
    rest: false
  - kind: positional
    name: min_length
    default: None
    rest: false
  - kind: positional
    name: max_length
    default: None
    rest: false
  - kind: positional
    name: pattern
    default: None
    rest: false
  - type: StringConstraints
  inherits_from:
  - <class 'annotated_types.GroupedMetadata'>
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: StringConstraints.max_length
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StringConstraints.min_length
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StringConstraints.pattern
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StringConstraints.strict
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StringConstraints.strip_whitespace
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StringConstraints.to_lower
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StringConstraints.to_upper
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ImportString
  kind: class
  ns: pydantic
  description: |-
    A type that can be used to import a type from a string.

    `ImportString` expects a string and loads the Python object importable at that dotted path.
    Attributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` was provided,
    the resulting field value would be the function`cos`. If a `.` is used and both an attribute and submodule
    are present at the same path, the module will be preferred.

    On model instantiation, pointers will be evaluated and imported. There is
    some nuance to this behavior, demonstrated in the examples below.

    **Good behavior:**
    ```py
    from math import cos

    from pydantic import BaseModel, Field, ImportString, ValidationError


    class ImportThings(BaseModel):
        obj: ImportString


    # A string value will cause an automatic import
    my_cos = ImportThings(obj='math.cos')

    # You can use the imported function as you would expect
    cos_of_0 = my_cos.obj(0)
    assert cos_of_0 == 1


    # A string whose value cannot be imported will raise an error
    try:
        ImportThings(obj='foo.bar')
    except ValidationError as e:
        print(e)
        '''
        1 validation error for ImportThings
        obj
        Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]
        '''


    # Actual python objects can be assigned as well
    my_cos = ImportThings(obj=cos)
    my_cos_2 = ImportThings(obj='math.cos')
    my_cos_3 = ImportThings(obj='math:cos')
    assert my_cos == my_cos_2 == my_cos_3


    # You can set default field value either as Python object:
    class ImportThingsDefaultPyObj(BaseModel):
        obj: ImportString = math.cos


    # or as a string value (but only if used with `validate_default=True`)
    class ImportThingsDefaultString(BaseModel):
        obj: ImportString = Field(default='math.cos', validate_default=True)


    my_cos_default1 = ImportThingsDefaultPyObj()
    my_cos_default2 = ImportThingsDefaultString()
    assert my_cos_default1.obj == my_cos_default2.obj == math.cos


    # note: this will not work!
    class ImportThingsMissingValidateDefault(BaseModel):
        obj: ImportString = 'math.cos'

    my_cos_default3 = ImportThingsMissingValidateDefault()
    assert my_cos_default3.obj == 'math.cos'  # just string, not evaluated
    ```

    Serializing an `ImportString` type to json is also possible.

    ```py
    from pydantic import BaseModel, ImportString


    class ImportThings(BaseModel):
        obj: ImportString


    # Create an instance
    m = ImportThings(obj='math.cos')
    print(m)
    #> obj=<built-in function cos>
    print(m.model_dump_json())
    #> {"obj":"math.cos"}
    ```
  summary: A type that can be used to import a type from a string
  signatures:
  - type: ImportString
  inherits_from: null
- name: conint
  kind: function
  ns: pydantic
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`Field`][pydantic.fields.Field] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `conint` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, conint

            class Foo(BaseModel):
                bar: conint(strict=True, gt=0)
            ```

        === ":white_check_mark: Do this"
            ```py
            from typing_extensions import Annotated

            from pydantic import BaseModel, Field

            class Foo(BaseModel):
                bar: Annotated[int, Field(strict=True, gt=0)]
            ```

    A wrapper around `int` that allows for additional constraints.

    Args:
        strict: Whether to validate the integer in strict mode. Defaults to `None`.
        gt: The value must be greater than this.
        ge: The value must be greater than or equal to this.
        lt: The value must be less than this.
        le: The value must be less than or equal to this.
        multiple_of: The value must be a multiple of this.

    Returns:
        The wrapped integer type.

    ```py
    from pydantic import BaseModel, ValidationError, conint

    class ConstrainedExample(BaseModel):
        constrained_int: conint(gt=1)

    m = ConstrainedExample(constrained_int=2)
    print(repr(m))
    #> ConstrainedExample(constrained_int=2)

    try:
        ConstrainedExample(constrained_int=0)
    except ValidationError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'greater_than',
                'loc': ('constrained_int',),
                'msg': 'Input should be greater than 1',
                'input': 0,
                'ctx': {'gt': 1},
                'url': 'https://errors.pydantic.dev/2/v/greater_than',
            }
        ]
        '''
    ```
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PositiveInt
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeInt
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeInt
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveInt
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: confloat
  kind: function
  ns: pydantic
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`Field`][pydantic.fields.Field] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `confloat` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, confloat

            class Foo(BaseModel):
                bar: confloat(strict=True, gt=0)
            ```

        === ":white_check_mark: Do this"
            ```py
            from typing_extensions import Annotated

            from pydantic import BaseModel, Field

            class Foo(BaseModel):
                bar: Annotated[float, Field(strict=True, gt=0)]
            ```

    A wrapper around `float` that allows for additional constraints.

    Args:
        strict: Whether to validate the float in strict mode.
        gt: The value must be greater than this.
        ge: The value must be greater than or equal to this.
        lt: The value must be less than this.
        le: The value must be less than or equal to this.
        multiple_of: The value must be a multiple of this.
        allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.

    Returns:
        The wrapped float type.

    ```py
    from pydantic import BaseModel, ValidationError, confloat

    class ConstrainedExample(BaseModel):
        constrained_float: confloat(gt=1.0)

    m = ConstrainedExample(constrained_float=1.1)
    print(repr(m))
    #> ConstrainedExample(constrained_float=1.1)

    try:
        ConstrainedExample(constrained_float=0.9)
    except ValidationError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'greater_than',
                'loc': ('constrained_float',),
                'msg': 'Input should be greater than 1',
                'input': 0.9,
                'ctx': {'gt': 1.0},
                'url': 'https://errors.pydantic.dev/2/v/greater_than',
            }
        ]
        '''
    ```
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PositiveFloat
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeFloat
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeFloat
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveFloat
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FiniteFloat
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: condecimal
  kind: function
  ns: pydantic
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`Field`][pydantic.fields.Field] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, condecimal

            class Foo(BaseModel):
                bar: condecimal(strict=True, allow_inf_nan=True)
            ```

        === ":white_check_mark: Do this"
            ```py
            from decimal import Decimal

            from typing_extensions import Annotated

            from pydantic import BaseModel, Field

            class Foo(BaseModel):
                bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]
            ```

    A wrapper around Decimal that adds validation.

    Args:
        strict: Whether to validate the value in strict mode. Defaults to `None`.
        gt: The value must be greater than this. Defaults to `None`.
        ge: The value must be greater than or equal to this. Defaults to `None`.
        lt: The value must be less than this. Defaults to `None`.
        le: The value must be less than or equal to this. Defaults to `None`.
        multiple_of: The value must be a multiple of this. Defaults to `None`.
        max_digits: The maximum number of digits. Defaults to `None`.
        decimal_places: The number of decimal places. Defaults to `None`.
        allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.

    ```py
    from decimal import Decimal

    from pydantic import BaseModel, ValidationError, condecimal

    class ConstrainedExample(BaseModel):
        constrained_decimal: condecimal(gt=Decimal('1.0'))

    m = ConstrainedExample(constrained_decimal=Decimal('1.1'))
    print(repr(m))
    #> ConstrainedExample(constrained_decimal=Decimal('1.1'))

    try:
        ConstrainedExample(constrained_decimal=Decimal('0.9'))
    except ValidationError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'greater_than',
                'loc': ('constrained_decimal',),
                'msg': 'Input should be greater than 1.0',
                'input': Decimal('0.9'),
                'ctx': {'gt': Decimal('1.0')},
                'url': 'https://errors.pydantic.dev/2/v/greater_than',
            }
        ]
        '''
    ```
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - name: max_digits
    default: None
    rest: false
    kind: kw-only
  - name: decimal_places
    default: None
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: condate
  kind: function
  ns: pydantic
  description: |-
    A wrapper for date that adds constraints.

    Args:
        strict: Whether to validate the date value in strict mode. Defaults to `None`.
        gt: The value must be greater than this. Defaults to `None`.
        ge: The value must be greater than or equal to this. Defaults to `None`.
        lt: The value must be less than this. Defaults to `None`.
        le: The value must be less than or equal to this. Defaults to `None`.

    Returns:
        A date type with the specified constraints.
  summary: A wrapper for date that adds constraints
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: UUID1
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UUID3
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UUID4
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UUID5
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NewPath
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Json
  kind: class
  ns: pydantic
  description: |-
    A special type wrapper which loads JSON before parsing.

    You can use the `Json` data type to make Pydantic first load a raw JSON string before
    validating the loaded data into the parametrized type:

    ```py
    from typing import Any, List

    from pydantic import BaseModel, Json, ValidationError


    class AnyJsonModel(BaseModel):
        json_obj: Json[Any]


    class ConstrainedJsonModel(BaseModel):
        json_obj: Json[List[int]]


    print(AnyJsonModel(json_obj='{"b": 1}'))
    #> json_obj={'b': 1}
    print(ConstrainedJsonModel(json_obj='[1, 2, 3]'))
    #> json_obj=[1, 2, 3]

    try:
        ConstrainedJsonModel(json_obj=12)
    except ValidationError as e:
        print(e)
        '''
        1 validation error for ConstrainedJsonModel
        json_obj
        JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]
        '''

    try:
        ConstrainedJsonModel(json_obj='[a, b]')
    except ValidationError as e:
        print(e)
        '''
        1 validation error for ConstrainedJsonModel
        json_obj
        Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]
        '''

    try:
        ConstrainedJsonModel(json_obj='["a", "b"]')
    except ValidationError as e:
        print(e)
        '''
        2 validation errors for ConstrainedJsonModel
        json_obj.0
        Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]
        json_obj.1
        Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]
        '''
    ```

    When you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,
    not the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:

    ```py
    from typing import List

    from pydantic import BaseModel, Json


    class ConstrainedJsonModel(BaseModel):
        json_obj: Json[List[int]]


    print(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())
    #> {"json_obj":[1,2,3]}
    print(
        ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)
    )
    #> {"json_obj":"[1,2,3]"}
    ```
  summary: A special type wrapper which loads JSON before parsing
  signatures:
  - type: Json
  inherits_from: null
- name: SecretStr
  kind: class
  ns: pydantic
  description: |-
    A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.

    When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in
    calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `''`.

    ```py
    from pydantic import BaseModel, SecretStr

    class User(BaseModel):
        username: str
        password: SecretStr

    user = User(username='scolvin', password='password1')

    print(user)
    #> username='scolvin' password=SecretStr('**********')
    print(user.password.get_secret_value())
    #> password1
    print((SecretStr('password'), SecretStr('')))
    #> (SecretStr('**********'), SecretStr(''))
    ```
  summary: A string used for storing sensitive information that you do not want to be visible in logging or tracebacks
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: secret_value
    default: null
    rest: false
  - type: SecretStr
  inherits_from:
  - <class 'pydantic.types._SecretField'>
  - <class 'typing.Generic'>
- name: SecretStr.get_secret_value
  kind: method
  ns: pydantic
  description: |-
    Get the secret value.

    Returns:
        The secret value.
  summary: Get the secret value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretBytes
  kind: class
  ns: pydantic
  description: |-
    A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.

    It displays `b'**********'` instead of the string value on `repr()` and `str()` calls.
    When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in
    calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `b''`.

    ```py
    from pydantic import BaseModel, SecretBytes

    class User(BaseModel):
        username: str
        password: SecretBytes

    user = User(username='scolvin', password=b'password1')
    #> username='scolvin' password=SecretBytes(b'**********')
    print(user.password.get_secret_value())
    #> b'password1'
    print((SecretBytes(b'password'), SecretBytes(b'')))
    #> (SecretBytes(b'**********'), SecretBytes(b''))
    ```
  summary: A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: secret_value
    default: null
    rest: false
  - type: SecretBytes
  inherits_from:
  - <class 'pydantic.types._SecretField'>
  - <class 'typing.Generic'>
- name: SecretBytes.get_secret_value
  kind: method
  ns: pydantic
  description: |-
    Get the secret value.

    Returns:
        The secret value.
  summary: Get the secret value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBool
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictInt
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictFloat
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber
  kind: class
  ns: pydantic
  description: 'Based on: https://en.wikipedia.org/wiki/Payment_card_number.'
  summary: 'Based on: https://en'
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: PaymentCardNumber
  inherits_from:
  - <class 'str'>
- name: PaymentCardNumber.capitalize
  kind: callable
  ns: pydantic
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.casefold
  kind: callable
  ns: pydantic
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.center
  kind: callable
  ns: pydantic
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.count
  kind: callable
  ns: pydantic
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.encode
  kind: callable
  ns: pydantic
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.endswith
  kind: callable
  ns: pydantic
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.expandtabs
  kind: callable
  ns: pydantic
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.find
  kind: callable
  ns: pydantic
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.format
  kind: callable
  ns: pydantic
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.format_map
  kind: callable
  ns: pydantic
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.index
  kind: callable
  ns: pydantic
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.isalnum
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isalpha
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isascii
  kind: callable
  ns: pydantic
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isdecimal
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isdigit
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isidentifier
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.islower
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isnumeric
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isprintable
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isspace
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.istitle
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isupper
  kind: callable
  ns: pydantic
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.join
  kind: callable
  ns: pydantic
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.ljust
  kind: callable
  ns: pydantic
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.lower
  kind: callable
  ns: pydantic
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.lstrip
  kind: callable
  ns: pydantic
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.masked
  kind: property
  ns: pydantic
  description: |-
    Mask all but the last 4 digits of the card number.

    Returns:
        A masked card number string.
  summary: Mask all but the last 4 digits of the card number
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.max_length
  kind: property
  ns: pydantic
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.min_length
  kind: property
  ns: pydantic
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.partition
  kind: callable
  ns: pydantic
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.removeprefix
  kind: callable
  ns: pydantic
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.removesuffix
  kind: callable
  ns: pydantic
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.replace
  kind: callable
  ns: pydantic
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rfind
  kind: callable
  ns: pydantic
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.rindex
  kind: callable
  ns: pydantic
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.rjust
  kind: callable
  ns: pydantic
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rpartition
  kind: callable
  ns: pydantic
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rsplit
  kind: callable
  ns: pydantic
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rstrip
  kind: callable
  ns: pydantic
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.split
  kind: callable
  ns: pydantic
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.splitlines
  kind: callable
  ns: pydantic
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.startswith
  kind: callable
  ns: pydantic
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.strip
  kind: callable
  ns: pydantic
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.strip_whitespace
  kind: property
  ns: pydantic
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.swapcase
  kind: callable
  ns: pydantic
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.title
  kind: callable
  ns: pydantic
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.translate
  kind: callable
  ns: pydantic
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.upper
  kind: callable
  ns: pydantic
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate
  kind: function
  ns: pydantic
  description: Validate the card number and return a `PaymentCardNumber` instance.
  summary: Validate the card number and return a `PaymentCardNumber` instance
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: _PaymentCardNumber__input_value
    default: null
    rest: false
  - kind: positional
    name: _
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate_brand
  kind: method
  ns: pydantic
  description: |-
    Validate length based on BIN for major brands:
    https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).
  summary: 'Validate length based on BIN for major brands:'
  signatures:
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate_digits
  kind: function
  ns: pydantic
  description: Validate that the card number is all digits.
  summary: Validate that the card number is all digits
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate_luhn_check_digit
  kind: function
  ns: pydantic
  description: 'Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.'
  summary: 'Based on: https://en'
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.zfill
  kind: callable
  ns: pydantic
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize
  kind: class
  ns: pydantic
  description: |-
    Converts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.

    You can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into
    an integer, and also to print out human-readable strings representing a number of bytes.

    In conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,
    and `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,
    rather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).

    !!! info
        Note that `1b` will be parsed as "1 byte" and not "1 bit".

    ```py
    from pydantic import BaseModel, ByteSize

    class MyModel(BaseModel):
        size: ByteSize

    print(MyModel(size=52000).size)
    #> 52000
    print(MyModel(size='3000 KiB').size)
    #> 3072000

    m = MyModel(size='50 PB')
    print(m.size.human_readable())
    #> 44.4PiB
    print(m.size.human_readable(decimal=True))
    #> 50.0PB

    print(m.size.to('TiB'))
    #> 45474.73508864641
    ```
  summary: Converts a string representing a number of bytes with units (such as `'1KB'` or `'11
  signatures: null
  inherits_from:
  - <class 'int'>
- name: ByteSize.as_integer_ratio
  kind: callable
  ns: pydantic
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.bit_count
  kind: callable
  ns: pydantic
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.bit_length
  kind: callable
  ns: pydantic
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.byte_sizes
  kind: property
  ns: pydantic
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: ByteSize.byte_string_pattern
  kind: property
  ns: pydantic
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: ByteSize.byte_string_re
  kind: property
  ns: pydantic
  description: Compiled regular expression object.
  summary: Compiled regular expression object
  signatures: null
  inherits_from: null
- name: ByteSize.conjugate
  kind: callable
  ns: pydantic
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: ByteSize.denominator
  kind: property
  ns: pydantic
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: ByteSize.human_readable
  kind: method
  ns: pydantic
  description: |-
    Converts a byte size to a human readable string.

    Args:
        decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units
            (e.g. 1024 bytes per KiB).

    Returns:
        A human readable string representation of the byte size.
  summary: Converts a byte size to a human readable string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: decimal
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.imag
  kind: property
  ns: pydantic
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: ByteSize.numerator
  kind: property
  ns: pydantic
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: ByteSize.real
  kind: property
  ns: pydantic
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: ByteSize.to
  kind: method
  ns: pydantic
  description: |-
    Converts a byte size to another unit, including both byte and bit units.

    Args:
        unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,
            KiB, MiB, GiB, TiB, PiB, EiB (byte units) and
            bit, kbit, mbit, gbit, tbit, pbit, ebit,
            kibit, mibit, gibit, tibit, pibit, eibit (bit units).

    Returns:
        The byte size in the new unit.
  summary: Converts a byte size to another unit, including both byte and bit units
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: unit
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.to_bytes
  kind: callable
  ns: pydantic
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PastDate
  kind: class
  ns: pydantic
  description: A date in the past.
  summary: A date in the past
  signatures:
  - type: PastDate
  inherits_from: null
- name: FutureDate
  kind: class
  ns: pydantic
  description: A date in the future.
  summary: A date in the future
  signatures:
  - type: FutureDate
  inherits_from: null
- name: PastDatetime
  kind: class
  ns: pydantic
  description: A datetime that must be in the past.
  summary: A datetime that must be in the past
  signatures:
  - type: PastDatetime
  inherits_from: null
- name: FutureDatetime
  kind: class
  ns: pydantic
  description: A datetime that must be in the future.
  summary: A datetime that must be in the future
  signatures:
  - type: FutureDatetime
  inherits_from: null
- name: AwareDatetime
  kind: class
  ns: pydantic
  description: A datetime that requires timezone info.
  summary: A datetime that requires timezone info
  signatures:
  - type: AwareDatetime
  inherits_from: null
- name: NaiveDatetime
  kind: class
  ns: pydantic
  description: A datetime that doesn't require timezone info.
  summary: A datetime that doesn't require timezone info
  signatures:
  - type: NaiveDatetime
  inherits_from: null
- name: AllowInfNan
  kind: class
  ns: pydantic
  description: A field metadata class to indicate that a field should allow ``-inf``, ``inf``, and ``nan``.
  summary: A field metadata class to indicate that a field should allow ``-inf``, ``inf``, and ``nan``
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: allow_inf_nan
    default: 'True'
    rest: false
  - type: AllowInfNan
  inherits_from:
  - <class 'pydantic._internal._fields.PydanticMetadata'>
  - <class 'pydantic._internal._repr.Representation'>
- name: AllowInfNan.allow_inf_nan
  kind: property
  ns: pydantic
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: EncoderProtocol
  kind: class
  ns: pydantic
  description: Protocol for encoding and decoding data to and from bytes.
  summary: Protocol for encoding and decoding data to and from bytes
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: EncoderProtocol
  inherits_from:
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: EncoderProtocol.decode
  kind: function
  ns: pydantic
  description: |-
    Decode the data using the encoder.

    Args:
        data: The data to decode.

    Returns:
        The decoded data.
  summary: Decode the data using the encoder
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncoderProtocol.encode
  kind: function
  ns: pydantic
  description: |-
    Encode the data using the encoder.

    Args:
        value: The data to encode.

    Returns:
        The encoded data.
  summary: Encode the data using the encoder
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncoderProtocol.get_json_format
  kind: function
  ns: pydantic
  description: |-
    Get the JSON format for the encoded data.

    Returns:
        The JSON format for the encoded data.
  summary: Get the JSON format for the encoded data
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedBytes
  kind: class
  ns: pydantic
  description: |-
    A bytes type that is encoded and decoded using the specified encoder.

    `EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.

    ```py
    from typing_extensions import Annotated

    from pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError

    class MyEncoder(EncoderProtocol):
        @classmethod
        def decode(cls, data: bytes) -> bytes:
            if data == b'**undecodable**':
                raise ValueError('Cannot decode data')
            return data[13:]

        @classmethod
        def encode(cls, value: bytes) -> bytes:
            return b'**encoded**: ' + value

        @classmethod
        def get_json_format(cls) -> str:
            return 'my-encoder'

    MyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]

    class Model(BaseModel):
        my_encoded_bytes: MyEncodedBytes

    # Initialize the model with encoded data
    m = Model(my_encoded_bytes=b'**encoded**: some bytes')

    # Access decoded value
    print(m.my_encoded_bytes)
    #> b'some bytes'

    # Serialize into the encoded form
    print(m.model_dump())
    #> {'my_encoded_bytes': b'**encoded**: some bytes'}

    # Validate encoded data
    try:
        Model(my_encoded_bytes=b'**undecodable**')
    except ValidationError as e:
        print(e)
        '''
        1 validation error for Model
        my_encoded_bytes
          Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]
        '''
    ```
  summary: A bytes type that is encoded and decoded using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoder
    default: null
    rest: false
  - type: EncodedBytes
  inherits_from: null
- name: EncodedBytes.decode
  kind: method
  ns: pydantic
  description: |-
    Decode the data using the specified encoder.

    Args:
        data: The data to decode.

    Returns:
        The decoded data.
  summary: Decode the data using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - kind: positional
    name: _
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedBytes.encode
  kind: method
  ns: pydantic
  description: |-
    Encode the data using the specified encoder.

    Args:
        value: The data to encode.

    Returns:
        The encoded data.
  summary: Encode the data using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedBytes.encoder
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: EncodedStr
  kind: class
  ns: pydantic
  description: |-
    A str type that is encoded and decoded using the specified encoder.

    `EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.

    ```py
    from typing_extensions import Annotated

    from pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError

    class MyEncoder(EncoderProtocol):
        @classmethod
        def decode(cls, data: bytes) -> bytes:
            if data == b'**undecodable**':
                raise ValueError('Cannot decode data')
            return data[13:]

        @classmethod
        def encode(cls, value: bytes) -> bytes:
            return b'**encoded**: ' + value

        @classmethod
        def get_json_format(cls) -> str:
            return 'my-encoder'

    MyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]

    class Model(BaseModel):
        my_encoded_str: MyEncodedStr

    # Initialize the model with encoded data
    m = Model(my_encoded_str='**encoded**: some str')

    # Access decoded value
    print(m.my_encoded_str)
    #> some str

    # Serialize into the encoded form
    print(m.model_dump())
    #> {'my_encoded_str': '**encoded**: some str'}

    # Validate encoded data
    try:
        Model(my_encoded_str='**undecodable**')
    except ValidationError as e:
        print(e)
        '''
        1 validation error for Model
        my_encoded_str
          Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]
        '''
    ```
  summary: A str type that is encoded and decoded using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoder
    default: null
    rest: false
  - type: EncodedStr
  inherits_from:
  - <class 'pydantic.types.EncodedBytes'>
- name: EncodedStr.decode
  kind: method
  ns: pydantic
  description: |-
    Decode the data using the specified encoder.

    Args:
        data: The data to decode.

    Returns:
        The decoded data.
  summary: Decode the data using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - kind: positional
    name: _
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedStr.decode_str
  kind: method
  ns: pydantic
  description: |-
    Decode the data using the specified encoder.

    Args:
        data: The data to decode.

    Returns:
        The decoded data.
  summary: Decode the data using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - kind: positional
    name: _
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedStr.encode
  kind: method
  ns: pydantic
  description: |-
    Encode the data using the specified encoder.

    Args:
        value: The data to encode.

    Returns:
        The encoded data.
  summary: Encode the data using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedStr.encode_str
  kind: method
  ns: pydantic
  description: |-
    Encode the data using the specified encoder.

    Args:
        value: The data to encode.

    Returns:
        The encoded data.
  summary: Encode the data using the specified encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EncodedStr.encoder
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Base64Encoder
  kind: class
  ns: pydantic
  description: Standard (non-URL-safe) Base64 encoder.
  summary: Standard (non-URL-safe) Base64 encoder
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: Base64Encoder
  inherits_from:
  - <class 'pydantic.types.EncoderProtocol'>
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: Base64Encoder.decode
  kind: function
  ns: pydantic
  description: |-
    Decode the data from base64 encoded bytes to original bytes data.

    Args:
        data: The data to decode.

    Returns:
        The decoded data.
  summary: Decode the data from base64 encoded bytes to original bytes data
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64Encoder.encode
  kind: function
  ns: pydantic
  description: |-
    Encode the data from bytes to a base64 encoded bytes.

    Args:
        value: The data to encode.

    Returns:
        The encoded data.
  summary: Encode the data from bytes to a base64 encoded bytes
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64Encoder.get_json_format
  kind: function
  ns: pydantic
  description: |-
    Get the JSON format for the encoded data.

    Returns:
        The JSON format for the encoded data.
  summary: Get the JSON format for the encoded data
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64Bytes
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64Str
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64UrlBytes
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64UrlStr
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GetPydanticSchema
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/types/#using-getpydanticschema-to-reduce-boilerplate

    A convenience class for creating an annotation that provides pydantic custom type hooks.

    This class is intended to eliminate the need to create a custom "marker" which defines the
     `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.

    For example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:
    ```python
    from typing import Any

    from typing_extensions import Annotated

    from pydantic import BaseModel, GetPydanticSchema

    HandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))

    class Model(BaseModel):
        x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`

    print(repr(Model(x='abc').x))
    #> 'abc'
    ```
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: get_pydantic_core_schema
    default: None
    rest: false
  - kind: positional
    name: get_pydantic_json_schema
    default: None
    rest: false
  - type: GetPydanticSchema
  inherits_from: null
- name: GetPydanticSchema.get_pydantic_core_schema
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: GetPydanticSchema.get_pydantic_json_schema
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Tag
  kind: class
  ns: pydantic
  description: |-
    Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.

    Also provides a way to label a union case in error messages.

    When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that
    should be used to identify that case. For example, in the below example, the `Tag` is used to specify that
    if `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it
    returns `'pumpkin'`, the input should be validated as a `PumpkinPie`.

    The primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to
    the appropriate member of the `Union` in question.

    ```py
    from typing import Any, Union

    from typing_extensions import Annotated, Literal

    from pydantic import BaseModel, Discriminator, Tag

    class Pie(BaseModel):
        time_to_cook: int
        num_ingredients: int

    class ApplePie(Pie):
        fruit: Literal['apple'] = 'apple'

    class PumpkinPie(Pie):
        filling: Literal['pumpkin'] = 'pumpkin'

    def get_discriminator_value(v: Any) -> str:
        if isinstance(v, dict):
            return v.get('fruit', v.get('filling'))
        return getattr(v, 'fruit', getattr(v, 'filling', None))

    class ThanksgivingDinner(BaseModel):
        dessert: Annotated[
            Union[
                Annotated[ApplePie, Tag('apple')],
                Annotated[PumpkinPie, Tag('pumpkin')],
            ],
            Discriminator(get_discriminator_value),
        ]

    apple_variation = ThanksgivingDinner.model_validate(
        {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}
    )
    print(repr(apple_variation))
    '''
    ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))
    '''

    pumpkin_variation = ThanksgivingDinner.model_validate(
        {
            'dessert': {
                'filling': 'pumpkin',
                'time_to_cook': 40,
                'num_ingredients': 6,
            }
        }
    )
    print(repr(pumpkin_variation))
    '''
    ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))
    '''
    ```

    !!! note
        You must specify a `Tag` for every case in a `Tag` that is associated with a
        callable `Discriminator`. Failing to do so will result in a `PydanticUserError` with code
        [`callable-discriminator-no-tag`](../errors/usage_errors.md#callable-discriminator-no-tag).

    See the [Discriminated Unions] concepts docs for more details on how to use `Tag`s.

    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions
  summary: Provides a way to specify the expected tag to use for a case of a (callable) discriminated union
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tag
    default: null
    rest: false
  - type: Tag
  inherits_from: null
- name: Tag.tag
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Discriminator
  kind: class
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/unions/#discriminated-unions-with-callable-discriminator

    Provides a way to use a custom callable as the way to extract the value of a union discriminator.

    This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,
    but without needing to have a single shared field across all the union choices. This also makes it
    possible to handle unions of models and primitive types with discriminated-union-style validation errors.
    Finally, this allows you to use a custom callable as the way to identify which member of a union a value
    belongs to, while still seeing all the performance benefits of a discriminated union.

    Consider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`
    than it would be as a normal `Union`.

    ```py
    from typing import Any, Union

    from typing_extensions import Annotated, Literal

    from pydantic import BaseModel, Discriminator, Tag

    class Pie(BaseModel):
        time_to_cook: int
        num_ingredients: int

    class ApplePie(Pie):
        fruit: Literal['apple'] = 'apple'

    class PumpkinPie(Pie):
        filling: Literal['pumpkin'] = 'pumpkin'

    def get_discriminator_value(v: Any) -> str:
        if isinstance(v, dict):
            return v.get('fruit', v.get('filling'))
        return getattr(v, 'fruit', getattr(v, 'filling', None))

    class ThanksgivingDinner(BaseModel):
        dessert: Annotated[
            Union[
                Annotated[ApplePie, Tag('apple')],
                Annotated[PumpkinPie, Tag('pumpkin')],
            ],
            Discriminator(get_discriminator_value),
        ]

    apple_variation = ThanksgivingDinner.model_validate(
        {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}
    )
    print(repr(apple_variation))
    '''
    ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))
    '''

    pumpkin_variation = ThanksgivingDinner.model_validate(
        {
            'dessert': {
                'filling': 'pumpkin',
                'time_to_cook': 40,
                'num_ingredients': 6,
            }
        }
    )
    print(repr(pumpkin_variation))
    '''
    ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))
    '''
    ```

    See the [Discriminated Unions] concepts docs for more details on how to use `Discriminator`s.

    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: discriminator
    default: null
    rest: false
  - kind: positional
    name: custom_error_type
    default: None
    rest: false
  - kind: positional
    name: custom_error_message
    default: None
    rest: false
  - kind: positional
    name: custom_error_context
    default: None
    rest: false
  - type: Discriminator
  inherits_from: null
- name: Discriminator.custom_error_context
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Discriminator.custom_error_message
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Discriminator.custom_error_type
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Discriminator.discriminator
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: JsonValue
  kind: callable
  ns: pydantic
  description: |-
    Create named, parameterized type aliases.

    This provides a backport of the new `type` statement in Python 3.12:

        type ListOrSet[T] = list[T] | set[T]

    is equivalent to:

        T = TypeVar("T")
        ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))

    The name ListOrSet can then be used as an alias for the type it refers to.

    The type_params argument should contain all the type parameters used
    in the value of the type alias. If the alias is not generic, this
    argument is omitted.

    Static type checkers should only support type aliases declared using
    TypeAliasType that follow these rules:

    - The first argument (the name) must be a string literal.
    - The TypeAliasType instance must be immediately assigned to a variable
      of the same name. (For example, 'X = TypeAliasType("Y", int)' is invalid,
      as is 'X, Y = TypeAliasType("X", int), TypeAliasType("Y", int)').
  summary: Create named, parameterized type aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: TypeAdapter
  kind: class
  ns: pydantic
  description: |-
    Type adapters provide a flexible way to perform validation and serialization based on a Python type.

    A `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods
    for types that do not have such methods (such as dataclasses, primitive types, and more).

    **Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.

    Attributes:
        core_schema: The core schema for the type.
        validator (SchemaValidator): The schema validator for the type.
        serializer: The schema serializer for the type.
  summary: Type adapters provide a flexible way to perform validation and serialization based on a Python type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: type
    default: null
    rest: false
  - name: config
    default: None
    rest: false
    kind: kw-only
  - name: _parent_depth
    default: '2'
    rest: false
    kind: kw-only
  - name: module
    default: None
    rest: false
    kind: kw-only
  - type: TypeAdapter
  inherits_from:
  - <class 'typing.Generic'>
- name: TypeAdapter.dump_json
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json/#json-serialization

    Serialize an instance of the adapted type to JSON.

    Args:
        __instance: The instance to be serialized.
        indent: Number of spaces for JSON indentation.
        include: Fields to include.
        exclude: Fields to exclude.
        by_alias: Whether to use alias names for field names.
        exclude_unset: Whether to exclude unset fields.
        exclude_defaults: Whether to exclude fields with default values.
        exclude_none: Whether to exclude fields with a value of `None`.
        round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.
        warnings: Whether to emit serialization warnings.

    Returns:
        The JSON representation of the given instance as bytes.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _TypeAdapter__instance
    default: null
    rest: false
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.dump_python
  kind: method
  ns: pydantic
  description: |-
    Dump an instance of the adapted type to a Python object.

    Args:
        __instance: The Python object to serialize.
        mode: The output format.
        include: Fields to include in the output.
        exclude: Fields to exclude from the output.
        by_alias: Whether to use alias names for field names.
        exclude_unset: Whether to exclude unset fields.
        exclude_defaults: Whether to exclude fields with default values.
        exclude_none: Whether to exclude fields with None values.
        round_trip: Whether to output the serialized data in a way that is compatible with deserialization.
        warnings: Whether to display serialization warnings.

    Returns:
        The serialized object.
  summary: Dump an instance of the adapted type to a Python object
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _TypeAdapter__instance
    default: null
    rest: false
  - name: mode
    default: python
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.get_default_value
  kind: method
  ns: pydantic
  description: |-
    Get the default value for the wrapped type.

    Args:
        strict: Whether to strictly check types.
        context: Additional context to pass to the validator.

    Returns:
        The default value wrapped in a `Some` if there is one or None if not.
  summary: Get the default value for the wrapped type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.json_schema
  kind: method
  ns: pydantic
  description: |-
    Generate a JSON schema for the adapted type.

    Args:
        by_alias: Whether to use alias names for field names.
        ref_template: The format string used for generating $ref strings.
        schema_generator: The generator class used for creating the schema.
        mode: The mode to use for schema generation.

    Returns:
        The JSON schema for the model as a dictionary.
  summary: Generate a JSON schema for the adapted type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - name: mode
    default: validation
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.json_schemas
  kind: method
  ns: pydantic
  description: |-
    Generate a JSON schema including definitions from multiple type adapters.

    Args:
        __inputs: Inputs to schema generation. The first two items will form the keys of the (first)
            output mapping; the type adapters will provide the core schemas that get converted into
            definitions in the output JSON schema.
        by_alias: Whether to use alias names.
        title: The title for the schema.
        description: The description for the schema.
        ref_template: The format string used for generating $ref strings.
        schema_generator: The generator class used for creating the schema.

    Returns:
        A tuple where:

            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and
                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have
                JsonRef references to definitions that are defined in the second returned element.)
            - The second element is a JSON schema containing all definitions referenced in the first returned
                element, along with the optional title and description keys.
  summary: Generate a JSON schema including definitions from multiple type adapters
  signatures:
  - kind: positional
    name: _TypeAdapter__inputs
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: description
    default: None
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.validate_json
  kind: method
  ns: pydantic
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json/#json-parsing

    Validate a JSON string or bytes against the model.

    Args:
        __data: The JSON data to validate against the model.
        strict: Whether to strictly check types.
        context: Additional context to use during validation.

    Returns:
        The validated object.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _TypeAdapter__data
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.validate_python
  kind: method
  ns: pydantic
  description: |-
    Validate a Python object against the model.

    Args:
        __object: The Python object to validate against the model.
        strict: Whether to strictly check types.
        from_attributes: Whether to extract data from object attributes.
        context: Additional context to pass to the validator.

    !!! note
        When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`
        argument is not supported.

    Returns:
        The validated object.
  summary: Validate a Python object against the model
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _TypeAdapter__object
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: TypeAdapter.validate_strings
  kind: method
  ns: pydantic
  description: |-
    Validate object contains string data against the model.

    Args:
        __obj: The object contains string data to validate.
        strict: Whether to strictly check types.
        context: Additional context to use during validation.

    Returns:
        The validated object.
  summary: Validate object contains string data against the model
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _TypeAdapter__obj
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: VERSION
  kind: const
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticDeprecatedSince20
  kind: class
  ns: pydantic
  description: A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.0.
  summary: A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - type: PydanticDeprecatedSince20
  inherits_from:
  - <class 'pydantic.warnings.PydanticDeprecationWarning'>
  - <class 'DeprecationWarning'>
  - <class 'Warning'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticDeprecatedSince20.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticDeprecatedSince20.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticDeprecatedSince20.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticDeprecatedSince26
  kind: class
  ns: pydantic
  description: A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.6.
  summary: A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - type: PydanticDeprecatedSince26
  inherits_from:
  - <class 'pydantic.warnings.PydanticDeprecationWarning'>
  - <class 'DeprecationWarning'>
  - <class 'Warning'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticDeprecatedSince26.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticDeprecatedSince26.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticDeprecatedSince26.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticDeprecationWarning
  kind: class
  ns: pydantic
  description: |-
    A Pydantic specific deprecation warning.

    This warning is raised when using deprecated functionality in Pydantic. It provides information on when the
    deprecation was introduced and the expected version in which the corresponding functionality will be removed.

    Attributes:
        message: Description of the warning.
        since: Pydantic version in what the deprecation was introduced.
        expected_removal: Pydantic version in what the corresponding functionality expected to be removed.
  summary: A Pydantic specific deprecation warning
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - name: since
    default: null
    rest: false
    kind: kw-only
  - name: expected_removal
    default: None
    rest: false
    kind: kw-only
  - type: PydanticDeprecationWarning
  inherits_from:
  - <class 'DeprecationWarning'>
  - <class 'Warning'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticDeprecationWarning.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticDeprecationWarning.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticDeprecationWarning.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: GetCoreSchemaHandler
  kind: class
  ns: pydantic
  description: Handler to call into the next CoreSchema schema generation function.
  summary: Handler to call into the next CoreSchema schema generation function
  signatures:
  - type: GetCoreSchemaHandler
  inherits_from: null
- name: GetCoreSchemaHandler.field_name
  kind: property
  ns: pydantic
  description: Get the name of the closest field to this validator.
  summary: Get the name of the closest field to this validator
  signatures: null
  inherits_from: null
- name: GetCoreSchemaHandler.generate_schema
  kind: method
  ns: pydantic
  description: |-
    Generate a schema unrelated to the current context.
    Use this function if e.g. you are handling schema generation for a sequence
    and want to generate a schema for its items.
    Otherwise, you may end up doing something like applying a `min_length` constraint
    that was intended for the sequence itself to its items!

    Args:
        __source_type: The input type.

    Returns:
        CoreSchema: The `pydantic-core` CoreSchema generated.
  summary: Generate a schema unrelated to the current context
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _GetCoreSchemaHandler__source_type
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GetCoreSchemaHandler.resolve_ref_schema
  kind: method
  ns: pydantic
  description: |-
    Get the real schema for a `definition-ref` schema.
    If the schema given is not a `definition-ref` schema, it will be returned as is.
    This means you don't have to check before calling this function.

    Args:
        __maybe_ref_schema: A `CoreSchema`, `ref`-based or not.

    Raises:
        LookupError: If the `ref` is not found.

    Returns:
        A concrete `CoreSchema`.
  summary: Get the real schema for a `definition-ref` schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _GetCoreSchemaHandler__maybe_ref_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GetJsonSchemaHandler
  kind: class
  ns: pydantic
  description: |-
    Handler to call into the next JSON schema generation function.

    Attributes:
        mode: Json schema mode, can be `validation` or `serialization`.
  summary: Handler to call into the next JSON schema generation function
  signatures:
  - type: GetJsonSchemaHandler
  inherits_from: null
- name: GetJsonSchemaHandler.resolve_ref_schema
  kind: method
  ns: pydantic
  description: |-
    Get the real schema for a `{"$ref": ...}` schema.
    If the schema given is not a `$ref` schema, it will be returned as is.
    This means you don't have to check before calling this function.

    Args:
        __maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema.

    Raises:
        LookupError: If the ref is not found.

    Returns:
        JsonSchemaValue: A JsonSchemaValue that has no `$ref`.
  summary: 'Get the real schema for a `{"$ref": '
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: _GetJsonSchemaHandler__maybe_ref_json_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateSchema
  kind: class
  ns: pydantic
  description: Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... .
  summary: 'Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, '
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: config_wrapper
    default: null
    rest: false
  - kind: positional
    name: types_namespace
    default: null
    rest: false
  - kind: positional
    name: typevars_map
    default: None
    rest: false
  - type: GenerateSchema
  inherits_from: null
- name: GenerateSchema.CollectedInvalid
  kind: class
  ns: pydantic
  description: Common base class for all non-exit exceptions.
  summary: Common base class for all non-exit exceptions
  signatures: null
  inherits_from:
  - <class 'Exception'>
  - <class 'BaseException'>
- name: GenerateSchema.CollectedInvalid.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: GenerateSchema.CollectedInvalid.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: GenerateSchema.CollectedInvalid.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: GenerateSchema.clean_schema
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateSchema.collect_definitions
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateSchema.defs
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: GenerateSchema.field_name_stack
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: GenerateSchema.generate_schema
  kind: method
  ns: pydantic
  description: |-
    Generate core schema.

    Args:
        obj: The object to generate core schema for.
        from_dunder_get_core_schema: Whether to generate schema from either the
            `__get_pydantic_core_schema__` function or `__pydantic_core_schema__` property.

    Returns:
        The generated core schema.

    Raises:
        PydanticUndefinedAnnotation:
            If it is not possible to evaluate forward reference.
        PydanticSchemaGenerationError:
            If it is not possible to generate pydantic-core schema.
        TypeError:
            - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices).
            - If V1 style validator with `each_item=True` applied on a wrong field.
        PydanticUserError:
            - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python < 3.12.
            - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`.
  summary: Generate core schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - kind: positional
    name: from_dunder_get_core_schema
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateSchema.match_type
  kind: method
  ns: pydantic
  description: |-
    Main mapping of types to schemas.

    The general structure is a series of if statements starting with the simple cases
    (non-generic primitive types) and then handling generics and other more complex cases.

    Each case either generates a schema directly, calls into a public user-overridable method
    (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some
    boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).

    The idea is that we'll evolve this into adding more and more user facing methods over time
    as they get requested and we figure out what the right API for them is.
  summary: Main mapping of types to schemas
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateSchema.str_schema
  kind: method
  ns: pydantic
  description: Generate a CoreSchema for `str`
  summary: Generate a CoreSchema for `str`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidationError
  kind: class
  ns: pydantic
  description: Inappropriate argument value (of correct type).
  summary: Inappropriate argument value (of correct type)
  signatures: null
  inherits_from:
  - <class 'ValueError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: ValidationError.add_note
  kind: callable
  ns: pydantic
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: ValidationError.args
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ValidationError.error_count
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidationError.errors
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include_url
    default: 'True'
    rest: false
    kind: kw-only
  - name: include_context
    default: 'True'
    rest: false
    kind: kw-only
  - name: include_input
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ValidationError.json
  kind: callable
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: include_url
    default: 'True'
    rest: false
    kind: kw-only
  - name: include_context
    default: 'True'
    rest: false
    kind: kw-only
  - name: include_input
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ValidationError.title
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ValidationError.with_traceback
  kind: callable
  ns: pydantic
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: ValidationInfo
  kind: class
  ns: pydantic
  description: Argument passed to validation functions.
  summary: Argument passed to validation functions
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ValidationInfo
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: ValidationInfo.config
  kind: property
  ns: pydantic
  description: The CoreConfig that applies to this validation.
  summary: The CoreConfig that applies to this validation
  signatures: null
  inherits_from: null
- name: ValidationInfo.context
  kind: property
  ns: pydantic
  description: Current validation context.
  summary: Current validation context
  signatures: null
  inherits_from: null
- name: ValidationInfo.data
  kind: property
  ns: pydantic
  description: The data being validated for this model.
  summary: The data being validated for this model
  signatures: null
  inherits_from: null
- name: ValidationInfo.field_name
  kind: property
  ns: pydantic
  description: |-
    The name of the current field being validated if this validator is
    attached to a model field.
  summary: The name of the current field being validated if this validator is
  signatures: null
  inherits_from: null
- name: ValidationInfo.mode
  kind: property
  ns: pydantic
  description: The type of input data we are currently validating
  summary: The type of input data we are currently validating
  signatures: null
  inherits_from: null
- name: SerializationInfo
  kind: class
  ns: pydantic
  description: |-
    Base class for protocol classes.

    Protocol classes are defined as::

        class Proto(Protocol):
            def meth(self) -> int:
                ...

    Such classes are primarily used with static type checkers that recognize
    structural subtyping (static duck-typing).

    For example::

        class C:
            def meth(self) -> int:
                return 0

        def func(x: Proto) -> int:
            return x.meth()

        func(C())  # Passes static type check

    See PEP 544 for details. Protocol classes decorated with
    @typing.runtime_checkable act as simple-minded runtime protocols that check
    only the presence of given attributes, ignoring their type signatures.
    Protocol classes can be generic, they are defined as::

        class GenProto(Protocol[T]):
            def meth(self) -> T:
                ...
  summary: Base class for protocol classes
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: SerializationInfo
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: SerializationInfo.by_alias
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.exclude
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.exclude_defaults
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.exclude_none
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.exclude_unset
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.include
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.mode
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializationInfo.mode_is_json
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SerializationInfo.round_trip
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ValidatorFunctionWrapHandler
  kind: class
  ns: pydantic
  description: |-
    Base class for protocol classes.

    Protocol classes are defined as::

        class Proto(Protocol):
            def meth(self) -> int:
                ...

    Such classes are primarily used with static type checkers that recognize
    structural subtyping (static duck-typing).

    For example::

        class C:
            def meth(self) -> int:
                return 0

        def func(x: Proto) -> int:
            return x.meth()

        func(C())  # Passes static type check

    See PEP 544 for details. Protocol classes decorated with
    @typing.runtime_checkable act as simple-minded runtime protocols that check
    only the presence of given attributes, ignoring their type signatures.
    Protocol classes can be generic, they are defined as::

        class GenProto(Protocol[T]):
            def meth(self) -> T:
                ...
  summary: Base class for protocol classes
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ValidatorFunctionWrapHandler
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: FieldSerializationInfo
  kind: class
  ns: pydantic
  description: |-
    Base class for protocol classes.

    Protocol classes are defined as::

        class Proto(Protocol):
            def meth(self) -> int:
                ...

    Such classes are primarily used with static type checkers that recognize
    structural subtyping (static duck-typing).

    For example::

        class C:
            def meth(self) -> int:
                return 0

        def func(x: Proto) -> int:
            return x.meth()

        func(C())  # Passes static type check

    See PEP 544 for details. Protocol classes decorated with
    @typing.runtime_checkable act as simple-minded runtime protocols that check
    only the presence of given attributes, ignoring their type signatures.
    Protocol classes can be generic, they are defined as::

        class GenProto(Protocol[T]):
            def meth(self) -> T:
                ...
  summary: Base class for protocol classes
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: FieldSerializationInfo
  inherits_from:
  - <class 'pydantic_core.core_schema.SerializationInfo'>
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: FieldSerializationInfo.by_alias
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.exclude
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.exclude_defaults
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.exclude_none
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.exclude_unset
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.field_name
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.include
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.mode
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldSerializationInfo.mode_is_json
  kind: method
  ns: pydantic
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldSerializationInfo.round_trip
  kind: property
  ns: pydantic
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SerializerFunctionWrapHandler
  kind: class
  ns: pydantic
  description: |-
    Base class for protocol classes.

    Protocol classes are defined as::

        class Proto(Protocol):
            def meth(self) -> int:
                ...

    Such classes are primarily used with static type checkers that recognize
    structural subtyping (static duck-typing).

    For example::

        class C:
            def meth(self) -> int:
                return 0

        def func(x: Proto) -> int:
            return x.meth()

        func(C())  # Passes static type check

    See PEP 544 for details. Protocol classes decorated with
    @typing.runtime_checkable act as simple-minded runtime protocols that check
    only the presence of given attributes, ignoring their type signatures.
    Protocol classes can be generic, they are defined as::

        class GenProto(Protocol[T]):
            def meth(self) -> T:
                ...
  summary: Base class for protocol classes
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: SerializerFunctionWrapHandler
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: OnErrorOmit
  kind: callable
  ns: pydantic
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.alias_generators
  kind: module
  ns: null
  description: Alias generators for converting between different capitalization conventions.
  summary: Alias generators for converting between different capitalization conventions
  signatures: null
  inherits_from: null
- name: to_pascal
  kind: function
  ns: pydantic.alias_generators
  description: |-
    Convert a snake_case string to PascalCase.

    Args:
        snake: The string to convert.

    Returns:
        The PascalCase string.
  summary: Convert a snake_case string to PascalCase
  signatures:
  - kind: positional
    name: snake
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: to_camel
  kind: function
  ns: pydantic.alias_generators
  description: |-
    Convert a snake_case string to camelCase.

    Args:
        snake: The string to convert.

    Returns:
        The converted camelCase string.
  summary: Convert a snake_case string to camelCase
  signatures:
  - kind: positional
    name: snake
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: to_snake
  kind: function
  ns: pydantic.alias_generators
  description: |-
    Convert a PascalCase or camelCase string to snake_case.

    Args:
        camel: The string to convert.

    Returns:
        The converted string in snake_case.
  summary: Convert a PascalCase or camelCase string to snake_case
  signatures:
  - kind: positional
    name: camel
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.aliases
  kind: module
  ns: null
  description: Support for alias configurations.
  summary: Support for alias configurations
  signatures: null
  inherits_from: null
- name: pydantic.annotated_handlers
  kind: module
  ns: null
  description: Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`.
  summary: Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`
  signatures: null
  inherits_from: null
- name: pydantic.class_validators
  kind: module
  ns: null
  description: '`class_validators` module is a backport module from V1.'
  summary: '`class_validators` module is a backport module from V1'
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.class_validators
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.color
  kind: module
  ns: null
  description: |-
    Color definitions are used as per the CSS3
    [CSS Color Module Level 3](http://www.w3.org/TR/css3-color/#svg-color) specification.

    A few colors have multiple names referring to the sames colors, eg. `grey` and `gray` or `aqua` and `cyan`.

    In these cases the _last_ color when sorted alphabetically takes preferences,
    eg. `Color((0, 255, 255)).as_named() == 'cyan'` because "cyan" comes after "aqua".

    Warning: Deprecated
        The `Color` class is deprecated, use `pydantic_extra_types` instead.
        See [`pydantic-extra-types.Color`](../usage/types/extra_types/color_types.md)
        for more information.
  summary: Color definitions are used as per the CSS3
  signatures: null
  inherits_from: null
- name: Any
  kind: class
  ns: pydantic.color
  description: |-
    Special type indicating an unconstrained type.

    - Any is compatible with every type.
    - Any assumed to have all methods.
    - All values assumed to be instances of Any.

    Note that all the above statements are true from the point of view of
    static type checkers. At runtime, Any should not be used with instance
    checks.
  summary: Special type indicating an unconstrained type
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: Any
  inherits_from: null
- name: COLORS_BY_NAME
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: COLORS_BY_VALUE
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Callable
  kind: callable
  ns: pydantic.color
  description: |-
    Deprecated alias to collections.abc.Callable.

    Callable[[int], str] signifies a function that takes a single
    parameter of type int and returns a str.

    The subscription syntax must always be used with exactly two
    values: the argument list and the return type.
    The argument list must be a list of types, a ParamSpec,
    Concatenate or ellipsis. The return type must be a single type.

    There is no syntax to indicate optional or keyword arguments;
    such function types are rarely used as callback types.
  summary: Deprecated alias to collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Color
  kind: class
  ns: pydantic.color
  description: Represents a color.
  summary: Represents a color
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: Color
  inherits_from:
  - <class 'pydantic._internal._repr.Representation'>
- name: Color.as_hex
  kind: method
  ns: pydantic.color
  description: |-
    Returns the hexadecimal representation of the color.

    Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string
    a "short" representation of the color is possible and whether there's an alpha channel.

    Returns:
        The hexadecimal representation of the color.
  summary: Returns the hexadecimal representation of the color
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Color.as_hsl
  kind: method
  ns: pydantic.color
  description: Color as an `hsl(<h>, <s>, <l>)` or `hsl(<h>, <s>, <l>, <a>)` string.
  summary: Color as an `hsl(<h>, <s>, <l>)` or `hsl(<h>, <s>, <l>, <a>)` string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Color.as_hsl_tuple
  kind: method
  ns: pydantic.color
  description: |-
    Returns the color as an HSL or HSLA tuple.

    Args:
        alpha: Whether to include the alpha channel.

            - `None` (default): Include the alpha channel only if it's set (e.g. not `None`).
            - `True`: Always include alpha.
            - `False`: Always omit alpha.

    Returns:
        The color as a tuple of hue, saturation, lightness, and alpha (if included).
            All elements are in the range 0 to 1.

    Note:
        This is HSL as used in HTML and most other places, not HLS as used in Python's `colorsys`.
  summary: Returns the color as an HSL or HSLA tuple
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: alpha
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Color.as_named
  kind: method
  ns: pydantic.color
  description: |-
    Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,
    otherwise returns the hexadecimal representation of the color or raises `ValueError`.

    Args:
        fallback: If True, falls back to returning the hexadecimal representation of
            the color instead of raising a ValueError when no named color is found.

    Returns:
        The name of the color, or the hexadecimal representation of the color.

    Raises:
        ValueError: When no named color is found and fallback is `False`.
  summary: Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: fallback
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Color.as_rgb
  kind: method
  ns: pydantic.color
  description: Color as an `rgb(<r>, <g>, <b>)` or `rgba(<r>, <g>, <b>, <a>)` string.
  summary: Color as an `rgb(<r>, <g>, <b>)` or `rgba(<r>, <g>, <b>, <a>)` string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Color.as_rgb_tuple
  kind: method
  ns: pydantic.color
  description: |-
    Returns the color as an RGB or RGBA tuple.

    Args:
        alpha: Whether to include the alpha channel. There are three options for this input:

            - `None` (default): Include alpha only if it's set. (e.g. not `None`)
            - `True`: Always include alpha.
            - `False`: Always omit alpha.

    Returns:
        A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.
            If alpha is included, it is in the range 0 to 1.
  summary: Returns the color as an RGB or RGBA tuple
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: alpha
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Color.original
  kind: method
  ns: pydantic.color
  description: Original value passed to `Color`.
  summary: Original value passed to `Color`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ColorTuple
  kind: callable
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ColorType
  kind: callable
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CoreSchema
  kind: callable
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HslColorTuple
  kind: callable
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaValue
  kind: callable
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Optional
  kind: callable
  ns: pydantic.color
  description: Optional[X] is equivalent to Union[X, None].
  summary: Optional[X] is equivalent to Union[X, None]
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PydanticCustomError
  kind: class
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: error_type
    default: null
    rest: false
  - kind: positional
    name: message_template
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: PydanticCustomError
  inherits_from:
  - <class 'ValueError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticCustomError.add_note
  kind: callable
  ns: pydantic.color
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticCustomError.args
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticCustomError.context
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticCustomError.message
  kind: callable
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PydanticCustomError.message_template
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticCustomError.type
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticCustomError.with_traceback
  kind: callable
  ns: pydantic.color
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: RGBA
  kind: class
  ns: pydantic.color
  description: Internal use only as a representation of a color.
  summary: Internal use only as a representation of a color
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: r
    default: null
    rest: false
  - kind: positional
    name: g
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - kind: positional
    name: alpha
    default: null
    rest: false
  - type: RGBA
  inherits_from: null
- name: RGBA.alpha
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RGBA.b
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RGBA.g
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RGBA.r
  kind: property
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Tuple
  kind: callable
  ns: pydantic.color
  description: |-
    Deprecated alias to builtins.tuple.

    Tuple[X, Y] is the cross-product type of X and Y.

    Example: Tuple[T1, T2] is a tuple of two elements corresponding
    to type variables T1 and T2.  Tuple[int, float, str] is a tuple
    of an int, a float and a string.

    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
  summary: Deprecated alias to builtins
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Type
  kind: callable
  ns: pydantic.color
  description: |-
    Deprecated alias to builtins.type.

    builtins.type or typing.Type can be used to annotate class objects.
    For example, suppose we have the following classes::

        class User: ...  # Abstract base for User classes
        class BasicUser(User): ...
        class ProUser(User): ...
        class TeamUser(User): ...

    And a function that takes a class argument that's a subclass of
    User and returns an instance of the corresponding class::

        U = TypeVar('U', bound=User)
        def new_user(user_class: Type[U]) -> U:
            user = user_class()
            # (Here we could write the user object to a database)
            return user

        joe = new_user(BasicUser)

    At this point the type checker knows that joe has type BasicUser.
  summary: Deprecated alias to builtins
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Union
  kind: callable
  ns: pydantic.color
  description: |-
    Union type; Union[X, Y] means either X or Y.

    On Python 3.10 and higher, the | operator
    can also be used to denote unions;
    X | Y means the same thing to the type checker as Union[X, Y].

    To define a union, use e.g. Union[int, str]. Details:
    - The arguments must be types and there must be at least one.
    - None as an argument is a special case and is replaced by
      type(None).
    - Unions of unions are flattened, e.g.::

        assert Union[Union[int, str], float] == Union[int, str, float]

    - Unions of a single argument vanish, e.g.::

        assert Union[int] == int  # The constructor actually returns int

    - Redundant arguments are skipped, e.g.::

        assert Union[int, str, int] == Union[int, str]

    - When comparing unions, the argument order is ignored, e.g.::

        assert Union[int, str] == Union[str, int]

    - You cannot subclass or instantiate a union.
    - You can use Optional[X] as a shorthand for Union[X, None].
  summary: Union type; Union[X, Y] means either X or Y
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: cast
  kind: function
  ns: pydantic.color
  description: |-
    Cast a value to a type.

    This returns the value unchanged.  To the type checker this
    signals that the return value has the designated type, but at
    runtime we intentionally don't check anything (we want this
    to be as fast as possible).
  summary: Cast a value to a type
  signatures:
  - kind: positional
    name: typ
    default: null
    rest: false
  - kind: positional
    name: val
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: deprecated
  kind: class
  ns: pydantic.color
  description: |-
    Indicate that a class, function or overload is deprecated.

    When this decorator is applied to an object, the type checker
    will generate a diagnostic on usage of the deprecated object.

    Usage:

        @deprecated("Use B instead")
        class A:
            pass

        @deprecated("Use g instead")
        def f():
            pass

        @overload
        @deprecated("int support is deprecated")
        def g(x: int) -> int: ...
        @overload
        def g(x: str) -> int: ...

    The warning specified by *category* will be emitted at runtime
    on use of deprecated objects. For functions, that happens on calls;
    for classes, on instantiation and on creation of subclasses.
    If the *category* is ``None``, no warning is emitted at runtime.
    The *stacklevel* determines where the
    warning is emitted. If it is ``1`` (the default), the warning
    is emitted at the direct caller of the deprecated object; if it
    is higher, it is emitted further up the stack.
    Static type checker behavior is not affected by the *category*
    and *stacklevel* arguments.

    The deprecation message passed to the decorator is saved in the
    ``__deprecated__`` attribute on the decorated object.
    If applied to an overload, the decorator
    must be after the ``@overload`` decorator for the attribute to
    exist on the overload as returned by ``get_overloads()``.

    See PEP 702 for details.
  summary: Indicate that a class, function or overload is deprecated
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: message
    default: null
    rest: false
  - name: category
    default: <class 'DeprecationWarning'>
    rest: false
    kind: kw-only
  - name: stacklevel
    default: '1'
    rest: false
    kind: kw-only
  - type: deprecated
  inherits_from: null
- name: float_to_255
  kind: function
  ns: pydantic.color
  description: |-
    Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).

    Args:
        c: The float value to be converted. Must be between 0 and 1 (inclusive).

    Returns:
        The integer equivalent of the given float value rounded to the nearest whole number.

    Raises:
        ValueError: If the given float value is outside the acceptable range of 0 to 1 (inclusive).
  summary: Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive)
  signatures:
  - kind: positional
    name: c
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: hls_to_rgb
  kind: function
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: h
    default: null
    rest: false
  - kind: positional
    name: l
    default: null
    rest: false
  - kind: positional
    name: s
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ints_to_rgba
  kind: function
  ns: pydantic.color
  description: |-
    Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object.

    Args:
        r: An integer or string representing the red color value.
        g: An integer or string representing the green color value.
        b: An integer or string representing the blue color value.
        alpha: A float representing the alpha value. Defaults to None.

    Returns:
        An instance of the `RGBA` class with the corresponding color and alpha values.
  summary: Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object
  signatures:
  - kind: positional
    name: r
    default: null
    rest: false
  - kind: positional
    name: g
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - kind: positional
    name: alpha
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_color_value
  kind: function
  ns: pydantic.color
  description: |-
    Parse the color value provided and return a number between 0 and 1.

    Args:
        value: An integer or string color value.
        max_val: Maximum range value. Defaults to 255.

    Raises:
        PydanticCustomError: If the value is not a valid color.

    Returns:
        A number between 0 and 1.
  summary: Parse the color value provided and return a number between 0 and 1
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: max_val
    default: '255'
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_float_alpha
  kind: function
  ns: pydantic.color
  description: |-
    Parse an alpha value checking it's a valid float in the range 0 to 1.

    Args:
        value: The input value to parse.

    Returns:
        The parsed value as a float, or `None` if the value was None or equal 1.

    Raises:
        PydanticCustomError: If the input value cannot be successfully parsed as a float in the expected range.
  summary: Parse an alpha value checking it's a valid float in the range 0 to 1
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_hsl
  kind: function
  ns: pydantic.color
  description: |-
    Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.

    Args:
        h: The hue value.
        h_units: The unit for hue value.
        sat: The saturation value.
        light: The lightness value.
        alpha: Alpha value.

    Returns:
        An instance of `RGBA`.
  summary: Parse raw hue, saturation, lightness, and alpha values and convert to RGBA
  signatures:
  - kind: positional
    name: h
    default: null
    rest: false
  - kind: positional
    name: h_units
    default: null
    rest: false
  - kind: positional
    name: sat
    default: null
    rest: false
  - kind: positional
    name: light
    default: null
    rest: false
  - kind: positional
    name: alpha
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_str
  kind: function
  ns: pydantic.color
  description: |-
    Parse a string representing a color to an RGBA tuple.

    Possible formats for the input string include:

    * named color, see `COLORS_BY_NAME`
    * hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)
    * hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)
    * `rgb(<r>, <g>, <b>)`
    * `rgba(<r>, <g>, <b>, <a>)`

    Args:
        value: A string representing a color.

    Returns:
        An `RGBA` tuple parsed from the input string.

    Raises:
        ValueError: If the input string cannot be parsed to an RGBA tuple.
  summary: Parse a string representing a color to an RGBA tuple
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_tuple
  kind: function
  ns: pydantic.color
  description: |-
    Parse a tuple or list to get RGBA values.

    Args:
        value: A tuple or list.

    Returns:
        An `RGBA` tuple parsed from the input tuple.

    Raises:
        PydanticCustomError: If tuple is not valid.
  summary: Parse a tuple or list to get RGBA values
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: r_hex_long
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: r_hex_short
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: r_hsl
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: r_hsl_v4_style
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: r_rgb
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: r_rgb_v4_style
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: rads
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: repeat_colors
  kind: const
  ns: pydantic.color
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: rgb_to_hls
  kind: function
  ns: pydantic.color
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: r
    default: null
    rest: false
  - kind: positional
    name: g
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.config
  kind: module
  ns: null
  description: Configuration for Pydantic models.
  summary: Configuration for Pydantic models
  signatures: null
  inherits_from: null
- name: pydantic.dataclasses
  kind: module
  ns: null
  description: Provide an enhanced dataclass that performs validation.
  summary: Provide an enhanced dataclass that performs validation
  signatures: null
  inherits_from: null
- name: dataclass
  kind: function
  ns: pydantic.dataclasses
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/dataclasses/

    A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,
    but with added validation.

    This function should be used similarly to `dataclasses.dataclass`.

    Args:
        _cls: The target `dataclass`.
        init: Included for signature compatibility with `dataclasses.dataclass`, and is passed through to
            `dataclasses.dataclass` when appropriate. If specified, must be set to `False`, as pydantic inserts its
            own  `__init__` function.
        repr: A boolean indicating whether to include the field in the `__repr__` output.
        eq: Determines if a `__eq__` method should be generated for the class.
        order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.
        unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.
        frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its
            attributes to be modified after it has been initialized.
        config: The Pydantic config to use for the `dataclass`.
        validate_on_init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses
            are validated on init.
        kw_only: Determines if `__init__` method parameters must be specified by keyword only. Defaults to `False`.
        slots: Determines if the generated class should be a 'slots' `dataclass`, which does not allow the addition of
            new attributes after instantiation.

    Returns:
        A decorator that accepts a class as its argument and returns a Pydantic `dataclass`.

    Raises:
        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: _cls
    default: None
    rest: false
  - name: init
    default: 'False'
    rest: false
    kind: kw-only
  - name: repr
    default: 'True'
    rest: false
    kind: kw-only
  - name: eq
    default: 'True'
    rest: false
    kind: kw-only
  - name: order
    default: 'False'
    rest: false
    kind: kw-only
  - name: unsafe_hash
    default: 'False'
    rest: false
    kind: kw-only
  - name: frozen
    default: 'False'
    rest: false
    kind: kw-only
  - name: config
    default: None
    rest: false
    kind: kw-only
  - name: validate_on_init
    default: None
    rest: false
    kind: kw-only
  - name: kw_only
    default: 'False'
    rest: false
    kind: kw-only
  - name: slots
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: rebuild_dataclass
  kind: function
  ns: pydantic.dataclasses
  description: |-
    Try to rebuild the pydantic-core schema for the dataclass.

    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during
    the initial attempt to build the schema, and automatic rebuilding fails.

    This is analogous to `BaseModel.model_rebuild`.

    Args:
        cls: The class to rebuild the pydantic-core schema for.
        force: Whether to force the rebuilding of the schema, defaults to `False`.
        raise_errors: Whether to raise errors, defaults to `True`.
        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.
        _types_namespace: The types namespace, defaults to `None`.

    Returns:
        Returns `None` if the schema is already "complete" and rebuilding was not required.
        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
  summary: Try to rebuild the pydantic-core schema for the dataclass
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: force
    default: 'False'
    rest: false
    kind: kw-only
  - name: raise_errors
    default: 'True'
    rest: false
    kind: kw-only
  - name: _parent_namespace_depth
    default: '2'
    rest: false
    kind: kw-only
  - name: _types_namespace
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: pydantic.datetime_parse
  kind: module
  ns: null
  description: The `datetime_parse` module is a backport module from V1.
  summary: The `datetime_parse` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.datetime_parse
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.decorator
  kind: module
  ns: null
  description: The `decorator` module is a backport module from V1.
  summary: The `decorator` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.decorator
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.deprecated
  kind: module
  ns: null
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: class_validators
  kind: module
  ns: pydantic.deprecated
  description: Old `@validator` and `@root_validator` function validators from V1.
  summary: Old `@validator` and `@root_validator` function validators from V1
  signatures: null
  inherits_from: null
- name: Callable
  kind: callable
  ns: pydantic.deprecated
  description: |-
    Deprecated alias to collections.abc.Callable.

    Callable[[int], str] signifies a function that takes a single
    parameter of type int and returns a str.

    The subscription syntax must always be used with exactly two
    values: the argument list and the return type.
    The argument list must be a list of types, a ParamSpec,
    Concatenate or ellipsis. The return type must be a single type.

    There is no syntax to indicate optional or keyword arguments;
    such function types are rarely used as callback types.
  summary: Deprecated alias to collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FunctionType
  kind: class
  ns: pydantic.deprecated
  description: |-
    Create a function object.

    code
      a code object
    globals
      the globals dictionary
    name
      a string that overrides the name from the code object
    argdefs
      a tuple that specifies the default argument values
    closure
      a tuple that supplies the bindings for free variables
  summary: Create a function object
  signatures:
  - kind: positional
    name: code
    default: null
    rest: false
  - kind: positional
    name: globals
    default: null
    rest: false
  - kind: positional
    name: name
    default: None
    rest: false
  - kind: positional
    name: argdefs
    default: None
    rest: false
  - kind: positional
    name: closure
    default: None
    rest: false
  - type: function
  inherits_from: null
- name: Literal
  kind: callable
  ns: pydantic.deprecated
  description: |-
    Special typing form to define literal types (a.k.a. value types).

    This form can be used to indicate to type checkers that the corresponding
    variable or function parameter has a value equivalent to the provided
    literal (or one of several literals)::

        def validate_simple(data: Any) -> Literal[True]:  # always returns True
            ...

        MODE = Literal['r', 'rb', 'w', 'wb']
        def open_helper(file: str, mode: MODE) -> str:
            ...

        open_helper('/some/path', 'r')  # Passes type check
        open_helper('/other/path', 'typo')  # Error in type checker

    Literal[...] cannot be subclassed. At runtime, an arbitrary value
    is allowed as type argument to Literal[...], but type checkers may
    impose restrictions.
  summary: Special typing form to define literal types (a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol
  kind: class
  ns: pydantic.deprecated
  description: |-
    Base class for protocol classes.

    Protocol classes are defined as::

        class Proto(Protocol):
            def meth(self) -> int:
                ...

    Such classes are primarily used with static type checkers that recognize
    structural subtyping (static duck-typing).

    For example::

        class C:
            def meth(self) -> int:
                return 0

        def func(x: Proto) -> int:
            return x.meth()

        func(C())  # Passes static type check

    See PEP 544 for details. Protocol classes decorated with
    @typing.runtime_checkable act as simple-minded runtime protocols that check
    only the presence of given attributes, ignoring their type signatures.
    Protocol classes can be generic, they are defined as::

        class GenProto(Protocol[T]):
            def meth(self) -> T:
                ...
  summary: Base class for protocol classes
  signatures:
  - type: Protocol
  inherits_from:
  - <class 'typing.Generic'>
- name: TYPE_CHECKING
  kind: const
  ns: pydantic.deprecated
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: TypeAlias
  kind: callable
  ns: pydantic.deprecated
  description: |-
    Special form for marking type aliases.

    Use TypeAlias to indicate that an assignment should
    be recognized as a proper type alias definition by type
    checkers.

    For example::

        Predicate: TypeAlias = Callable[..., bool]

    It's invalid when used anywhere except as in the example above.
  summary: Special form for marking type aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: TypeVar
  kind: class
  ns: pydantic.deprecated
  description: |-
    Type variable.

    Usage::

      T = TypeVar('T')  # Can be anything
      A = TypeVar('A', str, bytes)  # Must be str or bytes

    Type variables exist primarily for the benefit of static type
    checkers.  They serve as the parameters for generic types as well
    as for generic function definitions.  See class Generic for more
    information on generic types.  Generic functions work as follows:

      def repeat(x: T, n: int) -> List[T]:
          '''Return a list containing n references to x.'''
          return [x]*n

      def longest(x: A, y: A) -> A:
          '''Return the longest of two strings.'''
          return x if len(x) >= len(y) else y

    The latter example's signature is essentially the overloading
    of (str, str) -> str and (bytes, bytes) -> bytes.  Also note
    that if the arguments are instances of some subclass of str,
    the return type is still plain str.

    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.

    Type variables defined with covariant=True or contravariant=True
    can be used to declare covariant or contravariant generic types.
    See PEP 484 for more details. By default generic types are invariant
    in all type variables.

    Type variables can be introspected. e.g.:

      T.__name__ == 'T'
      T.__constraints__ == ()
      T.__covariant__ == False
      T.__contravariant__ = False
      A.__constraints__ == (str, bytes)

    Note that only type variables defined in global scope can be pickled.
  summary: Type variable
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - name: bound
    default: None
    rest: false
    kind: kw-only
  - name: covariant
    default: 'False'
    rest: false
    kind: kw-only
  - name: contravariant
    default: 'False'
    rest: false
    kind: kw-only
  - type: TypeVar
  inherits_from:
  - <class 'typing._Final'>
  - <class 'typing._Immutable'>
  - <class 'typing._BoundVarianceMixin'>
  - <class 'typing._PickleUsingNameMixin'>
- name: Union
  kind: callable
  ns: pydantic.deprecated
  description: |-
    Union type; Union[X, Y] means either X or Y.

    On Python 3.10 and higher, the | operator
    can also be used to denote unions;
    X | Y means the same thing to the type checker as Union[X, Y].

    To define a union, use e.g. Union[int, str]. Details:
    - The arguments must be types and there must be at least one.
    - None as an argument is a special case and is replaced by
      type(None).
    - Unions of unions are flattened, e.g.::

        assert Union[Union[int, str], float] == Union[int, str, float]

    - Unions of a single argument vanish, e.g.::

        assert Union[int] == int  # The constructor actually returns int

    - Redundant arguments are skipped, e.g.::

        assert Union[int, str, int] == Union[int, str]

    - When comparing unions, the argument order is ignored, e.g.::

        assert Union[int, str] == Union[str, int]

    - You cannot subclass or instantiate a union.
    - You can use Optional[X] as a shorthand for Union[X, None].
  summary: Union type; Union[X, Y] means either X or Y
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: overload
  kind: function
  ns: pydantic.deprecated
  description: |-
    Decorator for overloaded functions/methods.

    In a stub file, place two or more stub definitions for the same
    function in a row, each decorated with @overload.

    For example::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...

    In a non-stub file (i.e. a regular .py file), do the same but
    follow it with an implementation.  The implementation should *not*
    be decorated with @overload::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...
        def utf8(value):
            ...  # implementation goes here

    The overloads for a function can be retrieved at runtime using the
    get_overloads() function.
  summary: Decorator for overloaded functions/methods
  signatures:
  - kind: positional
    name: func
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: partial
  kind: class
  ns: pydantic.deprecated
  description: |-
    partial(func, *args, **keywords) - new function with partial application
    of the given arguments and keywords.
  summary: partial(func, *args, **keywords) - new function with partial application
  signatures: null
  inherits_from: null
- name: partial.args
  kind: property
  ns: pydantic.deprecated
  description: tuple of arguments to future partial calls
  summary: tuple of arguments to future partial calls
  signatures: null
  inherits_from: null
- name: partial.func
  kind: property
  ns: pydantic.deprecated
  description: function object to use in future partial calls
  summary: function object to use in future partial calls
  signatures: null
  inherits_from: null
- name: partial.keywords
  kind: property
  ns: pydantic.deprecated
  description: dictionary of keyword arguments to future partial calls
  summary: dictionary of keyword arguments to future partial calls
  signatures: null
  inherits_from: null
- name: partialmethod
  kind: class
  ns: pydantic.deprecated
  description: |-
    Method descriptor with partial application of the given arguments
    and keywords.

    Supports wrapping existing descriptors and handles non-descriptor
    callables as instance methods.
  summary: Method descriptor with partial application of the given arguments
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - type: partialmethod
  inherits_from: null
- name: root_validator
  kind: function
  ns: pydantic.deprecated
  description: |-
    Decorate methods on a model indicating that they should be used to validate (and perhaps
    modify) data either before or after standard model parsing/validation is performed.

    Args:
        pre (bool, optional): Whether this validator should be called before the standard
            validators (else after). Defaults to False.
        skip_on_failure (bool, optional): Whether to stop validation and return as soon as a
            failure is encountered. Defaults to False.
        allow_reuse (bool, optional): Whether to track and raise an error if another validator
            refers to the decorated function. Defaults to False.

    Returns:
        Any: A decorator that can be used to decorate a function to be used as a root_validator.
  summary: Decorate methods on a model indicating that they should be used to validate (and perhaps
  signatures:
  - name: pre
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_on_failure
    default: 'False'
    rest: false
    kind: kw-only
  - name: allow_reuse
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: validator
  kind: function
  ns: pydantic.deprecated
  description: |-
    Decorate methods on the class indicating that they should be used to validate fields.

    Args:
        __field (str): The first field the validator should be called on; this is separate
            from `fields` to ensure an error is raised if you don't pass at least one.
        *fields (str): Additional field(s) the validator should be called on.
        pre (bool, optional): Whether this validator should be called before the standard
            validators (else after). Defaults to False.
        each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate
            individual elements rather than the whole object. Defaults to False.
        always (bool, optional): Whether this method and other validators should be called even if
            the value is missing. Defaults to False.
        check_fields (bool | None, optional): Whether to check that the fields actually exist on the model.
            Defaults to None.
        allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to
            the decorated function. Defaults to False.

    Returns:
        Callable: A decorator that can be used to decorate a
            function to be used as a validator.
  summary: Decorate methods on the class indicating that they should be used to validate fields
  signatures:
  - kind: positional
    name: __field
    default: null
    rest: false
  - name: pre
    default: 'False'
    rest: false
    kind: kw-only
  - name: each_item
    default: 'False'
    rest: false
    kind: kw-only
  - name: always
    default: 'False'
    rest: false
    kind: kw-only
  - name: check_fields
    default: None
    rest: false
    kind: kw-only
  - name: allow_reuse
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: config
  kind: module
  ns: pydantic.deprecated
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: tools
  kind: module
  ns: pydantic.deprecated
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: parse_obj_as
  kind: function
  ns: pydantic.deprecated
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - kind: positional
    name: type_name
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: schema_of
  kind: function
  ns: pydantic.deprecated
  description: Generate a JSON schema (as dict) for the passed model or dynamically generated one.
  summary: Generate a JSON schema (as dict) for the passed model or dynamically generated one
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: schema_json_of
  kind: function
  ns: pydantic.deprecated
  description: Generate a JSON schema (as JSON) for the passed model or dynamically generated one.
  summary: Generate a JSON schema (as JSON) for the passed model or dynamically generated one
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: pydantic.env_settings
  kind: module
  ns: null
  description: The `env_settings` module is a backport module from V1.
  summary: The `env_settings` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.env_settings
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.error_wrappers
  kind: module
  ns: null
  description: The `error_wrappers` module is a backport module from V1.
  summary: The `error_wrappers` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.error_wrappers
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.errors
  kind: module
  ns: null
  description: Pydantic-specific errors.
  summary: Pydantic-specific errors
  signatures: null
  inherits_from: null
- name: PydanticErrorCodes
  kind: callable
  ns: pydantic.errors
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.fields
  kind: module
  ns: null
  description: Defining fields on models.
  summary: Defining fields on models
  signatures: null
  inherits_from: null
- name: ClassVar
  kind: callable
  ns: pydantic.fields
  description: |-
    Special type construct to mark class variables.

    An annotation wrapped in ClassVar indicates that a given
    attribute is intended to be used as a class variable and
    should not be set on instances of that class.

    Usage::

        class Starship:
            stats: ClassVar[dict[str, int]] = {} # class variable
            damage: int = 10                     # instance variable

    ClassVar accepts only types and cannot be further subscribed.

    Note that ClassVar is not a class itself, and should not
    be used with isinstance() or issubclass().
  summary: Special type construct to mark class variables
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ComputedFieldInfo
  kind: class
  ns: pydantic.fields
  description: |-
    A container for data from `@computed_field` so that we can access it while building the pydantic-core schema.

    Attributes:
        decorator_repr: A class variable representing the decorator string, '@computed_field'.
        wrapped_property: The wrapped computed field property.
        return_type: The type of the computed field property's return value.
        alias: The alias of the property to be used during serialization.
        alias_priority: The priority of the alias. This affects whether an alias generator is used.
        title: Title of the computed field to include in the serialization JSON schema.
        description: Description of the computed field to include in the serialization JSON schema.
        examples: Example values of the computed field to include in the serialization JSON schema.
        json_schema_extra: A dict or callable to provide extra JSON schema properties.
        repr: A boolean indicating whether to include the field in the __repr__ output.
  summary: A container for data from `@computed_field` so that we can access it while building the pydantic-core schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: wrapped_property
    default: null
    rest: false
  - kind: positional
    name: return_type
    default: null
    rest: false
  - kind: positional
    name: alias
    default: null
    rest: false
  - kind: positional
    name: alias_priority
    default: null
    rest: false
  - kind: positional
    name: title
    default: null
    rest: false
  - kind: positional
    name: description
    default: null
    rest: false
  - kind: positional
    name: examples
    default: null
    rest: false
  - kind: positional
    name: json_schema_extra
    default: null
    rest: false
  - kind: positional
    name: repr
    default: null
    rest: false
  - type: ComputedFieldInfo
  inherits_from: null
- name: ComputedFieldInfo.alias
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.alias_priority
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.decorator_repr
  kind: property
  ns: pydantic.fields
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.description
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.examples
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.json_schema_extra
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.repr
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.return_type
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.title
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ComputedFieldInfo.wrapped_property
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField
  kind: class
  ns: pydantic.fields
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: default
    default: null
    rest: false
  - kind: positional
    name: default_factory
    default: null
    rest: false
  - kind: positional
    name: init
    default: null
    rest: false
  - kind: positional
    name: repr
    default: null
    rest: false
  - kind: positional
    name: hash
    default: null
    rest: false
  - kind: positional
    name: compare
    default: null
    rest: false
  - kind: positional
    name: metadata
    default: null
    rest: false
  - kind: positional
    name: kw_only
    default: null
    rest: false
  - type: Field
  inherits_from: null
- name: DataclassField.compare
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.default
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.default_factory
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.hash
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.init
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.kw_only
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.metadata
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.name
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.repr
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DataclassField.type
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Field
  kind: function
  ns: pydantic.fields
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/fields

    Create a field for objects that can be configured.

    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
    apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.

    Note:
        - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`

    Args:
        default: Default value if the field is not set.
        default_factory: A callable to generate the default value, such as :func:`~datetime.utcnow`.
        alias: The name to use for the attribute when validating or serializing by alias.
            This is often used for things like converting between snake and camel case.
        alias_priority: Priority of the alias. This affects whether an alias generator is used.
        validation_alias: Like `alias`, but only affects validation, not serialization.
        serialization_alias: Like `alias`, but only affects serialization, not validation.
        title: Human-readable title.
        description: Human-readable description.
        examples: Example values for this field.
        exclude: Whether to exclude the field from the model serialization.
        discriminator: Field name or Discriminator for discriminating the type in a tagged union.
        json_schema_extra: A dict or callable to provide extra JSON schema properties.
        frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.
        validate_default: If `True`, apply validation to the default value every time you create an instance.
            Otherwise, for performance reasons, the default value of the field is trusted and not validated.
        repr: A boolean indicating whether to include the field in the `__repr__` output.
        init: Whether the field should be included in the constructor of the dataclass.
            (Only applies to dataclasses.)
        init_var: Whether the field should _only_ be included in the constructor of the dataclass.
            (Only applies to dataclasses.)
        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.
            (Only applies to dataclasses.)
        strict: If `True`, strict validation is applied to the field.
            See [Strict Mode](../concepts/strict_mode.md) for details.
        gt: Greater than. If set, value must be greater than this. Only applicable to numbers.
        ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.
        lt: Less than. If set, value must be less than this. Only applicable to numbers.
        le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.
        multiple_of: Value must be a multiple of this. Only applicable to numbers.
        min_length: Minimum length for strings.
        max_length: Maximum length for strings.
        pattern: Pattern for strings (a regular expression).
        allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to numbers.
        max_digits: Maximum number of allow digits for strings.
        decimal_places: Maximum number of decimal places allowed for numbers.
        union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.
            See [Union Mode](standard_library_types.md#union-mode) for details.
        extra: (Deprecated) Extra fields that will be included in the JSON schema.

            !!! warning Deprecated
                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.

    Returns:
        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on
            type-annotated fields without causing a type error.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: alias
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: alias_priority
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: validation_alias
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: serialization_alias
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: title
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: description
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: examples
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: exclude
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: discriminator
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: json_schema_extra
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: frozen
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: validate_default
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: repr
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: init
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: init_var
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: kw_only
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: pattern
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: strict
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: gt
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: ge
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: lt
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: le
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: multiple_of
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: max_digits
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: decimal_places
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: min_length
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: max_length
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: union_mode
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: FieldInfo
  kind: class
  ns: pydantic.fields
  description: |-
    This class holds information about a field.

    `FieldInfo` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field]
    function is explicitly used.

    !!! warning
        You generally shouldn't be creating `FieldInfo` directly, you'll only need to use it when accessing
        [`BaseModel`][pydantic.main.BaseModel] `.model_fields` internals.

    Attributes:
        annotation: The type annotation of the field.
        default: The default value of the field.
        default_factory: The factory function used to construct the default for the field.
        alias: The alias name of the field.
        alias_priority: The priority of the field's alias.
        validation_alias: The validation alias of the field.
        serialization_alias: The serialization alias of the field.
        title: The title of the field.
        description: The description of the field.
        examples: List of examples of the field.
        exclude: Whether to exclude the field from the model serialization.
        discriminator: Field name or Discriminator for discriminating the type in a tagged union.
        json_schema_extra: A dict or callable to provide extra JSON schema properties.
        frozen: Whether the field is frozen.
        validate_default: Whether to validate the default value of the field.
        repr: Whether to include the field in representation of the model.
        init: Whether the field should be included in the constructor of the dataclass.
        init_var: Whether the field should _only_ be included in the constructor of the dataclass, and not stored.
        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.
        metadata: List of metadata constraints.
  summary: This class holds information about a field
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: FieldInfo
  inherits_from:
  - <class 'pydantic._internal._repr.Representation'>
- name: FieldInfo.alias
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.alias_priority
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.annotation
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.apply_typevars_map
  kind: method
  ns: pydantic.fields
  description: |-
    Apply a `typevars_map` to the annotation.

    This method is used when analyzing parametrized generic types to replace typevars with their concrete types.

    This method applies the `typevars_map` to the annotation in place.

    Args:
        typevars_map: A dictionary mapping type variables to their concrete types.
        types_namespace (dict | None): A dictionary containing related types to the annotated type.

    See Also:
        pydantic._internal._generics.replace_types is used for replacing the typevars with
            their concrete types.
  summary: Apply a `typevars_map` to the annotation
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: typevars_map
    default: null
    rest: false
  - kind: positional
    name: types_namespace
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldInfo.default
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.default_factory
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.description
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.discriminator
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.examples
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.exclude
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.from_annotated_attribute
  kind: method
  ns: pydantic.fields
  description: |-
    Create `FieldInfo` from an annotation with a default value.

    This is used in cases like the following:

    ```python
    import annotated_types
    from typing_extensions import Annotated

    import pydantic

    class MyModel(pydantic.BaseModel):
        foo: int = 4  # <-- like this
        bar: Annotated[int, annotated_types.Gt(4)] = 4  # <-- or this
        spam: Annotated[int, pydantic.Field(gt=4)] = 4  # <-- or this
    ```

    Args:
        annotation: The type annotation of the field.
        default: The default value of the field.

    Returns:
        A field object with the passed values.
  summary: Create `FieldInfo` from an annotation with a default value
  signatures:
  - kind: positional
    name: annotation
    default: null
    rest: false
  - kind: positional
    name: default
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldInfo.from_annotation
  kind: method
  ns: pydantic.fields
  description: |-
    Creates a `FieldInfo` instance from a bare annotation.

    This function is used internally to create a `FieldInfo` from a bare annotation like this:

    ```python
    import pydantic

    class MyModel(pydantic.BaseModel):
        foo: int  # <-- like this
    ```

    We also account for the case where the annotation can be an instance of `Annotated` and where
    one of the (not first) arguments in `Annotated` is an instance of `FieldInfo`, e.g.:

    ```python
    import annotated_types
    from typing_extensions import Annotated

    import pydantic

    class MyModel(pydantic.BaseModel):
        foo: Annotated[int, annotated_types.Gt(42)]
        bar: Annotated[int, pydantic.Field(gt=42)]
    ```

    Args:
        annotation: An annotation object.

    Returns:
        An instance of the field metadata.
  summary: Creates a `FieldInfo` instance from a bare annotation
  signatures:
  - kind: positional
    name: annotation
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldInfo.from_field
  kind: method
  ns: pydantic.fields
  description: |-
    Create a new `FieldInfo` object with the `Field` function.

    Args:
        default: The default value for the field. Defaults to Undefined.
        **kwargs: Additional arguments dictionary.

    Raises:
        TypeError: If 'annotation' is passed as a keyword argument.

    Returns:
        A new FieldInfo object with the given parameters.

    Example:
        This is how you can create a field with default value like this:

        ```python
        import pydantic

        class MyModel(pydantic.BaseModel):
            foo: int = pydantic.Field(4)
        ```
  summary: Create a new `FieldInfo` object with the `Field` function
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldInfo.frozen
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.get_default
  kind: method
  ns: pydantic.fields
  description: |-
    Get the default value.

    We expose an option for whether to call the default_factory (if present), as calling it may
    result in side effects that we want to avoid. However, there are times when it really should
    be called (namely, when instantiating a model via `model_construct`).

    Args:
        call_default_factory: Whether to call the default_factory or not. Defaults to `False`.

    Returns:
        The default value, calling the default factory if requested or `None` if not set.
  summary: Get the default value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: call_default_factory
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: FieldInfo.init
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.init_var
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.is_required
  kind: method
  ns: pydantic.fields
  description: |-
    Check if the field is required (i.e., does not have a default value or factory).

    Returns:
        `True` if the field is required, `False` otherwise.
  summary: Check if the field is required (i
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldInfo.json_schema_extra
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.kw_only
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.merge_field_infos
  kind: method
  ns: pydantic.fields
  description: |-
    Merge `FieldInfo` instances keeping only explicitly set attributes.

    Later `FieldInfo` instances override earlier ones.

    Returns:
        FieldInfo: A merged FieldInfo instance.
  summary: Merge `FieldInfo` instances keeping only explicitly set attributes
  signatures:
  - type: '?'
  inherits_from: null
- name: FieldInfo.metadata
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.metadata_lookup
  kind: property
  ns: pydantic.fields
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: FieldInfo.rebuild_annotation
  kind: method
  ns: pydantic.fields
  description: |-
    Attempts to rebuild the original annotation for use in function signatures.

    If metadata is present, it adds it to the original annotation using
    `Annotated`. Otherwise, it returns the original annotation as-is.

    Note that because the metadata has been flattened, the original annotation
    may not be reconstructed exactly as originally provided, e.g. if the original
    type had unrecognized annotations, or was annotated with a call to `pydantic.Field`.

    Returns:
        The rebuilt annotation.
  summary: Attempts to rebuild the original annotation for use in function signatures
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldInfo.repr
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.serialization_alias
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.title
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.validate_default
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FieldInfo.validation_alias
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: JsonDict
  kind: callable
  ns: pydantic.fields
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Literal
  kind: callable
  ns: pydantic.fields
  description: |-
    Special typing form to define literal types (a.k.a. value types).

    This form can be used to indicate to type checkers that the corresponding
    variable or function parameter has a value equivalent to the provided
    literal (or one of several literals)::

        def validate_simple(data: Any) -> Literal[True]:  # always returns True
            ...

        MODE = Literal['r', 'rb', 'w', 'wb']
        def open_helper(file: str, mode: MODE) -> str:
            ...

        open_helper('/some/path', 'r')  # Passes type check
        open_helper('/other/path', 'typo')  # Error in type checker

    Literal[...] cannot be subclassed. At runtime, an arbitrary value
    is allowed as type argument to Literal[...], but type checkers may
    impose restrictions.
  summary: Special typing form to define literal types (a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ModelPrivateAttr
  kind: class
  ns: pydantic.fields
  description: |-
    A descriptor for private attributes in class models.

    !!! warning
        You generally shouldn't be creating `ModelPrivateAttr` instances directly, instead use
        `pydantic.fields.PrivateAttr`. (This is similar to `FieldInfo` vs. `Field`.)

    Attributes:
        default: The default value of the attribute if not provided.
        default_factory: A callable function that generates the default value of the
            attribute if not provided.
  summary: A descriptor for private attributes in class models
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: None
    rest: false
    kind: kw-only
  - type: ModelPrivateAttr
  inherits_from:
  - <class 'pydantic._internal._repr.Representation'>
- name: ModelPrivateAttr.default
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ModelPrivateAttr.default_factory
  kind: property
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ModelPrivateAttr.get_default
  kind: method
  ns: pydantic.fields
  description: |-
    Retrieve the default value of the object.

    If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.

    If `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.

    Returns:
        The default value of the object.
  summary: Retrieve the default value of the object
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PrivateAttr
  kind: function
  ns: pydantic.fields
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/models/#private-model-attributes

    Indicates that an attribute is intended for private use and not handled during normal validation/serialization.

    Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.

    Private attributes are stored in `__private_attributes__` on the model.

    Args:
        default: The attribute's default value. Defaults to Undefined.
        default_factory: Callable that will be
            called when a default value is needed for this attribute.
            If both `default` and `default_factory` are set, an error will be raised.

    Returns:
        An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.

    Raises:
        ValueError: If both `default` and `default_factory` are set.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PropertyT
  kind: const
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticUndefined
  kind: const
  ns: pydantic.fields
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Unpack
  kind: callable
  ns: pydantic.fields
  description: |-
    Type unpack operator.

    The type unpack operator takes the child types from some container type,
    such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For
    example:

      # For some generic class `Foo`:
      Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]

      Ts = TypeVarTuple('Ts')
      # Specifies that `Bar` is generic in an arbitrary number of types.
      # (Think of `Ts` as a tuple of an arbitrary number of individual
      #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the
      #  `Generic[]`.)
      class Bar(Generic[Unpack[Ts]]): ...
      Bar[int]  # Valid
      Bar[int, str]  # Also valid

    From Python 3.11, this can also be done using the `*` operator:

        Foo[*tuple[int, str]]
        class Bar(Generic[*Ts]): ...

    The operator can also be used along with a `TypedDict` to annotate
    `**kwargs` in a function signature. For instance:

      class Movie(TypedDict):
        name: str
        year: int

      # This function expects two keyword arguments - *name* of type `str` and
      # *year* of type `int`.
      def foo(**kwargs: Unpack[Movie]): ...

    Note that there is only some runtime checking of this operator. Not
    everything the runtime allows may be accepted by static type checkers.

    For more information, see PEP 646 and PEP 692.
  summary: Type unpack operator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: cached_property
  kind: class
  ns: pydantic.fields
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: func
    default: null
    rest: false
  - type: cached_property
  inherits_from: null
- name: computed_field
  kind: function
  ns: pydantic.fields
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/fields#the-computed_field-decorator

    Decorator to include `property` and `cached_property` when serializing models or dataclasses.

    This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.

    ```py
    from pydantic import BaseModel, computed_field

    class Rectangle(BaseModel):
        width: int
        length: int

        @computed_field
        @property
        def area(self) -> int:
            return self.width * self.length

    print(Rectangle(width=3, length=2).model_dump())
    #> {'width': 3, 'length': 2, 'area': 6}
    ```

    If applied to functions not yet decorated with `@property` or `@cached_property`, the function is
    automatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,
    and confuse static type checkers, thus explicit use of `@property` is recommended.

    !!! warning "Mypy Warning"
        Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,
        mypy may throw a `Decorated property not supported` error.
        See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.
        To avoid this error message, add `# type: ignore[misc]` to the `@computed_field` line.

        [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.

    ```py
    import random

    from pydantic import BaseModel, computed_field

    class Square(BaseModel):
        width: float

        @computed_field
        def area(self) -> float:  # converted to a `property` by `computed_field`
            return round(self.width**2, 2)

        @area.setter
        def area(self, new_area: float) -> None:
            self.width = new_area**0.5

        @computed_field(alias='the magic number', repr=False)
        def random_number(self) -> int:
            return random.randint(0, 1_000)

    square = Square(width=1.3)

    # `random_number` does not appear in representation
    print(repr(square))
    #> Square(width=1.3, area=1.69)

    print(square.random_number)
    #> 3

    square.area = 4

    print(square.model_dump_json(by_alias=True))
    #> {"width":2.0,"area":4.0,"the magic number":3}
    ```

    !!! warning "Overriding with `computed_field`"
        You can't override a field from a parent class with a `computed_field` in the child class.
        `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.
        See the example below:

    ```py
    from pydantic import BaseModel, computed_field

    class Parent(BaseModel):
        a: str

    try:

        class Child(Parent):
            @computed_field
            @property
            def a(self) -> str:
                return 'new a'

    except ValueError as e:
        print(repr(e))
        #> ValueError("you can't override a field with a computed field")
    ```

    Private properties decorated with `@computed_field` have `repr=False` by default.

    ```py
    from functools import cached_property

    from pydantic import BaseModel, computed_field

    class Model(BaseModel):
        foo: int

        @computed_field
        @cached_property
        def _private_cached_property(self) -> int:
            return -self.foo

        @computed_field
        @property
        def _private_property(self) -> int:
            return -self.foo

    m = Model(foo=1)
    print(repr(m))
    #> M(foo=1)
    ```

    Args:
        __f: the function to wrap.
        alias: alias to use when serializing this computed field, only used when `by_alias=True`
        alias_priority: priority of the alias. This affects whether an alias generator is used
        title: Title to use when including this computed field in JSON Schema
        description: Description to use when including this computed field in JSON Schema, defaults to the function's
            docstring
        examples: Example values to use when including this computed field in JSON Schema
        json_schema_extra: A dict or callable to provide extra JSON schema properties.
        repr: whether to include this computed field in model repr.
            Default is `False` for private properties and `True` for public properties.
        return_type: optional return for serialization logic to expect when serializing to JSON, if included
            this must be correct, otherwise a `TypeError` is raised.
            If you don't include a return type Any is used, which does runtime introspection to handle arbitrary
            objects.

    Returns:
        A proxy wrapper for the property.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __f
    default: None
    rest: false
  - name: alias
    default: None
    rest: false
    kind: kw-only
  - name: alias_priority
    default: None
    rest: false
    kind: kw-only
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: description
    default: None
    rest: false
    kind: kw-only
  - name: examples
    default: None
    rest: false
    kind: kw-only
  - name: json_schema_extra
    default: None
    rest: false
    kind: kw-only
  - name: repr
    default: None
    rest: false
    kind: kw-only
  - name: return_type
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: copy
  kind: function
  ns: pydantic.fields
  description: |-
    Shallow copy operation on arbitrary Python objects.

    See the module's __doc__ string for more info.
  summary: Shallow copy operation on arbitrary Python objects
  signatures:
  - kind: positional
    name: x
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.functional_serializers
  kind: module
  ns: null
  description: This module contains related classes and functions for serialization.
  summary: This module contains related classes and functions for serialization
  signatures: null
  inherits_from: null
- name: Annotated
  kind: class
  ns: pydantic.functional_serializers
  description: |-
    Add context-specific metadata to a type.

    Example: Annotated[int, runtime_check.Unsigned] indicates to the
    hypothetical runtime_check module that this type is an unsigned int.
    Every other consumer of this type can ignore this metadata and treat
    this type as int.

    The first argument to Annotated must be a valid type.

    Details:

    - It's an error to call `Annotated` with less than two arguments.
    - Access the metadata via the ``__metadata__`` attribute::

        assert Annotated[int, '$'].__metadata__ == ('$',)

    - Nested Annotated types are flattened::

        assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]

    - Instantiating an annotated type is equivalent to instantiating the
    underlying type::

        assert Annotated[C, Ann1](5) == C(5)

    - Annotated can be used as a generic type alias::

        Optimized: TypeAlias = Annotated[T, runtime.Optimize()]
        assert Optimized[int] == Annotated[int, runtime.Optimize()]

        OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]
        assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]

    - Annotated cannot be used with an unpacked TypeVarTuple::

        Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid

      This would be equivalent to::

        Annotated[T1, T2, T3, ..., Ann1]

      where T1, T2 etc. are TypeVars, which would be invalid, because
      only one type should be passed to Annotated.
  summary: Add context-specific metadata to a type
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: Annotated
  inherits_from: null
- name: AnyType
  kind: const
  ns: pydantic.functional_serializers
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Callable
  kind: callable
  ns: pydantic.functional_serializers
  description: |-
    Deprecated alias to collections.abc.Callable.

    Callable[[int], str] signifies a function that takes a single
    parameter of type int and returns a str.

    The subscription syntax must always be used with exactly two
    values: the argument list and the return type.
    The argument list must be a list of types, a ParamSpec,
    Concatenate or ellipsis. The return type must be a single type.

    There is no syntax to indicate optional or keyword arguments;
    such function types are rarely used as callback types.
  summary: Deprecated alias to collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FuncType
  kind: const
  ns: pydantic.functional_serializers
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Literal
  kind: callable
  ns: pydantic.functional_serializers
  description: |-
    Special typing form to define literal types (a.k.a. value types).

    This form can be used to indicate to type checkers that the corresponding
    variable or function parameter has a value equivalent to the provided
    literal (or one of several literals)::

        def validate_simple(data: Any) -> Literal[True]:  # always returns True
            ...

        MODE = Literal['r', 'rb', 'w', 'wb']
        def open_helper(file: str, mode: MODE) -> str:
            ...

        open_helper('/some/path', 'r')  # Passes type check
        open_helper('/other/path', 'typo')  # Error in type checker

    Literal[...] cannot be subclassed. At runtime, an arbitrary value
    is allowed as type argument to Literal[...], but type checkers may
    impose restrictions.
  summary: Special typing form to define literal types (a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PydanticUndefined
  kind: const
  ns: pydantic.functional_serializers
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: TYPE_CHECKING
  kind: const
  ns: pydantic.functional_serializers
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: TypeAlias
  kind: callable
  ns: pydantic.functional_serializers
  description: |-
    Special form for marking type aliases.

    Use TypeAlias to indicate that an assignment should
    be recognized as a proper type alias definition by type
    checkers.

    For example::

        Predicate: TypeAlias = Callable[..., bool]

    It's invalid when used anywhere except as in the example above.
  summary: Special form for marking type aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Union
  kind: callable
  ns: pydantic.functional_serializers
  description: |-
    Union type; Union[X, Y] means either X or Y.

    On Python 3.10 and higher, the | operator
    can also be used to denote unions;
    X | Y means the same thing to the type checker as Union[X, Y].

    To define a union, use e.g. Union[int, str]. Details:
    - The arguments must be types and there must be at least one.
    - None as an argument is a special case and is replaced by
      type(None).
    - Unions of unions are flattened, e.g.::

        assert Union[Union[int, str], float] == Union[int, str, float]

    - Unions of a single argument vanish, e.g.::

        assert Union[int] == int  # The constructor actually returns int

    - Redundant arguments are skipped, e.g.::

        assert Union[int, str, int] == Union[int, str]

    - When comparing unions, the argument order is ignored, e.g.::

        assert Union[int, str] == Union[str, int]

    - You cannot subclass or instantiate a union.
    - You can use Optional[X] as a shorthand for Union[X, None].
  summary: Union type; Union[X, Y] means either X or Y
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: annotations
  kind: const
  ns: pydantic.functional_serializers
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: field_serializer
  kind: function
  ns: pydantic.functional_serializers
  description: |-
    Decorator that enables custom field serialization.

    In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.

    ```python
    from typing import Set

    from pydantic import BaseModel, field_serializer

    class StudentModel(BaseModel):
        name: str = 'Jane'
        courses: Set[str]

        @field_serializer('courses', when_used='json')
        def serialize_courses_in_order(courses: Set[str]):
            return sorted(courses)

    student = StudentModel(courses={'Math', 'Chemistry', 'English'})
    print(student.model_dump_json())
    #> {"name":"Jane","courses":["Chemistry","English","Math"]}
    ```

    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.

    Four signatures are supported:

    - `(self, value: Any, info: FieldSerializationInfo)`
    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`
    - `(value: Any, info: SerializationInfo)`
    - `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`

    Args:
        fields: Which field(s) the method should be called on.
        mode: The serialization mode.

            - `plain` means the function will be called instead of the default serialization logic,
            - `wrap` means the function will be called with an argument to optionally call the
               default serialization logic.
        return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.
        when_used: Determines the serializer will be used for serialization.
        check_fields: Whether to check that the fields actually exist on the model.

    Returns:
        The decorator function.
  summary: Decorator that enables custom field serialization
  signatures:
  - name: mode
    default: plain
    rest: false
    kind: kw-only
  - name: return_type
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - name: when_used
    default: always
    rest: false
    kind: kw-only
  - name: check_fields
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: model_serializer
  kind: function
  ns: pydantic.functional_serializers
  description: |-
    Decorator that enables custom model serialization.

    This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.

    An example would be to serialize temperature to the same temperature scale, such as degrees Celsius.

    ```python
    from typing import Literal

    from pydantic import BaseModel, model_serializer

    class TemperatureModel(BaseModel):
        unit: Literal['C', 'F']
        value: int

        @model_serializer()
        def serialize_model(self):
            if self.unit == 'F':
                return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}
            return {'unit': self.unit, 'value': self.value}

    temperature = TemperatureModel(unit='F', value=212)
    print(temperature.model_dump())
    #> {'unit': 'C', 'value': 100}
    ```

    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.

    Args:
        __f: The function to be decorated.
        mode: The serialization mode.

            - `'plain'` means the function will be called instead of the default serialization logic
            - `'wrap'` means the function will be called with an argument to optionally call the default
                serialization logic.
        when_used: Determines when this serializer should be used.
        return_type: The return type for the function. If omitted it will be inferred from the type annotation.

    Returns:
        The decorator function.
  summary: Decorator that enables custom model serialization
  signatures:
  - kind: positional
    name: __f
    default: None
    rest: false
  - name: mode
    default: plain
    rest: false
    kind: kw-only
  - name: when_used
    default: always
    rest: false
    kind: kw-only
  - name: return_type
    default: PydanticUndefined
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: overload
  kind: function
  ns: pydantic.functional_serializers
  description: |-
    Decorator for overloaded functions/methods.

    In a stub file, place two or more stub definitions for the same
    function in a row, each decorated with @overload.

    For example::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...

    In a non-stub file (i.e. a regular .py file), do the same but
    follow it with an implementation.  The implementation should *not*
    be decorated with @overload::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...
        def utf8(value):
            ...  # implementation goes here

    The overloads for a function can be retrieved at runtime using the
    get_overloads() function.
  summary: Decorator for overloaded functions/methods
  signatures:
  - kind: positional
    name: func
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.functional_validators
  kind: module
  ns: null
  description: This module contains related classes and functions for validation.
  summary: This module contains related classes and functions for validation
  signatures: null
  inherits_from: null
- name: AnyType
  kind: const
  ns: pydantic.functional_validators
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Callable
  kind: callable
  ns: pydantic.functional_validators
  description: |-
    Deprecated alias to collections.abc.Callable.

    Callable[[int], str] signifies a function that takes a single
    parameter of type int and returns a str.

    The subscription syntax must always be used with exactly two
    values: the argument list and the return type.
    The argument list must be a list of types, a ParamSpec,
    Concatenate or ellipsis. The return type must be a single type.

    There is no syntax to indicate optional or keyword arguments;
    such function types are rarely used as callback types.
  summary: Deprecated alias to collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FieldValidatorModes
  kind: callable
  ns: pydantic.functional_validators
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FreeModelBeforeValidator
  kind: class
  ns: pydantic.functional_validators
  description: A `@model_validator` decorated function signature. This is used when `mode='before'`.
  summary: A `@model_validator` decorated function signature
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: FreeModelBeforeValidator
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: FreeModelBeforeValidatorWithoutInfo
  kind: class
  ns: pydantic.functional_validators
  description: |-
    A @model_validator decorated function signature.
    This is used when `mode='before'` and the function does not have info argument.
  summary: A @model_validator decorated function signature
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: FreeModelBeforeValidatorWithoutInfo
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: Literal
  kind: callable
  ns: pydantic.functional_validators
  description: |-
    Special typing form to define literal types (a.k.a. value types).

    This form can be used to indicate to type checkers that the corresponding
    variable or function parameter has a value equivalent to the provided
    literal (or one of several literals)::

        def validate_simple(data: Any) -> Literal[True]:  # always returns True
            ...

        MODE = Literal['r', 'rb', 'w', 'wb']
        def open_helper(file: str, mode: MODE) -> str:
            ...

        open_helper('/some/path', 'r')  # Passes type check
        open_helper('/other/path', 'typo')  # Error in type checker

    Literal[...] cannot be subclassed. At runtime, an arbitrary value
    is allowed as type argument to Literal[...], but type checkers may
    impose restrictions.
  summary: Special typing form to define literal types (a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ModelAfterValidator
  kind: callable
  ns: pydantic.functional_validators
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ModelAfterValidatorWithoutInfo
  kind: callable
  ns: pydantic.functional_validators
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ModelBeforeValidator
  kind: class
  ns: pydantic.functional_validators
  description: A `@model_validator` decorated function signature. This is used when `mode='before'`.
  summary: A `@model_validator` decorated function signature
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ModelBeforeValidator
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: ModelBeforeValidatorWithoutInfo
  kind: class
  ns: pydantic.functional_validators
  description: |-
    A @model_validator decorated function signature.
    This is used when `mode='before'` and the function does not have info argument.
  summary: A @model_validator decorated function signature
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ModelBeforeValidatorWithoutInfo
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: ModelWrapValidator
  kind: class
  ns: pydantic.functional_validators
  description: A @model_validator decorated function signature. This is used when `mode='wrap'`.
  summary: A @model_validator decorated function signature
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ModelWrapValidator
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: ModelWrapValidatorHandler
  kind: class
  ns: pydantic.functional_validators
  description: '@model_validator decorated function handler argument type. This is used when `mode=''wrap''`.'
  summary: '@model_validator decorated function handler argument type'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ModelWrapValidatorHandler
  inherits_from:
  - <class 'pydantic_core.core_schema.ValidatorFunctionWrapHandler'>
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: ModelWrapValidatorWithoutInfo
  kind: class
  ns: pydantic.functional_validators
  description: |-
    A @model_validator decorated function signature.
    This is used when `mode='wrap'` and the function does not have info argument.
  summary: A @model_validator decorated function signature
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ModelWrapValidatorWithoutInfo
  inherits_from:
  - <class 'typing.Protocol'>
  - <class 'typing.Generic'>
- name: TYPE_CHECKING
  kind: const
  ns: pydantic.functional_validators
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: TypeAlias
  kind: callable
  ns: pydantic.functional_validators
  description: |-
    Special form for marking type aliases.

    Use TypeAlias to indicate that an assignment should
    be recognized as a proper type alias definition by type
    checkers.

    For example::

        Predicate: TypeAlias = Callable[..., bool]

    It's invalid when used anywhere except as in the example above.
  summary: Special form for marking type aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Union
  kind: callable
  ns: pydantic.functional_validators
  description: |-
    Union type; Union[X, Y] means either X or Y.

    On Python 3.10 and higher, the | operator
    can also be used to denote unions;
    X | Y means the same thing to the type checker as Union[X, Y].

    To define a union, use e.g. Union[int, str]. Details:
    - The arguments must be types and there must be at least one.
    - None as an argument is a special case and is replaced by
      type(None).
    - Unions of unions are flattened, e.g.::

        assert Union[Union[int, str], float] == Union[int, str, float]

    - Unions of a single argument vanish, e.g.::

        assert Union[int] == int  # The constructor actually returns int

    - Redundant arguments are skipped, e.g.::

        assert Union[int, str, int] == Union[int, str]

    - When comparing unions, the argument order is ignored, e.g.::

        assert Union[int, str] == Union[str, int]

    - You cannot subclass or instantiate a union.
    - You can use Optional[X] as a shorthand for Union[X, None].
  summary: Union type; Union[X, Y] means either X or Y
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: cast
  kind: function
  ns: pydantic.functional_validators
  description: |-
    Cast a value to a type.

    This returns the value unchanged.  To the type checker this
    signals that the return value has the designated type, but at
    runtime we intentionally don't check anything (we want this
    to be as fast as possible).
  summary: Cast a value to a type
  signatures:
  - kind: positional
    name: typ
    default: null
    rest: false
  - kind: positional
    name: val
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: field_validator
  kind: function
  ns: pydantic.functional_validators
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#field-validators

    Decorate methods on the class indicating that they should be used to validate fields.

    Example usage:
    ```py
    from typing import Any

    from pydantic import (
        BaseModel,
        ValidationError,
        field_validator,
    )

    class Model(BaseModel):
        a: str

        @field_validator('a')
        @classmethod
        def ensure_foobar(cls, v: Any):
            if 'foobar' not in v:
                raise ValueError('"foobar" not found in a')
            return v

    print(repr(Model(a='this is foobar good')))
    #> Model(a='this is foobar good')

    try:
        Model(a='snap')
    except ValidationError as exc_info:
        print(exc_info)
        '''
        1 validation error for Model
        a
          Value error, "foobar" not found in a [type=value_error, input_value='snap', input_type=str]
        '''
    ```

    For more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).

    Args:
        __field: The first field the `field_validator` should be called on; this is separate
            from `fields` to ensure an error is raised if you don't pass at least one.
        *fields: Additional field(s) the `field_validator` should be called on.
        mode: Specifies whether to validate the fields before or after validation.
        check_fields: Whether to check that the fields actually exist on the model.

    Returns:
        A decorator that can be used to decorate a function to be used as a field_validator.

    Raises:
        PydanticUserError:
            - If `@field_validator` is used bare (with no fields).
            - If the args passed to `@field_validator` as fields are not strings.
            - If `@field_validator` applied to instance methods.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __field
    default: null
    rest: false
  - name: mode
    default: after
    rest: false
    kind: kw-only
  - name: check_fields
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: model_validator
  kind: function
  ns: pydantic.functional_validators
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validators/#model-validators

    Decorate model methods for validation purposes.

    Example usage:
    ```py
    from typing_extensions import Self

    from pydantic import BaseModel, ValidationError, model_validator

    class Square(BaseModel):
        width: float
        height: float

        @model_validator(mode='after')
        def verify_square(self) -> Self:
            if self.width != self.height:
                raise ValueError('width and height do not match')
            return self

    s = Square(width=1, height=1)
    print(repr(s))
    #> Square(width=1.0, height=1.0)

    try:
        Square(width=1, height=2)
    except ValidationError as e:
        print(e)
        '''
        1 validation error for Square
          Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]
        '''
    ```

    For more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).

    Args:
        mode: A required string literal that specifies the validation mode.
            It can be one of the following: 'wrap', 'before', or 'after'.

    Returns:
        A decorator that can be used to decorate a function to be used as a model validator.
  summary: 'Usage docs: https://docs'
  signatures:
  - name: mode
    default: null
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: overload
  kind: function
  ns: pydantic.functional_validators
  description: |-
    Decorator for overloaded functions/methods.

    In a stub file, place two or more stub definitions for the same
    function in a row, each decorated with @overload.

    For example::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...

    In a non-stub file (i.e. a regular .py file), do the same but
    follow it with an implementation.  The implementation should *not*
    be decorated with @overload::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...
        def utf8(value):
            ...  # implementation goes here

    The overloads for a function can be retrieved at runtime using the
    get_overloads() function.
  summary: Decorator for overloaded functions/methods
  signatures:
  - kind: positional
    name: func
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.generics
  kind: module
  ns: null
  description: The `generics` module is a backport module from V1.
  summary: The `generics` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.generics
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.json
  kind: module
  ns: null
  description: The `json` module is a backport module from V1.
  summary: The `json` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.json
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.json_schema
  kind: module
  ns: null
  description: |-
    Usage docs: https://docs.pydantic.dev/2.5/concepts/json_schema/

    The `json_schema` module contains classes and functions to allow the way [JSON Schema](https://json-schema.org/)
    is generated to be customized.

    In general you shouldn't need to use this module directly; instead, you can
    [`BaseModel.model_json_schema`][pydantic.BaseModel.model_json_schema] and
    [`TypeAdapter.json_schema`][pydantic.TypeAdapter.json_schema].
  summary: 'Usage docs: https://docs'
  signatures: null
  inherits_from: null
- name: AnyType
  kind: const
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Callable
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Deprecated alias to collections.abc.Callable.

    Callable[[int], str] signifies a function that takes a single
    parameter of type int and returns a str.

    The subscription syntax must always be used with exactly two
    values: the argument list and the return type.
    The argument list must be a list of types, a ParamSpec,
    Concatenate or ellipsis. The return type must be a single type.

    There is no syntax to indicate optional or keyword arguments;
    such function types are rarely used as callback types.
  summary: Deprecated alias to collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ComputedField
  kind: class
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from:
  - <class 'dict'>
- name: ComputedField.clear
  kind: callable
  ns: pydantic.json_schema
  description: D.clear() -> None.  Remove all items from D.
  summary: D
  signatures: null
  inherits_from: null
- name: ComputedField.copy
  kind: callable
  ns: pydantic.json_schema
  description: D.copy() -> a shallow copy of D
  summary: D
  signatures: null
  inherits_from: null
- name: ComputedField.get
  kind: callable
  ns: pydantic.json_schema
  description: Return the value for key if key is in the dictionary, else default.
  summary: Return the value for key if key is in the dictionary, else default
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ComputedField.items
  kind: callable
  ns: pydantic.json_schema
  description: D.items() -> a set-like object providing a view on D's items
  summary: D
  signatures: null
  inherits_from: null
- name: ComputedField.keys
  kind: callable
  ns: pydantic.json_schema
  description: D.keys() -> a set-like object providing a view on D's keys
  summary: D
  signatures: null
  inherits_from: null
- name: ComputedField.pop
  kind: callable
  ns: pydantic.json_schema
  description: |-
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

    If the key is not found, return the default if given; otherwise,
    raise a KeyError.
  summary: D
  signatures: null
  inherits_from: null
- name: ComputedField.popitem
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Remove and return a (key, value) pair as a 2-tuple.

    Pairs are returned in LIFO (last-in, first-out) order.
    Raises KeyError if the dict is empty.
  summary: Remove and return a (key, value) pair as a 2-tuple
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ComputedField.setdefault
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Insert key with a value of default if key is not in the dictionary.

    Return the value for key if key is in the dictionary, else default.
  summary: Insert key with a value of default if key is not in the dictionary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ComputedField.update
  kind: callable
  ns: pydantic.json_schema
  description: |-
    D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
    If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
    In either case, this is followed by: for k in F:  D[k] = F[k]
  summary: D
  signatures: null
  inherits_from: null
- name: ComputedField.values
  kind: callable
  ns: pydantic.json_schema
  description: D.values() -> an object providing a view on D's values
  summary: D
  signatures: null
  inherits_from: null
- name: CoreModeRef
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CoreRef
  kind: callable
  ns: pydantic.json_schema
  description: |-
    NewType creates simple unique types with almost zero runtime overhead.

    NewType(name, tp) is considered a subtype of tp
    by static type checkers. At runtime, NewType(name, tp) returns
    a dummy callable that simply returns its argument.

    Usage::

        UserId = NewType('UserId', int)

        def name_by_id(user_id: UserId) -> str:
            ...

        UserId('user')          # Fails type check

        name_by_id(42)          # Fails type check
        name_by_id(UserId(42))  # OK

        num = UserId(5) + 1     # type: int
  summary: NewType creates simple unique types with almost zero runtime overhead
  signatures:
  - kind: positional
    name: x
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CoreSchema
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CoreSchemaOrFieldType
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Counter
  kind: callable
  ns: pydantic.json_schema
  description: A generic version of collections.Counter.
  summary: A generic version of collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DEFAULT_REF_TEMPLATE
  kind: const
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: DefsRef
  kind: callable
  ns: pydantic.json_schema
  description: |-
    NewType creates simple unique types with almost zero runtime overhead.

    NewType(name, tp) is considered a subtype of tp
    by static type checkers. At runtime, NewType(name, tp) returns
    a dummy callable that simply returns its argument.

    Usage::

        UserId = NewType('UserId', int)

        def name_by_id(user_id: UserId) -> str:
            ...

        UserId('user')          # Fails type check

        name_by_id(42)          # Fails type check
        name_by_id(UserId(42))  # OK

        num = UserId(5) + 1     # type: int
  summary: NewType creates simple unique types with almost zero runtime overhead
  signatures:
  - kind: positional
    name: x
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Dict
  kind: callable
  ns: pydantic.json_schema
  description: A generic version of dict.
  summary: A generic version of dict
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Enum
  kind: class
  ns: pydantic.json_schema
  description: |-
    Create a collection of name/value pairs.

    Example enumeration:

    >>> class Color(Enum):
    ...     RED = 1
    ...     BLUE = 2
    ...     GREEN = 3

    Access them by:

    - attribute access::

    >>> Color.RED
    <Color.RED: 1>

    - value lookup:

    >>> Color(1)
    <Color.RED: 1>

    - name lookup:

    >>> Color['RED']
    <Color.RED: 1>

    Enumerations can be iterated over, and know how many members they have:

    >>> len(Color)
    3

    >>> list(Color)
    [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

    Methods can be added to enumerations, and members can have their own
    attributes -- see the documentation for details.
  summary: Create a collection of name/value pairs
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: names
    default: None
    rest: false
  - name: module
    default: None
    rest: false
    kind: kw-only
  - name: qualname
    default: None
    rest: false
    kind: kw-only
  - name: type
    default: None
    rest: false
    kind: kw-only
  - name: start
    default: '1'
    rest: false
    kind: kw-only
  - name: boundary
    default: None
    rest: false
    kind: kw-only
  - type: Enum
  inherits_from: null
- name: Examples
  kind: class
  ns: pydantic.json_schema
  description: |-
    Add examples to a JSON schema.

    Examples should be a map of example names (strings)
    to example values (any valid JSON).

    If `mode` is set this will only apply to that schema generation mode,
    allowing you to add different examples for validation and serialization.
  summary: Add examples to a JSON schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: examples
    default: null
    rest: false
  - kind: positional
    name: mode
    default: None
    rest: false
  - type: Examples
  inherits_from: null
- name: Examples.examples
  kind: property
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Examples.mode
  kind: property
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema
  kind: class
  ns: pydantic.json_schema
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json_schema/#customizing-the-json-schema-generation-process

    A class for generating JSON schemas.

    This class generates JSON schemas based on configured parameters. The default schema dialect
    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema).
    The class uses `by_alias` to configure how fields with
    multiple names are handled and `ref_template` to format reference names.

    Attributes:
        schema_dialect: The JSON schema dialect used to generate the schema. See
            [Declaring a Dialect](https://json-schema.org/understanding-json-schema/reference/schema.html#id4)
            in the JSON Schema documentation for more information about dialects.
        ignored_warning_kinds: Warnings to ignore when generating the schema. `self.render_warning_message` will
            do nothing if its argument `kind` is in `ignored_warning_kinds`;
            this value can be modified on subclasses to easily control which warnings are emitted.
        by_alias: Whether to use field aliases when generating the schema.
        ref_template: The format string used when generating reference names.
        core_to_json_refs: A mapping of core refs to JSON refs.
        core_to_defs_refs: A mapping of core refs to definition refs.
        defs_to_core_refs: A mapping of definition refs to core refs.
        json_to_defs_refs: A mapping of JSON refs to definition refs.
        definitions: Definitions in the schema.

    Args:
        by_alias: Whether to use field aliases in the generated schemas.
        ref_template: The format string to use when generating reference names.

    Raises:
        JsonSchemaError: If the instance of the class is inadvertently re-used after generating a schema.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/$defs/{model}'
    rest: false
  - type: GenerateJsonSchema
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping
  kind: class
  ns: pydantic.json_schema
  description: |-
    This class just contains mappings from core_schema attribute names to the corresponding
    JSON schema attribute names. While I suspect it is unlikely to be necessary, you can in
    principle override this class in a subclass of GenerateJsonSchema (by inheriting from
    GenerateJsonSchema.ValidationsMapping) to change these mappings.
  summary: This class just contains mappings from core_schema attribute names to the corresponding
  signatures:
  - type: ValidationsMapping
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping.array
  kind: property
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping.bytes
  kind: property
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping.date
  kind: property
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping.numeric
  kind: property
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping.object
  kind: property
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.ValidationsMapping.string
  kind: property
  ns: pydantic.json_schema
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.any_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches any value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches any value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.arguments_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a function's arguments.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a function's arguments
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.bool_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a bool value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a bool value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.build_schema_type_to_method
  kind: method
  ns: pydantic.json_schema
  description: |-
    Builds a dictionary mapping fields to methods for generating JSON schemas.

    Returns:
        A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method.

    Raises:
        TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.
  summary: Builds a dictionary mapping fields to methods for generating JSON schemas
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.bytes_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a bytes value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a bytes value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.call_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a function call.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a function call
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.callable_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a callable value.

    Unless overridden in a subclass, this raises an error.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a callable value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.chain_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a core_schema.ChainSchema.

    When generating a schema for validation, we return the validation JSON schema for the first step in the chain.
    For serialization, we return the serialization JSON schema for the last step in the chain.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a core_schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.computed_field_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a computed field.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a computed field
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.custom_error_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a custom error.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a custom error
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.dataclass_args_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.dataclass_field_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a dataclass field.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a dataclass field
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.dataclass_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a dataclass.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a dataclass
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.date_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a date value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a date value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.datetime_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a datetime value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a datetime value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.decimal_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a decimal value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a decimal value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.default_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema with a default value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema with a default value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.definition_ref_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that references a definition.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that references a definition
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.definitions_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a JSON object with definitions.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a JSON object with definitions
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.dict_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a dict schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a dict schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.emit_warning
  kind: method
  ns: pydantic.json_schema
  description: This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.
  summary: This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: kind
    default: null
    rest: false
  - kind: positional
    name: detail
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.encode_default
  kind: method
  ns: pydantic.json_schema
  description: |-
    Encode a default value to a JSON-serializable value.

    This is used to encode default values for fields in the generated JSON schema.

    Args:
        dft: The default value to encode.

    Returns:
        The encoded default value.
  summary: Encode a default value to a JSON-serializable value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: dft
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.field_is_present
  kind: method
  ns: pydantic.json_schema
  description: |-
    Whether the field should be included in the generated JSON schema.

    Args:
        field: The schema for the field itself.

    Returns:
        `True` if the field should be included in the generated JSON schema, `False` otherwise.
  summary: Whether the field should be included in the generated JSON schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.field_is_required
  kind: method
  ns: pydantic.json_schema
  description: |-
    Whether the field should be marked as required in the generated JSON schema.
    (Note that this is irrelevant if the field is not present in the JSON schema.).

    Args:
        field: The schema for the field itself.
        total: Only applies to `TypedDictField`s.
            Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't
            explicitly specify `required=False` are required.

    Returns:
        `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.
  summary: Whether the field should be marked as required in the generated JSON schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: total
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.field_title_should_be_set
  kind: method
  ns: pydantic.json_schema
  description: |-
    Returns true if a field with the given schema should have a title set based on the field name.

    Intuitively, we want this to return true for schemas that wouldn't otherwise provide their own title
    (e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).

    Args:
        schema: The schema to check.

    Returns:
        `True` if the field should have a title set, `False` otherwise.
  summary: Returns true if a field with the given schema should have a title set based on the field name
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.float_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a float value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a float value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.frozenset_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a frozenset schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a frozenset schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.function_after_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a function-after schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a function-after schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.function_before_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a function-before schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a function-before schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.function_plain_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a function-plain schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a function-plain schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.function_wrap_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a function-wrap schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a function-wrap schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.generate
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema for a specified schema in a specified mode.

    Args:
        schema: A Pydantic model.
        mode: The mode in which to generate the schema. Defaults to 'validation'.

    Returns:
        A JSON schema representing the specified schema.

    Raises:
        PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema.
  summary: Generates a JSON schema for a specified schema in a specified mode
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: mode
    default: validation
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.generate_definitions
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a
    mapping that links the input keys to the definition references.

    Args:
        inputs: A sequence of tuples, where:

            - The first element is a JSON schema key type.
            - The second element is the JSON mode: either 'validation' or 'serialization'.
            - The third element is a core schema.

    Returns:
        A tuple where:

            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and
                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have
                JsonRef references to definitions that are defined in the second returned element.)
            - The second element is a dictionary whose keys are definition references for the JSON schemas
                from the first returned element, and whose values are the actual JSON schema definitions.

    Raises:
        PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema.
  summary: Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: inputs
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.generate_inner
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema for a given core schema.

    Args:
        schema: The given core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema for a given core schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.generator_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Returns a JSON schema that represents the provided GeneratorSchema.

    Args:
        schema: The schema.

    Returns:
        The generated JSON schema.
  summary: Returns a JSON schema that represents the provided GeneratorSchema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_argument_name
  kind: method
  ns: pydantic.json_schema
  description: |-
    Retrieves the name of an argument.

    Args:
        argument: The core schema.

    Returns:
        The name of the argument.
  summary: Retrieves the name of an argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: argument
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_cache_defs_ref_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    This method wraps the get_defs_ref method with some cache-lookup/population logic,
    and returns both the produced defs_ref and the JSON schema that will refer to the right definition.

    Args:
        core_ref: The core reference to get the definitions reference for.

    Returns:
        A tuple of the definitions reference and the JSON schema that will refer to it.
  summary: This method wraps the get_defs_ref method with some cache-lookup/population logic,
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: core_ref
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_defs_ref
  kind: method
  ns: pydantic.json_schema
  description: |-
    Override this method to change the way that definitions keys are generated from a core reference.

    Args:
        core_mode_ref: The core reference.

    Returns:
        The definitions key.
  summary: Override this method to change the way that definitions keys are generated from a core reference
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: core_mode_ref
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_flattened_anyof
  kind: method
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schemas
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_json_ref_counts
  kind: method
  ns: pydantic.json_schema
  description: Get all values corresponding to the key '$ref' anywhere in the json_schema.
  summary: Get all values corresponding to the key '$ref' anywhere in the json_schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: json_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_schema_from_definitions
  kind: method
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: json_ref
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.get_title_from_name
  kind: method
  ns: pydantic.json_schema
  description: |-
    Retrieves a title from a name.

    Args:
        name: The name to retrieve a title from.

    Returns:
        The title.
  summary: Retrieves a title from a name
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.handle_invalid_for_json_schema
  kind: method
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: error_info
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.handle_ref_overrides
  kind: method
  ns: pydantic.json_schema
  description: |-
    It is not valid for a schema with a top-level $ref to have sibling keys.

    During our own schema generation, we treat sibling keys as overrides to the referenced schema,
    but this is not how the official JSON schema spec works.

    Because of this, we first remove any sibling keys that are redundant with the referenced schema, then if
    any remain, we transform the schema from a top-level '$ref' to use allOf to move the $ref out of the top level.
    (See bottom of https://swagger.io/docs/specification/using-ref/ for a reference about this behavior)
  summary: It is not valid for a schema with a top-level $ref to have sibling keys
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: json_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.ignored_warning_kinds
  kind: property
  ns: pydantic.json_schema
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.int_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches an int value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches an int value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.is_instance_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Handles JSON schema generation for a core schema that checks if a value is an instance of a class.

    Unless overridden in a subclass, this raises an error.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Handles JSON schema generation for a core schema that checks if a value is an instance of a class
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.is_subclass_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.

    For backwards compatibility with v1, this does not raise an error, but can be overridden to change this.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Handles JSON schema generation for a core schema that checks if a value is a subclass of a class
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.json_or_python_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the
    Python schema.

    The JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override
    this method.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.json_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a JSON object.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a JSON object
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.kw_arguments_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a function's keyword arguments.

    Args:
        arguments: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a function's keyword arguments
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: arguments
    default: null
    rest: false
  - kind: positional
    name: var_kwargs_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.lax_or_strict_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that allows values matching either the lax schema or the
    strict schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that allows values matching either the lax schema or the
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.list_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Returns a schema that matches a list schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Returns a schema that matches a list schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.literal_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a literal value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a literal value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.mode
  kind: property
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.model_field_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a model field.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a model field
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.model_fields_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a model's fields.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a model's fields
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.model_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a model.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a model
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.multi_host_url_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.none_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches `None`.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches `None`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.normalize_name
  kind: method
  ns: pydantic.json_schema
  description: |-
    Normalizes a name to be used as a key in a dictionary.

    Args:
        name: The name to normalize.

    Returns:
        The normalized name.
  summary: Normalizes a name to be used as a key in a dictionary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.nullable_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that allows null values.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that allows null values
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.p_arguments_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a function's positional arguments.

    Args:
        arguments: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a function's positional arguments
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: arguments
    default: null
    rest: false
  - kind: positional
    name: var_args_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.render_warning_message
  kind: method
  ns: pydantic.json_schema
  description: |-
    This method is responsible for ignoring warnings as desired, and for formatting the warning messages.

    You can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema
    to modify what warnings are generated. If you want more control, you can override this method;
    just return None in situations where you don't want warnings to be emitted.

    Args:
        kind: The kind of warning to render. It can be one of the following:

            - 'skipped-choice': A choice field was skipped because it had no valid choices.
            - 'non-serializable-default': A default value was skipped because it was not JSON-serializable.
        detail: A string with additional details about the warning.

    Returns:
        The formatted warning message, or `None` if no warning should be emitted.
  summary: This method is responsible for ignoring warnings as desired, and for formatting the warning messages
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: kind
    default: null
    rest: false
  - kind: positional
    name: detail
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.resolve_schema_to_update
  kind: method
  ns: pydantic.json_schema
  description: |-
    Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.

    Args:
        json_schema: The schema to resolve.

    Returns:
        The resolved schema.
  summary: Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: json_schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.schema_dialect
  kind: property
  ns: pydantic.json_schema
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: GenerateJsonSchema.ser_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a serialized object.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a serialized object
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.set_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a set schema.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a set schema
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.str_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a string value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a string value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.tagged_union_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where
    the schemas are tagged with a discriminator field that indicates which schema should be used to validate
    the value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.time_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a time value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a time value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.timedelta_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a timedelta value.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a timedelta value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.tuple_positional_schema
  kind: method
  ns: pydantic.json_schema
  description: Replaced by `tuple_schema`.
  summary: Replaced by `tuple_schema`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.tuple_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a tuple schema e.g. `Tuple[int,
    str, bool]` or `Tuple[int, ...]`.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a tuple schema e
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.tuple_variable_schema
  kind: method
  ns: pydantic.json_schema
  description: Replaced by `tuple_schema`.
  summary: Replaced by `tuple_schema`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.typed_dict_field_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a typed dict field.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a typed dict field
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.typed_dict_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a typed dict.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a typed dict
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.union_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that allows values matching any of the given schemas.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that allows values matching any of the given schemas
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.update_with_validations
  kind: method
  ns: pydantic.json_schema
  description: |-
    Update the json_schema with the corresponding validations specified in the core_schema,
    using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.

    Args:
        json_schema: The JSON schema to update.
        core_schema: The core schema to get the validations from.
        mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.
  summary: Update the json_schema with the corresponding validations specified in the core_schema,
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: json_schema
    default: null
    rest: false
  - kind: positional
    name: core_schema
    default: null
    rest: false
  - kind: positional
    name: mapping
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.url_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a schema that defines a URL.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a schema that defines a URL
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: GenerateJsonSchema.uuid_schema
  kind: method
  ns: pydantic.json_schema
  description: |-
    Generates a JSON schema that matches a UUID.

    Args:
        schema: The core schema.

    Returns:
        The generated JSON schema.
  summary: Generates a JSON schema that matches a UUID
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Hashable
  kind: callable
  ns: pydantic.json_schema
  description: A generic version of collections.abc.Hashable.
  summary: A generic version of collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Iterable
  kind: callable
  ns: pydantic.json_schema
  description: A generic version of collections.abc.Iterable.
  summary: A generic version of collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonDict
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonRef
  kind: callable
  ns: pydantic.json_schema
  description: |-
    NewType creates simple unique types with almost zero runtime overhead.

    NewType(name, tp) is considered a subtype of tp
    by static type checkers. At runtime, NewType(name, tp) returns
    a dummy callable that simply returns its argument.

    Usage::

        UserId = NewType('UserId', int)

        def name_by_id(user_id: UserId) -> str:
            ...

        UserId('user')          # Fails type check

        name_by_id(42)          # Fails type check
        name_by_id(UserId(42))  # OK

        num = UserId(5) + 1     # type: int
  summary: NewType creates simple unique types with almost zero runtime overhead
  signatures:
  - kind: positional
    name: x
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaExtraCallable
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaKeyT
  kind: const
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: JsonSchemaMode
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaValue
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaWarningKind
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonValue
  kind: callable
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Literal
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Special typing form to define literal types (a.k.a. value types).

    This form can be used to indicate to type checkers that the corresponding
    variable or function parameter has a value equivalent to the provided
    literal (or one of several literals)::

        def validate_simple(data: Any) -> Literal[True]:  # always returns True
            ...

        MODE = Literal['r', 'rb', 'w', 'wb']
        def open_helper(file: str, mode: MODE) -> str:
            ...

        open_helper('/some/path', 'r')  # Passes type check
        open_helper('/other/path', 'typo')  # Error in type checker

    Literal[...] cannot be subclassed. At runtime, an arbitrary value
    is allowed as type argument to Literal[...], but type checkers may
    impose restrictions.
  summary: Special typing form to define literal types (a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NewType
  kind: class
  ns: pydantic.json_schema
  description: |-
    NewType creates simple unique types with almost zero runtime overhead.

    NewType(name, tp) is considered a subtype of tp
    by static type checkers. At runtime, NewType(name, tp) returns
    a dummy callable that simply returns its argument.

    Usage::

        UserId = NewType('UserId', int)

        def name_by_id(user_id: UserId) -> str:
            ...

        UserId('user')          # Fails type check

        name_by_id(42)          # Fails type check
        name_by_id(UserId(42))  # OK

        num = UserId(5) + 1     # type: int
  summary: NewType creates simple unique types with almost zero runtime overhead
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - kind: positional
    name: tp
    default: null
    rest: false
  - type: NewType
  inherits_from: null
- name: PydanticJsonSchemaWarning
  kind: class
  ns: pydantic.json_schema
  description: |-
    This class is used to emit warnings produced during JSON schema generation.
    See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.GenerateJsonSchema.emit_warning] and
    [`GenerateJsonSchema.render_warning_message`][pydantic.json_schema.GenerateJsonSchema.render_warning_message]
    methods for more details; these can be overridden to control warning behavior.
  summary: This class is used to emit warnings produced during JSON schema generation
  signatures: null
  inherits_from:
  - <class 'UserWarning'>
  - <class 'Warning'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticJsonSchemaWarning.add_note
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticJsonSchemaWarning.args
  kind: property
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticJsonSchemaWarning.with_traceback
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticOmit
  kind: class
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures:
  - type: PydanticOmit
  inherits_from:
  - <class 'Exception'>
  - <class 'BaseException'>
- name: PydanticOmit.add_note
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: PydanticOmit.args
  kind: property
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PydanticOmit.with_traceback
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: Sequence
  kind: callable
  ns: pydantic.json_schema
  description: A generic version of collections.abc.Sequence.
  summary: A generic version of collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SkipJsonSchema
  kind: class
  ns: pydantic.json_schema
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/json_schema/#skipjsonschema-annotation

    Add this as an annotation on a field to skip generating a JSON schema for that field.

    Example:
        ```py
        from typing import Union

        from pydantic import BaseModel
        from pydantic.json_schema import SkipJsonSchema

        from pprint import pprint


        class Model(BaseModel):
            a: Union[int, None] = None  # (1)!
            b: Union[int, SkipJsonSchema[None]] = None  # (2)!
            c: SkipJsonSchema[Union[int, None]] = None  # (3)!


        pprint(Model.model_json_schema())
        '''
        {
            'properties': {
                'a': {
                    'anyOf': [
                        {'type': 'integer'},
                        {'type': 'null'}
                    ],
                    'default': None,
                    'title': 'A'
                },
                'b': {
                    'default': None,
                    'title': 'B',
                    'type': 'integer'
                }
            },
            'title': 'Model',
            'type': 'object'
        }
        '''
        ```

        1. The integer and null types are both included in the schema for `a`.
        2. The integer type is the only type included in the schema for `b`.
        3. The entirety of the `c` field is omitted from the schema.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: SkipJsonSchema
  inherits_from: null
- name: TYPE_CHECKING
  kind: const
  ns: pydantic.json_schema
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Tuple
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Deprecated alias to builtins.tuple.

    Tuple[X, Y] is the cross-product type of X and Y.

    Example: Tuple[T1, T2] is a tuple of two elements corresponding
    to type variables T1 and T2.  Tuple[int, float, str] is a tuple
    of an int, a float and a string.

    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
  summary: Deprecated alias to builtins
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: TypeAlias
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Special form for marking type aliases.

    Use TypeAlias to indicate that an assignment should
    be recognized as a proper type alias definition by type
    checkers.

    For example::

        Predicate: TypeAlias = Callable[..., bool]

    It's invalid when used anywhere except as in the example above.
  summary: Special form for marking type aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Union
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Union type; Union[X, Y] means either X or Y.

    On Python 3.10 and higher, the | operator
    can also be used to denote unions;
    X | Y means the same thing to the type checker as Union[X, Y].

    To define a union, use e.g. Union[int, str]. Details:
    - The arguments must be types and there must be at least one.
    - None as an argument is a special case and is replaced by
      type(None).
    - Unions of unions are flattened, e.g.::

        assert Union[Union[int, str], float] == Union[int, str, float]

    - Unions of a single argument vanish, e.g.::

        assert Union[int] == int  # The constructor actually returns int

    - Redundant arguments are skipped, e.g.::

        assert Union[int, str, int] == Union[int, str]

    - When comparing unions, the argument order is ignored, e.g.::

        assert Union[int, str] == Union[str, int]

    - You cannot subclass or instantiate a union.
    - You can use Optional[X] as a shorthand for Union[X, None].
  summary: Union type; Union[X, Y] means either X or Y
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: assert_never
  kind: function
  ns: pydantic.json_schema
  description: |-
    Statically assert that a line of code is unreachable.

    Example::

        def int_or_str(arg: int | str) -> None:
            match arg:
                case int():
                    print("It's an int")
                case str():
                    print("It's a str")
                case _:
                    assert_never(arg)

    If a type checker finds that a call to assert_never() is
    reachable, it will emit an error.

    At runtime, this throws an exception when called.
  summary: Statically assert that a line of code is unreachable
  signatures:
  - kind: positional
    name: arg
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: cast
  kind: function
  ns: pydantic.json_schema
  description: |-
    Cast a value to a type.

    This returns the value unchanged.  To the type checker this
    signals that the return value has the designated type, but at
    runtime we intentionally don't check anything (we want this
    to be as fast as possible).
  summary: Cast a value to a type
  signatures:
  - kind: positional
    name: typ
    default: null
    rest: false
  - kind: positional
    name: val
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: deepcopy
  kind: function
  ns: pydantic.json_schema
  description: |-
    Deep copy operation on arbitrary Python objects.

    See the module's __doc__ string for more info.
  summary: Deep copy operation on arbitrary Python objects
  signatures:
  - kind: positional
    name: x
    default: null
    rest: false
  - kind: positional
    name: memo
    default: None
    rest: false
  - kind: positional
    name: _nil
    default: '[]'
    rest: false
  - type: '?'
  inherits_from: null
- name: defaultdict
  kind: class
  ns: pydantic.json_schema
  description: |-
    defaultdict(default_factory=None, /, [...]) --> dict with default factory

    The default factory is called without arguments to produce
    a new value when a key is not present, in __getitem__ only.
    A defaultdict compares equal to a dict with the same items.
    All remaining arguments are treated the same as if they were
    passed to the dict constructor, including keyword arguments.
  summary: defaultdict(default_factory=None, /, [
  signatures: null
  inherits_from:
  - <class 'dict'>
- name: defaultdict.clear
  kind: callable
  ns: pydantic.json_schema
  description: D.clear() -> None.  Remove all items from D.
  summary: D
  signatures: null
  inherits_from: null
- name: defaultdict.copy
  kind: callable
  ns: pydantic.json_schema
  description: D.copy() -> a shallow copy of D.
  summary: D
  signatures: null
  inherits_from: null
- name: defaultdict.default_factory
  kind: property
  ns: pydantic.json_schema
  description: Factory for default value called by __missing__().
  summary: Factory for default value called by __missing__()
  signatures: null
  inherits_from: null
- name: defaultdict.get
  kind: callable
  ns: pydantic.json_schema
  description: Return the value for key if key is in the dictionary, else default.
  summary: Return the value for key if key is in the dictionary, else default
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: defaultdict.items
  kind: callable
  ns: pydantic.json_schema
  description: D.items() -> a set-like object providing a view on D's items
  summary: D
  signatures: null
  inherits_from: null
- name: defaultdict.keys
  kind: callable
  ns: pydantic.json_schema
  description: D.keys() -> a set-like object providing a view on D's keys
  summary: D
  signatures: null
  inherits_from: null
- name: defaultdict.pop
  kind: callable
  ns: pydantic.json_schema
  description: |-
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

    If the key is not found, return the default if given; otherwise,
    raise a KeyError.
  summary: D
  signatures: null
  inherits_from: null
- name: defaultdict.popitem
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Remove and return a (key, value) pair as a 2-tuple.

    Pairs are returned in LIFO (last-in, first-out) order.
    Raises KeyError if the dict is empty.
  summary: Remove and return a (key, value) pair as a 2-tuple
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: defaultdict.setdefault
  kind: callable
  ns: pydantic.json_schema
  description: |-
    Insert key with a value of default if key is not in the dictionary.

    Return the value for key if key is in the dictionary, else default.
  summary: Insert key with a value of default if key is not in the dictionary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: defaultdict.update
  kind: callable
  ns: pydantic.json_schema
  description: |-
    D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
    If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
    In either case, this is followed by: for k in F:  D[k] = F[k]
  summary: D
  signatures: null
  inherits_from: null
- name: defaultdict.values
  kind: callable
  ns: pydantic.json_schema
  description: D.values() -> an object providing a view on D's values
  summary: D
  signatures: null
  inherits_from: null
- name: final
  kind: function
  ns: pydantic.json_schema
  description: |-
    Decorator to indicate final methods and final classes.

    Use this decorator to indicate to type checkers that the decorated
    method cannot be overridden, and decorated class cannot be subclassed.

    For example::

        class Base:
            @final
            def done(self) -> None:
                ...
        class Sub(Base):
            def done(self) -> None:  # Error reported by type checker
                ...

        @final
        class Leaf:
            ...
        class Other(Leaf):  # Error reported by type checker
            ...

    There is no runtime checking of these properties. The decorator
    attempts to set the ``__final__`` attribute to ``True`` on the decorated
    object to allow runtime introspection.
  summary: Decorator to indicate final methods and final classes
  signatures:
  - kind: positional
    name: f
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: is_dataclass
  kind: function
  ns: pydantic.json_schema
  description: |-
    Returns True if obj is a dataclass or an instance of a
    dataclass.
  summary: Returns True if obj is a dataclass or an instance of a
  signatures:
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: model_json_schema
  kind: function
  ns: pydantic.json_schema
  description: |-
    Utility function to generate a JSON Schema for a model.

    Args:
        cls: The model class to generate a JSON Schema for.
        by_alias: If `True` (the default), fields will be serialized according to their alias.
            If `False`, fields will be serialized according to their attribute name.
        ref_template: The template to use for generating JSON Schema references.
        schema_generator: The class to use for generating the JSON Schema.
        mode: The mode to use for generating the JSON Schema. It can be one of the following:

            - 'validation': Generate a JSON Schema for validating data.
            - 'serialization': Generate a JSON Schema for serializing data.

    Returns:
        The generated JSON Schema.
  summary: Utility function to generate a JSON Schema for a model
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/$defs/{model}'
    rest: false
  - kind: positional
    name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
  - kind: positional
    name: mode
    default: validation
    rest: false
  - type: '?'
  inherits_from: null
- name: models_json_schema
  kind: function
  ns: pydantic.json_schema
  description: |-
    Utility function to generate a JSON Schema for multiple models.

    Args:
        models: A sequence of tuples of the form (model, mode).
        by_alias: Whether field aliases should be used as keys in the generated JSON Schema.
        title: The title of the generated JSON Schema.
        description: The description of the generated JSON Schema.
        ref_template: The reference template to use for generating JSON Schema references.
        schema_generator: The schema generator to use for generating the JSON Schema.

    Returns:
        A tuple where:
            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and
                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have
                JsonRef references to definitions that are defined in the second returned element.)
            - The second element is a JSON schema containing all definitions referenced in the first returned
                    element, along with the optional title and description keys.
  summary: Utility function to generate a JSON Schema for multiple models
  signatures:
  - kind: positional
    name: models
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: description
    default: None
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/$defs/{model}'
    rest: false
    kind: kw-only
  - name: schema_generator
    default: <class 'pydantic.json_schema.GenerateJsonSchema'>
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: update_json_schema
  kind: function
  ns: pydantic.json_schema
  description: |-
    Update a JSON schema in-place by providing a dictionary of updates.

    This function sets the provided key-value pairs in the schema and returns the updated schema.

    Args:
        schema: The JSON schema to update.
        updates: A dictionary of key-value pairs to set in the schema.

    Returns:
        The updated JSON schema.
  summary: Update a JSON schema in-place by providing a dictionary of updates
  signatures:
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: updates
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.main
  kind: module
  ns: null
  description: Logic for creating models.
  summary: Logic for creating models
  signatures: null
  inherits_from: null
- name: create_model
  kind: function
  ns: pydantic.main
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/models/#dynamic-model-creation

    Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a
    subclass of [`BaseModel`][pydantic.BaseModel].

    Args:
        __model_name: The name of the newly created model.
        __config__: The configuration of the new model.
        __doc__: The docstring of the new model.
        __base__: The base class or classes for the new model.
        __module__: The name of the module that the model belongs to;
            if `None`, the value is taken from `sys._getframe(1)`
        __validators__: A dictionary of methods that validate fields.
        __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.
        __slots__: Deprecated. Should not be passed to `create_model`.
        **field_definitions: Attributes of the new model. They should be passed in the format:
            `<name>=(<type>, <default value>)` or `<name>=(<type>, <FieldInfo>)`.

    Returns:
        The new [model][pydantic.BaseModel].

    Raises:
        PydanticUserError: If `__base__` and `__config__` are both passed.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __model_name
    default: null
    rest: false
  - name: __config__
    default: None
    rest: false
    kind: kw-only
  - name: __doc__
    default: None
    rest: false
    kind: kw-only
  - name: __base__
    default: None
    rest: false
    kind: kw-only
  - name: __module__
    default: None
    rest: false
    kind: kw-only
  - name: __validators__
    default: None
    rest: false
    kind: kw-only
  - name: __cls_kwargs__
    default: None
    rest: false
    kind: kw-only
  - name: __slots__
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: pydantic.networks
  kind: module
  ns: null
  description: The networks module contains types for common network-related fields.
  summary: The networks module contains types for common network-related fields
  signatures: null
  inherits_from: null
- name: AnyHttpUrl
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NatsDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: validate_email
  kind: function
  ns: pydantic.networks
  description: |-
    Email address validation using [email-validator](https://pypi.org/project/email-validator/).

    Note:
        Note that:

        * Raw IP address (literal) domain parts are not allowed.
        * `"John Doe <local_part@domain.com>"` style "pretty" email addresses are processed.
        * Spaces are striped from the beginning and end of addresses, but no error is raised.
  summary: Email address validation using [email-validator](https://pypi
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MySQLDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MariaDBDsn
  kind: callable
  ns: pydantic.networks
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.parse
  kind: module
  ns: null
  description: The `parse` module is a backport module from V1.
  summary: The `parse` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.parse
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.plugin
  kind: module
  ns: null
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/plugins#build-a-plugin

    Plugin interface for Pydantic plugins, and related types.
  summary: 'Usage docs: https://docs'
  signatures: null
  inherits_from: null
- name: PydanticPluginProtocol
  kind: class
  ns: pydantic.plugin
  description: Protocol defining the interface for Pydantic plugins.
  summary: Protocol defining the interface for Pydantic plugins
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: PydanticPluginProtocol
  inherits_from:
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: PydanticPluginProtocol.new_schema_validator
  kind: method
  ns: pydantic.plugin
  description: |-
    This method is called for each plugin every time a new [`SchemaValidator`][pydantic_core.SchemaValidator]
    is created.

    It should return an event handler for each of the three validation methods, or `None` if the plugin does not
    implement that method.

    Args:
        schema: The schema to validate against.
        schema_type: The original type which the schema was created from, e.g. the model class.
        schema_type_path: Path defining where `schema_type` was defined, or where `TypeAdapter` was called.
        schema_kind: The kind of schema to validate against.
        config: The config to use for validation.
        plugin_settings: Any plugin settings.

    Returns:
        A tuple of optional event handlers for each of the three validation methods -
            `validate_python`, `validate_json`, `validate_strings`.
  summary: This method is called for each plugin every time a new [`SchemaValidator`][pydantic_core
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: schema_type
    default: null
    rest: false
  - kind: positional
    name: schema_type_path
    default: null
    rest: false
  - kind: positional
    name: schema_kind
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - kind: positional
    name: plugin_settings
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseValidateHandlerProtocol
  kind: class
  ns: pydantic.plugin
  description: |-
    Base class for plugin callbacks protocols.

    You shouldn't implement this protocol directly, instead use one of the subclasses with adds the correctly
    typed `on_error` method.
  summary: Base class for plugin callbacks protocols
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: BaseValidateHandlerProtocol
  inherits_from:
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: BaseValidateHandlerProtocol.on_error
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation errors.

    Args:
        error: The validation error.
  summary: Callback to be notified of validation errors
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: error
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseValidateHandlerProtocol.on_exception
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation exceptions.

    Args:
        exception: The exception raised during validation.
  summary: Callback to be notified of validation exceptions
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: exception
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseValidateHandlerProtocol.on_success
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of successful validation.

    Args:
        result: The result of the validation.
  summary: Callback to be notified of successful validation
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: result
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidatePythonHandlerProtocol
  kind: class
  ns: pydantic.plugin
  description: Event handler for `SchemaValidator.validate_python`.
  summary: Event handler for `SchemaValidator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ValidatePythonHandlerProtocol
  inherits_from:
  - <class 'pydantic.plugin.BaseValidateHandlerProtocol'>
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: ValidatePythonHandlerProtocol.on_enter
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation start, and create an instance of the event handler.

    Args:
        input: The input to be validated.
        strict: Whether to validate the object in strict mode.
        from_attributes: Whether to validate objects as inputs by extracting attributes.
        context: The context to use for validation, this is passed to functional validators.
        self_instance: An instance of a model to set attributes on from validation, this is used when running
            validation from the `__init__` method of a model.
  summary: Callback to be notified of validation start, and create an instance of the event handler
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - name: self_instance
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ValidatePythonHandlerProtocol.on_error
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation errors.

    Args:
        error: The validation error.
  summary: Callback to be notified of validation errors
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: error
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidatePythonHandlerProtocol.on_exception
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation exceptions.

    Args:
        exception: The exception raised during validation.
  summary: Callback to be notified of validation exceptions
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: exception
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidatePythonHandlerProtocol.on_success
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of successful validation.

    Args:
        result: The result of the validation.
  summary: Callback to be notified of successful validation
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: result
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidateJsonHandlerProtocol
  kind: class
  ns: pydantic.plugin
  description: Event handler for `SchemaValidator.validate_json`.
  summary: Event handler for `SchemaValidator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ValidateJsonHandlerProtocol
  inherits_from:
  - <class 'pydantic.plugin.BaseValidateHandlerProtocol'>
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: ValidateJsonHandlerProtocol.on_enter
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation start, and create an instance of the event handler.

    Args:
        input: The JSON data to be validated.
        strict: Whether to validate the object in strict mode.
        context: The context to use for validation, this is passed to functional validators.
        self_instance: An instance of a model to set attributes on from validation, this is used when running
            validation from the `__init__` method of a model.
  summary: Callback to be notified of validation start, and create an instance of the event handler
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - name: self_instance
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ValidateJsonHandlerProtocol.on_error
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation errors.

    Args:
        error: The validation error.
  summary: Callback to be notified of validation errors
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: error
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidateJsonHandlerProtocol.on_exception
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation exceptions.

    Args:
        exception: The exception raised during validation.
  summary: Callback to be notified of validation exceptions
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: exception
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidateJsonHandlerProtocol.on_success
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of successful validation.

    Args:
        result: The result of the validation.
  summary: Callback to be notified of successful validation
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: result
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidateStringsHandlerProtocol
  kind: class
  ns: pydantic.plugin
  description: Event handler for `SchemaValidator.validate_strings`.
  summary: Event handler for `SchemaValidator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: ValidateStringsHandlerProtocol
  inherits_from:
  - <class 'pydantic.plugin.BaseValidateHandlerProtocol'>
  - <class 'typing_extensions.Protocol'>
  - <class 'typing.Generic'>
- name: ValidateStringsHandlerProtocol.on_enter
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation start, and create an instance of the event handler.

    Args:
        input: The string data to be validated.
        strict: Whether to validate the object in strict mode.
        context: The context to use for validation, this is passed to functional validators.
  summary: Callback to be notified of validation start, and create an instance of the event handler
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ValidateStringsHandlerProtocol.on_error
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation errors.

    Args:
        error: The validation error.
  summary: Callback to be notified of validation errors
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: error
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidateStringsHandlerProtocol.on_exception
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of validation exceptions.

    Args:
        exception: The exception raised during validation.
  summary: Callback to be notified of validation exceptions
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: exception
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidateStringsHandlerProtocol.on_success
  kind: method
  ns: pydantic.plugin
  description: |-
    Callback to be notified of successful validation.

    Args:
        result: The result of the validation.
  summary: Callback to be notified of successful validation
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: result
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NewSchemaReturns
  kind: const
  ns: pydantic.plugin
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SchemaTypePath
  kind: class
  ns: pydantic.plugin
  description: Path defining where `schema_type` was defined, or where `TypeAdapter` was called.
  summary: Path defining where `schema_type` was defined, or where `TypeAdapter` was called
  signatures:
  - kind: positional
    name: _cls
    default: null
    rest: false
  - kind: positional
    name: module
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: SchemaTypePath
  inherits_from:
  - <class 'tuple'>
- name: SchemaTypePath.count
  kind: callable
  ns: pydantic.plugin
  description: Return number of occurrences of value.
  summary: Return number of occurrences of value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SchemaTypePath.index
  kind: callable
  ns: pydantic.plugin
  description: |-
    Return first index of value.

    Raises ValueError if the value is not present.
  summary: Return first index of value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: start
    default: '0'
    rest: false
  - kind: positional
    name: stop
    default: '9223372036854775807'
    rest: false
  - type: '?'
  inherits_from: null
- name: SchemaTypePath.module
  kind: property
  ns: pydantic.plugin
  description: Alias for field number 0
  summary: Alias for field number 0
  signatures: null
  inherits_from: null
- name: SchemaTypePath.name
  kind: property
  ns: pydantic.plugin
  description: Alias for field number 1
  summary: Alias for field number 1
  signatures: null
  inherits_from: null
- name: SchemaKind
  kind: callable
  ns: pydantic.plugin
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.root_model
  kind: module
  ns: null
  description: RootModel class and type definitions.
  summary: RootModel class and type definitions
  signatures: null
  inherits_from: null
- name: pydantic.schema
  kind: module
  ns: null
  description: The `schema` module is a backport module from V1.
  summary: The `schema` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.schema
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.tools
  kind: module
  ns: null
  description: The `tools` module is a backport module from V1.
  summary: The `tools` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.tools
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.type_adapter
  kind: module
  ns: null
  description: Type adapter specification.
  summary: Type adapter specification
  signatures: null
  inherits_from: null
- name: CoreSchema
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DEFAULT_REF_TEMPLATE
  kind: const
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Dict
  kind: callable
  ns: pydantic.type_adapter
  description: A generic version of dict.
  summary: A generic version of dict
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Generic
  kind: class
  ns: pydantic.type_adapter
  description: |-
    Abstract base class for generic types.

    A generic type is typically declared by inheriting from
    this class parameterized with one or more type variables.
    For example, a generic mapping type might be defined as::

      class Mapping(Generic[KT, VT]):
          def __getitem__(self, key: KT) -> VT:
              ...
          # Etc.

    This class can then be used as follows::

      def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:
          try:
              return mapping[key]
          except KeyError:
              return default
  summary: Abstract base class for generic types
  signatures:
  - type: Generic
  inherits_from: null
- name: Iterable
  kind: callable
  ns: pydantic.type_adapter
  description: A generic version of collections.abc.Iterable.
  summary: A generic version of collections
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaKeyT
  kind: const
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: JsonSchemaMode
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonSchemaValue
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Literal
  kind: callable
  ns: pydantic.type_adapter
  description: |-
    Special typing form to define literal types (a.k.a. value types).

    This form can be used to indicate to type checkers that the corresponding
    variable or function parameter has a value equivalent to the provided
    literal (or one of several literals)::

        def validate_simple(data: Any) -> Literal[True]:  # always returns True
            ...

        MODE = Literal['r', 'rb', 'w', 'wb']
        def open_helper(file: str, mode: MODE) -> str:
            ...

        open_helper('/some/path', 'r')  # Passes type check
        open_helper('/other/path', 'typo')  # Error in type checker

    Literal[...] cannot be subclassed. At runtime, an arbitrary value
    is allowed as type argument to Literal[...], but type checkers may
    impose restrictions.
  summary: Special typing form to define literal types (a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SchemaSerializer
  kind: class
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: config
    default: None
    rest: false
  - type: SchemaSerializer
  inherits_from: null
- name: SchemaSerializer.to_json
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - name: fallback
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaSerializer.to_python
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - name: mode
    default: None
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: round_trip
    default: 'False'
    rest: false
    kind: kw-only
  - name: warnings
    default: 'True'
    rest: false
    kind: kw-only
  - name: fallback
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaValidator
  kind: class
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: config
    default: None
    rest: false
  - type: SchemaValidator
  inherits_from: null
- name: SchemaValidator.get_default_value
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaValidator.isinstance_python
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - name: self_instance
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaValidator.title
  kind: property
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SchemaValidator.validate_assignment
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - kind: positional
    name: field_name
    default: null
    rest: false
  - kind: positional
    name: field_value
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaValidator.validate_json
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - name: self_instance
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaValidator.validate_python
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: from_attributes
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - name: self_instance
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: SchemaValidator.validate_strings
  kind: callable
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: input
    default: null
    rest: false
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: context
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Set
  kind: callable
  ns: pydantic.type_adapter
  description: A generic version of set.
  summary: A generic version of set
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Some
  kind: class
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: Some
  inherits_from: null
- name: Some.value
  kind: property
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: T
  kind: const
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: TYPE_CHECKING
  kind: const
  ns: pydantic.type_adapter
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Union
  kind: callable
  ns: pydantic.type_adapter
  description: |-
    Union type; Union[X, Y] means either X or Y.

    On Python 3.10 and higher, the | operator
    can also be used to denote unions;
    X | Y means the same thing to the type checker as Union[X, Y].

    To define a union, use e.g. Union[int, str]. Details:
    - The arguments must be types and there must be at least one.
    - None as an argument is a special case and is replaced by
      type(None).
    - Unions of unions are flattened, e.g.::

        assert Union[Union[int, str], float] == Union[int, str, float]

    - Unions of a single argument vanish, e.g.::

        assert Union[int] == int  # The constructor actually returns int

    - Redundant arguments are skipped, e.g.::

        assert Union[int, str, int] == Union[int, str]

    - When comparing unions, the argument order is ignored, e.g.::

        assert Union[int, str] == Union[str, int]

    - You cannot subclass or instantiate a union.
    - You can use Optional[X] as a shorthand for Union[X, None].
  summary: Union type; Union[X, Y] means either X or Y
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: cast
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Cast a value to a type.

    This returns the value unchanged.  To the type checker this
    signals that the return value has the designated type, but at
    runtime we intentionally don't check anything (we want this
    to be as fast as possible).
  summary: Cast a value to a type
  signatures:
  - kind: positional
    name: typ
    default: null
    rest: false
  - kind: positional
    name: val
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: create_schema_validator
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Create a `SchemaValidator` or `PluggableSchemaValidator` if plugins are installed.

    Returns:
        If plugins are installed then return `PluggableSchemaValidator`, otherwise return `SchemaValidator`.
  summary: Create a `SchemaValidator` or `PluggableSchemaValidator` if plugins are installed
  signatures:
  - kind: positional
    name: schema
    default: null
    rest: false
  - kind: positional
    name: schema_type
    default: null
    rest: false
  - kind: positional
    name: schema_type_module
    default: null
    rest: false
  - kind: positional
    name: schema_type_name
    default: null
    rest: false
  - kind: positional
    name: schema_kind
    default: null
    rest: false
  - kind: positional
    name: config
    default: None
    rest: false
  - kind: positional
    name: plugin_settings
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: final
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Decorator to indicate final methods and final classes.

    Use this decorator to indicate to type checkers that the decorated
    method cannot be overridden, and decorated class cannot be subclassed.

    For example::

        class Base:
            @final
            def done(self) -> None:
                ...
        class Sub(Base):
            def done(self) -> None:  # Error reported by type checker
                ...

        @final
        class Leaf:
            ...
        class Other(Leaf):  # Error reported by type checker
            ...

    There is no runtime checking of these properties. The decorator
    attempts to set the ``__final__`` attribute to ``True`` on the decorated
    object to allow runtime introspection.
  summary: Decorator to indicate final methods and final classes
  signatures:
  - kind: positional
    name: f
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: get_args
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Get type arguments with all substitutions performed.

    For unions, basic simplifications used by Union constructor are performed.

    Examples::

        >>> T = TypeVar('T')
        >>> assert get_args(Dict[str, int]) == (str, int)
        >>> assert get_args(int) == ()
        >>> assert get_args(Union[int, Union[T, int], str][int]) == (int, str)
        >>> assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
        >>> assert get_args(Callable[[], T][int]) == ([], int)
  summary: Get type arguments with all substitutions performed
  signatures:
  - kind: positional
    name: tp
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: is_dataclass
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Returns True if obj is a dataclass or an instance of a
    dataclass.
  summary: Returns True if obj is a dataclass or an instance of a
  signatures:
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: is_typeddict
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Check if an annotation is a TypedDict class

    For example::
        class Film(TypedDict):
            title: str
            year: int

        is_typeddict(Film)  # => True
        is_typeddict(Union[list, str])  # => False
  summary: Check if an annotation is a TypedDict class
  signatures:
  - kind: positional
    name: tp
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: overload
  kind: function
  ns: pydantic.type_adapter
  description: |-
    Decorator for overloaded functions/methods.

    In a stub file, place two or more stub definitions for the same
    function in a row, each decorated with @overload.

    For example::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...

    In a non-stub file (i.e. a regular .py file), do the same but
    follow it with an implementation.  The implementation should *not*
    be decorated with @overload::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...
        def utf8(value):
            ...  # implementation goes here

    The overloads for a function can be retrieved at runtime using the
    get_overloads() function.
  summary: Decorator for overloaded functions/methods
  signatures:
  - kind: positional
    name: func
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.types
  kind: module
  ns: null
  description: The types module contains custom types used by pydantic.
  summary: The types module contains custom types used by pydantic
  signatures: null
  inherits_from: null
- name: StrictStr
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: conbytes
  kind: function
  ns: pydantic.types
  description: |-
    A wrapper around `bytes` that allows for additional constraints.

    Args:
        min_length: The minimum length of the bytes.
        max_length: The maximum length of the bytes.
        strict: Whether to validate the bytes in strict mode.

    Returns:
        The wrapped bytes type.
  summary: A wrapper around `bytes` that allows for additional constraints
  signatures:
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: conlist
  kind: function
  ns: pydantic.types
  description: |-
    A wrapper around typing.List that adds validation.

    Args:
        item_type: The type of the items in the list.
        min_length: The minimum length of the list. Defaults to None.
        max_length: The maximum length of the list. Defaults to None.
        unique_items: Whether the items in the list must be unique. Defaults to None.
            !!! warning Deprecated
                The `unique_items` parameter is deprecated, use `Set` instead.
                See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details.

    Returns:
        The wrapped list type.
  summary: A wrapper around typing
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: unique_items
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: conset
  kind: function
  ns: pydantic.types
  description: |-
    A wrapper around `typing.Set` that allows for additional constraints.

    Args:
        item_type: The type of the items in the set.
        min_length: The minimum length of the set.
        max_length: The maximum length of the set.

    Returns:
        The wrapped set type.
  summary: A wrapper around `typing
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: confrozenset
  kind: function
  ns: pydantic.types
  description: |-
    A wrapper around `typing.FrozenSet` that allows for additional constraints.

    Args:
        item_type: The type of the items in the frozenset.
        min_length: The minimum length of the frozenset.
        max_length: The maximum length of the frozenset.

    Returns:
        The wrapped frozenset type.
  summary: A wrapper around `typing
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: constr
  kind: function
  ns: pydantic.types
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`StringConstraints`][pydantic.types.StringConstraints] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `constr` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, constr

            class Foo(BaseModel):
                bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')
            ```

        === ":white_check_mark: Do this"
            ```py
            from typing_extensions import Annotated

            from pydantic import BaseModel, StringConstraints

            class Foo(BaseModel):
                bar: Annotated[str, StringConstraints(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')]
            ```

    A wrapper around `str` that allows for additional constraints.

    ```py
    from pydantic import BaseModel, constr

    class Foo(BaseModel):
        bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')


    foo = Foo(bar='  hello  ')
    print(foo)
    #> bar='HELLO'
    ```

    Args:
        strip_whitespace: Whether to remove leading and trailing whitespace.
        to_upper: Whether to turn all characters to uppercase.
        to_lower: Whether to turn all characters to lowercase.
        strict: Whether to validate the string in strict mode.
        min_length: The minimum length of the string.
        max_length: The maximum length of the string.
        pattern: A regex pattern to validate the string against.

    Returns:
        The wrapped string type.
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strip_whitespace
    default: None
    rest: false
    kind: kw-only
  - name: to_upper
    default: None
    rest: false
    kind: kw-only
  - name: to_lower
    default: None
    rest: false
    kind: kw-only
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: pattern
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: conint
  kind: function
  ns: pydantic.types
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`Field`][pydantic.fields.Field] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `conint` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, conint

            class Foo(BaseModel):
                bar: conint(strict=True, gt=0)
            ```

        === ":white_check_mark: Do this"
            ```py
            from typing_extensions import Annotated

            from pydantic import BaseModel, Field

            class Foo(BaseModel):
                bar: Annotated[int, Field(strict=True, gt=0)]
            ```

    A wrapper around `int` that allows for additional constraints.

    Args:
        strict: Whether to validate the integer in strict mode. Defaults to `None`.
        gt: The value must be greater than this.
        ge: The value must be greater than or equal to this.
        lt: The value must be less than this.
        le: The value must be less than or equal to this.
        multiple_of: The value must be a multiple of this.

    Returns:
        The wrapped integer type.

    ```py
    from pydantic import BaseModel, ValidationError, conint

    class ConstrainedExample(BaseModel):
        constrained_int: conint(gt=1)

    m = ConstrainedExample(constrained_int=2)
    print(repr(m))
    #> ConstrainedExample(constrained_int=2)

    try:
        ConstrainedExample(constrained_int=0)
    except ValidationError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'greater_than',
                'loc': ('constrained_int',),
                'msg': 'Input should be greater than 1',
                'input': 0,
                'ctx': {'gt': 1},
                'url': 'https://errors.pydantic.dev/2/v/greater_than',
            }
        ]
        '''
    ```
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PositiveInt
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeInt
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeInt
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveInt
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: confloat
  kind: function
  ns: pydantic.types
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`Field`][pydantic.fields.Field] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `confloat` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, confloat

            class Foo(BaseModel):
                bar: confloat(strict=True, gt=0)
            ```

        === ":white_check_mark: Do this"
            ```py
            from typing_extensions import Annotated

            from pydantic import BaseModel, Field

            class Foo(BaseModel):
                bar: Annotated[float, Field(strict=True, gt=0)]
            ```

    A wrapper around `float` that allows for additional constraints.

    Args:
        strict: Whether to validate the float in strict mode.
        gt: The value must be greater than this.
        ge: The value must be greater than or equal to this.
        lt: The value must be less than this.
        le: The value must be less than or equal to this.
        multiple_of: The value must be a multiple of this.
        allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.

    Returns:
        The wrapped float type.

    ```py
    from pydantic import BaseModel, ValidationError, confloat

    class ConstrainedExample(BaseModel):
        constrained_float: confloat(gt=1.0)

    m = ConstrainedExample(constrained_float=1.1)
    print(repr(m))
    #> ConstrainedExample(constrained_float=1.1)

    try:
        ConstrainedExample(constrained_float=0.9)
    except ValidationError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'greater_than',
                'loc': ('constrained_float',),
                'msg': 'Input should be greater than 1',
                'input': 0.9,
                'ctx': {'gt': 1.0},
                'url': 'https://errors.pydantic.dev/2/v/greater_than',
            }
        ]
        '''
    ```
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PositiveFloat
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeFloat
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeFloat
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveFloat
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FiniteFloat
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: condecimal
  kind: function
  ns: pydantic.types
  description: |-
    !!! warning "Discouraged"
        This function is **discouraged** in favor of using
        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with
        [`Field`][pydantic.fields.Field] instead.

        This function will be **deprecated** in Pydantic 3.0.

        The reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.

        === ":x: Don't do this"
            ```py
            from pydantic import BaseModel, condecimal

            class Foo(BaseModel):
                bar: condecimal(strict=True, allow_inf_nan=True)
            ```

        === ":white_check_mark: Do this"
            ```py
            from decimal import Decimal

            from typing_extensions import Annotated

            from pydantic import BaseModel, Field

            class Foo(BaseModel):
                bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]
            ```

    A wrapper around Decimal that adds validation.

    Args:
        strict: Whether to validate the value in strict mode. Defaults to `None`.
        gt: The value must be greater than this. Defaults to `None`.
        ge: The value must be greater than or equal to this. Defaults to `None`.
        lt: The value must be less than this. Defaults to `None`.
        le: The value must be less than or equal to this. Defaults to `None`.
        multiple_of: The value must be a multiple of this. Defaults to `None`.
        max_digits: The maximum number of digits. Defaults to `None`.
        decimal_places: The number of decimal places. Defaults to `None`.
        allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.

    ```py
    from decimal import Decimal

    from pydantic import BaseModel, ValidationError, condecimal

    class ConstrainedExample(BaseModel):
        constrained_decimal: condecimal(gt=Decimal('1.0'))

    m = ConstrainedExample(constrained_decimal=Decimal('1.1'))
    print(repr(m))
    #> ConstrainedExample(constrained_decimal=Decimal('1.1'))

    try:
        ConstrainedExample(constrained_decimal=Decimal('0.9'))
    except ValidationError as e:
        print(e.errors())
        '''
        [
            {
                'type': 'greater_than',
                'loc': ('constrained_decimal',),
                'msg': 'Input should be greater than 1.0',
                'input': Decimal('0.9'),
                'ctx': {'gt': Decimal('1.0')},
                'url': 'https://errors.pydantic.dev/2/v/greater_than',
            }
        ]
        '''
    ```
  summary: '!!! warning "Discouraged"'
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - name: max_digits
    default: None
    rest: false
    kind: kw-only
  - name: decimal_places
    default: None
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: UUID1
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UUID3
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UUID4
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: UUID5
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NewPath
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBool
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictInt
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictFloat
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: condate
  kind: function
  ns: pydantic.types
  description: |-
    A wrapper for date that adds constraints.

    Args:
        strict: Whether to validate the date value in strict mode. Defaults to `None`.
        gt: The value must be greater than this. Defaults to `None`.
        ge: The value must be greater than or equal to this. Defaults to `None`.
        lt: The value must be less than this. Defaults to `None`.
        le: The value must be less than or equal to this. Defaults to `None`.

    Returns:
        A date type with the specified constraints.
  summary: A wrapper for date that adds constraints
  signatures:
  - name: strict
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Base64Bytes
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64Str
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64UrlBytes
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Base64UrlStr
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: JsonValue
  kind: callable
  ns: pydantic.types
  description: |-
    Create named, parameterized type aliases.

    This provides a backport of the new `type` statement in Python 3.12:

        type ListOrSet[T] = list[T] | set[T]

    is equivalent to:

        T = TypeVar("T")
        ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))

    The name ListOrSet can then be used as an alias for the type it refers to.

    The type_params argument should contain all the type parameters used
    in the value of the type alias. If the alias is not generic, this
    argument is omitted.

    Static type checkers should only support type aliases declared using
    TypeAliasType that follow these rules:

    - The first argument (the name) must be a string literal.
    - The TypeAliasType instance must be immediately assigned to a variable
      of the same name. (For example, 'X = TypeAliasType("Y", int)' is invalid,
      as is 'X, Y = TypeAliasType("X", int), TypeAliasType("Y", int)').
  summary: Create named, parameterized type aliases
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: OnErrorOmit
  kind: callable
  ns: pydantic.types
  description: |-
    Runtime representation of an annotated type.

    At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'
    with extra annotations. The alias behaves like a normal typing alias.
    Instantiating is the same as instantiating the underlying type; binding
    it to types is also the same.

    The metadata itself is stored in a '__metadata__' attribute as a tuple.
  summary: Runtime representation of an annotated type
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.typing
  kind: module
  ns: null
  description: '`typing` module is a backport module from V1.'
  summary: '`typing` module is a backport module from V1'
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.typing
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.utils
  kind: module
  ns: null
  description: The `utils` module is a backport module from V1.
  summary: The `utils` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.utils
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.v1
  kind: module
  ns: null
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: create_model_from_namedtuple
  kind: function
  ns: pydantic.v1
  description: |-
    Create a `BaseModel` based on the fields of a named tuple.
    A named tuple can be created with `typing.NamedTuple` and declared annotations
    but also with `collections.namedtuple`, in this case we consider all fields
    to have type `Any`.
  summary: Create a `BaseModel` based on the fields of a named tuple
  signatures:
  - kind: positional
    name: namedtuple_cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: create_model_from_typeddict
  kind: function
  ns: pydantic.v1
  description: |-
    Create a `BaseModel` based on the fields of a `TypedDict`.
    Since `typing.TypedDict` in Python 3.8 does not store runtime information about optional keys,
    we raise an error if this happens (see https://bugs.python.org/issue38834).
  summary: Create a `BaseModel` based on the fields of a `TypedDict`
  signatures:
  - kind: positional
    name: typeddict_cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: dataclasses
  kind: module
  ns: pydantic.v1
  description: |-
    The main purpose is to enhance stdlib dataclasses by adding validation
    A pydantic dataclass can be generated from scratch or from a stdlib one.

    Behind the scene, a pydantic dataclass is just like a regular one on which we attach
    a `BaseModel` and magic methods to trigger the validation of the data.
    `__init__` and `__post_init__` are hence overridden and have extra logic to be
    able to validate input data.

    When a pydantic dataclass is generated from scratch, it's just a plain dataclass
    with validation triggered at initialization

    The tricky part if for stdlib dataclasses that are converted after into pydantic ones e.g.

    ```py
    @dataclasses.dataclass
    class M:
        x: int

    ValidatedM = pydantic.dataclasses.dataclass(M)
    ```

    We indeed still want to support equality, hashing, repr, ... as if it was the stdlib one!

    ```py
    assert isinstance(ValidatedM(x=1), M)
    assert ValidatedM(x=1) == M(x=1)
    ```

    This means we **don't want to create a new dataclass that inherits from it**
    The trick is to create a wrapper around `M` that will act as a proxy to trigger
    validation without altering default `M` behaviour.
  summary: The main purpose is to enhance stdlib dataclasses by adding validation
  signatures: null
  inherits_from: null
- name: dataclass
  kind: function
  ns: pydantic.v1
  description: |-
    Like the python standard lib dataclasses but with type validation.
    The result is either a pydantic dataclass that will validate input data
    or a wrapper that will trigger validation around a stdlib dataclass
    to avoid modifying it directly
  summary: Like the python standard lib dataclasses but with type validation
  signatures:
  - kind: positional
    name: _cls
    default: None
    rest: false
  - name: init
    default: 'True'
    rest: false
    kind: kw-only
  - name: repr
    default: 'True'
    rest: false
    kind: kw-only
  - name: eq
    default: 'True'
    rest: false
    kind: kw-only
  - name: order
    default: 'False'
    rest: false
    kind: kw-only
  - name: unsafe_hash
    default: 'False'
    rest: false
    kind: kw-only
  - name: frozen
    default: 'False'
    rest: false
    kind: kw-only
  - name: config
    default: None
    rest: false
    kind: kw-only
  - name: validate_on_init
    default: None
    rest: false
    kind: kw-only
  - name: use_proxy
    default: None
    rest: false
    kind: kw-only
  - name: kw_only
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: set_validation
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: '?'
  inherits_from: null
- name: create_pydantic_model_from_dataclass
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: dc_cls
    default: null
    rest: false
  - kind: positional
    name: config
    default: <class 'pydantic.v1.config.BaseConfig'>
    rest: false
  - kind: positional
    name: dc_cls_doc
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: is_builtin_dataclass
  kind: function
  ns: pydantic.v1
  description: |-
    Whether a class is a stdlib dataclass
    (useful to discriminated a pydantic dataclass that is actually a wrapper around a stdlib dataclass)

    we check that
    - `_cls` is a dataclass
    - `_cls` is not a processed pydantic dataclass (with a basemodel attached)
    - `_cls` is not a pydantic dataclass inheriting directly from a stdlib dataclass
    e.g.
    ```
    @dataclasses.dataclass
    class A:
        x: int

    @pydantic.dataclasses.dataclass
    class B(A):
        y: int
    ```
    In this case, when we first check `B`, we make an extra check and look at the annotations ('y'),
    which won't be a superset of all the dataclass fields (only the stdlib fields i.e. 'x')
  summary: Whether a class is a stdlib dataclass
  signatures:
  - kind: positional
    name: _cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: make_dataclass_validator
  kind: function
  ns: pydantic.v1
  description: |-
    Create a pydantic.dataclass from a builtin dataclass to add type validation
    and yield the validators
    It retrieves the parameters of the dataclass and forwards them to the newly created dataclass
  summary: Create a pydantic
  signatures:
  - kind: positional
    name: dc_cls
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: root_validator
  kind: function
  ns: pydantic.v1
  description: |-
    Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either
    before or after standard model parsing/validation is performed.
  summary: Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either
  signatures:
  - kind: positional
    name: _func
    default: None
    rest: false
  - name: pre
    default: 'False'
    rest: false
    kind: kw-only
  - name: allow_reuse
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_on_failure
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: validator
  kind: function
  ns: pydantic.v1
  description: |-
    Decorate methods on the class indicating that they should be used to validate fields
    :param fields: which field(s) the method should be called on
    :param pre: whether or not this validator should be called before the standard validators (else after)
    :param each_item: for complex objects (sets, lists etc.) whether to validate individual elements rather than the
      whole object
    :param always: whether this method and other validators should be called even if the value is missing
    :param check_fields: whether to check that the fields actually exist on the model
    :param allow_reuse: whether to track and raise an error if another validator refers to the decorated function
  summary: Decorate methods on the class indicating that they should be used to validate fields
  signatures:
  - name: pre
    default: 'False'
    rest: false
    kind: kw-only
  - name: each_item
    default: 'False'
    rest: false
    kind: kw-only
  - name: always
    default: 'False'
    rest: false
    kind: kw-only
  - name: check_fields
    default: 'True'
    rest: false
    kind: kw-only
  - name: whole
    default: None
    rest: false
    kind: kw-only
  - name: allow_reuse
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseConfig
  kind: class
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: BaseConfig
  inherits_from: null
- name: BaseConfig.alias_generator
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseConfig.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.allow_mutation
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.allow_population_by_field_name
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.anystr_lower
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.anystr_strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.anystr_upper
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.arbitrary_types_allowed
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.copy_on_model_validation
  kind: property
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: BaseConfig.error_msg_templates
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseConfig.extra
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseConfig.fields
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseConfig.frozen
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.get_field_info
  kind: function
  ns: pydantic.v1
  description: Get properties of FieldInfo from the `fields` property of the config class.
  summary: Get properties of FieldInfo from the `fields` property of the config class
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.getter_dict
  kind: class
  ns: pydantic.v1
  description: |-
    Hack to make object's smell just enough like dicts for validate_model.

    We can't inherit from Mapping[str, Any] because it upsets cython so we have to implement all methods ourselves.
  summary: Hack to make object's smell just enough like dicts for validate_model
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: GetterDict
  inherits_from:
  - <class 'pydantic.v1.utils.Representation'>
- name: BaseConfig.getter_dict.extra_keys
  kind: method
  ns: pydantic.v1
  description: We don't want to get any other attributes of obj if the model didn't explicitly ask for them
  summary: We don't want to get any other attributes of obj if the model didn't explicitly ask for them
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.getter_dict.get
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.getter_dict.items
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.getter_dict.keys
  kind: method
  ns: pydantic.v1
  description: |-
    Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python
    dictionaries.
  summary: Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.getter_dict.values
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.json_dumps
  kind: method
  ns: pydantic.v1
  description: |-
    Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is true then ``dict`` keys that are not basic types
    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
    instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value can contain non-ASCII
    characters if they appear in strings contained in ``obj``. Otherwise, all
    such characters are escaped in JSON strings.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``RecursionError`` (or worse).

    If ``allow_nan`` is false, then it will be a ``ValueError`` to
    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
    strict compliance of the JSON specification, instead of using the
    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).

    If ``indent`` is a non-negative integer, then JSON array elements and
    object members will be pretty-printed with that indent level. An indent
    level of 0 will only insert newlines. ``None`` is the most compact
    representation.

    If specified, ``separators`` should be an ``(item_separator, key_separator)``
    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
    you should specify ``(',', ':')`` to eliminate whitespace.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *sort_keys* is true (default: ``False``), then the output of
    dictionaries will be sorted by key.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
  summary: Serialize ``obj`` to a JSON formatted ``str``
  signatures:
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: skipkeys
    default: 'False'
    rest: false
    kind: kw-only
  - name: ensure_ascii
    default: 'True'
    rest: false
    kind: kw-only
  - name: check_circular
    default: 'True'
    rest: false
    kind: kw-only
  - name: allow_nan
    default: 'True'
    rest: false
    kind: kw-only
  - name: cls
    default: None
    rest: false
    kind: kw-only
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: separators
    default: None
    rest: false
    kind: kw-only
  - name: default
    default: None
    rest: false
    kind: kw-only
  - name: sort_keys
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseConfig.json_encoders
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseConfig.json_loads
  kind: method
  ns: pydantic.v1
  description: |-
    Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
    containing a JSON document) to a Python object.

    ``object_hook`` is an optional function that will be called with the
    result of any object literal decode (a ``dict``). The return value of
    ``object_hook`` will be used instead of the ``dict``. This feature
    can be used to implement custom decoders (e.g. JSON-RPC class hinting).

    ``object_pairs_hook`` is an optional function that will be called with the
    result of any object literal decoded with an ordered list of pairs.  The
    return value of ``object_pairs_hook`` will be used instead of the ``dict``.
    This feature can be used to implement custom decoders.  If ``object_hook``
    is also defined, the ``object_pairs_hook`` takes priority.

    ``parse_float``, if specified, will be called with the string
    of every JSON float to be decoded. By default this is equivalent to
    float(num_str). This can be used to use another datatype or parser
    for JSON floats (e.g. decimal.Decimal).

    ``parse_int``, if specified, will be called with the string
    of every JSON int to be decoded. By default this is equivalent to
    int(num_str). This can be used to use another datatype or parser
    for JSON integers (e.g. float).

    ``parse_constant``, if specified, will be called with one of the
    following strings: -Infinity, Infinity, NaN.
    This can be used to raise an exception if invalid JSON numbers
    are encountered.

    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
    kwarg; otherwise ``JSONDecoder`` is used.
  summary: Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
  signatures:
  - kind: positional
    name: s
    default: null
    rest: false
  - name: cls
    default: None
    rest: false
    kind: kw-only
  - name: object_hook
    default: None
    rest: false
    kind: kw-only
  - name: parse_float
    default: None
    rest: false
    kind: kw-only
  - name: parse_int
    default: None
    rest: false
    kind: kw-only
  - name: parse_constant
    default: None
    rest: false
    kind: kw-only
  - name: object_pairs_hook
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseConfig.keep_untouched
  kind: property
  ns: pydantic.v1
  description: |-
    Built-in immutable sequence.

    If no argument is given, the constructor returns an empty tuple.
    If iterable is specified the tuple is initialized from iterable's items.

    If the argument is a tuple, the return value is the same object.
  summary: Built-in immutable sequence
  signatures: null
  inherits_from: null
- name: BaseConfig.max_anystr_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseConfig.min_anystr_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: BaseConfig.orm_mode
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.post_init_call
  kind: property
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: BaseConfig.prepare_field
  kind: function
  ns: pydantic.v1
  description: Optional hook to check or modify fields during model creation.
  summary: Optional hook to check or modify fields during model creation
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseConfig.schema_extra
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseConfig.smart_union
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.title
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseConfig.underscore_attrs_are_private
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.use_enum_values
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.validate_all
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseConfig.validate_assignment
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConfigDict
  kind: class
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from:
  - <class 'dict'>
- name: ConfigDict.clear
  kind: callable
  ns: pydantic.v1
  description: D.clear() -> None.  Remove all items from D.
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.copy
  kind: callable
  ns: pydantic.v1
  description: D.copy() -> a shallow copy of D
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.get
  kind: callable
  ns: pydantic.v1
  description: Return the value for key if key is in the dictionary, else default.
  summary: Return the value for key if key is in the dictionary, else default
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConfigDict.items
  kind: callable
  ns: pydantic.v1
  description: D.items() -> a set-like object providing a view on D's items
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.keys
  kind: callable
  ns: pydantic.v1
  description: D.keys() -> a set-like object providing a view on D's keys
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.pop
  kind: callable
  ns: pydantic.v1
  description: |-
    D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

    If the key is not found, return the default if given; otherwise,
    raise a KeyError.
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.popitem
  kind: callable
  ns: pydantic.v1
  description: |-
    Remove and return a (key, value) pair as a 2-tuple.

    Pairs are returned in LIFO (last-in, first-out) order.
    Raises KeyError if the dict is empty.
  summary: Remove and return a (key, value) pair as a 2-tuple
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConfigDict.setdefault
  kind: callable
  ns: pydantic.v1
  description: |-
    Insert key with a value of default if key is not in the dictionary.

    Return the value for key if key is in the dictionary, else default.
  summary: Insert key with a value of default if key is not in the dictionary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: key
    default: null
    rest: false
  - kind: positional
    name: default
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConfigDict.update
  kind: callable
  ns: pydantic.v1
  description: |-
    D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
    If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
    If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
    In either case, this is followed by: for k in F:  D[k] = F[k]
  summary: D
  signatures: null
  inherits_from: null
- name: ConfigDict.values
  kind: callable
  ns: pydantic.v1
  description: D.values() -> an object providing a view on D's values
  summary: D
  signatures: null
  inherits_from: null
- name: Extra
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: names
    default: None
    rest: false
  - name: module
    default: None
    rest: false
    kind: kw-only
  - name: qualname
    default: None
    rest: false
    kind: kw-only
  - name: type
    default: None
    rest: false
    kind: kw-only
  - name: start
    default: '1'
    rest: false
    kind: kw-only
  - name: boundary
    default: None
    rest: false
    kind: kw-only
  - type: Extra
  inherits_from:
  - <class 'str'>
  - <enum 'Enum'>
- name: Extra.allow
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Extra.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.forbid
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Extra.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.ignore
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Extra.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.name
  kind: property
  ns: pydantic.v1
  description: The name of the Enum member.
  summary: The name of the Enum member
  signatures: null
  inherits_from: null
- name: Extra.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: Extra.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Extra.value
  kind: property
  ns: pydantic.v1
  description: The value of the Enum member.
  summary: The value of the Enum member
  signatures: null
  inherits_from: null
- name: Extra.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: validate_arguments
  kind: function
  ns: pydantic.v1
  description: Decorator to validate the arguments passed to a function.
  summary: Decorator to validate the arguments passed to a function
  signatures:
  - kind: positional
    name: func
    default: None
    rest: false
  - name: config
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings
  kind: class
  ns: pydantic.v1
  description: |-
    Base class for settings, allowing values to be overridden by environment variables.

    This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),
    Heroku and any 12 factor app design.
  summary: Base class for settings, allowing values to be overridden by environment variables
  signatures:
  - kind: positional
    name: _env_file
    default: <object object at 0x7fe72b099340>
    rest: false
  - kind: positional
    name: _env_file_encoding
    default: None
    rest: false
  - kind: positional
    name: _env_nested_delimiter
    default: None
    rest: false
  - kind: positional
    name: _secrets_dir
    default: None
    rest: false
  - type: BaseSettings
  inherits_from:
  - <class 'pydantic.v1.main.BaseModel'>
  - <class 'pydantic.v1.utils.Representation'>
- name: BaseSettings.Config
  kind: class
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: Config
  inherits_from:
  - <class 'pydantic.v1.config.BaseConfig'>
- name: BaseSettings.Config.alias_generator
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.allow_mutation
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.allow_population_by_field_name
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.anystr_lower
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.anystr_strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.anystr_upper
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.arbitrary_types_allowed
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.case_sensitive
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.copy_on_model_validation
  kind: property
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.customise_sources
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: init_settings
    default: null
    rest: false
  - kind: positional
    name: env_settings
    default: null
    rest: false
  - kind: positional
    name: file_secret_settings
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.Config.env_file
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.env_file_encoding
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.env_nested_delimiter
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.env_prefix
  kind: property
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.error_msg_templates
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.extra
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.fields
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.frozen
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.get_field_info
  kind: function
  ns: pydantic.v1
  description: Get properties of FieldInfo from the `fields` property of the config class.
  summary: Get properties of FieldInfo from the `fields` property of the config class
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.Config.json_dumps
  kind: method
  ns: pydantic.v1
  description: |-
    Serialize ``obj`` to a JSON formatted ``str``.

    If ``skipkeys`` is true then ``dict`` keys that are not basic types
    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
    instead of raising a ``TypeError``.

    If ``ensure_ascii`` is false, then the return value can contain non-ASCII
    characters if they appear in strings contained in ``obj``. Otherwise, all
    such characters are escaped in JSON strings.

    If ``check_circular`` is false, then the circular reference check
    for container types will be skipped and a circular reference will
    result in an ``RecursionError`` (or worse).

    If ``allow_nan`` is false, then it will be a ``ValueError`` to
    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
    strict compliance of the JSON specification, instead of using the
    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).

    If ``indent`` is a non-negative integer, then JSON array elements and
    object members will be pretty-printed with that indent level. An indent
    level of 0 will only insert newlines. ``None`` is the most compact
    representation.

    If specified, ``separators`` should be an ``(item_separator, key_separator)``
    tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
    ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
    you should specify ``(',', ':')`` to eliminate whitespace.

    ``default(obj)`` is a function that should return a serializable version
    of obj or raise TypeError. The default simply raises TypeError.

    If *sort_keys* is true (default: ``False``), then the output of
    dictionaries will be sorted by key.

    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
    ``.default()`` method to serialize additional types), specify it with
    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.
  summary: Serialize ``obj`` to a JSON formatted ``str``
  signatures:
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: skipkeys
    default: 'False'
    rest: false
    kind: kw-only
  - name: ensure_ascii
    default: 'True'
    rest: false
    kind: kw-only
  - name: check_circular
    default: 'True'
    rest: false
    kind: kw-only
  - name: allow_nan
    default: 'True'
    rest: false
    kind: kw-only
  - name: cls
    default: None
    rest: false
    kind: kw-only
  - name: indent
    default: None
    rest: false
    kind: kw-only
  - name: separators
    default: None
    rest: false
    kind: kw-only
  - name: default
    default: None
    rest: false
    kind: kw-only
  - name: sort_keys
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.Config.json_encoders
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.json_loads
  kind: method
  ns: pydantic.v1
  description: |-
    Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
    containing a JSON document) to a Python object.

    ``object_hook`` is an optional function that will be called with the
    result of any object literal decode (a ``dict``). The return value of
    ``object_hook`` will be used instead of the ``dict``. This feature
    can be used to implement custom decoders (e.g. JSON-RPC class hinting).

    ``object_pairs_hook`` is an optional function that will be called with the
    result of any object literal decoded with an ordered list of pairs.  The
    return value of ``object_pairs_hook`` will be used instead of the ``dict``.
    This feature can be used to implement custom decoders.  If ``object_hook``
    is also defined, the ``object_pairs_hook`` takes priority.

    ``parse_float``, if specified, will be called with the string
    of every JSON float to be decoded. By default this is equivalent to
    float(num_str). This can be used to use another datatype or parser
    for JSON floats (e.g. decimal.Decimal).

    ``parse_int``, if specified, will be called with the string
    of every JSON int to be decoded. By default this is equivalent to
    int(num_str). This can be used to use another datatype or parser
    for JSON integers (e.g. float).

    ``parse_constant``, if specified, will be called with one of the
    following strings: -Infinity, Infinity, NaN.
    This can be used to raise an exception if invalid JSON numbers
    are encountered.

    To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
    kwarg; otherwise ``JSONDecoder`` is used.
  summary: Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance
  signatures:
  - kind: positional
    name: s
    default: null
    rest: false
  - name: cls
    default: None
    rest: false
    kind: kw-only
  - name: object_hook
    default: None
    rest: false
    kind: kw-only
  - name: parse_float
    default: None
    rest: false
    kind: kw-only
  - name: parse_int
    default: None
    rest: false
    kind: kw-only
  - name: parse_constant
    default: None
    rest: false
    kind: kw-only
  - name: object_pairs_hook
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.Config.keep_untouched
  kind: property
  ns: pydantic.v1
  description: |-
    Built-in immutable sequence.

    If no argument is given, the constructor returns an empty tuple.
    If iterable is specified the tuple is initialized from iterable's items.

    If the argument is a tuple, the return value is the same object.
  summary: Built-in immutable sequence
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.max_anystr_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.min_anystr_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.orm_mode
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.parse_env_var
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: field_name
    default: null
    rest: false
  - kind: positional
    name: raw_val
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.Config.post_init_call
  kind: property
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.prepare_field
  kind: function
  ns: pydantic.v1
  description: Optional hook to check or modify fields during model creation.
  summary: Optional hook to check or modify fields during model creation
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.Config.schema_extra
  kind: property
  ns: pydantic.v1
  description: |-
    dict() -> new empty dictionary
    dict(mapping) -> new dictionary initialized from a mapping object's
        (key, value) pairs
    dict(iterable) -> new dictionary initialized as if via:
        d = {}
        for k, v in iterable:
            d[k] = v
    dict(**kwargs) -> new dictionary initialized with the name=value pairs
        in the keyword argument list.  For example:  dict(one=1, two=2)
  summary: dict() -> new empty dictionary
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.secrets_dir
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.smart_union
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.title
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.underscore_attrs_are_private
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.use_enum_values
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.validate_all
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.Config.validate_assignment
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: BaseSettings.construct
  kind: function
  ns: pydantic.v1
  description: |-
    Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.
    Default values are respected, but no other validation is performed.
    Behaves as if `Config.extra = 'allow'` was set since it adds all passed values
  summary: Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: _fields_set
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.copy
  kind: method
  ns: pydantic.v1
  description: |-
    Duplicate a model, optionally choose which fields to include, exclude and change.

    :param include: fields to include in new model
    :param exclude: fields to exclude from new model, as with values this takes precedence over include
    :param update: values to change/add in the new model. Note: the data is not validated before creating
        the new model: you should trust this data
    :param deep: set to `True` to make a deep copy of the model
    :return: new model instance
  summary: Duplicate a model, optionally choose which fields to include, exclude and change
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: update
    default: None
    rest: false
    kind: kw-only
  - name: deep
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.dict
  kind: method
  ns: pydantic.v1
  description: Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
  summary: Generate a dictionary representation of the model, optionally specifying which fields to include or exclude
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_defaults
    default: None
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.from_orm
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.json
  kind: method
  ns: pydantic.v1
  description: |-
    Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`.

    `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.
  summary: Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_defaults
    default: None
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: encoder
    default: None
    rest: false
    kind: kw-only
  - name: models_as_dict
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.parse_file
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: path
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.parse_obj
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.parse_raw
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.schema
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/definitions/{model}'
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.schema_json
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/definitions/{model}'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseSettings.update_forward_refs
  kind: function
  ns: pydantic.v1
  description: Try to update ForwardRefs on fields based on this Model, globalns and localns.
  summary: Try to update ForwardRefs on fields based on this Model, globalns and localns
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseSettings.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidationError
  kind: class
  ns: pydantic.v1
  description: |-
    Mixin to provide __str__, __repr__, and __pretty__ methods. See #884 for more details.

    __pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations
    of objects.
  summary: Mixin to provide __str__, __repr__, and __pretty__ methods
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: errors
    default: null
    rest: false
  - kind: positional
    name: model
    default: null
    rest: false
  - type: ValidationError
  inherits_from:
  - <class 'pydantic.v1.utils.Representation'>
  - <class 'ValueError'>
  - <class 'Exception'>
  - <class 'BaseException'>
- name: ValidationError.add_note
  kind: callable
  ns: pydantic.v1
  description: |-
    Exception.add_note(note) --
    add a note to the exception
  summary: Exception
  signatures: null
  inherits_from: null
- name: ValidationError.args
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ValidationError.errors
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ValidationError.json
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: indent
    default: '2'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ValidationError.model
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ValidationError.raw_errors
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ValidationError.with_traceback
  kind: callable
  ns: pydantic.v1
  description: |-
    Exception.with_traceback(tb) --
    set self.__traceback__ to tb and return self.
  summary: Exception
  signatures: null
  inherits_from: null
- name: Field
  kind: function
  ns: pydantic.v1
  description: |-
    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments
    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.

    :param default: since this is replacing the fieldâ€™s default, its first argument is used
      to set the default, use ellipsis (``...``) to indicate the field is required
    :param default_factory: callable that will be called when a default value is needed for this field
      If both `default` and `default_factory` are set, an error is raised.
    :param alias: the public name of the field
    :param title: can be any string, used in the schema
    :param description: can be any string, used in the schema
    :param exclude: exclude this field while dumping.
      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.
    :param include: include this field while dumping.
      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.
    :param const: this field is required and *must* take it's default value
    :param gt: only applies to numbers, requires the field to be "greater than". The schema
      will have an ``exclusiveMinimum`` validation keyword
    :param ge: only applies to numbers, requires the field to be "greater than or equal to". The
      schema will have a ``minimum`` validation keyword
    :param lt: only applies to numbers, requires the field to be "less than". The schema
      will have an ``exclusiveMaximum`` validation keyword
    :param le: only applies to numbers, requires the field to be "less than or equal to". The
      schema will have a ``maximum`` validation keyword
    :param multiple_of: only applies to numbers, requires the field to be "a multiple of". The
      schema will have a ``multipleOf`` validation keyword
    :param allow_inf_nan: only applies to numbers, allows the field to be NaN or infinity (+inf or -inf),
        which is a valid Python float. Default True, set to False for compatibility with JSON.
    :param max_digits: only applies to Decimals, requires the field to have a maximum number
      of digits within the decimal. It does not include a zero before the decimal point or trailing decimal zeroes.
    :param decimal_places: only applies to Decimals, requires the field to have at most a number of decimal places
      allowed. It does not include trailing decimal zeroes.
    :param min_items: only applies to lists, requires the field to have a minimum number of
      elements. The schema will have a ``minItems`` validation keyword
    :param max_items: only applies to lists, requires the field to have a maximum number of
      elements. The schema will have a ``maxItems`` validation keyword
    :param unique_items: only applies to lists, requires the field not to have duplicated
      elements. The schema will have a ``uniqueItems`` validation keyword
    :param min_length: only applies to strings, requires the field to have a minimum length. The
      schema will have a ``minLength`` validation keyword
    :param max_length: only applies to strings, requires the field to have a maximum length. The
      schema will have a ``maxLength`` validation keyword
    :param allow_mutation: a boolean which defaults to True. When False, the field raises a TypeError if the field is
      assigned on an instance.  The BaseModel Config must set validate_assignment to True
    :param regex: only applies to strings, requires the field match against a regular expression
      pattern string. The schema will have a ``pattern`` validation keyword
    :param discriminator: only useful with a (discriminated a.k.a. tagged) `Union` of sub models with a common field.
      The `discriminator` is the name of this common field to shorten validation and improve generated schema
    :param repr: show this field in the representation
    :param **extra: any additional keyword arguments will be added as is to the schema
  summary: Used to provide extra information about a field, either for the model schema or complex validation
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: None
    rest: false
    kind: kw-only
  - name: alias
    default: None
    rest: false
    kind: kw-only
  - name: title
    default: None
    rest: false
    kind: kw-only
  - name: description
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: const
    default: None
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: None
    rest: false
    kind: kw-only
  - name: max_digits
    default: None
    rest: false
    kind: kw-only
  - name: decimal_places
    default: None
    rest: false
    kind: kw-only
  - name: min_items
    default: None
    rest: false
    kind: kw-only
  - name: max_items
    default: None
    rest: false
    kind: kw-only
  - name: unique_items
    default: None
    rest: false
    kind: kw-only
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: allow_mutation
    default: 'True'
    rest: false
    kind: kw-only
  - name: regex
    default: None
    rest: false
    kind: kw-only
  - name: discriminator
    default: None
    rest: false
    kind: kw-only
  - name: repr
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: Required
  kind: const
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: BaseModel
  kind: class
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: BaseModel
  inherits_from:
  - <class 'pydantic.v1.utils.Representation'>
- name: BaseModel.construct
  kind: function
  ns: pydantic.v1
  description: |-
    Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.
    Default values are respected, but no other validation is performed.
    Behaves as if `Config.extra = 'allow'` was set since it adds all passed values
  summary: Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: _fields_set
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.copy
  kind: method
  ns: pydantic.v1
  description: |-
    Duplicate a model, optionally choose which fields to include, exclude and change.

    :param include: fields to include in new model
    :param exclude: fields to exclude from new model, as with values this takes precedence over include
    :param update: values to change/add in the new model. Note: the data is not validated before creating
        the new model: you should trust this data
    :param deep: set to `True` to make a deep copy of the model
    :return: new model instance
  summary: Duplicate a model, optionally choose which fields to include, exclude and change
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: update
    default: None
    rest: false
    kind: kw-only
  - name: deep
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.dict
  kind: method
  ns: pydantic.v1
  description: Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.
  summary: Generate a dictionary representation of the model, optionally specifying which fields to include or exclude
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_defaults
    default: None
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.from_orm
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.json
  kind: method
  ns: pydantic.v1
  description: |-
    Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`.

    `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.
  summary: Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: include
    default: None
    rest: false
    kind: kw-only
  - name: exclude
    default: None
    rest: false
    kind: kw-only
  - name: by_alias
    default: 'False'
    rest: false
    kind: kw-only
  - name: skip_defaults
    default: None
    rest: false
    kind: kw-only
  - name: exclude_unset
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_defaults
    default: 'False'
    rest: false
    kind: kw-only
  - name: exclude_none
    default: 'False'
    rest: false
    kind: kw-only
  - name: encoder
    default: None
    rest: false
    kind: kw-only
  - name: models_as_dict
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.parse_file
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: path
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.parse_obj
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.parse_raw
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.schema
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: by_alias
    default: 'True'
    rest: false
  - kind: positional
    name: ref_template
    default: '#/definitions/{model}'
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.schema_json
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: by_alias
    default: 'True'
    rest: false
    kind: kw-only
  - name: ref_template
    default: '#/definitions/{model}'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: BaseModel.update_forward_refs
  kind: function
  ns: pydantic.v1
  description: Try to update ForwardRefs on fields based on this Model, globalns and localns.
  summary: Try to update ForwardRefs on fields based on this Model, globalns and localns
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: BaseModel.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: create_model
  kind: function
  ns: pydantic.v1
  description: |-
    Dynamically create a model.
    :param __model_name: name of the created model
    :param __config__: config class to use for the new model
    :param __base__: base class for the new model to inherit from
    :param __module__: module of the created model
    :param __validators__: a dict of method names and @validator class methods
    :param __cls_kwargs__: a dict for class creation
    :param __slots__: Deprecated, `__slots__` should not be passed to `create_model`
    :param field_definitions: fields of the model (or extra fields if a base is supplied)
        in the format `<name>=(<type>, <default default>)` or `<name>=<default value>, e.g.
        `foobar=(str, ...)` or `foobar=123`, or, for complex use-cases, in the format
        `<name>=<Field>` or `<name>=(<type>, <FieldInfo>)`, e.g.
        `foo=Field(datetime, default_factory=datetime.utcnow, alias='bar')` or
        `foo=(str, FieldInfo(title='Foo'))`
  summary: Dynamically create a model
  signatures:
  - kind: positional
    name: __model_name
    default: null
    rest: false
  - name: __config__
    default: None
    rest: false
    kind: kw-only
  - name: __base__
    default: None
    rest: false
    kind: kw-only
  - name: __module__
    default: pydantic.v1.main
    rest: false
    kind: kw-only
  - name: __validators__
    default: None
    rest: false
    kind: kw-only
  - name: __cls_kwargs__
    default: None
    rest: false
    kind: kw-only
  - name: __slots__
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: validate_model
  kind: function
  ns: pydantic.v1
  description: validate data against a model.
  summary: validate data against a model
  signatures:
  - kind: positional
    name: model
    default: null
    rest: false
  - kind: positional
    name: input_data
    default: null
    rest: false
  - kind: positional
    name: cls
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: AnyUrl
  inherits_from:
  - <class 'str'>
- name: AnyUrl.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: AnyUrl.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: AnyUrl.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyUrl.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: AnyUrl.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: AnyUrl.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyUrl.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyUrl.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyUrl.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyUrl.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyUrl.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyUrl.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: AnyHttpUrl
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: AnyHttpUrl.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AnyHttpUrl.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: AnyHttpUrl.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: FileUrl
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: FileUrl.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: FileUrl.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: FileUrl.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: FileUrl.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: FileUrl.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: FileUrl.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: FileUrl.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: FileUrl.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: FileUrl.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: FileUrl.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FileUrl.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: FileUrl.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: FileUrl.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: HttpUrl
  inherits_from:
  - <class 'pydantic.v1.networks.AnyHttpUrl'>
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: HttpUrl.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: HttpUrl.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: HttpUrl.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: HttpUrl.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: HttpUrl.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: HttpUrl.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: HttpUrl.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: HttpUrl.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: HttpUrl.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: HttpUrl.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: HttpUrl.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: HttpUrl.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: HttpUrl.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: stricturl
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: strip_whitespace
    default: 'True'
    rest: false
    kind: kw-only
  - name: min_length
    default: '1'
    rest: false
    kind: kw-only
  - name: max_length
    default: '65536'
    rest: false
    kind: kw-only
  - name: tld_required
    default: 'True'
    rest: false
    kind: kw-only
  - name: host_required
    default: 'True'
    rest: false
    kind: kw-only
  - name: allowed_schemes
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: EmailStr
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from:
  - <class 'str'>
- name: EmailStr.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: EmailStr.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: EmailStr.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NameEmail
  kind: class
  ns: pydantic.v1
  description: |-
    Mixin to provide __str__, __repr__, and __pretty__ methods. See #884 for more details.

    __pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations
    of objects.
  summary: Mixin to provide __str__, __repr__, and __pretty__ methods
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - kind: positional
    name: email
    default: null
    rest: false
  - type: NameEmail
  inherits_from:
  - <class 'pydantic.v1.utils.Representation'>
- name: NameEmail.email
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NameEmail.name
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NameEmail.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyAddress
  kind: class
  ns: pydantic.v1
  description: |-
    A generic IP object.

    This IP class contains the version independent methods which are
    used by single IP addresses.
  summary: A generic IP object
  signatures:
  - type: IPvAnyAddress
  inherits_from:
  - <class 'ipaddress._BaseAddress'>
  - <class 'ipaddress._IPAddressBase'>
- name: IPvAnyAddress.compressed
  kind: property
  ns: pydantic.v1
  description: Return the shorthand version of the IP address as a string.
  summary: Return the shorthand version of the IP address as a string
  signatures: null
  inherits_from: null
- name: IPvAnyAddress.exploded
  kind: property
  ns: pydantic.v1
  description: Return the longhand version of the IP address as a string.
  summary: Return the longhand version of the IP address as a string
  signatures: null
  inherits_from: null
- name: IPvAnyAddress.reverse_pointer
  kind: property
  ns: pydantic.v1
  description: |-
    The name of the reverse DNS pointer for the IP address, e.g.:
    >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
    '1.0.0.127.in-addr.arpa'
    >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
    '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
  summary: The name of the reverse DNS pointer for the IP address, e
  signatures: null
  inherits_from: null
- name: IPvAnyAddress.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyAddress.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyInterface
  kind: class
  ns: pydantic.v1
  description: |-
    A generic IP object.

    This IP class contains the version independent methods which are
    used by single IP addresses.
  summary: A generic IP object
  signatures:
  - type: IPvAnyInterface
  inherits_from:
  - <class 'ipaddress._BaseAddress'>
  - <class 'ipaddress._IPAddressBase'>
- name: IPvAnyInterface.compressed
  kind: property
  ns: pydantic.v1
  description: Return the shorthand version of the IP address as a string.
  summary: Return the shorthand version of the IP address as a string
  signatures: null
  inherits_from: null
- name: IPvAnyInterface.exploded
  kind: property
  ns: pydantic.v1
  description: Return the longhand version of the IP address as a string.
  summary: Return the longhand version of the IP address as a string
  signatures: null
  inherits_from: null
- name: IPvAnyInterface.reverse_pointer
  kind: property
  ns: pydantic.v1
  description: |-
    The name of the reverse DNS pointer for the IP address, e.g.:
    >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
    '1.0.0.127.in-addr.arpa'
    >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
    '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
  summary: The name of the reverse DNS pointer for the IP address, e
  signatures: null
  inherits_from: null
- name: IPvAnyInterface.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyInterface.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork
  kind: class
  ns: pydantic.v1
  description: |-
    A generic IP network object.

    This IP class contains the version independent methods which are
    used by networks.
  summary: A generic IP network object
  signatures:
  - type: IPvAnyNetwork
  inherits_from:
  - <class 'ipaddress._BaseNetwork'>
  - <class 'ipaddress._IPAddressBase'>
- name: IPvAnyNetwork.address_exclude
  kind: method
  ns: pydantic.v1
  description: |-
    Remove an address from a larger block.

    For example:

        addr1 = ip_network('192.0.2.0/28')
        addr2 = ip_network('192.0.2.1/32')
        list(addr1.address_exclude(addr2)) =
            [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),
             IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]

    or IPv6:

        addr1 = ip_network('2001:db8::1/32')
        addr2 = ip_network('2001:db8::1/128')
        list(addr1.address_exclude(addr2)) =
            [ip_network('2001:db8::1/128'),
             ip_network('2001:db8::2/127'),
             ip_network('2001:db8::4/126'),
             ip_network('2001:db8::8/125'),
             ...
             ip_network('2001:db8:8000::/33')]

    Args:
        other: An IPv4Network or IPv6Network object of the same type.

    Returns:
        An iterator of the IPv(4|6)Network objects which is self
        minus other.

    Raises:
        TypeError: If self and other are of differing address
          versions, or if other is not a network object.
        ValueError: If other is not completely contained by self.
  summary: Remove an address from a larger block
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.broadcast_address
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.compare_networks
  kind: method
  ns: pydantic.v1
  description: |-
    Compare two IP objects.

    This is only concerned about the comparison of the integer
    representation of the network addresses.  This means that the
    host bits aren't considered at all in this method.  If you want
    to compare host bits, you can easily enough do a
    'HostA._ip < HostB._ip'

    Args:
        other: An IP object.

    Returns:
        If the IP versions of self and other are the same, returns:

        -1 if self < other:
          eg: IPv4Network('192.0.2.0/25') < IPv4Network('192.0.2.128/25')
          IPv6Network('2001:db8::1000/124') <
              IPv6Network('2001:db8::2000/124')
        0 if self == other
          eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')
          IPv6Network('2001:db8::1000/124') ==
              IPv6Network('2001:db8::1000/124')
        1 if self > other
          eg: IPv4Network('192.0.2.128/25') > IPv4Network('192.0.2.0/25')
              IPv6Network('2001:db8::2000/124') >
                  IPv6Network('2001:db8::1000/124')

      Raises:
          TypeError if the IP versions are different.
  summary: Compare two IP objects
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.compressed
  kind: property
  ns: pydantic.v1
  description: Return the shorthand version of the IP address as a string.
  summary: Return the shorthand version of the IP address as a string
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.exploded
  kind: property
  ns: pydantic.v1
  description: Return the longhand version of the IP address as a string.
  summary: Return the longhand version of the IP address as a string
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.hostmask
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.hosts
  kind: method
  ns: pydantic.v1
  description: |-
    Generate Iterator over usable hosts in a network.

    This is like __iter__ except it doesn't return the network
    or broadcast addresses.
  summary: Generate Iterator over usable hosts in a network
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.is_global
  kind: property
  ns: pydantic.v1
  description: |-
    Test if this address is allocated for public networks.

    Returns:
        A boolean, True if the address is not reserved per
        iana-ipv4-special-registry or iana-ipv6-special-registry.
  summary: Test if this address is allocated for public networks
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.is_link_local
  kind: property
  ns: pydantic.v1
  description: |-
    Test if the address is reserved for link-local.

    Returns:
        A boolean, True if the address is reserved per RFC 4291.
  summary: Test if the address is reserved for link-local
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.is_loopback
  kind: property
  ns: pydantic.v1
  description: |-
    Test if the address is a loopback address.

    Returns:
        A boolean, True if the address is a loopback address as defined in
        RFC 2373 2.5.3.
  summary: Test if the address is a loopback address
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.is_multicast
  kind: property
  ns: pydantic.v1
  description: |-
    Test if the address is reserved for multicast use.

    Returns:
        A boolean, True if the address is a multicast address.
        See RFC 2373 2.7 for details.
  summary: Test if the address is reserved for multicast use
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.is_private
  kind: property
  ns: pydantic.v1
  description: |-
    Test if this network belongs to a private range.

    Returns:
        A boolean, True if the network is reserved per
        iana-ipv4-special-registry or iana-ipv6-special-registry.
  summary: Test if this network belongs to a private range
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.is_reserved
  kind: property
  ns: pydantic.v1
  description: |-
    Test if the address is otherwise IETF reserved.

    Returns:
        A boolean, True if the address is within one of the
        reserved IPv6 Network ranges.
  summary: Test if the address is otherwise IETF reserved
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.is_unspecified
  kind: property
  ns: pydantic.v1
  description: |-
    Test if the address is unspecified.

    Returns:
        A boolean, True if this is the unspecified address as defined in
        RFC 2373 2.5.2.
  summary: Test if the address is unspecified
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.num_addresses
  kind: property
  ns: pydantic.v1
  description: Number of hosts in the current subnet.
  summary: Number of hosts in the current subnet
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.overlaps
  kind: method
  ns: pydantic.v1
  description: Tell if self is partly contained in other.
  summary: Tell if self is partly contained in other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.prefixlen
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.reverse_pointer
  kind: property
  ns: pydantic.v1
  description: |-
    The name of the reverse DNS pointer for the IP address, e.g.:
    >>> ipaddress.ip_address("127.0.0.1").reverse_pointer
    '1.0.0.127.in-addr.arpa'
    >>> ipaddress.ip_address("2001:db8::1").reverse_pointer
    '1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'
  summary: The name of the reverse DNS pointer for the IP address, e
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.subnet_of
  kind: method
  ns: pydantic.v1
  description: Return True if this network is a subnet of other.
  summary: Return True if this network is a subnet of other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.subnets
  kind: method
  ns: pydantic.v1
  description: |-
    The subnets which join to make the current subnet.

    In the case that self contains only one IP
    (self._prefixlen == 32 for IPv4 or self._prefixlen == 128
    for IPv6), yield an iterator with just ourself.

    Args:
        prefixlen_diff: An integer, the amount the prefix length
          should be increased by. This should not be set if
          new_prefix is also set.
        new_prefix: The desired new prefix length. This must be a
          larger number (smaller prefix) than the existing prefix.
          This should not be set if prefixlen_diff is also set.

    Returns:
        An iterator of IPv(4|6) objects.

    Raises:
        ValueError: The prefixlen_diff is too small or too large.
            OR
        prefixlen_diff and new_prefix are both set or new_prefix
          is a smaller number than the current prefix (smaller
          number means a larger network)
  summary: The subnets which join to make the current subnet
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefixlen_diff
    default: '1'
    rest: false
  - kind: positional
    name: new_prefix
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.supernet
  kind: method
  ns: pydantic.v1
  description: |-
    The supernet containing the current network.

    Args:
        prefixlen_diff: An integer, the amount the prefix length of
          the network should be decreased by.  For example, given a
          /24 network and a prefixlen_diff of 3, a supernet with a
          /21 netmask is returned.

    Returns:
        An IPv4 network object.

    Raises:
        ValueError: If self.prefixlen - prefixlen_diff < 0. I.e., you have
          a negative prefix length.
            OR
        If prefixlen_diff and new_prefix are both set or new_prefix is a
          larger number than the current prefix (larger number means a
          smaller network)
  summary: The supernet containing the current network
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefixlen_diff
    default: '1'
    rest: false
  - kind: positional
    name: new_prefix
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.supernet_of
  kind: method
  ns: pydantic.v1
  description: Return True if this network is a supernet of other.
  summary: Return True if this network is a supernet of other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: IPvAnyNetwork.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.with_hostmask
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.with_netmask
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: IPvAnyNetwork.with_prefixlen
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: hosts
    default: None
    rest: false
    kind: kw-only
  - type: PostgresDsn
  inherits_from:
  - <class 'pydantic.v1.networks.MultiHostDsn'>
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: PostgresDsn.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: PostgresDsn.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PostgresDsn.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: PostgresDsn.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PostgresDsn.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.hosts
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PostgresDsn.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PostgresDsn.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: PostgresDsn.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PostgresDsn.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PostgresDsn.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PostgresDsn.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PostgresDsn.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: PostgresDsn.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: CockroachDsn
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: CockroachDsn.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: CockroachDsn.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: CockroachDsn.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: CockroachDsn.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: CockroachDsn.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: CockroachDsn.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: CockroachDsn.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: CockroachDsn.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: CockroachDsn.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: CockroachDsn.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: CockroachDsn.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: CockroachDsn.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: CockroachDsn.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: AmqpDsn
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: AmqpDsn.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: AmqpDsn.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: AmqpDsn.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: AmqpDsn.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AmqpDsn.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: AmqpDsn.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: AmqpDsn.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: AmqpDsn.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AmqpDsn.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AmqpDsn.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: AmqpDsn.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: AmqpDsn.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: AmqpDsn.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: RedisDsn
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: RedisDsn.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: RedisDsn.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: RedisDsn.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: RedisDsn.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: RedisDsn.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: RedisDsn.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: RedisDsn.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: RedisDsn.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: RedisDsn.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: RedisDsn.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: RedisDsn.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: RedisDsn.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: RedisDsn.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: MongoDsn
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: MongoDsn.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: MongoDsn.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: MongoDsn.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: MongoDsn.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: MongoDsn.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: MongoDsn.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: MongoDsn.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: MongoDsn.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: MongoDsn.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: MongoDsn.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: MongoDsn.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: MongoDsn.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: MongoDsn.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: url
    default: null
    rest: false
  - type: KafkaDsn
  inherits_from:
  - <class 'pydantic.v1.networks.AnyUrl'>
  - <class 'str'>
- name: KafkaDsn.allowed_schemes
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: KafkaDsn.apply_default_parts
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.build
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - name: scheme
    default: null
    rest: false
    kind: kw-only
  - name: user
    default: None
    rest: false
    kind: kw-only
  - name: password
    default: None
    rest: false
    kind: kw-only
  - name: host
    default: null
    rest: false
    kind: kw-only
  - name: port
    default: None
    rest: false
    kind: kw-only
  - name: path
    default: None
    rest: false
    kind: kw-only
  - name: query
    default: None
    rest: false
    kind: kw-only
  - name: fragment
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: KafkaDsn.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.fragment
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.get_default_parts
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.hidden_parts
  kind: property
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from: null
- name: KafkaDsn.host
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.host_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: KafkaDsn.host_type
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: KafkaDsn.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: KafkaDsn.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.password
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.path
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.port
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.query
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.scheme
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: KafkaDsn.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: KafkaDsn.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.tld
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.tld_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: KafkaDsn.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.user
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: KafkaDsn.user_required
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: KafkaDsn.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: field
    default: null
    rest: false
  - kind: positional
    name: config
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.validate_host
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.validate_parts
  kind: function
  ns: pydantic.v1
  description: |-
    A method used to validate parts of a URL.
    Could be overridden to set default values for parts if missing
  summary: A method used to validate parts of a URL
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: parts
    default: null
    rest: false
  - kind: positional
    name: validate_port
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: KafkaDsn.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: validate_email
  kind: function
  ns: pydantic.v1
  description: |-
    Email address validation using https://pypi.org/project/email-validator/
    Notes:
    * raw ip address (literal) domain parts are not allowed.
    * "John Doe <local_part@domain.com>" style "pretty" email addresses are processed
    * spaces are striped from the beginning and end of addresses but no error is raised
  summary: Email address validation using https://pypi
  signatures:
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: names
    default: None
    rest: false
  - name: module
    default: None
    rest: false
    kind: kw-only
  - name: qualname
    default: None
    rest: false
    kind: kw-only
  - name: type
    default: None
    rest: false
    kind: kw-only
  - name: start
    default: '1'
    rest: false
    kind: kw-only
  - name: boundary
    default: None
    rest: false
    kind: kw-only
  - type: Protocol
  inherits_from:
  - <class 'str'>
  - <enum 'Enum'>
- name: Protocol.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.json
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Protocol.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.name
  kind: property
  ns: pydantic.v1
  description: The name of the Enum member.
  summary: The name of the Enum member
  signatures: null
  inherits_from: null
- name: Protocol.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.pickle
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: Protocol.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: Protocol.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: Protocol.value
  kind: property
  ns: pydantic.v1
  description: The value of the Enum member.
  summary: The value of the Enum member
  signatures: null
  inherits_from: null
- name: Protocol.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: parse_file_as
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - kind: positional
    name: path
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - name: json_loads
    default: <function loads at 0x7fe72ae86de0>
    rest: false
    kind: kw-only
  - name: type_name
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: parse_obj_as
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - kind: positional
    name: obj
    default: null
    rest: false
  - name: type_name
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: parse_raw_as
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - kind: positional
    name: b
    default: null
    rest: false
  - name: content_type
    default: None
    rest: false
    kind: kw-only
  - name: encoding
    default: utf8
    rest: false
    kind: kw-only
  - name: proto
    default: None
    rest: false
    kind: kw-only
  - name: allow_pickle
    default: 'False'
    rest: false
    kind: kw-only
  - name: json_loads
    default: <function loads at 0x7fe72ae86de0>
    rest: false
    kind: kw-only
  - name: type_name
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: schema_of
  kind: function
  ns: pydantic.v1
  description: Generate a JSON schema (as dict) for the passed model or dynamically generated one
  summary: Generate a JSON schema (as dict) for the passed model or dynamically generated one
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - name: title
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: schema_json_of
  kind: function
  ns: pydantic.v1
  description: Generate a JSON schema (as JSON) for the passed model or dynamically generated one
  summary: Generate a JSON schema (as JSON) for the passed model or dynamically generated one
  signatures:
  - kind: positional
    name: type_
    default: null
    rest: false
  - name: title
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: NoneStr
  kind: callable
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NoneBytes
  kind: callable
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrBytes
  kind: callable
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NoneStrBytes
  kind: callable
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedStr'>
  - <class 'str'>
- name: StrictStr.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.curtail_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictStr.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.max_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictStr.min_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictStr.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.regex
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictStr.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: StrictStr.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictStr.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictStr.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.to_lower
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictStr.to_upper
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictStr.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictStr.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes
  kind: class
  ns: pydantic.v1
  description: |-
    bytes(iterable_of_ints) -> bytes
    bytes(string, encoding[, errors]) -> bytes
    bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
    bytes(int) -> bytes object of size given by the parameter initialized with null bytes
    bytes() -> empty bytes object

    Construct an immutable array of bytes from:
      - an iterable yielding integers in range(256)
      - a text string encoded using the specified encoding
      - any object implementing the buffer API.
      - an integer
  summary: bytes(iterable_of_ints) -> bytes
  signatures: null
  inherits_from:
  - <class 'bytes'>
- name: ConstrainedBytes.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    B.capitalize() -> copy of B

    Return a copy of B with only its first character capitalized (ASCII)
    and the rest lower-cased.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character.
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: b' '
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.count
  kind: callable
  ns: pydantic.v1
  description: |-
    B.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of subsection sub in
    bytes B[start:end].  Optional arguments start and end are interpreted
    as in slice notation.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.decode
  kind: callable
  ns: pydantic.v1
  description: |-
    Decode the bytes using the codec registered for encoding.

    encoding
      The encoding with which to decode the bytes.
    errors
      The error handling scheme to use for the handling of decoding errors.
      The default is 'strict' meaning that decoding errors raise a
      UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
      as well as any other name registered with codecs.register_error that
      can handle UnicodeDecodeErrors.
  summary: Decode the bytes using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    B.endswith(suffix[, start[, end]]) -> bool

    Return True if B ends with the specified suffix, False otherwise.
    With optional start, test B beginning at that position.
    With optional end, stop comparing B at that position.
    suffix can also be a tuple of bytes to try.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.find
  kind: callable
  ns: pydantic.v1
  description: |-
    B.find(sub[, start[, end]]) -> int

    Return the lowest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Create a string of hexadecimal numbers from a bytes object.

      sep
        An optional single character or byte to separate hex bytes.
      bytes_per_sep
        How many bytes between separators.  Positive values count from the
        right, negative values count from the left.

    Example:
    >>> value = b'\xb9\x01\xef'
    >>> value.hex()
    'b901ef'
    >>> value.hex(':')
    'b9:01:ef'
    >>> value.hex(':', 2)
    'b9:01ef'
    >>> value.hex(':', -2)
    'b901:ef'
  summary: Create a string of hexadecimal numbers from a bytes object
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.index
  kind: callable
  ns: pydantic.v1
  description: |-
    B.index(sub[, start[, end]]) -> int

    Return the lowest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the subsection is not found.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isalnum() -> bool

    Return True if all characters in B are alphanumeric
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isalpha() -> bool

    Return True if all characters in B are alphabetic
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isascii() -> bool

    Return True if B is empty or all characters in B are ASCII,
    False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isdigit() -> bool

    Return True if all characters in B are digits
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    B.islower() -> bool

    Return True if all cased characters in B are lowercase and there is
    at least one cased character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isspace() -> bool

    Return True if all characters in B are whitespace
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    B.istitle() -> bool

    Return True if B is a titlecased string and there is at least one
    character in B, i.e. uppercase characters may only follow uncased
    characters and lowercase characters only cased ones. Return False
    otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isupper() -> bool

    Return True if all cased characters in B are uppercase and there is
    at least one cased character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of bytes objects.

    The bytes whose method is called is inserted in between each pair.

    The result is returned as a new bytes object.

    Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.
  summary: Concatenate any number of bytes objects
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable_of_bytes
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character.
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: b' '
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.lower
  kind: callable
  ns: pydantic.v1
  description: |-
    B.lower() -> copy of B

    Return a copy of B with all ASCII characters converted to lowercase.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Strip leading bytes contained in the argument.

    If the argument is omitted or None, strip leading  ASCII whitespace.
  summary: Strip leading bytes contained in the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.max_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.min_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the bytes into three parts using the given separator.

    This will search for the separator sep in the bytes. If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original bytes
    object and two empty bytes objects.
  summary: Partition the bytes into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a bytes object with the given prefix string removed if present.

    If the bytes starts with the prefix string, return bytes[len(prefix):].
    Otherwise, return a copy of the original bytes.
  summary: Return a bytes object with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a bytes object with the given suffix string removed if present.

    If the bytes ends with the suffix string and that suffix is not empty,
    return bytes[:-len(prefix)].  Otherwise, return a copy of the original
    bytes.
  summary: Return a bytes object with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    B.rfind(sub[, start[, end]]) -> int

    Return the highest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    B.rindex(sub[, start[, end]]) -> int

    Return the highest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raise ValueError when the subsection is not found.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character.
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: b' '
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the bytes into three parts using the given separator.

    This will search for the separator sep in the bytes, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty bytes
    objects and the original bytes object.
  summary: Partition the bytes into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the sections in the bytes, using sep as the delimiter.

      sep
        The delimiter according which to split the bytes.
        None (the default value) means split on ASCII whitespace characters
        (space, tab, return, newline, formfeed, vertical tab).
      maxsplit
        Maximum number of splits to do.
        -1 (the default value) means no limit.

    Splitting is done starting at the end of the bytes and working to the front.
  summary: Return a list of the sections in the bytes, using sep as the delimiter
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Strip trailing bytes contained in the argument.

    If the argument is omitted or None, strip trailing ASCII whitespace.
  summary: Strip trailing bytes contained in the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the sections in the bytes, using sep as the delimiter.

    sep
      The delimiter according which to split the bytes.
      None (the default value) means split on ASCII whitespace characters
      (space, tab, return, newline, formfeed, vertical tab).
    maxsplit
      Maximum number of splits to do.
      -1 (the default value) means no limit.
  summary: Return a list of the sections in the bytes, using sep as the delimiter
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the bytes, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the bytes, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    B.startswith(prefix[, start[, end]]) -> bool

    Return True if B starts with the specified prefix, False otherwise.
    With optional start, test B beginning at that position.
    With optional end, stop comparing B at that position.
    prefix can also be a tuple of bytes to try.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Strip leading and trailing bytes contained in the argument.

    If the argument is omitted or None, strip leading and trailing ASCII whitespace.
  summary: Strip leading and trailing bytes contained in the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.swapcase
  kind: callable
  ns: pydantic.v1
  description: |-
    B.swapcase() -> copy of B

    Return a copy of B with uppercase ASCII characters converted
    to lowercase ASCII and vice versa.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.title
  kind: callable
  ns: pydantic.v1
  description: |-
    B.title() -> copy of B

    Return a titlecased version of B, i.e. ASCII words start with uppercase
    characters, all remaining cased characters have lowercase.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.to_lower
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.to_upper
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with each character mapped by the given translation table.

      table
        Translation table, which must be a bytes object of length 256.

    All characters occurring in the optional argument delete are removed.
    The remaining characters are mapped through the given translation table.
  summary: Return a copy with each character mapped by the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - kind: positional
    name: delete
    default: b''
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedBytes.upper
  kind: callable
  ns: pydantic.v1
  description: |-
    B.upper() -> copy of B

    Return a copy of B with all ASCII characters converted to uppercase.
  summary: B
  signatures: null
  inherits_from: null
- name: ConstrainedBytes.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The original string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: conbytes
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: strip_whitespace
    default: 'False'
    rest: false
    kind: kw-only
  - name: to_upper
    default: 'False'
    rest: false
    kind: kw-only
  - name: to_lower
    default: 'False'
    rest: false
    kind: kw-only
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: strict
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedList
  kind: class
  ns: pydantic.v1
  description: |-
    Built-in mutable sequence.

    If no argument is given, the constructor creates a new empty list.
    The argument must be an iterable if specified.
  summary: Built-in mutable sequence
  signatures:
  - kind: positional
    name: iterable
    default: ()
    rest: false
  - type: ConstrainedList
  inherits_from:
  - <class 'list'>
- name: ConstrainedList.append
  kind: callable
  ns: pydantic.v1
  description: Append object to the end of the list.
  summary: Append object to the end of the list
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: object
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.clear
  kind: callable
  ns: pydantic.v1
  description: Remove all items from list.
  summary: Remove all items from list
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.copy
  kind: callable
  ns: pydantic.v1
  description: Return a shallow copy of the list.
  summary: Return a shallow copy of the list
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.count
  kind: callable
  ns: pydantic.v1
  description: Return number of occurrences of value.
  summary: Return number of occurrences of value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.extend
  kind: callable
  ns: pydantic.v1
  description: Extend list by appending elements from the iterable.
  summary: Extend list by appending elements from the iterable
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.index
  kind: callable
  ns: pydantic.v1
  description: |-
    Return first index of value.

    Raises ValueError if the value is not present.
  summary: Return first index of value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - kind: positional
    name: start
    default: '0'
    rest: false
  - kind: positional
    name: stop
    default: '9223372036854775807'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.insert
  kind: callable
  ns: pydantic.v1
  description: Insert object before index.
  summary: Insert object before index
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: index
    default: null
    rest: false
  - kind: positional
    name: object
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.list_length_validator
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: v
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.max_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedList.min_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedList.pop
  kind: callable
  ns: pydantic.v1
  description: |-
    Remove and return item at index (default last).

    Raises IndexError if list is empty or index is out of range.
  summary: Remove and return item at index (default last)
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: index
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.remove
  kind: callable
  ns: pydantic.v1
  description: |-
    Remove first occurrence of value.

    Raises ValueError if the value is not present.
  summary: Remove first occurrence of value
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.reverse
  kind: callable
  ns: pydantic.v1
  description: Reverse *IN PLACE*.
  summary: Reverse *IN PLACE*
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedList.sort
  kind: callable
  ns: pydantic.v1
  description: |-
    Sort the list in ascending order and return None.

    The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
    order of two equal elements is maintained).

    If a key function is given, apply it once to each list item and sort them,
    ascending or descending, according to their function values.

    The reverse flag can be set to sort in descending order.
  summary: Sort the list in ascending order and return None
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: key
    default: None
    rest: false
    kind: kw-only
  - name: reverse
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedList.unique_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedList.unique_items_validator
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: v
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: conlist
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_items
    default: None
    rest: false
    kind: kw-only
  - name: max_items
    default: None
    rest: false
    kind: kw-only
  - name: unique_items
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedSet
  kind: class
  ns: pydantic.v1
  description: |-
    set() -> new empty set object
    set(iterable) -> new set object

    Build an unordered collection of unique elements.
  summary: set() -> new empty set object
  signatures: null
  inherits_from:
  - <class 'set'>
- name: ConstrainedSet.add
  kind: callable
  ns: pydantic.v1
  description: |-
    Add an element to a set.

    This has no effect if the element is already present.
  summary: Add an element to a set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.clear
  kind: callable
  ns: pydantic.v1
  description: Remove all elements from this set.
  summary: Remove all elements from this set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.copy
  kind: callable
  ns: pydantic.v1
  description: Return a shallow copy of a set.
  summary: Return a shallow copy of a set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.difference
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the difference of two or more sets as a new set.

    (i.e. all elements that are in this set but not the others.)
  summary: Return the difference of two or more sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.difference_update
  kind: callable
  ns: pydantic.v1
  description: Remove all elements of another set from this set.
  summary: Remove all elements of another set from this set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.discard
  kind: callable
  ns: pydantic.v1
  description: |-
    Remove an element from a set if it is a member.

    Unlike set.remove(), the discard() method does not raise
    an exception when an element is missing from the set.
  summary: Remove an element from a set if it is a member
  signatures: null
  inherits_from: null
- name: ConstrainedSet.intersection
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the intersection of two sets as a new set.

    (i.e. all elements that are in both sets.)
  summary: Return the intersection of two sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.intersection_update
  kind: callable
  ns: pydantic.v1
  description: Update a set with the intersection of itself and another.
  summary: Update a set with the intersection of itself and another
  signatures: null
  inherits_from: null
- name: ConstrainedSet.isdisjoint
  kind: callable
  ns: pydantic.v1
  description: Return True if two sets have a null intersection.
  summary: Return True if two sets have a null intersection
  signatures: null
  inherits_from: null
- name: ConstrainedSet.issubset
  kind: callable
  ns: pydantic.v1
  description: Test whether every element in the set is in other.
  summary: Test whether every element in the set is in other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedSet.issuperset
  kind: callable
  ns: pydantic.v1
  description: Test whether every element in other is in the set.
  summary: Test whether every element in other is in the set
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedSet.max_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedSet.min_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedSet.pop
  kind: callable
  ns: pydantic.v1
  description: |-
    Remove and return an arbitrary set element.
    Raises KeyError if the set is empty.
  summary: Remove and return an arbitrary set element
  signatures: null
  inherits_from: null
- name: ConstrainedSet.remove
  kind: callable
  ns: pydantic.v1
  description: |-
    Remove an element from a set; it must be a member.

    If the element is not a member, raise a KeyError.
  summary: Remove an element from a set; it must be a member
  signatures: null
  inherits_from: null
- name: ConstrainedSet.set_length_validator
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: v
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedSet.symmetric_difference
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the symmetric difference of two sets as a new set.

    (i.e. all elements that are in exactly one of the sets.)
  summary: Return the symmetric difference of two sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.symmetric_difference_update
  kind: callable
  ns: pydantic.v1
  description: Update a set with the symmetric difference of itself and another.
  summary: Update a set with the symmetric difference of itself and another
  signatures: null
  inherits_from: null
- name: ConstrainedSet.union
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the union of sets as a new set.

    (i.e. all elements that are in either set.)
  summary: Return the union of sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedSet.update
  kind: callable
  ns: pydantic.v1
  description: Update a set with the union of itself and others.
  summary: Update a set with the union of itself and others
  signatures: null
  inherits_from: null
- name: conset
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_items
    default: None
    rest: false
    kind: kw-only
  - name: max_items
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedFrozenSet
  kind: class
  ns: pydantic.v1
  description: |-
    frozenset() -> empty frozenset object
    frozenset(iterable) -> frozenset object

    Build an immutable unordered collection of unique elements.
  summary: frozenset() -> empty frozenset object
  signatures: null
  inherits_from:
  - <class 'frozenset'>
- name: ConstrainedFrozenSet.copy
  kind: callable
  ns: pydantic.v1
  description: Return a shallow copy of a set.
  summary: Return a shallow copy of a set
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.difference
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the difference of two or more sets as a new set.

    (i.e. all elements that are in this set but not the others.)
  summary: Return the difference of two or more sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.frozenset_length_validator
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: v
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFrozenSet.intersection
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the intersection of two sets as a new set.

    (i.e. all elements that are in both sets.)
  summary: Return the intersection of two sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.isdisjoint
  kind: callable
  ns: pydantic.v1
  description: Return True if two sets have a null intersection.
  summary: Return True if two sets have a null intersection
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.issubset
  kind: callable
  ns: pydantic.v1
  description: Test whether every element in the set is in other.
  summary: Test whether every element in the set is in other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFrozenSet.issuperset
  kind: callable
  ns: pydantic.v1
  description: Test whether every element in other is in the set.
  summary: Test whether every element in other is in the set
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFrozenSet.max_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.min_items
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.symmetric_difference
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the symmetric difference of two sets as a new set.

    (i.e. all elements that are in exactly one of the sets.)
  summary: Return the symmetric difference of two sets as a new set
  signatures: null
  inherits_from: null
- name: ConstrainedFrozenSet.union
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the union of sets as a new set.

    (i.e. all elements that are in either set.)
  summary: Return the union of sets as a new set
  signatures: null
  inherits_from: null
- name: confrozenset
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: item_type
    default: null
    rest: false
  - name: min_items
    default: None
    rest: false
    kind: kw-only
  - name: max_items
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedStr
  kind: class
  ns: pydantic.v1
  description: |-
    str(object='') -> str
    str(bytes_or_buffer[, encoding[, errors]]) -> str

    Create a new string object from the given object. If encoding or
    errors is specified, then the object must expose a data buffer
    that will be decoded using the given encoding and error handler.
    Otherwise, returns the result of object.__str__() (if defined)
    or repr(object).
    encoding defaults to sys.getdefaultencoding().
    errors defaults to 'strict'.
  summary: str(object='') -> str
  signatures: null
  inherits_from:
  - <class 'str'>
- name: ConstrainedStr.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.curtail_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedStr.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.max_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedStr.min_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedStr.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.regex
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedStr.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: ConstrainedStr.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedStr.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedStr.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.to_lower
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedStr.to_upper
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedStr.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedStr.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: constr
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: strip_whitespace
    default: 'False'
    rest: false
    kind: kw-only
  - name: to_upper
    default: 'False'
    rest: false
    kind: kw-only
  - name: to_lower
    default: 'False'
    rest: false
    kind: kw-only
  - name: strict
    default: 'False'
    rest: false
    kind: kw-only
  - name: min_length
    default: None
    rest: false
    kind: kw-only
  - name: max_length
    default: None
    rest: false
    kind: kw-only
  - name: curtail_length
    default: None
    rest: false
    kind: kw-only
  - name: regex
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PyObject
  kind: class
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: PyObject
  inherits_from: null
- name: PyObject.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PyObject.validate_always
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedInt
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'int'>
- name: ConstrainedInt.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedInt.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedInt.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedInt.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: ConstrainedInt.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: ConstrainedInt.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedInt.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedInt.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: ConstrainedInt.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedInt.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedInt.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedInt.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: ConstrainedInt.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: ConstrainedInt.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedInt.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: conint
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: strict
    default: 'False'
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PositiveInt
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedInt'>
  - <class 'int'>
- name: PositiveInt.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveInt.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveInt.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveInt.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: PositiveInt.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: PositiveInt.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveInt.gt
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PositiveInt.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: PositiveInt.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveInt.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveInt.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveInt.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: PositiveInt.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: PositiveInt.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PositiveInt.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: NegativeInt
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedInt'>
  - <class 'int'>
- name: NegativeInt.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeInt.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeInt.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeInt.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: NegativeInt.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: NegativeInt.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeInt.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeInt.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: NegativeInt.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeInt.lt
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: NegativeInt.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeInt.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: NegativeInt.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: NegativeInt.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: NegativeInt.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: NonNegativeInt
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedInt'>
  - <class 'int'>
- name: NonNegativeInt.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeInt.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeInt.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeInt.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: NonNegativeInt.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: NonNegativeInt.ge
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: NonNegativeInt.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeInt.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: NonNegativeInt.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeInt.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeInt.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeInt.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: NonNegativeInt.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: NonNegativeInt.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: NonNegativeInt.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: NonPositiveInt
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedInt'>
  - <class 'int'>
- name: NonPositiveInt.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveInt.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveInt.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveInt.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: NonPositiveInt.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: NonPositiveInt.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveInt.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveInt.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: NonPositiveInt.le
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: NonPositiveInt.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveInt.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveInt.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: NonPositiveInt.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: NonPositiveInt.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: NonPositiveInt.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: ConstrainedFloat
  inherits_from:
  - <class 'float'>
- name: ConstrainedFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFloat.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedFloat.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: ConstrainedFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: confloat
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: strict
    default: 'False'
    rest: false
    kind: kw-only
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - name: allow_inf_nan
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: PositiveFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: PositiveFloat
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedFloat'>
  - <class 'float'>
- name: PositiveFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveFloat.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveFloat.gt
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PositiveFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: PositiveFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PositiveFloat.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveFloat.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PositiveFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: PositiveFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: NegativeFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: NegativeFloat
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedFloat'>
  - <class 'float'>
- name: NegativeFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeFloat.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeFloat.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: NegativeFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NegativeFloat.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeFloat.lt
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: NegativeFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NegativeFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: NegativeFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: NonNegativeFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: NonNegativeFloat
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedFloat'>
  - <class 'float'>
- name: NonNegativeFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeFloat.ge
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonNegativeFloat.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: NonNegativeFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: NonPositiveFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: NonPositiveFloat
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedFloat'>
  - <class 'float'>
- name: NonPositiveFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveFloat.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: NonPositiveFloat.le
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: NonPositiveFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: FiniteFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: FiniteFloat
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedFloat'>
  - <class 'float'>
- name: FiniteFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: FiniteFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FiniteFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FiniteFloat.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FiniteFloat.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FiniteFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FiniteFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: FiniteFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FiniteFloat.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FiniteFloat.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FiniteFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FiniteFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: FiniteFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal
  kind: class
  ns: pydantic.v1
  description: |-
    Construct a new Decimal object. 'value' can be an integer, string, tuple,
    or another Decimal object. If no value is given, return Decimal('0'). The
    context does not affect the conversion and is only passed to determine if
    the InvalidOperation trap is active.
  summary: Construct a new Decimal object
  signatures:
  - kind: positional
    name: value
    default: '0'
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: ConstrainedDecimal
  inherits_from:
  - <class 'decimal.Decimal'>
- name: ConstrainedDecimal.adjusted
  kind: callable
  ns: pydantic.v1
  description: Return the adjusted exponent of the number.  Defined as exp + digits - 1.
  summary: Return the adjusted exponent of the number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Decimal.as_integer_ratio() -> (int, int)

    Return a pair of integers, whose ratio is exactly equal to the original
    Decimal and with a positive denominator. The ratio is in lowest terms.
    Raise OverflowError on infinities and a ValueError on NaNs.
  summary: Decimal
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.as_tuple
  kind: callable
  ns: pydantic.v1
  description: Return a tuple representation of the number.
  summary: Return a tuple representation of the number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.canonical
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the canonical encoding of the argument.  Currently, the encoding
    of a Decimal instance is always canonical, so this operation returns its
    argument unchanged.
  summary: Return the canonical encoding of the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.compare
  kind: callable
  ns: pydantic.v1
  description: |-
    Compare self to other.  Return a decimal value:

    a or b is a NaN ==> Decimal('NaN')
    a < b           ==> Decimal('-1')
    a == b          ==> Decimal('0')
    a > b           ==> Decimal('1')
  summary: Compare self to other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.compare_signal
  kind: callable
  ns: pydantic.v1
  description: Identical to compare, except that all NaNs signal.
  summary: Identical to compare, except that all NaNs signal
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.compare_total
  kind: callable
  ns: pydantic.v1
  description: |-
    Compare two operands using their abstract representation rather than
    their numerical value.  Similar to the compare() method, but the result
    gives a total ordering on Decimal instances.  Two Decimal instances with
    the same numeric value but different representations compare unequal
    in this ordering:

        >>> Decimal('12.0').compare_total(Decimal('12'))
        Decimal('-1')

    Quiet and signaling NaNs are also included in the total ordering. The result
    of this function is Decimal('0') if both operands have the same representation,
    Decimal('-1') if the first operand is lower in the total order than the second,
    and Decimal('1') if the first operand is higher in the total order than the
    second operand. See the specification for details of the total order.

    This operation is unaffected by context and is quiet: no flags are changed
    and no rounding is performed. As an exception, the C version may raise
    InvalidOperation if the second operand cannot be converted exactly.
  summary: Compare two operands using their abstract representation rather than
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.compare_total_mag
  kind: callable
  ns: pydantic.v1
  description: |-
    Compare two operands using their abstract representation rather than their
    value as in compare_total(), but ignoring the sign of each operand.

    x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()).

    This operation is unaffected by context and is quiet: no flags are changed
    and no rounding is performed. As an exception, the C version may raise
    InvalidOperation if the second operand cannot be converted exactly.
  summary: Compare two operands using their abstract representation rather than their
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self.
  summary: Return self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.copy_abs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the absolute value of the argument.  This operation is unaffected by
    context and is quiet: no flags are changed and no rounding is performed.
  summary: Return the absolute value of the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.copy_negate
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the negation of the argument.  This operation is unaffected by context
    and is quiet: no flags are changed and no rounding is performed.
  summary: Return the negation of the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.copy_sign
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the first operand with the sign set to be the same as the
    sign of the second operand. For example:

        >>> Decimal('2.3').copy_sign(Decimal('-1.5'))
        Decimal('-2.3')

    This operation is unaffected by context and is quiet: no flags are changed
    and no rounding is performed. As an exception, the C version may raise
    InvalidOperation if the second operand cannot be converted exactly.
  summary: Return a copy of the first operand with the sign set to be the same as the
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.decimal_places
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.exp
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the value of the (natural) exponential function e**x at the given
    number.  The function always uses the ROUND_HALF_EVEN mode and the result
    is correctly rounded.
  summary: Return the value of the (natural) exponential function e**x at the given
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.fma
  kind: callable
  ns: pydantic.v1
  description: |-
    Fused multiply-add.  Return self*other+third with no rounding of the
    intermediate product self*other.

        >>> Decimal(2).fma(3, 5)
        Decimal('11')
  summary: Fused multiply-add
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: third
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.imag
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.is_canonical
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is canonical and False otherwise.  Currently,
    a Decimal instance is always canonical, so this operation always returns
    True.
  summary: Return True if the argument is canonical and False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_finite
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is a finite number, and False if the argument
    is infinite or a NaN.
  summary: Return True if the argument is a finite number, and False if the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_infinite
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is either positive or negative infinity and
    False otherwise.
  summary: Return True if the argument is either positive or negative infinity and
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_nan
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is a (quiet or signaling) NaN and False
    otherwise.
  summary: Return True if the argument is a (quiet or signaling) NaN and False
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_normal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is a normal finite non-zero number with an
    adjusted exponent greater than or equal to Emin. Return False if the
    argument is zero, subnormal, infinite or a NaN.
  summary: Return True if the argument is a normal finite non-zero number with an
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_qnan
  kind: callable
  ns: pydantic.v1
  description: Return True if the argument is a quiet NaN, and False otherwise.
  summary: Return True if the argument is a quiet NaN, and False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_signed
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument has a negative sign and False otherwise.
    Note that both zeros and NaNs can carry signs.
  summary: Return True if the argument has a negative sign and False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_snan
  kind: callable
  ns: pydantic.v1
  description: Return True if the argument is a signaling NaN and False otherwise.
  summary: Return True if the argument is a signaling NaN and False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_subnormal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is subnormal, and False otherwise. A number is
    subnormal if it is non-zero, finite, and has an adjusted exponent less
    than Emin.
  summary: Return True if the argument is subnormal, and False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.is_zero
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the argument is a (positive or negative) zero and False
    otherwise.
  summary: Return True if the argument is a (positive or negative) zero and False
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.ln
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the natural (base e) logarithm of the operand. The function always
    uses the ROUND_HALF_EVEN mode and the result is correctly rounded.
  summary: Return the natural (base e) logarithm of the operand
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.log10
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the base ten logarithm of the operand. The function always uses the
    ROUND_HALF_EVEN mode and the result is correctly rounded.
  summary: Return the base ten logarithm of the operand
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.logb
  kind: callable
  ns: pydantic.v1
  description: |-
    For a non-zero number, return the adjusted exponent of the operand as a
    Decimal instance.  If the operand is a zero, then Decimal('-Infinity') is
    returned and the DivisionByZero condition is raised. If the operand is
    an infinity then Decimal('Infinity') is returned.
  summary: For a non-zero number, return the adjusted exponent of the operand as a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.logical_and
  kind: callable
  ns: pydantic.v1
  description: Return the digit-wise 'and' of the two (logical) operands.
  summary: Return the digit-wise 'and' of the two (logical) operands
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.logical_invert
  kind: callable
  ns: pydantic.v1
  description: Return the digit-wise inversion of the (logical) operand.
  summary: Return the digit-wise inversion of the (logical) operand
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.logical_or
  kind: callable
  ns: pydantic.v1
  description: Return the digit-wise 'or' of the two (logical) operands.
  summary: Return the digit-wise 'or' of the two (logical) operands
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.logical_xor
  kind: callable
  ns: pydantic.v1
  description: Return the digit-wise 'exclusive or' of the two (logical) operands.
  summary: Return the digit-wise 'exclusive or' of the two (logical) operands
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.max
  kind: callable
  ns: pydantic.v1
  description: |-
    Maximum of self and other.  If one operand is a quiet NaN and the other is
    numeric, the numeric operand is returned.
  summary: Maximum of self and other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.max_digits
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.max_mag
  kind: callable
  ns: pydantic.v1
  description: |-
    Similar to the max() method, but the comparison is done using the absolute
    values of the operands.
  summary: Similar to the max() method, but the comparison is done using the absolute
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.min
  kind: callable
  ns: pydantic.v1
  description: |-
    Minimum of self and other. If one operand is a quiet NaN and the other is
    numeric, the numeric operand is returned.
  summary: Minimum of self and other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.min_mag
  kind: callable
  ns: pydantic.v1
  description: |-
    Similar to the min() method, but the comparison is done using the absolute
    values of the operands.
  summary: Similar to the min() method, but the comparison is done using the absolute
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.next_minus
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the largest number representable in the given context (or in the
    current default context if no context is given) that is smaller than the
    given operand.
  summary: Return the largest number representable in the given context (or in the
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.next_plus
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the smallest number representable in the given context (or in the
    current default context if no context is given) that is larger than the
    given operand.
  summary: Return the smallest number representable in the given context (or in the
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.next_toward
  kind: callable
  ns: pydantic.v1
  description: |-
    If the two operands are unequal, return the number closest to the first
    operand in the direction of the second operand.  If both operands are
    numerically equal, return a copy of the first operand with the sign set
    to be the same as the sign of the second operand.
  summary: If the two operands are unequal, return the number closest to the first
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.normalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Normalize the number by stripping the rightmost trailing zeros and
    converting any result equal to Decimal('0') to Decimal('0e0').  Used
    for producing canonical values for members of an equivalence class.
    For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize
    to the equivalent value Decimal('32.1').
  summary: Normalize the number by stripping the rightmost trailing zeros and
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.number_class
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a string describing the class of the operand.  The returned value
    is one of the following ten strings:

        * '-Infinity', indicating that the operand is negative infinity.
        * '-Normal', indicating that the operand is a negative normal number.
        * '-Subnormal', indicating that the operand is negative and subnormal.
        * '-Zero', indicating that the operand is a negative zero.
        * '+Zero', indicating that the operand is a positive zero.
        * '+Subnormal', indicating that the operand is positive and subnormal.
        * '+Normal', indicating that the operand is a positive normal number.
        * '+Infinity', indicating that the operand is positive infinity.
        * 'NaN', indicating that the operand is a quiet NaN (Not a Number).
        * 'sNaN', indicating that the operand is a signaling NaN.
  summary: Return a string describing the class of the operand
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.quantize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a value equal to the first operand after rounding and having the
    exponent of the second operand.

        >>> Decimal('1.41421356').quantize(Decimal('1.000'))
        Decimal('1.414')

    Unlike other operations, if the length of the coefficient after the quantize
    operation would be greater than precision, then an InvalidOperation is signaled.
    This guarantees that, unless there is an error condition, the quantized exponent
    is always equal to that of the right-hand operand.

    Also unlike other operations, quantize never signals Underflow, even if the
    result is subnormal and inexact.

    If the exponent of the second operand is larger than that of the first, then
    rounding may be necessary. In this case, the rounding mode is determined by the
    rounding argument if given, else by the given context argument; if neither
    argument is given, the rounding mode of the current thread's context is used.
  summary: Return a value equal to the first operand after rounding and having the
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: exp
    default: null
    rest: false
  - kind: positional
    name: rounding
    default: None
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.radix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return Decimal(10), the radix (base) in which the Decimal class does
    all its arithmetic. Included for compatibility with the specification.
  summary: Return Decimal(10), the radix (base) in which the Decimal class does
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.real
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDecimal.remainder_near
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the remainder from dividing self by other.  This differs from
    self % other in that the sign of the remainder is chosen so as to minimize
    its absolute value. More precisely, the return value is self - n * other
    where n is the integer nearest to the exact value of self / other, and
    if two integers are equally near then the even one is chosen.

    If the result is zero then its sign will be the sign of self.
  summary: Return the remainder from dividing self by other
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.rotate
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the result of rotating the digits of the first operand by an amount
    specified by the second operand.  The second operand must be an integer in
    the range -precision through precision. The absolute value of the second
    operand gives the number of places to rotate. If the second operand is
    positive then rotation is to the left; otherwise rotation is to the right.
    The coefficient of the first operand is padded on the left with zeros to
    length precision if necessary. The sign and exponent of the first operand are
    unchanged.
  summary: Return the result of rotating the digits of the first operand by an amount
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.same_quantum
  kind: callable
  ns: pydantic.v1
  description: |-
    Test whether self and other have the same exponent or whether both are NaN.

    This operation is unaffected by context and is quiet: no flags are changed
    and no rounding is performed. As an exception, the C version may raise
    InvalidOperation if the second operand cannot be converted exactly.
  summary: Test whether self and other have the same exponent or whether both are NaN
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.scaleb
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the first operand with the exponent adjusted the second.  Equivalently,
    return the first operand multiplied by 10**other. The second operand must be
    an integer.
  summary: Return the first operand with the exponent adjusted the second
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.shift
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the result of shifting the digits of the first operand by an amount
    specified by the second operand.  The second operand must be an integer in
    the range -precision through precision. The absolute value of the second
    operand gives the number of places to shift. If the second operand is
    positive, then the shift is to the left; otherwise the shift is to the
    right. Digits shifted into the coefficient are zeros. The sign and exponent
    of the first operand are unchanged.
  summary: Return the result of shifting the digits of the first operand by an amount
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.sqrt
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the square root of the argument to full precision. The result is
    correctly rounded using the ROUND_HALF_EVEN rounding mode.
  summary: Return the square root of the argument to full precision
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.to_eng_string
  kind: callable
  ns: pydantic.v1
  description: |-
    Convert to an engineering-type string.  Engineering notation has an exponent
    which is a multiple of 3, so there are up to 3 digits left of the decimal
    place. For example, Decimal('123E+1') is converted to Decimal('1.23E+3').

    The value of context.capitals determines whether the exponent sign is lower
    or upper case. Otherwise, the context does not affect the operation.
  summary: Convert to an engineering-type string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.to_integral
  kind: callable
  ns: pydantic.v1
  description: |-
    Identical to the to_integral_value() method.  The to_integral() name has been
    kept for compatibility with older versions.
  summary: Identical to the to_integral_value() method
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: rounding
    default: None
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.to_integral_exact
  kind: callable
  ns: pydantic.v1
  description: |-
    Round to the nearest integer, signaling Inexact or Rounded as appropriate if
    rounding occurs.  The rounding mode is determined by the rounding parameter
    if given, else by the given context. If neither parameter is given, then the
    rounding mode of the current default context is used.
  summary: Round to the nearest integer, signaling Inexact or Rounded as appropriate if
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: rounding
    default: None
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.to_integral_value
  kind: callable
  ns: pydantic.v1
  description: |-
    Round to the nearest integer without signaling Inexact or Rounded.  The
    rounding mode is determined by the rounding parameter if given, else by
    the given context. If neither parameter is given, then the rounding mode
    of the current default context is used.
  summary: Round to the nearest integer without signaling Inexact or Rounded
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: rounding
    default: None
    rest: false
  - kind: positional
    name: context
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: ConstrainedDecimal.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: condecimal
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - name: max_digits
    default: None
    rest: false
    kind: kw-only
  - name: decimal_places
    default: None
    rest: false
    kind: kw-only
  - name: multiple_of
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ConstrainedDate
  kind: class
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from:
  - <class 'datetime.date'>
- name: ConstrainedDate.ctime
  kind: callable
  ns: pydantic.v1
  description: Return ctime() style string.
  summary: Return ctime() style string
  signatures: null
  inherits_from: null
- name: ConstrainedDate.day
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDate.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDate.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDate.isocalendar
  kind: callable
  ns: pydantic.v1
  description: Return a named tuple containing ISO year, week number, and weekday.
  summary: Return a named tuple containing ISO year, week number, and weekday
  signatures: null
  inherits_from: null
- name: ConstrainedDate.isoformat
  kind: callable
  ns: pydantic.v1
  description: Return string in ISO 8601 format, YYYY-MM-DD.
  summary: Return string in ISO 8601 format, YYYY-MM-DD
  signatures: null
  inherits_from: null
- name: ConstrainedDate.isoweekday
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the day of the week represented by the date.
    Monday == 1 ... Sunday == 7
  summary: Return the day of the week represented by the date
  signatures: null
  inherits_from: null
- name: ConstrainedDate.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDate.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDate.max
  kind: property
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from: null
- name: ConstrainedDate.min
  kind: property
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from: null
- name: ConstrainedDate.month
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: ConstrainedDate.replace
  kind: callable
  ns: pydantic.v1
  description: Return date with new specified fields.
  summary: Return date with new specified fields
  signatures: null
  inherits_from: null
- name: ConstrainedDate.resolution
  kind: property
  ns: pydantic.v1
  description: |-
    Difference between two datetime values.

    timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

    All arguments are optional and default to 0.
    Arguments may be integers or floats, and may be positive or negative.
  summary: Difference between two datetime values
  signatures: null
  inherits_from: null
- name: ConstrainedDate.strftime
  kind: callable
  ns: pydantic.v1
  description: format -> strftime() style string.
  summary: format -> strftime() style string
  signatures: null
  inherits_from: null
- name: ConstrainedDate.timetuple
  kind: callable
  ns: pydantic.v1
  description: Return time tuple, compatible with time.localtime().
  summary: Return time tuple, compatible with time
  signatures: null
  inherits_from: null
- name: ConstrainedDate.toordinal
  kind: callable
  ns: pydantic.v1
  description: Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.
  summary: Return proleptic Gregorian ordinal
  signatures: null
  inherits_from: null
- name: ConstrainedDate.weekday
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the day of the week represented by the date.
    Monday == 0 ... Sunday == 6
  summary: Return the day of the week represented by the date
  signatures: null
  inherits_from: null
- name: ConstrainedDate.year
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: condate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - name: gt
    default: None
    rest: false
    kind: kw-only
  - name: ge
    default: None
    rest: false
    kind: kw-only
  - name: lt
    default: None
    rest: false
    kind: kw-only
  - name: le
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: UUID1
  kind: class
  ns: pydantic.v1
  description: |-
    Instances of the UUID class represent UUIDs as specified in RFC 4122.
    UUID objects are immutable, hashable, and usable as dictionary keys.
    Converting a UUID to a string with str() yields something in the form
    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
    five possible forms: a similar string of hexadecimal digits, or a tuple
    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
    48-bit values respectively) as an argument named 'fields', or a string
    of 16 bytes (with all the integer fields in big-endian order) as an
    argument named 'bytes', or a string of 16 bytes (with the first three
    fields in little-endian order) as an argument named 'bytes_le', or a
    single 128-bit integer as an argument named 'int'.

    UUIDs have these read-only attributes:

        bytes       the UUID as a 16-byte string (containing the six
                    integer fields in big-endian byte order)

        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                    and time_hi_version in little-endian byte order)

        fields      a tuple of the six integer fields of the UUID,
                    which are also available as six individual attributes
                    and two derived attributes:

            time_low                the first 32 bits of the UUID
            time_mid                the next 16 bits of the UUID
            time_hi_version         the next 16 bits of the UUID
            clock_seq_hi_variant    the next 8 bits of the UUID
            clock_seq_low           the next 8 bits of the UUID
            node                    the last 48 bits of the UUID

            time                    the 60-bit timestamp
            clock_seq               the 14-bit sequence number

        hex         the UUID as a 32-character hexadecimal string

        int         the UUID as a 128-bit integer

        urn         the UUID as a URN as specified in RFC 4122

        variant     the UUID variant (one of the constants RESERVED_NCS,
                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

        version     the UUID version number (1 through 5, meaningful only
                    when the variant is RFC_4122)

        is_safe     An enum indicating whether the UUID has been generated in
                    a way that is safe for multiprocessing applications, via
                    uuid_generate_time_safe(3).
  summary: Instances of the UUID class represent UUIDs as specified in RFC 4122
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: hex
    default: None
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - kind: positional
    name: bytes_le
    default: None
    rest: false
  - kind: positional
    name: fields
    default: None
    rest: false
  - kind: positional
    name: int
    default: None
    rest: false
  - kind: positional
    name: version
    default: None
    rest: false
  - name: is_safe
    default: SafeUUID.unknown
    rest: false
    kind: kw-only
  - type: UUID1
  inherits_from:
  - <class 'uuid.UUID'>
- name: UUID1.bytes
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.bytes_le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.clock_seq
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.clock_seq_hi_variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.clock_seq_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.fields
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.hex
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.int
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.is_safe
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.node
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.time
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.time_hi_version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.time_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.time_mid
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.urn
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID1.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3
  kind: class
  ns: pydantic.v1
  description: |-
    Instances of the UUID class represent UUIDs as specified in RFC 4122.
    UUID objects are immutable, hashable, and usable as dictionary keys.
    Converting a UUID to a string with str() yields something in the form
    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
    five possible forms: a similar string of hexadecimal digits, or a tuple
    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
    48-bit values respectively) as an argument named 'fields', or a string
    of 16 bytes (with all the integer fields in big-endian order) as an
    argument named 'bytes', or a string of 16 bytes (with the first three
    fields in little-endian order) as an argument named 'bytes_le', or a
    single 128-bit integer as an argument named 'int'.

    UUIDs have these read-only attributes:

        bytes       the UUID as a 16-byte string (containing the six
                    integer fields in big-endian byte order)

        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                    and time_hi_version in little-endian byte order)

        fields      a tuple of the six integer fields of the UUID,
                    which are also available as six individual attributes
                    and two derived attributes:

            time_low                the first 32 bits of the UUID
            time_mid                the next 16 bits of the UUID
            time_hi_version         the next 16 bits of the UUID
            clock_seq_hi_variant    the next 8 bits of the UUID
            clock_seq_low           the next 8 bits of the UUID
            node                    the last 48 bits of the UUID

            time                    the 60-bit timestamp
            clock_seq               the 14-bit sequence number

        hex         the UUID as a 32-character hexadecimal string

        int         the UUID as a 128-bit integer

        urn         the UUID as a URN as specified in RFC 4122

        variant     the UUID variant (one of the constants RESERVED_NCS,
                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

        version     the UUID version number (1 through 5, meaningful only
                    when the variant is RFC_4122)

        is_safe     An enum indicating whether the UUID has been generated in
                    a way that is safe for multiprocessing applications, via
                    uuid_generate_time_safe(3).
  summary: Instances of the UUID class represent UUIDs as specified in RFC 4122
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: hex
    default: None
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - kind: positional
    name: bytes_le
    default: None
    rest: false
  - kind: positional
    name: fields
    default: None
    rest: false
  - kind: positional
    name: int
    default: None
    rest: false
  - kind: positional
    name: version
    default: None
    rest: false
  - name: is_safe
    default: SafeUUID.unknown
    rest: false
    kind: kw-only
  - type: UUID3
  inherits_from:
  - <class 'pydantic.v1.types.UUID1'>
  - <class 'uuid.UUID'>
- name: UUID3.bytes
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.bytes_le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.clock_seq
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.clock_seq_hi_variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.clock_seq_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.fields
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.hex
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.int
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.is_safe
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.node
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.time
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.time_hi_version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.time_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.time_mid
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.urn
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID3.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4
  kind: class
  ns: pydantic.v1
  description: |-
    Instances of the UUID class represent UUIDs as specified in RFC 4122.
    UUID objects are immutable, hashable, and usable as dictionary keys.
    Converting a UUID to a string with str() yields something in the form
    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
    five possible forms: a similar string of hexadecimal digits, or a tuple
    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
    48-bit values respectively) as an argument named 'fields', or a string
    of 16 bytes (with all the integer fields in big-endian order) as an
    argument named 'bytes', or a string of 16 bytes (with the first three
    fields in little-endian order) as an argument named 'bytes_le', or a
    single 128-bit integer as an argument named 'int'.

    UUIDs have these read-only attributes:

        bytes       the UUID as a 16-byte string (containing the six
                    integer fields in big-endian byte order)

        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                    and time_hi_version in little-endian byte order)

        fields      a tuple of the six integer fields of the UUID,
                    which are also available as six individual attributes
                    and two derived attributes:

            time_low                the first 32 bits of the UUID
            time_mid                the next 16 bits of the UUID
            time_hi_version         the next 16 bits of the UUID
            clock_seq_hi_variant    the next 8 bits of the UUID
            clock_seq_low           the next 8 bits of the UUID
            node                    the last 48 bits of the UUID

            time                    the 60-bit timestamp
            clock_seq               the 14-bit sequence number

        hex         the UUID as a 32-character hexadecimal string

        int         the UUID as a 128-bit integer

        urn         the UUID as a URN as specified in RFC 4122

        variant     the UUID variant (one of the constants RESERVED_NCS,
                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

        version     the UUID version number (1 through 5, meaningful only
                    when the variant is RFC_4122)

        is_safe     An enum indicating whether the UUID has been generated in
                    a way that is safe for multiprocessing applications, via
                    uuid_generate_time_safe(3).
  summary: Instances of the UUID class represent UUIDs as specified in RFC 4122
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: hex
    default: None
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - kind: positional
    name: bytes_le
    default: None
    rest: false
  - kind: positional
    name: fields
    default: None
    rest: false
  - kind: positional
    name: int
    default: None
    rest: false
  - kind: positional
    name: version
    default: None
    rest: false
  - name: is_safe
    default: SafeUUID.unknown
    rest: false
    kind: kw-only
  - type: UUID4
  inherits_from:
  - <class 'pydantic.v1.types.UUID1'>
  - <class 'uuid.UUID'>
- name: UUID4.bytes
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.bytes_le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.clock_seq
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.clock_seq_hi_variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.clock_seq_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.fields
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.hex
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.int
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.is_safe
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.node
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.time
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.time_hi_version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.time_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.time_mid
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.urn
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID4.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5
  kind: class
  ns: pydantic.v1
  description: |-
    Instances of the UUID class represent UUIDs as specified in RFC 4122.
    UUID objects are immutable, hashable, and usable as dictionary keys.
    Converting a UUID to a string with str() yields something in the form
    '12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts
    five possible forms: a similar string of hexadecimal digits, or a tuple
    of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
    48-bit values respectively) as an argument named 'fields', or a string
    of 16 bytes (with all the integer fields in big-endian order) as an
    argument named 'bytes', or a string of 16 bytes (with the first three
    fields in little-endian order) as an argument named 'bytes_le', or a
    single 128-bit integer as an argument named 'int'.

    UUIDs have these read-only attributes:

        bytes       the UUID as a 16-byte string (containing the six
                    integer fields in big-endian byte order)

        bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                    and time_hi_version in little-endian byte order)

        fields      a tuple of the six integer fields of the UUID,
                    which are also available as six individual attributes
                    and two derived attributes:

            time_low                the first 32 bits of the UUID
            time_mid                the next 16 bits of the UUID
            time_hi_version         the next 16 bits of the UUID
            clock_seq_hi_variant    the next 8 bits of the UUID
            clock_seq_low           the next 8 bits of the UUID
            node                    the last 48 bits of the UUID

            time                    the 60-bit timestamp
            clock_seq               the 14-bit sequence number

        hex         the UUID as a 32-character hexadecimal string

        int         the UUID as a 128-bit integer

        urn         the UUID as a URN as specified in RFC 4122

        variant     the UUID variant (one of the constants RESERVED_NCS,
                    RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

        version     the UUID version number (1 through 5, meaningful only
                    when the variant is RFC_4122)

        is_safe     An enum indicating whether the UUID has been generated in
                    a way that is safe for multiprocessing applications, via
                    uuid_generate_time_safe(3).
  summary: Instances of the UUID class represent UUIDs as specified in RFC 4122
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: hex
    default: None
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - kind: positional
    name: bytes_le
    default: None
    rest: false
  - kind: positional
    name: fields
    default: None
    rest: false
  - kind: positional
    name: int
    default: None
    rest: false
  - kind: positional
    name: version
    default: None
    rest: false
  - name: is_safe
    default: SafeUUID.unknown
    rest: false
    kind: kw-only
  - type: UUID5
  inherits_from:
  - <class 'pydantic.v1.types.UUID1'>
  - <class 'uuid.UUID'>
- name: UUID5.bytes
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.bytes_le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.clock_seq
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.clock_seq_hi_variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.clock_seq_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.fields
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.hex
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.int
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.is_safe
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.node
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.time
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.time_hi_version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.time_low
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.time_mid
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.urn
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.variant
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: UUID5.version
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FilePath
  kind: class
  ns: pydantic.v1
  description: |-
    PurePath subclass that can make system calls.

    Path represents a filesystem path but unlike PurePath, also offers
    methods to do system calls on path objects. Depending on your system,
    instantiating a Path will return either a PosixPath or a WindowsPath
    object. You can also instantiate a PosixPath or WindowsPath directly,
    but cannot instantiate a WindowsPath on a POSIX system or vice versa.
  summary: PurePath subclass that can make system calls
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: FilePath
  inherits_from:
  - <class 'pathlib.Path'>
  - <class 'pathlib.PurePath'>
- name: FilePath.absolute
  kind: method
  ns: pydantic.v1
  description: |-
    Return an absolute version of this path by prepending the current
    working directory. No normalization or symlink resolution is performed.

    Use resolve() to get the canonical path to a file.
  summary: Return an absolute version of this path by prepending the current
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.anchor
  kind: property
  ns: pydantic.v1
  description: The concatenation of the drive and root, or ''.
  summary: The concatenation of the drive and root, or ''
  signatures: null
  inherits_from: null
- name: FilePath.as_posix
  kind: method
  ns: pydantic.v1
  description: |-
    Return the string representation of the path with forward (/)
    slashes.
  summary: Return the string representation of the path with forward (/)
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.as_uri
  kind: method
  ns: pydantic.v1
  description: Return the path as a 'file' URI.
  summary: Return the path as a 'file' URI
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.chmod
  kind: method
  ns: pydantic.v1
  description: Change the permissions of the path, like os.chmod().
  summary: Change the permissions of the path, like os
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: null
    rest: false
  - name: follow_symlinks
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: FilePath.cwd
  kind: function
  ns: pydantic.v1
  description: |-
    Return a new path pointing to the current working directory
    (as returned by os.getcwd()).
  summary: Return a new path pointing to the current working directory
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.drive
  kind: property
  ns: pydantic.v1
  description: The drive prefix (letter or UNC path), if any.
  summary: The drive prefix (letter or UNC path), if any
  signatures: null
  inherits_from: null
- name: FilePath.exists
  kind: method
  ns: pydantic.v1
  description: Whether this path exists.
  summary: Whether this path exists
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.expanduser
  kind: method
  ns: pydantic.v1
  description: |-
    Return a new path with expanded ~ and ~user constructs
    (as returned by os.path.expanduser)
  summary: Return a new path with expanded ~ and ~user constructs
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.glob
  kind: method
  ns: pydantic.v1
  description: |-
    Iterate over this subtree and yield all existing files (of any
    kind, including directories) matching the given relative pattern.
  summary: Iterate over this subtree and yield all existing files (of any
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: pattern
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.group
  kind: method
  ns: pydantic.v1
  description: Return the group name of the file gid.
  summary: Return the group name of the file gid
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.hardlink_to
  kind: method
  ns: pydantic.v1
  description: |-
    Make this path a hard link pointing to the same file as *target*.

    Note the order of arguments (self, target) is the reverse of os.link's.
  summary: Make this path a hard link pointing to the same file as *target*
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.home
  kind: function
  ns: pydantic.v1
  description: |-
    Return a new path pointing to the user's home directory (as
    returned by os.path.expanduser('~')).
  summary: Return a new path pointing to the user's home directory (as
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_absolute
  kind: method
  ns: pydantic.v1
  description: |-
    True if the path is absolute (has both a root and, if applicable,
    a drive).
  summary: True if the path is absolute (has both a root and, if applicable,
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_block_device
  kind: method
  ns: pydantic.v1
  description: Whether this path is a block device.
  summary: Whether this path is a block device
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_char_device
  kind: method
  ns: pydantic.v1
  description: Whether this path is a character device.
  summary: Whether this path is a character device
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_dir
  kind: method
  ns: pydantic.v1
  description: Whether this path is a directory.
  summary: Whether this path is a directory
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_fifo
  kind: method
  ns: pydantic.v1
  description: Whether this path is a FIFO.
  summary: Whether this path is a FIFO
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_file
  kind: method
  ns: pydantic.v1
  description: |-
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
  summary: Whether this path is a regular file (also True for symlinks pointing
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_mount
  kind: method
  ns: pydantic.v1
  description: Check if this path is a POSIX mount point
  summary: Check if this path is a POSIX mount point
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_relative_to
  kind: method
  ns: pydantic.v1
  description: "Return True if the path is relative to another path or False.\n        "
  summary: Return True if the path is relative to another path or False
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_reserved
  kind: method
  ns: pydantic.v1
  description: |-
    Return True if the path contains one of the special names reserved
    by the system, if any.
  summary: Return True if the path contains one of the special names reserved
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_socket
  kind: method
  ns: pydantic.v1
  description: Whether this path is a socket.
  summary: Whether this path is a socket
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.is_symlink
  kind: method
  ns: pydantic.v1
  description: Whether this path is a symbolic link.
  summary: Whether this path is a symbolic link
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.iterdir
  kind: method
  ns: pydantic.v1
  description: |-
    Iterate over the files in this directory.  Does not yield any
    result for the special paths '.' and '..'.
  summary: Iterate over the files in this directory
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.joinpath
  kind: method
  ns: pydantic.v1
  description: |-
    Combine this path with one or several arguments, and return a
    new path representing either a subpath (if all arguments are relative
    paths) or a totally different path (if one of the arguments is
    anchored).
  summary: Combine this path with one or several arguments, and return a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.lchmod
  kind: method
  ns: pydantic.v1
  description: |-
    Like chmod(), except if the path points to a symlink, the symlink's
    permissions are changed, rather than its target's.
  summary: Like chmod(), except if the path points to a symlink, the symlink's
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.link_to
  kind: method
  ns: pydantic.v1
  description: |-
    Make the target path a hard link pointing to this path.

    Note this function does not make this path a hard link to *target*,
    despite the implication of the function and argument names. The order
    of arguments (target, link) is the reverse of Path.symlink_to, but
    matches that of os.link.

    Deprecated since Python 3.10 and scheduled for removal in Python 3.12.
    Use `hardlink_to()` instead.
  summary: Make the target path a hard link pointing to this path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.lstat
  kind: method
  ns: pydantic.v1
  description: |-
    Like stat(), except if the path points to a symlink, the symlink's
    status information is returned, rather than its target's.
  summary: Like stat(), except if the path points to a symlink, the symlink's
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.match
  kind: method
  ns: pydantic.v1
  description: Return True if this path matches the given pattern.
  summary: Return True if this path matches the given pattern
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: path_pattern
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.mkdir
  kind: method
  ns: pydantic.v1
  description: Create a new directory at this given path.
  summary: Create a new directory at this given path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: '511'
    rest: false
  - kind: positional
    name: parents
    default: 'False'
    rest: false
  - kind: positional
    name: exist_ok
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.name
  kind: property
  ns: pydantic.v1
  description: The final path component, if any.
  summary: The final path component, if any
  signatures: null
  inherits_from: null
- name: FilePath.open
  kind: method
  ns: pydantic.v1
  description: |-
    Open the file pointed by this path and return a file object, as
    the built-in open() function does.
  summary: Open the file pointed by this path and return a file object, as
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: r
    rest: false
  - kind: positional
    name: buffering
    default: '-1'
    rest: false
  - kind: positional
    name: encoding
    default: None
    rest: false
  - kind: positional
    name: errors
    default: None
    rest: false
  - kind: positional
    name: newline
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.owner
  kind: method
  ns: pydantic.v1
  description: Return the login name of the file owner.
  summary: Return the login name of the file owner
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.parent
  kind: property
  ns: pydantic.v1
  description: The logical parent of the path.
  summary: The logical parent of the path
  signatures: null
  inherits_from: null
- name: FilePath.parents
  kind: property
  ns: pydantic.v1
  description: A sequence of this path's logical parents.
  summary: A sequence of this path's logical parents
  signatures: null
  inherits_from: null
- name: FilePath.parts
  kind: property
  ns: pydantic.v1
  description: |-
    An object providing sequence-like access to the
    components in the filesystem path.
  summary: An object providing sequence-like access to the
  signatures: null
  inherits_from: null
- name: FilePath.read_bytes
  kind: method
  ns: pydantic.v1
  description: Open the file in bytes mode, read it, and close the file.
  summary: Open the file in bytes mode, read it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.read_text
  kind: method
  ns: pydantic.v1
  description: Open the file in text mode, read it, and close the file.
  summary: Open the file in text mode, read it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: None
    rest: false
  - kind: positional
    name: errors
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.readlink
  kind: method
  ns: pydantic.v1
  description: Return the path to which the symbolic link points.
  summary: Return the path to which the symbolic link points
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.relative_to
  kind: method
  ns: pydantic.v1
  description: |-
    Return the relative path to another path identified by the passed
    arguments.  If the operation is not possible (because this is not
    a subpath of the other path), raise ValueError.
  summary: Return the relative path to another path identified by the passed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.rename
  kind: method
  ns: pydantic.v1
  description: |-
    Rename this path to the target path.

    The target path may be absolute or relative. Relative paths are
    interpreted relative to the current working directory, *not* the
    directory of the Path object.

    Returns the new Path instance pointing to the target path.
  summary: Rename this path to the target path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.replace
  kind: method
  ns: pydantic.v1
  description: |-
    Rename this path to the target path, overwriting if that path exists.

    The target path may be absolute or relative. Relative paths are
    interpreted relative to the current working directory, *not* the
    directory of the Path object.

    Returns the new Path instance pointing to the target path.
  summary: Rename this path to the target path, overwriting if that path exists
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.resolve
  kind: method
  ns: pydantic.v1
  description: |-
    Make the path absolute, resolving all symlinks on the way and also
    normalizing it.
  summary: Make the path absolute, resolving all symlinks on the way and also
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: strict
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.rglob
  kind: method
  ns: pydantic.v1
  description: |-
    Recursively yield all existing files (of any kind, including
    directories) matching the given relative pattern, anywhere in
    this subtree.
  summary: Recursively yield all existing files (of any kind, including
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: pattern
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.rmdir
  kind: method
  ns: pydantic.v1
  description: Remove this directory.  The directory must be empty.
  summary: Remove this directory
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.root
  kind: property
  ns: pydantic.v1
  description: The root of the path, if any.
  summary: The root of the path, if any
  signatures: null
  inherits_from: null
- name: FilePath.samefile
  kind: method
  ns: pydantic.v1
  description: |-
    Return whether other_path is the same or not as this file
    (as returned by os.path.samefile()).
  summary: Return whether other_path is the same or not as this file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other_path
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.stat
  kind: method
  ns: pydantic.v1
  description: |-
    Return the result of the stat() system call on this path, like
    os.stat() does.
  summary: Return the result of the stat() system call on this path, like
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: follow_symlinks
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: FilePath.stem
  kind: property
  ns: pydantic.v1
  description: The final path component, minus its last suffix.
  summary: The final path component, minus its last suffix
  signatures: null
  inherits_from: null
- name: FilePath.suffix
  kind: property
  ns: pydantic.v1
  description: |-
    The final component's last suffix, if any.

    This includes the leading period. For example: '.txt'
  summary: The final component's last suffix, if any
  signatures: null
  inherits_from: null
- name: FilePath.suffixes
  kind: property
  ns: pydantic.v1
  description: |-
    A list of the final component's suffixes, if any.

    These include the leading periods. For example: ['.tar', '.gz']
  summary: A list of the final component's suffixes, if any
  signatures: null
  inherits_from: null
- name: FilePath.symlink_to
  kind: method
  ns: pydantic.v1
  description: |-
    Make this path a symlink pointing to the target path.
    Note the order of arguments (link, target) is the reverse of os.symlink.
  summary: Make this path a symlink pointing to the target path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - kind: positional
    name: target_is_directory
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.touch
  kind: method
  ns: pydantic.v1
  description: Create this file with the given access mode, if it doesn't exist.
  summary: Create this file with the given access mode, if it doesn't exist
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: '438'
    rest: false
  - kind: positional
    name: exist_ok
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.unlink
  kind: method
  ns: pydantic.v1
  description: |-
    Remove this file or link.
    If the path is a directory, use rmdir() instead.
  summary: Remove this file or link
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: missing_ok
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.with_name
  kind: method
  ns: pydantic.v1
  description: Return a new path with the file name changed.
  summary: Return a new path with the file name changed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.with_stem
  kind: method
  ns: pydantic.v1
  description: Return a new path with the stem changed.
  summary: Return a new path with the stem changed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: stem
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.with_suffix
  kind: method
  ns: pydantic.v1
  description: |-
    Return a new path with the file suffix changed.  If the path
    has no suffix, add given suffix.  If the given suffix is an empty
    string, remove the suffix from the path.
  summary: Return a new path with the file suffix changed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.write_bytes
  kind: method
  ns: pydantic.v1
  description: Open the file in bytes mode, write to it, and close the file.
  summary: Open the file in bytes mode, write to it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FilePath.write_text
  kind: method
  ns: pydantic.v1
  description: Open the file in text mode, write to it, and close the file.
  summary: Open the file in text mode, write to it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: None
    rest: false
  - kind: positional
    name: errors
    default: None
    rest: false
  - kind: positional
    name: newline
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath
  kind: class
  ns: pydantic.v1
  description: |-
    PurePath subclass that can make system calls.

    Path represents a filesystem path but unlike PurePath, also offers
    methods to do system calls on path objects. Depending on your system,
    instantiating a Path will return either a PosixPath or a WindowsPath
    object. You can also instantiate a PosixPath or WindowsPath directly,
    but cannot instantiate a WindowsPath on a POSIX system or vice versa.
  summary: PurePath subclass that can make system calls
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: DirectoryPath
  inherits_from:
  - <class 'pathlib.Path'>
  - <class 'pathlib.PurePath'>
- name: DirectoryPath.absolute
  kind: method
  ns: pydantic.v1
  description: |-
    Return an absolute version of this path by prepending the current
    working directory. No normalization or symlink resolution is performed.

    Use resolve() to get the canonical path to a file.
  summary: Return an absolute version of this path by prepending the current
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.anchor
  kind: property
  ns: pydantic.v1
  description: The concatenation of the drive and root, or ''.
  summary: The concatenation of the drive and root, or ''
  signatures: null
  inherits_from: null
- name: DirectoryPath.as_posix
  kind: method
  ns: pydantic.v1
  description: |-
    Return the string representation of the path with forward (/)
    slashes.
  summary: Return the string representation of the path with forward (/)
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.as_uri
  kind: method
  ns: pydantic.v1
  description: Return the path as a 'file' URI.
  summary: Return the path as a 'file' URI
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.chmod
  kind: method
  ns: pydantic.v1
  description: Change the permissions of the path, like os.chmod().
  summary: Change the permissions of the path, like os
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: null
    rest: false
  - name: follow_symlinks
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: DirectoryPath.cwd
  kind: function
  ns: pydantic.v1
  description: |-
    Return a new path pointing to the current working directory
    (as returned by os.getcwd()).
  summary: Return a new path pointing to the current working directory
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.drive
  kind: property
  ns: pydantic.v1
  description: The drive prefix (letter or UNC path), if any.
  summary: The drive prefix (letter or UNC path), if any
  signatures: null
  inherits_from: null
- name: DirectoryPath.exists
  kind: method
  ns: pydantic.v1
  description: Whether this path exists.
  summary: Whether this path exists
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.expanduser
  kind: method
  ns: pydantic.v1
  description: |-
    Return a new path with expanded ~ and ~user constructs
    (as returned by os.path.expanduser)
  summary: Return a new path with expanded ~ and ~user constructs
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.glob
  kind: method
  ns: pydantic.v1
  description: |-
    Iterate over this subtree and yield all existing files (of any
    kind, including directories) matching the given relative pattern.
  summary: Iterate over this subtree and yield all existing files (of any
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: pattern
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.group
  kind: method
  ns: pydantic.v1
  description: Return the group name of the file gid.
  summary: Return the group name of the file gid
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.hardlink_to
  kind: method
  ns: pydantic.v1
  description: |-
    Make this path a hard link pointing to the same file as *target*.

    Note the order of arguments (self, target) is the reverse of os.link's.
  summary: Make this path a hard link pointing to the same file as *target*
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.home
  kind: function
  ns: pydantic.v1
  description: |-
    Return a new path pointing to the user's home directory (as
    returned by os.path.expanduser('~')).
  summary: Return a new path pointing to the user's home directory (as
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_absolute
  kind: method
  ns: pydantic.v1
  description: |-
    True if the path is absolute (has both a root and, if applicable,
    a drive).
  summary: True if the path is absolute (has both a root and, if applicable,
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_block_device
  kind: method
  ns: pydantic.v1
  description: Whether this path is a block device.
  summary: Whether this path is a block device
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_char_device
  kind: method
  ns: pydantic.v1
  description: Whether this path is a character device.
  summary: Whether this path is a character device
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_dir
  kind: method
  ns: pydantic.v1
  description: Whether this path is a directory.
  summary: Whether this path is a directory
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_fifo
  kind: method
  ns: pydantic.v1
  description: Whether this path is a FIFO.
  summary: Whether this path is a FIFO
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_file
  kind: method
  ns: pydantic.v1
  description: |-
    Whether this path is a regular file (also True for symlinks pointing
    to regular files).
  summary: Whether this path is a regular file (also True for symlinks pointing
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_mount
  kind: method
  ns: pydantic.v1
  description: Check if this path is a POSIX mount point
  summary: Check if this path is a POSIX mount point
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_relative_to
  kind: method
  ns: pydantic.v1
  description: "Return True if the path is relative to another path or False.\n        "
  summary: Return True if the path is relative to another path or False
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_reserved
  kind: method
  ns: pydantic.v1
  description: |-
    Return True if the path contains one of the special names reserved
    by the system, if any.
  summary: Return True if the path contains one of the special names reserved
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_socket
  kind: method
  ns: pydantic.v1
  description: Whether this path is a socket.
  summary: Whether this path is a socket
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.is_symlink
  kind: method
  ns: pydantic.v1
  description: Whether this path is a symbolic link.
  summary: Whether this path is a symbolic link
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.iterdir
  kind: method
  ns: pydantic.v1
  description: |-
    Iterate over the files in this directory.  Does not yield any
    result for the special paths '.' and '..'.
  summary: Iterate over the files in this directory
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.joinpath
  kind: method
  ns: pydantic.v1
  description: |-
    Combine this path with one or several arguments, and return a
    new path representing either a subpath (if all arguments are relative
    paths) or a totally different path (if one of the arguments is
    anchored).
  summary: Combine this path with one or several arguments, and return a
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.lchmod
  kind: method
  ns: pydantic.v1
  description: |-
    Like chmod(), except if the path points to a symlink, the symlink's
    permissions are changed, rather than its target's.
  summary: Like chmod(), except if the path points to a symlink, the symlink's
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.link_to
  kind: method
  ns: pydantic.v1
  description: |-
    Make the target path a hard link pointing to this path.

    Note this function does not make this path a hard link to *target*,
    despite the implication of the function and argument names. The order
    of arguments (target, link) is the reverse of Path.symlink_to, but
    matches that of os.link.

    Deprecated since Python 3.10 and scheduled for removal in Python 3.12.
    Use `hardlink_to()` instead.
  summary: Make the target path a hard link pointing to this path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.lstat
  kind: method
  ns: pydantic.v1
  description: |-
    Like stat(), except if the path points to a symlink, the symlink's
    status information is returned, rather than its target's.
  summary: Like stat(), except if the path points to a symlink, the symlink's
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.match
  kind: method
  ns: pydantic.v1
  description: Return True if this path matches the given pattern.
  summary: Return True if this path matches the given pattern
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: path_pattern
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.mkdir
  kind: method
  ns: pydantic.v1
  description: Create a new directory at this given path.
  summary: Create a new directory at this given path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: '511'
    rest: false
  - kind: positional
    name: parents
    default: 'False'
    rest: false
  - kind: positional
    name: exist_ok
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.name
  kind: property
  ns: pydantic.v1
  description: The final path component, if any.
  summary: The final path component, if any
  signatures: null
  inherits_from: null
- name: DirectoryPath.open
  kind: method
  ns: pydantic.v1
  description: |-
    Open the file pointed by this path and return a file object, as
    the built-in open() function does.
  summary: Open the file pointed by this path and return a file object, as
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: r
    rest: false
  - kind: positional
    name: buffering
    default: '-1'
    rest: false
  - kind: positional
    name: encoding
    default: None
    rest: false
  - kind: positional
    name: errors
    default: None
    rest: false
  - kind: positional
    name: newline
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.owner
  kind: method
  ns: pydantic.v1
  description: Return the login name of the file owner.
  summary: Return the login name of the file owner
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.parent
  kind: property
  ns: pydantic.v1
  description: The logical parent of the path.
  summary: The logical parent of the path
  signatures: null
  inherits_from: null
- name: DirectoryPath.parents
  kind: property
  ns: pydantic.v1
  description: A sequence of this path's logical parents.
  summary: A sequence of this path's logical parents
  signatures: null
  inherits_from: null
- name: DirectoryPath.parts
  kind: property
  ns: pydantic.v1
  description: |-
    An object providing sequence-like access to the
    components in the filesystem path.
  summary: An object providing sequence-like access to the
  signatures: null
  inherits_from: null
- name: DirectoryPath.read_bytes
  kind: method
  ns: pydantic.v1
  description: Open the file in bytes mode, read it, and close the file.
  summary: Open the file in bytes mode, read it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.read_text
  kind: method
  ns: pydantic.v1
  description: Open the file in text mode, read it, and close the file.
  summary: Open the file in text mode, read it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: None
    rest: false
  - kind: positional
    name: errors
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.readlink
  kind: method
  ns: pydantic.v1
  description: Return the path to which the symbolic link points.
  summary: Return the path to which the symbolic link points
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.relative_to
  kind: method
  ns: pydantic.v1
  description: |-
    Return the relative path to another path identified by the passed
    arguments.  If the operation is not possible (because this is not
    a subpath of the other path), raise ValueError.
  summary: Return the relative path to another path identified by the passed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.rename
  kind: method
  ns: pydantic.v1
  description: |-
    Rename this path to the target path.

    The target path may be absolute or relative. Relative paths are
    interpreted relative to the current working directory, *not* the
    directory of the Path object.

    Returns the new Path instance pointing to the target path.
  summary: Rename this path to the target path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.replace
  kind: method
  ns: pydantic.v1
  description: |-
    Rename this path to the target path, overwriting if that path exists.

    The target path may be absolute or relative. Relative paths are
    interpreted relative to the current working directory, *not* the
    directory of the Path object.

    Returns the new Path instance pointing to the target path.
  summary: Rename this path to the target path, overwriting if that path exists
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.resolve
  kind: method
  ns: pydantic.v1
  description: |-
    Make the path absolute, resolving all symlinks on the way and also
    normalizing it.
  summary: Make the path absolute, resolving all symlinks on the way and also
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: strict
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.rglob
  kind: method
  ns: pydantic.v1
  description: |-
    Recursively yield all existing files (of any kind, including
    directories) matching the given relative pattern, anywhere in
    this subtree.
  summary: Recursively yield all existing files (of any kind, including
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: pattern
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.rmdir
  kind: method
  ns: pydantic.v1
  description: Remove this directory.  The directory must be empty.
  summary: Remove this directory
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.root
  kind: property
  ns: pydantic.v1
  description: The root of the path, if any.
  summary: The root of the path, if any
  signatures: null
  inherits_from: null
- name: DirectoryPath.samefile
  kind: method
  ns: pydantic.v1
  description: |-
    Return whether other_path is the same or not as this file
    (as returned by os.path.samefile()).
  summary: Return whether other_path is the same or not as this file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: other_path
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.stat
  kind: method
  ns: pydantic.v1
  description: |-
    Return the result of the stat() system call on this path, like
    os.stat() does.
  summary: Return the result of the stat() system call on this path, like
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - name: follow_symlinks
    default: 'True'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: DirectoryPath.stem
  kind: property
  ns: pydantic.v1
  description: The final path component, minus its last suffix.
  summary: The final path component, minus its last suffix
  signatures: null
  inherits_from: null
- name: DirectoryPath.suffix
  kind: property
  ns: pydantic.v1
  description: |-
    The final component's last suffix, if any.

    This includes the leading period. For example: '.txt'
  summary: The final component's last suffix, if any
  signatures: null
  inherits_from: null
- name: DirectoryPath.suffixes
  kind: property
  ns: pydantic.v1
  description: |-
    A list of the final component's suffixes, if any.

    These include the leading periods. For example: ['.tar', '.gz']
  summary: A list of the final component's suffixes, if any
  signatures: null
  inherits_from: null
- name: DirectoryPath.symlink_to
  kind: method
  ns: pydantic.v1
  description: |-
    Make this path a symlink pointing to the target path.
    Note the order of arguments (link, target) is the reverse of os.symlink.
  summary: Make this path a symlink pointing to the target path
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: target
    default: null
    rest: false
  - kind: positional
    name: target_is_directory
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.touch
  kind: method
  ns: pydantic.v1
  description: Create this file with the given access mode, if it doesn't exist.
  summary: Create this file with the given access mode, if it doesn't exist
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: mode
    default: '438'
    rest: false
  - kind: positional
    name: exist_ok
    default: 'True'
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.unlink
  kind: method
  ns: pydantic.v1
  description: |-
    Remove this file or link.
    If the path is a directory, use rmdir() instead.
  summary: Remove this file or link
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: missing_ok
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.with_name
  kind: method
  ns: pydantic.v1
  description: Return a new path with the file name changed.
  summary: Return a new path with the file name changed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: name
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.with_stem
  kind: method
  ns: pydantic.v1
  description: Return a new path with the stem changed.
  summary: Return a new path with the stem changed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: stem
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.with_suffix
  kind: method
  ns: pydantic.v1
  description: |-
    Return a new path with the file suffix changed.  If the path
    has no suffix, add given suffix.  If the given suffix is an empty
    string, remove the suffix from the path.
  summary: Return a new path with the file suffix changed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.write_bytes
  kind: method
  ns: pydantic.v1
  description: Open the file in bytes mode, write to it, and close the file.
  summary: Open the file in bytes mode, write to it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: DirectoryPath.write_text
  kind: method
  ns: pydantic.v1
  description: Open the file in text mode, write to it, and close the file.
  summary: Open the file in text mode, write to it, and close the file
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: data
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: None
    rest: false
  - kind: positional
    name: errors
    default: None
    rest: false
  - kind: positional
    name: newline
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: Json
  kind: class
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: Json
  inherits_from: null
- name: JsonWrapper
  kind: class
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - type: JsonWrapper
  inherits_from: null
- name: SecretField
  kind: class
  ns: pydantic.v1
  description: |-
    Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,
    the `__init__()` should be part of the abstract class and the
    `get_secret_value()` method should use the generic `T` type.

    However Cython doesn't support very well generics at the moment and
    the generated code fails to be imported (see
    https://github.com/cython/cython/issues/2753).
  summary: 'Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,'
  signatures:
  - type: SecretField
  inherits_from:
  - <class 'abc.ABC'>
- name: SecretField.get_secret_value
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretStr
  kind: class
  ns: pydantic.v1
  description: |-
    Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,
    the `__init__()` should be part of the abstract class and the
    `get_secret_value()` method should use the generic `T` type.

    However Cython doesn't support very well generics at the moment and
    the generated code fails to be imported (see
    https://github.com/cython/cython/issues/2753).
  summary: 'Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: SecretStr
  inherits_from:
  - <class 'pydantic.v1.types.SecretField'>
  - <class 'abc.ABC'>
- name: SecretStr.display
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretStr.get_secret_value
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretStr.max_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SecretStr.min_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SecretStr.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretBytes
  kind: class
  ns: pydantic.v1
  description: |-
    Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,
    the `__init__()` should be part of the abstract class and the
    `get_secret_value()` method should use the generic `T` type.

    However Cython doesn't support very well generics at the moment and
    the generated code fails to be imported (see
    https://github.com/cython/cython/issues/2753).
  summary: 'Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: SecretBytes
  inherits_from:
  - <class 'pydantic.v1.types.SecretField'>
  - <class 'abc.ABC'>
- name: SecretBytes.display
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretBytes.get_secret_value
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: SecretBytes.max_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SecretBytes.min_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: SecretBytes.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBool
  kind: class
  ns: pydantic.v1
  description: StrictBool to allow for bools which are not type-coerced.
  summary: StrictBool to allow for bools which are not type-coerced
  signatures: null
  inherits_from:
  - <class 'int'>
- name: StrictBool.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBool.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBool.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBool.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: StrictBool.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: StrictBool.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: StrictBool.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: StrictBool.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: StrictBool.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: StrictBool.validate
  kind: function
  ns: pydantic.v1
  description: Ensure that we only allow bools.
  summary: Ensure that we only allow bools
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes
  kind: class
  ns: pydantic.v1
  description: |-
    bytes(iterable_of_ints) -> bytes
    bytes(string, encoding[, errors]) -> bytes
    bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
    bytes(int) -> bytes object of size given by the parameter initialized with null bytes
    bytes() -> empty bytes object

    Construct an immutable array of bytes from:
      - an iterable yielding integers in range(256)
      - a text string encoded using the specified encoding
      - any object implementing the buffer API.
      - an integer
  summary: bytes(iterable_of_ints) -> bytes
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedBytes'>
  - <class 'bytes'>
- name: StrictBytes.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    B.capitalize() -> copy of B

    Return a copy of B with only its first character capitalized (ASCII)
    and the rest lower-cased.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character.
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: b' '
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.count
  kind: callable
  ns: pydantic.v1
  description: |-
    B.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of subsection sub in
    bytes B[start:end].  Optional arguments start and end are interpreted
    as in slice notation.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.decode
  kind: callable
  ns: pydantic.v1
  description: |-
    Decode the bytes using the codec registered for encoding.

    encoding
      The encoding with which to decode the bytes.
    errors
      The error handling scheme to use for the handling of decoding errors.
      The default is 'strict' meaning that decoding errors raise a
      UnicodeDecodeError. Other possible values are 'ignore' and 'replace'
      as well as any other name registered with codecs.register_error that
      can handle UnicodeDecodeErrors.
  summary: Decode the bytes using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    B.endswith(suffix[, start[, end]]) -> bool

    Return True if B ends with the specified suffix, False otherwise.
    With optional start, test B beginning at that position.
    With optional end, stop comparing B at that position.
    suffix can also be a tuple of bytes to try.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.find
  kind: callable
  ns: pydantic.v1
  description: |-
    B.find(sub[, start[, end]]) -> int

    Return the lowest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Create a string of hexadecimal numbers from a bytes object.

      sep
        An optional single character or byte to separate hex bytes.
      bytes_per_sep
        How many bytes between separators.  Positive values count from the
        right, negative values count from the left.

    Example:
    >>> value = b'\xb9\x01\xef'
    >>> value.hex()
    'b901ef'
    >>> value.hex(':')
    'b9:01:ef'
    >>> value.hex(':', 2)
    'b9:01ef'
    >>> value.hex(':', -2)
    'b901:ef'
  summary: Create a string of hexadecimal numbers from a bytes object
  signatures: null
  inherits_from: null
- name: StrictBytes.index
  kind: callable
  ns: pydantic.v1
  description: |-
    B.index(sub[, start[, end]]) -> int

    Return the lowest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the subsection is not found.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isalnum() -> bool

    Return True if all characters in B are alphanumeric
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isalpha() -> bool

    Return True if all characters in B are alphabetic
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isascii() -> bool

    Return True if B is empty or all characters in B are ASCII,
    False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isdigit() -> bool

    Return True if all characters in B are digits
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    B.islower() -> bool

    Return True if all cased characters in B are lowercase and there is
    at least one cased character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isspace() -> bool

    Return True if all characters in B are whitespace
    and there is at least one character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    B.istitle() -> bool

    Return True if B is a titlecased string and there is at least one
    character in B, i.e. uppercase characters may only follow uncased
    characters and lowercase characters only cased ones. Return False
    otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    B.isupper() -> bool

    Return True if all cased characters in B are uppercase and there is
    at least one cased character in B, False otherwise.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of bytes objects.

    The bytes whose method is called is inserted in between each pair.

    The result is returned as a new bytes object.

    Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.
  summary: Concatenate any number of bytes objects
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable_of_bytes
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character.
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: b' '
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.lower
  kind: callable
  ns: pydantic.v1
  description: |-
    B.lower() -> copy of B

    Return a copy of B with all ASCII characters converted to lowercase.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Strip leading bytes contained in the argument.

    If the argument is omitted or None, strip leading  ASCII whitespace.
  summary: Strip leading bytes contained in the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.max_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictBytes.min_length
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictBytes.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the bytes into three parts using the given separator.

    This will search for the separator sep in the bytes. If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original bytes
    object and two empty bytes objects.
  summary: Partition the bytes into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a bytes object with the given prefix string removed if present.

    If the bytes starts with the prefix string, return bytes[len(prefix):].
    Otherwise, return a copy of the original bytes.
  summary: Return a bytes object with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a bytes object with the given suffix string removed if present.

    If the bytes ends with the suffix string and that suffix is not empty,
    return bytes[:-len(prefix)].  Otherwise, return a copy of the original
    bytes.
  summary: Return a bytes object with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    B.rfind(sub[, start[, end]]) -> int

    Return the highest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    B.rindex(sub[, start[, end]]) -> int

    Return the highest index in B where subsection sub is found,
    such that sub is contained within B[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raise ValueError when the subsection is not found.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character.
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: b' '
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the bytes into three parts using the given separator.

    This will search for the separator sep in the bytes, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty bytes
    objects and the original bytes object.
  summary: Partition the bytes into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the sections in the bytes, using sep as the delimiter.

      sep
        The delimiter according which to split the bytes.
        None (the default value) means split on ASCII whitespace characters
        (space, tab, return, newline, formfeed, vertical tab).
      maxsplit
        Maximum number of splits to do.
        -1 (the default value) means no limit.

    Splitting is done starting at the end of the bytes and working to the front.
  summary: Return a list of the sections in the bytes, using sep as the delimiter
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Strip trailing bytes contained in the argument.

    If the argument is omitted or None, strip trailing ASCII whitespace.
  summary: Strip trailing bytes contained in the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the sections in the bytes, using sep as the delimiter.

    sep
      The delimiter according which to split the bytes.
      None (the default value) means split on ASCII whitespace characters
      (space, tab, return, newline, formfeed, vertical tab).
    maxsplit
      Maximum number of splits to do.
      -1 (the default value) means no limit.
  summary: Return a list of the sections in the bytes, using sep as the delimiter
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the bytes, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the bytes, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    B.startswith(prefix[, start[, end]]) -> bool

    Return True if B starts with the specified prefix, False otherwise.
    With optional start, test B beginning at that position.
    With optional end, stop comparing B at that position.
    prefix can also be a tuple of bytes to try.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictBytes.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Strip leading and trailing bytes contained in the argument.

    If the argument is omitted or None, strip leading and trailing ASCII whitespace.
  summary: Strip leading and trailing bytes contained in the argument
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: bytes
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictBytes.swapcase
  kind: callable
  ns: pydantic.v1
  description: |-
    B.swapcase() -> copy of B

    Return a copy of B with uppercase ASCII characters converted
    to lowercase ASCII and vice versa.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.title
  kind: callable
  ns: pydantic.v1
  description: |-
    B.title() -> copy of B

    Return a titlecased version of B, i.e. ASCII words start with uppercase
    characters, all remaining cased characters have lowercase.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.to_lower
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictBytes.to_upper
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictBytes.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with each character mapped by the given translation table.

      table
        Translation table, which must be a bytes object of length 256.

    All characters occurring in the optional argument delete are removed.
    The remaining characters are mapped through the given translation table.
  summary: Return a copy with each character mapped by the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - kind: positional
    name: delete
    default: b''
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictBytes.upper
  kind: callable
  ns: pydantic.v1
  description: |-
    B.upper() -> copy of B

    Return a copy of B with all ASCII characters converted to uppercase.
  summary: B
  signatures: null
  inherits_from: null
- name: StrictBytes.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The original string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictInt
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedInt'>
  - <class 'int'>
- name: StrictInt.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictInt.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictInt.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictInt.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: StrictInt.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: StrictInt.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictInt.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictInt.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: StrictInt.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictInt.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictInt.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictInt.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: StrictInt.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: StrictInt.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: StrictInt.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: StrictFloat
  kind: class
  ns: pydantic.v1
  description: Convert a string or number to a floating point number, if possible.
  summary: Convert a string or number to a floating point number, if possible
  signatures:
  - kind: positional
    name: x
    default: '0'
    rest: false
  - type: StrictFloat
  inherits_from:
  - <class 'pydantic.v1.types.ConstrainedFloat'>
  - <class 'float'>
- name: StrictFloat.allow_inf_nan
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictFloat.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original float
    and with a positive denominator.

    Raise OverflowError on infinities and a ValueError on NaNs.

    >>> (10.0).as_integer_ratio()
    (10, 1)
    >>> (0.0).as_integer_ratio()
    (0, 1)
    >>> (-.25).as_integer_ratio()
    (-1, 4)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictFloat.conjugate
  kind: callable
  ns: pydantic.v1
  description: Return self, the complex conjugate of any float.
  summary: Return self, the complex conjugate of any float
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictFloat.ge
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictFloat.gt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictFloat.hex
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a hexadecimal representation of a floating-point number.

    >>> (-0.1).hex()
    '-0x1.999999999999ap-4'
    >>> 3.14159.hex()
    '0x1.921f9f01b866ep+1'
  summary: Return a hexadecimal representation of a floating-point number
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictFloat.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: StrictFloat.is_integer
  kind: callable
  ns: pydantic.v1
  description: Return True if the float is an integer.
  summary: Return True if the float is an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: StrictFloat.le
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictFloat.lt
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictFloat.multiple_of
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: StrictFloat.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: StrictFloat.strict
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PaymentCardNumber
  kind: class
  ns: pydantic.v1
  description: 'Based on: https://en.wikipedia.org/wiki/Payment_card_number'
  summary: 'Based on: https://en'
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: PaymentCardNumber
  inherits_from:
  - <class 'str'>
- name: PaymentCardNumber.capitalize
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a capitalized version of the string.

    More specifically, make the first character have upper case and the rest lower
    case.
  summary: Return a capitalized version of the string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.casefold
  kind: callable
  ns: pydantic.v1
  description: Return a version of the string suitable for caseless comparisons.
  summary: Return a version of the string suitable for caseless comparisons
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.center
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a centered string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a centered string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.count
  kind: callable
  ns: pydantic.v1
  description: |-
    S.count(sub[, start[, end]]) -> int

    Return the number of non-overlapping occurrences of substring sub in
    string S[start:end].  Optional arguments start and end are
    interpreted as in slice notation.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.encode
  kind: callable
  ns: pydantic.v1
  description: |-
    Encode the string using the codec registered for encoding.

    encoding
      The encoding in which to encode the string.
    errors
      The error handling scheme to use for encoding errors.
      The default is 'strict' meaning that encoding errors raise a
      UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and
      'xmlcharrefreplace' as well as any other name registered with
      codecs.register_error that can handle UnicodeEncodeErrors.
  summary: Encode the string using the codec registered for encoding
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: encoding
    default: utf-8
    rest: false
  - kind: positional
    name: errors
    default: strict
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.endswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.endswith(suffix[, start[, end]]) -> bool

    Return True if S ends with the specified suffix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    suffix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.expandtabs
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy where all tab characters are expanded using spaces.

    If tabsize is not given, a tab size of 8 characters is assumed.
  summary: Return a copy where all tab characters are expanded using spaces
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: tabsize
    default: '8'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.find
  kind: callable
  ns: pydantic.v1
  description: |-
    S.find(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.format
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format(*args, **kwargs) -> str

    Return a formatted version of S, using substitutions from args and kwargs.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.format_map
  kind: callable
  ns: pydantic.v1
  description: |-
    S.format_map(mapping) -> str

    Return a formatted version of S, using substitutions from mapping.
    The substitutions are identified by braces ('{' and '}').
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.index
  kind: callable
  ns: pydantic.v1
  description: |-
    S.index(sub[, start[, end]]) -> int

    Return the lowest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.isalnum
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alpha-numeric string, False otherwise.

    A string is alpha-numeric if all characters in the string are alpha-numeric and
    there is at least one character in the string.
  summary: Return True if the string is an alpha-numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isalpha
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an alphabetic string, False otherwise.

    A string is alphabetic if all characters in the string are alphabetic and there
    is at least one character in the string.
  summary: Return True if the string is an alphabetic string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isascii
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if all characters in the string are ASCII, False otherwise.

    ASCII characters have code points in the range U+0000-U+007F.
    Empty string is ASCII too.
  summary: Return True if all characters in the string are ASCII, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isdecimal
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a decimal string, False otherwise.

    A string is a decimal string if all characters in the string are decimal and
    there is at least one character in the string.
  summary: Return True if the string is a decimal string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isdigit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a digit string, False otherwise.

    A string is a digit string if all characters in the string are digits and there
    is at least one character in the string.
  summary: Return True if the string is a digit string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isidentifier
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a valid Python identifier, False otherwise.

    Call keyword.iskeyword(s) to test whether string s is a reserved identifier,
    such as "def" or "class".
  summary: Return True if the string is a valid Python identifier, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.islower
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a lowercase string, False otherwise.

    A string is lowercase if all cased characters in the string are lowercase and
    there is at least one cased character in the string.
  summary: Return True if the string is a lowercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isnumeric
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a numeric string, False otherwise.

    A string is numeric if all characters in the string are numeric and there is at
    least one character in the string.
  summary: Return True if the string is a numeric string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isprintable
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is printable, False otherwise.

    A string is printable if all of its characters are considered printable in
    repr() or if it is empty.
  summary: Return True if the string is printable, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isspace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a whitespace string, False otherwise.

    A string is whitespace if all characters in the string are whitespace and there
    is at least one character in the string.
  summary: Return True if the string is a whitespace string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.istitle
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is a title-cased string, False otherwise.

    In a title-cased string, upper- and title-case characters may only
    follow uncased characters and lowercase characters only cased ones.
  summary: Return True if the string is a title-cased string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.isupper
  kind: callable
  ns: pydantic.v1
  description: |-
    Return True if the string is an uppercase string, False otherwise.

    A string is uppercase if all cased characters in the string are uppercase and
    there is at least one cased character in the string.
  summary: Return True if the string is an uppercase string, False otherwise
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.join
  kind: callable
  ns: pydantic.v1
  description: |-
    Concatenate any number of strings.

    The string whose method is called is inserted in between each given string.
    The result is returned as a new string.

    Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'
  summary: Concatenate any number of strings
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: iterable
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.ljust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a left-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.lower
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to lowercase.
  summary: Return a copy of the string converted to lowercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.lstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.masked
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.max_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.min_length
  kind: property
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.partition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string.  If the separator is found,
    returns a 3-tuple containing the part before the separator, the separator
    itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing the original string
    and two empty strings.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.removeprefix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given prefix string removed if present.

    If the string starts with the prefix string, return string[len(prefix):].
    Otherwise, return a copy of the original string.
  summary: Return a str with the given prefix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: prefix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.removesuffix
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a str with the given suffix string removed if present.

    If the string ends with the suffix string and that suffix is not empty,
    return string[:-len(suffix)]. Otherwise, return a copy of the original
    string.
  summary: Return a str with the given suffix string removed if present
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: suffix
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.replace
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy with all occurrences of substring old replaced by new.

      count
        Maximum number of occurrences to replace.
        -1 (the default value) means replace all occurrences.

    If the optional argument count is given, only the first count occurrences are
    replaced.
  summary: Return a copy with all occurrences of substring old replaced by new
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: old
    default: null
    rest: false
  - kind: positional
    name: new
    default: null
    rest: false
  - kind: positional
    name: count
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rfind
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rfind(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.rindex
  kind: callable
  ns: pydantic.v1
  description: |-
    S.rindex(sub[, start[, end]]) -> int

    Return the highest index in S where substring sub is found,
    such that sub is contained within S[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Raises ValueError when the substring is not found.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.rjust
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
  summary: Return a right-justified string of length width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - kind: positional
    name: fillchar
    default: ' '
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rpartition
  kind: callable
  ns: pydantic.v1
  description: |-
    Partition the string into three parts using the given separator.

    This will search for the separator in the string, starting at the end. If
    the separator is found, returns a 3-tuple containing the part before the
    separator, the separator itself, and the part after it.

    If the separator is not found, returns a 3-tuple containing two empty strings
    and the original string.
  summary: Partition the string into three parts using the given separator
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rsplit
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the end of the string and works to the front.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.rstrip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.split
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the substrings in the string, using sep as the separator string.

      sep
        The separator used to split the string.

        When set to None (the default value), will split on any whitespace
        character (including \n \r \t \f and spaces) and will discard
        empty strings from the result.
      maxsplit
        Maximum number of splits.
        -1 (the default value) means no limit.

    Splitting starts at the front of the string and works to the end.

    Note, str.split() is mainly useful for data that has been intentionally
    delimited.  With natural text that includes punctuation, consider using
    the regular expression module.
  summary: Return a list of the substrings in the string, using sep as the separator string
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: sep
    default: None
    rest: false
  - kind: positional
    name: maxsplit
    default: '-1'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.splitlines
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a list of the lines in the string, breaking at line boundaries.

    Line breaks are not included in the resulting list unless keepends is given and
    true.
  summary: Return a list of the lines in the string, breaking at line boundaries
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: keepends
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.startswith
  kind: callable
  ns: pydantic.v1
  description: |-
    S.startswith(prefix[, start[, end]]) -> bool

    Return True if S starts with the specified prefix, False otherwise.
    With optional start, test S beginning at that position.
    With optional end, stop comparing S at that position.
    prefix can also be a tuple of strings to try.
  summary: S
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.strip
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a copy of the string with leading and trailing whitespace removed.

    If chars is given and not None, remove characters in chars instead.
  summary: Return a copy of the string with leading and trailing whitespace removed
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: chars
    default: None
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.strip_whitespace
  kind: property
  ns: pydantic.v1
  description: |-
    bool(x) -> bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
  summary: bool(x) -> bool
  signatures: null
  inherits_from: null
- name: PaymentCardNumber.swapcase
  kind: callable
  ns: pydantic.v1
  description: Convert uppercase characters to lowercase and lowercase characters to uppercase.
  summary: Convert uppercase characters to lowercase and lowercase characters to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.title
  kind: callable
  ns: pydantic.v1
  description: |-
    Return a version of the string where each word is titlecased.

    More specifically, words start with uppercased characters and all remaining
    cased characters have lower case.
  summary: Return a version of the string where each word is titlecased
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.translate
  kind: callable
  ns: pydantic.v1
  description: |-
    Replace each character in the string using the given translation table.

      table
        Translation table, which must be a mapping of Unicode ordinals to
        Unicode ordinals, strings, or None.

    The table must implement lookup/indexing via __getitem__, for instance a
    dictionary or list.  If this operation raises LookupError, the character is
    left untouched.  Characters mapped to None are deleted.
  summary: Replace each character in the string using the given translation table
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: table
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.upper
  kind: callable
  ns: pydantic.v1
  description: Return a copy of the string converted to uppercase.
  summary: Return a copy of the string converted to uppercase
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate_digits
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate_length_for_brand
  kind: function
  ns: pydantic.v1
  description: |-
    Validate length based on BIN for major brands:
    https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)
  summary: 'Validate length based on BIN for major brands:'
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.validate_luhn_check_digit
  kind: function
  ns: pydantic.v1
  description: 'Based on: https://en.wikipedia.org/wiki/Luhn_algorithm'
  summary: 'Based on: https://en'
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: card_number
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PaymentCardNumber.zfill
  kind: callable
  ns: pydantic.v1
  description: |-
    Pad a numeric string with zeros on the left, to fill a field of the given width.

    The string is never truncated.
  summary: Pad a numeric string with zeros on the left, to fill a field of the given width
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: width
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PrivateAttr
  kind: function
  ns: pydantic.v1
  description: |-
    Indicates that attribute is only used internally and never mixed with regular fields.

    Types or values of private attrs are not checked by pydantic and it's up to you to keep them relevant.

    Private attrs are stored in model __slots__.

    :param default: the attributeâ€™s default value
    :param default_factory: callable that will be called when a default value is needed for this attribute
      If both `default` and `default_factory` are set, an error is raised.
  summary: Indicates that attribute is only used internally and never mixed with regular fields
  signatures:
  - kind: positional
    name: default
    default: PydanticUndefined
    rest: false
  - name: default_factory
    default: None
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ByteSize
  kind: class
  ns: pydantic.v1
  description: |-
    int([x]) -> integer
    int(x, base=10) -> integer

    Convert a number or string to an integer, or return 0 if no arguments
    are given.  If x is a number, return x.__int__().  For floating point
    numbers, this truncates towards zero.

    If x is not a number or if base is given, then x must be a string,
    bytes, or bytearray instance representing an integer literal in the
    given base.  The literal can be preceded by '+' or '-' and be surrounded
    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
    Base 0 means to interpret the base from the string as an integer literal.
    >>> int('0b100', base=0)
    4
  summary: int([x]) -> integer
  signatures: null
  inherits_from:
  - <class 'int'>
- name: ByteSize.as_integer_ratio
  kind: callable
  ns: pydantic.v1
  description: |-
    Return integer ratio.

    Return a pair of integers, whose ratio is exactly equal to the original int
    and with a positive denominator.

    >>> (10).as_integer_ratio()
    (10, 1)
    >>> (-10).as_integer_ratio()
    (-10, 1)
    >>> (0).as_integer_ratio()
    (0, 1)
  summary: Return integer ratio
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.bit_count
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of ones in the binary representation of the absolute value of self.

    Also known as the population count.

    >>> bin(13)
    '0b1101'
    >>> (13).bit_count()
    3
  summary: Number of ones in the binary representation of the absolute value of self
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.bit_length
  kind: callable
  ns: pydantic.v1
  description: |-
    Number of bits necessary to represent self in binary.

    >>> bin(37)
    '0b100101'
    >>> (37).bit_length()
    6
  summary: Number of bits necessary to represent self in binary
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.conjugate
  kind: callable
  ns: pydantic.v1
  description: Returns self, the complex conjugate of any int.
  summary: Returns self, the complex conjugate of any int
  signatures: null
  inherits_from: null
- name: ByteSize.denominator
  kind: property
  ns: pydantic.v1
  description: the denominator of a rational number in lowest terms
  summary: the denominator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: ByteSize.human_readable
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: decimal
    default: 'False'
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.imag
  kind: property
  ns: pydantic.v1
  description: the imaginary part of a complex number
  summary: the imaginary part of a complex number
  signatures: null
  inherits_from: null
- name: ByteSize.numerator
  kind: property
  ns: pydantic.v1
  description: the numerator of a rational number in lowest terms
  summary: the numerator of a rational number in lowest terms
  signatures: null
  inherits_from: null
- name: ByteSize.real
  kind: property
  ns: pydantic.v1
  description: the real part of a complex number
  summary: the real part of a complex number
  signatures: null
  inherits_from: null
- name: ByteSize.to
  kind: method
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: unit
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: ByteSize.to_bytes
  kind: callable
  ns: pydantic.v1
  description: |-
    Return an array of bytes representing an integer.

    length
      Length of bytes object to use.  An OverflowError is raised if the
      integer is not representable with the given number of bytes.  Default
      is length 1.
    byteorder
      The byte order used to represent the integer.  If byteorder is 'big',
      the most significant byte is at the beginning of the byte array.  If
      byteorder is 'little', the most significant byte is at the end of the
      byte array.  To request the native byte order of the host system, use
      `sys.byteorder' as the byte order value.  Default is to use 'big'.
    signed
      Determines whether two's complement is used to represent the integer.
      If signed is False and a negative integer is given, an OverflowError
      is raised.
  summary: Return an array of bytes representing an integer
  signatures:
  - kind: positional
    name: self
    default: null
    rest: false
  - kind: positional
    name: length
    default: '1'
    rest: false
  - kind: positional
    name: byteorder
    default: big
    rest: false
  - name: signed
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: ByteSize.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: v
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PastDate
  kind: class
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from:
  - <class 'datetime.date'>
- name: PastDate.ctime
  kind: callable
  ns: pydantic.v1
  description: Return ctime() style string.
  summary: Return ctime() style string
  signatures: null
  inherits_from: null
- name: PastDate.day
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PastDate.isocalendar
  kind: callable
  ns: pydantic.v1
  description: Return a named tuple containing ISO year, week number, and weekday.
  summary: Return a named tuple containing ISO year, week number, and weekday
  signatures: null
  inherits_from: null
- name: PastDate.isoformat
  kind: callable
  ns: pydantic.v1
  description: Return string in ISO 8601 format, YYYY-MM-DD.
  summary: Return string in ISO 8601 format, YYYY-MM-DD
  signatures: null
  inherits_from: null
- name: PastDate.isoweekday
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the day of the week represented by the date.
    Monday == 1 ... Sunday == 7
  summary: Return the day of the week represented by the date
  signatures: null
  inherits_from: null
- name: PastDate.max
  kind: property
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from: null
- name: PastDate.min
  kind: property
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from: null
- name: PastDate.month
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: PastDate.replace
  kind: callable
  ns: pydantic.v1
  description: Return date with new specified fields.
  summary: Return date with new specified fields
  signatures: null
  inherits_from: null
- name: PastDate.resolution
  kind: property
  ns: pydantic.v1
  description: |-
    Difference between two datetime values.

    timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

    All arguments are optional and default to 0.
    Arguments may be integers or floats, and may be positive or negative.
  summary: Difference between two datetime values
  signatures: null
  inherits_from: null
- name: PastDate.strftime
  kind: callable
  ns: pydantic.v1
  description: format -> strftime() style string.
  summary: format -> strftime() style string
  signatures: null
  inherits_from: null
- name: PastDate.timetuple
  kind: callable
  ns: pydantic.v1
  description: Return time tuple, compatible with time.localtime().
  summary: Return time tuple, compatible with time
  signatures: null
  inherits_from: null
- name: PastDate.toordinal
  kind: callable
  ns: pydantic.v1
  description: Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.
  summary: Return proleptic Gregorian ordinal
  signatures: null
  inherits_from: null
- name: PastDate.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: PastDate.weekday
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the day of the week represented by the date.
    Monday == 0 ... Sunday == 6
  summary: Return the day of the week represented by the date
  signatures: null
  inherits_from: null
- name: PastDate.year
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FutureDate
  kind: class
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from:
  - <class 'datetime.date'>
- name: FutureDate.ctime
  kind: callable
  ns: pydantic.v1
  description: Return ctime() style string.
  summary: Return ctime() style string
  signatures: null
  inherits_from: null
- name: FutureDate.day
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FutureDate.isocalendar
  kind: callable
  ns: pydantic.v1
  description: Return a named tuple containing ISO year, week number, and weekday.
  summary: Return a named tuple containing ISO year, week number, and weekday
  signatures: null
  inherits_from: null
- name: FutureDate.isoformat
  kind: callable
  ns: pydantic.v1
  description: Return string in ISO 8601 format, YYYY-MM-DD.
  summary: Return string in ISO 8601 format, YYYY-MM-DD
  signatures: null
  inherits_from: null
- name: FutureDate.isoweekday
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the day of the week represented by the date.
    Monday == 1 ... Sunday == 7
  summary: Return the day of the week represented by the date
  signatures: null
  inherits_from: null
- name: FutureDate.max
  kind: property
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from: null
- name: FutureDate.min
  kind: property
  ns: pydantic.v1
  description: date(year, month, day) --> date object
  summary: date(year, month, day) --> date object
  signatures: null
  inherits_from: null
- name: FutureDate.month
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: FutureDate.replace
  kind: callable
  ns: pydantic.v1
  description: Return date with new specified fields.
  summary: Return date with new specified fields
  signatures: null
  inherits_from: null
- name: FutureDate.resolution
  kind: property
  ns: pydantic.v1
  description: |-
    Difference between two datetime values.

    timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

    All arguments are optional and default to 0.
    Arguments may be integers or floats, and may be positive or negative.
  summary: Difference between two datetime values
  signatures: null
  inherits_from: null
- name: FutureDate.strftime
  kind: callable
  ns: pydantic.v1
  description: format -> strftime() style string.
  summary: format -> strftime() style string
  signatures: null
  inherits_from: null
- name: FutureDate.timetuple
  kind: callable
  ns: pydantic.v1
  description: Return time tuple, compatible with time.localtime().
  summary: Return time tuple, compatible with time
  signatures: null
  inherits_from: null
- name: FutureDate.toordinal
  kind: callable
  ns: pydantic.v1
  description: Return proleptic Gregorian ordinal.  January 1 of year 1 is day 1.
  summary: Return proleptic Gregorian ordinal
  signatures: null
  inherits_from: null
- name: FutureDate.validate
  kind: function
  ns: pydantic.v1
  description: null
  summary: ''
  signatures:
  - kind: positional
    name: cls
    default: null
    rest: false
  - kind: positional
    name: value
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: FutureDate.weekday
  kind: callable
  ns: pydantic.v1
  description: |-
    Return the day of the week represented by the date.
    Monday == 0 ... Sunday == 6
  summary: Return the day of the week represented by the date
  signatures: null
  inherits_from: null
- name: FutureDate.year
  kind: property
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: compiled
  kind: const
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: VERSION
  kind: const
  ns: pydantic.v1
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: pydantic.validate_call_decorator
  kind: module
  ns: null
  description: Decorator for validating function calls.
  summary: Decorator for validating function calls
  signatures: null
  inherits_from: null
- name: validate_call
  kind: function
  ns: pydantic.validate_call_decorator
  description: |-
    Usage docs: https://docs.pydantic.dev/2.6/concepts/validation_decorator/

    Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.

    Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.

    Args:
        __func: The function to be decorated.
        config: The configuration dictionary.
        validate_return: Whether to validate the return value.

    Returns:
        The decorated function.
  summary: 'Usage docs: https://docs'
  signatures:
  - kind: positional
    name: __func
    default: None
    rest: false
  - name: config
    default: None
    rest: false
    kind: kw-only
  - name: validate_return
    default: 'False'
    rest: false
    kind: kw-only
  - type: '?'
  inherits_from: null
- name: pydantic.validators
  kind: module
  ns: null
  description: The `validators` module is a backport module from V1.
  summary: The `validators` module is a backport module from V1
  signatures: null
  inherits_from: null
- name: getattr_migration
  kind: function
  ns: pydantic.validators
  description: |-
    Implement PEP 562 for objects that were either moved or removed on the migration
    to V2.

    Args:
        module: The module name.

    Returns:
        A callable that will raise an error if the object is not found.
  summary: Implement PEP 562 for objects that were either moved or removed on the migration
  signatures:
  - kind: positional
    name: module
    default: null
    rest: false
  - type: '?'
  inherits_from: null
- name: pydantic.version
  kind: module
  ns: null
  description: The `version` module holds the version information for Pydantic.
  summary: The `version` module holds the version information for Pydantic
  signatures: null
  inherits_from: null
- name: VERSION
  kind: const
  ns: pydantic.version
  description: null
  summary: ''
  signatures: null
  inherits_from: null
- name: version_info
  kind: function
  ns: pydantic.version
  description: Return complete version information for Pydantic and its dependencies.
  summary: Return complete version information for Pydantic and its dependencies
  signatures:
  - type: '?'
  inherits_from: null
- name: pydantic.warnings
  kind: module
  ns: null
  description: Pydantic-specific warnings.
  summary: Pydantic-specific warnings
  signatures: null
  inherits_from: null
