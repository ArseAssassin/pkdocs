---
name: Nokogiri
slug: nokogiri
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori
  MUSHA, John Shahid,
  Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis,
  Sergio Arbeo,
  Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick
  MahoneyLicensed under the MIT License.
  https://nokogiri.org/rdoc/table_of_contents.html
homepage: null

---
- name: Nokogiri
  id: nokogiri
  summary: Nokogiri parses and searches XML/HTML very quickly, and also has correctly implemented CSS3 selector support as well as XPath 1.0 support
  description: "# module Nokogiri\n\n[`Nokogiri`](nokogiri) parses and searches XML/HTML very quickly, and also has correctly implemented CSS3 selector support as well as XPath 1.0 support.\n\nParsing a document returns either a [`Nokogiri::XML::Document`](nokogiri/xml/document), or a [`Nokogiri::HTML4::Document`](nokogiri/html4/document) depending on the kind of document you parse.\n\nHere is an example:\n\n``` ruby\nrequire 'nokogiri'\nrequire 'open-uri'\n\n# Get a Nokogiri::HTML4::Document for the page we’re interested in...\n\ndoc = Nokogiri::HTML4(URI.open('http://www.google.com/search?q=tenderlove'))\n\n# Do funky things with it using Nokogiri::XML::Node methods...\n\n####\n# Search for nodes by css\ndoc.css('h3.r a.l').each do |link|\n  puts link.content\nend\n```\n\nSee also:\n\n- [`Nokogiri::XML::Searchable#css`](nokogiri/xml/searchable#method-i-css) for more information about [`CSS`](nokogiri/css) searching\n\n- [`Nokogiri::XML::Searchable#xpath`](nokogiri/xml/searchable#method-i-xpath) for more information about XPath searching\n\n### Constants\n\nHTML\n\nAlias for [`Nokogiri::HTML4`](nokogiri/html4)\n\nJAR_DEPENDENCIES\n\ngenerated by the :vendor_jars rake task\n\nNEKO_VERSION\n\nVERSION\n\nThe version of [`Nokogiri`](nokogiri) you are using\n\nXERCES_VERSION\n\n### Public Class Methods\n\nHTML(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) → Nokogiri::HTML4::Document Show source\n\n``` c\n# File lib/nokogiri/html.rb, line 10\n  \n```\n\nParse [`HTML`](nokogiri/html4). Convenience method for [`Nokogiri::HTML4::Document.parse`](nokogiri/html4/document#method-c-parse)\n\nHTML4(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) → Nokogiri::HTML4::Document Show source\n\n``` ruby\n# File lib/nokogiri/html4.rb, line 10\ndef HTML4(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)\n  Nokogiri::HTML4::Document.parse(input, url, encoding, options, &block)\nend\n```\n\nParse [`HTML`](nokogiri/html4). Convenience method for [`Nokogiri::HTML4::Document.parse`](nokogiri/html4/document#method-c-parse)\n\nHTML5(input, url = nil, encoding = nil, \\*\\*options, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html5.rb, line 30\ndef self.HTML5(input, url = nil, encoding = nil, **options, &block)\n  Nokogiri::HTML5::Document.parse(input, url, encoding, **options, &block)\nend\n```\n\nSince v1.12.0\n\n⚠ [`HTML5`](nokogiri/html5) functionality is not available when running JRuby.\n\nParse an [`HTML5`](nokogiri/html5) document. Convenience method for {Nokogiri::HTML5::Document.parse}\n\nSlop(\\*args, &block) Show source\n\n``` ruby\n# File lib/nokogiri.rb, line 83\ndef Slop(*args, &block)\n  Nokogiri(*args, &block).slop!\nend\n```\n\nParse a document and add the [`Slop`](nokogiri#method-c-Slop) decorator. The [`Slop`](nokogiri#method-c-Slop) decorator implements method_missing such that methods may be used instead of [`CSS`](nokogiri/css) or XPath. For example:\n\n``` ruby\ndoc = Nokogiri::Slop(<<-eohtml)\n  <html>\n    <body>\n      <p>first</p>\n      <p>second</p>\n    </body>\n  </html>\neohtml\nassert_equal('second', doc.html.body.p[1].text)\n```\n\nXML(thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_XML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml.rb, line 7\ndef XML(thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_XML, &block)\n  Nokogiri::XML::Document.parse(thing, url, encoding, options, &block)\nend\n```\n\nParse [`XML`](nokogiri/xml). Convenience method for [`Nokogiri::XML::Document.parse`](nokogiri/xml/document#method-c-parse)\n\nXSLT(stylesheet, modules = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xslt.rb, line 13\ndef XSLT(stylesheet, modules = {})\n  XSLT.parse(stylesheet, modules)\nend\n```\n\nCreate a [`Nokogiri::XSLT::Stylesheet`](nokogiri/xslt/stylesheet) with `stylesheet`.\n\nExample:\n\n``` ruby\nxslt = Nokogiri::XSLT(File.read(ARGV[0]))\n```\n\nmake(input = nil, opts = {}, &blk) Show source\n\n``` ruby\n# File lib/nokogiri.rb, line 60\ndef make(input = nil, opts = {}, &blk)\n  if input\n    Nokogiri::HTML4.fragment(input).children.first\n  else\n    Nokogiri(&blk)\n  end\nend\n```\n\nCreate a new [`Nokogiri::XML::DocumentFragment`](nokogiri/xml/documentfragment)\n\nparse(string, url = nil, encoding = nil, options = nil) { \\|doc\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri.rb, line 42\ndef parse(string, url = nil, encoding = nil, options = nil)\n  if string.respond_to?(:read) ||\n      /^\\s*<(?:!DOCTYPE\\s+)?html[\\s>]/i.match?(string[0, 512])\n    # Expect an HTML indicator to appear within the first 512\n    # characters of a document. (<?xml ?> + <?xml-stylesheet ?>\n    # shouldn't be that long)\n    Nokogiri.HTML4(string, url, encoding,\n      options || XML::ParseOptions::DEFAULT_HTML)\n  else\n    Nokogiri.XML(string, url, encoding,\n      options || XML::ParseOptions::DEFAULT_XML)\n  end.tap do |doc|\n    yield doc if block_given?\n  end\nend\n```\n\nParse an [`HTML`](nokogiri/html4) or [`XML`](nokogiri/xml) document. `string` contains the document.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri.html](https://nokogiri.org/rdoc/Nokogiri.html)"
- name: Nokogiri::ClassResolver
  id: nokogiri/classresolver
  summary: Some classes in Nokogiri are namespaced as a group, for example Document, DocumentFragment, and Builder
  description: "# module Nokogiri::ClassResolver\n\nSome classes in [`Nokogiri`](../nokogiri) are namespaced as a group, for example Document, DocumentFragment, and Builder.\n\nIt’s sometimes necessary to look up the related class, e.g.:\n\n``` ruby\nXML::Builder → XML::Document\nHTML4::Builder → HTML4::Document\nHTML5::Document → HTML5::DocumentFragment\n```\n\nThis module is included into those key classes who need to do this.\n\n### Constants\n\nVALID_NAMESPACES  \n[`related_class`](classresolver#method-i-related_class) restricts matching namespaces to those matching this set.\n\n### Public Instance Methods\n\nrelated_class(class_name) → Class Show source\n\n``` ruby\n# File lib/nokogiri/class_resolver.rb, line 46\ndef related_class(class_name)\n  klass = nil\n  inspecting = self.class\n\n  while inspecting\n    namespace_path = inspecting.name.split(\"::\")[0..-2]\n    inspecting = inspecting.superclass\n\n    next unless VALID_NAMESPACES.include?(namespace_path.last)\n\n    related_class_name = (namespace_path << class_name).join(\"::\")\n    klass = begin\n      Object.const_get(related_class_name)\n    rescue NameError\n      nil\n    end\n    break if klass\n  end\n  klass\nend\n```\n\nFind a class constant within the\n\nSome examples:\n\n``` ruby\nNokogiri::XML::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::XML::DocumentFragment\nNokogiri::HTML4::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::HTML4::DocumentFragment\n```\n\nNote this will also work for subclasses that follow the same convention, e.g.:\n\n``` ruby\nLoofah::HTML::Document.new.related_class(\"DocumentFragment\")\n# => Loofah::HTML::DocumentFragment\n```\n\nAnd even if it’s a subclass, this will iterate through the superclasses:\n\n``` ruby\nclass ThisIsATopLevelClass < Nokogiri::HTML4::Builder ; end\nThisIsATopLevelClass.new.related_class(\"Document\")\n# => Nokogiri::HTML4::Document\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/ClassResolver.html](https://nokogiri.org/rdoc/Nokogiri/ClassResolver.html)"
- name: Nokogiri::ClassResolver#related_class
  id: nokogiri/classresolver#method-i-related_class
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::ClassResolver
  description: "related_class(class_name) → Class Show source\n\n``` ruby\n# File lib/nokogiri/class_resolver.rb, line 46\ndef related_class(class_name)\n  klass = nil\n  inspecting = self.class\n\n  while inspecting\n    namespace_path = inspecting.name.split(\"::\")[0..-2]\n    inspecting = inspecting.superclass\n\n    next unless VALID_NAMESPACES.include?(namespace_path.last)\n\n    related_class_name = (namespace_path << class_name).join(\"::\")\n    klass = begin\n      Object.const_get(related_class_name)\n    rescue NameError\n      nil\n    end\n    break if klass\n  end\n  klass\nend\n```\n\nFind a class constant within the\n\nSome examples:\n\n``` ruby\nNokogiri::XML::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::XML::DocumentFragment\nNokogiri::HTML4::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::HTML4::DocumentFragment\n```\n\nNote this will also work for subclasses that follow the same convention, e.g.:\n\n``` ruby\nLoofah::HTML::Document.new.related_class(\"DocumentFragment\")\n# => Loofah::HTML::DocumentFragment\n```\n\nAnd even if it’s a subclass, this will iterate through the superclasses:\n\n``` ruby\nclass ThisIsATopLevelClass < Nokogiri::HTML4::Builder ; end\nThisIsATopLevelClass.new.related_class(\"Document\")\n# => Nokogiri::HTML4::Document\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/ClassResolver.html](https://nokogiri.org/rdoc/Nokogiri/ClassResolver.html)"
- name: Nokogiri::CSS
  id: nokogiri/css
  summary: Translate a CSS selector to the equivalent XPath query
  description: "# module Nokogiri::CSS\n\nTranslate a [`CSS`](css) selector into an XPath 1.0 query\n\n### Public Class Methods\n\nxpath_for(selector) → String Show source\n\nxpath_for(selector \\[, prefix:\\] \\[, visitor:\\] \\[, ns:\\]) → String\n\n``` ruby\n# File lib/nokogiri/css.rb, line 42\ndef xpath_for(selector, options = {})\n  raise TypeError, \"no implicit conversion of #{selector.inspect} to String\" unless selector.respond_to?(:to_str)\n\n  selector = selector.to_str\n  raise Nokogiri::CSS::SyntaxError, \"empty CSS selector\" if selector.empty?\n\n  prefix = options.fetch(:prefix, Nokogiri::XML::XPath::GLOBAL_SEARCH_PREFIX)\n  visitor = options.fetch(:visitor) { Nokogiri::CSS::XPathVisitor.new }\n  ns = options.fetch(:ns, {})\n\n  Parser.new(ns).xpath_for(selector, prefix, visitor)\nend\n```\n\nTranslate a [`CSS`](css) selector to the equivalent XPath query.\n\nParameters\n\n- `selector` (String) The [`CSS`](css) selector to be translated into XPath\n\n- `prefix:` (String)\n\n  The XPath prefix for the query, see [`Nokogiri::XML::XPath`](xml/xpath) for some options. Default is `XML::XPath::GLOBAL_SEARCH_PREFIX`.\n\n- `visitor:` ([`Nokogiri::CSS::XPathVisitor`](css/xpathvisitor))\n\n  The visitor class to use to transform the AST into XPath. Default is `Nokogiri::CSS::XPathVisitor.new`.\n\n- `ns:` (Hash\\<String ⇒ String\\>)\n\n  The namespaces that are referenced in the query, if any. This is a hash where the keys are the namespace prefix and the values are the namespace URIs. Default is an empty Hash.\n\nReturns  \n(String) The equivalent XPath query for `selector`\n\n💡 Note that translated queries are cached for performance concerns.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS.html](https://nokogiri.org/rdoc/Nokogiri/CSS.html)"
- name: Nokogiri::CSS::SyntaxError
  id: nokogiri/css/syntaxerror
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::CSS::SyntaxError\n\nParent:  \n[Nokogiri::SyntaxError](../syntaxerror)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS/SyntaxError.html](https://nokogiri.org/rdoc/Nokogiri/CSS/SyntaxError.html)"
- name: Nokogiri::CSS::xpath_for
  id: nokogiri/css#method-c-xpath_for
  summary: Translate a CSS selector to the equivalent XPath query
  belongs_to: Nokogiri::CSS
  description: "xpath_for(selector) → String Show source\n\nxpath_for(selector \\[, prefix:\\] \\[, visitor:\\] \\[, ns:\\]) → String\n\n``` ruby\n# File lib/nokogiri/css.rb, line 42\ndef xpath_for(selector, options = {})\n  raise TypeError, \"no implicit conversion of #{selector.inspect} to String\" unless selector.respond_to?(:to_str)\n\n  selector = selector.to_str\n  raise Nokogiri::CSS::SyntaxError, \"empty CSS selector\" if selector.empty?\n\n  prefix = options.fetch(:prefix, Nokogiri::XML::XPath::GLOBAL_SEARCH_PREFIX)\n  visitor = options.fetch(:visitor) { Nokogiri::CSS::XPathVisitor.new }\n  ns = options.fetch(:ns, {})\n\n  Parser.new(ns).xpath_for(selector, prefix, visitor)\nend\n```\n\nTranslate a [`CSS`](css) selector to the equivalent XPath query.\n\nParameters\n\n- `selector` (String) The [`CSS`](css) selector to be translated into XPath\n\n- `prefix:` (String)\n\n  The XPath prefix for the query, see [`Nokogiri::XML::XPath`](xml/xpath) for some options. Default is `XML::XPath::GLOBAL_SEARCH_PREFIX`.\n\n- `visitor:` ([`Nokogiri::CSS::XPathVisitor`](css/xpathvisitor))\n\n  The visitor class to use to transform the AST into XPath. Default is `Nokogiri::CSS::XPathVisitor.new`.\n\n- `ns:` (Hash\\<String ⇒ String\\>)\n\n  The namespaces that are referenced in the query, if any. This is a hash where the keys are the namespace prefix and the values are the namespace URIs. Default is an empty Hash.\n\nReturns\n\n(String) The equivalent XPath query for `selector`\n\n💡 Note that translated queries are cached for performance concerns.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS.html](https://nokogiri.org/rdoc/Nokogiri/CSS.html)"
- name: Nokogiri::CSS::XPathVisitor
  id: nokogiri/css/xpathvisitor
  summary: When translating CSS selectors to XPath queries with Nokogiri::CSS.xpath_for, the XPathVisitor class allows for changing some of the behaviors related to builtin xpath functions and quirks of HTML5
  description: "# class Nokogiri::CSS::XPathVisitor\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nWhen translating [`CSS`](../css) selectors to XPath queries with [`Nokogiri::CSS.xpath_for`](../css#method-c-xpath_for), the [`XPathVisitor`](xpathvisitor) class allows for changing some of the behaviors related to builtin xpath functions and quirks of [`HTML5`](../html5).\n\n### Public Class Methods\n\nnew() → XPathVisitor Show source\n\nnew(builtins:, doctype:) → XPathVisitor\n\n``` ruby\n# File lib/nokogiri/css/xpath_visitor.rb, line 57\ndef initialize(builtins: BuiltinsConfig::NEVER, doctype: DoctypeConfig::XML)\n  unless BuiltinsConfig::VALUES.include?(builtins)\n    raise(ArgumentError, \"Invalid values #{builtins.inspect} for builtins: keyword parameter\")\n  end\n  unless DoctypeConfig::VALUES.include?(doctype)\n    raise(ArgumentError, \"Invalid values #{doctype.inspect} for doctype: keyword parameter\")\n  end\n\n  @builtins = builtins\n  @doctype = doctype\nend\n```\n\nParameters\n\n- `builtins:` ([`BuiltinsConfig`](xpathvisitor/builtinsconfig)) Determine when to use Nokogiri’s built-in xpath functions for performance improvements.\n\n- `doctype:` ([`DoctypeConfig`](xpathvisitor/doctypeconfig)) Make document-type-specific accommodations for [`CSS`](../css) queries.\n\nReturns  \n[`XPathVisitor`](xpathvisitor)\n\n### Public Instance Methods\n\nconfig() → Hash Show source\n\n``` ruby\n# File lib/nokogiri/css/xpath_visitor.rb, line 74\ndef config\n  { builtins: @builtins, doctype: @doctype }\nend\n```\n\nReturns  \na Hash representing the configuration of the [`XPathVisitor`](xpathvisitor), suitable for use as part of the [`CSS`](../css) cache key.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor.html](https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor.html)"
- name: Nokogiri::CSS::XPathVisitor#config
  id: nokogiri/css/xpathvisitor#method-i-config
  summary: a Hash representing the configuration of the XPathVisitor, suitable for use as part of the CSS cache key
  belongs_to: Nokogiri::CSS::XPathVisitor
  description: "config() → Hash Show source\n\n``` ruby\n# File lib/nokogiri/css/xpath_visitor.rb, line 74\ndef config\n  { builtins: @builtins, doctype: @doctype }\nend\n```\n\nReturns\n\na Hash representing the configuration of the [`XPathVisitor`](xpathvisitor), suitable for use as part of the [`CSS`](../css) cache key.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor.html](https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor.html)"
- name: Nokogiri::CSS::XPathVisitor::BuiltinsConfig
  id: nokogiri/css/xpathvisitor/builtinsconfig
  summary: Enum to direct XPathVisitor when to use Nokogiri builtin XPath functions
  description: "# module Nokogiri::CSS::XPathVisitor::BuiltinsConfig\n\nEnum to direct [`XPathVisitor`](../xpathvisitor) when to use [`Nokogiri`](../../../nokogiri) builtin XPath functions.\n\n### Constants\n\nALWAYS  \nAlways use [`Nokogiri`](../../../nokogiri) builtin functions whenever possible. This is probably only useful for testing.\n\nNEVER  \nNever use [`Nokogiri`](../../../nokogiri) builtin functions, always generate vanilla XPath 1.0 queries. This is the default when calling [`Nokogiri::CSS.xpath_for`](../../css#method-c-xpath_for) directly.\n\nOPTIMAL  \nOnly use [`Nokogiri`](../../../nokogiri) builtin functions when they will be faster than vanilla XPath. This is the behavior chosen when searching for [`CSS`](../../css) selectors on a [`Nokogiri`](../../../nokogiri) document, fragment, or node.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor/BuiltinsConfig.html](https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor/BuiltinsConfig.html)"
- name: Nokogiri::CSS::XPathVisitor::DoctypeConfig
  id: nokogiri/css/xpathvisitor/doctypeconfig
  summary: Enum to direct XPathVisitor when to tweak the XPath query to suit the nature of the document being searched
  description: "# module Nokogiri::CSS::XPathVisitor::DoctypeConfig\n\nEnum to direct [`XPathVisitor`](../xpathvisitor) when to tweak the XPath query to suit the nature of the document being searched. Note that searches for [`CSS`](../../css) selectors from a [`Nokogiri`](../../../nokogiri) document, fragment, or node will choose the correct option automatically.\n\n### Constants\n\nHTML4  \nThe document being searched is an [`HTML4`](../../html4) document.\n\nHTML5  \nThe document being searched is an [`HTML5`](../../html5) document.\n\nXML  \nThe document being searched is an [`XML`](../../xml) document. This is the default.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor/DoctypeConfig.html](https://nokogiri.org/rdoc/Nokogiri/CSS/XPathVisitor/DoctypeConfig.html)"
- name: Nokogiri::CSS::XPathVisitor::new
  id: nokogiri/css/xpathvisitor#method-c-new
  summary: 'builtins: (BuiltinsConfig) Determine when to use Nokogiri’s built-in xpath functions for performance improvements'
  belongs_to: Nokogiri::CSS::XPathVisitor
  description: |-
    new() → XPathVisitor Show source

    new(builtins:, doctype:) → XPathVisitor

    ``` ruby
    # File lib/nokogiri/css/xpath_visitor.rb, line 57
    def initialize(builtins: BuiltinsConfig::NEVER, doctype: DoctypeConfig::XML)
      unless BuiltinsConfig::VALUES.include?(builtins)
        raise(ArgumentError, "Invalid values #{builtins.inspect} for builtins: keyword parameter")
      end
      unless DoctypeConfig::VALUES.include?(doctype)
        raise(ArgumentError, "Invalid values #{doctype.inspect} for doctype: keyword parameter")
      end

      @builtins = builtins
      @doctype = doctype
    end
    ```

    Parameters

    - `builtins:` ([`BuiltinsConfig`](xpathvisitor/builtinsconfig)) Determine when to use Nokogiri’s built-in xpath functions for performance improvements.

    - `doctype:` ([`DoctypeConfig`](xpathvisitor/doctypeconfig)) Make document-type-specific accommodations for [`CSS`](../css) queries.

    Returns

    [`XPathVisitor`](xpathvisitor)

    ### Public Instance Methods
- name: Nokogiri::Decorators
  id: nokogiri/decorators
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# module Nokogiri::Decorators\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/Decorators.html](https://nokogiri.org/rdoc/Nokogiri/Decorators.html)"
- name: Nokogiri::Decorators::Slop
  id: nokogiri/decorators/slop
  summary: The Slop decorator implements method missing such that a methods may be used instead of XPath or CSS
  description: "# module Nokogiri::Decorators::Slop\n\nThe [`Slop`](slop) decorator implements method missing such that a methods may be used instead of XPath or [`CSS`](../css). See [`Nokogiri.Slop`](../../nokogiri#method-c-Slop)\n\n### Constants\n\nXPATH_PREFIX  \nThe default XPath search context for [`Slop`](slop)\n\n### Public Instance Methods\n\nmethod_missing(name, \\*args, &block) Show source\n\n``` ruby\n# File lib/nokogiri/decorators/slop.rb, line 14\ndef method_missing(name, *args, &block)\n  if args.empty?\n    list = xpath(\"#{XPATH_PREFIX}#{name.to_s.sub(/^_/, \"\")}\")\n  elsif args.first.is_a?(Hash)\n    hash = args.first\n    if hash[:css]\n      list = css(\"#{name}#{hash[:css]}\")\n    elsif hash[:xpath]\n      conds = Array(hash[:xpath]).join(\" and \")\n      list = xpath(\"#{XPATH_PREFIX}#{name}[#{conds}]\")\n    end\n  else\n    CSS::Parser.without_cache do\n      list = xpath(\n        *CSS.xpath_for(\"#{name}#{args.first}\", prefix: XPATH_PREFIX),\n      )\n    end\n  end\n\n  super if list.empty?\n  list.length == 1 ? list.first : list\nend\n```\n\nlook for node with `name`. See [`Nokogiri.Slop`](../../nokogiri#method-c-Slop)\n\nCalls superclass method\n\nrespond_to_missing?(name, include_private = false) Show source\n\n``` ruby\n# File lib/nokogiri/decorators/slop.rb, line 37\ndef respond_to_missing?(name, include_private = false)\n  list = xpath(\"#{XPATH_PREFIX}#{name.to_s.sub(/^_/, \"\")}\")\n\n  !list.empty?\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/Decorators/Slop.html](https://nokogiri.org/rdoc/Nokogiri/Decorators/Slop.html)"
- name: Nokogiri::Decorators::Slop#method_missing
  id: nokogiri/decorators/slop#method-i-method_missing
  summary: look for node with name
  belongs_to: Nokogiri::Decorators::Slop
  description: |-
    method_missing (name, \*args, &block) Show source

    ``` ruby
    # File lib/nokogiri/decorators/slop.rb, line 14
    def method_missing(name, *args, &block)
      if args.empty?
        list = xpath("#{XPATH_PREFIX}#{name.to_s.sub(/^_/, "")}")
      elsif args.first.is_a?(Hash)
        hash = args.first
        if hash[:css]
          list = css("#{name}#{hash[:css]}")
        elsif hash[:xpath]
          conds = Array(hash[:xpath]).join(" and ")
          list = xpath("#{XPATH_PREFIX}#{name}[#{conds}]")
        end
      else
        CSS::Parser.without_cache do
          list = xpath(
            *CSS.xpath_for("#{name}#{args.first}", prefix: XPATH_PREFIX),
          )
        end
      end

      super if list.empty?
      list.length == 1 ? list.first : list
    end
    ```

    look for node with `name`. See [`Nokogiri.Slop`](../../nokogiri#method-c-Slop)

    Calls superclass method
- name: Nokogiri::Decorators::Slop#respond_to_missing?
  id: nokogiri/decorators/slop#method-i-respond_to_missing-3F
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::Decorators::Slop
  description: "respond_to_missing? (name, include_private = false) Show source\n\n``` ruby\n# File lib/nokogiri/decorators/slop.rb, line 37\ndef respond_to_missing?(name, include_private = false)\n  list = xpath(\"#{XPATH_PREFIX}#{name.to_s.sub(/^_/, \"\")}\")\n\n  !list.empty?\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/Decorators/Slop.html](https://nokogiri.org/rdoc/Nokogiri/Decorators/Slop.html)"
- name: Nokogiri::EncodingHandler
  id: nokogiri/encodinghandler
  summary: USEFUL_ALIASES Popular encoding aliases not known by all iconv implementations that Nokogiri should support
  description: "# class Nokogiri::EncodingHandler\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n### Constants\n\nUSEFUL_ALIASES  \nPopular encoding aliases not known by all iconv implementations that [`Nokogiri`](../nokogiri) should support.\n\n### Public Class Methods\n\nNokogiri::EncodingHandler.\\[\\](name) Show source\n\n``` c\nstatic VALUE\nrb_xml_encoding_handler_s_get(VALUE klass, VALUE key)\n{\n  xmlCharEncodingHandlerPtr handler;\n\n  handler = xmlFindCharEncodingHandler(StringValueCStr(key));\n  if (handler) {\n    return Data_Wrap_Struct(klass, NULL, _xml_encoding_handler_dealloc, handler);\n  }\n\n  return Qnil;\n}\n```\n\nGet the encoding handler for `name`\n\nNokogiri::EncodingHandler.alias(real_name, alias_name) Show source\n\n``` c\nstatic VALUE\nrb_xml_encoding_handler_s_alias(VALUE klass, VALUE from, VALUE to)\n{\n  xmlAddEncodingAlias(StringValueCStr(from), StringValueCStr(to));\n\n  return to;\n}\n```\n\nAlias encoding handler with name `real_name` to name `alias_name`\n\nNokogiri::EncodingHandler.clear_aliases! Show source\n\n``` c\nstatic VALUE\nrb_xml_encoding_handler_s_clear_aliases(VALUE klass)\n{\n  xmlCleanupEncodingAliases();\n\n  return klass;\n}\n```\n\nRemove all encoding aliases.\n\nNokogiri::EncodingHandler.delete(name) Show source\n\n``` c\nstatic VALUE\nrb_xml_encoding_handler_s_delete(VALUE klass, VALUE name)\n{\n  if (xmlDelEncodingAlias(StringValueCStr(name))) { return Qnil; }\n\n  return Qtrue;\n}\n```\n\nDelete the encoding alias named `name`\n\ninstall_default_aliases() Show source\n\n``` ruby\n# File lib/nokogiri/encoding_handler.rb, line 15\ndef install_default_aliases\n  USEFUL_ALIASES.each do |alias_name, name|\n    EncodingHandler.alias(name, alias_name) if EncodingHandler[alias_name].nil?\n  end\nend\n```\n\n### Public Instance Methods\n\nname Show source\n\n``` c\nstatic VALUE\nrb_xml_encoding_handler_name(VALUE self)\n{\n  xmlCharEncodingHandlerPtr handler;\n\n  Data_Get_Struct(self, xmlCharEncodingHandler, handler);\n\n  return NOKOGIRI_STR_NEW2(handler->name);\n}\n```\n\nGet the name of this [`EncodingHandler`](encodinghandler)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/EncodingHandler.html](https://nokogiri.org/rdoc/Nokogiri/EncodingHandler.html)"
- name: Nokogiri::EncodingHandler#name
  id: nokogiri/encodinghandler#method-i-name
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::EncodingHandler
  description: "name Show source\n\n``` c\nstatic VALUE\nrb_xml_encoding_handler_name(VALUE self)\n{\n  xmlCharEncodingHandlerPtr handler;\n\n  Data_Get_Struct(self, xmlCharEncodingHandler, handler);\n\n  return NOKOGIRI_STR_NEW2(handler->name);\n}\n```\n\nGet the name of this [`EncodingHandler`](encodinghandler)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/EncodingHandler.html](https://nokogiri.org/rdoc/Nokogiri/EncodingHandler.html)"
- name: Nokogiri::EncodingHandler::[]
  id: nokogiri/encodinghandler#method-c-5B-5D
  summary: null
  belongs_to: Nokogiri::EncodingHandler
  description: |-
    Nokogiri::EncodingHandler.\[\](name) Show source

    ``` c
    static VALUE
    rb_xml_encoding_handler_s_get(VALUE klass, VALUE key)
    {
      xmlCharEncodingHandlerPtr handler;

      handler = xmlFindCharEncodingHandler(StringValueCStr(key));
      if (handler) {
        return Data_Wrap_Struct(klass, NULL, _xml_encoding_handler_dealloc, handler);
      }

      return Qnil;
    }
    ```

    Get the encoding handler for `name`
- name: Nokogiri::EncodingHandler::alias
  id: nokogiri/encodinghandler#method-c-alias
  summary: null
  belongs_to: Nokogiri::EncodingHandler
  description: |-
    Nokogiri::EncodingHandler.alias(real_name, alias_name) Show source

    ``` c
    static VALUE
    rb_xml_encoding_handler_s_alias(VALUE klass, VALUE from, VALUE to)
    {
      xmlAddEncodingAlias(StringValueCStr(from), StringValueCStr(to));

      return to;
    }
    ```

    Alias encoding handler with name `real_name` to name `alias_name`
- name: Nokogiri::EncodingHandler::clear_aliases!
  id: nokogiri/encodinghandler#method-c-clear_aliases-21
  summary: Remove all encoding aliases
  belongs_to: Nokogiri::EncodingHandler
  description: |-
    Nokogiri::EncodingHandler.clear_aliases! Show source

    ``` c
    static VALUE
    rb_xml_encoding_handler_s_clear_aliases(VALUE klass)
    {
      xmlCleanupEncodingAliases();

      return klass;
    }
    ```

    Remove all encoding aliases.
- name: Nokogiri::EncodingHandler::delete
  id: nokogiri/encodinghandler#method-c-delete
  summary: null
  belongs_to: Nokogiri::EncodingHandler
  description: |-
    Nokogiri::EncodingHandler.delete(name) Show source

    ``` c
    static VALUE
    rb_xml_encoding_handler_s_delete(VALUE klass, VALUE name)
    {
      if (xmlDelEncodingAlias(StringValueCStr(name))) { return Qnil; }

      return Qtrue;
    }
    ```

    Delete the encoding alias named `name`
- name: Nokogiri::EncodingHandler::install_default_aliases
  id: nokogiri/encodinghandler#method-c-install_default_aliases
  summary: null
  belongs_to: Nokogiri::EncodingHandler
  description: |-
    install_default_aliases () Show source

    ``` ruby
    # File lib/nokogiri/encoding_handler.rb, line 15
    def install_default_aliases
      USEFUL_ALIASES.each do |alias_name, name|
        EncodingHandler.alias(name, alias_name) if EncodingHandler[alias_name].nil?
      end
    end
    ```

    ### Public Instance Methods
- name: Nokogiri::Gumbo
  id: nokogiri/gumbo
  summary: DEFAULT_MAX_ATTRIBUTES The default maximum number of attributes per element
  description: "# module Nokogiri::Gumbo\n\n### Constants\n\nDEFAULT_MAX_ATTRIBUTES  \nThe default maximum number of attributes per element.\n\nDEFAULT_MAX_ERRORS  \nThe default maximum number of errors for parsing a document or a fragment.\n\nDEFAULT_MAX_TREE_DEPTH  \nThe default maximum depth of the DOM tree produced by parsing a document or fragment.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/Gumbo.html](https://nokogiri.org/rdoc/Nokogiri/Gumbo.html)"
- name: Nokogiri::HTML
  id: nokogiri#method-c-HTML
  summary: Parse HTML
  belongs_to: Nokogiri
  description: "HTML(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) → Nokogiri::HTML4::Document Show source\n\n``` c\n# File lib/nokogiri/html.rb, line 10\n  \n```\n\nParse [`HTML`](nokogiri/html4). Convenience method for [`Nokogiri::HTML4::Document.parse`](nokogiri/html4/document#method-c-parse)"
- name: Nokogiri::HTML4
  id: nokogiri/html4
  summary: 💡 This module/namespace is an alias for Nokogiri::HTML4 as of v1.12.0
  description: "# module Nokogiri::HTML4\n\n💡 This module/namespace is an alias for [`Nokogiri::HTML4`](html4) as of v1.12.0. Before v1.12.0,\n\n    Nokogiri::HTML4 did not exist, and this was the module/namespace for all HTML-related\n    classes.\n\nSince v1.12.0\n\n💡 Before v1.12.0, [`Nokogiri::HTML4`](html4) did not exist, and [`Nokogiri::HTML`](html4) was the module/namespace for parsing [`HTML`](html4).\n\n### Constants\n\nNamedCharacters  \nInstance of [`Nokogiri::HTML4::EntityLookup`](html4/entitylookup)\n\n### Public Class Methods\n\nfragment(string, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html4.rb, line 29\ndef fragment(string, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)\n  HTML4::DocumentFragment.parse(string, encoding, options, &block)\nend\n```\n\nParse a fragment from `string` in to a NodeSet.\n\nparse(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html4.rb, line 23\ndef parse(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)\n  Document.parse(input, url, encoding, options, &block)\nend\n```\n\nParse [`HTML`](html4). Convenience method for [`Nokogiri::HTML4::Document.parse`](html4/document#method-c-parse)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4.html](https://nokogiri.org/rdoc/Nokogiri/HTML4.html)"
- name: Nokogiri::HTML4
  id: nokogiri#method-c-HTML4
  summary: Parse HTML
  belongs_to: Nokogiri
  description: |-
    HTML4(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) → Nokogiri::HTML4::Document Show source

    ``` ruby
    # File lib/nokogiri/html4.rb, line 10
    def HTML4(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)
      Nokogiri::HTML4::Document.parse(input, url, encoding, options, &block)
    end
    ```

    Parse [`HTML`](nokogiri/html4). Convenience method for [`Nokogiri::HTML4::Document.parse`](nokogiri/html4/document#method-c-parse)
- name: Nokogiri::HTML4::Builder
  id: nokogiri/html4/builder
  summary: Nokogiri HTML builder is used for building HTML documents
  description: "# class Nokogiri::HTML4::Builder\n\nParent:  \n[Nokogiri::XML::Builder](../xml/builder)\n\n[`Nokogiri`](../../nokogiri) [`HTML`](../html4) builder is used for building [`HTML`](../html4) documents. It is very similar to the [`Nokogiri::XML::Builder`](../xml/builder). In fact, you should go read the documentation for [`Nokogiri::XML::Builder`](../xml/builder) before reading this documentation.\n\n## Synopsis:\n\nCreate an [`HTML`](../html4) document with a body that has an onload attribute, and a span tag with a class of “bold” that has content of “Hello world”.\n\n``` ruby\nbuilder = Nokogiri::HTML4::Builder.new do |doc|\n  doc.html {\n    doc.body(:onload => 'some_func();') {\n      doc.span.bold {\n        doc.text \"Hello world\"\n      }\n    }\n  }\nend\nputs builder.to_html\n```\n\nThe [`HTML`](../html4) builder inherits from the [`XML`](../xml) builder, so make sure to read the [`Nokogiri::XML::Builder`](../xml/builder) documentation.\n\n### Public Instance Methods\n\nto_html() Show source\n\n``` ruby\n# File lib/nokogiri/html4/builder.rb, line 32\ndef to_html\n  @doc.to_html\nend\n```\n\nConvert the builder to [`HTML`](../html4)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/Builder.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/Builder.html)"
- name: Nokogiri::HTML4::Builder#to_html
  id: nokogiri/html4/builder#method-i-to_html
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML4::Builder
  description: "to_html () Show source\n\n``` ruby\n# File lib/nokogiri/html4/builder.rb, line 32\ndef to_html\n  @doc.to_html\nend\n```\n\nConvert the builder to [`HTML`](../html4)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/Builder.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/Builder.html)"
- name: Nokogiri::HTML4::Document
  id: nokogiri/html4/document
  summary: Parse HTML
  description: "# class Nokogiri::HTML4::Document\n\nParent:  \n[Nokogiri::XML::Document](../xml/document)\n\n### Public Class Methods\n\nparse(string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 172\ndef parse(string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML)\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil\n\n  if string_or_io.respond_to?(:encoding)\n    unless string_or_io.encoding == Encoding::ASCII_8BIT\n      encoding ||= string_or_io.encoding.name\n    end\n  end\n\n  if string_or_io.respond_to?(:read)\n    if string_or_io.is_a?(Pathname)\n      # resolve the Pathname to the file and open it as an IO object, see #2110\n      string_or_io = string_or_io.expand_path.open\n      url ||= string_or_io.path\n    end\n\n    unless encoding\n      string_or_io = EncodingReader.new(string_or_io)\n      begin\n        return read_io(string_or_io, url, encoding, options.to_i)\n      rescue EncodingReader::EncodingFound => e\n        encoding = e.found_encoding\n      end\n    end\n    return read_io(string_or_io, url, encoding, options.to_i)\n  end\n\n  # read_memory pukes on empty docs\n  if string_or_io.nil? || string_or_io.empty?\n    return encoding ? new.tap { |i| i.encoding = encoding } : new\n  end\n\n  encoding ||= EncodingReader.detect_encoding(string_or_io)\n\n  read_memory(string_or_io, url, encoding, options.to_i)\nend\n```\n\nParse [`HTML`](../html4). `string_or_io` may be a String, or any object that responds to *read* and *close* such as an IO, or StringIO. `url` is resource where this document is located. `encoding` is the encoding that should be used when processing the document. `options` is a number that sets options in the parser, such as Nokogiri::XML::ParseOptions::RECOVER. See the constants in [`Nokogiri::XML::ParseOptions`](../xml/parseoptions).\n\n### Public Instance Methods\n\nfragment(tags = nil) Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 149\ndef fragment(tags = nil)\n  DocumentFragment.new(self, tags, root)\nend\n```\n\nCreate a [`Nokogiri::XML::DocumentFragment`](../xml/documentfragment) from `tags`\n\nmeta_encoding() Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 12\ndef meta_encoding\n  if (meta = at_xpath(\"//meta[@charset]\"))\n    meta[:charset]\n  elsif (meta = meta_content_type)\n    meta[\"content\"][/charset\\s*=\\s*([\\w-]+)/i, 1]\n  end\nend\n```\n\nGet the meta tag encoding for this document. If there is no meta tag, then nil is returned.\n\nmeta_encoding=(encoding) Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 36\ndef meta_encoding=(encoding)\n  if (meta = meta_content_type)\n    meta[\"content\"] = format(\"text/html; charset=%s\", encoding)\n    encoding\n  elsif (meta = at_xpath(\"//meta[@charset]\"))\n    meta[\"charset\"] = encoding\n  else\n    meta = XML::Node.new(\"meta\", self)\n    if (dtd = internal_subset) && dtd.html5_dtd?\n      meta[\"charset\"] = encoding\n    else\n      meta[\"http-equiv\"] = \"Content-Type\"\n      meta[\"content\"] = format(\"text/html; charset=%s\", encoding)\n    end\n\n    if (head = at_xpath(\"//head\"))\n      head.prepend_child(meta)\n    else\n      set_metadata_element(meta)\n    end\n    encoding\n  end\nend\n```\n\nSet the meta tag encoding for this document.\n\nIf an meta encoding tag is already present, its content is replaced with the given text.\n\nOtherwise, this method tries to create one at an appropriate place supplying head and/or html elements as necessary, which is inside a head element if any, and before any text node or content element (typically \\<body\\>) if any.\n\nThe result when trying to set an encoding that is different from the document encoding is undefined.\n\nBeware in CRuby, that libxml2 automatically inserts a meta tag into a head element.\n\nserialize(options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 142\ndef serialize(options = {})\n  options[:save_with] ||= XML::Node::SaveOptions::DEFAULT_HTML\n  super\nend\n```\n\nSerialize Node using `options`. Save options can also be set using a block.\n\nSee also [`Nokogiri::XML::Node::SaveOptions`](../xml/node/saveoptions) and Node.\n\nThese two statements are equivalent:\n\n``` ruby\nnode.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)\n```\n\nor\n\n``` ruby\nnode.serialize(:encoding => 'UTF-8') do |config|\n  config.format.as_xml\nend\n```\n\nCalls superclass method\n\ntitle() Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 70\ndef title\n  (title = at_xpath(\"//title\")) && title.inner_text\nend\n```\n\nGet the title string of this document. Return nil if there is no title tag.\n\ntitle=(text) Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 85\ndef title=(text)\n  tnode = XML::Text.new(text, self)\n  if (title = at_xpath(\"//title\"))\n    title.children = tnode\n    return text\n  end\n\n  title = XML::Node.new(\"title\", self) << tnode\n  if (head = at_xpath(\"//head\"))\n    head << title\n  elsif (meta = (at_xpath(\"//meta[@charset]\") || meta_content_type))\n    # better put after charset declaration\n    meta.add_next_sibling(title)\n  else\n    set_metadata_element(title)\n  end\nend\n```\n\nSet the title string of this document.\n\nIf a title element is already present, its content is replaced with the given text.\n\nOtherwise, this method tries to create one at an appropriate place supplying head and/or html elements as necessary, which is inside a head element if any, right after a meta encoding/charset tag if any, and before any text node or content element (typically \\<body\\>) if any.\n\nxpath_doctype() → Nokogiri::CSS::XPathVisitor::DoctypeConfig Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 159\ndef xpath_doctype\n  Nokogiri::CSS::XPathVisitor::DoctypeConfig::HTML4\nend\n```\n\nReturns  \nThe document type which determines CSS-to-XPath translation.\n\nSee XPathVisitor for more information.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/Document.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/Document.html)"
- name: Nokogiri::HTML4::Document#fragment
  id: nokogiri/html4/document#method-i-fragment
  summary: null
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    fragment (tags = nil) Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 149
    def fragment(tags = nil)
      DocumentFragment.new(self, tags, root)
    end
    ```

    Create a [`Nokogiri::XML::DocumentFragment`](../xml/documentfragment) from `tags`
- name: Nokogiri::HTML4::Document#meta_encoding
  id: nokogiri/html4/document#method-i-meta_encoding
  summary: Get the meta tag encoding for this document
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    meta_encoding () Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 12
    def meta_encoding
      if (meta = at_xpath("//meta[@charset]"))
        meta[:charset]
      elsif (meta = meta_content_type)
        meta["content"][/charset\s*=\s*([\w-]+)/i, 1]
      end
    end
    ```

    Get the meta tag encoding for this document. If there is no meta tag, then nil is returned.
- name: Nokogiri::HTML4::Document#meta_encoding=
  id: nokogiri/html4/document#method-i-meta_encoding-3D
  summary: Set the meta tag encoding for this document
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    meta_encoding= (encoding) Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 36
    def meta_encoding=(encoding)
      if (meta = meta_content_type)
        meta["content"] = format("text/html; charset=%s", encoding)
        encoding
      elsif (meta = at_xpath("//meta[@charset]"))
        meta["charset"] = encoding
      else
        meta = XML::Node.new("meta", self)
        if (dtd = internal_subset) && dtd.html5_dtd?
          meta["charset"] = encoding
        else
          meta["http-equiv"] = "Content-Type"
          meta["content"] = format("text/html; charset=%s", encoding)
        end

        if (head = at_xpath("//head"))
          head.prepend_child(meta)
        else
          set_metadata_element(meta)
        end
        encoding
      end
    end
    ```

    Set the meta tag encoding for this document.

    If an meta encoding tag is already present, its content is replaced with the given text.

    Otherwise, this method tries to create one at an appropriate place supplying head and/or html elements as necessary, which is inside a head element if any, and before any text node or content element (typically \<body\>) if any.

    The result when trying to set an encoding that is different from the document encoding is undefined.

    Beware in CRuby, that libxml2 automatically inserts a meta tag into a head element.
- name: Nokogiri::HTML4::Document#serialize
  id: nokogiri/html4/document#method-i-serialize
  summary: Serialize Node using options
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    serialize (options = {}) Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 142
    def serialize(options = {})
      options[:save_with] ||= XML::Node::SaveOptions::DEFAULT_HTML
      super
    end
    ```

    Serialize Node using `options`. Save options can also be set using a block.

    See also [`Nokogiri::XML::Node::SaveOptions`](../xml/node/saveoptions) and Node.

    These two statements are equivalent:

    ``` ruby
    node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
    ```

    or

    ``` ruby
    node.serialize(:encoding => 'UTF-8') do |config|
      config.format.as_xml
    end
    ```

    Calls superclass method
- name: Nokogiri::HTML4::Document#title
  id: nokogiri/html4/document#method-i-title
  summary: Get the title string of this document
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    title () Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 70
    def title
      (title = at_xpath("//title")) && title.inner_text
    end
    ```

    Get the title string of this document. Return nil if there is no title tag.
- name: Nokogiri::HTML4::Document#title=
  id: nokogiri/html4/document#method-i-title-3D
  summary: Set the title string of this document
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    title= (text) Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 85
    def title=(text)
      tnode = XML::Text.new(text, self)
      if (title = at_xpath("//title"))
        title.children = tnode
        return text
      end

      title = XML::Node.new("title", self) << tnode
      if (head = at_xpath("//head"))
        head << title
      elsif (meta = (at_xpath("//meta[@charset]") || meta_content_type))
        # better put after charset declaration
        meta.add_next_sibling(title)
      else
        set_metadata_element(title)
      end
    end
    ```

    Set the title string of this document.

    If a title element is already present, its content is replaced with the given text.

    Otherwise, this method tries to create one at an appropriate place supplying head and/or html elements as necessary, which is inside a head element if any, right after a meta encoding/charset tag if any, and before any text node or content element (typically \<body\>) if any.
- name: Nokogiri::HTML4::Document#xpath_doctype
  id: nokogiri/html4/document#method-i-xpath_doctype
  summary: The document type which determines CSS-to-XPath translation
  belongs_to: Nokogiri::HTML4::Document
  description: "xpath_doctype() → Nokogiri::CSS::XPathVisitor::DoctypeConfig Show source\n\n``` ruby\n# File lib/nokogiri/html4/document.rb, line 159\ndef xpath_doctype\n  Nokogiri::CSS::XPathVisitor::DoctypeConfig::HTML4\nend\n```\n\nReturns\n\nThe document type which determines CSS-to-XPath translation.\n\nSee XPathVisitor for more information.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/Document.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/Document.html)"
- name: Nokogiri::HTML4::Document::parse
  id: nokogiri/html4/document#method-c-parse
  summary: Parse HTML
  belongs_to: Nokogiri::HTML4::Document
  description: |-
    parse (string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML) { \|options\| ... } Show source

    ``` ruby
    # File lib/nokogiri/html4/document.rb, line 172
    def parse(string_or_io, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML)
      options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
      yield options if block_given?

      url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil

      if string_or_io.respond_to?(:encoding)
        unless string_or_io.encoding == Encoding::ASCII_8BIT
          encoding ||= string_or_io.encoding.name
        end
      end

      if string_or_io.respond_to?(:read)
        if string_or_io.is_a?(Pathname)
          # resolve the Pathname to the file and open it as an IO object, see #2110
          string_or_io = string_or_io.expand_path.open
          url ||= string_or_io.path
        end

        unless encoding
          string_or_io = EncodingReader.new(string_or_io)
          begin
            return read_io(string_or_io, url, encoding, options.to_i)
          rescue EncodingReader::EncodingFound => e
            encoding = e.found_encoding
          end
        end
        return read_io(string_or_io, url, encoding, options.to_i)
      end

      # read_memory pukes on empty docs
      if string_or_io.nil? || string_or_io.empty?
        return encoding ? new.tap { |i| i.encoding = encoding } : new
      end

      encoding ||= EncodingReader.detect_encoding(string_or_io)

      read_memory(string_or_io, url, encoding, options.to_i)
    end
    ```

    Parse [`HTML`](../html4). `string_or_io` may be a String, or any object that responds to *read* and *close* such as an IO, or StringIO. `url` is resource where this document is located. `encoding` is the encoding that should be used when processing the document. `options` is a number that sets options in the parser, such as Nokogiri::XML::ParseOptions::RECOVER. See the constants in [`Nokogiri::XML::ParseOptions`](../xml/parseoptions).

    ### Public Instance Methods
- name: Nokogiri::HTML4::DocumentFragment
  id: nokogiri/html4/documentfragment
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::HTML4::DocumentFragment\n\nParent:  \n[Nokogiri::XML::DocumentFragment](../xml/documentfragment)\n\n### Public Class Methods\n\nnew(document, tags = nil, ctx = nil, options = XML::ParseOptions::DEFAULT_HTML) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html4/document_fragment.rb, line 27\ndef initialize(document, tags = nil, ctx = nil, options = XML::ParseOptions::DEFAULT_HTML)\n  return self unless tags\n\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  if ctx\n    preexisting_errors = document.errors.dup\n    node_set = ctx.parse(\"<div>#{tags}</div>\", options)\n    node_set.first.children.each { |child| child.parent = self } unless node_set.empty?\n    self.errors = document.errors - preexisting_errors\n  else\n    # This is a horrible hack, but I don't care\n    path = if /^\\s*?<body/i.match?(tags)\n      \"/html/body\"\n    else\n      \"/html/body/node()\"\n    end\n\n    temp_doc = HTML4::Document.parse(\"<html><body>#{tags}\", nil, document.encoding, options)\n    temp_doc.xpath(path).each { |child| child.parent = self }\n    self.errors = temp_doc.errors\n  end\n  children\nend\n```\n\nparse(tags, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html4/document_fragment.rb, line 8\ndef self.parse(tags, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)\n  doc = HTML4::Document.new\n\n  encoding ||= if tags.respond_to?(:encoding)\n    encoding = tags.encoding\n    if encoding == ::Encoding::ASCII_8BIT\n      \"UTF-8\"\n    else\n      encoding.name\n    end\n  else\n    \"UTF-8\"\n  end\n\n  doc.encoding = encoding\n\n  new(doc, tags, nil, options, &block)\nend\n```\n\nCreate a [`Nokogiri::XML::DocumentFragment`](../xml/documentfragment) from `tags`, using `encoding`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/DocumentFragment.html)"
- name: Nokogiri::HTML4::DocumentFragment::new
  id: nokogiri/html4/documentfragment#method-c-new
  summary: null
  belongs_to: Nokogiri::HTML4::DocumentFragment
  description: |-
    new (document, tags = nil, ctx = nil, options = XML::ParseOptions::DEFAULT_HTML) { \|options\| ... } Show source

    ``` ruby
    # File lib/nokogiri/html4/document_fragment.rb, line 27
    def initialize(document, tags = nil, ctx = nil, options = XML::ParseOptions::DEFAULT_HTML)
      return self unless tags

      options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
      yield options if block_given?

      if ctx
        preexisting_errors = document.errors.dup
        node_set = ctx.parse("<div>#{tags}</div>", options)
        node_set.first.children.each { |child| child.parent = self } unless node_set.empty?
        self.errors = document.errors - preexisting_errors
      else
        # This is a horrible hack, but I don't care
        path = if /^\s*?<body/i.match?(tags)
          "/html/body"
        else
          "/html/body/node()"
        end

        temp_doc = HTML4::Document.parse("<html><body>#{tags}", nil, document.encoding, options)
        temp_doc.xpath(path).each { |child| child.parent = self }
        self.errors = temp_doc.errors
      end
      children
    end
    ```
- name: Nokogiri::HTML4::DocumentFragment::parse
  id: nokogiri/html4/documentfragment#method-c-parse
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML4::DocumentFragment
  description: "parse (tags, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html4/document_fragment.rb, line 8\ndef self.parse(tags, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)\n  doc = HTML4::Document.new\n\n  encoding ||= if tags.respond_to?(:encoding)\n    encoding = tags.encoding\n    if encoding == ::Encoding::ASCII_8BIT\n      \"UTF-8\"\n    else\n      encoding.name\n    end\n  else\n    \"UTF-8\"\n  end\n\n  doc.encoding = encoding\n\n  new(doc, tags, nil, options, &block)\nend\n```\n\nCreate a [`Nokogiri::XML::DocumentFragment`](../xml/documentfragment) from `tags`, using `encoding`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/DocumentFragment.html)"
- name: Nokogiri::HTML4::ElementDescription
  id: nokogiri/html4/elementdescription
  summary: This is filled in down below
  description: "# class Nokogiri::HTML4::ElementDescription\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n### Constants\n\nACTION_ATTR\n\nALIGN_ATTR\n\nALT_ATTR\n\nAPPLET_ATTRS\n\nAREA_ATTRS\n\nATTRS\n\nA_ATTRS\n\nBASEFONT_ATTRS\n\nBGCOLOR_ATTR\n\nBLOCK\n\nBLOCKLI_ELT\n\nBODY_ATTRS\n\nBODY_CONTENTS\n\nBODY_DEPR\n\nBUTTON_ATTRS\n\nCELLHALIGN\n\nCELLVALIGN\n\nCLEAR_ATTRS\n\nCOL_ATTRS\n\nCOL_ELT\n\nCOMPACT_ATTR\n\nCOMPACT_ATTRS\n\nCONTENT_ATTR\n\nCOREATTRS\n\nCORE_ATTRS\n\nCORE_I18N_ATTRS\n\nDIR_ATTR\n\nDL_CONTENTS\n\nDefaultDescriptions\n\nThis is filled in down below.\n\nDesc\n\nMethods are defined protected by method_defined? because at this point the C-library or Java library is already loaded, and we don’t want to clobber any methods that have been defined there.\n\nEDIT_ATTRS\n\nEMBED_ATTRS\n\nEMPTY\n\nEVENTS\n\nFIELDSET_CONTENTS\n\nFLOW\n\nFLOW_PARAM\n\nFONTSTYLE\n\nAttributes defined and categorized\n\nFONT_ATTRS\n\nFORMCTRL\n\nFORM_ATTRS\n\nFORM_CONTENTS\n\nFRAMESET_ATTRS\n\nFRAMESET_CONTENTS\n\nFRAME_ATTRS\n\nHEADING\n\nHEAD_ATTRS\n\nHEAD_CONTENTS\n\nHREF_ATTRS\n\nHR_DEPR\n\nHTML_ATTRS\n\nHTML_CDATA\n\nHTML_CONTENT\n\nHTML_FLOW\n\nHTML_INLINE\n\nHTML_PCDATA\n\nI18N\n\nI18N_ATTRS\n\nIFRAME_ATTRS\n\nIMG_ATTRS\n\nINLINE\n\nINLINE_P\n\nINPUT_ATTRS\n\nLABEL_ATTR\n\nLABEL_ATTRS\n\nLANGUAGE_ATTR\n\nLEGEND_ATTRS\n\nLINK_ATTRS\n\nLIST\n\nLI_ELT\n\nMAP_CONTENTS\n\nMETA_ATTRS\n\nMODIFIER\n\nNAME_ATTR\n\nNOFRAMES_CONTENT\n\nOBJECT_ATTRS\n\nOBJECT_CONTENTS\n\nOBJECT_DEPR\n\nOL_ATTRS\n\nOPTGROUP_ATTRS\n\nOPTION_ATTRS\n\nOPTION_ELT\n\nPARAM_ATTRS\n\nPCDATA\n\nPHRASE\n\nPRE_CONTENT\n\nPROMPT_ATTRS\n\nQUOTE_ATTRS\n\nROWS_COLS_ATTR\n\nSCRIPT_ATTRS\n\nSELECT_ATTRS\n\nSELECT_CONTENT\n\nSPECIAL\n\nSRC_ALT_ATTRS\n\nSTYLE_ATTRS\n\nTABLE_ATTRS\n\nTABLE_CONTENTS\n\nTABLE_DEPR\n\nTALIGN_ATTRS\n\nTARGET_ATTR\n\nTEXTAREA_ATTRS\n\nTH_TD_ATTR\n\nTH_TD_DEPR\n\nTR_CONTENTS\n\nTR_ELT\n\nTYPE_ATTR\n\nUL_DEPR\n\nVERSION_ATTR\n\nWIDTH_ATTR\n\n### Public Instance Methods\n\nblock?() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description.rb, line 8\ndef block?\n  !inline?\nend\n```\n\nIs this element a block element?\n\ndefault_sub_element() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 57\ndef default_sub_element\n  default_desc&.defaultsubelt\nend\n```\n\ndeprecated?() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 45\ndef deprecated?\n  default_desc&.depr\nend\n```\n\ndeprecated_attributes() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 70\ndef deprecated_attributes\n  d = default_desc\n  d ? d.attrs_depr : []\nend\n```\n\ndescription() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 51\ndef description\n  default_desc&.desc\nend\n```\n\nimplied_end_tag?() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 33\ndef implied_end_tag?\n  default_desc&.endTag\nend\n```\n\nimplied_start_tag?() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 27\ndef implied_start_tag?\n  default_desc&.startTag\nend\n```\n\ninspect() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description.rb, line 20\ndef inspect\n  \"#<#{self.class.name}: #{name} #{description}>\"\nend\n```\n\nInspection information\n\noptional_attributes() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 63\ndef optional_attributes\n  d = default_desc\n  d ? d.attrs_opt : []\nend\n```\n\nrequired_attributes() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 77\ndef required_attributes\n  d = default_desc\n  d ? d.attrs_req : []\nend\n```\n\nsave_end_tag?() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description_defaults.rb, line 39\ndef save_end_tag?\n  default_desc&.saveEndTag\nend\n```\n\nto_s() Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description.rb, line 14\ndef to_s\n  \"#{name}: #{description}\"\nend\n```\n\nConvert this description to a string\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/ElementDescription.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/ElementDescription.html)"
- name: Nokogiri::HTML4::ElementDescription#block?
  id: nokogiri/html4/elementdescription#method-i-block-3F
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    block? () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description.rb, line 8
    def block?
      !inline?
    end
    ```

    Is this element a block element?
- name: Nokogiri::HTML4::ElementDescription#default_sub_element
  id: nokogiri/html4/elementdescription#method-i-default_sub_element
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    default_sub_element () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 57
    def default_sub_element
      default_desc&.defaultsubelt
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#deprecated?
  id: nokogiri/html4/elementdescription#method-i-deprecated-3F
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    deprecated? () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 45
    def deprecated?
      default_desc&.depr
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#deprecated_attributes
  id: nokogiri/html4/elementdescription#method-i-deprecated_attributes
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    deprecated_attributes () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 70
    def deprecated_attributes
      d = default_desc
      d ? d.attrs_depr : []
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#description
  id: nokogiri/html4/elementdescription#method-i-description
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    description () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 51
    def description
      default_desc&.desc
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#implied_end_tag?
  id: nokogiri/html4/elementdescription#method-i-implied_end_tag-3F
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    implied_end_tag? () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 33
    def implied_end_tag?
      default_desc&.endTag
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#implied_start_tag?
  id: nokogiri/html4/elementdescription#method-i-implied_start_tag-3F
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    implied_start_tag? () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 27
    def implied_start_tag?
      default_desc&.startTag
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#inspect
  id: nokogiri/html4/elementdescription#method-i-inspect
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    inspect () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description.rb, line 20
    def inspect
      "#<#{self.class.name}: #{name} #{description}>"
    end
    ```

    Inspection information
- name: Nokogiri::HTML4::ElementDescription#optional_attributes
  id: nokogiri/html4/elementdescription#method-i-optional_attributes
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    optional_attributes () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 63
    def optional_attributes
      d = default_desc
      d ? d.attrs_opt : []
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#required_attributes
  id: nokogiri/html4/elementdescription#method-i-required_attributes
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    required_attributes () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 77
    def required_attributes
      d = default_desc
      d ? d.attrs_req : []
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#save_end_tag?
  id: nokogiri/html4/elementdescription#method-i-save_end_tag-3F
  summary: null
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: |-
    save_end_tag? () Show source

    ``` ruby
    # File lib/nokogiri/html4/element_description_defaults.rb, line 39
    def save_end_tag?
      default_desc&.saveEndTag
    end
    ```
- name: Nokogiri::HTML4::ElementDescription#to_s
  id: nokogiri/html4/elementdescription#method-i-to_s
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML4::ElementDescription
  description: "to_s () Show source\n\n``` ruby\n# File lib/nokogiri/html4/element_description.rb, line 14\ndef to_s\n  \"#{name}: #{description}\"\nend\n```\n\nConvert this description to a string\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/ElementDescription.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/ElementDescription.html)"
- name: Nokogiri::HTML4::EntityDescription
  id: nokogiri/html4/entitydescription
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::HTML4::EntityDescription\n\nParent:  \nStruct.new(:value, :name, :description);\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/EntityDescription.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/EntityDescription.html)"
- name: Nokogiri::HTML4::EntityLookup
  id: nokogiri/html4/entitylookup
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::HTML4::EntityLookup\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n### Public Instance Methods\n\n\\[\\](name) Show source\n\n``` ruby\n# File lib/nokogiri/html4/entity_lookup.rb, line 10\ndef [](name)\n  (val = get(name)) && val.value\nend\n```\n\nLook up entity with `name`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/EntityLookup.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/EntityLookup.html)"
- name: Nokogiri::HTML4::EntityLookup#[]
  id: nokogiri/html4/entitylookup#method-i-5B-5D
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML4::EntityLookup
  description: "\\[\\] (name) Show source\n\n``` ruby\n# File lib/nokogiri/html4/entity_lookup.rb, line 10\ndef [](name)\n  (val = get(name)) && val.value\nend\n```\n\nLook up entity with `name`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/EntityLookup.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/EntityLookup.html)"
- name: Nokogiri::HTML4::fragment
  id: nokogiri/html4#method-c-fragment
  summary: Parse a fragment from string in to a NodeSet
  belongs_to: Nokogiri::HTML4
  description: |-
    fragment (string, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) Show source

    ``` ruby
    # File lib/nokogiri/html4.rb, line 29
    def fragment(string, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)
      HTML4::DocumentFragment.parse(string, encoding, options, &block)
    end
    ```

    Parse a fragment from `string` in to a NodeSet.
- name: Nokogiri::HTML4::parse
  id: nokogiri/html4#method-c-parse
  summary: Parse HTML
  belongs_to: Nokogiri::HTML4
  description: "parse (input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html4.rb, line 23\ndef parse(input, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_HTML, &block)\n  Document.parse(input, url, encoding, options, &block)\nend\n```\n\nParse [`HTML`](html4). Convenience method for [`Nokogiri::HTML4::Document.parse`](html4/document#method-c-parse)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4.html](https://nokogiri.org/rdoc/Nokogiri/HTML4.html)"
- name: Nokogiri::HTML4::SAX
  id: nokogiri/html4/sax
  summary: Nokogiri lets you write a SAX parser to process HTML but get HTML correction features
  description: "# module Nokogiri::HTML4::SAX\n\n[`Nokogiri`](../../nokogiri) lets you write a [`SAX`](sax) parser to process [`HTML`](../html4) but get [`HTML`](../html4) correction features.\n\nSee [`Nokogiri::HTML4::SAX::Parser`](sax/parser) for a basic example of using a [`SAX`](sax) parser with [`HTML`](../html4).\n\nFor more information on [`SAX`](sax) parsers, see [`Nokogiri::XML::SAX`](../xml/sax)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX.html)"
- name: Nokogiri::HTML4::SAX::Parser
  id: nokogiri/html4/sax/parser
  summary: 💡 This class is an alias for Nokogiri::HTML4::SAX::Parser as of v1.12.0
  description: "# class Nokogiri::HTML4::SAX::Parser\n\nParent:  \n[Nokogiri::XML::SAX::Parser](../../xml/sax/parser)\n\n💡 This class is an alias for [`Nokogiri::HTML4::SAX::Parser`](parser) as of v1.12.0.\n\nThis class lets you perform [`SAX`](../sax) style parsing on [`HTML`](../../html4) with [`HTML`](../../html4) error correction.\n\nHere is a basic usage example:\n\n``` ruby\nclass MyDoc < Nokogiri::XML::SAX::Document\n  def start_element name, attributes = []\n    puts \"found a #{name}\"\n  end\nend\n\nparser = Nokogiri::HTML4::SAX::Parser.new(MyDoc.new)\nparser.parse(File.read(ARGV[0], mode: 'rb'))\n```\n\nFor more information on [`SAX`](../sax) parsers, see [`Nokogiri::XML::SAX`](../../xml/sax)\n\n### Public Instance Methods\n\nparse_file(filename, encoding = \"UTF-8\") { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/parser.rb, line 51\ndef parse_file(filename, encoding = \"UTF-8\")\n  raise ArgumentError unless filename\n  raise Errno::ENOENT unless File.exist?(filename)\n  raise Errno::EISDIR if File.directory?(filename)\n\n  ctx = ParserContext.file(filename, encoding)\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\nParse a file with `filename`\n\nparse_io(io, encoding = \"UTF-8\") { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/parser.rb, line 41\ndef parse_io(io, encoding = \"UTF-8\")\n  check_encoding(encoding)\n  @encoding = encoding\n  ctx = ParserContext.io(io, ENCODINGS[encoding])\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\nParse given `io`\n\nparse_memory(data, encoding = \"UTF-8\") { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/parser.rb, line 30\ndef parse_memory(data, encoding = \"UTF-8\")\n  raise TypeError unless String === data\n  return if data.empty?\n\n  ctx = ParserContext.memory(data, encoding)\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\nParse html stored in `data` using `encoding`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/Parser.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/Parser.html)"
- name: Nokogiri::HTML4::SAX::Parser#parse_file
  id: nokogiri/html4/sax/parser#method-i-parse_file
  summary: null
  belongs_to: Nokogiri::HTML4::SAX::Parser
  description: |-
    parse_file (filename, encoding = "UTF-8") { \|ctx\| ... } Show source

    ``` ruby
    # File lib/nokogiri/html4/sax/parser.rb, line 51
    def parse_file(filename, encoding = "UTF-8")
      raise ArgumentError unless filename
      raise Errno::ENOENT unless File.exist?(filename)
      raise Errno::EISDIR if File.directory?(filename)

      ctx = ParserContext.file(filename, encoding)
      yield ctx if block_given?
      ctx.parse_with(self)
    end
    ```

    Parse a file with `filename`
- name: Nokogiri::HTML4::SAX::Parser#parse_io
  id: nokogiri/html4/sax/parser#method-i-parse_io
  summary: null
  belongs_to: Nokogiri::HTML4::SAX::Parser
  description: |-
    parse_io (io, encoding = "UTF-8") { \|ctx\| ... } Show source

    ``` ruby
    # File lib/nokogiri/html4/sax/parser.rb, line 41
    def parse_io(io, encoding = "UTF-8")
      check_encoding(encoding)
      @encoding = encoding
      ctx = ParserContext.io(io, ENCODINGS[encoding])
      yield ctx if block_given?
      ctx.parse_with(self)
    end
    ```

    Parse given `io`
- name: Nokogiri::HTML4::SAX::Parser#parse_memory
  id: nokogiri/html4/sax/parser#method-i-parse_memory
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML4::SAX::Parser
  description: "parse_memory (data, encoding = \"UTF-8\") { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/parser.rb, line 30\ndef parse_memory(data, encoding = \"UTF-8\")\n  raise TypeError unless String === data\n  return if data.empty?\n\n  ctx = ParserContext.memory(data, encoding)\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\nParse html stored in `data` using `encoding`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/Parser.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/Parser.html)"
- name: Nokogiri::HTML4::SAX::ParserContext
  id: nokogiri/html4/sax/parsercontext
  summary: 💡 This class is an alias for Nokogiri::HTML4::SAX::ParserContext as of v1.12.0
  description: "# class Nokogiri::HTML4::SAX::ParserContext\n\nParent:  \n[Nokogiri::XML::SAX::ParserContext](../../xml/sax/parsercontext)\n\n💡 This class is an alias for [`Nokogiri::HTML4::SAX::ParserContext`](parsercontext) as of v1.12.0.\n\nContext for [`HTML`](../../html4) [`SAX`](../sax) parsers. This class is usually not instantiated by the user. Instead, you should be looking at [`Nokogiri::HTML4::SAX::Parser`](parser)\n\n### Public Class Methods\n\nnew(thing, encoding = \"UTF-8\") Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/parser_context.rb, line 10\ndef self.new(thing, encoding = \"UTF-8\")\n  if [:read, :close].all? { |x| thing.respond_to?(x) }\n    super\n  else\n    memory(thing, encoding)\n  end\nend\n```\n\nCalls superclass method [`Nokogiri::XML::SAX::ParserContext::new`](../../xml/sax/parsercontext#method-c-new)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/ParserContext.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/ParserContext.html)"
- name: Nokogiri::HTML4::SAX::ParserContext::new
  id: nokogiri/html4/sax/parsercontext#method-c-new
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML4::SAX::ParserContext
  description: "new (thing, encoding = \"UTF-8\") Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/parser_context.rb, line 10\ndef self.new(thing, encoding = \"UTF-8\")\n  if [:read, :close].all? { |x| thing.respond_to?(x) }\n    super\n  else\n    memory(thing, encoding)\n  end\nend\n```\n\nCalls superclass method [`Nokogiri::XML::SAX::ParserContext::new`](../../xml/sax/parsercontext#method-c-new)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/ParserContext.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/ParserContext.html)"
- name: Nokogiri::HTML4::SAX::PushParser
  id: nokogiri/html4/sax/pushparser
  summary: 💡 This class is an alias for Nokogiri::HTML4::SAX::PushParser as of v1.12.0
  description: "# class Nokogiri::HTML4::SAX::PushParser\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n💡 This class is an alias for [`Nokogiri::HTML4::SAX::PushParser`](pushparser) as of v1.12.0.\n\n### Attributes\n\ndocument\\[RW\\]\n\nThe Nokogiri::HTML4::SAX::Document on which the [`PushParser`](pushparser) will be operating\n\n### Public Class Methods\n\nnew(doc = HTML4::SAX::Document.new, file_name = nil, encoding = \"UTF-8\") Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/push_parser.rb, line 11\ndef initialize(doc = HTML4::SAX::Document.new, file_name = nil, encoding = \"UTF-8\")\n  @document = doc\n  @encoding = encoding\n  @sax_parser = HTML4::SAX::Parser.new(doc, @encoding)\n\n  ## Create our push parser context\n  initialize_native(@sax_parser, file_name, encoding)\nend\n```\n\n### Public Instance Methods\n\n\\<\\<(chunk, last_chunk = false)\n\nAlias for: [write](pushparser#method-i-write)\n\nfinish() Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/push_parser.rb, line 31\ndef finish\n  write(\"\", true)\nend\n```\n\nFinish the parsing. This method is only necessary for Nokogiri::HTML4::SAX::Document#end_document to be called.\n\nwrite(chunk, last_chunk = false) Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/push_parser.rb, line 23\ndef write(chunk, last_chunk = false)\n  native_write(chunk, last_chunk)\nend\n```\n\nWrite a `chunk` of [`HTML`](../../html4) to the [`PushParser`](pushparser). Any callback methods that can be called will be called immediately.\n\nAlso aliased as: [\\<\\<](pushparser#method-i-3C-3C)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/PushParser.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/PushParser.html)"
- name: Nokogiri::HTML4::SAX::PushParser#<<
  id: nokogiri/html4/sax/pushparser#method-i-3C-3C
  summary: null
  belongs_to: Nokogiri::HTML4::SAX::PushParser
  description: |-
    \<\< (chunk, last_chunk = false)

    Alias for: [write](pushparser#method-i-write)
- name: Nokogiri::HTML4::SAX::PushParser#document
  id: nokogiri/html4/sax/pushparser#attribute-i-document
  summary: null
  belongs_to: Nokogiri::HTML4::SAX::PushParser
  description: |-
    document \[RW\]

    The Nokogiri::HTML4::SAX::Document on which the [`PushParser`](pushparser) will be operating

    ### Public Class Methods
- name: Nokogiri::HTML4::SAX::PushParser#finish
  id: nokogiri/html4/sax/pushparser#method-i-finish
  summary: Finish the parsing
  belongs_to: Nokogiri::HTML4::SAX::PushParser
  description: |-
    finish () Show source

    ``` ruby
    # File lib/nokogiri/html4/sax/push_parser.rb, line 31
    def finish
      write("", true)
    end
    ```

    Finish the parsing. This method is only necessary for Nokogiri::HTML4::SAX::Document#end_document to be called.
- name: Nokogiri::HTML4::SAX::PushParser#write
  id: nokogiri/html4/sax/pushparser#method-i-write
  summary: Write a chunk of HTML to the PushParser
  belongs_to: Nokogiri::HTML4::SAX::PushParser
  description: "write (chunk, last_chunk = false) Show source\n\n``` ruby\n# File lib/nokogiri/html4/sax/push_parser.rb, line 23\ndef write(chunk, last_chunk = false)\n  native_write(chunk, last_chunk)\nend\n```\n\nWrite a `chunk` of [`HTML`](../../html4) to the [`PushParser`](pushparser). Any callback methods that can be called will be called immediately.\n\nAlso aliased as: [\\<\\<](pushparser#method-i-3C-3C)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/PushParser.html](https://nokogiri.org/rdoc/Nokogiri/HTML4/SAX/PushParser.html)"
- name: Nokogiri::HTML4::SAX::PushParser::new
  id: nokogiri/html4/sax/pushparser#method-c-new
  summary: null
  belongs_to: Nokogiri::HTML4::SAX::PushParser
  description: |-
    new (doc = HTML4::SAX::Document.new, file_name = nil, encoding = "UTF-8") Show source

    ``` ruby
    # File lib/nokogiri/html4/sax/push_parser.rb, line 11
    def initialize(doc = HTML4::SAX::Document.new, file_name = nil, encoding = "UTF-8")
      @document = doc
      @encoding = encoding
      @sax_parser = HTML4::SAX::Parser.new(doc, @encoding)

      ## Create our push parser context
      initialize_native(@sax_parser, file_name, encoding)
    end
    ```

    ### Public Instance Methods
- name: Nokogiri::HTML5
  id: nokogiri#method-c-HTML5
  summary: ⚠ HTML5 functionality is not available when running JRuby
  belongs_to: Nokogiri
  description: |-
    HTML5 (input, url = nil, encoding = nil, \*\*options, &block) Show source

    ``` ruby
    # File lib/nokogiri/html5.rb, line 30
    def self.HTML5(input, url = nil, encoding = nil, **options, &block)
      Nokogiri::HTML5::Document.parse(input, url, encoding, **options, &block)
    end
    ```

    Since v1.12.0

    ⚠ [`HTML5`](nokogiri/html5) functionality is not available when running JRuby.

    Parse an [`HTML5`](nokogiri/html5) document. Convenience method for {Nokogiri::HTML5::Document.parse}
- name: Nokogiri::HTML5
  id: nokogiri/html5
  summary: ⚠ HTML5 functionality is not available when running JRuby
  description: "# module Nokogiri::HTML5\n\n## Usage\n\n⚠ [`HTML5`](html5) functionality is not available when running JRuby.\n\nParse an [`HTML5`](html5) document:\n\n``` ruby\ndoc = Nokogiri.HTML5(string)\n```\n\nParse an [`HTML5`](html5) fragment:\n\n``` ruby\nfragment = Nokogiri::HTML5.fragment(string)\n```\n\n## Parsing options\n\nThe document and fragment parsing methods support options that are different from Nokogiri’s.\n\n- `Nokogiri.HTML5(html, url = nil, encoding = nil, options = {})`\n\n- `Nokogiri::HTML5.parse(html, url = nil, encoding = nil, options = {})`\n\n- `Nokogiri::HTML5::Document.parse(html, url = nil, encoding = nil, options = {})`\n\n- `Nokogiri::HTML5.fragment(html, encoding = nil, options = {})`\n\n- `Nokogiri::HTML5::DocumentFragment.parse(html, encoding = nil, options = {})`\n\nThe three currently supported options are `:max_errors`, `:max_tree_depth` and `:max_attributes`, described below.\n\n### Error reporting\n\n[`Nokogiri`](../nokogiri) contains an experimental [`HTML5`](html5) parse error reporting facility. By default, no parse errors are reported but this can be configured by passing the `:max_errors` option to {HTML5.parse} or {HTML5.fragment}.\n\nFor example, this script:\n\n``` ruby\ndoc = Nokogiri::HTML5.parse('<span/>Hi there!</span foo=bar />', max_errors: 10)\ndoc.errors.each do |err|\n  puts(err)\nend\n```\n\nEmits:\n\n    1:1: ERROR: Expected a doctype token\n    <span/>Hi there!</span foo=bar />\n    ^\n    1:1: ERROR: Start tag of nonvoid HTML element ends with '/>', use '>'.\n    <span/>Hi there!</span foo=bar />\n    ^\n    1:17: ERROR: End tag ends with '/>', use '>'.\n    <span/>Hi there!</span foo=bar />\n                    ^\n    1:17: ERROR: End tag contains attributes.\n    <span/>Hi there!</span foo=bar />\n                    ^\n\nUsing `max_errors: -1` results in an unlimited number of errors being returned.\n\nThe errors returned by {HTML5::Document#errors} are instances of {Nokogiri::XML::SyntaxError}.\n\nThe {[html.spec.whatwg.org/multipage/parsing.html#parse-errors](https://html.spec.whatwg.org/multipage/parsing.html#parse-errors) [`HTML`](html4) standard} defines a number of standard parse error codes. These error codes only cover the “tokenization” stage of parsing [`HTML`](html4). The parse errors in the “tree construction” stage do not have standardized error codes (yet).\n\nAs a convenience to [`Nokogiri`](../nokogiri) users, the defined error codes are available via {Nokogiri::XML::SyntaxError#str1} method.\n\n``` ruby\ndoc = Nokogiri::HTML5.parse('<span/>Hi there!</span foo=bar />', max_errors: 10)\ndoc.errors.each do |err|\n  puts(\"#{err.line}:#{err.column}: #{err.str1}\")\nend\n# => 1:1: generic-parser\n#    1:1: non-void-html-element-start-tag-with-trailing-solidus\n#    1:17: end-tag-with-trailing-solidus\n#    1:17: end-tag-with-attributes\n```\n\nNote that the first error is `generic-parser` because it’s an error from the tree construction stage and doesn’t have a standardized error code.\n\nFor the purposes of semantic versioning, the error messages, error locations, and error codes are not part of Nokogiri’s public API. That is, these are subject to change without Nokogiri’s major version number changing. These may be stabilized in the future.\n\n### Maximum tree depth\n\nThe maximum depth of the DOM tree parsed by the various parsing methods is configurable by the `:max_tree_depth` option. If the depth of the tree would exceed this limit, then an {::ArgumentError} is thrown.\n\nThis limit (which defaults to `Nokogiri::Gumbo::DEFAULT_MAX_TREE_DEPTH = 400`) can be removed by giving the option `max_tree_depth: -1`.\n\n``` ruby\nhtml = '<!DOCTYPE html>' + '<div>' * 1000\ndoc = Nokogiri.HTML5(html)\n# raises ArgumentError: Document tree depth limit exceeded\ndoc = Nokogiri.HTML5(html, max_tree_depth: -1)\n```\n\n### Attribute limit per element\n\nThe maximum number of attributes per DOM element is configurable by the `:max_attributes` option. If a given element would exceed this limit, then an {::ArgumentError} is thrown.\n\nThis limit (which defaults to `Nokogiri::Gumbo::DEFAULT_MAX_ATTRIBUTES = 400`) can be removed by giving the option `max_attributes: -1`.\n\n``` ruby\nhtml = '<!DOCTYPE html><div ' + (1..1000).map { |x| \"attr-#{x}\" }.join(' ') + '>'\n# \"<!DOCTYPE html><div attr-1 attr-2 attr-3 ... attr-1000>\"\ndoc = Nokogiri.HTML5(html)\n# raises ArgumentError: Attributes per element limit exceeded\ndoc = Nokogiri.HTML5(html, max_attributes: -1)\n```\n\n## [`HTML`](html4) Serialization\n\nAfter parsing [`HTML`](html4), it may be serialized using any of the {Nokogiri::XML::Node} serialization methods. In particular, {XML::Node#serialize}, {XML::Node#to_html}, and {XML::Node#to_s} will serialize a given node and its children. (This is the equivalent of JavaScript’s `Element.outerHTML`.) Similarly, {XML::Node#inner_html} will serialize the children of a given node. (This is the equivalent of JavaScript’s `Element.innerHTML`.)\n\n``` ruby\ndoc = Nokogiri::HTML5(\"<!DOCTYPE html><span>Hello world!</span>\")\nputs doc.serialize\n# => <!DOCTYPE html><html><head></head><body><span>Hello world!</span></body></html>\n```\n\nDue to quirks in how [`HTML`](html4) is parsed and serialized, it’s possible for a DOM tree to be serialized and then re-parsed, resulting in a different DOM. Mostly, this happens with DOMs produced from invalid [`HTML`](html4). Unfortunately, even valid [`HTML`](html4) may not survive serialization and re-parsing.\n\nIn particular, a newline at the start of `pre`, `listing`, and `textarea` elements is ignored by the parser.\n\n``` ruby\ndoc = Nokogiri::HTML5(<<-EOF)\n<!DOCTYPE html>\n<pre>\nContent</pre>\nEOF\nputs doc.at('/html/body/pre').serialize\n# => <pre>Content</pre>\n```\n\nIn this case, the original [`HTML`](html4) is semantically equivalent to the serialized version. If the `pre`, `listing`, or `textarea` content starts with two newlines, the first newline will be stripped on the first parse and the second newline will be stripped on the second, leading to semantically different DOMs. Passing the parameter `preserve_newline: true` will cause two or more newlines to be preserved. (A single leading newline will still be removed.)\n\n``` ruby\ndoc = Nokogiri::HTML5(<<-EOF)\n<!DOCTYPE html>\n<listing>\n\nContent</listing>\nEOF\nputs doc.at('/html/body/listing').serialize(preserve_newline: true)\n# => <listing>\n#\n#    Content</listing>\n```\n\n## Encodings\n\n[`Nokogiri`](../nokogiri) always parses [`HTML5`](html5) using {[en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8) UTF-8}; however, the encoding of the input can be explicitly selected via the optional `encoding` parameter. This is most useful when the input comes not from a string but from an IO object.\n\nWhen serializing a document or node, the encoding of the output string can be specified via the `:encoding` options. Characters that cannot be encoded in the selected encoding will be encoded as {[en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references](https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references) [`HTML`](html4) numeric entities}.\n\n``` ruby\nfrag = Nokogiri::HTML5.fragment('<span>아는 길도 물어가라</span>')\nhtml = frag.serialize(encoding: 'US-ASCII')\nputs html\n# => <span>&#xc544;&#xb294; &#xae38;&#xb3c4; &#xbb3c;&#xc5b4;&#xac00;&#xb77c;</span>\nfrag = Nokogiri::HTML5.fragment(html)\nputs frag.serialize\n# => <span>아는 길도 물어가라</span>\n```\n\n(There’s a {[bugs.ruby-lang.org/issues/15033](https://bugs.ruby-lang.org/issues/15033) bug} in all current versions of Ruby that can cause the entity encoding to fail. Of the mandated supported encodings for [`HTML`](html4), the only encoding I’m aware of that has this bug is `'ISO-2022-JP'`. We recommend avoiding this encoding.)\n\n## Notes\n\n- The {Nokogiri::HTML5.fragment} function takes a string and parses it as a [`HTML5`](html5) document. The +\\<html\\>+, +\\<head\\>+, and +\\<body\\>+ elements are removed from this document, and any children of these elements that remain are returned as a {Nokogiri::HTML5::DocumentFragment}.\n\n- The {Nokogiri::HTML5.parse} function takes a string and passes it to the `gumbo_parse_with_options` method, using the default options. The resulting [`Gumbo`](gumbo) parse tree is then walked.\n\n- Instead of uppercase element names, lowercase element names are produced.\n\n- Instead of returning `unknown` as the element name for unknown tags, the original tag name is returned verbatim.\n\nSince v1.12.0\n\n### Public Class Methods\n\nfragment(string, encoding = nil, \\*\\*options) Show source\n\n``` ruby\n# File lib/nokogiri/html5.rb, line 238\ndef fragment(string, encoding = nil, **options)\n  DocumentFragment.parse(string, encoding, options)\nend\n```\n\nParse a fragment from `string`. Convenience method for {Nokogiri::HTML5::DocumentFragment.parse}.\n\nget(uri, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/html5.rb, line 249\ndef get(uri, options = {})\n  # TODO: deprecate\n  warn(\"Nokogiri::HTML5.get is deprecated and will be removed in a future version of Nokogiri.\",\n    uplevel: 1, category: :deprecated)\n  get_impl(uri, options)\nend\n```\n\nFetch and parse a [`HTML`](html4) document from the web, following redirects, handling https, and determining the character encoding using [`HTML5`](html5) rules. `uri` may be a `String` or a `URI`. `options` contains http headers and special options. Everything which is not a special option is considered a header. Special options include:\n\n    * :follow_limit => number of redirects which are followed\n    * :basic_auth => [username, password]\n\nparse(string, url = nil, encoding = nil, \\*\\*options, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html5.rb, line 232\ndef parse(string, url = nil, encoding = nil, **options, &block)\n  Document.parse(string, url, encoding, **options, &block)\nend\n```\n\nParse an [`HTML`](html4) 5 document. Convenience method for {Nokogiri::HTML5::Document.parse}\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5.html](https://nokogiri.org/rdoc/Nokogiri/HTML5.html)"
- name: Nokogiri::HTML5::Document
  id: nokogiri/html5/document
  summary: 💡 HTML5 functionality is not available when running JRuby
  description: "# class Nokogiri::HTML5::Document\n\nParent:  \n[Nokogiri::HTML4::Document](../html4/document)\n\nSince v1.12.0\n\n💡 [`HTML5`](../html5) functionality is not available when running JRuby.\n\n### Attributes\n\nquirks_mode\\[R\\]\n\nGet the parser’s quirks mode value. See [`HTML5::QuirksMode`](quirksmode).\n\nThis method returns ‘nil\\` if the parser was not invoked (e.g., \\`Nokogiri::HTML5::Document.new\\`).\n\nSince v1.14.0\n\nurl\\[R\\]\n\nGet the url name for this document, as passed into [`Document.parse`](document#method-c-parse), [`Document.read_io`](document#method-c-read_io), or [`Document.read_memory`](document#method-c-read_memory)\n\n### Public Class Methods\n\nparse(input) Show source\n\nparse(input, url=nil, encoding=nil, \\*\\*options)\n\nparse(input, url=nil, encoding=nil) { \\|options\\| ... }\n\n``` ruby\n# File lib/nokogiri/html5/document.rb, line 80\ndef parse(string_or_io, url = nil, encoding = nil, **options, &block)\n  yield options if block\n  string_or_io = \"\" unless string_or_io\n\n  if string_or_io.respond_to?(:encoding) && string_or_io.encoding != Encoding::ASCII_8BIT\n    encoding ||= string_or_io.encoding.name\n  end\n\n  if string_or_io.respond_to?(:read) && string_or_io.respond_to?(:path)\n    url ||= string_or_io.path\n  end\n  unless string_or_io.respond_to?(:read) || string_or_io.respond_to?(:to_str)\n    raise ArgumentError, \"not a string or IO object\"\n  end\n\n  do_parse(string_or_io, url, encoding, options)\nend\n```\n\nParse [`HTML5`](../html5) input.\n\nParameters\n\n- `input` may be a String, or any object that responds to *read* and *close* such as an IO, or StringIO.\n\n- `url` (optional) is a String indicating the canonical URI where this document is located.\n\n- `encoding` (optional) is the encoding that should be used when processing the document.\n\n- `options` (optional) is a configuration Hash (or keyword arguments) to set options during parsing. The three currently supported options are `:max_errors`, `:max_tree_depth` and `:max_attributes`, described at [`Nokogiri::HTML5`](../html5).\n\n  ⚠ Note that these options are different than those made available by [`Nokogiri::XML::Document`](../xml/document) and [`Nokogiri::HTML4::Document`](../html4/document).\n\n- `block` (optional) is passed a configuration Hash on which parse options may be set. See [`Nokogiri::HTML5`](../html5) for more information and usage.\n\nReturns  \n[`Nokogiri::HTML5::Document`](document)\n\nread_io(io, url = nil, encoding = nil, \\*\\*options) Show source\n\n``` ruby\n# File lib/nokogiri/html5/document.rb, line 101\ndef read_io(io, url = nil, encoding = nil, **options)\n  raise ArgumentError, \"io object doesn't respond to :read\" unless io.respond_to?(:read)\n\n  do_parse(io, url, encoding, options)\nend\n```\n\nCreate a new document from an IO object.\n\n💡 Most users should prefer [`Document.parse`](document#method-c-parse) to this method.\n\nread_memory(string, url = nil, encoding = nil, \\*\\*options) Show source\n\n``` ruby\n# File lib/nokogiri/html5/document.rb, line 110\ndef read_memory(string, url = nil, encoding = nil, **options)\n  raise ArgumentError, \"string object doesn't respond to :to_str\" unless string.respond_to?(:to_str)\n\n  do_parse(string, url, encoding, options)\nend\n```\n\nCreate a new document from a String.\n\n💡 Most users should prefer [`Document.parse`](document#method-c-parse) to this method.\n\n### Public Instance Methods\n\nfragment() → Nokogiri::HTML5::DocumentFragment Show source\n\nfragment(markup) → Nokogiri::HTML5::DocumentFragment\n\n``` ruby\n# File lib/nokogiri/html5/document.rb, line 147\ndef fragment(markup = nil)\n  DocumentFragment.new(self, markup)\nend\n```\n\nParse a [`HTML5`](../html5) document fragment from `markup`, returning a [`Nokogiri::HTML5::DocumentFragment`](documentfragment).\n\nProperties\n\n- `markup` (String) The [`HTML5`](../html5) markup fragment to be parsed\n\nReturns  \n[`Nokogiri::HTML5::DocumentFragment`](documentfragment). This object’s children will be empty if ‘markup\\` is not passed, is empty, or is \\`nil\\`.\n\nxpath_doctype() → Nokogiri::CSS::XPathVisitor::DoctypeConfig Show source\n\n``` ruby\n# File lib/nokogiri/html5/document.rb, line 163\ndef xpath_doctype\n  Nokogiri::CSS::XPathVisitor::DoctypeConfig::HTML5\nend\n```\n\nReturns  \nThe document type which determines CSS-to-XPath translation.\n\nSee [`CSS::XPathVisitor`](../css/xpathvisitor) for more information.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/Document.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/Document.html)"
- name: Nokogiri::HTML5::Document#fragment
  id: nokogiri/html5/document#method-i-fragment
  summary: Parse a HTML5 document fragment from markup, returning a Nokogiri::HTML5::DocumentFragment
  belongs_to: Nokogiri::HTML5::Document
  description: |-
    fragment() → Nokogiri::HTML5::DocumentFragment Show source

    fragment(markup) → Nokogiri::HTML5::DocumentFragment

    ``` ruby
    # File lib/nokogiri/html5/document.rb, line 147
    def fragment(markup = nil)
      DocumentFragment.new(self, markup)
    end
    ```

    Parse a [`HTML5`](../html5) document fragment from `markup`, returning a [`Nokogiri::HTML5::DocumentFragment`](documentfragment).

    Properties

    - `markup` (String) The [`HTML5`](../html5) markup fragment to be parsed

    Returns

    [`Nokogiri::HTML5::DocumentFragment`](documentfragment). This object’s children will be empty if ‘markup\` is not passed, is empty, or is \`nil\`.
- name: Nokogiri::HTML5::Document#quirks_mode
  id: nokogiri/html5/document#attribute-i-quirks_mode
  summary: Get the parser’s quirks mode value
  belongs_to: Nokogiri::HTML5::Document
  description: |-
    quirks_mode \[R\]

    Get the parser’s quirks mode value. See [`HTML5::QuirksMode`](quirksmode).

    This method returns ‘nil\` if the parser was not invoked (e.g., \`Nokogiri::HTML5::Document.new\`).

    Since v1.14.0
- name: Nokogiri::HTML5::Document#url
  id: nokogiri/html5/document#attribute-i-url
  summary: null
  belongs_to: Nokogiri::HTML5::Document
  description: |-
    url \[R\]

    Get the url name for this document, as passed into [`Document.parse`](document#method-c-parse), [`Document.read_io`](document#method-c-read_io), or [`Document.read_memory`](document#method-c-read_memory)

    ### Public Class Methods
- name: Nokogiri::HTML5::Document#xpath_doctype
  id: nokogiri/html5/document#method-i-xpath_doctype
  summary: The document type which determines CSS-to-XPath translation
  belongs_to: Nokogiri::HTML5::Document
  description: "xpath_doctype() → Nokogiri::CSS::XPathVisitor::DoctypeConfig Show source\n\n``` ruby\n# File lib/nokogiri/html5/document.rb, line 163\ndef xpath_doctype\n  Nokogiri::CSS::XPathVisitor::DoctypeConfig::HTML5\nend\n```\n\nReturns\n\nThe document type which determines CSS-to-XPath translation.\n\nSee [`CSS::XPathVisitor`](../css/xpathvisitor) for more information.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/Document.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/Document.html)"
- name: Nokogiri::HTML5::Document::parse
  id: nokogiri/html5/document#method-c-parse
  summary: Parse HTML5 input
  belongs_to: Nokogiri::HTML5::Document
  description: |-
    parse(input) Show source

    parse(input, url=nil, encoding=nil, \*\*options)

    parse(input, url=nil, encoding=nil) { \|options\| ... }

    ``` ruby
    # File lib/nokogiri/html5/document.rb, line 80
    def parse(string_or_io, url = nil, encoding = nil, **options, &block)
      yield options if block
      string_or_io = "" unless string_or_io

      if string_or_io.respond_to?(:encoding) && string_or_io.encoding != Encoding::ASCII_8BIT
        encoding ||= string_or_io.encoding.name
      end

      if string_or_io.respond_to?(:read) && string_or_io.respond_to?(:path)
        url ||= string_or_io.path
      end
      unless string_or_io.respond_to?(:read) || string_or_io.respond_to?(:to_str)
        raise ArgumentError, "not a string or IO object"
      end

      do_parse(string_or_io, url, encoding, options)
    end
    ```

    Parse [`HTML5`](../html5) input.

    Parameters

    - `input` may be a String, or any object that responds to *read* and *close* such as an IO, or StringIO.

    - `url` (optional) is a String indicating the canonical URI where this document is located.

    - `encoding` (optional) is the encoding that should be used when processing the document.

    - `options` (optional) is a configuration Hash (or keyword arguments) to set options during parsing. The three currently supported options are `:max_errors`, `:max_tree_depth` and `:max_attributes`, described at [`Nokogiri::HTML5`](../html5).

      ⚠ Note that these options are different than those made available by [`Nokogiri::XML::Document`](../xml/document) and [`Nokogiri::HTML4::Document`](../html4/document).

    - `block` (optional) is passed a configuration Hash on which parse options may be set. See [`Nokogiri::HTML5`](../html5) for more information and usage.

    Returns

    [`Nokogiri::HTML5::Document`](document)
- name: Nokogiri::HTML5::Document::read_io
  id: nokogiri/html5/document#method-c-read_io
  summary: Create a new document from an IO object
  belongs_to: Nokogiri::HTML5::Document
  description: |-
    read_io (io, url = nil, encoding = nil, \*\*options) Show source

    ``` ruby
    # File lib/nokogiri/html5/document.rb, line 101
    def read_io(io, url = nil, encoding = nil, **options)
      raise ArgumentError, "io object doesn't respond to :read" unless io.respond_to?(:read)

      do_parse(io, url, encoding, options)
    end
    ```

    Create a new document from an IO object.

    💡 Most users should prefer [`Document.parse`](document#method-c-parse) to this method.
- name: Nokogiri::HTML5::Document::read_memory
  id: nokogiri/html5/document#method-c-read_memory
  summary: Create a new document from a String
  belongs_to: Nokogiri::HTML5::Document
  description: |-
    read_memory (string, url = nil, encoding = nil, \*\*options) Show source

    ``` ruby
    # File lib/nokogiri/html5/document.rb, line 110
    def read_memory(string, url = nil, encoding = nil, **options)
      raise ArgumentError, "string object doesn't respond to :to_str" unless string.respond_to?(:to_str)

      do_parse(string, url, encoding, options)
    end
    ```

    Create a new document from a String.

    💡 Most users should prefer [`Document.parse`](document#method-c-parse) to this method.

    ### Public Instance Methods
- name: Nokogiri::HTML5::DocumentFragment
  id: nokogiri/html5/documentfragment
  summary: 💡 HTML5 functionality is not available when running JRuby
  description: "# class Nokogiri::HTML5::DocumentFragment\n\nParent:  \n[Nokogiri::HTML4::DocumentFragment](../html4/documentfragment)\n\nSince v1.12.0\n\n💡 [`HTML5`](../html5) functionality is not available when running JRuby.\n\n### Attributes\n\ndocument\\[RW\\]\n\nerrors\\[RW\\]\n\nquirks_mode\\[R\\]\n\nGet the parser’s quirks mode value. See [`HTML5::QuirksMode`](quirksmode).\n\nThis method returns ‘nil\\` if the parser was not invoked (e.g., \\`Nokogiri::HTML5::DocumentFragment.new(doc)\\`).\n\nSince v1.14.0\n\n### Public Class Methods\n\nnew(doc, tags = nil, ctx = nil, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/html5/document_fragment.rb, line 39\ndef initialize(doc, tags = nil, ctx = nil, options = {})\n  self.document = doc\n  self.errors = []\n  return self unless tags\n\n  max_attributes = options[:max_attributes] || Nokogiri::Gumbo::DEFAULT_MAX_ATTRIBUTES\n  max_errors = options[:max_errors] || Nokogiri::Gumbo::DEFAULT_MAX_ERRORS\n  max_depth = options[:max_tree_depth] || Nokogiri::Gumbo::DEFAULT_MAX_TREE_DEPTH\n  tags = Nokogiri::HTML5.read_and_encode(tags, nil)\n  Nokogiri::Gumbo.fragment(self, tags, ctx, max_attributes, max_errors, max_depth)\nend\n```\n\nCreate a document fragment.\n\nparse(tags, encoding = nil, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/html5/document_fragment.rb, line 58\ndef self.parse(tags, encoding = nil, options = {})\n  doc = HTML5::Document.new\n  tags = HTML5.read_and_encode(tags, encoding)\n  doc.encoding = \"UTF-8\"\n  new(doc, tags, nil, options)\nend\n```\n\nParse a document fragment from `tags`, returning a Nodeset.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/DocumentFragment.html)"
- name: Nokogiri::HTML5::DocumentFragment#document
  id: nokogiri/html5/documentfragment#attribute-i-document
  summary: null
  belongs_to: Nokogiri::HTML5::DocumentFragment
  description: document \[RW\]
- name: Nokogiri::HTML5::DocumentFragment#errors
  id: nokogiri/html5/documentfragment#attribute-i-errors
  summary: null
  belongs_to: Nokogiri::HTML5::DocumentFragment
  description: errors \[RW\]
- name: Nokogiri::HTML5::DocumentFragment#quirks_mode
  id: nokogiri/html5/documentfragment#attribute-i-quirks_mode
  summary: Get the parser’s quirks mode value
  belongs_to: Nokogiri::HTML5::DocumentFragment
  description: |-
    quirks_mode \[R\]

    Get the parser’s quirks mode value. See [`HTML5::QuirksMode`](quirksmode).

    This method returns ‘nil\` if the parser was not invoked (e.g., \`Nokogiri::HTML5::DocumentFragment.new(doc)\`).

    Since v1.14.0

    ### Public Class Methods
- name: Nokogiri::HTML5::DocumentFragment::new
  id: nokogiri/html5/documentfragment#method-c-new
  summary: Create a document fragment
  belongs_to: Nokogiri::HTML5::DocumentFragment
  description: |-
    new (doc, tags = nil, ctx = nil, options = {}) Show source

    ``` ruby
    # File lib/nokogiri/html5/document_fragment.rb, line 39
    def initialize(doc, tags = nil, ctx = nil, options = {})
      self.document = doc
      self.errors = []
      return self unless tags

      max_attributes = options[:max_attributes] || Nokogiri::Gumbo::DEFAULT_MAX_ATTRIBUTES
      max_errors = options[:max_errors] || Nokogiri::Gumbo::DEFAULT_MAX_ERRORS
      max_depth = options[:max_tree_depth] || Nokogiri::Gumbo::DEFAULT_MAX_TREE_DEPTH
      tags = Nokogiri::HTML5.read_and_encode(tags, nil)
      Nokogiri::Gumbo.fragment(self, tags, ctx, max_attributes, max_errors, max_depth)
    end
    ```

    Create a document fragment.
- name: Nokogiri::HTML5::DocumentFragment::parse
  id: nokogiri/html5/documentfragment#method-c-parse
  summary: Parse a document fragment from tags, returning a Nodeset
  belongs_to: Nokogiri::HTML5::DocumentFragment
  description: "parse (tags, encoding = nil, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/html5/document_fragment.rb, line 58\ndef self.parse(tags, encoding = nil, options = {})\n  doc = HTML5::Document.new\n  tags = HTML5.read_and_encode(tags, encoding)\n  doc.encoding = \"UTF-8\"\n  new(doc, tags, nil, options)\nend\n```\n\nParse a document fragment from `tags`, returning a Nodeset.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/DocumentFragment.html)"
- name: Nokogiri::HTML5::fragment
  id: nokogiri/html5#method-c-fragment
  summary: Parse a fragment from string
  belongs_to: Nokogiri::HTML5
  description: |-
    fragment (string, encoding = nil, \*\*options) Show source

    ``` ruby
    # File lib/nokogiri/html5.rb, line 238
    def fragment(string, encoding = nil, **options)
      DocumentFragment.parse(string, encoding, options)
    end
    ```

    Parse a fragment from `string`. Convenience method for {Nokogiri::HTML5::DocumentFragment.parse}.
- name: Nokogiri::HTML5::get
  id: nokogiri/html5#method-c-get
  summary: Fetch and parse a HTML document from the web, following redirects, handling https, and determining the character encoding using HTML5 rules
  belongs_to: Nokogiri::HTML5
  description: |-
    get (uri, options = {}) Show source

    ``` ruby
    # File lib/nokogiri/html5.rb, line 249
    def get(uri, options = {})
      # TODO: deprecate
      warn("Nokogiri::HTML5.get is deprecated and will be removed in a future version of Nokogiri.",
        uplevel: 1, category: :deprecated)
      get_impl(uri, options)
    end
    ```

    Fetch and parse a [`HTML`](html4) document from the web, following redirects, handling https, and determining the character encoding using [`HTML5`](html5) rules. `uri` may be a `String` or a `URI`. `options` contains http headers and special options. Everything which is not a special option is considered a header. Special options include:

        * :follow_limit => number of redirects which are followed
        * :basic_auth => [username, password]
- name: Nokogiri::HTML5::Node
  id: nokogiri/html5/node
  summary: 💡 HTML5 functionality is not available when running JRuby
  description: "# module Nokogiri::HTML5::Node\n\nSince v1.12.0\n\n💡 [`HTML5`](../html5) functionality is not available when running JRuby.\n\n### Public Instance Methods\n\nfragment(tags) Show source\n\n``` ruby\n# File lib/nokogiri/html5/node.rb, line 65\ndef fragment(tags)\n  return super(tags) unless document.is_a?(HTML5::Document)\n\n  DocumentFragment.new(document, tags, self)\nend\n```\n\nCalls superclass method\n\ninner_html(options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/html5/node.rb, line 28\ndef inner_html(options = {})\n  return super(options) unless document.is_a?(HTML5::Document)\n\n  result = options[:preserve_newline] && prepend_newline? ? +\"\\n\" : +\"\"\n  result << children.map { |child| child.to_html(options) }.join\n  result\nend\n```\n\nCalls superclass method\n\nwrite_to(io, \\*options) { \\|config\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html5/node.rb, line 36\ndef write_to(io, *options)\n  return super(io, *options) unless document.is_a?(HTML5::Document)\n\n  options = options.first.is_a?(Hash) ? options.shift : {}\n  encoding = options[:encoding] || options[0]\n  if Nokogiri.jruby?\n    save_options = options[:save_with] || options[1]\n    indent_times = options[:indent] || 0\n  else\n    save_options = options[:save_with] || options[1] || XML::Node::SaveOptions::FORMAT\n    indent_times = options[:indent] || 2\n  end\n  indent_string = (options[:indent_text] || \" \") * indent_times\n\n  config = XML::Node::SaveOptions.new(save_options.to_i)\n  yield config if block_given?\n\n  config_options = config.options\n  if config_options & (XML::Node::SaveOptions::AS_XML | XML::Node::SaveOptions::AS_XHTML) != 0\n    # Use Nokogiri's serializing code.\n    native_write_to(io, encoding, indent_string, config_options)\n  else\n    # Serialize including the current node.\n    html = html_standard_serialize(options[:preserve_newline] || false)\n    encoding ||= document.encoding || Encoding::UTF_8\n    io << html.encode(encoding, fallback: lambda { |c| \"&#x#{c.ord.to_s(16)};\" })\n  end\nend\n```\n\nCalls superclass method\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/Node.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/Node.html)"
- name: Nokogiri::HTML5::Node#fragment
  id: nokogiri/html5/node#method-i-fragment
  summary: null
  belongs_to: Nokogiri::HTML5::Node
  description: |-
    fragment (tags) Show source

    ``` ruby
    # File lib/nokogiri/html5/node.rb, line 65
    def fragment(tags)
      return super(tags) unless document.is_a?(HTML5::Document)

      DocumentFragment.new(document, tags, self)
    end
    ```

    Calls superclass method
- name: Nokogiri::HTML5::Node#inner_html
  id: nokogiri/html5/node#method-i-inner_html
  summary: null
  belongs_to: Nokogiri::HTML5::Node
  description: |-
    inner_html (options = {}) Show source

    ``` ruby
    # File lib/nokogiri/html5/node.rb, line 28
    def inner_html(options = {})
      return super(options) unless document.is_a?(HTML5::Document)

      result = options[:preserve_newline] && prepend_newline? ? +"\n" : +""
      result << children.map { |child| child.to_html(options) }.join
      result
    end
    ```

    Calls superclass method
- name: Nokogiri::HTML5::Node#write_to
  id: nokogiri/html5/node#method-i-write_to
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::HTML5::Node
  description: "write_to (io, \\*options) { \\|config\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/html5/node.rb, line 36\ndef write_to(io, *options)\n  return super(io, *options) unless document.is_a?(HTML5::Document)\n\n  options = options.first.is_a?(Hash) ? options.shift : {}\n  encoding = options[:encoding] || options[0]\n  if Nokogiri.jruby?\n    save_options = options[:save_with] || options[1]\n    indent_times = options[:indent] || 0\n  else\n    save_options = options[:save_with] || options[1] || XML::Node::SaveOptions::FORMAT\n    indent_times = options[:indent] || 2\n  end\n  indent_string = (options[:indent_text] || \" \") * indent_times\n\n  config = XML::Node::SaveOptions.new(save_options.to_i)\n  yield config if block_given?\n\n  config_options = config.options\n  if config_options & (XML::Node::SaveOptions::AS_XML | XML::Node::SaveOptions::AS_XHTML) != 0\n    # Use Nokogiri's serializing code.\n    native_write_to(io, encoding, indent_string, config_options)\n  else\n    # Serialize including the current node.\n    html = html_standard_serialize(options[:preserve_newline] || false)\n    encoding ||= document.encoding || Encoding::UTF_8\n    io << html.encode(encoding, fallback: lambda { |c| \"&#x#{c.ord.to_s(16)};\" })\n  end\nend\n```\n\nCalls superclass method\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/Node.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/Node.html)"
- name: Nokogiri::HTML5::parse
  id: nokogiri/html5#method-c-parse
  summary: Parse an HTML 5 document
  belongs_to: Nokogiri::HTML5
  description: "parse (string, url = nil, encoding = nil, \\*\\*options, &block) Show source\n\n``` ruby\n# File lib/nokogiri/html5.rb, line 232\ndef parse(string, url = nil, encoding = nil, **options, &block)\n  Document.parse(string, url, encoding, **options, &block)\nend\n```\n\nParse an [`HTML`](html4) 5 document. Convenience method for {Nokogiri::HTML5::Document.parse}\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5.html](https://nokogiri.org/rdoc/Nokogiri/HTML5.html)"
- name: Nokogiri::HTML5::QuirksMode
  id: nokogiri/html5/quirksmode
  summary: Enum for the HTML5 parser quirks mode values
  description: "# module Nokogiri::HTML5::QuirksMode\n\nEnum for the [`HTML5`](../html5) parser quirks mode values. Values returned by [`HTML5::Document#quirks_mode`](document#attribute-i-quirks_mode)\n\nSee [dom.spec.whatwg.org/#concept-document-quirks](https://dom.spec.whatwg.org/#concept-document-quirks) for more information on [`HTML5`](../html5) quirks mode.\n\nSince v1.14.0\n\n### Constants\n\nLIMITED_QUIRKS\n\nNO_QUIRKS\n\nQUIRKS\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML5/QuirksMode.html](https://nokogiri.org/rdoc/Nokogiri/HTML5/QuirksMode.html)"
- name: Nokogiri::HTML::Builder
  id: nokogiri/html/builder
  summary: 💡 This class is an alias for Nokogiri::HTML4::Builder as of v1.12.0
  description: "# class Nokogiri::HTML::Builder\n\nParent:  \n[Nokogiri::XML::Builder](../xml/builder)\n\n💡 This class is an alias for [`Nokogiri::HTML4::Builder`](../html4/builder) as of v1.12.0.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML/Builder.html](https://nokogiri.org/rdoc/Nokogiri/HTML/Builder.html)"
- name: Nokogiri::HTML::Document
  id: nokogiri/html/document
  summary: 💡 This class is an alias for Nokogiri::HTML4::Document as of v1.12.0
  description: "# class Nokogiri::HTML::Document\n\nParent:  \n[Nokogiri::XML::Document](../xml/document)\n\n💡 This class is an alias for [`Nokogiri::HTML4::Document`](../html4/document) as of v1.12.0.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML/Document.html](https://nokogiri.org/rdoc/Nokogiri/HTML/Document.html)"
- name: Nokogiri::HTML::DocumentFragment
  id: nokogiri/html/documentfragment
  summary: 💡 This class is an alias for Nokogiri::HTML4::DocumentFragment as of v1.12.0
  description: "# class Nokogiri::HTML::DocumentFragment\n\nParent:  \n[Nokogiri::XML::DocumentFragment](../xml/documentfragment)\n\n💡 This class is an alias for [`Nokogiri::HTML4::DocumentFragment`](../html4/documentfragment) as of v1.12.0.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/HTML/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/HTML/DocumentFragment.html)"
- name: Nokogiri::make
  id: nokogiri#method-c-make
  summary: null
  belongs_to: Nokogiri
  description: |-
    make (input = nil, opts = {}, &blk) Show source

    ``` ruby
    # File lib/nokogiri.rb, line 60
    def make(input = nil, opts = {}, &blk)
      if input
        Nokogiri::HTML4.fragment(input).children.first
      else
        Nokogiri(&blk)
      end
    end
    ```

    Create a new [`Nokogiri::XML::DocumentFragment`](nokogiri/xml/documentfragment)
- name: Nokogiri::parse
  id: nokogiri#method-c-parse
  summary: Parse an HTML or XML document
  belongs_to: Nokogiri
  description: "parse (string, url = nil, encoding = nil, options = nil) { \\|doc\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri.rb, line 42\ndef parse(string, url = nil, encoding = nil, options = nil)\n  if string.respond_to?(:read) ||\n      /^\\s*<(?:!DOCTYPE\\s+)?html[\\s>]/i.match?(string[0, 512])\n    # Expect an HTML indicator to appear within the first 512\n    # characters of a document. (<?xml ?> + <?xml-stylesheet ?>\n    # shouldn't be that long)\n    Nokogiri.HTML4(string, url, encoding,\n      options || XML::ParseOptions::DEFAULT_HTML)\n  else\n    Nokogiri.XML(string, url, encoding,\n      options || XML::ParseOptions::DEFAULT_XML)\n  end.tap do |doc|\n    yield doc if block_given?\n  end\nend\n```\n\nParse an [`HTML`](nokogiri/html4) or [`XML`](nokogiri/xml) document. `string` contains the document.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri.html](https://nokogiri.org/rdoc/Nokogiri.html)"
- name: Nokogiri::Slop
  id: nokogiri#method-c-Slop
  summary: Parse a document and add the Slop decorator
  belongs_to: Nokogiri
  description: |-
    Slop (\*args, &block) Show source

    ``` ruby
    # File lib/nokogiri.rb, line 83
    def Slop(*args, &block)
      Nokogiri(*args, &block).slop!
    end
    ```

    Parse a document and add the [`Slop`](nokogiri#method-c-Slop) decorator. The [`Slop`](nokogiri#method-c-Slop) decorator implements method_missing such that methods may be used instead of [`CSS`](nokogiri/css) or XPath. For example:

    ``` ruby
    doc = Nokogiri::Slop(<<-eohtml)
      <html>
        <body>
          <p>first</p>
          <p>second</p>
        </body>
      </html>
    eohtml
    assert_equal('second', doc.html.body.p[1].text)
    ```
- name: Nokogiri::SyntaxError
  id: nokogiri/syntaxerror
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::SyntaxError\n\nParent:  \nStandardError\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/SyntaxError.html](https://nokogiri.org/rdoc/Nokogiri/SyntaxError.html)"
- name: Nokogiri::XML
  id: nokogiri/xml
  summary: Parse an XML document using the Nokogiri::XML::Reader API
  description: "# module Nokogiri::XML\n\n### Constants\n\nXML_C14N_1_0  \nOriginal C14N 1.0 spec canonicalization\n\nXML_C14N_1_1  \nC14N 1.1 spec canonicalization\n\nXML_C14N_EXCLUSIVE_1_0  \nExclusive C14N 1.0 spec canonicalization\n\n### Public Class Methods\n\nReader(string_or_io, url = nil, encoding = nil, options = ParseOptions::STRICT) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml.rb, line 23\ndef Reader(string_or_io, url = nil, encoding = nil, options = ParseOptions::STRICT)\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  if string_or_io.respond_to?(:read)\n    return Reader.from_io(string_or_io, url, encoding, options.to_i)\n  end\n\n  Reader.from_memory(string_or_io, url, encoding, options.to_i)\nend\n```\n\nParse an [`XML`](xml) document using the [`Nokogiri::XML::Reader`](xml/reader) API. See [`Nokogiri::XML::Reader`](xml/reader) for mor information\n\nRelaxNG(string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Show source\n\n``` ruby\n# File lib/nokogiri/xml/relax_ng.rb, line 9\ndef RelaxNG(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n  RelaxNG.new(string_or_io, options)\nend\n```\n\nCreate a new [`Nokogiri::XML::RelaxNG`](xml/relaxng) document from `string_or_io`. See [`Nokogiri::XML::RelaxNG`](xml/relaxng) for an example.\n\nSchema(string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Show source\n\n``` ruby\n# File lib/nokogiri/xml/schema.rb, line 9\ndef Schema(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n  Schema.new(string_or_io, options)\nend\n```\n\nCreate a new [`Nokogiri::XML::Schema`](xml/schema) object using a `string_or_io` object.\n\nfragment(string, options = ParseOptions::DEFAULT_XML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml.rb, line 42\ndef fragment(string, options = ParseOptions::DEFAULT_XML, &block)\n  XML::DocumentFragment.parse(string, options, &block)\nend\n```\n\nParse a fragment from `string` in to a [`NodeSet`](xml/nodeset).\n\nparse(thing, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml.rb, line 36\ndef parse(thing, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML, &block)\n  Document.parse(thing, url, encoding, options, &block)\nend\n```\n\nParse [`XML`](xml). Convenience method for [`Nokogiri::XML::Document.parse`](xml/document#method-c-parse)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML.html](https://nokogiri.org/rdoc/Nokogiri/XML.html)"
- name: Nokogiri::XML
  id: nokogiri#method-c-XML
  summary: Parse XML
  belongs_to: Nokogiri
  description: |-
    XML (thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_XML, &block) Show source

    ``` ruby
    # File lib/nokogiri/xml.rb, line 7
    def XML(thing, url = nil, encoding = nil, options = XML::ParseOptions::DEFAULT_XML, &block)
      Nokogiri::XML::Document.parse(thing, url, encoding, options, &block)
    end
    ```

    Parse [`XML`](nokogiri/xml). Convenience method for [`Nokogiri::XML::Document.parse`](nokogiri/xml/document#method-c-parse)
- name: Nokogiri::XML::Attr
  id: nokogiri/xml/attr
  summary: Attr represents a Attr node in an xml document
  description: "# class Nokogiri::XML::Attr\n\nParent:  \ncNokogiriXmlNode\n\n[`Attr`](attr) represents a [`Attr`](attr) node in an xml document.\n\n### Public Class Methods\n\nnew(document, name) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  VALUE document;\n  VALUE name;\n  VALUE rest;\n  xmlAttrPtr node;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"2*\", &document, &name, &rest);\n\n  if (! rb_obj_is_kind_of(document, cNokogiriXmlDocument)) {\n    rb_raise(rb_eArgError, \"parameter must be a Nokogiri::XML::Document\");\n  }\n\n  Noko_Node_Get_Struct(document, xmlDoc, xml_doc);\n\n  node = xmlNewDocProp(\n           xml_doc,\n           (const xmlChar *)StringValueCStr(name),\n           NULL\n         );\n\n  noko_xml_document_pin_node((xmlNodePtr)node);\n\n  rb_node = noko_xml_node_wrap(klass, (xmlNodePtr)node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  if (rb_block_given_p()) {\n    rb_yield(rb_node);\n  }\n\n  return rb_node;\n}\n```\n\nCreate a new [`Attr`](attr) element on the `document` with `name`\n\n### Public Instance Methods\n\ncontent=(p1)\n\nAlias for: [value=](attr#method-i-value-3D)\n\ndeconstruct_keys(array_of_names) → Hash Show source\n\n``` ruby\n# File lib/nokogiri/xml/attr.rb, line 55\ndef deconstruct_keys(keys)\n  { name: name, value: value, namespace: namespace }\nend\n```\n\nReturns a hash describing the [`Attr`](attr), to use in pattern matching.\n\nValid keys and their values:\n\n- `name` → (String) The name of the attribute.\n\n- `value` → (String) The value of the attribute.\n\n- `namespace` → ([`Namespace`](namespace), nil) The [`Namespace`](namespace) of the attribute, or `nil` if there is no namespace.\n\n⚡ This is an experimental feature, available since v1.14.0\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML.parse(<<~XML)\n  <?xml version=\"1.0\"?>\n  <root xmlns=\"http://nokogiri.org/ns/default\" xmlns:noko=\"http://nokogiri.org/ns/noko\">\n    <child1 foo=\"abc\" noko:bar=\"def\"/>\n  </root>\nXML\n\nattributes = doc.root.elements.first.attribute_nodes\n# => [#(Attr:0x35c { name = \"foo\", value = \"abc\" }),\n#     #(Attr:0x370 {\n#       name = \"bar\",\n#       namespace = #(Namespace:0x384 {\n#         prefix = \"noko\",\n#         href = \"http://nokogiri.org/ns/noko\"\n#         }),\n#       value = \"def\"\n#       })]\n\nattributes.first.deconstruct_keys([:name, :value, :namespace])\n# => {:name=>\"foo\", :value=>\"abc\", :namespace=>nil}\n\nattributes.last.deconstruct_keys([:name, :value, :namespace])\n# => {:name=>\"bar\",\n#     :value=>\"def\",\n#     :namespace=>\n#      #(Namespace:0x384 {\n#        prefix = \"noko\",\n#        href = \"http://nokogiri.org/ns/noko\"\n#        })}\n```\n\nvalue=(content) Show source\n\n``` c\nstatic VALUE\nset_value(VALUE self, VALUE content)\n{\n  xmlAttrPtr attr;\n  xmlChar *value;\n  xmlNode *cur;\n\n  Noko_Node_Get_Struct(self, xmlAttr, attr);\n\n  if (attr->children) {\n    xmlFreeNodeList(attr->children);\n  }\n  attr->children = attr->last = NULL;\n\n  if (content == Qnil) {\n    return content;\n  }\n\n  value = xmlEncodeEntitiesReentrant(attr->doc, (unsigned char *)StringValueCStr(content));\n  if (xmlStrlen(value) == 0) {\n    attr->children = xmlNewDocText(attr->doc, value);\n  } else {\n    attr->children = xmlStringGetNodeList(attr->doc, value);\n  }\n  xmlFree(value);\n\n  for (cur = attr->children; cur; cur = cur->next) {\n    cur->parent = (xmlNode *)attr;\n    cur->doc = attr->doc;\n    if (cur->next == NULL) {\n      attr->last = cur;\n    }\n  }\n\n  return content;\n}\n```\n\nSet the value for this [`Attr`](attr) to `content`. Use ‘nil\\` to remove the value (e.g., a [`HTML`](../html4) boolean attribute).\n\nAlso aliased as: [content=](attr#method-i-content-3D)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Attr.html](https://nokogiri.org/rdoc/Nokogiri/XML/Attr.html)"
- name: Nokogiri::XML::Attr#content=
  id: nokogiri/xml/attr#method-i-content-3D
  summary: null
  belongs_to: Nokogiri::XML::Attr
  description: |-
    content= (p1)

    Alias for: [value=](attr#method-i-value-3D)
- name: Nokogiri::XML::Attr#deconstruct_keys
  id: nokogiri/xml/attr#method-i-deconstruct_keys
  summary: Returns a hash describing the Attr, to use in pattern matching
  belongs_to: Nokogiri::XML::Attr
  description: |-
    deconstruct_keys(array_of_names) → Hash Show source

    ``` ruby
    # File lib/nokogiri/xml/attr.rb, line 55
    def deconstruct_keys(keys)
      { name: name, value: value, namespace: namespace }
    end
    ```

    Returns a hash describing the [`Attr`](attr), to use in pattern matching.

    Valid keys and their values:

    - `name` → (String) The name of the attribute.

    - `value` → (String) The value of the attribute.

    - `namespace` → ([`Namespace`](namespace), nil) The [`Namespace`](namespace) of the attribute, or `nil` if there is no namespace.

    ⚡ This is an experimental feature, available since v1.14.0

    **Example**

    ``` ruby
    doc = Nokogiri::XML.parse(<<~XML)
      <?xml version="1.0"?>
      <root xmlns="http://nokogiri.org/ns/default" xmlns:noko="http://nokogiri.org/ns/noko">
        <child1 foo="abc" noko:bar="def"/>
      </root>
    XML

    attributes = doc.root.elements.first.attribute_nodes
    # => [#(Attr:0x35c { name = "foo", value = "abc" }),
    #     #(Attr:0x370 {
    #       name = "bar",
    #       namespace = #(Namespace:0x384 {
    #         prefix = "noko",
    #         href = "http://nokogiri.org/ns/noko"
    #         }),
    #       value = "def"
    #       })]

    attributes.first.deconstruct_keys([:name, :value, :namespace])
    # => {:name=>"foo", :value=>"abc", :namespace=>nil}

    attributes.last.deconstruct_keys([:name, :value, :namespace])
    # => {:name=>"bar",
    #     :value=>"def",
    #     :namespace=>
    #      #(Namespace:0x384 {
    #        prefix = "noko",
    #        href = "http://nokogiri.org/ns/noko"
    #        })}
    ```
- name: Nokogiri::XML::Attr#value=
  id: nokogiri/xml/attr#method-i-value-3D
  summary: Set the value for this Attr to content
  belongs_to: Nokogiri::XML::Attr
  description: "value=(content) Show source\n\n``` c\nstatic VALUE\nset_value(VALUE self, VALUE content)\n{\n  xmlAttrPtr attr;\n  xmlChar *value;\n  xmlNode *cur;\n\n  Noko_Node_Get_Struct(self, xmlAttr, attr);\n\n  if (attr->children) {\n    xmlFreeNodeList(attr->children);\n  }\n  attr->children = attr->last = NULL;\n\n  if (content == Qnil) {\n    return content;\n  }\n\n  value = xmlEncodeEntitiesReentrant(attr->doc, (unsigned char *)StringValueCStr(content));\n  if (xmlStrlen(value) == 0) {\n    attr->children = xmlNewDocText(attr->doc, value);\n  } else {\n    attr->children = xmlStringGetNodeList(attr->doc, value);\n  }\n  xmlFree(value);\n\n  for (cur = attr->children; cur; cur = cur->next) {\n    cur->parent = (xmlNode *)attr;\n    cur->doc = attr->doc;\n    if (cur->next == NULL) {\n      attr->last = cur;\n    }\n  }\n\n  return content;\n}\n```\n\nSet the value for this [`Attr`](attr) to `content`. Use ‘nil\\` to remove the value (e.g., a [`HTML`](../html4) boolean attribute).\n\nAlso aliased as: [content=](attr#method-i-content-3D)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Attr.html](https://nokogiri.org/rdoc/Nokogiri/XML/Attr.html)"
- name: Nokogiri::XML::Attr::new
  id: nokogiri/xml/attr#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::Attr
  description: |-
    new(document, name) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr xml_doc;
      VALUE document;
      VALUE name;
      VALUE rest;
      xmlAttrPtr node;
      VALUE rb_node;

      rb_scan_args(argc, argv, "2*", &document, &name, &rest);

      if (! rb_obj_is_kind_of(document, cNokogiriXmlDocument)) {
        rb_raise(rb_eArgError, "parameter must be a Nokogiri::XML::Document");
      }

      Noko_Node_Get_Struct(document, xmlDoc, xml_doc);

      node = xmlNewDocProp(
               xml_doc,
               (const xmlChar *)StringValueCStr(name),
               NULL
             );

      noko_xml_document_pin_node((xmlNodePtr)node);

      rb_node = noko_xml_node_wrap(klass, (xmlNodePtr)node);
      rb_obj_call_init(rb_node, argc, argv);

      if (rb_block_given_p()) {
        rb_yield(rb_node);
      }

      return rb_node;
    }
    ```

    Create a new [`Attr`](attr) element on the `document` with `name`

    ### Public Instance Methods
- name: Nokogiri::XML::AttributeDecl
  id: nokogiri/xml/attributedecl
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::AttributeDecl\n\nParent:  \ncNokogiriXmlNode\n\nRepresents an attribute declaration in a [`DTD`](dtd)\n\n### Public Instance Methods\n\nattribute_type Show source\n\n``` c\nstatic VALUE\nattribute_type(VALUE self)\n{\n  xmlAttributePtr node;\n  Noko_Node_Get_Struct(self, xmlAttribute, node);\n  return INT2NUM(node->atype);\n}\n```\n\nThe [`attribute_type`](attributedecl#method-i-attribute_type) for this [`AttributeDecl`](attributedecl)\n\ndefault Show source\n\n``` c\nstatic VALUE\ndefault_value(VALUE self)\n{\n  xmlAttributePtr node;\n  Noko_Node_Get_Struct(self, xmlAttribute, node);\n\n  if (node->defaultValue) { return NOKOGIRI_STR_NEW2(node->defaultValue); }\n  return Qnil;\n}\n```\n\nThe default value\n\nenumeration Show source\n\n``` c\nstatic VALUE\nenumeration(VALUE self)\n{\n  xmlAttributePtr node;\n  xmlEnumerationPtr enm;\n  VALUE list;\n\n  Noko_Node_Get_Struct(self, xmlAttribute, node);\n\n  list = rb_ary_new();\n  enm = node->tree;\n\n  while (enm) {\n    rb_ary_push(list, NOKOGIRI_STR_NEW2(enm->name));\n    enm = enm->next;\n  }\n\n  return list;\n}\n```\n\nAn enumeration of possible values\n\ninspect() Show source\n\n``` ruby\n# File lib/nokogiri/xml/attribute_decl.rb, line 15\ndef inspect\n  \"#<#{self.class.name}:#{format(\"0x%x\", object_id)} #{to_s.inspect}>\"\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/AttributeDecl.html](https://nokogiri.org/rdoc/Nokogiri/XML/AttributeDecl.html)"
- name: Nokogiri::XML::AttributeDecl#attribute_type
  id: nokogiri/xml/attributedecl#method-i-attribute_type
  summary: null
  belongs_to: Nokogiri::XML::AttributeDecl
  description: |-
    attribute_type Show source

    ``` c
    static VALUE
    attribute_type(VALUE self)
    {
      xmlAttributePtr node;
      Noko_Node_Get_Struct(self, xmlAttribute, node);
      return INT2NUM(node->atype);
    }
    ```

    The [`attribute_type`](attributedecl#method-i-attribute_type) for this [`AttributeDecl`](attributedecl)
- name: Nokogiri::XML::AttributeDecl#default
  id: nokogiri/xml/attributedecl#method-i-default
  summary: null
  belongs_to: Nokogiri::XML::AttributeDecl
  description: |-
    default Show source

    ``` c
    static VALUE
    default_value(VALUE self)
    {
      xmlAttributePtr node;
      Noko_Node_Get_Struct(self, xmlAttribute, node);

      if (node->defaultValue) { return NOKOGIRI_STR_NEW2(node->defaultValue); }
      return Qnil;
    }
    ```

    The default value
- name: Nokogiri::XML::AttributeDecl#enumeration
  id: nokogiri/xml/attributedecl#method-i-enumeration
  summary: null
  belongs_to: Nokogiri::XML::AttributeDecl
  description: |-
    enumeration Show source

    ``` c
    static VALUE
    enumeration(VALUE self)
    {
      xmlAttributePtr node;
      xmlEnumerationPtr enm;
      VALUE list;

      Noko_Node_Get_Struct(self, xmlAttribute, node);

      list = rb_ary_new();
      enm = node->tree;

      while (enm) {
        rb_ary_push(list, NOKOGIRI_STR_NEW2(enm->name));
        enm = enm->next;
      }

      return list;
    }
    ```

    An enumeration of possible values
- name: Nokogiri::XML::AttributeDecl#inspect
  id: nokogiri/xml/attributedecl#method-i-inspect
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::AttributeDecl
  description: "inspect () Show source\n\n``` ruby\n# File lib/nokogiri/xml/attribute_decl.rb, line 15\ndef inspect\n  \"#<#{self.class.name}:#{format(\"0x%x\", object_id)} #{to_s.inspect}>\"\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/AttributeDecl.html](https://nokogiri.org/rdoc/Nokogiri/XML/AttributeDecl.html)"
- name: Nokogiri::XML::Builder
  id: nokogiri/xml/builder
  summary: Nokogiri builder can be used for building XML and HTML documents
  description: "# class Nokogiri::XML::Builder\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nIncluded modules:  \n[Nokogiri::ClassResolver](../classresolver)\n\n[`Nokogiri`](../../nokogiri) builder can be used for building [`XML`](../xml) and [`HTML`](../html4) documents.\n\n## Synopsis:\n\n``` ruby\nbuilder = Nokogiri::XML::Builder.new do |xml|\n  xml.root {\n    xml.products {\n      xml.widget {\n        xml.id_ \"10\"\n        xml.name \"Awesome widget\"\n      }\n    }\n  }\nend\nputs builder.to_xml\n```\n\nWill output:\n\n    <?xml version=\"1.0\"?>\n    <root>\n      <products>\n        <widget>\n          <id>10</id>\n          <name>Awesome widget</name>\n        </widget>\n      </products>\n    </root>\n\n### [`Builder`](builder) scope\n\nThe builder allows two forms. When the builder is supplied with a block that has a parameter, the outside scope is maintained. This means you can access variables that are outside your builder. If you don’t need outside scope, you can use the builder without the “xml” prefix like this:\n\n``` ruby\nbuilder = Nokogiri::XML::Builder.new do\n  root {\n    products {\n      widget {\n        id_ \"10\"\n        name \"Awesome widget\"\n      }\n    }\n  }\nend\n```\n\n## Special Tags\n\nThe builder works by taking advantage of method_missing. Unfortunately some methods are defined in ruby that are difficult or dangerous to remove. You may want to create tags with the name “type”, “class”, and “id” for example. In that case, you can use an underscore to disambiguate your tag name from the method call.\n\nHere is an example of using the underscore to disambiguate tag names from ruby methods:\n\n``` ruby\n@objects = [Object.new, Object.new, Object.new]\n\nbuilder = Nokogiri::XML::Builder.new do |xml|\n  xml.root {\n    xml.objects {\n      @objects.each do |o|\n        xml.object {\n          xml.type_   o.type\n          xml.class_  o.class.name\n          xml.id_     o.id\n        }\n      end\n    }\n  }\nend\nputs builder.to_xml\n```\n\nThe underscore may be used with any tag name, and the last underscore will just be removed. This code will output the following XML:\n\n    <?xml version=\"1.0\"?>\n    <root>\n      <objects>\n        <object>\n          <type>Object</type>\n          <class>Object</class>\n          <id>48390</id>\n        </object>\n        <object>\n          <type>Object</type>\n          <class>Object</class>\n          <id>48380</id>\n        </object>\n        <object>\n          <type>Object</type>\n          <class>Object</class>\n          <id>48370</id>\n        </object>\n      </objects>\n    </root>\n\n## Tag Attributes\n\nTag attributes may be supplied as method arguments. Here is our previous example, but using attributes rather than tags:\n\n``` ruby\n@objects = [Object.new, Object.new, Object.new]\n\nbuilder = Nokogiri::XML::Builder.new do |xml|\n  xml.root {\n    xml.objects {\n      @objects.each do |o|\n        xml.object(:type => o.type, :class => o.class, :id => o.id)\n      end\n    }\n  }\nend\nputs builder.to_xml\n```\n\n### Tag Attribute Short Cuts\n\nA couple attribute short cuts are available when building tags. The short cuts are available by special method calls when building a tag.\n\nThis example builds an “object” tag with the class attribute “classy” and the id of “thing”:\n\n``` ruby\nbuilder = Nokogiri::XML::Builder.new do |xml|\n  xml.root {\n    xml.objects {\n      xml.object.classy.thing!\n    }\n  }\nend\nputs builder.to_xml\n```\n\nWhich will output:\n\n    <?xml version=\"1.0\"?>\n    <root>\n      <objects>\n        <object class=\"classy\" id=\"thing\"/>\n      </objects>\n    </root>\n\nAll other options are still supported with this syntax, including blocks and extra tag attributes.\n\n## Namespaces\n\nNamespaces are added similarly to attributes. [`Nokogiri::XML::Builder`](builder) assumes that when an attribute starts with “xmlns”, it is meant to be a namespace:\n\n``` ruby\nbuilder = Nokogiri::XML::Builder.new { |xml|\n  xml.root('xmlns' => 'default', 'xmlns:foo' => 'bar') do\n    xml.tenderlove\n  end\n}\nputs builder.to_xml\n```\n\nWill output [`XML`](../xml) like this:\n\n    <?xml version=\"1.0\"?>\n    <root xmlns:foo=\"bar\" xmlns=\"default\">\n      <tenderlove/>\n    </root>\n\n### Referencing declared namespaces\n\nTags that reference non-default namespaces (i.e. a tag “foo:bar”) can be built by using the [`Nokogiri::XML::Builder#[]`](builder#method-i-5B-5D) method.\n\nFor example:\n\n``` ruby\nbuilder = Nokogiri::XML::Builder.new do |xml|\n  xml.root('xmlns:foo' => 'bar') {\n    xml.objects {\n      xml['foo'].object.classy.thing!\n    }\n  }\nend\nputs builder.to_xml\n```\n\nWill output this XML:\n\n    <?xml version=\"1.0\"?>\n    <root xmlns:foo=\"bar\">\n      <objects>\n        <foo:object class=\"classy\" id=\"thing\"/>\n      </objects>\n    </root>\n\nNote the “foo:object” tag.\n\n### [`Namespace`](namespace) inheritance\n\nIn the [`Builder`](builder) context, children will inherit their parent’s namespace. This is the same behavior as if the underlying {XML::Document} set `namespace_inheritance` to `true`:\n\n``` ruby\nresult = Nokogiri::XML::Builder.new do |xml|\n  xml[\"soapenv\"].Envelope(\"xmlns:soapenv\" => \"http://schemas.xmlsoap.org/soap/envelope/\") do\n    xml.Header\n  end\nend\nresult.doc.to_xml\n# => <?xml version=\"1.0\" encoding=\"utf-8\"?>\n#    <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n#      <soapenv:Header/>\n#    </soapenv:Envelope>\n```\n\nUsers may turn this behavior off by passing a keyword argument `namespace_inheritance:false` to the initializer:\n\n``` ruby\nresult = Nokogiri::XML::Builder.new(namespace_inheritance: false) do |xml|\n  xml[\"soapenv\"].Envelope(\"xmlns:soapenv\" => \"http://schemas.xmlsoap.org/soap/envelope/\") do\n    xml.Header\n    xml[\"soapenv\"].Body # users may explicitly opt into the namespace\n  end\nend\nresult.doc.to_xml\n# => <?xml version=\"1.0\" encoding=\"utf-8\"?>\n#    <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n#      <Header/>\n#      <soapenv:Body/>\n#    </soapenv:Envelope>\n```\n\nFor more information on namespace inheritance, please see {XML::Document#namespace_inheritance}\n\n## [`Document`](document) Types\n\nTo create a document type ([`DTD`](dtd)), use the [`Builder#doc`](builder#attribute-i-doc) method to get the current context document. Then call [`Node#create_internal_subset`](node#method-i-create_internal_subset) to create the [`DTD`](dtd) node.\n\nFor example, this Ruby:\n\n``` ruby\nbuilder = Nokogiri::XML::Builder.new do |xml|\n  xml.doc.create_internal_subset(\n    'html',\n    \"-//W3C//DTD HTML 4.01 Transitional//EN\",\n    \"http://www.w3.org/TR/html4/loose.dtd\"\n  )\n  xml.root do\n    xml.foo\n  end\nend\n\nputs builder.to_xml\n```\n\nWill output this xml:\n\n    <?xml version=\"1.0\"?>\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n    <root>\n      <foo/>\n    </root>\n\n### Constants\n\nDEFAULT_DOCUMENT_OPTIONS  \nVALID_NAMESPACES  \nIncluded from [Nokogiri::ClassResolver](../classresolver)\n\n[`related_class`](builder#method-i-related_class) restricts matching namespaces to those matching this set.\n\n### Attributes\n\ncontext\\[RW\\]\n\nA context object for use when the block has no arguments\n\ndoc\\[RW\\]\n\nThe current [`Document`](document) object being built\n\nparent\\[RW\\]\n\nThe parent of the current node being built\n\n### Public Class Methods\n\nnew(options = {}, root = nil) { \\|self\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 307\ndef initialize(options = {}, root = nil, &block)\n  if root\n    @doc = root.document\n    @parent = root\n  else\n    @parent = @doc = related_class(\"Document\").new\n  end\n\n  @context = nil\n  @arity = nil\n  @ns = nil\n\n  options = DEFAULT_DOCUMENT_OPTIONS.merge(options)\n  options.each do |k, v|\n    @doc.send(:\"#{k}=\", v)\n  end\n\n  return unless block\n\n  @arity = block.arity\n  if @arity <= 0\n    @context = eval(\"self\", block.binding)\n    instance_eval(&block)\n  else\n    yield self\n  end\n\n  @parent = @doc\nend\n```\n\nCreate a new [`Builder`](builder) object. `options` are sent to the top level [`Document`](document) that is being built.\n\nBuilding a document with a particular encoding for example:\n\n    Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|\n      ...\n    end\n\nwith(root, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 294\ndef self.with(root, &block)\n  new({}, root, &block)\nend\n```\n\nCreate a builder with an existing root object. This is for use when you have an existing document that you would like to augment with builder methods. The builder context created will start with the given `root` node.\n\nFor example:\n\n``` ruby\ndoc = Nokogiri::XML(File.read('somedoc.xml'))\nNokogiri::XML::Builder.with(doc.at_css('some_tag')) do |xml|\n  # ... Use normal builder methods here ...\n  xml.awesome # add the \"awesome\" tag below \"some_tag\"\nend\n```\n\n### Public Instance Methods\n\n\\<\\<(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 390\ndef <<(string)\n  @doc.fragment(string).children.each { |x| insert(x) }\nend\n```\n\nAppend the given raw [`XML`](../xml) `string` to the document\n\n\\[\\](ns) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 358\ndef [](ns)\n  if @parent != @doc\n    @ns = @parent.namespace_definitions.find { |x| x.prefix == ns.to_s }\n  end\n  return self if @ns\n\n  @parent.ancestors.each do |a|\n    next if a == doc\n\n    @ns = a.namespace_definitions.find { |x| x.prefix == ns.to_s }\n    return self if @ns\n  end\n\n  @ns = { pending: ns.to_s }\n  self\nend\n```\n\nBuild a tag that is associated with namespace `ns`. Raises an ArgumentError if `ns` has not been defined higher in the tree.\n\ncdata(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 345\ndef cdata(string)\n  insert(doc.create_cdata(string))\nend\n```\n\nCreate a [`CDATA`](cdata) [`Node`](node) with content of `string`\n\ncomment(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 351\ndef comment(string)\n  insert(doc.create_comment(string))\nend\n```\n\nCreate a [`Comment`](comment) [`Node`](node) with content of `string`\n\nrelated_class(class_name) → Class Show source\n\n``` ruby\n# File lib/nokogiri/class_resolver.rb, line 46\ndef related_class(class_name)\n  klass = nil\n  inspecting = self.class\n\n  while inspecting\n    namespace_path = inspecting.name.split(\"::\")[0..-2]\n    inspecting = inspecting.superclass\n\n    next unless VALID_NAMESPACES.include?(namespace_path.last)\n\n    related_class_name = (namespace_path << class_name).join(\"::\")\n    klass = begin\n      Object.const_get(related_class_name)\n    rescue NameError\n      nil\n    end\n    break if klass\n  end\n  klass\nend\n```\n\nIncluded from [Nokogiri::ClassResolver](../classresolver)\n\nFind a class constant within the\n\nSome examples:\n\n``` ruby\nNokogiri::XML::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::XML::DocumentFragment\nNokogiri::HTML4::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::HTML4::DocumentFragment\n```\n\nNote this will also work for subclasses that follow the same convention, e.g.:\n\n``` ruby\nLoofah::HTML::Document.new.related_class(\"DocumentFragment\")\n# => Loofah::HTML::DocumentFragment\n```\n\nAnd even if it’s a subclass, this will iterate through the superclasses:\n\n``` ruby\nclass ThisIsATopLevelClass < Nokogiri::HTML4::Builder ; end\nThisIsATopLevelClass.new.related_class(\"Document\")\n# => Nokogiri::HTML4::Document\n```\n\ntext(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 339\ndef text(string)\n  insert(@doc.create_text_node(string))\nend\n```\n\nCreate a [`Text`](text) [`Node`](node) with content of `string`\n\nto_xml(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 377\ndef to_xml(*args)\n  if Nokogiri.jruby?\n    options = args.first.is_a?(Hash) ? args.shift : {}\n    unless options[:save_with]\n      options[:save_with] = Node::SaveOptions::AS_BUILDER\n    end\n    args.insert(0, options)\n  end\n  @doc.to_xml(*args)\nend\n```\n\nConvert this [`Builder`](builder) object to [`XML`](../xml)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Builder.html](https://nokogiri.org/rdoc/Nokogiri/XML/Builder.html)"
- name: Nokogiri::XML::Builder#<<
  id: nokogiri/xml/builder#method-i-3C-3C
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    \<\< (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 390
    def <<(string)
      @doc.fragment(string).children.each { |x| insert(x) }
    end
    ```

    Append the given raw [`XML`](../xml) `string` to the document
- name: Nokogiri::XML::Builder#[]
  id: nokogiri/xml/builder#method-i-5B-5D
  summary: Build a tag that is associated with namespace ns
  belongs_to: Nokogiri::XML::Builder
  description: |-
    \[\] (ns) Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 358
    def [](ns)
      if @parent != @doc
        @ns = @parent.namespace_definitions.find { |x| x.prefix == ns.to_s }
      end
      return self if @ns

      @parent.ancestors.each do |a|
        next if a == doc

        @ns = a.namespace_definitions.find { |x| x.prefix == ns.to_s }
        return self if @ns
      end

      @ns = { pending: ns.to_s }
      self
    end
    ```

    Build a tag that is associated with namespace `ns`. Raises an ArgumentError if `ns` has not been defined higher in the tree.
- name: Nokogiri::XML::Builder#cdata
  id: nokogiri/xml/builder#method-i-cdata
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    cdata (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 345
    def cdata(string)
      insert(doc.create_cdata(string))
    end
    ```

    Create a [`CDATA`](cdata) [`Node`](node) with content of `string`
- name: Nokogiri::XML::Builder#comment
  id: nokogiri/xml/builder#method-i-comment
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    comment (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 351
    def comment(string)
      insert(doc.create_comment(string))
    end
    ```

    Create a [`Comment`](comment) [`Node`](node) with content of `string`
- name: Nokogiri::XML::Builder#context
  id: nokogiri/xml/builder#attribute-i-context
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    context \[RW\]

    A context object for use when the block has no arguments
- name: Nokogiri::XML::Builder#doc
  id: nokogiri/xml/builder#attribute-i-doc
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    doc \[RW\]

    The current [`Document`](document) object being built
- name: Nokogiri::XML::Builder#parent
  id: nokogiri/xml/builder#attribute-i-parent
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    parent \[RW\]

    The parent of the current node being built

    ### Public Class Methods
- name: Nokogiri::XML::Builder#related_class
  id: nokogiri/xml/builder#method-i-related_class
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    related_class(class_name) → Class Show source

    ``` ruby
    # File lib/nokogiri/class_resolver.rb, line 46
    def related_class(class_name)
      klass = nil
      inspecting = self.class

      while inspecting
        namespace_path = inspecting.name.split("::")[0..-2]
        inspecting = inspecting.superclass

        next unless VALID_NAMESPACES.include?(namespace_path.last)

        related_class_name = (namespace_path << class_name).join("::")
        klass = begin
          Object.const_get(related_class_name)
        rescue NameError
          nil
        end
        break if klass
      end
      klass
    end
    ```

    Included from [Nokogiri::ClassResolver](../classresolver)

    Find a class constant within the

    Some examples:

    ``` ruby
    Nokogiri::XML::Document.new.related_class("DocumentFragment")
    # => Nokogiri::XML::DocumentFragment
    Nokogiri::HTML4::Document.new.related_class("DocumentFragment")
    # => Nokogiri::HTML4::DocumentFragment
    ```

    Note this will also work for subclasses that follow the same convention, e.g.:

    ``` ruby
    Loofah::HTML::Document.new.related_class("DocumentFragment")
    # => Loofah::HTML::DocumentFragment
    ```

    And even if it’s a subclass, this will iterate through the superclasses:

    ``` ruby
    class ThisIsATopLevelClass < Nokogiri::HTML4::Builder ; end
    ThisIsATopLevelClass.new.related_class("Document")
    # => Nokogiri::HTML4::Document
    ```
- name: Nokogiri::XML::Builder#text
  id: nokogiri/xml/builder#method-i-text
  summary: null
  belongs_to: Nokogiri::XML::Builder
  description: |-
    text (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 339
    def text(string)
      insert(@doc.create_text_node(string))
    end
    ```

    Create a [`Text`](text) [`Node`](node) with content of `string`
- name: Nokogiri::XML::Builder#to_xml
  id: nokogiri/xml/builder#method-i-to_xml
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::Builder
  description: "to_xml (\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/builder.rb, line 377\ndef to_xml(*args)\n  if Nokogiri.jruby?\n    options = args.first.is_a?(Hash) ? args.shift : {}\n    unless options[:save_with]\n      options[:save_with] = Node::SaveOptions::AS_BUILDER\n    end\n    args.insert(0, options)\n  end\n  @doc.to_xml(*args)\nend\n```\n\nConvert this [`Builder`](builder) object to [`XML`](../xml)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Builder.html](https://nokogiri.org/rdoc/Nokogiri/XML/Builder.html)"
- name: Nokogiri::XML::Builder::new
  id: nokogiri/xml/builder#method-c-new
  summary: Create a new Builder object
  belongs_to: Nokogiri::XML::Builder
  description: |-
    new (options = {}, root = nil) { \|self\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 307
    def initialize(options = {}, root = nil, &block)
      if root
        @doc = root.document
        @parent = root
      else
        @parent = @doc = related_class("Document").new
      end

      @context = nil
      @arity = nil
      @ns = nil

      options = DEFAULT_DOCUMENT_OPTIONS.merge(options)
      options.each do |k, v|
        @doc.send(:"#{k}=", v)
      end

      return unless block

      @arity = block.arity
      if @arity <= 0
        @context = eval("self", block.binding)
        instance_eval(&block)
      else
        yield self
      end

      @parent = @doc
    end
    ```

    Create a new [`Builder`](builder) object. `options` are sent to the top level [`Document`](document) that is being built.

    Building a document with a particular encoding for example:

        Nokogiri::XML::Builder.new(:encoding => 'UTF-8') do |xml|
          ...
        end
- name: Nokogiri::XML::Builder::with
  id: nokogiri/xml/builder#method-c-with
  summary: Create a builder with an existing root object
  belongs_to: Nokogiri::XML::Builder
  description: |-
    with (root, &block) Show source

    ``` ruby
    # File lib/nokogiri/xml/builder.rb, line 294
    def self.with(root, &block)
      new({}, root, &block)
    end
    ```

    Create a builder with an existing root object. This is for use when you have an existing document that you would like to augment with builder methods. The builder context created will start with the given `root` node.

    For example:

    ``` ruby
    doc = Nokogiri::XML(File.read('somedoc.xml'))
    Nokogiri::XML::Builder.with(doc.at_css('some_tag')) do |xml|
      # ... Use normal builder methods here ...
      xml.awesome # add the "awesome" tag below "some_tag"
    end
    ```

    ### Public Instance Methods
- name: Nokogiri::XML::CDATA
  id: nokogiri/xml/cdata
  summary: CData represents a CData node in an xml document
  description: "# class Nokogiri::XML::CDATA\n\nParent:  \ncNokogiriXmlText\n\nCData represents a CData node in an xml document.\n\n### Public Class Methods\n\nnew(document, content) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  xmlNodePtr node;\n  VALUE doc;\n  VALUE content;\n  VALUE rest;\n  VALUE rb_node;\n  xmlChar *content_str = NULL;\n  int content_str_len = 0;\n\n  rb_scan_args(argc, argv, \"2*\", &doc, &content, &rest);\n\n  Noko_Node_Get_Struct(doc, xmlDoc, xml_doc);\n\n  if (!NIL_P(content)) {\n    content_str = (xmlChar *)StringValuePtr(content);\n    content_str_len = RSTRING_LENINT(content);\n  }\n\n  node = xmlNewCDataBlock(xml_doc->doc, content_str, content_str_len);\n\n  noko_xml_document_pin_node(node);\n\n  rb_node = noko_xml_node_wrap(klass, node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  if (rb_block_given_p()) { rb_yield(rb_node); }\n\n  return rb_node;\n}\n```\n\nCreate a new [`CDATA`](cdata) element on the `document` with `content`\n\nIf `content` cannot be implicitly converted to a string, this method will raise a TypeError exception.\n\n### Public Instance Methods\n\nname() Show source\n\n``` ruby\n# File lib/nokogiri/xml/cdata.rb, line 8\ndef name\n  \"#cdata-section\"\nend\n```\n\nGet the name of this [`CDATA`](cdata) node\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/CDATA.html](https://nokogiri.org/rdoc/Nokogiri/XML/CDATA.html)"
- name: Nokogiri::XML::CDATA#name
  id: nokogiri/xml/cdata#method-i-name
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::CDATA
  description: "name () Show source\n\n``` ruby\n# File lib/nokogiri/xml/cdata.rb, line 8\ndef name\n  \"#cdata-section\"\nend\n```\n\nGet the name of this [`CDATA`](cdata) node\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/CDATA.html](https://nokogiri.org/rdoc/Nokogiri/XML/CDATA.html)"
- name: Nokogiri::XML::CDATA::new
  id: nokogiri/xml/cdata#method-c-new
  summary: If content cannot be implicitly converted to a string, this method will raise a TypeError exception
  belongs_to: Nokogiri::XML::CDATA
  description: |-
    new(document, content) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr xml_doc;
      xmlNodePtr node;
      VALUE doc;
      VALUE content;
      VALUE rest;
      VALUE rb_node;
      xmlChar *content_str = NULL;
      int content_str_len = 0;

      rb_scan_args(argc, argv, "2*", &doc, &content, &rest);

      Noko_Node_Get_Struct(doc, xmlDoc, xml_doc);

      if (!NIL_P(content)) {
        content_str = (xmlChar *)StringValuePtr(content);
        content_str_len = RSTRING_LENINT(content);
      }

      node = xmlNewCDataBlock(xml_doc->doc, content_str, content_str_len);

      noko_xml_document_pin_node(node);

      rb_node = noko_xml_node_wrap(klass, node);
      rb_obj_call_init(rb_node, argc, argv);

      if (rb_block_given_p()) { rb_yield(rb_node); }

      return rb_node;
    }
    ```

    Create a new [`CDATA`](cdata) element on the `document` with `content`

    If `content` cannot be implicitly converted to a string, this method will raise a TypeError exception.

    ### Public Instance Methods
- name: Nokogiri::XML::CharacterData
  id: nokogiri/xml/characterdata
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::CharacterData\n\nParent:  \ncNokogiriXmlNode\n\nIncluded modules:  \n[Nokogiri::XML::PP::CharacterData](pp/characterdata)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/CharacterData.html](https://nokogiri.org/rdoc/Nokogiri/XML/CharacterData.html)"
- name: Nokogiri::XML::Comment
  id: nokogiri/xml/comment
  summary: Comment represents a comment node in an xml document
  description: "# class Nokogiri::XML::Comment\n\nParent:  \ncNokogiriXmlCharacterData\n\n[`Comment`](comment) represents a comment node in an xml document.\n\n### Public Class Methods\n\nnew(document_or_node, content) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  xmlNodePtr node;\n  VALUE document;\n  VALUE content;\n  VALUE rest;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"2*\", &document, &content, &rest);\n\n  if (rb_obj_is_kind_of(document, cNokogiriXmlNode)) {\n    document = rb_funcall(document, document_id, 0);\n  } else if (!rb_obj_is_kind_of(document, cNokogiriXmlDocument)\n             && !rb_obj_is_kind_of(document, cNokogiriXmlDocumentFragment)) {\n    rb_raise(rb_eArgError, \"first argument must be a XML::Document or XML::Node\");\n  }\n\n  Data_Get_Struct(document, xmlDoc, xml_doc);\n\n  node = xmlNewDocComment(\n           xml_doc,\n           (const xmlChar *)StringValueCStr(content)\n         );\n\n  rb_node = noko_xml_node_wrap(klass, node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  noko_xml_document_pin_node(node);\n\n  if (rb_block_given_p()) { rb_yield(rb_node); }\n\n  return rb_node;\n}\n```\n\nCreate a new [`Comment`](comment) element on the `document` with `content`. Alternatively, if a `node` is passed, the `node`‘s document is used.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Comment.html](https://nokogiri.org/rdoc/Nokogiri/XML/Comment.html)"
- name: Nokogiri::XML::Comment::new
  id: nokogiri/xml/comment#method-c-new
  summary: Create a new Comment element on the document with content
  belongs_to: Nokogiri::XML::Comment
  description: "new(document_or_node, content) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  xmlNodePtr node;\n  VALUE document;\n  VALUE content;\n  VALUE rest;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"2*\", &document, &content, &rest);\n\n  if (rb_obj_is_kind_of(document, cNokogiriXmlNode)) {\n    document = rb_funcall(document, document_id, 0);\n  } else if (!rb_obj_is_kind_of(document, cNokogiriXmlDocument)\n             && !rb_obj_is_kind_of(document, cNokogiriXmlDocumentFragment)) {\n    rb_raise(rb_eArgError, \"first argument must be a XML::Document or XML::Node\");\n  }\n\n  Data_Get_Struct(document, xmlDoc, xml_doc);\n\n  node = xmlNewDocComment(\n           xml_doc,\n           (const xmlChar *)StringValueCStr(content)\n         );\n\n  rb_node = noko_xml_node_wrap(klass, node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  noko_xml_document_pin_node(node);\n\n  if (rb_block_given_p()) { rb_yield(rb_node); }\n\n  return rb_node;\n}\n```\n\nCreate a new [`Comment`](comment) element on the `document` with `content`. Alternatively, if a `node` is passed, the `node`‘s document is used.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Comment.html](https://nokogiri.org/rdoc/Nokogiri/XML/Comment.html)"
- name: Nokogiri::XML::Document
  id: nokogiri/xml/document
  summary: Nokogiri::XML::Document wraps an xml document
  description: "# class Nokogiri::XML::Document\n\nParent:  \ncNokogiriXmlNode\n\n[`Nokogiri::XML::Document`](document) wraps an xml document.\n\n[`Nokogiri::XML::Document`](document) is the main entry point for dealing with [`XML`](../xml) documents. The [`Document`](document) is created by parsing an [`XML`](../xml) document. See [`Nokogiri::XML::Document.parse`](document#method-c-parse) for more information on parsing.\n\nFor searching a [`Document`](document), see [`Nokogiri::XML::Searchable#css`](searchable#method-i-css) and [`Nokogiri::XML::Searchable#xpath`](searchable#method-i-xpath)\n\n### Constants\n\nNCNAME_CHAR  \nNCNAME_RE  \nNCNAME_START_CHAR  \nSee [www.w3.org/TR/REC-xml-names/#ns-decl](http://www.w3.org/TR/REC-xml-names/#ns-decl) for more details. Note that we’re not attempting to handle unicode characters partly because libxml2 doesn’t handle unicode characters in NCNAMEs.\n\n### Attributes\n\nerrors\\[RW\\]\n\nThe errors found while parsing a document.\n\nReturns  \nArray\\<Nokogiri::XML::SyntaxError\\>\n\nnamespace_inheritance\\[RW\\]\n\nWhen ‘true\\`, reparented elements without a namespace will inherit their new parent’s namespace (if one exists). Defaults to ‘false\\`.\n\nReturns  \nBoolean\n\n**Example:** Default behavior of namespace inheritance\n\n``` ruby\nxml = <<~EOF\n        <root xmlns:foo=\"http://nokogiri.org/default_ns/test/foo\">\n          <foo:parent>\n          </foo:parent>\n        </root>\n      EOF\ndoc = Nokogiri::XML(xml)\nparent = doc.at_xpath(\"//foo:parent\", \"foo\" => \"http://nokogiri.org/default_ns/test/foo\")\nparent.add_child(\"<child></child>\")\ndoc.to_xml\n# => <?xml version=\"1.0\"?>\n#    <root xmlns:foo=\"http://nokogiri.org/default_ns/test/foo\">\n#      <foo:parent>\n#        <child/>\n#      </foo:parent>\n#    </root>\n```\n\n**Example:** Setting namespace inheritance to ‘true\\`\n\n``` ruby\nxml = <<~EOF\n        <root xmlns:foo=\"http://nokogiri.org/default_ns/test/foo\">\n          <foo:parent>\n          </foo:parent>\n        </root>\n      EOF\ndoc = Nokogiri::XML(xml)\ndoc.namespace_inheritance = true\nparent = doc.at_xpath(\"//foo:parent\", \"foo\" => \"http://nokogiri.org/default_ns/test/foo\")\nparent.add_child(\"<child></child>\")\ndoc.to_xml\n# => <?xml version=\"1.0\"?>\n#    <root xmlns:foo=\"http://nokogiri.org/default_ns/test/foo\">\n#      <foo:parent>\n#        <foo:child/>\n#      </foo:parent>\n#    </root>\n```\n\nSince v1.12.4\n\n### Public Class Methods\n\nnew(version = default) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr doc;\n  VALUE version, rest, rb_doc ;\n\n  rb_scan_args(argc, argv, \"0*\", &rest);\n  version = rb_ary_entry(rest, (long)0);\n  if (NIL_P(version)) { version = rb_str_new2(\"1.0\"); }\n\n  doc = xmlNewDoc((xmlChar *)StringValueCStr(version));\n  rb_doc = noko_xml_document_wrap_with_init_args(klass, doc, argc, argv);\n  return rb_doc ;\n}\n```\n\nCreate a new document with `version` (defaults to “1.0”)\n\nparse(string_or_io, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/document.rb, line 48\ndef parse(string_or_io, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML)\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil\n\n  if empty_doc?(string_or_io)\n    if options.strict?\n      raise Nokogiri::XML::SyntaxError, \"Empty document\"\n    else\n      return encoding ? new.tap { |i| i.encoding = encoding } : new\n    end\n  end\n\n  doc = if string_or_io.respond_to?(:read)\n    if string_or_io.is_a?(Pathname)\n      # resolve the Pathname to the file and open it as an IO object, see #2110\n      string_or_io = string_or_io.expand_path.open\n      url ||= string_or_io.path\n    end\n\n    read_io(string_or_io, url, encoding, options.to_i)\n  else\n    # read_memory pukes on empty docs\n    read_memory(string_or_io, url, encoding, options.to_i)\n  end\n\n  # do xinclude processing\n  doc.do_xinclude(options) if options.xinclude?\n\n  doc\nend\n```\n\nParse an [`XML`](../xml) file.\n\n`string_or_io` may be a String, or any object that responds to *read* and *close* such as an IO, or StringIO.\n\n`url` (optional) is the URI where this document is located.\n\n`encoding` (optional) is the encoding that should be used when processing the document.\n\n`options` (optional) is a configuration object that sets options during parsing, such as Nokogiri::XML::ParseOptions::RECOVER. See the [`Nokogiri::XML::ParseOptions`](parseoptions) for more information.\n\n`block` (optional) is passed a configuration object on which parse options may be set.\n\nBy default, [`Nokogiri`](../../nokogiri) treats documents as untrusted, and so does not attempt to load DTDs or access the network. See [`Nokogiri::XML::ParseOptions`](parseoptions) for a complete list of options; and that module’s DEFAULT_XML constant for what’s set (and not set) by default.\n\n[`Nokogiri.XML()`](../../nokogiri#method-c-XML) is a convenience method which will call this method.\n\nread_io(io, url, encoding, options) Show source\n\n``` c\nstatic VALUE\nread_io(VALUE klass,\n        VALUE io,\n        VALUE url,\n        VALUE encoding,\n        VALUE options)\n{\n  const char *c_url    = NIL_P(url)      ? NULL : StringValueCStr(url);\n  const char *c_enc    = NIL_P(encoding) ? NULL : StringValueCStr(encoding);\n  VALUE error_list      = rb_ary_new();\n  VALUE document;\n  xmlDocPtr doc;\n\n  xmlResetLastError();\n  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);\n\n  doc = xmlReadIO(\n          (xmlInputReadCallback)noko_io_read,\n          (xmlInputCloseCallback)noko_io_close,\n          (void *)io,\n          c_url,\n          c_enc,\n          (int)NUM2INT(options)\n        );\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  if (doc == NULL) {\n    xmlErrorPtr error;\n\n    xmlFreeDoc(doc);\n\n    error = xmlGetLastError();\n    if (error) {\n      rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  document = noko_xml_document_wrap(klass, doc);\n  rb_iv_set(document, \"@errors\", error_list);\n  return document;\n}\n```\n\nCreate a new document from an IO object\n\nread_memory(string, url, encoding, options) Show source\n\n``` c\nstatic VALUE\nread_memory(VALUE klass,\n            VALUE string,\n            VALUE url,\n            VALUE encoding,\n            VALUE options)\n{\n  const char *c_buffer = StringValuePtr(string);\n  const char *c_url    = NIL_P(url)      ? NULL : StringValueCStr(url);\n  const char *c_enc    = NIL_P(encoding) ? NULL : StringValueCStr(encoding);\n  int len               = (int)RSTRING_LEN(string);\n  VALUE error_list      = rb_ary_new();\n  VALUE document;\n  xmlDocPtr doc;\n\n  xmlResetLastError();\n  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);\n  doc = xmlReadMemory(c_buffer, len, c_url, c_enc, (int)NUM2INT(options));\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  if (doc == NULL) {\n    xmlErrorPtr error;\n\n    xmlFreeDoc(doc);\n\n    error = xmlGetLastError();\n    if (error) {\n      rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  document = noko_xml_document_wrap(klass, doc);\n  rb_iv_set(document, \"@errors\", error_list);\n  return document;\n}\n```\n\nCreate a new document from a String\n\nwrap(java_document) → Nokogiri::XML::Document Show source\n\n``` c\n# File lib/nokogiri/xml/document.rb, line 91\n      \n```\n\n⚠ This method is only available when running JRuby.\n\nCreate a [`Document`](document) using an existing Java DOM document object.\n\nThe returned [`Document`](document) shares the same underlying data structure as the Java object, so changes in one are reflected in the other.\n\nParameters\n\n- ‘java_document\\` (Java::OrgW3cDom::Document) (The class \\`Java::OrgW3cDom::Document\\` is also accessible as \\`org.w3c.dom.Document\\`.)\n\nReturns  \n[`Nokogiri::XML::Document`](document)\n\nSee also \\#to_java\n\n### Public Instance Methods\n\ncanonicalize(mode=XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false) Show source\n\ncanonicalize { \\|obj, parent\\| ... }\n\n``` c\nstatic VALUE\nrb_xml_document_canonicalize(int argc, VALUE *argv, VALUE self)\n{\n  VALUE rb_mode;\n  VALUE rb_namespaces;\n  VALUE rb_comments_p;\n  int c_mode = 0;\n  xmlChar **c_namespaces;\n\n  xmlDocPtr c_doc;\n  xmlOutputBufferPtr c_obuf;\n  xmlC14NIsVisibleCallback c_callback_wrapper = NULL;\n  void *rb_callback = NULL;\n\n  VALUE rb_cStringIO;\n  VALUE rb_io;\n\n  rb_scan_args(argc, argv, \"03\", &rb_mode, &rb_namespaces, &rb_comments_p);\n  if (!NIL_P(rb_mode)) {\n    Check_Type(rb_mode, T_FIXNUM);\n    c_mode = NUM2INT(rb_mode);\n  }\n  if (!NIL_P(rb_namespaces)) {\n    Check_Type(rb_namespaces, T_ARRAY);\n    if (c_mode == XML_C14N_1_0 || c_mode == XML_C14N_1_1) {\n      rb_raise(rb_eRuntimeError, \"This canonicalizer does not support this operation\");\n    }\n  }\n\n  Data_Get_Struct(self, xmlDoc, c_doc);\n\n  rb_cStringIO = rb_const_get_at(rb_cObject, rb_intern(\"StringIO\"));\n  rb_io = rb_class_new_instance(0, 0, rb_cStringIO);\n  c_obuf = xmlAllocOutputBuffer(NULL);\n\n  c_obuf->writecallback = (xmlOutputWriteCallback)noko_io_write;\n  c_obuf->closecallback = (xmlOutputCloseCallback)noko_io_close;\n  c_obuf->context = (void *)rb_io;\n\n  if (rb_block_given_p()) {\n    c_callback_wrapper = block_caller;\n    rb_callback = (void *)rb_block_proc();\n  }\n\n  if (NIL_P(rb_namespaces)) {\n    c_namespaces = NULL;\n  } else {\n    long ns_len = RARRAY_LEN(rb_namespaces);\n    c_namespaces = ruby_xcalloc((size_t)ns_len + 1, sizeof(xmlChar *));\n    for (int j = 0 ; j < ns_len ; j++) {\n      VALUE entry = rb_ary_entry(rb_namespaces, j);\n      c_namespaces[j] = (xmlChar *)StringValueCStr(entry);\n    }\n  }\n\n  xmlC14NExecute(c_doc, c_callback_wrapper, rb_callback,\n                 c_mode,\n                 c_namespaces,\n                 (int)RTEST(rb_comments_p),\n                 c_obuf);\n\n  ruby_xfree(c_namespaces);\n  xmlOutputBufferClose(c_obuf);\n\n  return rb_funcall(rb_io, rb_intern(\"string\"), 0);\n}\n```\n\nCanonicalize a document and return the results. Takes an optional block that takes two parameters: the `obj` and that node’s `parent`. The `obj` will be either a [`Nokogiri::XML::Node`](node), or a [`Nokogiri::XML::Namespace`](namespace) The block must return a non-nil, non-false value if the `obj` passed in should be included in the canonicalized document.\n\ncreate_entity(name, type, external_id, system_id, content) Show source\n\n``` c\nstatic VALUE\ncreate_entity(int argc, VALUE *argv, VALUE self)\n{\n  VALUE name;\n  VALUE type;\n  VALUE external_id;\n  VALUE system_id;\n  VALUE content;\n  xmlEntityPtr ptr;\n  xmlDocPtr doc ;\n\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  rb_scan_args(argc, argv, \"14\", &name, &type, &external_id, &system_id,\n               &content);\n\n  xmlResetLastError();\n  ptr = xmlAddDocEntity(\n          doc,\n          (xmlChar *)(NIL_P(name)        ? NULL                        : StringValueCStr(name)),\n          (int)(NIL_P(type)        ? XML_INTERNAL_GENERAL_ENTITY : NUM2INT(type)),\n          (xmlChar *)(NIL_P(external_id) ? NULL                        : StringValueCStr(external_id)),\n          (xmlChar *)(NIL_P(system_id)   ? NULL                        : StringValueCStr(system_id)),\n          (xmlChar *)(NIL_P(content)     ? NULL                        : StringValueCStr(content))\n        );\n\n  if (NULL == ptr) {\n    xmlErrorPtr error = xmlGetLastError();\n    if (error) {\n      rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not create entity\");\n    }\n\n    return Qnil;\n  }\n\n  return noko_xml_node_wrap(cNokogiriXmlEntityDecl, (xmlNodePtr)ptr);\n}\n```\n\nCreate a new entity named `name`.\n\n`type` is an integer representing the type of entity to be created, and it defaults to Nokogiri::XML::EntityDecl::INTERNAL_GENERAL. See the constants on [`Nokogiri::XML::EntityDecl`](entitydecl) for more information.\n\n`external_id`, `system_id`, and `content` set the External ID, System ID, and content respectively. All of these parameters are optional.\n\ndup Show source\n\n``` c\nstatic VALUE\nduplicate_document(int argc, VALUE *argv, VALUE self)\n{\n  xmlDocPtr doc, dup;\n  VALUE copy;\n  VALUE level;\n\n  if (rb_scan_args(argc, argv, \"01\", &level) == 0) {\n    level = INT2NUM((long)1);\n  }\n\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  dup = xmlCopyDoc(doc, (int)NUM2INT(level));\n\n  if (dup == NULL) { return Qnil; }\n\n  dup->type = doc->type;\n  copy = noko_xml_document_wrap(rb_obj_class(self), dup);\n  rb_iv_set(copy, \"@errors\", rb_iv_get(self, \"@errors\"));\n  return copy ;\n}\n```\n\nCopy this [`Document`](document). An optional depth may be passed in, but it defaults to a deep copy. 0 is a shallow copy, 1 is a deep copy.\n\nencoding Show source\n\n``` c\nstatic VALUE\nencoding(VALUE self)\n{\n  xmlDocPtr doc;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  if (!doc->encoding) { return Qnil; }\n  return NOKOGIRI_STR_NEW2(doc->encoding);\n}\n```\n\nGet the encoding for this [`Document`](document)\n\nencoding= encoding Show source\n\n``` c\nstatic VALUE\nset_encoding(VALUE self, VALUE encoding)\n{\n  xmlDocPtr doc;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  if (doc->encoding) {\n    xmlFree(DISCARD_CONST_QUAL_XMLCHAR(doc->encoding));\n  }\n\n  doc->encoding = xmlStrdup((xmlChar *)StringValueCStr(encoding));\n\n  return encoding;\n}\n```\n\nSet the encoding string for this [`Document`](document)\n\nremove_namespaces! Show source\n\n``` c\nstatic VALUE\nremove_namespaces_bang(VALUE self)\n{\n  xmlDocPtr doc ;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  recursively_remove_namespaces_from_node((xmlNodePtr)doc);\n  return self;\n}\n```\n\nRemove all namespaces from all nodes in the document.\n\nThis could be useful for developers who either don’t understand namespaces or don’t care about them.\n\nThe following example shows a use case, and you can decide for yourself whether this is a good thing or not:\n\n``` ruby\ndoc = Nokogiri::XML <<-EOXML\n   <root>\n     <car xmlns:part=\"http://general-motors.com/\">\n       <part:tire>Michelin Model XGV</part:tire>\n     </car>\n     <bicycle xmlns:part=\"http://schwinn.com/\">\n       <part:tire>I'm a bicycle tire!</part:tire>\n     </bicycle>\n   </root>\n   EOXML\n\ndoc.xpath(\"//tire\").to_s # => \"\"\ndoc.xpath(\"//part:tire\", \"part\" => \"http://general-motors.com/\").to_s # => \"<part:tire>Michelin Model XGV</part:tire>\"\ndoc.xpath(\"//part:tire\", \"part\" => \"http://schwinn.com/\").to_s # => \"<part:tire>I'm a bicycle tire!</part:tire>\"\n\ndoc.remove_namespaces!\n\ndoc.xpath(\"//tire\").to_s # => \"<tire>Michelin Model XGV</tire><tire>I'm a bicycle tire!</tire>\"\ndoc.xpath(\"//part:tire\", \"part\" => \"http://general-motors.com/\").to_s # => \"\"\ndoc.xpath(\"//part:tire\", \"part\" => \"http://schwinn.com/\").to_s # => \"\"\n```\n\nFor more information on why this probably is **not** a good thing in general, please direct your browser to [tenderlovemaking.com/2009/04/23/namespaces-in-xml.html](http://tenderlovemaking.com/2009/04/23/namespaces-in-xml.html)\n\nroot Show source\n\n``` c\nstatic VALUE\nrb_xml_document_root(VALUE self)\n{\n  xmlDocPtr c_document;\n  xmlNodePtr c_root;\n\n  Data_Get_Struct(self, xmlDoc, c_document);\n\n  c_root = xmlDocGetRootElement(c_document);\n  if (!c_root) {\n    return Qnil;\n  }\n\n  return noko_xml_node_wrap(Qnil, c_root) ;\n}\n```\n\nGet the root node for this document.\n\nroot= Show source\n\n``` c\nstatic VALUE\nrb_xml_document_root_set(VALUE self, VALUE rb_new_root)\n{\n  xmlDocPtr c_document;\n  xmlNodePtr c_new_root = NULL, c_current_root;\n\n  Data_Get_Struct(self, xmlDoc, c_document);\n\n  c_current_root = xmlDocGetRootElement(c_document);\n  if (c_current_root) {\n    xmlUnlinkNode(c_current_root);\n    noko_xml_document_pin_node(c_current_root);\n  }\n\n  if (!NIL_P(rb_new_root)) {\n    if (!rb_obj_is_kind_of(rb_new_root, cNokogiriXmlNode)) {\n      rb_raise(rb_eArgError,\n               \"expected Nokogiri::XML::Node but received %\"PRIsVALUE,\n               rb_obj_class(rb_new_root));\n    }\n\n    Noko_Node_Get_Struct(rb_new_root, xmlNode, c_new_root);\n\n    /* If the new root's document is not the same as the current document,\n     * then we need to dup the node in to this document. */\n    if (c_new_root->doc != c_document) {\n      c_new_root = xmlDocCopyNode(c_new_root, c_document, 1);\n      if (!c_new_root) {\n        rb_raise(rb_eRuntimeError, \"Could not reparent node (xmlDocCopyNode)\");\n      }\n    }\n  }\n\n  xmlDocSetRootElement(c_document, c_new_root);\n\n  return rb_new_root;\n}\n```\n\nSet the root element on this document\n\nto_java() → Java::OrgW3cDom::Document Show source\n\n``` c\n# File lib/nokogiri/xml/document.rb, line 109\n      \n```\n\n⚠ This method is only available when running JRuby.\n\nReturns the underlying Java DOM document object for this document.\n\nThe returned Java object shares the same underlying data structure as this document, so changes in one are reflected in the other.\n\nReturns  \nJava::OrgW3cDom::Document (The class ‘Java::OrgW3cDom::Document\\` is also accessible as \\`org.w3c.dom.Document\\`.)\n\nSee also [`Document.wrap`](document#method-c-wrap)\n\nurl Show source\n\n``` c\nstatic VALUE\nurl(VALUE self)\n{\n  xmlDocPtr doc;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  if (doc->URL) { return NOKOGIRI_STR_NEW2(doc->URL); }\n\n  return Qnil;\n}\n```\n\nGet the url name for this document.\n\nversion Show source\n\n``` c\nstatic VALUE\nversion(VALUE self)\n{\n  xmlDocPtr doc;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  if (!doc->version) { return Qnil; }\n  return NOKOGIRI_STR_NEW2(doc->version);\n}\n```\n\nGet the [`XML`](../xml) version for this [`Document`](document)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Document.html](https://nokogiri.org/rdoc/Nokogiri/XML/Document.html)"
- name: Nokogiri::XML::Document#canonicalize
  id: nokogiri/xml/document#method-i-canonicalize
  summary: Canonicalize a document and return the results
  belongs_to: Nokogiri::XML::Document
  description: |-
    canonicalize(mode=XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false) Show source

    canonicalize { \|obj, parent\| ... }

    ``` c
    static VALUE
    rb_xml_document_canonicalize(int argc, VALUE *argv, VALUE self)
    {
      VALUE rb_mode;
      VALUE rb_namespaces;
      VALUE rb_comments_p;
      int c_mode = 0;
      xmlChar **c_namespaces;

      xmlDocPtr c_doc;
      xmlOutputBufferPtr c_obuf;
      xmlC14NIsVisibleCallback c_callback_wrapper = NULL;
      void *rb_callback = NULL;

      VALUE rb_cStringIO;
      VALUE rb_io;

      rb_scan_args(argc, argv, "03", &rb_mode, &rb_namespaces, &rb_comments_p);
      if (!NIL_P(rb_mode)) {
        Check_Type(rb_mode, T_FIXNUM);
        c_mode = NUM2INT(rb_mode);
      }
      if (!NIL_P(rb_namespaces)) {
        Check_Type(rb_namespaces, T_ARRAY);
        if (c_mode == XML_C14N_1_0 || c_mode == XML_C14N_1_1) {
          rb_raise(rb_eRuntimeError, "This canonicalizer does not support this operation");
        }
      }

      Data_Get_Struct(self, xmlDoc, c_doc);

      rb_cStringIO = rb_const_get_at(rb_cObject, rb_intern("StringIO"));
      rb_io = rb_class_new_instance(0, 0, rb_cStringIO);
      c_obuf = xmlAllocOutputBuffer(NULL);

      c_obuf->writecallback = (xmlOutputWriteCallback)noko_io_write;
      c_obuf->closecallback = (xmlOutputCloseCallback)noko_io_close;
      c_obuf->context = (void *)rb_io;

      if (rb_block_given_p()) {
        c_callback_wrapper = block_caller;
        rb_callback = (void *)rb_block_proc();
      }

      if (NIL_P(rb_namespaces)) {
        c_namespaces = NULL;
      } else {
        long ns_len = RARRAY_LEN(rb_namespaces);
        c_namespaces = ruby_xcalloc((size_t)ns_len + 1, sizeof(xmlChar *));
        for (int j = 0 ; j < ns_len ; j++) {
          VALUE entry = rb_ary_entry(rb_namespaces, j);
          c_namespaces[j] = (xmlChar *)StringValueCStr(entry);
        }
      }

      xmlC14NExecute(c_doc, c_callback_wrapper, rb_callback,
                     c_mode,
                     c_namespaces,
                     (int)RTEST(rb_comments_p),
                     c_obuf);

      ruby_xfree(c_namespaces);
      xmlOutputBufferClose(c_obuf);

      return rb_funcall(rb_io, rb_intern("string"), 0);
    }
    ```

    Canonicalize a document and return the results. Takes an optional block that takes two parameters: the `obj` and that node’s `parent`. The `obj` will be either a [`Nokogiri::XML::Node`](node), or a [`Nokogiri::XML::Namespace`](namespace) The block must return a non-nil, non-false value if the `obj` passed in should be included in the canonicalized document.
- name: Nokogiri::XML::Document#create_entity
  id: nokogiri/xml/document#method-i-create_entity
  summary: Create a new entity named name
  belongs_to: Nokogiri::XML::Document
  description: |-
    create_entity(name, type, external_id, system_id, content) Show source

    ``` c
    static VALUE
    create_entity(int argc, VALUE *argv, VALUE self)
    {
      VALUE name;
      VALUE type;
      VALUE external_id;
      VALUE system_id;
      VALUE content;
      xmlEntityPtr ptr;
      xmlDocPtr doc ;

      Data_Get_Struct(self, xmlDoc, doc);

      rb_scan_args(argc, argv, "14", &name, &type, &external_id, &system_id,
                   &content);

      xmlResetLastError();
      ptr = xmlAddDocEntity(
              doc,
              (xmlChar *)(NIL_P(name)        ? NULL                        : StringValueCStr(name)),
              (int)(NIL_P(type)        ? XML_INTERNAL_GENERAL_ENTITY : NUM2INT(type)),
              (xmlChar *)(NIL_P(external_id) ? NULL                        : StringValueCStr(external_id)),
              (xmlChar *)(NIL_P(system_id)   ? NULL                        : StringValueCStr(system_id)),
              (xmlChar *)(NIL_P(content)     ? NULL                        : StringValueCStr(content))
            );

      if (NULL == ptr) {
        xmlErrorPtr error = xmlGetLastError();
        if (error) {
          rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));
        } else {
          rb_raise(rb_eRuntimeError, "Could not create entity");
        }

        return Qnil;
      }

      return noko_xml_node_wrap(cNokogiriXmlEntityDecl, (xmlNodePtr)ptr);
    }
    ```

    Create a new entity named `name`.

    `type` is an integer representing the type of entity to be created, and it defaults to Nokogiri::XML::EntityDecl::INTERNAL_GENERAL. See the constants on [`Nokogiri::XML::EntityDecl`](entitydecl) for more information.

    `external_id`, `system_id`, and `content` set the External ID, System ID, and content respectively. All of these parameters are optional.
- name: Nokogiri::XML::Document#dup
  id: nokogiri/xml/document#method-i-dup
  summary: Copy this Document
  belongs_to: Nokogiri::XML::Document
  description: |-
    dup Show source

    ``` c
    static VALUE
    duplicate_document(int argc, VALUE *argv, VALUE self)
    {
      xmlDocPtr doc, dup;
      VALUE copy;
      VALUE level;

      if (rb_scan_args(argc, argv, "01", &level) == 0) {
        level = INT2NUM((long)1);
      }

      Data_Get_Struct(self, xmlDoc, doc);

      dup = xmlCopyDoc(doc, (int)NUM2INT(level));

      if (dup == NULL) { return Qnil; }

      dup->type = doc->type;
      copy = noko_xml_document_wrap(rb_obj_class(self), dup);
      rb_iv_set(copy, "@errors", rb_iv_get(self, "@errors"));
      return copy ;
    }
    ```

    Copy this [`Document`](document). An optional depth may be passed in, but it defaults to a deep copy. 0 is a shallow copy, 1 is a deep copy.
- name: Nokogiri::XML::Document#encoding
  id: nokogiri/xml/document#method-i-encoding
  summary: null
  belongs_to: Nokogiri::XML::Document
  description: |-
    encoding Show source

    ``` c
    static VALUE
    encoding(VALUE self)
    {
      xmlDocPtr doc;
      Data_Get_Struct(self, xmlDoc, doc);

      if (!doc->encoding) { return Qnil; }
      return NOKOGIRI_STR_NEW2(doc->encoding);
    }
    ```

    Get the encoding for this [`Document`](document)
- name: Nokogiri::XML::Document#encoding=
  id: nokogiri/xml/document#method-i-encoding-3D
  summary: null
  belongs_to: Nokogiri::XML::Document
  description: |-
    encoding= encoding Show source

    ``` c
    static VALUE
    set_encoding(VALUE self, VALUE encoding)
    {
      xmlDocPtr doc;
      Data_Get_Struct(self, xmlDoc, doc);

      if (doc->encoding) {
        xmlFree(DISCARD_CONST_QUAL_XMLCHAR(doc->encoding));
      }

      doc->encoding = xmlStrdup((xmlChar *)StringValueCStr(encoding));

      return encoding;
    }
    ```

    Set the encoding string for this [`Document`](document)
- name: Nokogiri::XML::Document#errors
  id: nokogiri/xml/document#attribute-i-errors
  summary: The errors found while parsing a document
  belongs_to: Nokogiri::XML::Document
  description: |-
    errors \[RW\]

    The errors found while parsing a document.

    Returns

    Array\<Nokogiri::XML::SyntaxError\>
- name: Nokogiri::XML::Document#namespace_inheritance
  id: nokogiri/xml/document#attribute-i-namespace_inheritance
  summary: When ‘true`, reparented elements without a namespace will inherit their new parent’s namespace (if one exists)
  belongs_to: Nokogiri::XML::Document
  description: |-
    namespace_inheritance \[RW\]

    When ‘true\`, reparented elements without a namespace will inherit their new parent’s namespace (if one exists). Defaults to ‘false\`.

    Returns

    Boolean

    **Example:** Default behavior of namespace inheritance

    ``` ruby
    xml = <<~EOF
            <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
              <foo:parent>
              </foo:parent>
            </root>
          EOF
    doc = Nokogiri::XML(xml)
    parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
    parent.add_child("<child></child>")
    doc.to_xml
    # => <?xml version="1.0"?>
    #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
    #      <foo:parent>
    #        <child/>
    #      </foo:parent>
    #    </root>
    ```

    **Example:** Setting namespace inheritance to ‘true\`

    ``` ruby
    xml = <<~EOF
            <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
              <foo:parent>
              </foo:parent>
            </root>
          EOF
    doc = Nokogiri::XML(xml)
    doc.namespace_inheritance = true
    parent = doc.at_xpath("//foo:parent", "foo" => "http://nokogiri.org/default_ns/test/foo")
    parent.add_child("<child></child>")
    doc.to_xml
    # => <?xml version="1.0"?>
    #    <root xmlns:foo="http://nokogiri.org/default_ns/test/foo">
    #      <foo:parent>
    #        <foo:child/>
    #      </foo:parent>
    #    </root>
    ```

    Since v1.12.4

    ### Public Class Methods
- name: Nokogiri::XML::Document#remove_namespaces!
  id: nokogiri/xml/document#method-i-remove_namespaces-21
  summary: Remove all namespaces from all nodes in the document
  belongs_to: Nokogiri::XML::Document
  description: |-
    remove_namespaces! Show source

    ``` c
    static VALUE
    remove_namespaces_bang(VALUE self)
    {
      xmlDocPtr doc ;
      Data_Get_Struct(self, xmlDoc, doc);

      recursively_remove_namespaces_from_node((xmlNodePtr)doc);
      return self;
    }
    ```

    Remove all namespaces from all nodes in the document.

    This could be useful for developers who either don’t understand namespaces or don’t care about them.

    The following example shows a use case, and you can decide for yourself whether this is a good thing or not:

    ``` ruby
    doc = Nokogiri::XML <<-EOXML
       <root>
         <car xmlns:part="http://general-motors.com/">
           <part:tire>Michelin Model XGV</part:tire>
         </car>
         <bicycle xmlns:part="http://schwinn.com/">
           <part:tire>I'm a bicycle tire!</part:tire>
         </bicycle>
       </root>
       EOXML

    doc.xpath("//tire").to_s # => ""
    doc.xpath("//part:tire", "part" => "http://general-motors.com/").to_s # => "<part:tire>Michelin Model XGV</part:tire>"
    doc.xpath("//part:tire", "part" => "http://schwinn.com/").to_s # => "<part:tire>I'm a bicycle tire!</part:tire>"

    doc.remove_namespaces!

    doc.xpath("//tire").to_s # => "<tire>Michelin Model XGV</tire><tire>I'm a bicycle tire!</tire>"
    doc.xpath("//part:tire", "part" => "http://general-motors.com/").to_s # => ""
    doc.xpath("//part:tire", "part" => "http://schwinn.com/").to_s # => ""
    ```

    For more information on why this probably is **not** a good thing in general, please direct your browser to [tenderlovemaking.com/2009/04/23/namespaces-in-xml.html](http://tenderlovemaking.com/2009/04/23/namespaces-in-xml.html)
- name: Nokogiri::XML::Document#root
  id: nokogiri/xml/document#method-i-root
  summary: Get the root node for this document
  belongs_to: Nokogiri::XML::Document
  description: |-
    root Show source

    ``` c
    static VALUE
    rb_xml_document_root(VALUE self)
    {
      xmlDocPtr c_document;
      xmlNodePtr c_root;

      Data_Get_Struct(self, xmlDoc, c_document);

      c_root = xmlDocGetRootElement(c_document);
      if (!c_root) {
        return Qnil;
      }

      return noko_xml_node_wrap(Qnil, c_root) ;
    }
    ```

    Get the root node for this document.
- name: Nokogiri::XML::Document#root=
  id: nokogiri/xml/document#method-i-root-3D
  summary: null
  belongs_to: Nokogiri::XML::Document
  description: |-
    root= Show source

    ``` c
    static VALUE
    rb_xml_document_root_set(VALUE self, VALUE rb_new_root)
    {
      xmlDocPtr c_document;
      xmlNodePtr c_new_root = NULL, c_current_root;

      Data_Get_Struct(self, xmlDoc, c_document);

      c_current_root = xmlDocGetRootElement(c_document);
      if (c_current_root) {
        xmlUnlinkNode(c_current_root);
        noko_xml_document_pin_node(c_current_root);
      }

      if (!NIL_P(rb_new_root)) {
        if (!rb_obj_is_kind_of(rb_new_root, cNokogiriXmlNode)) {
          rb_raise(rb_eArgError,
                   "expected Nokogiri::XML::Node but received %"PRIsVALUE,
                   rb_obj_class(rb_new_root));
        }

        Noko_Node_Get_Struct(rb_new_root, xmlNode, c_new_root);

        /* If the new root's document is not the same as the current document,
         * then we need to dup the node in to this document. */
        if (c_new_root->doc != c_document) {
          c_new_root = xmlDocCopyNode(c_new_root, c_document, 1);
          if (!c_new_root) {
            rb_raise(rb_eRuntimeError, "Could not reparent node (xmlDocCopyNode)");
          }
        }
      }

      xmlDocSetRootElement(c_document, c_new_root);

      return rb_new_root;
    }
    ```

    Set the root element on this document
- name: Nokogiri::XML::Document#to_java
  id: nokogiri/xml/document#method-i-to_java
  summary: ⚠ This method is only available when running JRuby
  belongs_to: Nokogiri::XML::Document
  description: "to_java() → Java::OrgW3cDom::Document Show source\n\n``` c\n# File lib/nokogiri/xml/document.rb, line 109\n      \n```\n\n⚠ This method is only available when running JRuby.\n\nReturns the underlying Java DOM document object for this document.\n\nThe returned Java object shares the same underlying data structure as this document, so changes in one are reflected in the other.\n\nReturns\n\nJava::OrgW3cDom::Document (The class ‘Java::OrgW3cDom::Document\\` is also accessible as \\`org.w3c.dom.Document\\`.)\n\nSee also [`Document.wrap`](document#method-c-wrap)"
- name: Nokogiri::XML::Document#url
  id: nokogiri/xml/document#method-i-url
  summary: Get the url name for this document
  belongs_to: Nokogiri::XML::Document
  description: "url Show source\n\n``` c\nstatic VALUE\nurl(VALUE self)\n{\n  xmlDocPtr doc;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  if (doc->URL) { return NOKOGIRI_STR_NEW2(doc->URL); }\n\n  return Qnil;\n}\n```\n\nGet the url name for this document.\n\nversion Show source\n\n``` c\nstatic VALUE\nversion(VALUE self)\n{\n  xmlDocPtr doc;\n  Data_Get_Struct(self, xmlDoc, doc);\n\n  if (!doc->version) { return Qnil; }\n  return NOKOGIRI_STR_NEW2(doc->version);\n}\n```\n\nGet the [`XML`](../xml) version for this [`Document`](document)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Document.html](https://nokogiri.org/rdoc/Nokogiri/XML/Document.html)"
- name: Nokogiri::XML::Document::new
  id: nokogiri/xml/document#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::Document
  description: |-
    new(version = default) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr doc;
      VALUE version, rest, rb_doc ;

      rb_scan_args(argc, argv, "0*", &rest);
      version = rb_ary_entry(rest, (long)0);
      if (NIL_P(version)) { version = rb_str_new2("1.0"); }

      doc = xmlNewDoc((xmlChar *)StringValueCStr(version));
      rb_doc = noko_xml_document_wrap_with_init_args(klass, doc, argc, argv);
      return rb_doc ;
    }
    ```

    Create a new document with `version` (defaults to “1.0”)
- name: Nokogiri::XML::Document::parse
  id: nokogiri/xml/document#method-c-parse
  summary: Parse an XML file
  belongs_to: Nokogiri::XML::Document
  description: |-
    parse (string_or_io, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML) { \|options\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/document.rb, line 48
    def parse(string_or_io, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML)
      options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
      yield options if block_given?

      url ||= string_or_io.respond_to?(:path) ? string_or_io.path : nil

      if empty_doc?(string_or_io)
        if options.strict?
          raise Nokogiri::XML::SyntaxError, "Empty document"
        else
          return encoding ? new.tap { |i| i.encoding = encoding } : new
        end
      end

      doc = if string_or_io.respond_to?(:read)
        if string_or_io.is_a?(Pathname)
          # resolve the Pathname to the file and open it as an IO object, see #2110
          string_or_io = string_or_io.expand_path.open
          url ||= string_or_io.path
        end

        read_io(string_or_io, url, encoding, options.to_i)
      else
        # read_memory pukes on empty docs
        read_memory(string_or_io, url, encoding, options.to_i)
      end

      # do xinclude processing
      doc.do_xinclude(options) if options.xinclude?

      doc
    end
    ```

    Parse an [`XML`](../xml) file.

    `string_or_io` may be a String, or any object that responds to *read* and *close* such as an IO, or StringIO.

    `url` (optional) is the URI where this document is located.

    `encoding` (optional) is the encoding that should be used when processing the document.

    `options` (optional) is a configuration object that sets options during parsing, such as Nokogiri::XML::ParseOptions::RECOVER. See the [`Nokogiri::XML::ParseOptions`](parseoptions) for more information.

    `block` (optional) is passed a configuration object on which parse options may be set.

    By default, [`Nokogiri`](../../nokogiri) treats documents as untrusted, and so does not attempt to load DTDs or access the network. See [`Nokogiri::XML::ParseOptions`](parseoptions) for a complete list of options; and that module’s DEFAULT_XML constant for what’s set (and not set) by default.

    [`Nokogiri.XML()`](../../nokogiri#method-c-XML) is a convenience method which will call this method.
- name: Nokogiri::XML::Document::read_io
  id: nokogiri/xml/document#method-c-read_io
  summary: null
  belongs_to: Nokogiri::XML::Document
  description: |-
    read_io(io, url, encoding, options) Show source

    ``` c
    static VALUE
    read_io(VALUE klass,
            VALUE io,
            VALUE url,
            VALUE encoding,
            VALUE options)
    {
      const char *c_url    = NIL_P(url)      ? NULL : StringValueCStr(url);
      const char *c_enc    = NIL_P(encoding) ? NULL : StringValueCStr(encoding);
      VALUE error_list      = rb_ary_new();
      VALUE document;
      xmlDocPtr doc;

      xmlResetLastError();
      xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

      doc = xmlReadIO(
              (xmlInputReadCallback)noko_io_read,
              (xmlInputCloseCallback)noko_io_close,
              (void *)io,
              c_url,
              c_enc,
              (int)NUM2INT(options)
            );
      xmlSetStructuredErrorFunc(NULL, NULL);

      if (doc == NULL) {
        xmlErrorPtr error;

        xmlFreeDoc(doc);

        error = xmlGetLastError();
        if (error) {
          rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));
        } else {
          rb_raise(rb_eRuntimeError, "Could not parse document");
        }

        return Qnil;
      }

      document = noko_xml_document_wrap(klass, doc);
      rb_iv_set(document, "@errors", error_list);
      return document;
    }
    ```

    Create a new document from an IO object
- name: Nokogiri::XML::Document::read_memory
  id: nokogiri/xml/document#method-c-read_memory
  summary: null
  belongs_to: Nokogiri::XML::Document
  description: |-
    read_memory(string, url, encoding, options) Show source

    ``` c
    static VALUE
    read_memory(VALUE klass,
                VALUE string,
                VALUE url,
                VALUE encoding,
                VALUE options)
    {
      const char *c_buffer = StringValuePtr(string);
      const char *c_url    = NIL_P(url)      ? NULL : StringValueCStr(url);
      const char *c_enc    = NIL_P(encoding) ? NULL : StringValueCStr(encoding);
      int len               = (int)RSTRING_LEN(string);
      VALUE error_list      = rb_ary_new();
      VALUE document;
      xmlDocPtr doc;

      xmlResetLastError();
      xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
      doc = xmlReadMemory(c_buffer, len, c_url, c_enc, (int)NUM2INT(options));
      xmlSetStructuredErrorFunc(NULL, NULL);

      if (doc == NULL) {
        xmlErrorPtr error;

        xmlFreeDoc(doc);

        error = xmlGetLastError();
        if (error) {
          rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));
        } else {
          rb_raise(rb_eRuntimeError, "Could not parse document");
        }

        return Qnil;
      }

      document = noko_xml_document_wrap(klass, doc);
      rb_iv_set(document, "@errors", error_list);
      return document;
    }
    ```

    Create a new document from a String
- name: Nokogiri::XML::Document::wrap
  id: nokogiri/xml/document#method-c-wrap
  summary: ⚠ This method is only available when running JRuby
  belongs_to: Nokogiri::XML::Document
  description: "wrap(java_document) → Nokogiri::XML::Document Show source\n\n``` c\n# File lib/nokogiri/xml/document.rb, line 91\n      \n```\n\n⚠ This method is only available when running JRuby.\n\nCreate a [`Document`](document) using an existing Java DOM document object.\n\nThe returned [`Document`](document) shares the same underlying data structure as the Java object, so changes in one are reflected in the other.\n\nParameters\n\n- ‘java_document\\` (Java::OrgW3cDom::Document) (The class \\`Java::OrgW3cDom::Document\\` is also accessible as \\`org.w3c.dom.Document\\`.)\n\nReturns\n\n[`Nokogiri::XML::Document`](document)\n\nSee also \\#to_java\n\n### Public Instance Methods"
- name: Nokogiri::XML::DocumentFragment
  id: nokogiri/xml/documentfragment
  summary: DocumentFragment represents a DocumentFragment node in an xml document
  description: "# class Nokogiri::XML::DocumentFragment\n\nParent:  \ncNokogiriXmlNode\n\n[`DocumentFragment`](documentfragment) represents a [`DocumentFragment`](documentfragment) node in an xml document.\n\n### Public Class Methods\n\nnew(document) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  xmlNodePtr node;\n  VALUE document;\n  VALUE rest;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"1*\", &document, &rest);\n\n  Data_Get_Struct(document, xmlDoc, xml_doc);\n\n  node = xmlNewDocFragment(xml_doc->doc);\n\n  noko_xml_document_pin_node(node);\n\n  rb_node = noko_xml_node_wrap(klass, node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  return rb_node;\n}\n```\n\nCreate a new [`DocumentFragment`](documentfragment) element on the `document`\n\nnew(document, tags = nil, ctx = nil, options = ParseOptions::DEFAULT_XML) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 19\ndef initialize(document, tags = nil, ctx = nil, options = ParseOptions::DEFAULT_XML)\n  return self unless tags\n\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  children = if ctx\n    # Fix for issue#490\n    if Nokogiri.jruby?\n      # fix for issue #770\n      ctx.parse(\"<root #{namespace_declarations(ctx)}>#{tags}</root>\", options).children\n    else\n      ctx.parse(tags, options)\n    end\n  else\n    wrapper_doc = XML::Document.parse(\"<root>#{tags}</root>\", nil, nil, options)\n    self.errors = wrapper_doc.errors\n    wrapper_doc.xpath(\"/root/node()\")\n  end\n  children.each { |child| child.parent = self }\nend\n```\n\nCreate a new [`DocumentFragment`](documentfragment) from `tags`.\n\nIf `ctx` is present, it is used as a context node for the subtree created, e.g., namespaces will be resolved relative to `ctx`.\n\nparse(tags, options = ParseOptions::DEFAULT_XML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 9\ndef self.parse(tags, options = ParseOptions::DEFAULT_XML, &block)\n  new(XML::Document.new, tags, nil, options, &block)\nend\n```\n\nCreate a [`Nokogiri::XML::DocumentFragment`](documentfragment) from `tags`\n\n### Public Instance Methods\n\ncss \\*rules, \\[namespace-bindings, custom-pseudo-class\\] Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 102\ndef css(*args)\n  if children.any?\n    children.css(*args) # 'children' is a smell here\n  else\n    NodeSet.new(document)\n  end\nend\n```\n\nSearch this fragment for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:\n\nFor more information see [`Nokogiri::XML::Searchable#css`](searchable#method-i-css)\n\ndeconstruct() → Array Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 190\ndef deconstruct\n  children.to_a\nend\n```\n\nReturns the root nodes of this document fragment as an array, to use in pattern matching.\n\n💡 Note that text nodes are returned as well as elements. If you wish to operate only on root elements, you should deconstruct the array returned by `DocumentFragment#elements`.\n\n⚡ This is an experimental feature, available since v1.14.0\n\n**Example**\n\n``` ruby\nfrag = Nokogiri::HTML5.fragment(<<~HTML)\n  <div>Start</div>\n  This is a <a href=\"#jump\">shortcut</a> for you.\n  <div>End</div>\nHTML\n\nfrag.deconstruct\n# => [#(Element:0x35c { name = \"div\", children = [ #(Text \"Start\")] }),\n#     #(Text \"\\n\" + \"This is a \"),\n#     #(Element:0x370 {\n#       name = \"a\",\n#       attributes = [ #(Attr:0x384 { name = \"href\", value = \"#jump\" })],\n#       children = [ #(Text \"shortcut\")]\n#       }),\n#     #(Text \" for you.\\n\"),\n#     #(Element:0x398 { name = \"div\", children = [ #(Text \"End\")] }),\n#     #(Text \"\\n\")]\n```\n\n**Example** only the elements, not the text nodes.\n\n``` ruby\nfrag.elements.deconstruct\n# => [#(Element:0x35c { name = \"div\", children = [ #(Text \"Start\")] }),\n#     #(Element:0x370 {\n#       name = \"a\",\n#       attributes = [ #(Attr:0x384 { name = \"href\", value = \"#jump\" })],\n#       children = [ #(Text \"shortcut\")]\n#       }),\n#     #(Element:0x398 { name = \"div\", children = [ #(Text \"End\")] })]\n```\n\ndup() Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 42\ndef dup\n  new_document = document.dup\n  new_fragment = self.class.new(new_document)\n  children.each do |child|\n    child.dup(1, new_document).parent = new_fragment\n  end\n  new_fragment\nend\n```\n\nerrors() Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 136\ndef errors\n  document.errors\nend\n```\n\nA list of [`Nokogiri::XML::SyntaxError`](syntaxerror) found when parsing a document\n\nfragment(data) Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 144\ndef fragment(data)\n  document.fragment(data)\nend\n```\n\nname() Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 54\ndef name\n  \"#document-fragment\"\nend\n```\n\nreturn the name for [`DocumentFragment`](documentfragment)\n\nsearch \\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\] Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 121\ndef search(*rules)\n  rules, handler, ns, binds = extract_params(rules)\n\n  rules.inject(NodeSet.new(document)) do |set, rule|\n    set + if Searchable::LOOKS_LIKE_XPATH.match?(rule)\n      xpath(*[rule, ns, handler, binds].compact)\n    else\n      children.css(*[rule, ns, handler].compact) # 'children' is a smell here\n    end\n  end\nend\n```\n\nSearch this fragment for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.\n\nFor more information see [`Nokogiri::XML::Searchable#search`](searchable#method-i-search)\n\nserialize()\n\nAlias for: [to_s](documentfragment#method-i-to_s)\n\nto_html(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 67\ndef to_html(*args)\n  if Nokogiri.jruby?\n    options = args.first.is_a?(Hash) ? args.shift : {}\n    options[:save_with] ||= Node::SaveOptions::DEFAULT_HTML\n    args.insert(0, options)\n  end\n  children.to_html(*args)\nend\n```\n\nConvert this [`DocumentFragment`](documentfragment) to html See [`Nokogiri::XML::NodeSet#to_html`](nodeset#method-i-to_html)\n\nto_s() Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 60\ndef to_s\n  children.to_s\nend\n```\n\nConvert this [`DocumentFragment`](documentfragment) to a string\n\nAlso aliased as: [serialize](documentfragment#method-i-serialize)\n\nto_xhtml(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 79\ndef to_xhtml(*args)\n  if Nokogiri.jruby?\n    options = args.first.is_a?(Hash) ? args.shift : {}\n    options[:save_with] ||= Node::SaveOptions::DEFAULT_XHTML\n    args.insert(0, options)\n  end\n  children.to_xhtml(*args)\nend\n```\n\nConvert this [`DocumentFragment`](documentfragment) to xhtml See [`Nokogiri::XML::NodeSet#to_xhtml`](nodeset#method-i-to_xhtml)\n\nto_xml(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 91\ndef to_xml(*args)\n  children.to_xml(*args)\nend\n```\n\nConvert this [`DocumentFragment`](documentfragment) to xml See [`Nokogiri::XML::NodeSet#to_xml`](nodeset#method-i-to_xml)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/XML/DocumentFragment.html)"
- name: Nokogiri::XML::DocumentFragment#css
  id: nokogiri/xml/documentfragment#method-i-css
  summary: Search this fragment for CSS rules
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    css \*rules, \[namespace-bindings, custom-pseudo-class\] Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 102
    def css(*args)
      if children.any?
        children.css(*args) # 'children' is a smell here
      else
        NodeSet.new(document)
      end
    end
    ```

    Search this fragment for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:

    For more information see [`Nokogiri::XML::Searchable#css`](searchable#method-i-css)
- name: Nokogiri::XML::DocumentFragment#deconstruct
  id: nokogiri/xml/documentfragment#method-i-deconstruct
  summary: Returns the root nodes of this document fragment as an array, to use in pattern matching
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    deconstruct() → Array Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 190
    def deconstruct
      children.to_a
    end
    ```

    Returns the root nodes of this document fragment as an array, to use in pattern matching.

    💡 Note that text nodes are returned as well as elements. If you wish to operate only on root elements, you should deconstruct the array returned by `DocumentFragment#elements`.

    ⚡ This is an experimental feature, available since v1.14.0

    **Example**

    ``` ruby
    frag = Nokogiri::HTML5.fragment(<<~HTML)
      <div>Start</div>
      This is a <a href="#jump">shortcut</a> for you.
      <div>End</div>
    HTML

    frag.deconstruct
    # => [#(Element:0x35c { name = "div", children = [ #(Text "Start")] }),
    #     #(Text "\n" + "This is a "),
    #     #(Element:0x370 {
    #       name = "a",
    #       attributes = [ #(Attr:0x384 { name = "href", value = "#jump" })],
    #       children = [ #(Text "shortcut")]
    #       }),
    #     #(Text " for you.\n"),
    #     #(Element:0x398 { name = "div", children = [ #(Text "End")] }),
    #     #(Text "\n")]
    ```

    **Example** only the elements, not the text nodes.

    ``` ruby
    frag.elements.deconstruct
    # => [#(Element:0x35c { name = "div", children = [ #(Text "Start")] }),
    #     #(Element:0x370 {
    #       name = "a",
    #       attributes = [ #(Attr:0x384 { name = "href", value = "#jump" })],
    #       children = [ #(Text "shortcut")]
    #       }),
    #     #(Element:0x398 { name = "div", children = [ #(Text "End")] })]
    ```
- name: Nokogiri::XML::DocumentFragment#dup
  id: nokogiri/xml/documentfragment#method-i-dup
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    dup () Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 42
    def dup
      new_document = document.dup
      new_fragment = self.class.new(new_document)
      children.each do |child|
        child.dup(1, new_document).parent = new_fragment
      end
      new_fragment
    end
    ```
- name: Nokogiri::XML::DocumentFragment#errors
  id: nokogiri/xml/documentfragment#method-i-errors
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    errors () Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 136
    def errors
      document.errors
    end
    ```

    A list of [`Nokogiri::XML::SyntaxError`](syntaxerror) found when parsing a document
- name: Nokogiri::XML::DocumentFragment#fragment
  id: nokogiri/xml/documentfragment#method-i-fragment
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    fragment (data) Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 144
    def fragment(data)
      document.fragment(data)
    end
    ```
- name: Nokogiri::XML::DocumentFragment#name
  id: nokogiri/xml/documentfragment#method-i-name
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    name () Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 54
    def name
      "#document-fragment"
    end
    ```

    return the name for [`DocumentFragment`](documentfragment)
- name: Nokogiri::XML::DocumentFragment#search
  id: nokogiri/xml/documentfragment#method-i-search
  summary: Search this fragment for paths
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    search \*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\] Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 121
    def search(*rules)
      rules, handler, ns, binds = extract_params(rules)

      rules.inject(NodeSet.new(document)) do |set, rule|
        set + if Searchable::LOOKS_LIKE_XPATH.match?(rule)
          xpath(*[rule, ns, handler, binds].compact)
        else
          children.css(*[rule, ns, handler].compact) # 'children' is a smell here
        end
      end
    end
    ```

    Search this fragment for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.

    For more information see [`Nokogiri::XML::Searchable#search`](searchable#method-i-search)
- name: Nokogiri::XML::DocumentFragment#serialize
  id: nokogiri/xml/documentfragment#method-i-serialize
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    serialize ()

    Alias for: [to_s](documentfragment#method-i-to_s)
- name: Nokogiri::XML::DocumentFragment#to_html
  id: nokogiri/xml/documentfragment#method-i-to_html
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    to_html (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 67
    def to_html(*args)
      if Nokogiri.jruby?
        options = args.first.is_a?(Hash) ? args.shift : {}
        options[:save_with] ||= Node::SaveOptions::DEFAULT_HTML
        args.insert(0, options)
      end
      children.to_html(*args)
    end
    ```

    Convert this [`DocumentFragment`](documentfragment) to html See [`Nokogiri::XML::NodeSet#to_html`](nodeset#method-i-to_html)
- name: Nokogiri::XML::DocumentFragment#to_s
  id: nokogiri/xml/documentfragment#method-i-to_s
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    to_s () Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 60
    def to_s
      children.to_s
    end
    ```

    Convert this [`DocumentFragment`](documentfragment) to a string

    Also aliased as: [serialize](documentfragment#method-i-serialize)
- name: Nokogiri::XML::DocumentFragment#to_xhtml
  id: nokogiri/xml/documentfragment#method-i-to_xhtml
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    to_xhtml (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 79
    def to_xhtml(*args)
      if Nokogiri.jruby?
        options = args.first.is_a?(Hash) ? args.shift : {}
        options[:save_with] ||= Node::SaveOptions::DEFAULT_XHTML
        args.insert(0, options)
      end
      children.to_xhtml(*args)
    end
    ```

    Convert this [`DocumentFragment`](documentfragment) to xhtml See [`Nokogiri::XML::NodeSet#to_xhtml`](nodeset#method-i-to_xhtml)
- name: Nokogiri::XML::DocumentFragment#to_xml
  id: nokogiri/xml/documentfragment#method-i-to_xml
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::DocumentFragment
  description: "to_xml (\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/document_fragment.rb, line 91\ndef to_xml(*args)\n  children.to_xml(*args)\nend\n```\n\nConvert this [`DocumentFragment`](documentfragment) to xml See [`Nokogiri::XML::NodeSet#to_xml`](nodeset#method-i-to_xml)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/DocumentFragment.html](https://nokogiri.org/rdoc/Nokogiri/XML/DocumentFragment.html)"
- name: Nokogiri::XML::DocumentFragment::new
  id: nokogiri/xml/documentfragment#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    new(document) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr xml_doc;
      xmlNodePtr node;
      VALUE document;
      VALUE rest;
      VALUE rb_node;

      rb_scan_args(argc, argv, "1*", &document, &rest);

      Data_Get_Struct(document, xmlDoc, xml_doc);

      node = xmlNewDocFragment(xml_doc->doc);

      noko_xml_document_pin_node(node);

      rb_node = noko_xml_node_wrap(klass, node);
      rb_obj_call_init(rb_node, argc, argv);

      return rb_node;
    }
    ```

    Create a new [`DocumentFragment`](documentfragment) element on the `document`
- name: Nokogiri::XML::DocumentFragment::parse
  id: nokogiri/xml/documentfragment#method-c-parse
  summary: null
  belongs_to: Nokogiri::XML::DocumentFragment
  description: |-
    parse (tags, options = ParseOptions::DEFAULT_XML, &block) Show source

    ``` ruby
    # File lib/nokogiri/xml/document_fragment.rb, line 9
    def self.parse(tags, options = ParseOptions::DEFAULT_XML, &block)
      new(XML::Document.new, tags, nil, options, &block)
    end
    ```

    Create a [`Nokogiri::XML::DocumentFragment`](documentfragment) from `tags`

    ### Public Instance Methods
- name: Nokogiri::XML::DTD
  id: nokogiri/xml/dtd
  summary: Get a hash of the attributes for this DTD
  description: "# class Nokogiri::XML::DTD\n\nParent:  \ncNokogiriXmlNode\n\n[`Nokogiri::XML::DTD`](dtd) wraps [`DTD`](dtd) nodes in an [`XML`](../xml) document\n\n### Public Instance Methods\n\nattributes Show source\n\n``` c\nstatic VALUE\nattributes(VALUE self)\n{\n  xmlDtdPtr dtd;\n  VALUE hash;\n\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n\n  hash = rb_hash_new();\n\n  if (!dtd->attributes) { return hash; }\n\n  xmlHashScan((xmlHashTablePtr)dtd->attributes, element_copier, (void *)hash);\n\n  return hash;\n}\n```\n\nGet a hash of the attributes for this [`DTD`](dtd).\n\neach() { \\|key, value\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/dtd.rb, line 17\ndef each\n  attributes.each do |key, value|\n    yield([key, value])\n  end\nend\n```\n\nelements Show source\n\n``` c\nstatic VALUE\nelements(VALUE self)\n{\n  xmlDtdPtr dtd;\n  VALUE hash;\n\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n\n  if (!dtd->elements) { return Qnil; }\n\n  hash = rb_hash_new();\n\n  xmlHashScan((xmlHashTablePtr)dtd->elements, element_copier, (void *)hash);\n\n  return hash;\n}\n```\n\nGet a hash of the elements for this [`DTD`](dtd).\n\nentities Show source\n\n``` c\nstatic VALUE\nentities(VALUE self)\n{\n  xmlDtdPtr dtd;\n  VALUE hash;\n\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n\n  if (!dtd->entities) { return Qnil; }\n\n  hash = rb_hash_new();\n\n  xmlHashScan((xmlHashTablePtr)dtd->entities, element_copier, (void *)hash);\n\n  return hash;\n}\n```\n\nGet a hash of the elements for this [`DTD`](dtd).\n\nexternal_id Show source\n\n``` c\nstatic VALUE\nexternal_id(VALUE self)\n{\n  xmlDtdPtr dtd;\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n\n  if (!dtd->ExternalID) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(dtd->ExternalID);\n}\n```\n\nGet the External ID for this [`DTD`](dtd)\n\nhtml5_dtd?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/dtd.rb, line 27\ndef html5_dtd?\n  html_dtd? &&\n    external_id.nil? &&\n    (system_id.nil? || system_id == \"about:legacy-compat\")\nend\n```\n\nhtml_dtd?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/dtd.rb, line 23\ndef html_dtd?\n  name.casecmp(\"html\").zero?\nend\n```\n\nkeys() Show source\n\n``` ruby\n# File lib/nokogiri/xml/dtd.rb, line 13\ndef keys\n  attributes.keys\nend\n```\n\nnotations() → Hash\\<name(String)⇒Notation\\> Show source\n\n``` c\nstatic VALUE\nnotations(VALUE self)\n{\n  xmlDtdPtr dtd;\n  VALUE hash;\n\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n\n  if (!dtd->notations) { return Qnil; }\n\n  hash = rb_hash_new();\n\n  xmlHashScan((xmlHashTablePtr)dtd->notations, notation_copier, (void *)hash);\n\n  return hash;\n}\n```\n\nReturns  \nAll the notations for this [`DTD`](dtd) in a Hash of [`Notation`](notation) `name` to [`Notation`](notation).\n\nsystem_id Show source\n\n``` c\nstatic VALUE\nsystem_id(VALUE self)\n{\n  xmlDtdPtr dtd;\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n\n  if (!dtd->SystemID) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(dtd->SystemID);\n}\n```\n\nGet the System ID for this [`DTD`](dtd)\n\nvalidate(document) Show source\n\n``` c\nstatic VALUE\nvalidate(VALUE self, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlDtdPtr dtd;\n  xmlValidCtxtPtr ctxt;\n  VALUE error_list;\n\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n  Noko_Node_Get_Struct(document, xmlDoc, doc);\n  error_list = rb_ary_new();\n\n  ctxt = xmlNewValidCtxt();\n\n  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);\n\n  xmlValidateDtd(ctxt, doc, dtd);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  xmlFreeValidCtxt(ctxt);\n\n  return error_list;\n}\n```\n\nValidate `document` returning a list of errors\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/DTD.html](https://nokogiri.org/rdoc/Nokogiri/XML/DTD.html)"
- name: Nokogiri::XML::DTD#attributes
  id: nokogiri/xml/dtd#method-i-attributes
  summary: Get a hash of the attributes for this DTD
  belongs_to: Nokogiri::XML::DTD
  description: |-
    attributes Show source

    ``` c
    static VALUE
    attributes(VALUE self)
    {
      xmlDtdPtr dtd;
      VALUE hash;

      Noko_Node_Get_Struct(self, xmlDtd, dtd);

      hash = rb_hash_new();

      if (!dtd->attributes) { return hash; }

      xmlHashScan((xmlHashTablePtr)dtd->attributes, element_copier, (void *)hash);

      return hash;
    }
    ```

    Get a hash of the attributes for this [`DTD`](dtd).
- name: Nokogiri::XML::DTD#each
  id: nokogiri/xml/dtd#method-i-each
  summary: null
  belongs_to: Nokogiri::XML::DTD
  description: |-
    each () { \|key, value\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/dtd.rb, line 17
    def each
      attributes.each do |key, value|
        yield([key, value])
      end
    end
    ```
- name: Nokogiri::XML::DTD#elements
  id: nokogiri/xml/dtd#method-i-elements
  summary: Get a hash of the elements for this DTD
  belongs_to: Nokogiri::XML::DTD
  description: |-
    elements Show source

    ``` c
    static VALUE
    elements(VALUE self)
    {
      xmlDtdPtr dtd;
      VALUE hash;

      Noko_Node_Get_Struct(self, xmlDtd, dtd);

      if (!dtd->elements) { return Qnil; }

      hash = rb_hash_new();

      xmlHashScan((xmlHashTablePtr)dtd->elements, element_copier, (void *)hash);

      return hash;
    }
    ```

    Get a hash of the elements for this [`DTD`](dtd).
- name: Nokogiri::XML::DTD#entities
  id: nokogiri/xml/dtd#method-i-entities
  summary: Get a hash of the elements for this DTD
  belongs_to: Nokogiri::XML::DTD
  description: |-
    entities Show source

    ``` c
    static VALUE
    entities(VALUE self)
    {
      xmlDtdPtr dtd;
      VALUE hash;

      Noko_Node_Get_Struct(self, xmlDtd, dtd);

      if (!dtd->entities) { return Qnil; }

      hash = rb_hash_new();

      xmlHashScan((xmlHashTablePtr)dtd->entities, element_copier, (void *)hash);

      return hash;
    }
    ```

    Get a hash of the elements for this [`DTD`](dtd).
- name: Nokogiri::XML::DTD#external_id
  id: nokogiri/xml/dtd#method-i-external_id
  summary: null
  belongs_to: Nokogiri::XML::DTD
  description: |-
    external_id Show source

    ``` c
    static VALUE
    external_id(VALUE self)
    {
      xmlDtdPtr dtd;
      Noko_Node_Get_Struct(self, xmlDtd, dtd);

      if (!dtd->ExternalID) { return Qnil; }

      return NOKOGIRI_STR_NEW2(dtd->ExternalID);
    }
    ```

    Get the External ID for this [`DTD`](dtd)
- name: Nokogiri::XML::DTD#html5_dtd?
  id: nokogiri/xml/dtd#method-i-html5_dtd-3F
  summary: null
  belongs_to: Nokogiri::XML::DTD
  description: |-
    html5_dtd? () Show source

    ``` ruby
    # File lib/nokogiri/xml/dtd.rb, line 27
    def html5_dtd?
      html_dtd? &&
        external_id.nil? &&
        (system_id.nil? || system_id == "about:legacy-compat")
    end
    ```
- name: Nokogiri::XML::DTD#html_dtd?
  id: nokogiri/xml/dtd#method-i-html_dtd-3F
  summary: null
  belongs_to: Nokogiri::XML::DTD
  description: |-
    html_dtd? () Show source

    ``` ruby
    # File lib/nokogiri/xml/dtd.rb, line 23
    def html_dtd?
      name.casecmp("html").zero?
    end
    ```
- name: Nokogiri::XML::DTD#keys
  id: nokogiri/xml/dtd#method-i-keys
  summary: null
  belongs_to: Nokogiri::XML::DTD
  description: |-
    keys () Show source

    ``` ruby
    # File lib/nokogiri/xml/dtd.rb, line 13
    def keys
      attributes.keys
    end
    ```
- name: Nokogiri::XML::DTD#notations
  id: nokogiri/xml/dtd#method-i-notations
  summary: All the notations for this DTD in a Hash of Notation name to Notation
  belongs_to: Nokogiri::XML::DTD
  description: |-
    notations() → Hash\<name(String)⇒Notation\> Show source

    ``` c
    static VALUE
    notations(VALUE self)
    {
      xmlDtdPtr dtd;
      VALUE hash;

      Noko_Node_Get_Struct(self, xmlDtd, dtd);

      if (!dtd->notations) { return Qnil; }

      hash = rb_hash_new();

      xmlHashScan((xmlHashTablePtr)dtd->notations, notation_copier, (void *)hash);

      return hash;
    }
    ```

    Returns

    All the notations for this [`DTD`](dtd) in a Hash of [`Notation`](notation) `name` to [`Notation`](notation).
- name: Nokogiri::XML::DTD#system_id
  id: nokogiri/xml/dtd#method-i-system_id
  summary: null
  belongs_to: Nokogiri::XML::DTD
  description: |-
    system_id Show source

    ``` c
    static VALUE
    system_id(VALUE self)
    {
      xmlDtdPtr dtd;
      Noko_Node_Get_Struct(self, xmlDtd, dtd);

      if (!dtd->SystemID) { return Qnil; }

      return NOKOGIRI_STR_NEW2(dtd->SystemID);
    }
    ```

    Get the System ID for this [`DTD`](dtd)
- name: Nokogiri::XML::DTD#validate
  id: nokogiri/xml/dtd#method-i-validate
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::DTD
  description: "validate(document) Show source\n\n``` c\nstatic VALUE\nvalidate(VALUE self, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlDtdPtr dtd;\n  xmlValidCtxtPtr ctxt;\n  VALUE error_list;\n\n  Noko_Node_Get_Struct(self, xmlDtd, dtd);\n  Noko_Node_Get_Struct(document, xmlDoc, doc);\n  error_list = rb_ary_new();\n\n  ctxt = xmlNewValidCtxt();\n\n  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);\n\n  xmlValidateDtd(ctxt, doc, dtd);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  xmlFreeValidCtxt(ctxt);\n\n  return error_list;\n}\n```\n\nValidate `document` returning a list of errors\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/DTD.html](https://nokogiri.org/rdoc/Nokogiri/XML/DTD.html)"
- name: Nokogiri::XML::Element
  id: nokogiri/xml/element
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::Element\n\nParent:  \ncNokogiriXmlNode\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Element.html](https://nokogiri.org/rdoc/Nokogiri/XML/Element.html)"
- name: Nokogiri::XML::ElementContent
  id: nokogiri/xml/elementcontent
  summary: ElementContent represents the tree inside the <!ELEMENT> tag shown above that lists the possible content for the div1 tag
  description: "# class Nokogiri::XML::ElementContent\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nRepresents the allowed content in an [`Element`](element) Declaration inside a DTD:\n\n    <?xml version=\"1.0\"?><?TEST-STYLE PIDATA?>\n    <!DOCTYPE staff SYSTEM \"staff.dtd\" [\n       <!ELEMENT div1 (head, (p | list | note)*, div2*)>\n    ]>\n    </root>\n\n[`ElementContent`](elementcontent) represents the tree inside the \\<!ELEMENT\\> tag shown above that lists the possible content for the div1 tag.\n\n### Constants\n\nELEMENT\n\nMULT\n\nONCE\n\nPossible content occurrences\n\nOPT\n\nOR\n\nPCDATA\n\nPossible definitions of type\n\nPLUS\n\nSEQ\n\n### Attributes\n\ndocument\\[R\\]\n\n### Public Instance Methods\n\nchildren() Show source\n\n``` ruby\n# File lib/nokogiri/xml/element_content.rb, line 33\ndef children\n  [c1, c2].compact\nend\n```\n\nGet the children of this [`ElementContent`](elementcontent) node\n\nname Show source\n\n``` c\nstatic VALUE\nget_name(VALUE self)\n{\n  xmlElementContentPtr elem;\n  Data_Get_Struct(self, xmlElementContent, elem);\n\n  if (!elem->name) { return Qnil; }\n  return NOKOGIRI_STR_NEW2(elem->name);\n}\n```\n\nGet the require element `name`\n\noccur Show source\n\n``` c\nstatic VALUE\nget_occur(VALUE self)\n{\n  xmlElementContentPtr elem;\n  Data_Get_Struct(self, xmlElementContent, elem);\n\n  return INT2NUM(elem->ocur);\n}\n```\n\nGet the element content `occur` flag. Possible values are [`ONCE`](elementcontent#ONCE), [`OPT`](elementcontent#OPT), [`MULT`](elementcontent#MULT) or [`PLUS`](elementcontent#PLUS).\n\nprefix Show source\n\n``` c\nstatic VALUE\nget_prefix(VALUE self)\n{\n  xmlElementContentPtr elem;\n  Data_Get_Struct(self, xmlElementContent, elem);\n\n  if (!elem->prefix) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(elem->prefix);\n}\n```\n\nGet the element content namespace `prefix`.\n\ntype Show source\n\n``` c\nstatic VALUE\nget_type(VALUE self)\n{\n  xmlElementContentPtr elem;\n  Data_Get_Struct(self, xmlElementContent, elem);\n\n  return INT2NUM(elem->type);\n}\n```\n\nGet the element content `type`. Possible values are [`PCDATA`](elementcontent#PCDATA), [`ELEMENT`](elementcontent#ELEMENT), [`SEQ`](elementcontent#SEQ), or [`OR`](elementcontent#OR).\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ElementContent.html](https://nokogiri.org/rdoc/Nokogiri/XML/ElementContent.html)"
- name: Nokogiri::XML::ElementContent#children
  id: nokogiri/xml/elementcontent#method-i-children
  summary: null
  belongs_to: Nokogiri::XML::ElementContent
  description: |-
    children () Show source

    ``` ruby
    # File lib/nokogiri/xml/element_content.rb, line 33
    def children
      [c1, c2].compact
    end
    ```

    Get the children of this [`ElementContent`](elementcontent) node
- name: Nokogiri::XML::ElementContent#document
  id: nokogiri/xml/elementcontent#attribute-i-document
  summary: null
  belongs_to: Nokogiri::XML::ElementContent
  description: |-
    document \[R\]

    ### Public Instance Methods
- name: Nokogiri::XML::ElementContent#name
  id: nokogiri/xml/elementcontent#method-i-name
  summary: null
  belongs_to: Nokogiri::XML::ElementContent
  description: |-
    name Show source

    ``` c
    static VALUE
    get_name(VALUE self)
    {
      xmlElementContentPtr elem;
      Data_Get_Struct(self, xmlElementContent, elem);

      if (!elem->name) { return Qnil; }
      return NOKOGIRI_STR_NEW2(elem->name);
    }
    ```

    Get the require element `name`
- name: Nokogiri::XML::ElementContent#occur
  id: nokogiri/xml/elementcontent#method-i-occur
  summary: Get the element content occur flag
  belongs_to: Nokogiri::XML::ElementContent
  description: |-
    occur Show source

    ``` c
    static VALUE
    get_occur(VALUE self)
    {
      xmlElementContentPtr elem;
      Data_Get_Struct(self, xmlElementContent, elem);

      return INT2NUM(elem->ocur);
    }
    ```

    Get the element content `occur` flag. Possible values are [`ONCE`](elementcontent#ONCE), [`OPT`](elementcontent#OPT), [`MULT`](elementcontent#MULT) or [`PLUS`](elementcontent#PLUS).
- name: Nokogiri::XML::ElementContent#prefix
  id: nokogiri/xml/elementcontent#method-i-prefix
  summary: Get the element content namespace prefix
  belongs_to: Nokogiri::XML::ElementContent
  description: |-
    prefix Show source

    ``` c
    static VALUE
    get_prefix(VALUE self)
    {
      xmlElementContentPtr elem;
      Data_Get_Struct(self, xmlElementContent, elem);

      if (!elem->prefix) { return Qnil; }

      return NOKOGIRI_STR_NEW2(elem->prefix);
    }
    ```

    Get the element content namespace `prefix`.
- name: Nokogiri::XML::ElementContent#type
  id: nokogiri/xml/elementcontent#method-i-type
  summary: Get the element content type
  belongs_to: Nokogiri::XML::ElementContent
  description: "type Show source\n\n``` c\nstatic VALUE\nget_type(VALUE self)\n{\n  xmlElementContentPtr elem;\n  Data_Get_Struct(self, xmlElementContent, elem);\n\n  return INT2NUM(elem->type);\n}\n```\n\nGet the element content `type`. Possible values are [`PCDATA`](elementcontent#PCDATA), [`ELEMENT`](elementcontent#ELEMENT), [`SEQ`](elementcontent#SEQ), or [`OR`](elementcontent#OR).\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ElementContent.html](https://nokogiri.org/rdoc/Nokogiri/XML/ElementContent.html)"
- name: Nokogiri::XML::ElementDecl
  id: nokogiri/xml/elementdecl
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::ElementDecl\n\nParent:  \ncNokogiriXmlNode\n\n### Public Instance Methods\n\ncontent Show source\n\n``` c\nstatic VALUE\ncontent(VALUE self)\n{\n  xmlElementPtr node;\n  Noko_Node_Get_Struct(self, xmlElement, node);\n\n  if (!node->content) { return Qnil; }\n\n  return noko_xml_element_content_wrap(\n           rb_funcall(self, id_document, 0),\n           node->content\n         );\n}\n```\n\nThe allowed content for this [`ElementDecl`](elementdecl)\n\nelement_type Show source\n\n``` c\nstatic VALUE\nelement_type(VALUE self)\n{\n  xmlElementPtr node;\n  Noko_Node_Get_Struct(self, xmlElement, node);\n  return INT2NUM(node->etype);\n}\n```\n\nThe [`element_type`](elementdecl#method-i-element_type)\n\ninspect() Show source\n\n``` ruby\n# File lib/nokogiri/xml/element_decl.rb, line 10\ndef inspect\n  \"#<#{self.class.name}:#{format(\"0x%x\", object_id)} #{to_s.inspect}>\"\nend\n```\n\nprefix Show source\n\n``` c\nstatic VALUE\nprefix(VALUE self)\n{\n  xmlElementPtr node;\n  Noko_Node_Get_Struct(self, xmlElement, node);\n\n  if (!node->prefix) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(node->prefix);\n}\n```\n\nThe namespace prefix for this [`ElementDecl`](elementdecl)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ElementDecl.html](https://nokogiri.org/rdoc/Nokogiri/XML/ElementDecl.html)"
- name: Nokogiri::XML::ElementDecl#content
  id: nokogiri/xml/elementdecl#method-i-content
  summary: null
  belongs_to: Nokogiri::XML::ElementDecl
  description: |-
    content Show source

    ``` c
    static VALUE
    content(VALUE self)
    {
      xmlElementPtr node;
      Noko_Node_Get_Struct(self, xmlElement, node);

      if (!node->content) { return Qnil; }

      return noko_xml_element_content_wrap(
               rb_funcall(self, id_document, 0),
               node->content
             );
    }
    ```

    The allowed content for this [`ElementDecl`](elementdecl)
- name: Nokogiri::XML::ElementDecl#element_type
  id: nokogiri/xml/elementdecl#method-i-element_type
  summary: null
  belongs_to: Nokogiri::XML::ElementDecl
  description: |-
    element_type Show source

    ``` c
    static VALUE
    element_type(VALUE self)
    {
      xmlElementPtr node;
      Noko_Node_Get_Struct(self, xmlElement, node);
      return INT2NUM(node->etype);
    }
    ```

    The [`element_type`](elementdecl#method-i-element_type)
- name: Nokogiri::XML::ElementDecl#inspect
  id: nokogiri/xml/elementdecl#method-i-inspect
  summary: null
  belongs_to: Nokogiri::XML::ElementDecl
  description: |-
    inspect () Show source

    ``` ruby
    # File lib/nokogiri/xml/element_decl.rb, line 10
    def inspect
      "#<#{self.class.name}:#{format("0x%x", object_id)} #{to_s.inspect}>"
    end
    ```
- name: Nokogiri::XML::ElementDecl#prefix
  id: nokogiri/xml/elementdecl#method-i-prefix
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::ElementDecl
  description: "prefix Show source\n\n``` c\nstatic VALUE\nprefix(VALUE self)\n{\n  xmlElementPtr node;\n  Noko_Node_Get_Struct(self, xmlElement, node);\n\n  if (!node->prefix) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(node->prefix);\n}\n```\n\nThe namespace prefix for this [`ElementDecl`](elementdecl)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ElementDecl.html](https://nokogiri.org/rdoc/Nokogiri/XML/ElementDecl.html)"
- name: Nokogiri::XML::EntityDecl
  id: nokogiri/xml/entitydecl
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::EntityDecl\n\nParent:  \ncNokogiriXmlNode\n\n### Public Class Methods\n\nnew(name, doc, \\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/entity_decl.rb, line 12\ndef self.new(name, doc, *args)\n  doc.create_entity(name, *args)\nend\n```\n\n### Public Instance Methods\n\ncontent Show source\n\n``` c\nstatic VALUE\nget_content(VALUE self)\n{\n  xmlEntityPtr node;\n  Noko_Node_Get_Struct(self, xmlEntity, node);\n\n  if (!node->content) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW(node->content, node->length);\n}\n```\n\nGet the content\n\nentity_type Show source\n\n``` c\nstatic VALUE\nentity_type(VALUE self)\n{\n  xmlEntityPtr node;\n  Noko_Node_Get_Struct(self, xmlEntity, node);\n\n  return INT2NUM((int)node->etype);\n}\n```\n\nGet the entity type\n\nexternal_id Show source\n\n``` c\nstatic VALUE\nexternal_id(VALUE self)\n{\n  xmlEntityPtr node;\n  Noko_Node_Get_Struct(self, xmlEntity, node);\n\n  if (!node->ExternalID) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(node->ExternalID);\n}\n```\n\nGet the external identifier for PUBLIC\n\ninspect() Show source\n\n``` ruby\n# File lib/nokogiri/xml/entity_decl.rb, line 16\ndef inspect\n  \"#<#{self.class.name}:#{format(\"0x%x\", object_id)} #{to_s.inspect}>\"\nend\n```\n\noriginal_content Show source\n\n``` c\nstatic VALUE\noriginal_content(VALUE self)\n{\n  xmlEntityPtr node;\n  Noko_Node_Get_Struct(self, xmlEntity, node);\n\n  if (!node->orig) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(node->orig);\n}\n```\n\nGet the [`original_content`](entitydecl#method-i-original_content) before ref substitution\n\nsystem_id Show source\n\n``` c\nstatic VALUE\nsystem_id(VALUE self)\n{\n  xmlEntityPtr node;\n  Noko_Node_Get_Struct(self, xmlEntity, node);\n\n  if (!node->SystemID) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(node->SystemID);\n}\n```\n\nGet the URI for a SYSTEM or PUBLIC Entity\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/EntityDecl.html](https://nokogiri.org/rdoc/Nokogiri/XML/EntityDecl.html)"
- name: Nokogiri::XML::EntityDecl#content
  id: nokogiri/xml/entitydecl#method-i-content
  summary: null
  belongs_to: Nokogiri::XML::EntityDecl
  description: |-
    content Show source

    ``` c
    static VALUE
    get_content(VALUE self)
    {
      xmlEntityPtr node;
      Noko_Node_Get_Struct(self, xmlEntity, node);

      if (!node->content) { return Qnil; }

      return NOKOGIRI_STR_NEW(node->content, node->length);
    }
    ```

    Get the content
- name: Nokogiri::XML::EntityDecl#entity_type
  id: nokogiri/xml/entitydecl#method-i-entity_type
  summary: null
  belongs_to: Nokogiri::XML::EntityDecl
  description: |-
    entity_type Show source

    ``` c
    static VALUE
    entity_type(VALUE self)
    {
      xmlEntityPtr node;
      Noko_Node_Get_Struct(self, xmlEntity, node);

      return INT2NUM((int)node->etype);
    }
    ```

    Get the entity type
- name: Nokogiri::XML::EntityDecl#external_id
  id: nokogiri/xml/entitydecl#method-i-external_id
  summary: null
  belongs_to: Nokogiri::XML::EntityDecl
  description: |-
    external_id Show source

    ``` c
    static VALUE
    external_id(VALUE self)
    {
      xmlEntityPtr node;
      Noko_Node_Get_Struct(self, xmlEntity, node);

      if (!node->ExternalID) { return Qnil; }

      return NOKOGIRI_STR_NEW2(node->ExternalID);
    }
    ```

    Get the external identifier for PUBLIC
- name: Nokogiri::XML::EntityDecl#inspect
  id: nokogiri/xml/entitydecl#method-i-inspect
  summary: null
  belongs_to: Nokogiri::XML::EntityDecl
  description: |-
    inspect () Show source

    ``` ruby
    # File lib/nokogiri/xml/entity_decl.rb, line 16
    def inspect
      "#<#{self.class.name}:#{format("0x%x", object_id)} #{to_s.inspect}>"
    end
    ```
- name: Nokogiri::XML::EntityDecl#original_content
  id: nokogiri/xml/entitydecl#method-i-original_content
  summary: null
  belongs_to: Nokogiri::XML::EntityDecl
  description: |-
    original_content Show source

    ``` c
    static VALUE
    original_content(VALUE self)
    {
      xmlEntityPtr node;
      Noko_Node_Get_Struct(self, xmlEntity, node);

      if (!node->orig) { return Qnil; }

      return NOKOGIRI_STR_NEW2(node->orig);
    }
    ```

    Get the [`original_content`](entitydecl#method-i-original_content) before ref substitution
- name: Nokogiri::XML::EntityDecl#system_id
  id: nokogiri/xml/entitydecl#method-i-system_id
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::EntityDecl
  description: "system_id Show source\n\n``` c\nstatic VALUE\nsystem_id(VALUE self)\n{\n  xmlEntityPtr node;\n  Noko_Node_Get_Struct(self, xmlEntity, node);\n\n  if (!node->SystemID) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(node->SystemID);\n}\n```\n\nGet the URI for a SYSTEM or PUBLIC Entity\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/EntityDecl.html](https://nokogiri.org/rdoc/Nokogiri/XML/EntityDecl.html)"
- name: Nokogiri::XML::EntityDecl::new
  id: nokogiri/xml/entitydecl#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::EntityDecl
  description: |-
    new (name, doc, \*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/entity_decl.rb, line 12
    def self.new(name, doc, *args)
      doc.create_entity(name, *args)
    end
    ```

    ### Public Instance Methods
- name: Nokogiri::XML::EntityReference
  id: nokogiri/xml/entityreference
  summary: EntityReference represents an EntityReference node in an xml document
  description: "# class Nokogiri::XML::EntityReference\n\nParent:  \ncNokogiriXmlNode\n\n[`EntityReference`](entityreference) represents an [`EntityReference`](entityreference) node in an xml document.\n\n### Public Class Methods\n\nnew(document, content) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  xmlNodePtr node;\n  VALUE document;\n  VALUE name;\n  VALUE rest;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"2*\", &document, &name, &rest);\n\n  Data_Get_Struct(document, xmlDoc, xml_doc);\n\n  node = xmlNewReference(\n           xml_doc,\n           (const xmlChar *)StringValueCStr(name)\n         );\n\n  noko_xml_document_pin_node(node);\n\n  rb_node = noko_xml_node_wrap(klass, node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  if (rb_block_given_p()) { rb_yield(rb_node); }\n\n  return rb_node;\n}\n```\n\nCreate a new [`EntityReference`](entityreference) element on the `document` with `name`\n\n### Public Instance Methods\n\nchildren() Show source\n\n``` ruby\n# File lib/nokogiri/xml/entity_reference.rb, line 6\ndef children\n  # libxml2 will create a malformed child node for predefined\n  # entities. because any use of that child is likely to cause a\n  # segfault, we shall pretend that it doesn't exist.\n  #\n  # see https://github.com/sparklemotion/nokogiri/issues/1238 for details\n  NodeSet.new(document)\nend\n```\n\ninspect_attributes() Show source\n\n``` ruby\n# File lib/nokogiri/xml/entity_reference.rb, line 15\ndef inspect_attributes\n  [:name]\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/EntityReference.html](https://nokogiri.org/rdoc/Nokogiri/XML/EntityReference.html)"
- name: Nokogiri::XML::EntityReference#children
  id: nokogiri/xml/entityreference#method-i-children
  summary: null
  belongs_to: Nokogiri::XML::EntityReference
  description: |-
    children () Show source

    ``` ruby
    # File lib/nokogiri/xml/entity_reference.rb, line 6
    def children
      # libxml2 will create a malformed child node for predefined
      # entities. because any use of that child is likely to cause a
      # segfault, we shall pretend that it doesn't exist.
      #
      # see https://github.com/sparklemotion/nokogiri/issues/1238 for details
      NodeSet.new(document)
    end
    ```
- name: Nokogiri::XML::EntityReference#inspect_attributes
  id: nokogiri/xml/entityreference#method-i-inspect_attributes
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::EntityReference
  description: "inspect_attributes () Show source\n\n``` ruby\n# File lib/nokogiri/xml/entity_reference.rb, line 15\ndef inspect_attributes\n  [:name]\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/EntityReference.html](https://nokogiri.org/rdoc/Nokogiri/XML/EntityReference.html)"
- name: Nokogiri::XML::EntityReference::new
  id: nokogiri/xml/entityreference#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::EntityReference
  description: |-
    new(document, content) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr xml_doc;
      xmlNodePtr node;
      VALUE document;
      VALUE name;
      VALUE rest;
      VALUE rb_node;

      rb_scan_args(argc, argv, "2*", &document, &name, &rest);

      Data_Get_Struct(document, xmlDoc, xml_doc);

      node = xmlNewReference(
               xml_doc,
               (const xmlChar *)StringValueCStr(name)
             );

      noko_xml_document_pin_node(node);

      rb_node = noko_xml_node_wrap(klass, node);
      rb_obj_call_init(rb_node, argc, argv);

      if (rb_block_given_p()) { rb_yield(rb_node); }

      return rb_node;
    }
    ```

    Create a new [`EntityReference`](entityreference) element on the `document` with `name`

    ### Public Instance Methods
- name: Nokogiri::XML::fragment
  id: nokogiri/xml#method-c-fragment
  summary: Parse a fragment from string in to a NodeSet
  belongs_to: Nokogiri::XML
  description: |-
    fragment (string, options = ParseOptions::DEFAULT_XML, &block) Show source

    ``` ruby
    # File lib/nokogiri/xml.rb, line 42
    def fragment(string, options = ParseOptions::DEFAULT_XML, &block)
      XML::DocumentFragment.parse(string, options, &block)
    end
    ```

    Parse a fragment from `string` in to a [`NodeSet`](xml/nodeset).
- name: Nokogiri::XML::Namespace
  id: nokogiri/xml/namespace
  summary: Returns a hash describing the Namespace, to use in pattern matching
  description: "# class Nokogiri::XML::Namespace\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nIncluded modules:  \n[Nokogiri::XML::PP::Node](pp/node)\n\n### Attributes\n\ndocument\\[R\\]\n\n### Public Instance Methods\n\ndeconstruct_keys(array_of_names) → Hash Show source\n\n``` ruby\n# File lib/nokogiri/xml/namespace.rb, line 47\ndef deconstruct_keys(keys)\n  { prefix: prefix, href: href }\nend\n```\n\nReturns a hash describing the [`Namespace`](namespace), to use in pattern matching.\n\nValid keys and their values:\n\n- `prefix` → (String, nil) The namespace’s prefix, or `nil` if there is no prefix (e.g., default namespace).\n\n- `href` → (String) The namespace’s URI\n\n⚡ This is an experimental feature, available since v1.14.0\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML.parse(<<~XML)\n  <?xml version=\"1.0\"?>\n  <root xmlns=\"http://nokogiri.org/ns/default\" xmlns:noko=\"http://nokogiri.org/ns/noko\">\n    <child1 foo=\"abc\" noko:bar=\"def\"/>\n    <noko:child2 foo=\"qwe\" noko:bar=\"rty\"/>\n  </root>\nXML\n\ndoc.root.elements.first.namespace\n# => #(Namespace:0x35c { href = \"http://nokogiri.org/ns/default\" })\n\ndoc.root.elements.first.namespace.deconstruct_keys([:prefix, :href])\n# => {:prefix=>nil, :href=>\"http://nokogiri.org/ns/default\"}\n\ndoc.root.elements.last.namespace\n# => #(Namespace:0x370 {\n#      prefix = \"noko\",\n#      href = \"http://nokogiri.org/ns/noko\"\n#      })\n\ndoc.root.elements.last.namespace.deconstruct_keys([:prefix, :href])\n# => {:prefix=>\"noko\", :href=>\"http://nokogiri.org/ns/noko\"}\n```\n\nhref() → String Show source\n\n``` c\nstatic VALUE\nhref(VALUE self)\n{\n  xmlNsPtr ns;\n\n  Noko_Namespace_Get_Struct(self, xmlNs, ns);\n  if (!ns->href) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(ns->href);\n}\n```\n\nReturns the URI reference for this [`Namespace`](namespace).\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML.parse(<<~XML)\n  <?xml version=\"1.0\"?>\n  <root xmlns=\"http://nokogiri.org/ns/default\" xmlns:noko=\"http://nokogiri.org/ns/noko\">\n    <child1 foo=\"abc\" noko:bar=\"def\"/>\n    <noko:child2 foo=\"qwe\" noko:bar=\"rty\"/>\n  </root>\nXML\n\ndoc.root.elements.first.namespace.href\n# => \"http://nokogiri.org/ns/default\"\n\ndoc.root.elements.last.namespace.href\n# => \"http://nokogiri.org/ns/noko\"\n```\n\nprefix() → String or nil Show source\n\n``` c\nstatic VALUE\nprefix(VALUE self)\n{\n  xmlNsPtr ns;\n\n  Noko_Namespace_Get_Struct(self, xmlNs, ns);\n  if (!ns->prefix) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(ns->prefix);\n}\n```\n\nReturn the prefix for this [`Namespace`](namespace), or `nil` if there is no prefix (e.g., default namespace).\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML.parse(<<~XML)\n  <?xml version=\"1.0\"?>\n  <root xmlns=\"http://nokogiri.org/ns/default\" xmlns:noko=\"http://nokogiri.org/ns/noko\">\n    <child1 foo=\"abc\" noko:bar=\"def\"/>\n    <noko:child2 foo=\"qwe\" noko:bar=\"rty\"/>\n  </root>\nXML\n\ndoc.root.elements.first.namespace.prefix\n# => nil\n\ndoc.root.elements.last.namespace.prefix\n# => \"noko\"\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Namespace.html](https://nokogiri.org/rdoc/Nokogiri/XML/Namespace.html)"
- name: Nokogiri::XML::Namespace#deconstruct_keys
  id: nokogiri/xml/namespace#method-i-deconstruct_keys
  summary: Returns a hash describing the Namespace, to use in pattern matching
  belongs_to: Nokogiri::XML::Namespace
  description: |-
    deconstruct_keys(array_of_names) → Hash Show source

    ``` ruby
    # File lib/nokogiri/xml/namespace.rb, line 47
    def deconstruct_keys(keys)
      { prefix: prefix, href: href }
    end
    ```

    Returns a hash describing the [`Namespace`](namespace), to use in pattern matching.

    Valid keys and their values:

    - `prefix` → (String, nil) The namespace’s prefix, or `nil` if there is no prefix (e.g., default namespace).

    - `href` → (String) The namespace’s URI

    ⚡ This is an experimental feature, available since v1.14.0

    **Example**

    ``` ruby
    doc = Nokogiri::XML.parse(<<~XML)
      <?xml version="1.0"?>
      <root xmlns="http://nokogiri.org/ns/default" xmlns:noko="http://nokogiri.org/ns/noko">
        <child1 foo="abc" noko:bar="def"/>
        <noko:child2 foo="qwe" noko:bar="rty"/>
      </root>
    XML

    doc.root.elements.first.namespace
    # => #(Namespace:0x35c { href = "http://nokogiri.org/ns/default" })

    doc.root.elements.first.namespace.deconstruct_keys([:prefix, :href])
    # => {:prefix=>nil, :href=>"http://nokogiri.org/ns/default"}

    doc.root.elements.last.namespace
    # => #(Namespace:0x370 {
    #      prefix = "noko",
    #      href = "http://nokogiri.org/ns/noko"
    #      })

    doc.root.elements.last.namespace.deconstruct_keys([:prefix, :href])
    # => {:prefix=>"noko", :href=>"http://nokogiri.org/ns/noko"}
    ```
- name: Nokogiri::XML::Namespace#document
  id: nokogiri/xml/namespace#attribute-i-document
  summary: null
  belongs_to: Nokogiri::XML::Namespace
  description: |-
    document \[R\]

    ### Public Instance Methods
- name: Nokogiri::XML::Namespace#href
  id: nokogiri/xml/namespace#method-i-href
  summary: Returns the URI reference for this Namespace
  belongs_to: Nokogiri::XML::Namespace
  description: |-
    href() → String Show source

    ``` c
    static VALUE
    href(VALUE self)
    {
      xmlNsPtr ns;

      Noko_Namespace_Get_Struct(self, xmlNs, ns);
      if (!ns->href) { return Qnil; }

      return NOKOGIRI_STR_NEW2(ns->href);
    }
    ```

    Returns the URI reference for this [`Namespace`](namespace).

    **Example**

    ``` ruby
    doc = Nokogiri::XML.parse(<<~XML)
      <?xml version="1.0"?>
      <root xmlns="http://nokogiri.org/ns/default" xmlns:noko="http://nokogiri.org/ns/noko">
        <child1 foo="abc" noko:bar="def"/>
        <noko:child2 foo="qwe" noko:bar="rty"/>
      </root>
    XML

    doc.root.elements.first.namespace.href
    # => "http://nokogiri.org/ns/default"

    doc.root.elements.last.namespace.href
    # => "http://nokogiri.org/ns/noko"
    ```
- name: Nokogiri::XML::Namespace#prefix
  id: nokogiri/xml/namespace#method-i-prefix
  summary: Return the prefix for this Namespace, or nil if there is no prefix (e.g., default namespace)
  belongs_to: Nokogiri::XML::Namespace
  description: "prefix() → String or nil Show source\n\n``` c\nstatic VALUE\nprefix(VALUE self)\n{\n  xmlNsPtr ns;\n\n  Noko_Namespace_Get_Struct(self, xmlNs, ns);\n  if (!ns->prefix) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(ns->prefix);\n}\n```\n\nReturn the prefix for this [`Namespace`](namespace), or `nil` if there is no prefix (e.g., default namespace).\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML.parse(<<~XML)\n  <?xml version=\"1.0\"?>\n  <root xmlns=\"http://nokogiri.org/ns/default\" xmlns:noko=\"http://nokogiri.org/ns/noko\">\n    <child1 foo=\"abc\" noko:bar=\"def\"/>\n    <noko:child2 foo=\"qwe\" noko:bar=\"rty\"/>\n  </root>\nXML\n\ndoc.root.elements.first.namespace.prefix\n# => nil\n\ndoc.root.elements.last.namespace.prefix\n# => \"noko\"\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Namespace.html](https://nokogiri.org/rdoc/Nokogiri/XML/Namespace.html)"
- name: Nokogiri::XML::Node
  id: nokogiri/xml/node
  summary: Nokogiri::XML::Node is the primary API you’ll use to interact with your Document
  description: "# class Nokogiri::XML::Node\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nIncluded modules:  \n[Nokogiri::XML::PP::Node](pp/node), [Nokogiri::XML::Searchable](searchable), [Nokogiri::ClassResolver](../classresolver)\n\n[`Nokogiri::XML::Node`](node) is the primary API you’ll use to interact with your [`Document`](document).\n\n## Attributes\n\nA [`Nokogiri::XML::Node`](node) may be treated similarly to a hash with regard to attributes. For example:\n\n``` ruby\nnode = Nokogiri::XML::DocumentFragment.parse(\"<a href='#foo' id='link'>link</a>\").at_css(\"a\")\nnode.to_html # => \"<a href=\\\"#foo\\\" id=\\\"link\\\">link</a>\"\nnode['href'] # => \"#foo\"\nnode.keys # => [\"href\", \"id\"]\nnode.values # => [\"#foo\", \"link\"]\nnode['class'] = 'green' # => \"green\"\nnode.to_html # => \"<a href=\\\"#foo\\\" id=\\\"link\\\" class=\\\"green\\\">link</a>\"\n```\n\nSee the method group entitled [Working With Node Attributes at `Node`](node#class-Nokogiri::XML::Node-label-Working+With+Node+Attributes) for the full set of methods.\n\n## Navigation\n\n[`Nokogiri::XML::Node`](node) also has methods that let you move around your tree:\n\n[`#parent`](node#method-i-parent), [`#children`](node#method-i-children), [`#next`](node#method-i-next), [`#previous`](node#method-i-previous)  \nNavigate up, down, or through siblings.\n\nSee the method group entitled [Traversing Document Structure at `Node`](node#class-Nokogiri::XML::Node-label-Traversing+Document+Structure) for the full set of methods.\n\n## Serialization\n\nWhen printing or otherwise emitting a document or a node (and its subtree), there are a few methods you might want to use:\n\n[`#content`](node#method-i-content), [`#text`](node#method-i-text), [`#inner_text`](node#method-i-inner_text), [`#to_str`](node#method-i-to_str)  \nThese methods will all \\*\\*emit plaintext\\*\\*, meaning that entities will be replaced (e.g., +&lt;+ will be replaced with +\\<+), meaning that any sanitizing will likely be un-done in the output.\n\n[`#to_s`](node#method-i-to_s), [`#to_xml`](node#method-i-to_xml), [`#to_html`](node#method-i-to_html), [`#inner_html`](node#method-i-inner_html)  \nThese methods will all \\*\\*emit properly-escaped markup\\*\\*, meaning that it’s suitable for consumption by browsers, parsers, etc.\n\nSee the method group entitled [Serialization and Generating Output at `Node`](node#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output) for the full set of methods.\n\n## Searching\n\nYou may search this node’s subtree using methods like [`#xpath`](node#method-i-xpath) and [`#css`](node#method-i-css).\n\nSee the method group entitled [Searching via XPath or CSS Queries at `Node`](node#class-Nokogiri::XML::Node-label-Searching+via+XPath+or+CSS+Queries) for the full set of methods.\n\n### Constants\n\nATTRIBUTE_DECL  \nAttribute declaration type\n\nATTRIBUTE_NODE  \nAttribute node type\n\nCDATA_SECTION_NODE  \n[`CDATA`](cdata) node type, see [`Nokogiri::XML::Node#cdata?`](node#method-i-cdata-3F)\n\nCOMMENT_NODE  \n[`Comment`](comment) node type, see [`Nokogiri::XML::Node#comment?`](node#method-i-comment-3F)\n\nDOCB_DOCUMENT_NODE  \nDOCB document node type\n\nDOCUMENT_FRAG_NODE  \n[`Document`](document) fragment node type\n\nDOCUMENT_NODE  \n[`Document`](document) node type, see [`Nokogiri::XML::Node#xml?`](node#method-i-xml-3F)\n\nDOCUMENT_TYPE_NODE  \n[`Document`](document) type node type\n\nDTD_NODE  \n[`DTD`](dtd) node type\n\nELEMENT_DECL  \n[`Element`](element) declaration type\n\nELEMENT_NODE  \n[`Element`](element) node type, see [`Nokogiri::XML::Node#element?`](node#method-i-element-3F)\n\nENTITY_DECL  \nEntity declaration type\n\nENTITY_NODE  \nEntity node type\n\nENTITY_REF_NODE  \nEntity reference node type\n\nHTML_DOCUMENT_NODE  \n[`HTML`](../html4) document node type, see [`Nokogiri::XML::Node#html?`](node#method-i-html-3F)\n\nIMPLIED_XPATH_CONTEXTS  \nLOOKS_LIKE_XPATH  \nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nRegular expression used by [`Searchable#search`](searchable#method-i-search) to determine if a query string is [`CSS`](../css) or [`XPath`](xpath)\n\nNAMESPACE_DECL  \n[`Namespace`](namespace) declaration type\n\nNOTATION_NODE  \n[`Notation`](notation) node type\n\nPI_NODE  \nPI node type\n\nTEXT_NODE  \n[`Text`](text) node type, see [`Nokogiri::XML::Node#text?`](node#method-i-text-3F)\n\nVALID_NAMESPACES  \nIncluded from [Nokogiri::ClassResolver](../classresolver)\n\n[`related_class`](node#method-i-related_class) restricts matching namespaces to those matching this set.\n\nXINCLUDE_END  \nXInclude end type\n\nXINCLUDE_START  \nXInclude start type\n\n### Public Class Methods\n\nnew(name, document) → Nokogiri::XML::Node Show source\n\nnew(name, document) { \\|node\\| ... } → Nokogiri::XML::Node\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 126\ndef initialize(name, document)\n  # This is intentionally empty, and sets the method signature for subclasses.\nend\n```\n\nCreate a new node with `name` that belongs to `document`.\n\nIf you intend to add a node to a document tree, it’s likely that you will prefer one of the [`Nokogiri::XML::Node`](node) methods like [`#add_child`](node#method-i-add_child), [`#add_next_sibling`](node#method-i-add_next_sibling), [`#replace`](node#method-i-replace), etc. which will both create an element (or subtree) and place it in the document tree.\n\nAnother alternative, if you are concerned about performance, is Nokogiri::XML::Document#create_element which accepts additional arguments for contents or attributes but (like this method) avoids parsing markup.\n\nParameters\n\n- `name` (String)\n\n- `document` ([`Nokogiri::XML::Document`](document)) The document to which the the returned node will belong.\n\nYields  \n[`Nokogiri::XML::Node`](node)\n\nReturns  \n[`Nokogiri::XML::Node`](node)\n\n### Public Instance Methods\n\n\\<=\\>(other) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1256\ndef <=>(other)\n  return nil unless other.is_a?(Nokogiri::XML::Node)\n  return nil unless document == other.document\n\n  compare(other)\nend\n```\n\nCompare two [`Node`](node) objects with respect to their [`Document`](document). Nodes from different documents cannot be compared.\n\n==(other) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1246\ndef ==(other)\n  return false unless other\n  return false unless other.respond_to?(:pointer_id)\n\n  pointer_id == other.pointer_id\nend\n```\n\nTest to see if this [`Node`](node) is equal to `other`\n\naccept(visitor) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1240\ndef accept(visitor)\n  visitor.visit(self)\nend\n```\n\nAccept a visitor. This method calls “visit” on `visitor` with self.\n\nancestors(selector = nil) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1209\ndef ancestors(selector = nil)\n  return NodeSet.new(document) unless respond_to?(:parent)\n  return NodeSet.new(document) unless parent\n\n  parents = [parent]\n\n  while parents.last.respond_to?(:parent)\n    break unless (ctx_parent = parents.last.parent)\n\n    parents << ctx_parent\n  end\n\n  return NodeSet.new(document, parents) unless selector\n\n  root = parents.last\n  search_results = root.search(selector)\n\n  NodeSet.new(document, parents.find_all do |parent|\n    search_results.include?(parent)\n  end)\nend\n```\n\nGet a list of ancestor [`Node`](node) for this [`Node`](node). If `selector` is given, the ancestors must match `selector`\n\nblank? → Boolean Show source\n\n``` c\nstatic VALUE\nrb_xml_node_blank_eh(VALUE self)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;\n}\n```\n\nReturns  \n`true` if the node is an empty or whitespace-only text or cdata node, else `false`.\n\n**Example:**\n\n``` ruby\nNokogiri(\"<root><child/></root>\").root.child.blank? # => false\nNokogiri(\"<root>\\t \\n</root>\").root.child.blank? # => true\nNokogiri(\"<root><![CDATA[\\t \\n]]></root>\").root.child.blank? # => true\nNokogiri(\"<root>not-blank</root>\").root.child\n  .tap { |n| n.content = \"\" }.blank # => true\n```\n\ncdata?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1130\ndef cdata?\n  type == CDATA_SECTION_NODE\nend\n```\n\nReturns true if this is a [`CDATA`](cdata)\n\nclone(p1 = v1, p2 = v2)\n\nAlias for: [dup](node#method-i-dup)\n\ncomment?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1125\ndef comment?\n  type == COMMENT_NODE\nend\n```\n\nReturns true if this is a [`Comment`](comment)\n\ncontent() → String Show source\n\n``` c\nstatic VALUE\nrb_xml_node_content(VALUE self)\n{\n  xmlNodePtr node;\n  xmlChar *content;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  content = xmlNodeGetContent(node);\n  if (content) {\n    VALUE rval = NOKOGIRI_STR_NEW2(content);\n    xmlFree(content);\n    return rval;\n  }\n  return Qnil;\n}\n```\n\nReturns  \nContents of all the text nodes in this node’s subtree, concatenated together into a single String.\n\n⚠ Note that entities will *always* be expanded in the returned String.\n\nSee related: [`#inner_html`](node#method-i-inner_html)\n\n**Example** of how entities are handled:\n\nNote that `&lt;` becomes `<` in the returned String.\n\n``` ruby\ndoc = Nokogiri::XML.fragment(\"<child>a &lt; b</child>\")\ndoc.at_css(\"child\").content\n# => \"a < b\"\n```\n\n**Example** of how a subtree is handled:\n\nNote that the `<span>` tags are omitted and only the text node contents are returned, concatenated into a single string.\n\n``` ruby\ndoc = Nokogiri::XML.fragment(\"<child><span>first</span> <span>second</span></child>\")\ndoc.at_css(\"child\").content\n# => \"first second\"\n```\n\nAlso aliased as: [inner_text](node#method-i-inner_text), [text](node#method-i-text), [to_str](node#method-i-to_str)\n\ncreate_external_subset(name, external_id, system_id) Show source\n\n``` c\nstatic VALUE\ncreate_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\n{\n  xmlNodePtr node;\n  xmlDocPtr doc;\n  xmlDtdPtr dtd;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  doc = node->doc;\n\n  if (doc->extSubset) {\n    rb_raise(rb_eRuntimeError, \"Document already has an external subset\");\n  }\n\n  dtd = xmlNewDtd(\n          doc,\n          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\n          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\n          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\n        );\n\n  if (!dtd) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);\n}\n```\n\nCreate an external subset\n\ncreate_internal_subset(name, external_id, system_id) Show source\n\n``` c\nstatic VALUE\ncreate_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)\n{\n  xmlNodePtr node;\n  xmlDocPtr doc;\n  xmlDtdPtr dtd;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  doc = node->doc;\n\n  if (xmlGetIntSubset(doc)) {\n    rb_raise(rb_eRuntimeError, \"Document already has an internal subset\");\n  }\n\n  dtd = xmlCreateIntSubset(\n          doc,\n          NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),\n          NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),\n          NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)\n        );\n\n  if (!dtd) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);\n}\n```\n\nCreate the internal subset of a document.\n\n``` ruby\ndoc.create_internal_subset(\"chapter\", \"-//OASIS//DTD DocBook XML//EN\", \"chapter.dtd\")\n# => <!DOCTYPE chapter PUBLIC \"-//OASIS//DTD DocBook XML//EN\" \"chapter.dtd\">\n\ndoc.create_internal_subset(\"chapter\", nil, \"chapter.dtd\")\n# => <!DOCTYPE chapter SYSTEM \"chapter.dtd\">\n```\n\ncss_path() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1200\ndef css_path\n  path.split(%r{/}).filter_map do |part|\n    part.empty? ? nil : part.gsub(/\\[(\\d+)\\]/, ':nth-of-type(\\1)')\n  end.join(\" > \")\nend\n```\n\nGet the path to this node as a [`CSS`](../css) expression\n\ndecorate!() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 132\ndef decorate!\n  document.decorate(self)\nend\n```\n\nDecorate this node with the decorators set up in this node’s [`Document`](document)\n\ndescription() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1167\ndef description\n  return nil if document.xml?\n\n  Nokogiri::HTML4::ElementDescription[name]\nend\n```\n\nFetch the [`Nokogiri::HTML4::ElementDescription`](../html4/elementdescription) for this node. Returns nil on [`XML`](../xml) documents and on unknown tags.\n\ndocument?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1145\ndef document?\n  is_a?(XML::Document)\nend\n```\n\nReturns true if this is a [`Document`](document)\n\ndup → Nokogiri::XML::Node Show source\n\ndup(depth) → Nokogiri::XML::Node\n\ndup(depth, new_parent_doc) → Nokogiri::XML::Node\n\n``` c\nstatic VALUE\nduplicate_node(int argc, VALUE *argv, VALUE self)\n{\n  VALUE r_level, r_new_parent_doc;\n  int level;\n  int n_args;\n  xmlDocPtr new_parent_doc;\n  xmlNodePtr node, dup;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  n_args = rb_scan_args(argc, argv, \"02\", &r_level, &r_new_parent_doc);\n\n  if (n_args < 1) {\n    r_level = INT2NUM((long)1);\n  }\n  level = (int)NUM2INT(r_level);\n\n  if (n_args < 2) {\n    new_parent_doc = node->doc;\n  } else {\n    Data_Get_Struct(r_new_parent_doc, xmlDoc, new_parent_doc);\n  }\n\n  dup = xmlDocCopyNode(node, new_parent_doc, level);\n  if (dup == NULL) { return Qnil; }\n\n  noko_xml_document_pin_node(dup);\n\n  return noko_xml_node_wrap(rb_obj_class(self), dup);\n}\n```\n\nCopy this node.\n\nParameters\n\n- `depth` 0 is a shallow copy, 1 (the default) is a deep copy.\n\n- `new_parent_doc` The new node’s parent [`Document`](document). Defaults to the this node’s document.\n\nReturns  \nThe new Nokgiri::XML::Node\n\nAlso aliased as: [clone](node#method-i-clone)\n\nelem?()\n\nAlias for: [element?](node#method-i-element-3F)\n\nelement?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1181\ndef element?\n  type == ELEMENT_NODE\nend\n```\n\nReturns true if this is an [`Element`](element) node\n\nAlso aliased as: [elem?](node#method-i-elem-3F)\n\nelement_children() → NodeSet Show source\n\n``` c\nstatic VALUE\nrb_xml_node_element_children(VALUE self)\n{\n  xmlNodePtr node;\n  xmlNodePtr child;\n  xmlNodeSetPtr set;\n  VALUE document;\n  VALUE node_set;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  child = xmlFirstElementChild(node);\n  set = xmlXPathNodeSetCreate(child);\n\n  document = DOC_RUBY_OBJECT(node->doc);\n\n  if (!child) { return noko_xml_node_set_wrap(set, document); }\n\n  child = xmlNextElementSibling(child);\n  while (NULL != child) {\n    xmlXPathNodeSetAddUnique(set, child);\n    child = xmlNextElementSibling(child);\n  }\n\n  node_set = noko_xml_node_set_wrap(set, document);\n\n  return node_set;\n}\n```\n\nReturns  \nThe node’s child elements as a [`NodeSet`](nodeset). Only children that are elements will be returned, which notably excludes [`Text`](text) nodes.\n\n**Example:**\n\nNote that [`#children`](node#method-i-children) returns the [`Text`](text) node “hello” while [`#element_children`](node#method-i-element_children) does not.\n\n``` ruby\ndiv = Nokogiri::HTML5(\"<div>hello<span>world</span>\").at_css(\"div\")\ndiv.element_children\n# => [#<Nokogiri::XML::Element:0x50 name=\"span\" children=[#<Nokogiri::XML::Text:0x3c \"world\">]>]\ndiv.children\n# => [#<Nokogiri::XML::Text:0x64 \"hello\">,\n#     #<Nokogiri::XML::Element:0x50 name=\"span\" children=[#<Nokogiri::XML::Text:0x3c \"world\">]>]\n```\n\nAlso aliased as: [elements](node#method-i-elements)\n\nelements() → NodeSet\n\nAlias for: [element_children](node#method-i-element_children)\n\nencode_special_chars(string) → String Show source\n\n``` c\nstatic VALUE\nencode_special_chars(VALUE self, VALUE string)\n{\n  xmlNodePtr node;\n  xmlChar *encoded;\n  VALUE encoded_str;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  encoded = xmlEncodeSpecialChars(\n              node->doc,\n              (const xmlChar *)StringValueCStr(string)\n            );\n\n  encoded_str = NOKOGIRI_STR_NEW2(encoded);\n  xmlFree(encoded);\n\n  return encoded_str;\n}\n```\n\nEncode any special characters in `string`\n\nexternal_subset() Show source\n\n``` c\nstatic VALUE\nexternal_subset(VALUE self)\n{\n  xmlNodePtr node;\n  xmlDocPtr doc;\n  xmlDtdPtr dtd;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  if (!node->doc) { return Qnil; }\n\n  doc = node->doc;\n  dtd = doc->extSubset;\n\n  if (!dtd) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);\n}\n```\n\nGet the external subset\n\nfirst_element_child() → Node Show source\n\n``` c\nstatic VALUE\nrb_xml_node_first_element_child(VALUE self)\n{\n  xmlNodePtr node, child;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  child = xmlFirstElementChild(node);\n  if (!child) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, child);\n}\n```\n\nReturns  \nThe first child [`Node`](node) that is an element.\n\n**Example:**\n\nNote that the “hello” child, which is a [`Text`](text) node, is skipped and the `<span>` element is returned.\n\n``` ruby\ndiv = Nokogiri::HTML5(\"<div>hello<span>world</span>\").at_css(\"div\")\ndiv.first_element_child\n# => #(Element:0x3c { name = \"span\", children = [ #(Text \"world\")] })\n```\n\nfragment(tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1022\ndef fragment(tags)\n  document.related_class(\"DocumentFragment\").new(document, tags, self)\nend\n```\n\nCreate a [`DocumentFragment`](documentfragment) containing `tags` that is relative to *this* context node.\n\nfragment?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1160\ndef fragment?\n  type == DOCUMENT_FRAG_NODE\nend\n```\n\nReturns true if this is a [`DocumentFragment`](documentfragment)\n\nhtml?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1140\ndef html?\n  type == HTML_DOCUMENT_NODE\nend\n```\n\nReturns true if this is an [`HTML4::Document`](../html4/document) or [`HTML5::Document`](../html5/document) node\n\ninner_html(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1195\ndef inner_html(*args)\n  children.map { |x| x.to_html(*args) }.join\nend\n```\n\nGet the [`inner_html`](node#method-i-inner_html) for this node’s [`Node#children`](node#method-i-children)\n\ninner_text()\n\nAlias for: [content](node#method-i-content)\n\ninternal_subset() Show source\n\n``` c\nstatic VALUE\ninternal_subset(VALUE self)\n{\n  xmlNodePtr node;\n  xmlDocPtr doc;\n  xmlDtdPtr dtd;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  if (!node->doc) { return Qnil; }\n\n  doc = node->doc;\n  dtd = xmlGetIntSubset(doc);\n\n  if (!dtd) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);\n}\n```\n\nGet the internal subset\n\nkey?(attribute) Show source\n\n``` c\nstatic VALUE\nkey_eh(VALUE self, VALUE attribute)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  if (xmlHasProp(node, (xmlChar *)StringValueCStr(attribute))) {\n    return Qtrue;\n  }\n  return Qfalse;\n}\n```\n\nReturns true if `attribute` is set\n\nAlso aliased as: [has_attribute?](node#method-i-has_attribute-3F)\n\nlang Show source\n\n``` c\nstatic VALUE\nget_lang(VALUE self_rb)\n{\n  xmlNodePtr self ;\n  xmlChar *lang ;\n  VALUE lang_rb ;\n\n  Noko_Node_Get_Struct(self_rb, xmlNode, self);\n\n  lang = xmlNodeGetLang(self);\n  if (lang) {\n    lang_rb = NOKOGIRI_STR_NEW2(lang);\n    xmlFree(lang);\n    return lang_rb ;\n  }\n\n  return Qnil ;\n}\n```\n\nSearches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.\n\nlang= Show source\n\n``` c\nstatic VALUE\nset_lang(VALUE self_rb, VALUE lang_rb)\n{\n  xmlNodePtr self ;\n  xmlChar *lang ;\n\n  Noko_Node_Get_Struct(self_rb, xmlNode, self);\n  lang = (xmlChar *)StringValueCStr(lang_rb);\n\n  xmlNodeSetLang(self, lang);\n\n  return Qnil ;\n}\n```\n\nSet the language of a node, i.e. the values of the xml:lang attribute.\n\nlast_element_child() → Node Show source\n\n``` c\nstatic VALUE\nrb_xml_node_last_element_child(VALUE self)\n{\n  xmlNodePtr node, child;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  child = xmlLastElementChild(node);\n  if (!child) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, child);\n}\n```\n\nReturns  \nThe last child [`Node`](node) that is an element.\n\n**Example:**\n\nNote that the “hello” child, which is a [`Text`](text) node, is skipped and the `<span>yes</span>` element is returned.\n\n``` ruby\ndiv = Nokogiri::HTML5(\"<div><span>no</span><span>yes</span>skip</div>\").at_css(\"div\")\ndiv.last_element_child\n# => #(Element:0x3c { name = \"span\", children = [ #(Text \"yes\")] })\n```\n\nline() → Integer Show source\n\n``` c\nstatic VALUE\nrb_xml_node_line(VALUE rb_node)\n{\n  xmlNodePtr c_node;\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  return LONG2NUM(xmlGetLineNo(c_node));\n}\n```\n\nReturns  \nThe line number of this [`Node`](node).\n\n**⚠ The CRuby and JRuby implementations differ in important ways!**\n\nSemantic differences:\n\n- The CRuby method reflects the node’s line number *in the parsed string*\n\n- The JRuby method reflects the node’s line number *in the final DOM structure* after corrections have been applied\n\nPerformance differences:\n\n- The CRuby method is [O(1)](https://en.wikipedia.org/wiki/Time_complexity#Constant_time) (constant time)\n\n- The JRuby method is [O(n)](https://en.wikipedia.org/wiki/Time_complexity#Linear_time) (linear time, where n is the number of nodes before/above the element in the DOM)\n\nIf you’d like to help improve the JRuby implementation, please review these issues and reach out to the maintainers:\n\n- [github.com/sparklemotion/nokogiri/issues/1223](https://github.com/sparklemotion/nokogiri/issues/1223)\n\n- [github.com/sparklemotion/nokogiri/pull/2177](https://github.com/sparklemotion/nokogiri/pull/2177)\n\n- [github.com/sparklemotion/nokogiri/issues/2380](https://github.com/sparklemotion/nokogiri/issues/2380)\n\nline=(num) Show source\n\n``` c\nstatic VALUE\nrb_xml_node_line_set(VALUE rb_node, VALUE rb_line_number)\n{\n  xmlNodePtr c_node;\n  int line_number = NUM2INT(rb_line_number);\n\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  // libxml2 optionally uses xmlNode.psvi to store longer line numbers, but only for text nodes.\n  // search for \"psvi\" in SAX2.c and tree.c to learn more.\n  if (line_number < 65535) {\n    c_node->line = (short) line_number;\n  } else {\n    c_node->line = 65535;\n    if (c_node->type == XML_TEXT_NODE) {\n      c_node->psvi = (void *)(ptrdiff_t) line_number;\n    }\n  }\n\n  return rb_line_number;\n}\n```\n\nSets the line for this [`Node`](node). num must be less than 65535.\n\nmatches?(selector) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1015\ndef matches?(selector)\n  ancestors.last.search(selector).include?(self)\nend\n```\n\nReturns true if this [`Node`](node) matches `selector`\n\nname\n\nAlias for: [node_name](node#method-i-node_name)\n\nnamespace() → Namespace Show source\n\n``` c\nstatic VALUE\nrb_xml_node_namespace(VALUE rb_node)\n{\n  xmlNodePtr c_node ;\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  if (c_node->ns) {\n    return noko_xml_namespace_wrap(c_node->ns, c_node->doc);\n  }\n\n  return Qnil ;\n}\n```\n\nReturns  \nThe [`Namespace`](namespace) of the element or attribute node, or `nil` if there is no namespace.\n\n**Example:**\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root>\n    <first/>\n    <second xmlns=\"http://example.com/child\"/>\n    <foo:third xmlns:foo=\"http://example.com/foo\"/>\n  </root>\nEOF\ndoc.at_xpath(\"//first\").namespace\n# => nil\ndoc.at_xpath(\"//xmlns:second\", \"xmlns\" => \"http://example.com/child\").namespace\n# => #(Namespace:0x3c { href = \"http://example.com/child\" })\ndoc.at_xpath(\"//foo:third\", \"foo\" => \"http://example.com/foo\").namespace\n# => #(Namespace:0x50 { prefix = \"foo\", href = \"http://example.com/foo\" })\n```\n\nnamespace_definitions() → Array\\<Nokogiri::XML::Namespace\\> Show source\n\n``` c\nstatic VALUE\nnamespace_definitions(VALUE rb_node)\n{\n  /* this code in the mode of xmlHasProp() */\n  xmlNodePtr c_node ;\n  xmlNsPtr c_namespace;\n  VALUE definitions = rb_ary_new();\n\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  c_namespace = c_node->nsDef;\n  if (!c_namespace) {\n    return definitions;\n  }\n\n  while (c_namespace != NULL) {\n    rb_ary_push(definitions, noko_xml_namespace_wrap(c_namespace, c_node->doc));\n    c_namespace = c_namespace->next;\n  }\n\n  return definitions;\n}\n```\n\nReturns  \nNamespaces that are defined directly on this node, as an Array of [`Namespace`](namespace) objects. The array will be empty if no namespaces are defined on this node.\n\n**Example:**\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns=\"http://example.com/root\">\n    <first/>\n    <second xmlns=\"http://example.com/child\" xmlns:unused=\"http://example.com/unused\"/>\n    <foo:third xmlns:foo=\"http://example.com/foo\"/>\n  </root>\nEOF\ndoc.at_xpath(\"//root:first\", \"root\" => \"http://example.com/root\").namespace_definitions\n# => []\ndoc.at_xpath(\"//xmlns:second\", \"xmlns\" => \"http://example.com/child\").namespace_definitions\n# => [#(Namespace:0x3c { href = \"http://example.com/child\" }),\n#     #(Namespace:0x50 {\n#       prefix = \"unused\",\n#       href = \"http://example.com/unused\"\n#       })]\ndoc.at_xpath(\"//foo:third\", \"foo\" => \"http://example.com/foo\").namespace_definitions\n# => [#(Namespace:0x64 { prefix = \"foo\", href = \"http://example.com/foo\" })]\n```\n\nnamespace_scopes() → Array\\<Nokogiri::XML::Namespace\\> Show source\n\n``` c\nstatic VALUE\nrb_xml_node_namespace_scopes(VALUE rb_node)\n{\n  xmlNodePtr c_node ;\n  xmlNsPtr *namespaces;\n  VALUE scopes = rb_ary_new();\n  int j;\n\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  namespaces = xmlGetNsList(c_node->doc, c_node);\n  if (!namespaces) {\n    return scopes;\n  }\n\n  for (j = 0 ; namespaces[j] != NULL ; ++j) {\n    rb_ary_push(scopes, noko_xml_namespace_wrap(namespaces[j], c_node->doc));\n  }\n\n  xmlFree(namespaces);\n  return scopes;\n}\n```\n\nReturns  \nArray of all the Namespaces on this node and its ancestors.\n\nSee also [`#namespaces`](node#method-i-namespaces)\n\n**Example:**\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns=\"http://example.com/root\" xmlns:bar=\"http://example.com/bar\">\n    <first/>\n    <second xmlns=\"http://example.com/child\"/>\n    <third xmlns:foo=\"http://example.com/foo\"/>\n  </root>\nEOF\ndoc.at_xpath(\"//root:first\", \"root\" => \"http://example.com/root\").namespace_scopes\n# => [#(Namespace:0x3c { href = \"http://example.com/root\" }),\n#     #(Namespace:0x50 { prefix = \"bar\", href = \"http://example.com/bar\" })]\ndoc.at_xpath(\"//child:second\", \"child\" => \"http://example.com/child\").namespace_scopes\n# => [#(Namespace:0x64 { href = \"http://example.com/child\" }),\n#     #(Namespace:0x50 { prefix = \"bar\", href = \"http://example.com/bar\" })]\ndoc.at_xpath(\"//root:third\", \"root\" => \"http://example.com/root\").namespace_scopes\n# => [#(Namespace:0x78 { prefix = \"foo\", href = \"http://example.com/foo\" }),\n#     #(Namespace:0x3c { href = \"http://example.com/root\" }),\n#     #(Namespace:0x50 { prefix = \"bar\", href = \"http://example.com/bar\" })]\n```\n\nnamespaced_key?(attribute, namespace) Show source\n\n``` c\nstatic VALUE\nnamespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  if (xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),\n                   NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace))) {\n    return Qtrue;\n  }\n  return Qfalse;\n}\n```\n\nReturns true if `attribute` is set with `namespace`\n\nnamespaces() → Hash\\<String(Namespace#prefix) ⇒ String(Namespace#href)\\> Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1116\ndef namespaces\n  namespace_scopes.each_with_object({}) do |ns, hash|\n    prefix = ns.prefix\n    key = prefix ? \"xmlns:#{prefix}\" : \"xmlns\"\n    hash[key] = ns.href\n  end\nend\n```\n\nFetch all the namespaces on this node and its ancestors.\n\nNote that the keys in this hash [`XML`](../xml) attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix.\n\nThe default namespace for this node will be included with key “xmlns”.\n\nSee also [`#namespace_scopes`](node#method-i-namespace_scopes)\n\nReturns  \nHash containing all the namespaces on this node and its ancestors. The hash keys are the namespace prefix, and the hash value for each key is the namespace URI.\n\n**Example:**\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns=\"http://example.com/root\" xmlns:in_scope=\"http://example.com/in_scope\">\n    <first/>\n    <second xmlns=\"http://example.com/child\"/>\n    <third xmlns:foo=\"http://example.com/foo\"/>\n  </root>\nEOF\ndoc.at_xpath(\"//root:first\", \"root\" => \"http://example.com/root\").namespaces\n# => {\"xmlns\"=>\"http://example.com/root\",\n#     \"xmlns:in_scope\"=>\"http://example.com/in_scope\"}\ndoc.at_xpath(\"//child:second\", \"child\" => \"http://example.com/child\").namespaces\n# => {\"xmlns\"=>\"http://example.com/child\",\n#     \"xmlns:in_scope\"=>\"http://example.com/in_scope\"}\ndoc.at_xpath(\"//root:third\", \"root\" => \"http://example.com/root\").namespaces\n# => {\"xmlns:foo\"=>\"http://example.com/foo\",\n#     \"xmlns\"=>\"http://example.com/root\",\n#     \"xmlns:in_scope\"=>\"http://example.com/in_scope\"}\n```\n\ncontent= Show source\n\n``` c\nstatic VALUE\nset_native_content(VALUE self, VALUE content)\n{\n  xmlNodePtr node, child, next ;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  child = node->children;\n  while (NULL != child) {\n    next = child->next ;\n    xmlUnlinkNode(child) ;\n    noko_xml_document_pin_node(child);\n    child = next ;\n  }\n\n  xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));\n  return content;\n}\n```\n\nSet the content for this [`Node`](node)\n\nnext_element Show source\n\n``` c\nstatic VALUE\nnext_element(VALUE self)\n{\n  xmlNodePtr node, sibling;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  sibling = xmlNextElementSibling(node);\n  if (!sibling) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, sibling);\n}\n```\n\nReturns the next [`Nokogiri::XML::Element`](element) type sibling node.\n\nnext_sibling Show source\n\n``` c\nstatic VALUE\nnext_sibling(VALUE self)\n{\n  xmlNodePtr node, sibling;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  sibling = node->next;\n  if (!sibling) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, sibling) ;\n}\n```\n\nReturns the next sibling node\n\nAlso aliased as: [next](node#method-i-next)\n\nname Show source\n\n``` c\nstatic VALUE\nget_name(VALUE self)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  if (node->name) {\n    return NOKOGIRI_STR_NEW2(node->name);\n  }\n  return Qnil;\n}\n```\n\nReturns the name for this [`Node`](node)\n\nAlso aliased as: [name](node#method-i-name)\n\nnode_name=(new_name) Show source\n\n``` c\nstatic VALUE\nset_name(VALUE self, VALUE new_name)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  xmlNodeSetName(node, (xmlChar *)StringValueCStr(new_name));\n  return new_name;\n}\n```\n\nSet the name for this [`Node`](node)\n\nAlso aliased as: [name=](node#method-i-name-3D)\n\nnode_type Show source\n\n``` c\nstatic VALUE\nnode_type(VALUE self)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  return INT2NUM(node->type);\n}\n```\n\nGet the type for this [`Node`](node)\n\nAlso aliased as: [type](node#method-i-type)\n\nparent Show source\n\n``` c\nstatic VALUE\nget_parent(VALUE self)\n{\n  xmlNodePtr node, parent;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  parent = node->parent;\n  if (!parent) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, parent) ;\n}\n```\n\nGet the parent [`Node`](node) for this [`Node`](node)\n\nparse(string_or_io, options = nil) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1030\ndef parse(string_or_io, options = nil)\n  ##\n  # When the current node is unparented and not an element node, use the\n  # document as the parsing context instead. Otherwise, the in-context\n  # parser cannot find an element or a document node.\n  # Document Fragments are also not usable by the in-context parser.\n  if !element? && !document? && (!parent || parent.fragment?)\n    return document.parse(string_or_io, options)\n  end\n\n  options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  contents = if string_or_io.respond_to?(:read)\n    string_or_io.read\n  else\n    string_or_io\n  end\n\n  return Nokogiri::XML::NodeSet.new(document) if contents.empty?\n\n  # libxml2 does not obey the +recover+ option after encountering errors during +in_context+\n  # parsing, and so this horrible hack is here to try to emulate recovery behavior.\n  #\n  # Unfortunately, this means we're no longer parsing \"in context\" and so namespaces that\n  # would have been inherited from the context node won't be handled correctly. This hack was\n  # written in 2010, and I regret it, because it's silently degrading functionality in a way\n  # that's not easily prevented (or even detected).\n  #\n  # I think preferable behavior would be to either:\n  #\n  # a. add an error noting that we \"fell back\" and pointing the user to turning off the +recover+ option\n  # b. don't recover, but raise a sensible exception\n  #\n  # For context and background: https://github.com/sparklemotion/nokogiri/issues/313\n  # FIXME bug report: https://github.com/sparklemotion/nokogiri/issues/2092\n  error_count = document.errors.length\n  node_set = in_context(contents, options.to_i)\n  if node_set.empty? && (document.errors.length > error_count)\n    if options.recover?\n      fragment = document.related_class(\"DocumentFragment\").parse(contents)\n      node_set = fragment.children\n    else\n      raise document.errors[error_count]\n    end\n  end\n  node_set\nend\n```\n\nParse `string_or_io` as a document fragment within the context of **this** node. Returns a [`XML::NodeSet`](nodeset) containing the nodes parsed from `string_or_io`.\n\npath Show source\n\n``` c\nstatic VALUE\nrb_xml_node_path(VALUE rb_node)\n{\n  xmlNodePtr c_node;\n  xmlChar *c_path ;\n  VALUE rval;\n\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  c_path = xmlGetNodePath(c_node);\n  if (c_path == NULL) {\n    // see https://github.com/sparklemotion/nokogiri/issues/2250\n    // this behavior is clearly undesirable, but is what libxml <= 2.9.10 returned, and so we\n    // do this for now to preserve the behavior across libxml2 versions.\n    rval = NOKOGIRI_STR_NEW2(\"?\");\n  } else {\n    rval = NOKOGIRI_STR_NEW2(c_path);\n    xmlFree(c_path);\n  }\n\n  return rval ;\n}\n```\n\nReturns the path associated with this [`Node`](node)\n\npointer_id() → Integer Show source\n\n``` c\nstatic VALUE\nrb_xml_node_pointer_id(VALUE self)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  return rb_uint2inum((uintptr_t)(node));\n}\n```\n\nReturns  \nA unique id for this node based on the internal memory structures. This method is used by [`#==`](node#method-i-3D-3D) to determine node identity.\n\nprevious_element Show source\n\n``` c\nstatic VALUE\nprevious_element(VALUE self)\n{\n  xmlNodePtr node, sibling;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  /*\n   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.\n   */\n  sibling = node->prev;\n  if (!sibling) { return Qnil; }\n\n  while (sibling && sibling->type != XML_ELEMENT_NODE) {\n    sibling = sibling->prev;\n  }\n\n  return sibling ? noko_xml_node_wrap(Qnil, sibling) : Qnil ;\n}\n```\n\nReturns the previous [`Nokogiri::XML::Element`](element) type sibling node.\n\nprevious_sibling Show source\n\n``` c\nstatic VALUE\nprevious_sibling(VALUE self)\n{\n  xmlNodePtr node, sibling;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  sibling = node->prev;\n  if (!sibling) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, sibling);\n}\n```\n\nReturns the previous sibling node\n\nAlso aliased as: [previous](node#method-i-previous)\n\nprocessing_instruction?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1150\ndef processing_instruction?\n  type == PI_NODE\nend\n```\n\nReturns true if this is a [`ProcessingInstruction`](processinginstruction) node\n\nread_only?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1175\ndef read_only?\n  # According to gdome2, these are read-only node types\n  [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)\nend\n```\n\nIs this a read only node?\n\nrelated_class(class_name) → Class Show source\n\n``` ruby\n# File lib/nokogiri/class_resolver.rb, line 46\ndef related_class(class_name)\n  klass = nil\n  inspecting = self.class\n\n  while inspecting\n    namespace_path = inspecting.name.split(\"::\")[0..-2]\n    inspecting = inspecting.superclass\n\n    next unless VALID_NAMESPACES.include?(namespace_path.last)\n\n    related_class_name = (namespace_path << class_name).join(\"::\")\n    klass = begin\n      Object.const_get(related_class_name)\n    rescue NameError\n      nil\n    end\n    break if klass\n  end\n  klass\nend\n```\n\nIncluded from [Nokogiri::ClassResolver](../classresolver)\n\nFind a class constant within the\n\nSome examples:\n\n``` ruby\nNokogiri::XML::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::XML::DocumentFragment\nNokogiri::HTML4::Document.new.related_class(\"DocumentFragment\")\n# => Nokogiri::HTML4::DocumentFragment\n```\n\nNote this will also work for subclasses that follow the same convention, e.g.:\n\n``` ruby\nLoofah::HTML::Document.new.related_class(\"DocumentFragment\")\n# => Loofah::HTML::DocumentFragment\n```\n\nAnd even if it’s a subclass, this will iterate through the superclasses:\n\n``` ruby\nclass ThisIsATopLevelClass < Nokogiri::HTML4::Builder ; end\nThisIsATopLevelClass.new.related_class(\"Document\")\n# => Nokogiri::HTML4::Document\n```\n\ntext() → String\n\nAlias for: [content](node#method-i-content)\n\ntext?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1155\ndef text?\n  type == TEXT_NODE\nend\n```\n\nReturns true if this is a [`Text`](text) node\n\nto_s() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1190\ndef to_s\n  document.xml? ? to_xml : to_html\nend\n```\n\nTurn this node in to a string. If the document is [`HTML`](../html4), this method returns html. If the document is [`XML`](../xml), this method returns [`XML`](../xml).\n\nto_str() → String\n\nAlias for: [content](node#method-i-content)\n\ntraverse() { \\|self\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1233\ndef traverse(&block)\n  children.each { |j| j.traverse(&block) }\n  yield(self)\nend\n```\n\nYields self and all children to `block` recursively.\n\nnode_type\n\nAlias for: [node_type](node#method-i-node_type)\n\nunlink() → self Show source\n\n``` c\nstatic VALUE\nunlink_node(VALUE self)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  xmlUnlinkNode(node);\n  noko_xml_document_pin_node(node);\n  return self;\n}\n```\n\nUnlink this node from its current context.\n\nAlso aliased as: [remove](node#method-i-remove)\n\nxml?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1135\ndef xml?\n  type == DOCUMENT_NODE\nend\n```\n\nReturns true if this is an [`XML::Document`](document) node\n\n### Protected Instance Methods\n\ncoerce(data) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1473\n      def coerce(data)\n        case data\n        when XML::NodeSet\n          return data\n        when XML::DocumentFragment\n          return data.children\n        when String\n          return fragment(data).children\n        when Document, XML::Attr\n          # unacceptable\n        when XML::Node\n          return data\n        end\n\n        raise ArgumentError, <<~EOERR\n          Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.\n          (You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)\n        EOERR\n      end\n```\n\n## Manipulating Document Structure\n\n[↑ top](#top)\n\n### Public Instance Methods\n\n\\<\\<(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 256\ndef <<(node_or_tags)\n  add_child(node_or_tags)\n  self\nend\n```\n\nAdd `node_or_tags` as a child of this [`Node`](node).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns `self`, to support chaining of calls (e.g., root \\<\\< child1 \\<\\< child2)\n\nAlso see related method `add_child`.\n\nadd_child(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 148\ndef add_child(node_or_tags)\n  node_or_tags = coerce(node_or_tags)\n  if node_or_tags.is_a?(XML::NodeSet)\n    node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }\n  else\n    add_child_node_and_reparent_attrs(node_or_tags)\n  end\n  node_or_tags\nend\n```\n\nAdd `node_or_tags` as a child of this [`Node`](node).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).\n\nAlso see related method +\\<\\<+.\n\nadd_namespace(prefix, href) → Nokogiri::XML::Namespace\n\nAlias for: [add_namespace_definition](node#method-i-add_namespace_definition)\n\nadd_namespace_definition(prefix, href) → Nokogiri::XML::Namespace Show source\n\n``` c\nstatic VALUE\nrb_xml_node_add_namespace_definition(VALUE rb_node, VALUE rb_prefix, VALUE rb_href)\n{\n  xmlNodePtr c_node, element;\n  xmlNsPtr c_namespace;\n  const xmlChar *c_prefix = (const xmlChar *)(NIL_P(rb_prefix) ? NULL : StringValueCStr(rb_prefix));\n\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n  element = c_node ;\n\n  c_namespace = xmlSearchNs(c_node->doc, c_node, c_prefix);\n\n  if (!c_namespace) {\n    if (c_node->type != XML_ELEMENT_NODE) {\n      element = c_node->parent;\n    }\n    c_namespace = xmlNewNs(element, (const xmlChar *)StringValueCStr(rb_href), c_prefix);\n  }\n\n  if (!c_namespace) {\n    return Qnil ;\n  }\n\n  if (NIL_P(rb_prefix) || c_node != element) {\n    xmlSetNs(c_node, c_namespace);\n  }\n\n  return noko_xml_namespace_wrap(c_namespace, c_node->doc);\n}\n```\n\nAdds a namespace definition to this node with `prefix` using `href` value, as if this node had included an attribute “xmlns:prefix=href”.\n\nA default namespace definition for this node can be added by passing `nil` for `prefix`.\n\nParameters\n\n- `prefix` (String, `nil`) An [XML Name](https://www.w3.org/TR/xml-names/#ns-decl)\n\n- `href` (String) The [URI reference](https://www.w3.org/TR/xml-names/#sec-namespaces)\n\nReturns  \nThe new [`Nokogiri::XML::Namespace`](namespace)\n\n**Example:** adding a non-default namespace definition\n\n``` ruby\ndoc = Nokogiri::XML(\"<store><inventory></inventory></store>\")\ninventory = doc.at_css(\"inventory\")\ninventory.add_namespace_definition(\"automobile\", \"http://alices-autos.com/\")\ninventory.add_namespace_definition(\"bicycle\", \"http://bobs-bikes.com/\")\ninventory.add_child(\"<automobile:tire>Michelin model XGV, size 75R</automobile:tire>\")\ndoc.to_xml\n# => \"<?xml version=\\\"1.0\\\"?>\\n\" +\n#    \"<store>\\n\" +\n#    \"  <inventory xmlns:automobile=\\\"http://alices-autos.com/\\\" xmlns:bicycle=\\\"http://bobs-bikes.com/\\\">\\n\" +\n#    \"    <automobile:tire>Michelin model XGV, size 75R</automobile:tire>\\n\" +\n#    \"  </inventory>\\n\" +\n#    \"</store>\\n\"\n```\n\n**Example:** adding a default namespace definition\n\n``` ruby\ndoc = Nokogiri::XML(\"<store><inventory><tire>Michelin model XGV, size 75R</tire></inventory></store>\")\ndoc.at_css(\"tire\").add_namespace_definition(nil, \"http://bobs-bikes.com/\")\ndoc.to_xml\n# => \"<?xml version=\\\"1.0\\\"?>\\n\" +\n#    \"<store>\\n\" +\n#    \"  <inventory>\\n\" +\n#    \"    <tire xmlns=\\\"http://bobs-bikes.com/\\\">Michelin model XGV, size 75R</tire>\\n\" +\n#    \"  </inventory>\\n\" +\n#    \"</store>\\n\"\n```\n\nAlso aliased as: [add_namespace](node#method-i-add_namespace)\n\nadd_next_sibling(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 288\ndef add_next_sibling(node_or_tags)\n  raise ArgumentError,\n    \"A document may not have multiple root nodes.\" if parent&.document? && !(node_or_tags.comment? || node_or_tags.processing_instruction?)\n\n  add_sibling(:next, node_or_tags)\nend\n```\n\nInsert `node_or_tags` after this [`Node`](node) (as a sibling).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).\n\nAlso see related method `after`.\n\nAlso aliased as: [next=](node#method-i-next-3D)\n\nadd_previous_sibling(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 271\ndef add_previous_sibling(node_or_tags)\n  raise ArgumentError,\n    \"A document may not have multiple root nodes.\" if parent&.document? && !(node_or_tags.comment? || node_or_tags.processing_instruction?)\n\n  add_sibling(:previous, node_or_tags)\nend\n```\n\nInsert `node_or_tags` before this [`Node`](node) (as a sibling).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).\n\nAlso see related method `before`.\n\nAlso aliased as: [previous=](node#method-i-previous-3D)\n\nafter(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 318\ndef after(node_or_tags)\n  add_next_sibling(node_or_tags)\n  self\nend\n```\n\nInsert `node_or_tags` after this node (as a sibling).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a [`Nokogiri::XML::DocumentFragment`](documentfragment), or a String containing markup.\n\nReturns `self`, to support chaining of calls.\n\nAlso see related method `add_next_sibling`.\n\nbefore(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 304\ndef before(node_or_tags)\n  add_previous_sibling(node_or_tags)\n  self\nend\n```\n\nInsert `node_or_tags` before this node (as a sibling).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns `self`, to support chaining of calls.\n\nAlso see related method `add_previous_sibling`.\n\nchildren=(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 349\ndef children=(node_or_tags)\n  node_or_tags = coerce(node_or_tags)\n  children.unlink\n  if node_or_tags.is_a?(XML::NodeSet)\n    node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }\n  else\n    add_child_node_and_reparent_attrs(node_or_tags)\n  end\nend\n```\n\nSet the content for this [`Node`](node) `node_or_tags`\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a [`Nokogiri::XML::DocumentFragment`](documentfragment), or a String containing markup.\n\nAlso see related method `inner_html=`\n\ncontent=(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 411\ndef content=(string)\n  self.native_content = encode_special_chars(string.to_s)\nend\n```\n\nSet the Node’s content to a [`Text`](text) node containing `string`. The string gets [`XML`](../xml) escaped, not interpreted as markup.\n\ndefault_namespace=(url) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 427\ndef default_namespace=(url)\n  add_namespace_definition(nil, url)\nend\n```\n\nAdds a default namespace supplied as a string `url` href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed [`XML`](../xml). A default namespace set with this method will now show up in [`#attributes`](node#method-i-attributes), but when this node is serialized to [`XML`](../xml) an “xmlns” attribute will appear. See also [`#namespace`](node#method-i-namespace) and [`#namespace=`](node#method-i-namespace-3D)\n\ndo_xinclude(options = XML::ParseOptions::DEFAULT_XML) { \\|options\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 454\ndef do_xinclude(options = XML::ParseOptions::DEFAULT_XML)\n  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options\n  yield options if block_given?\n\n  # call c extension\n  process_xincludes(options.to_i)\nend\n```\n\nDo xinclude substitution on the subtree below node. If given a block, a [`Nokogiri::XML::ParseOptions`](parseoptions) object initialized from `options`, will be passed to it, allowing more convenient modification of the parser options.\n\ninner_html=(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 338\ndef inner_html=(node_or_tags)\n  self.children = node_or_tags\nend\n```\n\nSet the content for this [`Node`](node) to `node_or_tags`.\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a [`Nokogiri::XML::DocumentFragment`](documentfragment), or a String containing markup.\n\n⚠ Please note that despite the name, this method will **not** always parse a String argument as [`HTML`](../html4). A String argument will be parsed with the `DocumentFragment` parser related to this node’s document.\n\nFor example, if the document is an [`HTML4::Document`](../html4/document) then the string will be parsed as [`HTML4`](../html4) using [`HTML4::DocumentFragment`](../html4/documentfragment); but if the document is an [`XML::Document`](document) then it will parse the string as [`XML`](../xml) using [`XML::DocumentFragment`](documentfragment).\n\nAlso see related method `children=`\n\nname=(new_name)\n\nAlias for: [node_name=](node#method-i-node_name-3D)\n\nnamespace=(ns) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 437\ndef namespace=(ns)\n  return set_namespace(ns) unless ns\n\n  unless Nokogiri::XML::Namespace === ns\n    raise TypeError, \"#{ns.class} can't be coerced into Nokogiri::XML::Namespace\"\n  end\n  if ns.document != document\n    raise ArgumentError, \"namespace must be declared on the same document\"\n  end\n\n  set_namespace(ns)\nend\n```\n\nSet the default namespace on this node (as would be defined with an “xmlns=” attribute in [`XML`](../xml) source), as a [`Namespace`](namespace) object `ns`. Note that a [`Namespace`](namespace) added this way will NOT be serialized as an xmlns attribute for this node. You probably want [`#default_namespace=`](node#method-i-default_namespace-3D) instead, or perhaps [`#add_namespace_definition`](node#method-i-add_namespace_definition) with a nil prefix argument.\n\nnext_sibling\n\nAlias for: [next_sibling](node#method-i-next_sibling)\n\nnext=(node_or_tags)\n\nAlias for: [add_next_sibling](node#method-i-add_next_sibling)\n\nparent=(parent_node) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 417\ndef parent=(parent_node)\n  parent_node.add_child(self)\nend\n```\n\nSet the parent [`Node`](node) for this [`Node`](node)\n\nprepend_child(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 168\ndef prepend_child(node_or_tags)\n  if (first = children.first)\n    # Mimic the error add_child would raise.\n    raise \"Document already has a root node\" if document? && !(node_or_tags.comment? || node_or_tags.processing_instruction?)\n\n    first.__send__(:add_sibling, :previous, node_or_tags)\n  else\n    add_child(node_or_tags)\n  end\nend\n```\n\nAdd `node_or_tags` as the first child of this [`Node`](node).\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).\n\nAlso see related method `add_child`.\n\nprevious_sibling\n\nAlias for: [previous_sibling](node#method-i-previous_sibling)\n\nprevious=(node_or_tags)\n\nAlias for: [add_previous_sibling](node#method-i-add_previous_sibling)\n\nremove()\n\nAlias for: [unlink](node#method-i-unlink)\n\nreplace(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 369\ndef replace(node_or_tags)\n  raise(\"Cannot replace a node with no parent\") unless parent\n\n  # We cannot replace a text node directly, otherwise libxml will return\n  # an internal error at parser.c:13031, I don't know exactly why\n  # libxml is trying to find a parent node that is an element or document\n  # so I can't tell if this is bug in libxml or not. issue #775.\n  if text?\n    replacee = Nokogiri::XML::Node.new(\"dummy\", document)\n    add_previous_sibling_node(replacee)\n    unlink\n    return replacee.replace(node_or_tags)\n  end\n\n  node_or_tags = parent.coerce(node_or_tags)\n\n  if node_or_tags.is_a?(XML::NodeSet)\n    node_or_tags.each { |n| add_previous_sibling(n) }\n    unlink\n  else\n    replace_node(node_or_tags)\n  end\n  node_or_tags\nend\n```\n\nReplace this [`Node`](node) with `node_or_tags`.\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.\n\nReturns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).\n\nAlso see related method `swap`.\n\nswap(node_or_tags) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 403\ndef swap(node_or_tags)\n  replace(node_or_tags)\n  self\nend\n```\n\nSwap this [`Node`](node) for `node_or_tags`\n\n`node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String Containing markup.\n\nReturns self, to support chaining of calls.\n\nAlso see related method `replace`.\n\nwrap(markup) → self Show source\n\nwrap(node) → self\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 223\ndef wrap(node_or_tags)\n  case node_or_tags\n  when String\n    context_node = parent || document\n    new_parent = context_node.coerce(node_or_tags).first\n    if new_parent.nil?\n      raise \"Failed to parse '#{node_or_tags}' in the context of a '#{context_node.name}' element\"\n    end\n  when XML::Node\n    new_parent = node_or_tags.dup\n  else\n    raise ArgumentError, \"Requires a String or Node argument, and cannot accept a #{node_or_tags.class}\"\n  end\n\n  if parent\n    add_next_sibling(new_parent)\n  else\n    new_parent.unlink\n  end\n  new_parent.add_child(self)\n\n  self\nend\n```\n\nWrap this [`Node`](node) with the node parsed from `markup` or a dup of the `node`.\n\nParameters\n\n- **markup** (String) Markup that is parsed and used as the wrapper. This node’s parent, if it exists, is used as the context node for parsing; otherwise the associated document is used. If the parsed fragment has multiple roots, the first root node is used as the wrapper.\n\n- **node** ([`Nokogiri::XML::Node`](node)) An element that is ‘#dup\\`ed and used as the wrapper.\n\nReturns  \n`self`, to support chaining.\n\nAlso see [`NodeSet#wrap`](nodeset#method-i-wrap)\n\n**Example** with a `String` argument:\n\n``` ruby\ndoc = Nokogiri::HTML5(<<~HTML)\n  <html><body>\n    <a>asdf</a>\n  </body></html>\nHTML\ndoc.at_css(\"a\").wrap(\"<div></div>\")\ndoc.to_html\n# => <html><head></head><body>\n#      <div><a>asdf</a></div>\n#    </body></html>\n```\n\n**Example** with a `Node` argument:\n\n``` ruby\ndoc = Nokogiri::HTML5(<<~HTML)\n  <html><body>\n    <a>asdf</a>\n  </body></html>\nHTML\ndoc.at_css(\"a\").wrap(doc.create_element(\"div\"))\ndoc.to_html\n# <html><head></head><body>\n#   <div><a>asdf</a></div>\n# </body></html>\n```\n\n## Searching via XPath or CSS Queries\n\n[↑ top](#top)\n\n### Public Instance Methods\n\n%(\\*args)\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nAlias for: [at](searchable#method-i-at)\n\n/(\\*args)\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nAlias for: [search](searchable#method-i-search)\n\n\\>(selector) → NodeSet Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 196\ndef >(selector) # rubocop:disable Naming/BinaryOperatorParameterName\n  ns = (document.root&.namespaces || {})\n  xpath(CSS.xpath_for(selector, prefix: \"./\", ns: ns).first)\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this node’s immediate children using [`CSS`](../css) selector `selector`\n\nat(\\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 71\ndef at(*args)\n  search(*args).first\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for `paths`, and return only the first result. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.\n\nSee [`Searchable#search`](searchable#method-i-search) for more information.\n\nAlso aliased as: [%](searchable#method-i-25)\n\nat_css(\\*rules, \\[namespace-bindings, custom-pseudo-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 140\ndef at_css(*args)\n  css(*args).first\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for [`CSS`](../css) `rules`, and return only the first match. `rules` must be one or more [`CSS`](../css) selectors.\n\nSee [`Searchable#css`](searchable#method-i-css) for more information.\n\nat_xpath(\\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 188\ndef at_xpath(*args)\n  xpath(*args).first\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this node for [`XPath`](xpath) `paths`, and return only the first match. `paths` must be one or more [`XPath`](xpath) queries.\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) for more information.\n\ncss(\\*rules, \\[namespace-bindings, custom-pseudo-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 126\ndef css(*args)\n  rules, handler, ns, _ = extract_params(args)\n\n  css_internal(self, rules, handler, ns)\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:\n\n``` ruby\nnode.css('title')\nnode.css('body h1.bold')\nnode.css('div + p.green', 'div#one')\n```\n\nA hash of namespace bindings may be appended. For example:\n\n``` ruby\nnode.css('bike|tire', {'bike' => 'http://schwinn.com/'})\n```\n\n💡 Custom [`CSS`](../css) pseudo classes may also be defined which are mapped to a custom [`XPath`](xpath) function. To define custom pseudo classes, create a class and implement the custom pseudo class you want defined. The first argument to the method will be the matching context [`NodeSet`](nodeset). Any other arguments are ones that you pass in. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex(node_set, regex)\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.css('title:regex(\"\\w+\")', handler)\n```\n\n💡 Some [`XPath`](xpath) syntax is supported in [`CSS`](../css) queries. For example, to query for an attribute:\n\n``` ruby\nnode.css('img > @href') # returns all +href+ attributes on an +img+ element\nnode.css('img / @href') # same\n\n# ⚠ this returns +class+ attributes from all +div+ elements AND THEIR CHILDREN!\nnode.css('div @class')\n\nnode.css\n```\n\n💡 Array-like syntax is supported in [`CSS`](../css) queries as an alternative to using +:nth-child()+.\n\n⚠ NOTE that indices are 1-based like `:nth-child` and not 0-based like Ruby Arrays. For example:\n\n``` ruby\n# equivalent to 'li:nth-child(2)'\nnode.css('li[2]') # retrieve the second li element in a list\n```\n\n⚠ NOTE that the [`CSS`](../css) query string is case-sensitive with regards to your document type. [`HTML`](../html4) tags will match only lowercase [`CSS`](../css) queries, so if you search for “H1” in an [`HTML`](../html4) document, you’ll never find anything. However, “H1” might be found in an [`XML`](../xml) document, where tags names are case-sensitive (e.g., “H1” is distinct from “h1”).\n\nsearch(\\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 51\ndef search(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpaths = paths.map(&:to_s).map do |path|\n    LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)\n  end.flatten.uniq\n\n  xpath(*(xpaths + [ns, handler, binds].compact))\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries:\n\n``` ruby\nnode.search(\"div.employee\", \".//title\")\n```\n\nA hash of namespace bindings may be appended:\n\n``` ruby\nnode.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})\nnode.search('bike|tire', {'bike' => 'http://schwinn.com/'})\n```\n\nFor [`XPath`](xpath) queries, a hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions and [`CSS`](../css) pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex node_set, regex\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.search('.//title[regex(., \"\\w+\")]', 'div.employee:regex(\"[0-9]+\")', handler)\n```\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) and [`Searchable#css`](searchable#method-i-css) for further usage help.\n\nAlso aliased as: [/](searchable#method-i-2F)\n\nxpath(\\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 174\ndef xpath(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpath_internal(self, paths, handler, ns, binds)\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this node for [`XPath`](xpath) `paths`. `paths` must be one or more [`XPath`](xpath) queries.\n\n``` ruby\nnode.xpath('.//title')\n```\n\nA hash of namespace bindings may be appended. For example:\n\n``` ruby\nnode.xpath('.//foo:name', {'foo' => 'http://example.org/'})\nnode.xpath('.//xmlns:name', node.root.namespaces)\n```\n\nA hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.xpath('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex(node_set, regex)\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.xpath('.//title[regex(., \"\\w+\")]', handler)\n```\n\n## Serialization and Generating Output\n\n[↑ top](#top)\n\n### Public Instance Methods\n\ncanonicalize(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1398\ndef canonicalize(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)\n  c14n_root = self\n  document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|\n    tn = node.is_a?(XML::Node) ? node : parent\n    tn == c14n_root || tn.ancestors.include?(c14n_root)\n  end\nend\n```\n\ndeconstruct_keys(array_of_names) → Hash Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1459\ndef deconstruct_keys(keys)\n  requested_keys = DECONSTRUCT_KEYS & keys\n  {}.tap do |values|\n    requested_keys.each do |key|\n      method = DECONSTRUCT_METHODS[key] || key\n      values[key] = send(method)\n    end\n  end\nend\n```\n\nReturns a hash describing the [`Node`](node), to use in pattern matching.\n\nValid keys and their values:\n\n- `name` → (String) The name of this node, or “text” if it is a [`Text`](text) node.\n\n- `namespace` → ([`Namespace`](namespace), nil) The namespace of this node, or nil if there is no namespace.\n\n- `attributes` → (Array\\<Attr\\>) The attributes of this node.\n\n- `children` → (Array\\<Node\\>) The children of this node. 💡 Note this includes text nodes.\n\n- `elements` → (Array\\<Node\\>) The child elements of this node. 💡 Note this does not include text nodes.\n\n- `content` → (String) The contents of all the text nodes in this node’s subtree. See [`#content`](node#method-i-content).\n\n- `inner_html` → (String) The inner markup for the children of this node. See [`#inner_html`](node#method-i-inner_html).\n\n⚡ This is an experimental feature, available since v1.14.0\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML.parse(<<~XML)\n  <?xml version=\"1.0\"?>\n  <parent xmlns=\"http://nokogiri.org/ns/default\" xmlns:noko=\"http://nokogiri.org/ns/noko\">\n    <child1 foo=\"abc\" noko:bar=\"def\">First</child1>\n    <noko:child2 foo=\"qwe\" noko:bar=\"rty\">Second</noko:child2>\n  </parent>\nXML\n\ndoc.root.deconstruct_keys([:name, :namespace])\n# => {:name=>\"parent\",\n#     :namespace=>\n#      #(Namespace:0x35c { href = \"http://nokogiri.org/ns/default\" })}\n\ndoc.root.deconstruct_keys([:inner_html, :content])\n# => {:content=>\"\\n\" + \"  First\\n\" + \"  Second\\n\",\n#     :inner_html=>\n#      \"\\n\" +\n#      \"  <child1 foo=\\\"abc\\\" noko:bar=\\\"def\\\">First</child1>\\n\" +\n#      \"  <noko:child2 foo=\\\"qwe\\\" noko:bar=\\\"rty\\\">Second</noko:child2>\\n\"}\n\ndoc.root.elements.first.deconstruct_keys([:attributes])\n# => {:attributes=>\n#      [#(Attr:0x370 { name = \"foo\", value = \"abc\" }),\n#       #(Attr:0x384 {\n#         name = \"bar\",\n#         namespace = #(Namespace:0x398 {\n#           prefix = \"noko\",\n#           href = \"http://nokogiri.org/ns/noko\"\n#           }),\n#         value = \"def\"\n#         })]}\n```\n\nserialize(\\*args, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1280\ndef serialize(*args, &block)\n  options = if args.first.is_a?(Hash)\n    args.shift\n  else\n    {\n      encoding: args[0],\n      save_with: args[1],\n    }\n  end\n\n  options[:encoding] ||= document.encoding\n  encoding = Encoding.find(options[:encoding] || \"UTF-8\")\n\n  io = StringIO.new(String.new(encoding: encoding))\n\n  write_to(io, options, &block)\n  io.string\nend\n```\n\nSerialize [`Node`](node) using `options`. Save options can also be set using a block.\n\nSee also [`Nokogiri::XML::Node::SaveOptions`](node/saveoptions) and [Serialization and Generating Output at `Node`](node#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output).\n\nThese two statements are equivalent:\n\n``` ruby\nnode.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)\n```\n\nor\n\n``` ruby\nnode.serialize(:encoding => 'UTF-8') do |config|\n  config.format.as_xml\nend\n```\n\nto_html(options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1306\ndef to_html(options = {})\n  to_format(SaveOptions::DEFAULT_HTML, options)\nend\n```\n\nSerialize this [`Node`](node) to [`HTML`](../html4)\n\n``` ruby\ndoc.to_html\n```\n\nSee [`Node#write_to`](node#method-i-write_to) for a list of `options`. For formatted output, use [`Node#to_xhtml`](node#method-i-to_xhtml) instead.\n\nto_xhtml(options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1327\ndef to_xhtml(options = {})\n  to_format(SaveOptions::DEFAULT_XHTML, options)\nend\n```\n\nSerialize this [`Node`](node) to XHTML using `options`\n\n``` ruby\ndoc.to_xhtml(:indent => 5, :encoding => 'UTF-8')\n```\n\nSee [`Node#write_to`](node#method-i-write_to) for a list of `options`\n\nto_xml(options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1316\ndef to_xml(options = {})\n  options[:save_with] ||= SaveOptions::DEFAULT_XML\n  serialize(options)\nend\n```\n\nSerialize this [`Node`](node) to [`XML`](../xml) using `options`\n\n``` ruby\ndoc.to_xml(:indent => 5, :encoding => 'UTF-8')\n```\n\nSee [`Node#write_to`](node#method-i-write_to) for a list of `options`\n\nwrite_html_to(io, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1375\ndef write_html_to(io, options = {})\n  write_format_to(SaveOptions::DEFAULT_HTML, io, options)\nend\n```\n\nWrite [`Node`](node) as [`HTML`](../html4) to `io` with `options`\n\nSee [`Node#write_to`](node#method-i-write_to) for a list of `options`\n\nwrite_to(io, \\*options) { \\|config\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1348\ndef write_to(io, *options)\n  options = options.first.is_a?(Hash) ? options.shift : {}\n  encoding = options[:encoding] || options[0]\n  if Nokogiri.jruby?\n    save_options = options[:save_with] || options[1]\n    indent_times = options[:indent] || 0\n  else\n    save_options = options[:save_with] || options[1] || SaveOptions::FORMAT\n    indent_times = options[:indent] || 2\n  end\n  indent_text = options[:indent_text] || \" \"\n\n  # Any string times 0 returns an empty string. Therefore, use the same\n  # string instead of generating a new empty string for every node with\n  # zero indentation.\n  indentation = indent_times.zero? ? \"\" : (indent_text * indent_times)\n\n  config = SaveOptions.new(save_options.to_i)\n  yield config if block_given?\n\n  native_write_to(io, encoding, indentation, config.options)\nend\n```\n\nWrite [`Node`](node) to `io` with `options`. `options` modify the output of this method. Valid options are:\n\n- `:encoding` for changing the encoding\n\n- `:indent_text` the indentation text, defaults to one space\n\n- `:indent` the number of `:indent_text` to use, defaults to 2\n\n- `:save_with` a combination of [`SaveOptions`](node/saveoptions) constants.\n\nTo save with UTF-8 indented twice:\n\n``` ruby\nnode.write_to(io, :encoding => 'UTF-8', :indent => 2)\n```\n\nTo save indented with two dashes:\n\n``` ruby\nnode.write_to(io, :indent_text => '-', :indent => 2)\n```\n\nwrite_xhtml_to(io, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1383\ndef write_xhtml_to(io, options = {})\n  write_format_to(SaveOptions::DEFAULT_XHTML, io, options)\nend\n```\n\nWrite [`Node`](node) as XHTML to `io` with `options`\n\nSee [`Node#write_to`](node#method-i-write_to) for a list of `options`\n\nwrite_xml_to(io, options = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 1393\ndef write_xml_to(io, options = {})\n  options[:save_with] ||= SaveOptions::DEFAULT_XML\n  write_to(io, options)\nend\n```\n\nWrite [`Node`](node) as [`XML`](../xml) to `io` with `options`\n\n``` ruby\ndoc.write_xml_to io, :encoding => 'UTF-8'\n```\n\nSee [`Node#write_to`](node#method-i-write_to) for a list of options\n\n## Traversing Document Structure\n\n[↑ top](#top)\n\n### Public Instance Methods\n\nchild() → Nokogiri::XML::Node Show source\n\n``` c\nstatic VALUE\nrb_xml_node_child(VALUE self)\n{\n  xmlNodePtr node, child;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  child = node->children;\n  if (!child) { return Qnil; }\n\n  return noko_xml_node_wrap(Qnil, child);\n}\n```\n\nReturns  \nFirst of this node’s children, or `nil` if there are no children\n\nThis is a convenience method and is equivalent to:\n\n``` ruby\nnode.children.first\n```\n\nSee related: [`#children`](node#method-i-children)\n\nchildren() → Nokogiri::XML::NodeSet Show source\n\n``` c\nstatic VALUE\nrb_xml_node_children(VALUE self)\n{\n  xmlNodePtr node;\n  xmlNodePtr child;\n  xmlNodeSetPtr set;\n  VALUE document;\n  VALUE node_set;\n\n  Noko_Node_Get_Struct(self, xmlNode, node);\n\n  child = node->children;\n  set = xmlXPathNodeSetCreate(child);\n\n  document = DOC_RUBY_OBJECT(node->doc);\n\n  if (!child) { return noko_xml_node_set_wrap(set, document); }\n\n  child = child->next;\n  while (NULL != child) {\n    xmlXPathNodeSetAddUnique(set, child);\n    child = child->next;\n  }\n\n  node_set = noko_xml_node_set_wrap(set, document);\n\n  return node_set;\n}\n```\n\nReturns  \n[`Nokogiri::XML::NodeSet`](nodeset) containing this node’s children.\n\ndocument() → Nokogiri::XML::Document Show source\n\n``` c\nstatic VALUE\nrb_xml_node_document(VALUE self)\n{\n  xmlNodePtr node;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  return DOC_RUBY_OBJECT(node->doc);\n}\n```\n\nReturns  \nParent [`Nokogiri::XML::Document`](document) for this node\n\n## Working With Node Attributes\n\n[↑ top](#top)\n\n### Public Instance Methods\n\n\\[\\](name) → (String, nil) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 512\ndef [](name)\n  get(name.to_s)\nend\n```\n\nFetch an attribute from this node.\n\n⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes, use [`#attribute_with_ns`](node#method-i-attribute_with_ns).\n\nReturns  \n(String, nil) value of the attribute `name`, or `nil` if no matching attribute exists\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML(\"<root><child size='large' class='big wide tall'/></root>\")\nchild = doc.at_css(\"child\")\nchild[\"size\"] # => \"large\"\nchild[\"class\"] # => \"big wide tall\"\n```\n\n**Example:** Namespaced attributes will not be returned.\n\n⚠ Note namespaced attributes may be accessed with [`#attribute`](node#method-i-attribute) or [`#attribute_with_ns`](node#method-i-attribute_with_ns)\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns:width='http://example.com/widths'>\n    <child width:size='broad'/>\n  </root>\nEOF\ndoc.at_css(\"child\")[\"size\"] # => nil\ndoc.at_css(\"child\").attribute(\"size\").value # => \"broad\"\ndoc.at_css(\"child\").attribute_with_ns(\"size\", \"http://example.com/widths\").value\n# => \"broad\"\n```\n\nAlso aliased as: [get_attribute](node#method-i-get_attribute), [attr](node#method-i-attr)\n\n\\[\\]=(name, value) → value Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 550\ndef []=(name, value)\n  set(name.to_s, value.to_s)\nend\n```\n\nUpdate the attribute `name` to `value`, or create the attribute if it does not exist.\n\n⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes for update, use [`#attribute_with_ns`](node#method-i-attribute_with_ns). To add a namespaced attribute, see the example below.\n\nReturns  \n`value`\n\n**Example**\n\n``` ruby\ndoc = Nokogiri::XML(\"<root><child/></root>\")\nchild = doc.at_css(\"child\")\nchild[\"size\"] = \"broad\"\nchild.to_html\n# => \"<child size=\\\"broad\\\"></child>\"\n```\n\n**Example:** Add a namespaced attribute.\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns:width='http://example.com/widths'>\n    <child/>\n  </root>\nEOF\nchild = doc.at_css(\"child\")\nchild[\"size\"] = \"broad\"\nns = doc.root.namespace_definitions.find { |ns| ns.prefix == \"width\" }\nchild.attribute(\"size\").namespace = ns\ndoc.to_html\n# => \"<root xmlns:width=\\\"http://example.com/widths\\\">\\n\" +\n#    \"  <child width:size=\\\"broad\\\"></child>\\n\" +\n#    \"</root>\\n\"\n```\n\nAlso aliased as: [set_attribute](node#method-i-set_attribute)\n\nadd_class(names) → self Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 715\ndef add_class(names)\n  kwattr_add(\"class\", names)\nend\n```\n\nEnsure [`HTML`](../html4) [`CSS`](../css) classes are present on `self`. Any [`CSS`](../css) classes in `names` that already exist in the “class” attribute are *not* added. Note that any existing duplicates in the “class” attribute are not removed. Compare with [`#append_class`](node#method-i-append_class).\n\nThis is a convenience function and is equivalent to:\n\n``` ruby\nnode.kwattr_add(\"class\", names)\n```\n\nSee related: [`#kwattr_add`](node#method-i-kwattr_add), [`#classes`](node#method-i-classes), [`#append_class`](node#method-i-append_class), [`#remove_class`](node#method-i-remove_class)\n\nParameters\n\n- `names` (String, Array\\<String\\>)\n\n  [`CSS`](../css) class names to be added to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will not be added. Any class names not present will be added. If no “class” attribute exists, one is created.\n\nReturns  \n`self` ([`Node`](node)) for ease of chaining method calls.\n\n**Example:** Ensure that the node has [`CSS`](../css) class “section”\n\n``` ruby\nnode                      # => <div></div>\nnode.add_class(\"section\") # => <div class=\"section\"></div>\nnode.add_class(\"section\") # => <div class=\"section\"></div> # duplicate not added\n```\n\n**Example:** Ensure that the node has [`CSS`](../css) classes “section” and “header”, via a String argument\n\nNote that the [`CSS`](../css) class “section” is not added because it is already present. Note also that the pre-existing duplicate [`CSS`](../css) class “section” is not removed.\n\n``` ruby\nnode                             # => <div class=\"section section\"></div>\nnode.add_class(\"section header\") # => <div class=\"section section header\"></div>\n```\n\n**Example:** Ensure that the node has [`CSS`](../css) classes “section” and “header”, via an Array argument\n\n``` ruby\nnode                                  # => <div></div>\nnode.add_class([\"section\", \"header\"]) # => <div class=\"section header\"></div>\n```\n\nappend_class(names) → self Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 759\ndef append_class(names)\n  kwattr_append(\"class\", names)\nend\n```\n\nAdd [`HTML`](../html4) [`CSS`](../css) classes to `self`, regardless of duplication. Compare with [`#add_class`](node#method-i-add_class).\n\nThis is a convenience function and is equivalent to:\n\n``` ruby\nnode.kwattr_append(\"class\", names)\n```\n\nSee related: [`#kwattr_append`](node#method-i-kwattr_append), [`#classes`](node#method-i-classes), [`#add_class`](node#method-i-add_class), [`#remove_class`](node#method-i-remove_class)\n\nParameters\n\n- `names` (String, Array\\<String\\>)\n\n  [`CSS`](../css) class names to be appended to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. All class names passed in will be appended to the “class” attribute even if they are already present in the attribute value. If no “class” attribute exists, one is created.\n\nReturns  \n`self` ([`Node`](node)) for ease of chaining method calls.\n\n**Example:** Append “section” to the node’s [`CSS`](../css) “class” attribute\n\n``` ruby\nnode                         # => <div></div>\nnode.append_class(\"section\") # => <div class=\"section\"></div>\nnode.append_class(\"section\") # => <div class=\"section section\"></div> # duplicate added!\n```\n\n**Example:** Append “section” and “header” to the noded’s [`CSS`](../css) “class” attribute, via a String argument\n\nNote that the [`CSS`](../css) class “section” is appended even though it is already present\n\n``` ruby\nnode                                # => <div class=\"section section\"></div>\nnode.append_class(\"section header\") # => <div class=\"section section section header\"></div>\n```\n\n**Example:** Append “section” and “header” to the node’s [`CSS`](../css) “class” attribute, via an Array argument\n\n``` ruby\nnode                                     # => <div></div>\nnode.append_class([\"section\", \"header\"]) # => <div class=\"section header\"></div>\nnode.append_class([\"section\", \"header\"]) # => <div class=\"section header section header\"></div>\n```\n\nattr(name)\n\nAlias for: [\\[\\]](node#method-i-5B-5D)\n\nattribute(name) → Nokogiri::XML::Attr Show source\n\n``` c\nstatic VALUE\nrb_xml_node_attribute(VALUE self, VALUE name)\n{\n  xmlNodePtr node;\n  xmlAttrPtr prop;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));\n\n  if (! prop) { return Qnil; }\n  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);\n}\n```\n\nReturns  \nAttribute ([`Nokogiri::XML::Attr`](attr)) belonging to this node with name `name`.\n\n⚠ Note that attribute namespaces are ignored and only the simple (non-namespace-prefixed) name is used to find a matching attribute. In case of a simple name collision, only one of the matching attributes will be returned. In this case, you will need to use [`#attribute_with_ns`](node#method-i-attribute_with_ns).\n\n**Example:**\n\n``` ruby\ndoc = Nokogiri::XML(\"<root><child size='large' class='big wide tall'/></root>\")\nchild = doc.at_css(\"child\")\nchild.attribute(\"size\") # => #<Nokogiri::XML::Attr:0x550 name=\"size\" value=\"large\">\nchild.attribute(\"class\") # => #<Nokogiri::XML::Attr:0x564 name=\"class\" value=\"big wide tall\">\n```\n\n**Example** showing that namespaced attributes will not be returned:\n\n⚠ Note that only one of the two matching attributes is returned.\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns:width='http://example.com/widths'\n        xmlns:height='http://example.com/heights'>\n    <child width:size='broad' height:size='tall'/>\n  </root>\nEOF\ndoc.at_css(\"child\").attribute(\"size\")\n# => #(Attr:0x550 {\n#      name = \"size\",\n#      namespace = #(Namespace:0x564 {\n#        prefix = \"width\",\n#        href = \"http://example.com/widths\"\n#        }),\n#      value = \"broad\"\n#      })\n```\n\nattribute_nodes() → Array\\<Nokogiri::XML::Attr\\> Show source\n\n``` c\nstatic VALUE\nrb_xml_node_attribute_nodes(VALUE rb_node)\n{\n  xmlNodePtr c_node;\n\n  Noko_Node_Get_Struct(rb_node, xmlNode, c_node);\n\n  return noko_xml_node_attrs(c_node);\n}\n```\n\nReturns  \nAttributes (an Array of [`Nokogiri::XML::Attr`](attr)) belonging to this node.\n\nNote that this is the preferred alternative to [`#attributes`](node#method-i-attributes) when the simple (non-namespace-prefixed) attribute names may collide.\n\n**Example:**\n\nContrast this with the colliding-name example from [`#attributes`](node#method-i-attributes).\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns:width='http://example.com/widths'\n        xmlns:height='http://example.com/heights'>\n    <child width:size='broad' height:size='tall'/>\n  </root>\nEOF\ndoc.at_css(\"child\").attribute_nodes\n# => [#(Attr:0x550 {\n#       name = \"size\",\n#       namespace = #(Namespace:0x564 {\n#         prefix = \"width\",\n#         href = \"http://example.com/widths\"\n#         }),\n#       value = \"broad\"\n#       }),\n#     #(Attr:0x578 {\n#       name = \"size\",\n#       namespace = #(Namespace:0x58c {\n#         prefix = \"height\",\n#         href = \"http://example.com/heights\"\n#         }),\n#       value = \"tall\"\n#       })]\n```\n\nattribute_with_ns(name, namespace) → Nokogiri::XML::Attr Show source\n\n``` c\nstatic VALUE\nrb_xml_node_attribute_with_ns(VALUE self, VALUE name, VALUE namespace)\n{\n  xmlNodePtr node;\n  xmlAttrPtr prop;\n  Noko_Node_Get_Struct(self, xmlNode, node);\n  prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),\n                      NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));\n\n  if (! prop) { return Qnil; }\n  return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);\n}\n```\n\nReturns  \nAttribute ([`Nokogiri::XML::Attr`](attr)) belonging to this node with matching `name` and `namespace`.\n\n- `name` (String): the simple (non-namespace-prefixed) name of the attribute\n\n- `namespace` (String): the URI of the attribute’s namespace\n\nSee related: [`#attribute`](node#method-i-attribute)\n\n**Example:**\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns:width='http://example.com/widths'\n        xmlns:height='http://example.com/heights'>\n    <child width:size='broad' height:size='tall'/>\n  </root>\nEOF\ndoc.at_css(\"child\").attribute_with_ns(\"size\", \"http://example.com/widths\")\n# => #(Attr:0x550 {\n#      name = \"size\",\n#      namespace = #(Namespace:0x564 {\n#        prefix = \"width\",\n#        href = \"http://example.com/widths\"\n#        }),\n#      value = \"broad\"\n#      })\ndoc.at_css(\"child\").attribute_with_ns(\"size\", \"http://example.com/heights\")\n# => #(Attr:0x578 {\n#      name = \"size\",\n#      namespace = #(Namespace:0x58c {\n#        prefix = \"height\",\n#        href = \"http://example.com/heights\"\n#        }),\n#      value = \"tall\"\n#      })\n```\n\nattributes() → Hash\\<String ⇒ Nokogiri::XML::Attr\\> Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 609\ndef attributes\n  attribute_nodes.each_with_object({}) do |node, hash|\n    hash[node.node_name] = node\n  end\nend\n```\n\nFetch this node’s attributes.\n\n⚠ Because the keys do not include any namespace information for the attribute, in case of a simple name collision, not all attributes will be returned. In this case, you will need to use [`#attribute_nodes`](node#method-i-attribute_nodes).\n\nReturns  \nHash containing attributes belonging to `self`. The hash keys are String attribute names (without the namespace), and the hash values are [`Nokogiri::XML::Attr`](attr).\n\n**Example** with no namespaces:\n\n``` ruby\ndoc = Nokogiri::XML(\"<root><child size='large' class='big wide tall'/></root>\")\ndoc.at_css(\"child\").attributes\n# => {\"size\"=>#(Attr:0x550 { name = \"size\", value = \"large\" }),\n#     \"class\"=>#(Attr:0x564 { name = \"class\", value = \"big wide tall\" })}\n```\n\n**Example** with a namespace:\n\n``` ruby\ndoc = Nokogiri::XML(\"<root xmlns:desc='http://example.com/sizes'><child desc:size='large'/></root>\")\ndoc.at_css(\"child\").attributes\n# => {\"size\"=>\n#      #(Attr:0x550 {\n#        name = \"size\",\n#        namespace = #(Namespace:0x564 {\n#          prefix = \"desc\",\n#          href = \"http://example.com/sizes\"\n#          }),\n#        value = \"large\"\n#        })}\n```\n\n**Example** with an attribute name collision:\n\n⚠ Note that only one of the attributes is returned in the Hash.\n\n``` ruby\ndoc = Nokogiri::XML(<<~EOF)\n  <root xmlns:width='http://example.com/widths'\n        xmlns:height='http://example.com/heights'>\n    <child width:size='broad' height:size='tall'/>\n  </root>\nEOF\ndoc.at_css(\"child\").attributes\n# => {\"size\"=>\n#      #(Attr:0x550 {\n#        name = \"size\",\n#        namespace = #(Namespace:0x564 {\n#          prefix = \"height\",\n#          href = \"http://example.com/heights\"\n#          }),\n#        value = \"tall\"\n#        })}\n```\n\nclasses() → Array\\<String\\> Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 669\ndef classes\n  kwattr_values(\"class\")\nend\n```\n\nFetch [`CSS`](../css) class names of a [`Node`](node).\n\nThis is a convenience function and is equivalent to:\n\n``` ruby\nnode.kwattr_values(\"class\")\n```\n\nSee related: [`#kwattr_values`](node#method-i-kwattr_values), [`#add_class`](node#method-i-add_class), [`#append_class`](node#method-i-append_class), [`#remove_class`](node#method-i-remove_class)\n\nReturns  \nThe [`CSS`](../css) classes (Array of String) present in the Node’s “class” attribute. If the attribute is empty or non-existent, the return value is an empty array.\n\n**Example**\n\n``` ruby\nnode         # => <div class=\"section title header\"></div>\nnode.classes # => [\"section\", \"title\", \"header\"]\n```\n\ndelete(name)\n\nAlias for: [remove_attribute](node#method-i-remove_attribute)\n\neach() { \\|node_name, value\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 635\ndef each\n  attribute_nodes.each do |node|\n    yield [node.node_name, node.value]\n  end\nend\n```\n\nIterate over each attribute name and value pair for this [`Node`](node).\n\nget_attribute(name)\n\nAlias for: [\\[\\]](node#method-i-5B-5D)\n\nhas_attribute?(p1)\n\nAlias for: [key?](node#method-i-key-3F)\n\nkeys() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 629\ndef keys\n  attribute_nodes.map(&:node_name)\nend\n```\n\nGet the attribute names for this [`Node`](node).\n\nkwattr_add(attribute_name, keywords) → self Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 892\ndef kwattr_add(attribute_name, keywords)\n  keywords = keywordify(keywords)\n  current_kws = kwattr_values(attribute_name)\n  new_kws = (current_kws + (keywords - current_kws)).join(\" \")\n  set_attribute(attribute_name, new_kws)\n  self\nend\n```\n\nEnsure that values are present in a keyword attribute.\n\nAny values in `keywords` that already exist in the Node’s attribute values are *not* added. Note that any existing duplicates in the attribute values are not removed. Compare with [`#kwattr_append`](node#method-i-kwattr_append).\n\nA “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).\n\nSee also [`#add_class`](node#method-i-add_class), [`#kwattr_values`](node#method-i-kwattr_values), [`#kwattr_append`](node#method-i-kwattr_append), [`#kwattr_remove`](node#method-i-kwattr_remove)\n\nParameters\n\n- `attribute_name` (String) The name of the keyword attribute to be modified.\n\n- `keywords` (String, Array\\<String\\>) Keywords to be added to the attribute named `attribute_name`. May be a string containing whitespace-delimited values, or an Array of String values. Any values already present will not be added. Any values not present will be added. If the named attribute does not exist, it is created.\n\nReturns  \n`self` ([`Nokogiri::XML::Node`](node)) for ease of chaining method calls.\n\n**Example:** Ensure that a `Node` has “nofollow” in its `rel` attribute.\n\nNote that duplicates are not added.\n\n``` ruby\nnode                               # => <a></a>\nnode.kwattr_add(\"rel\", \"nofollow\") # => <a rel=\"nofollow\"></a>\nnode.kwattr_add(\"rel\", \"nofollow\") # => <a rel=\"nofollow\"></a>\n```\n\n**Example:** Ensure that a `Node` has “nofollow” and “noreferrer” in its `rel` attribute, via a String argument.\n\n    Note that \"nofollow\" is not added because it is already present. Note also that the\n    pre-existing duplicate \"nofollow\" is not removed.\n\n     node                                          # => <a rel=\"nofollow nofollow\"></a>\n     node.kwattr_add(\"rel\", \"nofollow noreferrer\") # => <a rel=\"nofollow nofollow noreferrer\"></a>\n\n**Example:** Ensure that a `Node` has “nofollow” and “noreferrer” in its `rel` attribute, via an Array argument.\n\n``` ruby\nnode                                               # => <a></a>\nnode.kwattr_add(\"rel\", [\"nofollow\", \"noreferrer\"]) # => <a rel=\"nofollow noreferrer\"></a>\n```\n\nSince v1.11.0\n\nkwattr_append(attribute_name, keywords) → self Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 945\ndef kwattr_append(attribute_name, keywords)\n  keywords = keywordify(keywords)\n  current_kws = kwattr_values(attribute_name)\n  new_kws = (current_kws + keywords).join(\" \")\n  set_attribute(attribute_name, new_kws)\n  self\nend\n```\n\nAdd keywords to a Node’s keyword attribute, regardless of duplication. Compare with [`#kwattr_add`](node#method-i-kwattr_add).\n\nA “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).\n\nSee also [`#append_class`](node#method-i-append_class), [`#kwattr_values`](node#method-i-kwattr_values), [`#kwattr_add`](node#method-i-kwattr_add), [`#kwattr_remove`](node#method-i-kwattr_remove)\n\nParameters\n\n- `attribute_name` (String) The name of the keyword attribute to be modified.\n\n- `keywords` (String, Array\\<String\\>) Keywords to be added to the attribute named `attribute_name`. May be a string containing whitespace-delimited values, or an Array of String values. All values passed in will be appended to the named attribute even if they are already present in the attribute. If the named attribute does not exist, it is created.\n\nReturns  \n`self` ([`Node`](node)) for ease of chaining method calls.\n\n**Example:** Append “nofollow” to the `rel` attribute.\n\nNote that duplicates are added.\n\n``` ruby\nnode                                  # => <a></a>\nnode.kwattr_append(\"rel\", \"nofollow\") # => <a rel=\"nofollow\"></a>\nnode.kwattr_append(\"rel\", \"nofollow\") # => <a rel=\"nofollow nofollow\"></a>\n```\n\n**Example:** Append “nofollow” and “noreferrer” to the `rel` attribute, via a String argument.\n\nNote that “nofollow” is appended even though it is already present.\n\n``` ruby\nnode                                             # => <a rel=\"nofollow\"></a>\nnode.kwattr_append(\"rel\", \"nofollow noreferrer\") # => <a rel=\"nofollow nofollow noreferrer\"></a>\n```\n\n**Example:** Append “nofollow” and “noreferrer” to the `rel` attribute, via an Array argument.\n\n``` ruby\nnode                                                  # => <a></a>\nnode.kwattr_append(\"rel\", [\"nofollow\", \"noreferrer\"]) # => <a rel=\"nofollow noreferrer\"></a>\n```\n\nSince v1.11.0\n\nkwattr_remove(attribute_name, keywords) → self Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 988\ndef kwattr_remove(attribute_name, keywords)\n  if keywords.nil?\n    remove_attribute(attribute_name)\n    return self\n  end\n\n  keywords = keywordify(keywords)\n  current_kws = kwattr_values(attribute_name)\n  new_kws = current_kws - keywords\n  if new_kws.empty?\n    remove_attribute(attribute_name)\n  else\n    set_attribute(attribute_name, new_kws.join(\" \"))\n  end\n  self\nend\n```\n\nRemove keywords from a keyword attribute. Any matching keywords that exist in the named attribute are removed, including any multiple entries.\n\nIf no keywords remain after this operation, or if `keywords` is `nil`, the attribute is deleted from the node.\n\nA “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).\n\nSee also [`#remove_class`](node#method-i-remove_class), [`#kwattr_values`](node#method-i-kwattr_values), [`#kwattr_add`](node#method-i-kwattr_add), [`#kwattr_append`](node#method-i-kwattr_append)\n\nParameters\n\n- `attribute_name` (String) The name of the keyword attribute to be modified.\n\n- `keywords` (String, Array\\<String\\>) Keywords to be removed from the attribute named `attribute_name`. May be a string containing whitespace-delimited values, or an Array of String values. Any keywords present in the named attribute will be removed. If no keywords remain, or if `keywords` is nil, the attribute is deleted.\n\nReturns  \n`self` ([`Node`](node)) for ease of chaining method calls.\n\n**Example:**\n\nNote that the `rel` attribute is deleted when empty.\n\n``` ruby\nnode                                    # => <a rel=\"nofollow noreferrer\">link</a>\nnode.kwattr_remove(\"rel\", \"nofollow\")   # => <a rel=\"noreferrer\">link</a>\nnode.kwattr_remove(\"rel\", \"noreferrer\") # => <a>link</a>\n```\n\nSince v1.11.0\n\nkwattr_values(attribute_name) → Array\\<String\\> Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 838\ndef kwattr_values(attribute_name)\n  keywordify(get_attribute(attribute_name) || [])\nend\n```\n\nFetch values from a keyword attribute of a [`Node`](node).\n\nA “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).\n\nSee also [`#classes`](node#method-i-classes), [`#kwattr_add`](node#method-i-kwattr_add), [`#kwattr_append`](node#method-i-kwattr_append), [`#kwattr_remove`](node#method-i-kwattr_remove)\n\nParameters\n\n- `attribute_name` (String) The name of the keyword attribute to be inspected.\n\nReturns  \n(Array\\<String\\>) The values present in the Node’s `attribute_name` attribute. If the attribute is empty or non-existent, the return value is an empty array.\n\n**Example:**\n\n``` ruby\nnode                      # => <a rel=\"nofollow noopener external\">link</a>\nnode.kwattr_values(\"rel\") # => [\"nofollow\", \"noopener\", \"external\"]\n```\n\nSince v1.11.0\n\nremove_attribute(name) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 643\ndef remove_attribute(name)\n  attr = attributes[name].remove if key?(name)\n  clear_xpath_context if Nokogiri.jruby?\n  attr\nend\n```\n\nRemove the attribute named `name`\n\nAlso aliased as: [delete](node#method-i-delete)\n\nremove_class(css_classes) → self Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 809\ndef remove_class(names = nil)\n  kwattr_remove(\"class\", names)\nend\n```\n\nRemove [`HTML`](../html4) [`CSS`](../css) classes from this node. Any [`CSS`](../css) class names in `css_classes` that exist in this node’s “class” attribute are removed, including any multiple entries.\n\nIf no [`CSS`](../css) classes remain after this operation, or if `css_classes` is `nil`, the “class” attribute is deleted from the node.\n\nThis is a convenience function and is equivalent to:\n\n``` ruby\nnode.kwattr_remove(\"class\", css_classes)\n```\n\nAlso see [`#kwattr_remove`](node#method-i-kwattr_remove), [`#classes`](node#method-i-classes), [`#add_class`](node#method-i-add_class), [`#append_class`](node#method-i-append_class)\n\nParameters\n\n- `css_classes` (String, Array\\<String\\>)\n\n  [`CSS`](../css) class names to be removed from the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will be removed. If no [`CSS`](../css) classes remain, the “class” attribute is deleted.\n\nReturns  \n`self` ([`Nokogiri::XML::Node`](node)) for ease of chaining method calls.\n\n**Example**: Deleting a [`CSS`](../css) class\n\nNote that all instances of the class “section” are removed from the “class” attribute.\n\n``` ruby\nnode                         # => <div class=\"section header section\"></div>\nnode.remove_class(\"section\") # => <div class=\"header\"></div>\n```\n\n**Example**: Deleting the only remaining [`CSS`](../css) class\n\nNote that the attribute is removed once there are no remaining classes.\n\n``` ruby\nnode                         # => <div class=\"section\"></div>\nnode.remove_class(\"section\") # => <div></div>\n```\n\n**Example**: Deleting multiple [`CSS`](../css) classes\n\nNote that the “class” attribute is deleted once it’s empty.\n\n``` ruby\nnode                                    # => <div class=\"section header float\"></div>\nnode.remove_class([\"section\", \"float\"]) # => <div class=\"header\"></div>\n```\n\n\\[\\]=(name, value) → value\n\nAlias for: [\\[\\]=](node#method-i-5B-5D-3D)\n\nvalue?(value) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 623\ndef value?(value)\n  values.include?(value)\nend\n```\n\nDoes this Node’s attributes include \\<value\\>\n\nvalues() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 617\ndef values\n  attribute_nodes.map(&:value)\nend\n```\n\nGet the attribute values for this [`Node`](node).\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Node.html](https://nokogiri.org/rdoc/Nokogiri/XML/Node.html)"
- name: Nokogiri::XML::Node#%
  id: nokogiri/xml/node#method-i-25
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    % (\*args)

    Included from [Nokogiri::XML::Searchable](searchable)

    Alias for: [at](searchable#method-i-at)
- name: Nokogiri::XML::Node#/
  id: nokogiri/xml/node#method-i-2F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    / (\*args)

    Included from [Nokogiri::XML::Searchable](searchable)

    Alias for: [search](searchable#method-i-search)
- name: Nokogiri::XML::Node#<<
  id: nokogiri/xml/node#method-i-3C-3C
  summary: Add node_or_tags as a child of this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    \<\< (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 256
    def <<(node_or_tags)
      add_child(node_or_tags)
      self
    end
    ```

    Add `node_or_tags` as a child of this [`Node`](node).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns `self`, to support chaining of calls (e.g., root \<\< child1 \<\< child2)

    Also see related method `add_child`.
- name: Nokogiri::XML::Node#<=>
  id: nokogiri/xml/node#method-i-3C-3D-3E
  summary: Compare two Node objects with respect to their Document
  belongs_to: Nokogiri::XML::Node
  description: |-
    \<=\> (other) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1256
    def <=>(other)
      return nil unless other.is_a?(Nokogiri::XML::Node)
      return nil unless document == other.document

      compare(other)
    end
    ```

    Compare two [`Node`](node) objects with respect to their [`Document`](document). Nodes from different documents cannot be compared.
- name: Nokogiri::XML::Node#==
  id: nokogiri/xml/node#method-i-3D-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    == (other) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1246
    def ==(other)
      return false unless other
      return false unless other.respond_to?(:pointer_id)

      pointer_id == other.pointer_id
    end
    ```

    Test to see if this [`Node`](node) is equal to `other`
- name: Nokogiri::XML::Node#>
  id: nokogiri/xml/node#method-i-3E
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    \>(selector) → NodeSet Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 196
    def >(selector) # rubocop:disable Naming/BinaryOperatorParameterName
      ns = (document.root&.namespaces || {})
      xpath(CSS.xpath_for(selector, prefix: "./", ns: ns).first)
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this node’s immediate children using [`CSS`](../css) selector `selector`
- name: Nokogiri::XML::Node#[]
  id: nokogiri/xml/node#method-i-5B-5D
  summary: Fetch an attribute from this node
  belongs_to: Nokogiri::XML::Node
  description: |-
    \[\](name) → (String, nil) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 512
    def [](name)
      get(name.to_s)
    end
    ```

    Fetch an attribute from this node.

    ⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes, use [`#attribute_with_ns`](node#method-i-attribute_with_ns).

    Returns

    (String, nil) value of the attribute `name`, or `nil` if no matching attribute exists

    **Example**

    ``` ruby
    doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
    child = doc.at_css("child")
    child["size"] # => "large"
    child["class"] # => "big wide tall"
    ```

    **Example:** Namespaced attributes will not be returned.

    ⚠ Note namespaced attributes may be accessed with [`#attribute`](node#method-i-attribute) or [`#attribute_with_ns`](node#method-i-attribute_with_ns)

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns:width='http://example.com/widths'>
        <child width:size='broad'/>
      </root>
    EOF
    doc.at_css("child")["size"] # => nil
    doc.at_css("child").attribute("size").value # => "broad"
    doc.at_css("child").attribute_with_ns("size", "http://example.com/widths").value
    # => "broad"
    ```

    Also aliased as: [get_attribute](node#method-i-get_attribute), [attr](node#method-i-attr)
- name: Nokogiri::XML::Node#[]=
  id: nokogiri/xml/node#method-i-5B-5D-3D
  summary: Update the attribute name to value, or create the attribute if it does not exist
  belongs_to: Nokogiri::XML::Node
  description: |-
    \[\]=(name, value) → value Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 550
    def []=(name, value)
      set(name.to_s, value.to_s)
    end
    ```

    Update the attribute `name` to `value`, or create the attribute if it does not exist.

    ⚠ Note that attributes with namespaces cannot be accessed with this method. To access namespaced attributes for update, use [`#attribute_with_ns`](node#method-i-attribute_with_ns). To add a namespaced attribute, see the example below.

    Returns

    `value`

    **Example**

    ``` ruby
    doc = Nokogiri::XML("<root><child/></root>")
    child = doc.at_css("child")
    child["size"] = "broad"
    child.to_html
    # => "<child size=\"broad\"></child>"
    ```

    **Example:** Add a namespaced attribute.

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns:width='http://example.com/widths'>
        <child/>
      </root>
    EOF
    child = doc.at_css("child")
    child["size"] = "broad"
    ns = doc.root.namespace_definitions.find { |ns| ns.prefix == "width" }
    child.attribute("size").namespace = ns
    doc.to_html
    # => "<root xmlns:width=\"http://example.com/widths\">\n" +
    #    "  <child width:size=\"broad\"></child>\n" +
    #    "</root>\n"
    ```

    Also aliased as: [set_attribute](node#method-i-set_attribute)
- name: Nokogiri::XML::Node#accept
  id: nokogiri/xml/node#method-i-accept
  summary: Accept a visitor
  belongs_to: Nokogiri::XML::Node
  description: |-
    accept (visitor) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1240
    def accept(visitor)
      visitor.visit(self)
    end
    ```

    Accept a visitor. This method calls “visit” on `visitor` with self.
- name: Nokogiri::XML::Node#add_child
  id: nokogiri/xml/node#method-i-add_child
  summary: Add node_or_tags as a child of this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    add_child (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 148
    def add_child(node_or_tags)
      node_or_tags = coerce(node_or_tags)
      if node_or_tags.is_a?(XML::NodeSet)
        node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }
      else
        add_child_node_and_reparent_attrs(node_or_tags)
      end
      node_or_tags
    end
    ```

    Add `node_or_tags` as a child of this [`Node`](node).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).

    Also see related method +\<\<+.
- name: Nokogiri::XML::Node#add_class
  id: nokogiri/xml/node#method-i-add_class
  summary: Ensure HTML CSS classes are present on self
  belongs_to: Nokogiri::XML::Node
  description: |-
    add_class(names) → self Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 715
    def add_class(names)
      kwattr_add("class", names)
    end
    ```

    Ensure [`HTML`](../html4) [`CSS`](../css) classes are present on `self`. Any [`CSS`](../css) classes in `names` that already exist in the “class” attribute are *not* added. Note that any existing duplicates in the “class” attribute are not removed. Compare with [`#append_class`](node#method-i-append_class).

    This is a convenience function and is equivalent to:

    ``` ruby
    node.kwattr_add("class", names)
    ```

    See related: [`#kwattr_add`](node#method-i-kwattr_add), [`#classes`](node#method-i-classes), [`#append_class`](node#method-i-append_class), [`#remove_class`](node#method-i-remove_class)

    Parameters

    - `names` (String, Array\<String\>)

      [`CSS`](../css) class names to be added to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will not be added. Any class names not present will be added. If no “class” attribute exists, one is created.

    Returns

    `self` ([`Node`](node)) for ease of chaining method calls.

    **Example:** Ensure that the node has [`CSS`](../css) class “section”

    ``` ruby
    node                      # => <div></div>
    node.add_class("section") # => <div class="section"></div>
    node.add_class("section") # => <div class="section"></div> # duplicate not added
    ```

    **Example:** Ensure that the node has [`CSS`](../css) classes “section” and “header”, via a String argument

    Note that the [`CSS`](../css) class “section” is not added because it is already present. Note also that the pre-existing duplicate [`CSS`](../css) class “section” is not removed.

    ``` ruby
    node                             # => <div class="section section"></div>
    node.add_class("section header") # => <div class="section section header"></div>
    ```

    **Example:** Ensure that the node has [`CSS`](../css) classes “section” and “header”, via an Array argument

    ``` ruby
    node                                  # => <div></div>
    node.add_class(["section", "header"]) # => <div class="section header"></div>
    ```
- name: Nokogiri::XML::Node#add_namespace
  id: nokogiri/xml/node#method-i-add_namespace
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    add_namespace(prefix, href) → Nokogiri::XML::Namespace

    Alias for: [add_namespace_definition](node#method-i-add_namespace_definition)
- name: Nokogiri::XML::Node#add_namespace_definition
  id: nokogiri/xml/node#method-i-add_namespace_definition
  summary: A default namespace definition for this node can be added by passing nil for prefix
  belongs_to: Nokogiri::XML::Node
  description: |-
    add_namespace_definition(prefix, href) → Nokogiri::XML::Namespace Show source

    ``` c
    static VALUE
    rb_xml_node_add_namespace_definition(VALUE rb_node, VALUE rb_prefix, VALUE rb_href)
    {
      xmlNodePtr c_node, element;
      xmlNsPtr c_namespace;
      const xmlChar *c_prefix = (const xmlChar *)(NIL_P(rb_prefix) ? NULL : StringValueCStr(rb_prefix));

      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);
      element = c_node ;

      c_namespace = xmlSearchNs(c_node->doc, c_node, c_prefix);

      if (!c_namespace) {
        if (c_node->type != XML_ELEMENT_NODE) {
          element = c_node->parent;
        }
        c_namespace = xmlNewNs(element, (const xmlChar *)StringValueCStr(rb_href), c_prefix);
      }

      if (!c_namespace) {
        return Qnil ;
      }

      if (NIL_P(rb_prefix) || c_node != element) {
        xmlSetNs(c_node, c_namespace);
      }

      return noko_xml_namespace_wrap(c_namespace, c_node->doc);
    }
    ```

    Adds a namespace definition to this node with `prefix` using `href` value, as if this node had included an attribute “xmlns:prefix=href”.

    A default namespace definition for this node can be added by passing `nil` for `prefix`.

    Parameters

    - `prefix` (String, `nil`) An [XML Name](https://www.w3.org/TR/xml-names/#ns-decl)

    - `href` (String) The [URI reference](https://www.w3.org/TR/xml-names/#sec-namespaces)

    Returns

    The new [`Nokogiri::XML::Namespace`](namespace)

    **Example:** adding a non-default namespace definition

    ``` ruby
    doc = Nokogiri::XML("<store><inventory></inventory></store>")
    inventory = doc.at_css("inventory")
    inventory.add_namespace_definition("automobile", "http://alices-autos.com/")
    inventory.add_namespace_definition("bicycle", "http://bobs-bikes.com/")
    inventory.add_child("<automobile:tire>Michelin model XGV, size 75R</automobile:tire>")
    doc.to_xml
    # => "<?xml version=\"1.0\"?>\n" +
    #    "<store>\n" +
    #    "  <inventory xmlns:automobile=\"http://alices-autos.com/\" xmlns:bicycle=\"http://bobs-bikes.com/\">\n" +
    #    "    <automobile:tire>Michelin model XGV, size 75R</automobile:tire>\n" +
    #    "  </inventory>\n" +
    #    "</store>\n"
    ```

    **Example:** adding a default namespace definition

    ``` ruby
    doc = Nokogiri::XML("<store><inventory><tire>Michelin model XGV, size 75R</tire></inventory></store>")
    doc.at_css("tire").add_namespace_definition(nil, "http://bobs-bikes.com/")
    doc.to_xml
    # => "<?xml version=\"1.0\"?>\n" +
    #    "<store>\n" +
    #    "  <inventory>\n" +
    #    "    <tire xmlns=\"http://bobs-bikes.com/\">Michelin model XGV, size 75R</tire>\n" +
    #    "  </inventory>\n" +
    #    "</store>\n"
    ```

    Also aliased as: [add_namespace](node#method-i-add_namespace)
- name: Nokogiri::XML::Node#add_next_sibling
  id: nokogiri/xml/node#method-i-add_next_sibling
  summary: Insert node_or_tags after this Node (as a sibling)
  belongs_to: Nokogiri::XML::Node
  description: |-
    add_next_sibling (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 288
    def add_next_sibling(node_or_tags)
      raise ArgumentError,
        "A document may not have multiple root nodes." if parent&.document? && !(node_or_tags.comment? || node_or_tags.processing_instruction?)

      add_sibling(:next, node_or_tags)
    end
    ```

    Insert `node_or_tags` after this [`Node`](node) (as a sibling).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).

    Also see related method `after`.

    Also aliased as: [next=](node#method-i-next-3D)
- name: Nokogiri::XML::Node#add_previous_sibling
  id: nokogiri/xml/node#method-i-add_previous_sibling
  summary: Insert node_or_tags before this Node (as a sibling)
  belongs_to: Nokogiri::XML::Node
  description: |-
    add_previous_sibling (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 271
    def add_previous_sibling(node_or_tags)
      raise ArgumentError,
        "A document may not have multiple root nodes." if parent&.document? && !(node_or_tags.comment? || node_or_tags.processing_instruction?)

      add_sibling(:previous, node_or_tags)
    end
    ```

    Insert `node_or_tags` before this [`Node`](node) (as a sibling).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).

    Also see related method `before`.

    Also aliased as: [previous=](node#method-i-previous-3D)
- name: Nokogiri::XML::Node#after
  id: nokogiri/xml/node#method-i-after
  summary: Insert node_or_tags after this node (as a sibling)
  belongs_to: Nokogiri::XML::Node
  description: |-
    after (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 318
    def after(node_or_tags)
      add_next_sibling(node_or_tags)
      self
    end
    ```

    Insert `node_or_tags` after this node (as a sibling).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a [`Nokogiri::XML::DocumentFragment`](documentfragment), or a String containing markup.

    Returns `self`, to support chaining of calls.

    Also see related method `add_next_sibling`.
- name: Nokogiri::XML::Node#ancestors
  id: nokogiri/xml/node#method-i-ancestors
  summary: Get a list of ancestor Node for this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    ancestors (selector = nil) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1209
    def ancestors(selector = nil)
      return NodeSet.new(document) unless respond_to?(:parent)
      return NodeSet.new(document) unless parent

      parents = [parent]

      while parents.last.respond_to?(:parent)
        break unless (ctx_parent = parents.last.parent)

        parents << ctx_parent
      end

      return NodeSet.new(document, parents) unless selector

      root = parents.last
      search_results = root.search(selector)

      NodeSet.new(document, parents.find_all do |parent|
        search_results.include?(parent)
      end)
    end
    ```

    Get a list of ancestor [`Node`](node) for this [`Node`](node). If `selector` is given, the ancestors must match `selector`
- name: Nokogiri::XML::Node#append_class
  id: nokogiri/xml/node#method-i-append_class
  summary: Add HTML CSS classes to self, regardless of duplication
  belongs_to: Nokogiri::XML::Node
  description: |-
    append_class(names) → self Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 759
    def append_class(names)
      kwattr_append("class", names)
    end
    ```

    Add [`HTML`](../html4) [`CSS`](../css) classes to `self`, regardless of duplication. Compare with [`#add_class`](node#method-i-add_class).

    This is a convenience function and is equivalent to:

    ``` ruby
    node.kwattr_append("class", names)
    ```

    See related: [`#kwattr_append`](node#method-i-kwattr_append), [`#classes`](node#method-i-classes), [`#add_class`](node#method-i-add_class), [`#remove_class`](node#method-i-remove_class)

    Parameters

    - `names` (String, Array\<String\>)

      [`CSS`](../css) class names to be appended to the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. All class names passed in will be appended to the “class” attribute even if they are already present in the attribute value. If no “class” attribute exists, one is created.

    Returns

    `self` ([`Node`](node)) for ease of chaining method calls.

    **Example:** Append “section” to the node’s [`CSS`](../css) “class” attribute

    ``` ruby
    node                         # => <div></div>
    node.append_class("section") # => <div class="section"></div>
    node.append_class("section") # => <div class="section section"></div> # duplicate added!
    ```

    **Example:** Append “section” and “header” to the noded’s [`CSS`](../css) “class” attribute, via a String argument

    Note that the [`CSS`](../css) class “section” is appended even though it is already present

    ``` ruby
    node                                # => <div class="section section"></div>
    node.append_class("section header") # => <div class="section section section header"></div>
    ```

    **Example:** Append “section” and “header” to the node’s [`CSS`](../css) “class” attribute, via an Array argument

    ``` ruby
    node                                     # => <div></div>
    node.append_class(["section", "header"]) # => <div class="section header"></div>
    node.append_class(["section", "header"]) # => <div class="section header section header"></div>
    ```
- name: Nokogiri::XML::Node#at
  id: nokogiri/xml/node#method-i-at
  summary: Search this object for paths, and return only the first result
  belongs_to: Nokogiri::XML::Node
  description: |-
    at(\*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 71
    def at(*args)
      search(*args).first
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this object for `paths`, and return only the first result. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.

    See [`Searchable#search`](searchable#method-i-search) for more information.

    Also aliased as: [%](searchable#method-i-25)
- name: Nokogiri::XML::Node#at_css
  id: nokogiri/xml/node#method-i-at_css
  summary: Search this object for CSS rules, and return only the first match
  belongs_to: Nokogiri::XML::Node
  description: |-
    at_css(\*rules, \[namespace-bindings, custom-pseudo-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 140
    def at_css(*args)
      css(*args).first
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this object for [`CSS`](../css) `rules`, and return only the first match. `rules` must be one or more [`CSS`](../css) selectors.

    See [`Searchable#css`](searchable#method-i-css) for more information.
- name: Nokogiri::XML::Node#at_xpath
  id: nokogiri/xml/node#method-i-at_xpath
  summary: Search this node for XPath paths, and return only the first match
  belongs_to: Nokogiri::XML::Node
  description: |-
    at_xpath(\*paths, \[namespace-bindings, variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 188
    def at_xpath(*args)
      xpath(*args).first
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this node for [`XPath`](xpath) `paths`, and return only the first match. `paths` must be one or more [`XPath`](xpath) queries.

    See [`Searchable#xpath`](searchable#method-i-xpath) for more information.
- name: Nokogiri::XML::Node#attr
  id: nokogiri/xml/node#method-i-attr
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    attr (name)

    Alias for: [\[\]](node#method-i-5B-5D)
- name: Nokogiri::XML::Node#attribute
  id: nokogiri/xml/node#method-i-attribute
  summary: Attribute (Nokogiri::XML::Attr) belonging to this node with name name
  belongs_to: Nokogiri::XML::Node
  description: |-
    attribute(name) → Nokogiri::XML::Attr Show source

    ``` c
    static VALUE
    rb_xml_node_attribute(VALUE self, VALUE name)
    {
      xmlNodePtr node;
      xmlAttrPtr prop;
      Noko_Node_Get_Struct(self, xmlNode, node);
      prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));

      if (! prop) { return Qnil; }
      return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
    }
    ```

    Returns

    Attribute ([`Nokogiri::XML::Attr`](attr)) belonging to this node with name `name`.

    ⚠ Note that attribute namespaces are ignored and only the simple (non-namespace-prefixed) name is used to find a matching attribute. In case of a simple name collision, only one of the matching attributes will be returned. In this case, you will need to use [`#attribute_with_ns`](node#method-i-attribute_with_ns).

    **Example:**

    ``` ruby
    doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
    child = doc.at_css("child")
    child.attribute("size") # => #<Nokogiri::XML::Attr:0x550 name="size" value="large">
    child.attribute("class") # => #<Nokogiri::XML::Attr:0x564 name="class" value="big wide tall">
    ```

    **Example** showing that namespaced attributes will not be returned:

    ⚠ Note that only one of the two matching attributes is returned.

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns:width='http://example.com/widths'
            xmlns:height='http://example.com/heights'>
        <child width:size='broad' height:size='tall'/>
      </root>
    EOF
    doc.at_css("child").attribute("size")
    # => #(Attr:0x550 {
    #      name = "size",
    #      namespace = #(Namespace:0x564 {
    #        prefix = "width",
    #        href = "http://example.com/widths"
    #        }),
    #      value = "broad"
    #      })
    ```
- name: Nokogiri::XML::Node#attribute_nodes
  id: nokogiri/xml/node#method-i-attribute_nodes
  summary: Attributes (an Array of Nokogiri::XML::Attr) belonging to this node
  belongs_to: Nokogiri::XML::Node
  description: |-
    attribute_nodes() → Array\<Nokogiri::XML::Attr\> Show source

    ``` c
    static VALUE
    rb_xml_node_attribute_nodes(VALUE rb_node)
    {
      xmlNodePtr c_node;

      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      return noko_xml_node_attrs(c_node);
    }
    ```

    Returns

    Attributes (an Array of [`Nokogiri::XML::Attr`](attr)) belonging to this node.

    Note that this is the preferred alternative to [`#attributes`](node#method-i-attributes) when the simple (non-namespace-prefixed) attribute names may collide.

    **Example:**

    Contrast this with the colliding-name example from [`#attributes`](node#method-i-attributes).

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns:width='http://example.com/widths'
            xmlns:height='http://example.com/heights'>
        <child width:size='broad' height:size='tall'/>
      </root>
    EOF
    doc.at_css("child").attribute_nodes
    # => [#(Attr:0x550 {
    #       name = "size",
    #       namespace = #(Namespace:0x564 {
    #         prefix = "width",
    #         href = "http://example.com/widths"
    #         }),
    #       value = "broad"
    #       }),
    #     #(Attr:0x578 {
    #       name = "size",
    #       namespace = #(Namespace:0x58c {
    #         prefix = "height",
    #         href = "http://example.com/heights"
    #         }),
    #       value = "tall"
    #       })]
    ```
- name: Nokogiri::XML::Node#attribute_with_ns
  id: nokogiri/xml/node#method-i-attribute_with_ns
  summary: Attribute (Nokogiri::XML::Attr) belonging to this node with matching name and namespace
  belongs_to: Nokogiri::XML::Node
  description: |-
    attribute_with_ns(name, namespace) → Nokogiri::XML::Attr Show source

    ``` c
    static VALUE
    rb_xml_node_attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
    {
      xmlNodePtr node;
      xmlAttrPtr prop;
      Noko_Node_Get_Struct(self, xmlNode, node);
      prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),
                          NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));

      if (! prop) { return Qnil; }
      return noko_xml_node_wrap(Qnil, (xmlNodePtr)prop);
    }
    ```

    Returns

    Attribute ([`Nokogiri::XML::Attr`](attr)) belonging to this node with matching `name` and `namespace`.

    - `name` (String): the simple (non-namespace-prefixed) name of the attribute

    - `namespace` (String): the URI of the attribute’s namespace

    See related: [`#attribute`](node#method-i-attribute)

    **Example:**

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns:width='http://example.com/widths'
            xmlns:height='http://example.com/heights'>
        <child width:size='broad' height:size='tall'/>
      </root>
    EOF
    doc.at_css("child").attribute_with_ns("size", "http://example.com/widths")
    # => #(Attr:0x550 {
    #      name = "size",
    #      namespace = #(Namespace:0x564 {
    #        prefix = "width",
    #        href = "http://example.com/widths"
    #        }),
    #      value = "broad"
    #      })
    doc.at_css("child").attribute_with_ns("size", "http://example.com/heights")
    # => #(Attr:0x578 {
    #      name = "size",
    #      namespace = #(Namespace:0x58c {
    #        prefix = "height",
    #        href = "http://example.com/heights"
    #        }),
    #      value = "tall"
    #      })
    ```
- name: Nokogiri::XML::Node#attributes
  id: nokogiri/xml/node#method-i-attributes
  summary: Fetch this node’s attributes
  belongs_to: Nokogiri::XML::Node
  description: |-
    attributes() → Hash\<String ⇒ Nokogiri::XML::Attr\> Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 609
    def attributes
      attribute_nodes.each_with_object({}) do |node, hash|
        hash[node.node_name] = node
      end
    end
    ```

    Fetch this node’s attributes.

    ⚠ Because the keys do not include any namespace information for the attribute, in case of a simple name collision, not all attributes will be returned. In this case, you will need to use [`#attribute_nodes`](node#method-i-attribute_nodes).

    Returns

    Hash containing attributes belonging to `self`. The hash keys are String attribute names (without the namespace), and the hash values are [`Nokogiri::XML::Attr`](attr).

    **Example** with no namespaces:

    ``` ruby
    doc = Nokogiri::XML("<root><child size='large' class='big wide tall'/></root>")
    doc.at_css("child").attributes
    # => {"size"=>#(Attr:0x550 { name = "size", value = "large" }),
    #     "class"=>#(Attr:0x564 { name = "class", value = "big wide tall" })}
    ```

    **Example** with a namespace:

    ``` ruby
    doc = Nokogiri::XML("<root xmlns:desc='http://example.com/sizes'><child desc:size='large'/></root>")
    doc.at_css("child").attributes
    # => {"size"=>
    #      #(Attr:0x550 {
    #        name = "size",
    #        namespace = #(Namespace:0x564 {
    #          prefix = "desc",
    #          href = "http://example.com/sizes"
    #          }),
    #        value = "large"
    #        })}
    ```

    **Example** with an attribute name collision:

    ⚠ Note that only one of the attributes is returned in the Hash.

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns:width='http://example.com/widths'
            xmlns:height='http://example.com/heights'>
        <child width:size='broad' height:size='tall'/>
      </root>
    EOF
    doc.at_css("child").attributes
    # => {"size"=>
    #      #(Attr:0x550 {
    #        name = "size",
    #        namespace = #(Namespace:0x564 {
    #          prefix = "height",
    #          href = "http://example.com/heights"
    #          }),
    #        value = "tall"
    #        })}
    ```
- name: Nokogiri::XML::Node#before
  id: nokogiri/xml/node#method-i-before
  summary: Insert node_or_tags before this node (as a sibling)
  belongs_to: Nokogiri::XML::Node
  description: |-
    before (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 304
    def before(node_or_tags)
      add_previous_sibling(node_or_tags)
      self
    end
    ```

    Insert `node_or_tags` before this node (as a sibling).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns `self`, to support chaining of calls.

    Also see related method `add_previous_sibling`.
- name: Nokogiri::XML::Node#blank?
  id: nokogiri/xml/node#method-i-blank-3F
  summary: true if the node is an empty or whitespace-only text or cdata node, else false
  belongs_to: Nokogiri::XML::Node
  description: |-
    blank? → Boolean Show source

    ``` c
    static VALUE
    rb_xml_node_blank_eh(VALUE self)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
    }
    ```

    Returns

    `true` if the node is an empty or whitespace-only text or cdata node, else `false`.

    **Example:**

    ``` ruby
    Nokogiri("<root><child/></root>").root.child.blank? # => false
    Nokogiri("<root>\t \n</root>").root.child.blank? # => true
    Nokogiri("<root><![CDATA[\t \n]]></root>").root.child.blank? # => true
    Nokogiri("<root>not-blank</root>").root.child
      .tap { |n| n.content = "" }.blank # => true
    ```
- name: Nokogiri::XML::Node#canonicalize
  id: nokogiri/xml/node#method-i-canonicalize
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    canonicalize (mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1398
    def canonicalize(mode = XML::XML_C14N_1_0, inclusive_namespaces = nil, with_comments = false)
      c14n_root = self
      document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|
        tn = node.is_a?(XML::Node) ? node : parent
        tn == c14n_root || tn.ancestors.include?(c14n_root)
      end
    end
    ```
- name: Nokogiri::XML::Node#cdata?
  id: nokogiri/xml/node#method-i-cdata-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    cdata? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1130
    def cdata?
      type == CDATA_SECTION_NODE
    end
    ```

    Returns true if this is a [`CDATA`](cdata)
- name: Nokogiri::XML::Node#child
  id: nokogiri/xml/node#method-i-child
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    child() → Nokogiri::XML::Node Show source

    ``` c
    static VALUE
    rb_xml_node_child(VALUE self)
    {
      xmlNodePtr node, child;
      Noko_Node_Get_Struct(self, xmlNode, node);

      child = node->children;
      if (!child) { return Qnil; }

      return noko_xml_node_wrap(Qnil, child);
    }
    ```

    Returns

    First of this node’s children, or `nil` if there are no children

    This is a convenience method and is equivalent to:

    ``` ruby
    node.children.first
    ```

    See related: [`#children`](node#method-i-children)
- name: Nokogiri::XML::Node#children
  id: nokogiri/xml/node#method-i-children
  summary: Nokogiri::XML::NodeSet containing this node’s children
  belongs_to: Nokogiri::XML::Node
  description: |-
    children() → Nokogiri::XML::NodeSet Show source

    ``` c
    static VALUE
    rb_xml_node_children(VALUE self)
    {
      xmlNodePtr node;
      xmlNodePtr child;
      xmlNodeSetPtr set;
      VALUE document;
      VALUE node_set;

      Noko_Node_Get_Struct(self, xmlNode, node);

      child = node->children;
      set = xmlXPathNodeSetCreate(child);

      document = DOC_RUBY_OBJECT(node->doc);

      if (!child) { return noko_xml_node_set_wrap(set, document); }

      child = child->next;
      while (NULL != child) {
        xmlXPathNodeSetAddUnique(set, child);
        child = child->next;
      }

      node_set = noko_xml_node_set_wrap(set, document);

      return node_set;
    }
    ```

    Returns

    [`Nokogiri::XML::NodeSet`](nodeset) containing this node’s children.
- name: Nokogiri::XML::Node#children=
  id: nokogiri/xml/node#method-i-children-3D
  summary: node_or_tags can be a Nokogiri::XML::Node, a Nokogiri::XML::DocumentFragment, or a String containing markup
  belongs_to: Nokogiri::XML::Node
  description: |-
    children= (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 349
    def children=(node_or_tags)
      node_or_tags = coerce(node_or_tags)
      children.unlink
      if node_or_tags.is_a?(XML::NodeSet)
        node_or_tags.each { |n| add_child_node_and_reparent_attrs(n) }
      else
        add_child_node_and_reparent_attrs(node_or_tags)
      end
    end
    ```

    Set the content for this [`Node`](node) `node_or_tags`

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a [`Nokogiri::XML::DocumentFragment`](documentfragment), or a String containing markup.

    Also see related method `inner_html=`
- name: Nokogiri::XML::Node#classes
  id: nokogiri/xml/node#method-i-classes
  summary: Fetch CSS class names of a Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    classes() → Array\<String\> Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 669
    def classes
      kwattr_values("class")
    end
    ```

    Fetch [`CSS`](../css) class names of a [`Node`](node).

    This is a convenience function and is equivalent to:

    ``` ruby
    node.kwattr_values("class")
    ```

    See related: [`#kwattr_values`](node#method-i-kwattr_values), [`#add_class`](node#method-i-add_class), [`#append_class`](node#method-i-append_class), [`#remove_class`](node#method-i-remove_class)

    Returns

    The [`CSS`](../css) classes (Array of String) present in the Node’s “class” attribute. If the attribute is empty or non-existent, the return value is an empty array.

    **Example**

    ``` ruby
    node         # => <div class="section title header"></div>
    node.classes # => ["section", "title", "header"]
    ```
- name: Nokogiri::XML::Node#clone
  id: nokogiri/xml/node#method-i-clone
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    clone (p1 = v1, p2 = v2)

    Alias for: [dup](node#method-i-dup)
- name: Nokogiri::XML::Node#coerce
  id: nokogiri/xml/node#method-i-coerce
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    coerce (data) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1473
          def coerce(data)
            case data
            when XML::NodeSet
              return data
            when XML::DocumentFragment
              return data.children
            when String
              return fragment(data).children
            when Document, XML::Attr
              # unacceptable
            when XML::Node
              return data
            end

            raise ArgumentError, <<~EOERR
              Requires a Node, NodeSet or String argument, and cannot accept a #{data.class}.
              (You probably want to select a node from the Document with at() or search(), or create a new Node via Node.new().)
            EOERR
          end
    ```

    ## Manipulating Document Structure

    [↑ top](#top)

    ### Public Instance Methods
- name: Nokogiri::XML::Node#comment?
  id: nokogiri/xml/node#method-i-comment-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    comment? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1125
    def comment?
      type == COMMENT_NODE
    end
    ```

    Returns true if this is a [`Comment`](comment)
- name: Nokogiri::XML::Node#content
  id: nokogiri/xml/node#method-i-content
  summary: Contents of all the text nodes in this node’s subtree, concatenated together into a single String
  belongs_to: Nokogiri::XML::Node
  description: |-
    content() → String Show source

    ``` c
    static VALUE
    rb_xml_node_content(VALUE self)
    {
      xmlNodePtr node;
      xmlChar *content;

      Noko_Node_Get_Struct(self, xmlNode, node);

      content = xmlNodeGetContent(node);
      if (content) {
        VALUE rval = NOKOGIRI_STR_NEW2(content);
        xmlFree(content);
        return rval;
      }
      return Qnil;
    }
    ```

    Returns

    Contents of all the text nodes in this node’s subtree, concatenated together into a single String.

    ⚠ Note that entities will *always* be expanded in the returned String.

    See related: [`#inner_html`](node#method-i-inner_html)

    **Example** of how entities are handled:

    Note that `&lt;` becomes `<` in the returned String.

    ``` ruby
    doc = Nokogiri::XML.fragment("<child>a &lt; b</child>")
    doc.at_css("child").content
    # => "a < b"
    ```

    **Example** of how a subtree is handled:

    Note that the `<span>` tags are omitted and only the text node contents are returned, concatenated into a single string.

    ``` ruby
    doc = Nokogiri::XML.fragment("<child><span>first</span> <span>second</span></child>")
    doc.at_css("child").content
    # => "first second"
    ```

    Also aliased as: [inner_text](node#method-i-inner_text), [text](node#method-i-text), [to_str](node#method-i-to_str)
- name: Nokogiri::XML::Node#content=
  id: nokogiri/xml/node#method-i-content-3D
  summary: Set the Node’s content to a Text node containing string
  belongs_to: Nokogiri::XML::Node
  description: |-
    content= (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 411
    def content=(string)
      self.native_content = encode_special_chars(string.to_s)
    end
    ```

    Set the Node’s content to a [`Text`](text) node containing `string`. The string gets [`XML`](../xml) escaped, not interpreted as markup.
- name: Nokogiri::XML::Node#create_external_subset
  id: nokogiri/xml/node#method-i-create_external_subset
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    create_external_subset(name, external_id, system_id) Show source

    ``` c
    static VALUE
    create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
    {
      xmlNodePtr node;
      xmlDocPtr doc;
      xmlDtdPtr dtd;

      Noko_Node_Get_Struct(self, xmlNode, node);

      doc = node->doc;

      if (doc->extSubset) {
        rb_raise(rb_eRuntimeError, "Document already has an external subset");
      }

      dtd = xmlNewDtd(
              doc,
              NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
              NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
              NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
            );

      if (!dtd) { return Qnil; }

      return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
    }
    ```

    Create an external subset
- name: Nokogiri::XML::Node#create_internal_subset
  id: nokogiri/xml/node#method-i-create_internal_subset
  summary: Create the internal subset of a document
  belongs_to: Nokogiri::XML::Node
  description: |-
    create_internal_subset(name, external_id, system_id) Show source

    ``` c
    static VALUE
    create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
    {
      xmlNodePtr node;
      xmlDocPtr doc;
      xmlDtdPtr dtd;

      Noko_Node_Get_Struct(self, xmlNode, node);

      doc = node->doc;

      if (xmlGetIntSubset(doc)) {
        rb_raise(rb_eRuntimeError, "Document already has an internal subset");
      }

      dtd = xmlCreateIntSubset(
              doc,
              NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
              NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
              NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
            );

      if (!dtd) { return Qnil; }

      return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
    }
    ```

    Create the internal subset of a document.

    ``` ruby
    doc.create_internal_subset("chapter", "-//OASIS//DTD DocBook XML//EN", "chapter.dtd")
    # => <!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd">

    doc.create_internal_subset("chapter", nil, "chapter.dtd")
    # => <!DOCTYPE chapter SYSTEM "chapter.dtd">
    ```
- name: Nokogiri::XML::Node#css
  id: nokogiri/xml/node#method-i-css
  summary: Search this object for CSS rules
  belongs_to: Nokogiri::XML::Node
  description: |-
    css(\*rules, \[namespace-bindings, custom-pseudo-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 126
    def css(*args)
      rules, handler, ns, _ = extract_params(args)

      css_internal(self, rules, handler, ns)
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this object for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:

    ``` ruby
    node.css('title')
    node.css('body h1.bold')
    node.css('div + p.green', 'div#one')
    ```

    A hash of namespace bindings may be appended. For example:

    ``` ruby
    node.css('bike|tire', {'bike' => 'http://schwinn.com/'})
    ```

    💡 Custom [`CSS`](../css) pseudo classes may also be defined which are mapped to a custom [`XPath`](xpath) function. To define custom pseudo classes, create a class and implement the custom pseudo class you want defined. The first argument to the method will be the matching context [`NodeSet`](nodeset). Any other arguments are ones that you pass in. For example:

    ``` ruby
    handler = Class.new {
      def regex(node_set, regex)
        node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      end
    }.new
    node.css('title:regex("\w+")', handler)
    ```

    💡 Some [`XPath`](xpath) syntax is supported in [`CSS`](../css) queries. For example, to query for an attribute:

    ``` ruby
    node.css('img > @href') # returns all +href+ attributes on an +img+ element
    node.css('img / @href') # same

    # ⚠ this returns +class+ attributes from all +div+ elements AND THEIR CHILDREN!
    node.css('div @class')

    node.css
    ```

    💡 Array-like syntax is supported in [`CSS`](../css) queries as an alternative to using +:nth-child()+.

    ⚠ NOTE that indices are 1-based like `:nth-child` and not 0-based like Ruby Arrays. For example:

    ``` ruby
    # equivalent to 'li:nth-child(2)'
    node.css('li[2]') # retrieve the second li element in a list
    ```

    ⚠ NOTE that the [`CSS`](../css) query string is case-sensitive with regards to your document type. [`HTML`](../html4) tags will match only lowercase [`CSS`](../css) queries, so if you search for “H1” in an [`HTML`](../html4) document, you’ll never find anything. However, “H1” might be found in an [`XML`](../xml) document, where tags names are case-sensitive (e.g., “H1” is distinct from “h1”).
- name: Nokogiri::XML::Node#css_path
  id: nokogiri/xml/node#method-i-css_path
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    css_path () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1200
    def css_path
      path.split(%r{/}).filter_map do |part|
        part.empty? ? nil : part.gsub(/\[(\d+)\]/, ':nth-of-type(\1)')
      end.join(" > ")
    end
    ```

    Get the path to this node as a [`CSS`](../css) expression
- name: Nokogiri::XML::Node#deconstruct_keys
  id: nokogiri/xml/node#method-i-deconstruct_keys
  summary: Returns a hash describing the Node, to use in pattern matching
  belongs_to: Nokogiri::XML::Node
  description: |-
    deconstruct_keys(array_of_names) → Hash Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1459
    def deconstruct_keys(keys)
      requested_keys = DECONSTRUCT_KEYS & keys
      {}.tap do |values|
        requested_keys.each do |key|
          method = DECONSTRUCT_METHODS[key] || key
          values[key] = send(method)
        end
      end
    end
    ```

    Returns a hash describing the [`Node`](node), to use in pattern matching.

    Valid keys and their values:

    - `name` → (String) The name of this node, or “text” if it is a [`Text`](text) node.

    - `namespace` → ([`Namespace`](namespace), nil) The namespace of this node, or nil if there is no namespace.

    - `attributes` → (Array\<Attr\>) The attributes of this node.

    - `children` → (Array\<Node\>) The children of this node. 💡 Note this includes text nodes.

    - `elements` → (Array\<Node\>) The child elements of this node. 💡 Note this does not include text nodes.

    - `content` → (String) The contents of all the text nodes in this node’s subtree. See [`#content`](node#method-i-content).

    - `inner_html` → (String) The inner markup for the children of this node. See [`#inner_html`](node#method-i-inner_html).

    ⚡ This is an experimental feature, available since v1.14.0

    **Example**

    ``` ruby
    doc = Nokogiri::XML.parse(<<~XML)
      <?xml version="1.0"?>
      <parent xmlns="http://nokogiri.org/ns/default" xmlns:noko="http://nokogiri.org/ns/noko">
        <child1 foo="abc" noko:bar="def">First</child1>
        <noko:child2 foo="qwe" noko:bar="rty">Second</noko:child2>
      </parent>
    XML

    doc.root.deconstruct_keys([:name, :namespace])
    # => {:name=>"parent",
    #     :namespace=>
    #      #(Namespace:0x35c { href = "http://nokogiri.org/ns/default" })}

    doc.root.deconstruct_keys([:inner_html, :content])
    # => {:content=>"\n" + "  First\n" + "  Second\n",
    #     :inner_html=>
    #      "\n" +
    #      "  <child1 foo=\"abc\" noko:bar=\"def\">First</child1>\n" +
    #      "  <noko:child2 foo=\"qwe\" noko:bar=\"rty\">Second</noko:child2>\n"}

    doc.root.elements.first.deconstruct_keys([:attributes])
    # => {:attributes=>
    #      [#(Attr:0x370 { name = "foo", value = "abc" }),
    #       #(Attr:0x384 {
    #         name = "bar",
    #         namespace = #(Namespace:0x398 {
    #           prefix = "noko",
    #           href = "http://nokogiri.org/ns/noko"
    #           }),
    #         value = "def"
    #         })]}
    ```
- name: Nokogiri::XML::Node#decorate!
  id: nokogiri/xml/node#method-i-decorate-21
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    decorate! () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 132
    def decorate!
      document.decorate(self)
    end
    ```

    Decorate this node with the decorators set up in this node’s [`Document`](document)
- name: Nokogiri::XML::Node#default_namespace=
  id: nokogiri/xml/node#method-i-default_namespace-3D
  summary: Adds a default namespace supplied as a string url href, to self
  belongs_to: Nokogiri::XML::Node
  description: |-
    default_namespace= (url) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 427
    def default_namespace=(url)
      add_namespace_definition(nil, url)
    end
    ```

    Adds a default namespace supplied as a string `url` href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed [`XML`](../xml). A default namespace set with this method will now show up in [`#attributes`](node#method-i-attributes), but when this node is serialized to [`XML`](../xml) an “xmlns” attribute will appear. See also [`#namespace`](node#method-i-namespace) and [`#namespace=`](node#method-i-namespace-3D)
- name: Nokogiri::XML::Node#delete
  id: nokogiri/xml/node#method-i-delete
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    delete (name)

    Alias for: [remove_attribute](node#method-i-remove_attribute)
- name: Nokogiri::XML::Node#description
  id: nokogiri/xml/node#method-i-description
  summary: Fetch the Nokogiri::HTML4::ElementDescription for this node
  belongs_to: Nokogiri::XML::Node
  description: |-
    description () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1167
    def description
      return nil if document.xml?

      Nokogiri::HTML4::ElementDescription[name]
    end
    ```

    Fetch the [`Nokogiri::HTML4::ElementDescription`](../html4/elementdescription) for this node. Returns nil on [`XML`](../xml) documents and on unknown tags.
- name: Nokogiri::XML::Node#do_xinclude
  id: nokogiri/xml/node#method-i-do_xinclude
  summary: Do xinclude substitution on the subtree below node
  belongs_to: Nokogiri::XML::Node
  description: |-
    do_xinclude (options = XML::ParseOptions::DEFAULT_XML) { \|options\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 454
    def do_xinclude(options = XML::ParseOptions::DEFAULT_XML)
      options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
      yield options if block_given?

      # call c extension
      process_xincludes(options.to_i)
    end
    ```

    Do xinclude substitution on the subtree below node. If given a block, a [`Nokogiri::XML::ParseOptions`](parseoptions) object initialized from `options`, will be passed to it, allowing more convenient modification of the parser options.
- name: Nokogiri::XML::Node#document
  id: nokogiri/xml/node#method-i-document
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    document() → Nokogiri::XML::Document Show source

    ``` c
    static VALUE
    rb_xml_node_document(VALUE self)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      return DOC_RUBY_OBJECT(node->doc);
    }
    ```

    Returns

    Parent [`Nokogiri::XML::Document`](document) for this node

    ## Working With Node Attributes

    [↑ top](#top)

    ### Public Instance Methods
- name: Nokogiri::XML::Node#document?
  id: nokogiri/xml/node#method-i-document-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    document? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1145
    def document?
      is_a?(XML::Document)
    end
    ```

    Returns true if this is a [`Document`](document)
- name: Nokogiri::XML::Node#dup
  id: nokogiri/xml/node#method-i-dup
  summary: Copy this node
  belongs_to: Nokogiri::XML::Node
  description: |-
    dup → Nokogiri::XML::Node Show source

    dup(depth) → Nokogiri::XML::Node

    dup(depth, new_parent_doc) → Nokogiri::XML::Node

    ``` c
    static VALUE
    duplicate_node(int argc, VALUE *argv, VALUE self)
    {
      VALUE r_level, r_new_parent_doc;
      int level;
      int n_args;
      xmlDocPtr new_parent_doc;
      xmlNodePtr node, dup;

      Noko_Node_Get_Struct(self, xmlNode, node);

      n_args = rb_scan_args(argc, argv, "02", &r_level, &r_new_parent_doc);

      if (n_args < 1) {
        r_level = INT2NUM((long)1);
      }
      level = (int)NUM2INT(r_level);

      if (n_args < 2) {
        new_parent_doc = node->doc;
      } else {
        Data_Get_Struct(r_new_parent_doc, xmlDoc, new_parent_doc);
      }

      dup = xmlDocCopyNode(node, new_parent_doc, level);
      if (dup == NULL) { return Qnil; }

      noko_xml_document_pin_node(dup);

      return noko_xml_node_wrap(rb_obj_class(self), dup);
    }
    ```

    Copy this node.

    Parameters

    - `depth` 0 is a shallow copy, 1 (the default) is a deep copy.

    - `new_parent_doc` The new node’s parent [`Document`](document). Defaults to the this node’s document.

    Returns

    The new Nokgiri::XML::Node

    Also aliased as: [clone](node#method-i-clone)
- name: Nokogiri::XML::Node#each
  id: nokogiri/xml/node#method-i-each
  summary: Iterate over each attribute name and value pair for this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    each () { \|node_name, value\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 635
    def each
      attribute_nodes.each do |node|
        yield [node.node_name, node.value]
      end
    end
    ```

    Iterate over each attribute name and value pair for this [`Node`](node).
- name: Nokogiri::XML::Node#elem?
  id: nokogiri/xml/node#method-i-elem-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    elem? ()

    Alias for: [element?](node#method-i-element-3F)
- name: Nokogiri::XML::Node#element?
  id: nokogiri/xml/node#method-i-element-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    element? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1181
    def element?
      type == ELEMENT_NODE
    end
    ```

    Returns true if this is an [`Element`](element) node

    Also aliased as: [elem?](node#method-i-elem-3F)
- name: Nokogiri::XML::Node#element_children
  id: nokogiri/xml/node#method-i-element_children
  summary: The node’s child elements as a NodeSet
  belongs_to: Nokogiri::XML::Node
  description: |-
    element_children() → NodeSet Show source

    ``` c
    static VALUE
    rb_xml_node_element_children(VALUE self)
    {
      xmlNodePtr node;
      xmlNodePtr child;
      xmlNodeSetPtr set;
      VALUE document;
      VALUE node_set;

      Noko_Node_Get_Struct(self, xmlNode, node);

      child = xmlFirstElementChild(node);
      set = xmlXPathNodeSetCreate(child);

      document = DOC_RUBY_OBJECT(node->doc);

      if (!child) { return noko_xml_node_set_wrap(set, document); }

      child = xmlNextElementSibling(child);
      while (NULL != child) {
        xmlXPathNodeSetAddUnique(set, child);
        child = xmlNextElementSibling(child);
      }

      node_set = noko_xml_node_set_wrap(set, document);

      return node_set;
    }
    ```

    Returns

    The node’s child elements as a [`NodeSet`](nodeset). Only children that are elements will be returned, which notably excludes [`Text`](text) nodes.

    **Example:**

    Note that [`#children`](node#method-i-children) returns the [`Text`](text) node “hello” while [`#element_children`](node#method-i-element_children) does not.

    ``` ruby
    div = Nokogiri::HTML5("<div>hello<span>world</span>").at_css("div")
    div.element_children
    # => [#<Nokogiri::XML::Element:0x50 name="span" children=[#<Nokogiri::XML::Text:0x3c "world">]>]
    div.children
    # => [#<Nokogiri::XML::Text:0x64 "hello">,
    #     #<Nokogiri::XML::Element:0x50 name="span" children=[#<Nokogiri::XML::Text:0x3c "world">]>]
    ```

    Also aliased as: [elements](node#method-i-elements)
- name: Nokogiri::XML::Node#elements
  id: nokogiri/xml/node#method-i-elements
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    elements() → NodeSet

    Alias for: [element_children](node#method-i-element_children)
- name: Nokogiri::XML::Node#encode_special_chars
  id: nokogiri/xml/node#method-i-encode_special_chars
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    encode_special_chars(string) → String Show source

    ``` c
    static VALUE
    encode_special_chars(VALUE self, VALUE string)
    {
      xmlNodePtr node;
      xmlChar *encoded;
      VALUE encoded_str;

      Noko_Node_Get_Struct(self, xmlNode, node);
      encoded = xmlEncodeSpecialChars(
                  node->doc,
                  (const xmlChar *)StringValueCStr(string)
                );

      encoded_str = NOKOGIRI_STR_NEW2(encoded);
      xmlFree(encoded);

      return encoded_str;
    }
    ```

    Encode any special characters in `string`
- name: Nokogiri::XML::Node#external_subset
  id: nokogiri/xml/node#method-i-external_subset
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    external_subset() Show source

    ``` c
    static VALUE
    external_subset(VALUE self)
    {
      xmlNodePtr node;
      xmlDocPtr doc;
      xmlDtdPtr dtd;

      Noko_Node_Get_Struct(self, xmlNode, node);

      if (!node->doc) { return Qnil; }

      doc = node->doc;
      dtd = doc->extSubset;

      if (!dtd) { return Qnil; }

      return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
    }
    ```

    Get the external subset
- name: Nokogiri::XML::Node#first_element_child
  id: nokogiri/xml/node#method-i-first_element_child
  summary: The first child Node that is an element
  belongs_to: Nokogiri::XML::Node
  description: |-
    first_element_child() → Node Show source

    ``` c
    static VALUE
    rb_xml_node_first_element_child(VALUE self)
    {
      xmlNodePtr node, child;
      Noko_Node_Get_Struct(self, xmlNode, node);

      child = xmlFirstElementChild(node);
      if (!child) { return Qnil; }

      return noko_xml_node_wrap(Qnil, child);
    }
    ```

    Returns

    The first child [`Node`](node) that is an element.

    **Example:**

    Note that the “hello” child, which is a [`Text`](text) node, is skipped and the `<span>` element is returned.

    ``` ruby
    div = Nokogiri::HTML5("<div>hello<span>world</span>").at_css("div")
    div.first_element_child
    # => #(Element:0x3c { name = "span", children = [ #(Text "world")] })
    ```
- name: Nokogiri::XML::Node#fragment
  id: nokogiri/xml/node#method-i-fragment
  summary: Create a DocumentFragment containing tags that is relative to this context node
  belongs_to: Nokogiri::XML::Node
  description: |-
    fragment (tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1022
    def fragment(tags)
      document.related_class("DocumentFragment").new(document, tags, self)
    end
    ```

    Create a [`DocumentFragment`](documentfragment) containing `tags` that is relative to *this* context node.
- name: Nokogiri::XML::Node#fragment?
  id: nokogiri/xml/node#method-i-fragment-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    fragment? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1160
    def fragment?
      type == DOCUMENT_FRAG_NODE
    end
    ```

    Returns true if this is a [`DocumentFragment`](documentfragment)
- name: Nokogiri::XML::Node#get_attribute
  id: nokogiri/xml/node#method-i-get_attribute
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    get_attribute (name)

    Alias for: [\[\]](node#method-i-5B-5D)
- name: Nokogiri::XML::Node#has_attribute?
  id: nokogiri/xml/node#method-i-has_attribute-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    has_attribute? (p1)

    Alias for: [key?](node#method-i-key-3F)
- name: Nokogiri::XML::Node#html?
  id: nokogiri/xml/node#method-i-html-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    html? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1140
    def html?
      type == HTML_DOCUMENT_NODE
    end
    ```

    Returns true if this is an [`HTML4::Document`](../html4/document) or [`HTML5::Document`](../html5/document) node
- name: Nokogiri::XML::Node#inner_html
  id: nokogiri/xml/node#method-i-inner_html
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    inner_html (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1195
    def inner_html(*args)
      children.map { |x| x.to_html(*args) }.join
    end
    ```

    Get the [`inner_html`](node#method-i-inner_html) for this node’s [`Node#children`](node#method-i-children)
- name: Nokogiri::XML::Node#inner_html=
  id: nokogiri/xml/node#method-i-inner_html-3D
  summary: Set the content for this Node to node_or_tags
  belongs_to: Nokogiri::XML::Node
  description: |-
    inner_html= (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 338
    def inner_html=(node_or_tags)
      self.children = node_or_tags
    end
    ```

    Set the content for this [`Node`](node) to `node_or_tags`.

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a [`Nokogiri::XML::DocumentFragment`](documentfragment), or a String containing markup.

    ⚠ Please note that despite the name, this method will **not** always parse a String argument as [`HTML`](../html4). A String argument will be parsed with the `DocumentFragment` parser related to this node’s document.

    For example, if the document is an [`HTML4::Document`](../html4/document) then the string will be parsed as [`HTML4`](../html4) using [`HTML4::DocumentFragment`](../html4/documentfragment); but if the document is an [`XML::Document`](document) then it will parse the string as [`XML`](../xml) using [`XML::DocumentFragment`](documentfragment).

    Also see related method `children=`
- name: Nokogiri::XML::Node#inner_text
  id: nokogiri/xml/node#method-i-inner_text
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    inner_text ()

    Alias for: [content](node#method-i-content)
- name: Nokogiri::XML::Node#internal_subset
  id: nokogiri/xml/node#method-i-internal_subset
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    internal_subset() Show source

    ``` c
    static VALUE
    internal_subset(VALUE self)
    {
      xmlNodePtr node;
      xmlDocPtr doc;
      xmlDtdPtr dtd;

      Noko_Node_Get_Struct(self, xmlNode, node);

      if (!node->doc) { return Qnil; }

      doc = node->doc;
      dtd = xmlGetIntSubset(doc);

      if (!dtd) { return Qnil; }

      return noko_xml_node_wrap(Qnil, (xmlNodePtr)dtd);
    }
    ```

    Get the internal subset
- name: Nokogiri::XML::Node#key?
  id: nokogiri/xml/node#method-i-key-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    key?(attribute) Show source

    ``` c
    static VALUE
    key_eh(VALUE self, VALUE attribute)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      if (xmlHasProp(node, (xmlChar *)StringValueCStr(attribute))) {
        return Qtrue;
      }
      return Qfalse;
    }
    ```

    Returns true if `attribute` is set

    Also aliased as: [has_attribute?](node#method-i-has_attribute-3F)
- name: Nokogiri::XML::Node#keys
  id: nokogiri/xml/node#method-i-keys
  summary: Get the attribute names for this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    keys () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 629
    def keys
      attribute_nodes.map(&:node_name)
    end
    ```

    Get the attribute names for this [`Node`](node).
- name: Nokogiri::XML::Node#kwattr_add
  id: nokogiri/xml/node#method-i-kwattr_add
  summary: Ensure that values are present in a keyword attribute
  belongs_to: Nokogiri::XML::Node
  description: |-
    kwattr_add(attribute_name, keywords) → self Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 892
    def kwattr_add(attribute_name, keywords)
      keywords = keywordify(keywords)
      current_kws = kwattr_values(attribute_name)
      new_kws = (current_kws + (keywords - current_kws)).join(" ")
      set_attribute(attribute_name, new_kws)
      self
    end
    ```

    Ensure that values are present in a keyword attribute.

    Any values in `keywords` that already exist in the Node’s attribute values are *not* added. Note that any existing duplicates in the attribute values are not removed. Compare with [`#kwattr_append`](node#method-i-kwattr_append).

    A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).

    See also [`#add_class`](node#method-i-add_class), [`#kwattr_values`](node#method-i-kwattr_values), [`#kwattr_append`](node#method-i-kwattr_append), [`#kwattr_remove`](node#method-i-kwattr_remove)

    Parameters

    - `attribute_name` (String) The name of the keyword attribute to be modified.

    - `keywords` (String, Array\<String\>) Keywords to be added to the attribute named `attribute_name`. May be a string containing whitespace-delimited values, or an Array of String values. Any values already present will not be added. Any values not present will be added. If the named attribute does not exist, it is created.

    Returns

    `self` ([`Nokogiri::XML::Node`](node)) for ease of chaining method calls.

    **Example:** Ensure that a `Node` has “nofollow” in its `rel` attribute.

    Note that duplicates are not added.

    ``` ruby
    node                               # => <a></a>
    node.kwattr_add("rel", "nofollow") # => <a rel="nofollow"></a>
    node.kwattr_add("rel", "nofollow") # => <a rel="nofollow"></a>
    ```

    **Example:** Ensure that a `Node` has “nofollow” and “noreferrer” in its `rel` attribute, via a String argument.

        Note that "nofollow" is not added because it is already present. Note also that the
        pre-existing duplicate "nofollow" is not removed.

         node                                          # => <a rel="nofollow nofollow"></a>
         node.kwattr_add("rel", "nofollow noreferrer") # => <a rel="nofollow nofollow noreferrer"></a>

    **Example:** Ensure that a `Node` has “nofollow” and “noreferrer” in its `rel` attribute, via an Array argument.

    ``` ruby
    node                                               # => <a></a>
    node.kwattr_add("rel", ["nofollow", "noreferrer"]) # => <a rel="nofollow noreferrer"></a>
    ```

    Since v1.11.0
- name: Nokogiri::XML::Node#kwattr_append
  id: nokogiri/xml/node#method-i-kwattr_append
  summary: Add keywords to a Node’s keyword attribute, regardless of duplication
  belongs_to: Nokogiri::XML::Node
  description: |-
    kwattr_append(attribute_name, keywords) → self Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 945
    def kwattr_append(attribute_name, keywords)
      keywords = keywordify(keywords)
      current_kws = kwattr_values(attribute_name)
      new_kws = (current_kws + keywords).join(" ")
      set_attribute(attribute_name, new_kws)
      self
    end
    ```

    Add keywords to a Node’s keyword attribute, regardless of duplication. Compare with [`#kwattr_add`](node#method-i-kwattr_add).

    A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).

    See also [`#append_class`](node#method-i-append_class), [`#kwattr_values`](node#method-i-kwattr_values), [`#kwattr_add`](node#method-i-kwattr_add), [`#kwattr_remove`](node#method-i-kwattr_remove)

    Parameters

    - `attribute_name` (String) The name of the keyword attribute to be modified.

    - `keywords` (String, Array\<String\>) Keywords to be added to the attribute named `attribute_name`. May be a string containing whitespace-delimited values, or an Array of String values. All values passed in will be appended to the named attribute even if they are already present in the attribute. If the named attribute does not exist, it is created.

    Returns

    `self` ([`Node`](node)) for ease of chaining method calls.

    **Example:** Append “nofollow” to the `rel` attribute.

    Note that duplicates are added.

    ``` ruby
    node                                  # => <a></a>
    node.kwattr_append("rel", "nofollow") # => <a rel="nofollow"></a>
    node.kwattr_append("rel", "nofollow") # => <a rel="nofollow nofollow"></a>
    ```

    **Example:** Append “nofollow” and “noreferrer” to the `rel` attribute, via a String argument.

    Note that “nofollow” is appended even though it is already present.

    ``` ruby
    node                                             # => <a rel="nofollow"></a>
    node.kwattr_append("rel", "nofollow noreferrer") # => <a rel="nofollow nofollow noreferrer"></a>
    ```

    **Example:** Append “nofollow” and “noreferrer” to the `rel` attribute, via an Array argument.

    ``` ruby
    node                                                  # => <a></a>
    node.kwattr_append("rel", ["nofollow", "noreferrer"]) # => <a rel="nofollow noreferrer"></a>
    ```

    Since v1.11.0
- name: Nokogiri::XML::Node#kwattr_remove
  id: nokogiri/xml/node#method-i-kwattr_remove
  summary: Remove keywords from a keyword attribute
  belongs_to: Nokogiri::XML::Node
  description: |-
    kwattr_remove(attribute_name, keywords) → self Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 988
    def kwattr_remove(attribute_name, keywords)
      if keywords.nil?
        remove_attribute(attribute_name)
        return self
      end

      keywords = keywordify(keywords)
      current_kws = kwattr_values(attribute_name)
      new_kws = current_kws - keywords
      if new_kws.empty?
        remove_attribute(attribute_name)
      else
        set_attribute(attribute_name, new_kws.join(" "))
      end
      self
    end
    ```

    Remove keywords from a keyword attribute. Any matching keywords that exist in the named attribute are removed, including any multiple entries.

    If no keywords remain after this operation, or if `keywords` is `nil`, the attribute is deleted from the node.

    A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).

    See also [`#remove_class`](node#method-i-remove_class), [`#kwattr_values`](node#method-i-kwattr_values), [`#kwattr_add`](node#method-i-kwattr_add), [`#kwattr_append`](node#method-i-kwattr_append)

    Parameters

    - `attribute_name` (String) The name of the keyword attribute to be modified.

    - `keywords` (String, Array\<String\>) Keywords to be removed from the attribute named `attribute_name`. May be a string containing whitespace-delimited values, or an Array of String values. Any keywords present in the named attribute will be removed. If no keywords remain, or if `keywords` is nil, the attribute is deleted.

    Returns

    `self` ([`Node`](node)) for ease of chaining method calls.

    **Example:**

    Note that the `rel` attribute is deleted when empty.

    ``` ruby
    node                                    # => <a rel="nofollow noreferrer">link</a>
    node.kwattr_remove("rel", "nofollow")   # => <a rel="noreferrer">link</a>
    node.kwattr_remove("rel", "noreferrer") # => <a>link</a>
    ```

    Since v1.11.0
- name: Nokogiri::XML::Node#kwattr_values
  id: nokogiri/xml/node#method-i-kwattr_values
  summary: Fetch values from a keyword attribute of a Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    kwattr_values(attribute_name) → Array\<String\> Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 838
    def kwattr_values(attribute_name)
      keywordify(get_attribute(attribute_name) || [])
    end
    ```

    Fetch values from a keyword attribute of a [`Node`](node).

    A “keyword attribute” is a node attribute that contains a set of space-delimited values. Perhaps the most familiar example of this is the [`HTML`](../html4) “class” attribute used to contain [`CSS`](../css) classes. But other keyword attributes exist, for instance [the “rel” attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel).

    See also [`#classes`](node#method-i-classes), [`#kwattr_add`](node#method-i-kwattr_add), [`#kwattr_append`](node#method-i-kwattr_append), [`#kwattr_remove`](node#method-i-kwattr_remove)

    Parameters

    - `attribute_name` (String) The name of the keyword attribute to be inspected.

    Returns

    (Array\<String\>) The values present in the Node’s `attribute_name` attribute. If the attribute is empty or non-existent, the return value is an empty array.

    **Example:**

    ``` ruby
    node                      # => <a rel="nofollow noopener external">link</a>
    node.kwattr_values("rel") # => ["nofollow", "noopener", "external"]
    ```

    Since v1.11.0
- name: Nokogiri::XML::Node#lang
  id: nokogiri/xml/node#method-i-lang
  summary: Searches the language of a node, i.e
  belongs_to: Nokogiri::XML::Node
  description: |-
    lang Show source

    ``` c
    static VALUE
    get_lang(VALUE self_rb)
    {
      xmlNodePtr self ;
      xmlChar *lang ;
      VALUE lang_rb ;

      Noko_Node_Get_Struct(self_rb, xmlNode, self);

      lang = xmlNodeGetLang(self);
      if (lang) {
        lang_rb = NOKOGIRI_STR_NEW2(lang);
        xmlFree(lang);
        return lang_rb ;
      }

      return Qnil ;
    }
    ```

    Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.
- name: Nokogiri::XML::Node#lang=
  id: nokogiri/xml/node#method-i-lang-3D
  summary: Set the language of a node, i.e
  belongs_to: Nokogiri::XML::Node
  description: |-
    lang= Show source

    ``` c
    static VALUE
    set_lang(VALUE self_rb, VALUE lang_rb)
    {
      xmlNodePtr self ;
      xmlChar *lang ;

      Noko_Node_Get_Struct(self_rb, xmlNode, self);
      lang = (xmlChar *)StringValueCStr(lang_rb);

      xmlNodeSetLang(self, lang);

      return Qnil ;
    }
    ```

    Set the language of a node, i.e. the values of the xml:lang attribute.
- name: Nokogiri::XML::Node#last_element_child
  id: nokogiri/xml/node#method-i-last_element_child
  summary: The last child Node that is an element
  belongs_to: Nokogiri::XML::Node
  description: |-
    last_element_child() → Node Show source

    ``` c
    static VALUE
    rb_xml_node_last_element_child(VALUE self)
    {
      xmlNodePtr node, child;
      Noko_Node_Get_Struct(self, xmlNode, node);

      child = xmlLastElementChild(node);
      if (!child) { return Qnil; }

      return noko_xml_node_wrap(Qnil, child);
    }
    ```

    Returns

    The last child [`Node`](node) that is an element.

    **Example:**

    Note that the “hello” child, which is a [`Text`](text) node, is skipped and the `<span>yes</span>` element is returned.

    ``` ruby
    div = Nokogiri::HTML5("<div><span>no</span><span>yes</span>skip</div>").at_css("div")
    div.last_element_child
    # => #(Element:0x3c { name = "span", children = [ #(Text "yes")] })
    ```
- name: Nokogiri::XML::Node#line
  id: nokogiri/xml/node#method-i-line
  summary: The line number of this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    line() → Integer Show source

    ``` c
    static VALUE
    rb_xml_node_line(VALUE rb_node)
    {
      xmlNodePtr c_node;
      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      return LONG2NUM(xmlGetLineNo(c_node));
    }
    ```

    Returns

    The line number of this [`Node`](node).

    **⚠ The CRuby and JRuby implementations differ in important ways!**

    Semantic differences:

    - The CRuby method reflects the node’s line number *in the parsed string*

    - The JRuby method reflects the node’s line number *in the final DOM structure* after corrections have been applied

    Performance differences:

    - The CRuby method is [O(1)](https://en.wikipedia.org/wiki/Time_complexity#Constant_time) (constant time)

    - The JRuby method is [O(n)](https://en.wikipedia.org/wiki/Time_complexity#Linear_time) (linear time, where n is the number of nodes before/above the element in the DOM)

    If you’d like to help improve the JRuby implementation, please review these issues and reach out to the maintainers:

    - [github.com/sparklemotion/nokogiri/issues/1223](https://github.com/sparklemotion/nokogiri/issues/1223)

    - [github.com/sparklemotion/nokogiri/pull/2177](https://github.com/sparklemotion/nokogiri/pull/2177)

    - [github.com/sparklemotion/nokogiri/issues/2380](https://github.com/sparklemotion/nokogiri/issues/2380)
- name: Nokogiri::XML::Node#line=
  id: nokogiri/xml/node#method-i-line-3D
  summary: Sets the line for this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    line=(num) Show source

    ``` c
    static VALUE
    rb_xml_node_line_set(VALUE rb_node, VALUE rb_line_number)
    {
      xmlNodePtr c_node;
      int line_number = NUM2INT(rb_line_number);

      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      // libxml2 optionally uses xmlNode.psvi to store longer line numbers, but only for text nodes.
      // search for "psvi" in SAX2.c and tree.c to learn more.
      if (line_number < 65535) {
        c_node->line = (short) line_number;
      } else {
        c_node->line = 65535;
        if (c_node->type == XML_TEXT_NODE) {
          c_node->psvi = (void *)(ptrdiff_t) line_number;
        }
      }

      return rb_line_number;
    }
    ```

    Sets the line for this [`Node`](node). num must be less than 65535.
- name: Nokogiri::XML::Node#matches?
  id: nokogiri/xml/node#method-i-matches-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    matches? (selector) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1015
    def matches?(selector)
      ancestors.last.search(selector).include?(self)
    end
    ```

    Returns true if this [`Node`](node) matches `selector`
- name: Nokogiri::XML::Node#name
  id: nokogiri/xml/node#method-i-name
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    name

    Alias for: [node_name](node#method-i-node_name)
- name: Nokogiri::XML::Node#name=
  id: nokogiri/xml/node#method-i-name-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    name=(new_name)

    Alias for: [node_name=](node#method-i-node_name-3D)
- name: Nokogiri::XML::Node#namespace
  id: nokogiri/xml/node#method-i-namespace
  summary: The Namespace of the element or attribute node, or nil if there is no namespace
  belongs_to: Nokogiri::XML::Node
  description: |-
    namespace() → Namespace Show source

    ``` c
    static VALUE
    rb_xml_node_namespace(VALUE rb_node)
    {
      xmlNodePtr c_node ;
      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      if (c_node->ns) {
        return noko_xml_namespace_wrap(c_node->ns, c_node->doc);
      }

      return Qnil ;
    }
    ```

    Returns

    The [`Namespace`](namespace) of the element or attribute node, or `nil` if there is no namespace.

    **Example:**

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root>
        <first/>
        <second xmlns="http://example.com/child"/>
        <foo:third xmlns:foo="http://example.com/foo"/>
      </root>
    EOF
    doc.at_xpath("//first").namespace
    # => nil
    doc.at_xpath("//xmlns:second", "xmlns" => "http://example.com/child").namespace
    # => #(Namespace:0x3c { href = "http://example.com/child" })
    doc.at_xpath("//foo:third", "foo" => "http://example.com/foo").namespace
    # => #(Namespace:0x50 { prefix = "foo", href = "http://example.com/foo" })
    ```
- name: Nokogiri::XML::Node#namespace=
  id: nokogiri/xml/node#method-i-namespace-3D
  summary: Set the default namespace on this node (as would be defined with an “xmlns=” attribute in XML source), as a Namespace object ns
  belongs_to: Nokogiri::XML::Node
  description: |-
    namespace= (ns) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 437
    def namespace=(ns)
      return set_namespace(ns) unless ns

      unless Nokogiri::XML::Namespace === ns
        raise TypeError, "#{ns.class} can't be coerced into Nokogiri::XML::Namespace"
      end
      if ns.document != document
        raise ArgumentError, "namespace must be declared on the same document"
      end

      set_namespace(ns)
    end
    ```

    Set the default namespace on this node (as would be defined with an “xmlns=” attribute in [`XML`](../xml) source), as a [`Namespace`](namespace) object `ns`. Note that a [`Namespace`](namespace) added this way will NOT be serialized as an xmlns attribute for this node. You probably want [`#default_namespace=`](node#method-i-default_namespace-3D) instead, or perhaps [`#add_namespace_definition`](node#method-i-add_namespace_definition) with a nil prefix argument.
- name: Nokogiri::XML::Node#namespace_definitions
  id: nokogiri/xml/node#method-i-namespace_definitions
  summary: Namespaces that are defined directly on this node, as an Array of Namespace objects
  belongs_to: Nokogiri::XML::Node
  description: |-
    namespace_definitions() → Array\<Nokogiri::XML::Namespace\> Show source

    ``` c
    static VALUE
    namespace_definitions(VALUE rb_node)
    {
      /* this code in the mode of xmlHasProp() */
      xmlNodePtr c_node ;
      xmlNsPtr c_namespace;
      VALUE definitions = rb_ary_new();

      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      c_namespace = c_node->nsDef;
      if (!c_namespace) {
        return definitions;
      }

      while (c_namespace != NULL) {
        rb_ary_push(definitions, noko_xml_namespace_wrap(c_namespace, c_node->doc));
        c_namespace = c_namespace->next;
      }

      return definitions;
    }
    ```

    Returns

    Namespaces that are defined directly on this node, as an Array of [`Namespace`](namespace) objects. The array will be empty if no namespaces are defined on this node.

    **Example:**

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns="http://example.com/root">
        <first/>
        <second xmlns="http://example.com/child" xmlns:unused="http://example.com/unused"/>
        <foo:third xmlns:foo="http://example.com/foo"/>
      </root>
    EOF
    doc.at_xpath("//root:first", "root" => "http://example.com/root").namespace_definitions
    # => []
    doc.at_xpath("//xmlns:second", "xmlns" => "http://example.com/child").namespace_definitions
    # => [#(Namespace:0x3c { href = "http://example.com/child" }),
    #     #(Namespace:0x50 {
    #       prefix = "unused",
    #       href = "http://example.com/unused"
    #       })]
    doc.at_xpath("//foo:third", "foo" => "http://example.com/foo").namespace_definitions
    # => [#(Namespace:0x64 { prefix = "foo", href = "http://example.com/foo" })]
    ```
- name: Nokogiri::XML::Node#namespace_scopes
  id: nokogiri/xml/node#method-i-namespace_scopes
  summary: Array of all the Namespaces on this node and its ancestors
  belongs_to: Nokogiri::XML::Node
  description: |-
    namespace_scopes() → Array\<Nokogiri::XML::Namespace\> Show source

    ``` c
    static VALUE
    rb_xml_node_namespace_scopes(VALUE rb_node)
    {
      xmlNodePtr c_node ;
      xmlNsPtr *namespaces;
      VALUE scopes = rb_ary_new();
      int j;

      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      namespaces = xmlGetNsList(c_node->doc, c_node);
      if (!namespaces) {
        return scopes;
      }

      for (j = 0 ; namespaces[j] != NULL ; ++j) {
        rb_ary_push(scopes, noko_xml_namespace_wrap(namespaces[j], c_node->doc));
      }

      xmlFree(namespaces);
      return scopes;
    }
    ```

    Returns

    Array of all the Namespaces on this node and its ancestors.

    See also [`#namespaces`](node#method-i-namespaces)

    **Example:**

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns="http://example.com/root" xmlns:bar="http://example.com/bar">
        <first/>
        <second xmlns="http://example.com/child"/>
        <third xmlns:foo="http://example.com/foo"/>
      </root>
    EOF
    doc.at_xpath("//root:first", "root" => "http://example.com/root").namespace_scopes
    # => [#(Namespace:0x3c { href = "http://example.com/root" }),
    #     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
    doc.at_xpath("//child:second", "child" => "http://example.com/child").namespace_scopes
    # => [#(Namespace:0x64 { href = "http://example.com/child" }),
    #     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
    doc.at_xpath("//root:third", "root" => "http://example.com/root").namespace_scopes
    # => [#(Namespace:0x78 { prefix = "foo", href = "http://example.com/foo" }),
    #     #(Namespace:0x3c { href = "http://example.com/root" }),
    #     #(Namespace:0x50 { prefix = "bar", href = "http://example.com/bar" })]
    ```
- name: Nokogiri::XML::Node#namespaced_key?
  id: nokogiri/xml/node#method-i-namespaced_key-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    namespaced_key?(attribute, namespace) Show source

    ``` c
    static VALUE
    namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      if (xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),
                       NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace))) {
        return Qtrue;
      }
      return Qfalse;
    }
    ```

    Returns true if `attribute` is set with `namespace`
- name: Nokogiri::XML::Node#namespaces
  id: nokogiri/xml/node#method-i-namespaces
  summary: Fetch all the namespaces on this node and its ancestors
  belongs_to: Nokogiri::XML::Node
  description: |-
    namespaces() → Hash\<String(Namespace#prefix) ⇒ String(Namespace#href)\> Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1116
    def namespaces
      namespace_scopes.each_with_object({}) do |ns, hash|
        prefix = ns.prefix
        key = prefix ? "xmlns:#{prefix}" : "xmlns"
        hash[key] = ns.href
      end
    end
    ```

    Fetch all the namespaces on this node and its ancestors.

    Note that the keys in this hash [`XML`](../xml) attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix.

    The default namespace for this node will be included with key “xmlns”.

    See also [`#namespace_scopes`](node#method-i-namespace_scopes)

    Returns

    Hash containing all the namespaces on this node and its ancestors. The hash keys are the namespace prefix, and the hash value for each key is the namespace URI.

    **Example:**

    ``` ruby
    doc = Nokogiri::XML(<<~EOF)
      <root xmlns="http://example.com/root" xmlns:in_scope="http://example.com/in_scope">
        <first/>
        <second xmlns="http://example.com/child"/>
        <third xmlns:foo="http://example.com/foo"/>
      </root>
    EOF
    doc.at_xpath("//root:first", "root" => "http://example.com/root").namespaces
    # => {"xmlns"=>"http://example.com/root",
    #     "xmlns:in_scope"=>"http://example.com/in_scope"}
    doc.at_xpath("//child:second", "child" => "http://example.com/child").namespaces
    # => {"xmlns"=>"http://example.com/child",
    #     "xmlns:in_scope"=>"http://example.com/in_scope"}
    doc.at_xpath("//root:third", "root" => "http://example.com/root").namespaces
    # => {"xmlns:foo"=>"http://example.com/foo",
    #     "xmlns"=>"http://example.com/root",
    #     "xmlns:in_scope"=>"http://example.com/in_scope"}
    ```
- name: Nokogiri::XML::Node#native_content=
  id: nokogiri/xml/node#method-i-native_content-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    content= Show source

    ``` c
    static VALUE
    set_native_content(VALUE self, VALUE content)
    {
      xmlNodePtr node, child, next ;
      Noko_Node_Get_Struct(self, xmlNode, node);

      child = node->children;
      while (NULL != child) {
        next = child->next ;
        xmlUnlinkNode(child) ;
        noko_xml_document_pin_node(child);
        child = next ;
      }

      xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));
      return content;
    }
    ```

    Set the content for this [`Node`](node)
- name: Nokogiri::XML::Node#next
  id: nokogiri/xml/node#method-i-next
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    next_sibling

    Alias for: [next_sibling](node#method-i-next_sibling)
- name: Nokogiri::XML::Node#next=
  id: nokogiri/xml/node#method-i-next-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    next= (node_or_tags)

    Alias for: [add_next_sibling](node#method-i-add_next_sibling)
- name: Nokogiri::XML::Node#next_element
  id: nokogiri/xml/node#method-i-next_element
  summary: Returns the next Nokogiri::XML::Element type sibling node
  belongs_to: Nokogiri::XML::Node
  description: |-
    next_element Show source

    ``` c
    static VALUE
    next_element(VALUE self)
    {
      xmlNodePtr node, sibling;
      Noko_Node_Get_Struct(self, xmlNode, node);

      sibling = xmlNextElementSibling(node);
      if (!sibling) { return Qnil; }

      return noko_xml_node_wrap(Qnil, sibling);
    }
    ```

    Returns the next [`Nokogiri::XML::Element`](element) type sibling node.
- name: Nokogiri::XML::Node#next_sibling
  id: nokogiri/xml/node#method-i-next_sibling
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    next_sibling Show source

    ``` c
    static VALUE
    next_sibling(VALUE self)
    {
      xmlNodePtr node, sibling;
      Noko_Node_Get_Struct(self, xmlNode, node);

      sibling = node->next;
      if (!sibling) { return Qnil; }

      return noko_xml_node_wrap(Qnil, sibling) ;
    }
    ```

    Returns the next sibling node

    Also aliased as: [next](node#method-i-next)
- name: Nokogiri::XML::Node#node_name
  id: nokogiri/xml/node#method-i-node_name
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    name Show source

    ``` c
    static VALUE
    get_name(VALUE self)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      if (node->name) {
        return NOKOGIRI_STR_NEW2(node->name);
      }
      return Qnil;
    }
    ```

    Returns the name for this [`Node`](node)

    Also aliased as: [name](node#method-i-name)
- name: Nokogiri::XML::Node#node_name=
  id: nokogiri/xml/node#method-i-node_name-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    node_name= (new_name) Show source

    ``` c
    static VALUE
    set_name(VALUE self, VALUE new_name)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      xmlNodeSetName(node, (xmlChar *)StringValueCStr(new_name));
      return new_name;
    }
    ```

    Set the name for this [`Node`](node)

    Also aliased as: [name=](node#method-i-name-3D)
- name: Nokogiri::XML::Node#node_type
  id: nokogiri/xml/node#method-i-node_type
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    node_type Show source

    ``` c
    static VALUE
    node_type(VALUE self)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      return INT2NUM(node->type);
    }
    ```

    Get the type for this [`Node`](node)

    Also aliased as: [type](node#method-i-type)
- name: Nokogiri::XML::Node#parent
  id: nokogiri/xml/node#method-i-parent
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    parent Show source

    ``` c
    static VALUE
    get_parent(VALUE self)
    {
      xmlNodePtr node, parent;
      Noko_Node_Get_Struct(self, xmlNode, node);

      parent = node->parent;
      if (!parent) { return Qnil; }

      return noko_xml_node_wrap(Qnil, parent) ;
    }
    ```

    Get the parent [`Node`](node) for this [`Node`](node)
- name: Nokogiri::XML::Node#parent=
  id: nokogiri/xml/node#method-i-parent-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    parent= (parent_node) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 417
    def parent=(parent_node)
      parent_node.add_child(self)
    end
    ```

    Set the parent [`Node`](node) for this [`Node`](node)
- name: Nokogiri::XML::Node#parse
  id: nokogiri/xml/node#method-i-parse
  summary: Parse string_or_io as a document fragment within the context of this node
  belongs_to: Nokogiri::XML::Node
  description: |-
    parse (string_or_io, options = nil) { \|options\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1030
    def parse(string_or_io, options = nil)
      ##
      # When the current node is unparented and not an element node, use the
      # document as the parsing context instead. Otherwise, the in-context
      # parser cannot find an element or a document node.
      # Document Fragments are also not usable by the in-context parser.
      if !element? && !document? && (!parent || parent.fragment?)
        return document.parse(string_or_io, options)
      end

      options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)
      options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
      yield options if block_given?

      contents = if string_or_io.respond_to?(:read)
        string_or_io.read
      else
        string_or_io
      end

      return Nokogiri::XML::NodeSet.new(document) if contents.empty?

      # libxml2 does not obey the +recover+ option after encountering errors during +in_context+
      # parsing, and so this horrible hack is here to try to emulate recovery behavior.
      #
      # Unfortunately, this means we're no longer parsing "in context" and so namespaces that
      # would have been inherited from the context node won't be handled correctly. This hack was
      # written in 2010, and I regret it, because it's silently degrading functionality in a way
      # that's not easily prevented (or even detected).
      #
      # I think preferable behavior would be to either:
      #
      # a. add an error noting that we "fell back" and pointing the user to turning off the +recover+ option
      # b. don't recover, but raise a sensible exception
      #
      # For context and background: https://github.com/sparklemotion/nokogiri/issues/313
      # FIXME bug report: https://github.com/sparklemotion/nokogiri/issues/2092
      error_count = document.errors.length
      node_set = in_context(contents, options.to_i)
      if node_set.empty? && (document.errors.length > error_count)
        if options.recover?
          fragment = document.related_class("DocumentFragment").parse(contents)
          node_set = fragment.children
        else
          raise document.errors[error_count]
        end
      end
      node_set
    end
    ```

    Parse `string_or_io` as a document fragment within the context of **this** node. Returns a [`XML::NodeSet`](nodeset) containing the nodes parsed from `string_or_io`.
- name: Nokogiri::XML::Node#path
  id: nokogiri/xml/node#method-i-path
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    path Show source

    ``` c
    static VALUE
    rb_xml_node_path(VALUE rb_node)
    {
      xmlNodePtr c_node;
      xmlChar *c_path ;
      VALUE rval;

      Noko_Node_Get_Struct(rb_node, xmlNode, c_node);

      c_path = xmlGetNodePath(c_node);
      if (c_path == NULL) {
        // see https://github.com/sparklemotion/nokogiri/issues/2250
        // this behavior is clearly undesirable, but is what libxml <= 2.9.10 returned, and so we
        // do this for now to preserve the behavior across libxml2 versions.
        rval = NOKOGIRI_STR_NEW2("?");
      } else {
        rval = NOKOGIRI_STR_NEW2(c_path);
        xmlFree(c_path);
      }

      return rval ;
    }
    ```

    Returns the path associated with this [`Node`](node)
- name: Nokogiri::XML::Node#pointer_id
  id: nokogiri/xml/node#method-i-pointer_id
  summary: A unique id for this node based on the internal memory structures
  belongs_to: Nokogiri::XML::Node
  description: |-
    pointer_id() → Integer Show source

    ``` c
    static VALUE
    rb_xml_node_pointer_id(VALUE self)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);

      return rb_uint2inum((uintptr_t)(node));
    }
    ```

    Returns

    A unique id for this node based on the internal memory structures. This method is used by [`#==`](node#method-i-3D-3D) to determine node identity.
- name: Nokogiri::XML::Node#prepend_child
  id: nokogiri/xml/node#method-i-prepend_child
  summary: Add node_or_tags as the first child of this Node
  belongs_to: Nokogiri::XML::Node
  description: |-
    prepend_child (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 168
    def prepend_child(node_or_tags)
      if (first = children.first)
        # Mimic the error add_child would raise.
        raise "Document already has a root node" if document? && !(node_or_tags.comment? || node_or_tags.processing_instruction?)

        first.__send__(:add_sibling, :previous, node_or_tags)
      else
        add_child(node_or_tags)
      end
    end
    ```

    Add `node_or_tags` as the first child of this [`Node`](node).

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).

    Also see related method `add_child`.
- name: Nokogiri::XML::Node#previous
  id: nokogiri/xml/node#method-i-previous
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    previous_sibling

    Alias for: [previous_sibling](node#method-i-previous_sibling)
- name: Nokogiri::XML::Node#previous=
  id: nokogiri/xml/node#method-i-previous-3D
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    previous= (node_or_tags)

    Alias for: [add_previous_sibling](node#method-i-add_previous_sibling)
- name: Nokogiri::XML::Node#previous_element
  id: nokogiri/xml/node#method-i-previous_element
  summary: Returns the previous Nokogiri::XML::Element type sibling node
  belongs_to: Nokogiri::XML::Node
  description: |-
    previous_element Show source

    ``` c
    static VALUE
    previous_element(VALUE self)
    {
      xmlNodePtr node, sibling;
      Noko_Node_Get_Struct(self, xmlNode, node);

      /*
       *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
       */
      sibling = node->prev;
      if (!sibling) { return Qnil; }

      while (sibling && sibling->type != XML_ELEMENT_NODE) {
        sibling = sibling->prev;
      }

      return sibling ? noko_xml_node_wrap(Qnil, sibling) : Qnil ;
    }
    ```

    Returns the previous [`Nokogiri::XML::Element`](element) type sibling node.
- name: Nokogiri::XML::Node#previous_sibling
  id: nokogiri/xml/node#method-i-previous_sibling
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    previous_sibling Show source

    ``` c
    static VALUE
    previous_sibling(VALUE self)
    {
      xmlNodePtr node, sibling;
      Noko_Node_Get_Struct(self, xmlNode, node);

      sibling = node->prev;
      if (!sibling) { return Qnil; }

      return noko_xml_node_wrap(Qnil, sibling);
    }
    ```

    Returns the previous sibling node

    Also aliased as: [previous](node#method-i-previous)
- name: Nokogiri::XML::Node#processing_instruction?
  id: nokogiri/xml/node#method-i-processing_instruction-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    processing_instruction? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1150
    def processing_instruction?
      type == PI_NODE
    end
    ```

    Returns true if this is a [`ProcessingInstruction`](processinginstruction) node
- name: Nokogiri::XML::Node#read_only?
  id: nokogiri/xml/node#method-i-read_only-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    read_only? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1175
    def read_only?
      # According to gdome2, these are read-only node types
      [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)
    end
    ```

    Is this a read only node?
- name: Nokogiri::XML::Node#related_class
  id: nokogiri/xml/node#method-i-related_class
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    related_class(class_name) → Class Show source

    ``` ruby
    # File lib/nokogiri/class_resolver.rb, line 46
    def related_class(class_name)
      klass = nil
      inspecting = self.class

      while inspecting
        namespace_path = inspecting.name.split("::")[0..-2]
        inspecting = inspecting.superclass

        next unless VALID_NAMESPACES.include?(namespace_path.last)

        related_class_name = (namespace_path << class_name).join("::")
        klass = begin
          Object.const_get(related_class_name)
        rescue NameError
          nil
        end
        break if klass
      end
      klass
    end
    ```

    Included from [Nokogiri::ClassResolver](../classresolver)

    Find a class constant within the

    Some examples:

    ``` ruby
    Nokogiri::XML::Document.new.related_class("DocumentFragment")
    # => Nokogiri::XML::DocumentFragment
    Nokogiri::HTML4::Document.new.related_class("DocumentFragment")
    # => Nokogiri::HTML4::DocumentFragment
    ```

    Note this will also work for subclasses that follow the same convention, e.g.:

    ``` ruby
    Loofah::HTML::Document.new.related_class("DocumentFragment")
    # => Loofah::HTML::DocumentFragment
    ```

    And even if it’s a subclass, this will iterate through the superclasses:

    ``` ruby
    class ThisIsATopLevelClass < Nokogiri::HTML4::Builder ; end
    ThisIsATopLevelClass.new.related_class("Document")
    # => Nokogiri::HTML4::Document
    ```
- name: Nokogiri::XML::Node#remove
  id: nokogiri/xml/node#method-i-remove
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    remove ()

    Alias for: [unlink](node#method-i-unlink)
- name: Nokogiri::XML::Node#remove_attribute
  id: nokogiri/xml/node#method-i-remove_attribute
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    remove_attribute (name) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 643
    def remove_attribute(name)
      attr = attributes[name].remove if key?(name)
      clear_xpath_context if Nokogiri.jruby?
      attr
    end
    ```

    Remove the attribute named `name`

    Also aliased as: [delete](node#method-i-delete)
- name: Nokogiri::XML::Node#remove_class
  id: nokogiri/xml/node#method-i-remove_class
  summary: Remove HTML CSS classes from this node
  belongs_to: Nokogiri::XML::Node
  description: |-
    remove_class(css_classes) → self Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 809
    def remove_class(names = nil)
      kwattr_remove("class", names)
    end
    ```

    Remove [`HTML`](../html4) [`CSS`](../css) classes from this node. Any [`CSS`](../css) class names in `css_classes` that exist in this node’s “class” attribute are removed, including any multiple entries.

    If no [`CSS`](../css) classes remain after this operation, or if `css_classes` is `nil`, the “class” attribute is deleted from the node.

    This is a convenience function and is equivalent to:

    ``` ruby
    node.kwattr_remove("class", css_classes)
    ```

    Also see [`#kwattr_remove`](node#method-i-kwattr_remove), [`#classes`](node#method-i-classes), [`#add_class`](node#method-i-add_class), [`#append_class`](node#method-i-append_class)

    Parameters

    - `css_classes` (String, Array\<String\>)

      [`CSS`](../css) class names to be removed from the Node’s “class” attribute. May be a string containing whitespace-delimited names, or an Array of String names. Any class names already present will be removed. If no [`CSS`](../css) classes remain, the “class” attribute is deleted.

    Returns

    `self` ([`Nokogiri::XML::Node`](node)) for ease of chaining method calls.

    **Example**: Deleting a [`CSS`](../css) class

    Note that all instances of the class “section” are removed from the “class” attribute.

    ``` ruby
    node                         # => <div class="section header section"></div>
    node.remove_class("section") # => <div class="header"></div>
    ```

    **Example**: Deleting the only remaining [`CSS`](../css) class

    Note that the attribute is removed once there are no remaining classes.

    ``` ruby
    node                         # => <div class="section"></div>
    node.remove_class("section") # => <div></div>
    ```

    **Example**: Deleting multiple [`CSS`](../css) classes

    Note that the “class” attribute is deleted once it’s empty.

    ``` ruby
    node                                    # => <div class="section header float"></div>
    node.remove_class(["section", "float"]) # => <div class="header"></div>
    ```
- name: Nokogiri::XML::Node#replace
  id: nokogiri/xml/node#method-i-replace
  summary: Replace this Node with node_or_tags
  belongs_to: Nokogiri::XML::Node
  description: |-
    replace (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 369
    def replace(node_or_tags)
      raise("Cannot replace a node with no parent") unless parent

      # We cannot replace a text node directly, otherwise libxml will return
      # an internal error at parser.c:13031, I don't know exactly why
      # libxml is trying to find a parent node that is an element or document
      # so I can't tell if this is bug in libxml or not. issue #775.
      if text?
        replacee = Nokogiri::XML::Node.new("dummy", document)
        add_previous_sibling_node(replacee)
        unlink
        return replacee.replace(node_or_tags)
      end

      node_or_tags = parent.coerce(node_or_tags)

      if node_or_tags.is_a?(XML::NodeSet)
        node_or_tags.each { |n| add_previous_sibling(n) }
        unlink
      else
        replace_node(node_or_tags)
      end
      node_or_tags
    end
    ```

    Replace this [`Node`](node) with `node_or_tags`.

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String containing markup.

    Returns the reparented node (if `node_or_tags` is a [`Node`](node)), or [`NodeSet`](nodeset) (if `node_or_tags` is a [`DocumentFragment`](documentfragment), [`NodeSet`](nodeset), or String).

    Also see related method `swap`.
- name: Nokogiri::XML::Node#search
  id: nokogiri/xml/node#method-i-search
  summary: Search this object for paths
  belongs_to: Nokogiri::XML::Node
  description: |-
    search(\*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 51
    def search(*args)
      paths, handler, ns, binds = extract_params(args)

      xpaths = paths.map(&:to_s).map do |path|
        LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)
      end.flatten.uniq

      xpath(*(xpaths + [ns, handler, binds].compact))
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this object for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries:

    ``` ruby
    node.search("div.employee", ".//title")
    ```

    A hash of namespace bindings may be appended:

    ``` ruby
    node.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})
    node.search('bike|tire', {'bike' => 'http://schwinn.com/'})
    ```

    For [`XPath`](xpath) queries, a hash of variable bindings may also be appended to the namespace bindings. For example:

    ``` ruby
    node.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})
    ```

    💡 Custom [`XPath`](xpath) functions and [`CSS`](../css) pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:

    ``` ruby
    handler = Class.new {
      def regex node_set, regex
        node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      end
    }.new
    node.search('.//title[regex(., "\w+")]', 'div.employee:regex("[0-9]+")', handler)
    ```

    See [`Searchable#xpath`](searchable#method-i-xpath) and [`Searchable#css`](searchable#method-i-css) for further usage help.

    Also aliased as: [/](searchable#method-i-2F)
- name: Nokogiri::XML::Node#serialize
  id: nokogiri/xml/node#method-i-serialize
  summary: Serialize Node using options
  belongs_to: Nokogiri::XML::Node
  description: |-
    serialize (\*args, &block) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1280
    def serialize(*args, &block)
      options = if args.first.is_a?(Hash)
        args.shift
      else
        {
          encoding: args[0],
          save_with: args[1],
        }
      end

      options[:encoding] ||= document.encoding
      encoding = Encoding.find(options[:encoding] || "UTF-8")

      io = StringIO.new(String.new(encoding: encoding))

      write_to(io, options, &block)
      io.string
    end
    ```

    Serialize [`Node`](node) using `options`. Save options can also be set using a block.

    See also [`Nokogiri::XML::Node::SaveOptions`](node/saveoptions) and [Serialization and Generating Output at `Node`](node#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output).

    These two statements are equivalent:

    ``` ruby
    node.serialize(:encoding => 'UTF-8', :save_with => FORMAT | AS_XML)
    ```

    or

    ``` ruby
    node.serialize(:encoding => 'UTF-8') do |config|
      config.format.as_xml
    end
    ```
- name: Nokogiri::XML::Node#set_attribute
  id: nokogiri/xml/node#method-i-set_attribute
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    \[\]=(name, value) → value

    Alias for: [\[\]=](node#method-i-5B-5D-3D)
- name: Nokogiri::XML::Node#swap
  id: nokogiri/xml/node#method-i-swap
  summary: node_or_tags can be a Nokogiri::XML::Node, a ::DocumentFragment, a ::NodeSet, or a String Containing markup
  belongs_to: Nokogiri::XML::Node
  description: |-
    swap (node_or_tags) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 403
    def swap(node_or_tags)
      replace(node_or_tags)
      self
    end
    ```

    Swap this [`Node`](node) for `node_or_tags`

    `node_or_tags` can be a [`Nokogiri::XML::Node`](node), a ::DocumentFragment, a ::NodeSet, or a String Containing markup.

    Returns self, to support chaining of calls.

    Also see related method `replace`.
- name: Nokogiri::XML::Node#text
  id: nokogiri/xml/node#method-i-text
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    text() → String

    Alias for: [content](node#method-i-content)
- name: Nokogiri::XML::Node#text?
  id: nokogiri/xml/node#method-i-text-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    text? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1155
    def text?
      type == TEXT_NODE
    end
    ```

    Returns true if this is a [`Text`](text) node
- name: Nokogiri::XML::Node#to_html
  id: nokogiri/xml/node#method-i-to_html
  summary: See Node#write_to for a list of options
  belongs_to: Nokogiri::XML::Node
  description: |-
    to_html (options = {}) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1306
    def to_html(options = {})
      to_format(SaveOptions::DEFAULT_HTML, options)
    end
    ```

    Serialize this [`Node`](node) to [`HTML`](../html4)

    ``` ruby
    doc.to_html
    ```

    See [`Node#write_to`](node#method-i-write_to) for a list of `options`. For formatted output, use [`Node#to_xhtml`](node#method-i-to_xhtml) instead.
- name: Nokogiri::XML::Node#to_s
  id: nokogiri/xml/node#method-i-to_s
  summary: Turn this node in to a string
  belongs_to: Nokogiri::XML::Node
  description: |-
    to_s () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1190
    def to_s
      document.xml? ? to_xml : to_html
    end
    ```

    Turn this node in to a string. If the document is [`HTML`](../html4), this method returns html. If the document is [`XML`](../xml), this method returns [`XML`](../xml).
- name: Nokogiri::XML::Node#to_str
  id: nokogiri/xml/node#method-i-to_str
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    to_str() → String

    Alias for: [content](node#method-i-content)
- name: Nokogiri::XML::Node#to_xhtml
  id: nokogiri/xml/node#method-i-to_xhtml
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    to_xhtml (options = {}) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1327
    def to_xhtml(options = {})
      to_format(SaveOptions::DEFAULT_XHTML, options)
    end
    ```

    Serialize this [`Node`](node) to XHTML using `options`

    ``` ruby
    doc.to_xhtml(:indent => 5, :encoding => 'UTF-8')
    ```

    See [`Node#write_to`](node#method-i-write_to) for a list of `options`
- name: Nokogiri::XML::Node#to_xml
  id: nokogiri/xml/node#method-i-to_xml
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    to_xml (options = {}) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1316
    def to_xml(options = {})
      options[:save_with] ||= SaveOptions::DEFAULT_XML
      serialize(options)
    end
    ```

    Serialize this [`Node`](node) to [`XML`](../xml) using `options`

    ``` ruby
    doc.to_xml(:indent => 5, :encoding => 'UTF-8')
    ```

    See [`Node#write_to`](node#method-i-write_to) for a list of `options`
- name: Nokogiri::XML::Node#traverse
  id: nokogiri/xml/node#method-i-traverse
  summary: Yields self and all children to block recursively
  belongs_to: Nokogiri::XML::Node
  description: |-
    traverse () { \|self\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1233
    def traverse(&block)
      children.each { |j| j.traverse(&block) }
      yield(self)
    end
    ```

    Yields self and all children to `block` recursively.
- name: Nokogiri::XML::Node#type
  id: nokogiri/xml/node#method-i-type
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    node_type

    Alias for: [node_type](node#method-i-node_type)
- name: Nokogiri::XML::Node#unlink
  id: nokogiri/xml/node#method-i-unlink
  summary: Unlink this node from its current context
  belongs_to: Nokogiri::XML::Node
  description: |-
    unlink() → self Show source

    ``` c
    static VALUE
    unlink_node(VALUE self)
    {
      xmlNodePtr node;
      Noko_Node_Get_Struct(self, xmlNode, node);
      xmlUnlinkNode(node);
      noko_xml_document_pin_node(node);
      return self;
    }
    ```

    Unlink this node from its current context.

    Also aliased as: [remove](node#method-i-remove)
- name: Nokogiri::XML::Node#value?
  id: nokogiri/xml/node#method-i-value-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    value? (value) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 623
    def value?(value)
      values.include?(value)
    end
    ```

    Does this Node’s attributes include \<value\>
- name: Nokogiri::XML::Node#values
  id: nokogiri/xml/node#method-i-values
  summary: Get the attribute values for this Node
  belongs_to: Nokogiri::XML::Node
  description: "values () Show source\n\n``` ruby\n# File lib/nokogiri/xml/node.rb, line 617\ndef values\n  attribute_nodes.map(&:value)\nend\n```\n\nGet the attribute values for this [`Node`](node).\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Node.html](https://nokogiri.org/rdoc/Nokogiri/XML/Node.html)"
- name: Nokogiri::XML::Node#wrap
  id: nokogiri/xml/node#method-i-wrap
  summary: Wrap this Node with the node parsed from markup or a dup of the node
  belongs_to: Nokogiri::XML::Node
  description: |-
    wrap(markup) → self Show source

    wrap(node) → self

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 223
    def wrap(node_or_tags)
      case node_or_tags
      when String
        context_node = parent || document
        new_parent = context_node.coerce(node_or_tags).first
        if new_parent.nil?
          raise "Failed to parse '#{node_or_tags}' in the context of a '#{context_node.name}' element"
        end
      when XML::Node
        new_parent = node_or_tags.dup
      else
        raise ArgumentError, "Requires a String or Node argument, and cannot accept a #{node_or_tags.class}"
      end

      if parent
        add_next_sibling(new_parent)
      else
        new_parent.unlink
      end
      new_parent.add_child(self)

      self
    end
    ```

    Wrap this [`Node`](node) with the node parsed from `markup` or a dup of the `node`.

    Parameters

    - **markup** (String) Markup that is parsed and used as the wrapper. This node’s parent, if it exists, is used as the context node for parsing; otherwise the associated document is used. If the parsed fragment has multiple roots, the first root node is used as the wrapper.

    - **node** ([`Nokogiri::XML::Node`](node)) An element that is ‘#dup\`ed and used as the wrapper.

    Returns

    `self`, to support chaining.

    Also see [`NodeSet#wrap`](nodeset#method-i-wrap)

    **Example** with a `String` argument:

    ``` ruby
    doc = Nokogiri::HTML5(<<~HTML)
      <html><body>
        <a>asdf</a>
      </body></html>
    HTML
    doc.at_css("a").wrap("<div></div>")
    doc.to_html
    # => <html><head></head><body>
    #      <div><a>asdf</a></div>
    #    </body></html>
    ```

    **Example** with a `Node` argument:

    ``` ruby
    doc = Nokogiri::HTML5(<<~HTML)
      <html><body>
        <a>asdf</a>
      </body></html>
    HTML
    doc.at_css("a").wrap(doc.create_element("div"))
    doc.to_html
    # <html><head></head><body>
    #   <div><a>asdf</a></div>
    # </body></html>
    ```

    ## Searching via XPath or CSS Queries

    [↑ top](#top)

    ### Public Instance Methods
- name: Nokogiri::XML::Node#write_html_to
  id: nokogiri/xml/node#method-i-write_html_to
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    write_html_to (io, options = {}) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1375
    def write_html_to(io, options = {})
      write_format_to(SaveOptions::DEFAULT_HTML, io, options)
    end
    ```

    Write [`Node`](node) as [`HTML`](../html4) to `io` with `options`

    See [`Node#write_to`](node#method-i-write_to) for a list of `options`
- name: Nokogiri::XML::Node#write_to
  id: nokogiri/xml/node#method-i-write_to
  summary: Write Node to io with options
  belongs_to: Nokogiri::XML::Node
  description: |-
    write_to (io, \*options) { \|config\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1348
    def write_to(io, *options)
      options = options.first.is_a?(Hash) ? options.shift : {}
      encoding = options[:encoding] || options[0]
      if Nokogiri.jruby?
        save_options = options[:save_with] || options[1]
        indent_times = options[:indent] || 0
      else
        save_options = options[:save_with] || options[1] || SaveOptions::FORMAT
        indent_times = options[:indent] || 2
      end
      indent_text = options[:indent_text] || " "

      # Any string times 0 returns an empty string. Therefore, use the same
      # string instead of generating a new empty string for every node with
      # zero indentation.
      indentation = indent_times.zero? ? "" : (indent_text * indent_times)

      config = SaveOptions.new(save_options.to_i)
      yield config if block_given?

      native_write_to(io, encoding, indentation, config.options)
    end
    ```

    Write [`Node`](node) to `io` with `options`. `options` modify the output of this method. Valid options are:

    - `:encoding` for changing the encoding

    - `:indent_text` the indentation text, defaults to one space

    - `:indent` the number of `:indent_text` to use, defaults to 2

    - `:save_with` a combination of [`SaveOptions`](node/saveoptions) constants.

    To save with UTF-8 indented twice:

    ``` ruby
    node.write_to(io, :encoding => 'UTF-8', :indent => 2)
    ```

    To save indented with two dashes:

    ``` ruby
    node.write_to(io, :indent_text => '-', :indent => 2)
    ```
- name: Nokogiri::XML::Node#write_xhtml_to
  id: nokogiri/xml/node#method-i-write_xhtml_to
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    write_xhtml_to (io, options = {}) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1383
    def write_xhtml_to(io, options = {})
      write_format_to(SaveOptions::DEFAULT_XHTML, io, options)
    end
    ```

    Write [`Node`](node) as XHTML to `io` with `options`

    See [`Node#write_to`](node#method-i-write_to) for a list of `options`
- name: Nokogiri::XML::Node#write_xml_to
  id: nokogiri/xml/node#method-i-write_xml_to
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    write_xml_to (io, options = {}) Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1393
    def write_xml_to(io, options = {})
      options[:save_with] ||= SaveOptions::DEFAULT_XML
      write_to(io, options)
    end
    ```

    Write [`Node`](node) as [`XML`](../xml) to `io` with `options`

    ``` ruby
    doc.write_xml_to io, :encoding => 'UTF-8'
    ```

    See [`Node#write_to`](node#method-i-write_to) for a list of options

    ## Traversing Document Structure

    [↑ top](#top)

    ### Public Instance Methods
- name: Nokogiri::XML::Node#xml?
  id: nokogiri/xml/node#method-i-xml-3F
  summary: null
  belongs_to: Nokogiri::XML::Node
  description: |-
    xml? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 1135
    def xml?
      type == DOCUMENT_NODE
    end
    ```

    Returns true if this is an [`XML::Document`](document) node

    ### Protected Instance Methods
- name: Nokogiri::XML::Node#xpath
  id: nokogiri/xml/node#method-i-xpath
  summary: Search this node for XPath paths
  belongs_to: Nokogiri::XML::Node
  description: |-
    xpath(\*paths, \[namespace-bindings, variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 174
    def xpath(*args)
      paths, handler, ns, binds = extract_params(args)

      xpath_internal(self, paths, handler, ns, binds)
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this node for [`XPath`](xpath) `paths`. `paths` must be one or more [`XPath`](xpath) queries.

    ``` ruby
    node.xpath('.//title')
    ```

    A hash of namespace bindings may be appended. For example:

    ``` ruby
    node.xpath('.//foo:name', {'foo' => 'http://example.org/'})
    node.xpath('.//xmlns:name', node.root.namespaces)
    ```

    A hash of variable bindings may also be appended to the namespace bindings. For example:

    ``` ruby
    node.xpath('.//address[@domestic=$value]', nil, {:value => 'Yes'})
    ```

    💡 Custom [`XPath`](xpath) functions may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:

    ``` ruby
    handler = Class.new {
      def regex(node_set, regex)
        node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      end
    }.new
    node.xpath('.//title[regex(., "\w+")]', handler)
    ```

    ## Serialization and Generating Output

    [↑ top](#top)

    ### Public Instance Methods
- name: Nokogiri::XML::Node::new
  id: nokogiri/xml/node#method-c-new
  summary: Create a new node with name that belongs to document
  belongs_to: Nokogiri::XML::Node
  description: |-
    new(name, document) → Nokogiri::XML::Node Show source

    new(name, document) { \|node\| ... } → Nokogiri::XML::Node

    ``` ruby
    # File lib/nokogiri/xml/node.rb, line 126
    def initialize(name, document)
      # This is intentionally empty, and sets the method signature for subclasses.
    end
    ```

    Create a new node with `name` that belongs to `document`.

    If you intend to add a node to a document tree, it’s likely that you will prefer one of the [`Nokogiri::XML::Node`](node) methods like [`#add_child`](node#method-i-add_child), [`#add_next_sibling`](node#method-i-add_next_sibling), [`#replace`](node#method-i-replace), etc. which will both create an element (or subtree) and place it in the document tree.

    Another alternative, if you are concerned about performance, is Nokogiri::XML::Document#create_element which accepts additional arguments for contents or attributes but (like this method) avoids parsing markup.

    Parameters

    - `name` (String)

    - `document` ([`Nokogiri::XML::Document`](document)) The document to which the the returned node will belong.

    Yields

    [`Nokogiri::XML::Node`](node)

    Returns

    [`Nokogiri::XML::Node`](node)

    ### Public Instance Methods
- name: Nokogiri::XML::Node::SaveOptions
  id: nokogiri/xml/node/saveoptions
  summary: Save options for serializing nodes
  description: "# class Nokogiri::XML::Node::SaveOptions\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nSave options for serializing nodes. See the method group entitled [Serialization and Generating Output at `Node`](../node#class-Nokogiri::XML::Node-label-Serialization+and+Generating+Output) for usage.\n\n### Constants\n\nAS_BUILDER  \nSave builder created document\n\nAS_HTML  \nSave as [`HTML`](../../html4)\n\nAS_XHTML  \nSave as XHTML\n\nAS_XML  \nSave as [`XML`](../../xml)\n\nDEFAULT_HTML  \nthe default for [`HTML`](../../html4) document\n\nDEFAULT_XHTML  \nthe default for XHTML document\n\nDEFAULT_XML  \nthe default for [`XML`](../../xml) documents\n\nFORMAT  \nFormat serialized xml\n\nNO_DECLARATION  \nDo not include declarations\n\nNO_EMPTY_TAGS  \nDo not include empty tags\n\nNO_XHTML  \nDo not save XHTML\n\n### Attributes\n\noptions\\[R\\]\n\nInteger representation of the [`SaveOptions`](saveoptions)\n\nto_i\\[R\\]\n\nInteger representation of the [`SaveOptions`](saveoptions)\n\n### Public Class Methods\n\nnew(options = 0) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node/save_options.rb, line 47\ndef initialize(options = 0)\n  @options = options\nend\n```\n\nCreate a new [`SaveOptions`](saveoptions) object with `options`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Node/SaveOptions.html](https://nokogiri.org/rdoc/Nokogiri/XML/Node/SaveOptions.html)"
- name: Nokogiri::XML::Node::SaveOptions#options
  id: nokogiri/xml/node/saveoptions#attribute-i-options
  summary: null
  belongs_to: Nokogiri::XML::Node::SaveOptions
  description: |-
    options \[R\]

    Integer representation of the [`SaveOptions`](saveoptions)
- name: Nokogiri::XML::Node::SaveOptions#to_i
  id: nokogiri/xml/node/saveoptions#attribute-i-to_i
  summary: null
  belongs_to: Nokogiri::XML::Node::SaveOptions
  description: |-
    to_i \[R\]

    Integer representation of the [`SaveOptions`](saveoptions)

    ### Public Class Methods
- name: Nokogiri::XML::Node::SaveOptions::new
  id: nokogiri/xml/node/saveoptions#method-c-new
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::Node::SaveOptions
  description: "new (options = 0) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node/save_options.rb, line 47\ndef initialize(options = 0)\n  @options = options\nend\n```\n\nCreate a new [`SaveOptions`](saveoptions) object with `options`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Node/SaveOptions.html](https://nokogiri.org/rdoc/Nokogiri/XML/Node/SaveOptions.html)"
- name: Nokogiri::XML::NodeSet
  id: nokogiri/xml/nodeset
  summary: A NodeSet contains a list of Nokogiri::XML::Node objects
  description: "# class Nokogiri::XML::NodeSet\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nIncluded modules:  \n[Nokogiri::XML::Searchable](searchable)\n\nA [`NodeSet`](nodeset) contains a list of [`Nokogiri::XML::Node`](node) objects. Typically a [`NodeSet`](nodeset) is return as a result of searching a [`Document`](document) via [`Nokogiri::XML::Searchable#css`](searchable#method-i-css) or [`Nokogiri::XML::Searchable#xpath`](searchable#method-i-xpath)\n\n### Constants\n\nLOOKS_LIKE_XPATH  \nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nRegular expression used by [`Searchable#search`](searchable#method-i-search) to determine if a query string is [`CSS`](../css) or [`XPath`](xpath)\n\n### Attributes\n\ndocument\\[RW\\]\n\nThe [`Document`](document) this [`NodeSet`](nodeset) is associated with\n\n### Public Class Methods\n\nnew(document, list = \\[\\]) { \\|self\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 20\ndef initialize(document, list = [])\n  @document = document\n  document.decorate(self)\n  list.each { |x| self << x }\n  yield self if block_given?\nend\n```\n\nCreate a [`NodeSet`](nodeset) with `document` defaulting to `list`\n\n### Public Instance Methods\n\nsearch \\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]\n\nAlias for: [at](nodeset#method-i-at)\n\n&(node_set) Show source\n\n``` c\nstatic VALUE\nintersection(VALUE self, VALUE rb_other)\n{\n  xmlNodeSetPtr node_set, other ;\n  xmlNodeSetPtr intersection;\n\n  if (!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet)) {\n    rb_raise(rb_eArgError, \"node_set must be a Nokogiri::XML::NodeSet\");\n  }\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_other, xmlNodeSet, other);\n\n  intersection = xmlXPathIntersection(node_set, other);\n  return noko_xml_node_set_wrap(intersection, rb_iv_get(self, \"@document\"));\n}\n```\n\nSet Intersection — Returns a new [`NodeSet`](nodeset) containing nodes common to the two NodeSets.\n\n+(p1)\n\nAlias for: [\\|](nodeset#method-i-7C)\n\n-(node_set) Show source\n\n``` c\nstatic VALUE\nminus(VALUE self, VALUE rb_other)\n{\n  xmlNodeSetPtr node_set, other;\n  xmlNodeSetPtr new;\n  int j ;\n\n  if (!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet)) {\n    rb_raise(rb_eArgError, \"node_set must be a Nokogiri::XML::NodeSet\");\n  }\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Data_Get_Struct(rb_other, xmlNodeSet, other);\n\n  new = xmlXPathNodeSetMerge(NULL, node_set);\n  for (j = 0 ; j < other->nodeNr ; ++j) {\n    xpath_node_set_del(new, other->nodeTab[j]);\n  }\n\n  return noko_xml_node_set_wrap(new, rb_iv_get(self, \"@document\"));\n}\n```\n\nDifference - returns a new [`NodeSet`](nodeset) that is a copy of this [`NodeSet`](nodeset), removing each item that also appears in `node_set`\n\n\\<\\<(p1)\n\nAlias for: [push](nodeset#method-i-push)\n\n==(other) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 393\ndef ==(other)\n  return false unless other.is_a?(Nokogiri::XML::NodeSet)\n  return false unless length == other.length\n\n  each_with_index do |node, i|\n    return false unless node == other[i]\n  end\n  true\nend\n```\n\nEquality – Two NodeSets are equal if the contain the same number of elements and if each element is equal to the corresponding element in the other [`NodeSet`](nodeset)\n\n\\[index\\] → Node or nil Show source\n\n\\[start, length\\] → NodeSet or nil\n\n\\[range\\] → NodeSet or nil\n\n``` c\nstatic VALUE\nslice(int argc, VALUE *argv, VALUE self)\n{\n  VALUE arg ;\n  long beg, len ;\n  xmlNodeSetPtr node_set;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  if (argc == 2) {\n    beg = NUM2LONG(argv[0]);\n    len = NUM2LONG(argv[1]);\n    if (beg < 0) {\n      beg += node_set->nodeNr ;\n    }\n    return subseq(self, beg, len);\n  }\n\n  if (argc != 1) {\n    rb_scan_args(argc, argv, \"11\", NULL, NULL);\n  }\n  arg = argv[0];\n\n  if (FIXNUM_P(arg)) {\n    return index_at(self, FIX2LONG(arg));\n  }\n\n  /* if arg is Range */\n  switch (rb_range_beg_len(arg, &beg, &len, (long)node_set->nodeNr, 0)) {\n    case Qfalse:\n      break;\n    case Qnil:\n      return Qnil;\n    default:\n      return subseq(self, beg, len);\n  }\n\n  return index_at(self, NUM2LONG(arg));\n}\n```\n\n[`Element`](element) reference - returns the node at `index`, or returns a [`NodeSet`](nodeset) containing nodes starting at `start` and continuing for `length` elements, or returns a [`NodeSet`](nodeset) containing nodes specified by `range`. Negative `indices` count backward from the end of the `node_set` (-1 is the last node). Returns nil if the `index` (or `start`) are out of range.\n\nAlso aliased as: [slice](nodeset#method-i-slice)\n\nadd_class(name) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 139\ndef add_class(name)\n  each do |el|\n    el.add_class(name)\n  end\n  self\nend\n```\n\nAdd the class attribute `name` to all [`Node`](node) objects in the [`NodeSet`](nodeset).\n\nSee [`Nokogiri::XML::Node#add_class`](node#method-i-add_class) for more information.\n\nafter(datum) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 69\ndef after(datum)\n  last.after(datum)\nend\n```\n\nInsert `datum` after the last [`Node`](node) in this [`NodeSet`](nodeset)\n\nappend_class(name) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 151\ndef append_class(name)\n  each do |el|\n    el.append_class(name)\n  end\n  self\nend\n```\n\nAppend the class attribute `name` to all [`Node`](node) objects in the [`NodeSet`](nodeset).\n\nSee [`Nokogiri::XML::Node#append_class`](node#method-i-append_class) for more information.\n\nsearch \\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\] Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 119\ndef at(*args)\n  if args.length == 1 && args.first.is_a?(Numeric)\n    return self[args.first]\n  end\n\n  super(*args)\nend\n```\n\nSearch this object for `paths`, and return only the first result. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.\n\nSee [`Searchable#search`](searchable#method-i-search) for more information.\n\nOr, if passed an integer, index into the NodeSet:\n\n``` ruby\nnode_set.at(3) # same as node_set[3]\n```\n\nCalls superclass method [`Nokogiri::XML::Searchable#at`](searchable#method-i-at)\n\nAlso aliased as: [%](nodeset#method-i-25)\n\nattr(key, value = nil) { \\|node\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 203\ndef attr(key, value = nil, &block)\n  unless key.is_a?(Hash) || (key && (value || block))\n    return first&.attribute(key)\n  end\n\n  hash = key.is_a?(Hash) ? key : { key => value }\n\n  hash.each do |k, v|\n    each do |node|\n      node[k] = v || yield(node)\n    end\n  end\n\n  self\nend\n```\n\nSet attributes on each [`Node`](node) in the [`NodeSet`](nodeset), or get an attribute from the first [`Node`](node) in the [`NodeSet`](nodeset).\n\nTo get an attribute from the first [`Node`](node) in a NodeSet:\n\n``` ruby\nnode_set.attr(\"href\") # => \"https://www.nokogiri.org\"\n```\n\nNote that an empty [`NodeSet`](nodeset) will return nil when `#attr` is called as a getter.\n\nTo set an attribute on each node, `key` can either be an attribute name, or a Hash of attribute names and values. When called as a setter, `#attr` returns the [`NodeSet`](nodeset).\n\nIf `key` is an attribute name, then either `value` or `block` must be passed.\n\nIf `key` is a Hash then attributes will be set for each key/value pair:\n\n``` ruby\nnode_set.attr(\"href\" => \"https://www.nokogiri.org\", \"class\" => \"member\")\n```\n\nIf `value` is passed, it will be used as the attribute value for all nodes:\n\n``` ruby\nnode_set.attr(\"href\", \"https://www.nokogiri.org\")\n```\n\nIf `block` is passed, it will be called on each [`Node`](node) object in the [`NodeSet`](nodeset) and the return value used as the attribute value for that node:\n\n``` ruby\nnode_set.attr(\"class\") { |node| node.name }\n```\n\nAlso aliased as: [set](nodeset#method-i-set), [attribute](nodeset#method-i-attribute)\n\nattribute(key, value = nil, &block)\n\nAlias for: [attr](nodeset#method-i-attr)\n\nbefore(datum) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 63\ndef before(datum)\n  first.before(datum)\nend\n```\n\nInsert `datum` before the first [`Node`](node) in this [`NodeSet`](nodeset)\n\nchildren() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 406\ndef children\n  node_set = NodeSet.new(document)\n  each do |node|\n    node.children.each { |n| node_set.push(n) }\n  end\n  node_set\nend\n```\n\nReturns a new [`NodeSet`](nodeset) containing all the children of all the nodes in the [`NodeSet`](nodeset)\n\ndup\n\nAlias for: [dup](nodeset#method-i-dup)\n\ncss \\*rules, \\[namespace-bindings, custom-pseudo-class\\] Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 83\ndef css(*args)\n  rules, handler, ns, _ = extract_params(args)\n  paths = css_rules_to_xpath(rules, ns)\n\n  inject(NodeSet.new(document)) do |set, node|\n    set + xpath_internal(node, paths, handler, ns, nil)\n  end\nend\n```\n\nSearch this node set for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:\n\nFor more information see [`Nokogiri::XML::Searchable#css`](searchable#method-i-css)\n\ndeconstruct() → Array Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 440\ndef deconstruct\n  to_a\nend\n```\n\nReturns the members of this [`NodeSet`](nodeset) as an array, to use in pattern matching.\n\n⚡ This is an experimental feature, available since v1.14.0\n\ndelete(node) Show source\n\n``` c\nstatic VALUE\ndelete (VALUE self, VALUE rb_node)\n{\n  xmlNodeSetPtr node_set;\n  xmlNodePtr node;\n\n  Check_Node_Set_Node_Type(rb_node);\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Noko_Node_Get_Struct(rb_node, xmlNode, node);\n\n  if (xmlXPathNodeSetContains(node_set, node)) {\n    xpath_node_set_del(node_set, node);\n    return rb_node;\n  }\n  return Qnil ;\n}\n```\n\nDelete `node` from the Nodeset, if it is a member. Returns the deleted node if found, otherwise returns nil.\n\ndup Show source\n\n``` c\nstatic VALUE\nduplicate(VALUE self)\n{\n  xmlNodeSetPtr node_set;\n  xmlNodeSetPtr dupl;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  dupl = xmlXPathNodeSetMerge(NULL, node_set);\n\n  return noko_xml_node_set_wrap(dupl, rb_iv_get(self, \"@document\"));\n}\n```\n\nDuplicate this [`NodeSet`](nodeset). Note that the Nodes contained in the [`NodeSet`](nodeset) are not duplicated (similar to how Array and other Enumerable classes work).\n\nAlso aliased as: [clone](nodeset#method-i-clone)\n\neach() { \\|self\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 231\ndef each\n  return to_enum unless block_given?\n\n  0.upto(length - 1) do |x|\n    yield self[x]\n  end\n  self\nend\n```\n\nIterate over each node, yielding to `block`\n\nempty?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 45\ndef empty?\n  length == 0\nend\n```\n\nIs this [`NodeSet`](nodeset) empty?\n\nfilter(expr) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 130\ndef filter(expr)\n  find_all { |node| node.matches?(expr) }\nend\n```\n\nFilter this list for nodes that match `expr`\n\nfirst(n = nil) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 29\ndef first(n = nil)\n  return self[0] unless n\n\n  list = []\n  [n, length].min.times { |i| list << self[i] }\n  list\nend\n```\n\nGet the first element of the [`NodeSet`](nodeset).\n\ninclude?(node) Show source\n\n``` c\nstatic VALUE\ninclude_eh(VALUE self, VALUE rb_node)\n{\n  xmlNodeSetPtr node_set;\n  xmlNodePtr node;\n\n  Check_Node_Set_Node_Type(rb_node);\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Noko_Node_Get_Struct(rb_node, xmlNode, node);\n\n  return (xmlXPathNodeSetContains(node_set, node) ? Qtrue : Qfalse);\n}\n```\n\nReturns true if any member of node set equals `node`.\n\nindex(node = nil) { \\|member\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 51\ndef index(node = nil)\n  if node\n    warn(\"given block not used\") if block_given?\n    each_with_index { |member, j| return j if member == node }\n  elsif block_given?\n    each_with_index { |member, j| return j if yield(member) }\n  end\n  nil\nend\n```\n\nReturns the index of the first node in self that is == to `node` or meets the given block. Returns nil if no match is found.\n\ninner_html(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 260\ndef inner_html(*args)\n  collect { |j| j.inner_html(*args) }.join(\"\")\nend\n```\n\nGet the inner html of all contained [`Node`](node) objects\n\ninner_text() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 253\ndef inner_text\n  collect(&:inner_text).join(\"\")\nend\n```\n\nGet the inner text of all contained [`Node`](node) objects\n\nNote: This joins the text of all [`Node`](node) objects in the NodeSet:\n\n``` ruby\ndoc = Nokogiri::XML('<xml><a><d>foo</d><d>bar</d></a></xml>')\ndoc.css('d').text # => \"foobar\"\n```\n\nInstead, if you want to return the text of all nodes in the NodeSet:\n\n``` ruby\ndoc.css('d').map(&:text) # => [\"foo\", \"bar\"]\n```\n\nSee [`Nokogiri::XML::Node#content`](node#method-i-content) for more information.\n\nAlso aliased as: [text](nodeset#method-i-text)\n\ninspect() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 427\ndef inspect\n  \"[#{map(&:inspect).join(\", \")}]\"\nend\n```\n\nReturn a nicely formated string representation\n\nlast() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 39\ndef last\n  self[-1]\nend\n```\n\nGet the last element of the [`NodeSet`](nodeset).\n\nlength Show source\n\n``` c\nstatic VALUE\nlength(VALUE self)\n{\n  xmlNodeSetPtr node_set;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  return node_set ? INT2NUM(node_set->nodeNr) : INT2NUM(0);\n}\n```\n\nGet the length of the node set\n\nAlso aliased as: [size](nodeset#method-i-size)\n\npop() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 374\ndef pop\n  return nil if length == 0\n\n  delete(last)\nend\n```\n\nRemoves the last element from set and returns it, or `nil` if the set is empty\n\npush(node) Show source\n\n``` c\nstatic VALUE\npush(VALUE self, VALUE rb_node)\n{\n  xmlNodeSetPtr node_set;\n  xmlNodePtr node;\n\n  Check_Node_Set_Node_Type(rb_node);\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n  Noko_Node_Get_Struct(rb_node, xmlNode, node);\n\n  xmlXPathNodeSetAdd(node_set, node);\n\n  return self;\n}\n```\n\nAppend `node` to the [`NodeSet`](nodeset).\n\nAlso aliased as: [\\<\\<](nodeset#method-i-3C-3C)\n\nunlink\n\nAlias for: [unlink](nodeset#method-i-unlink)\n\nremove_attr(name) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 223\ndef remove_attr(name)\n  each { |el| el.delete(name) }\n  self\nend\n```\n\nRemove the attributed named `name` from all [`Node`](node) objects in the [`NodeSet`](nodeset)\n\nAlso aliased as: [remove_attribute](nodeset#method-i-remove_attribute)\n\nremove_attribute(name)\n\nAlias for: [remove_attr](nodeset#method-i-remove_attr)\n\nremove_class(name = nil) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 163\ndef remove_class(name = nil)\n  each do |el|\n    el.remove_class(name)\n  end\n  self\nend\n```\n\nRemove the class attribute `name` from all [`Node`](node) objects in the [`NodeSet`](nodeset).\n\nSee [`Nokogiri::XML::Node#remove_class`](node#method-i-remove_class) for more information.\n\nreverse() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 417\ndef reverse\n  node_set = NodeSet.new(document)\n  (length - 1).downto(0) do |x|\n    node_set.push(self[x])\n  end\n  node_set\nend\n```\n\nReturns a new [`NodeSet`](nodeset) containing all the nodes in the [`NodeSet`](nodeset) in reverse order\n\nset(key, value = nil, &block)\n\nAlias for: [attr](nodeset#method-i-attr)\n\nshift() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 383\ndef shift\n  return nil if length == 0\n\n  delete(first)\nend\n```\n\nReturns the first element of the [`NodeSet`](nodeset) and removes it. Returns `nil` if the set is empty.\n\nlength\n\nAlias for: [length](nodeset#method-i-length)\n\nslice(index) → Node or nil\n\nslice(start, length) → NodeSet or nil\n\nslice(range) → NodeSet or nil\n\n[`Element`](element) reference - returns the node at `index`, or returns a [`NodeSet`](nodeset) containing nodes starting at `start` and continuing for `length` elements, or returns a [`NodeSet`](nodeset) containing nodes specified by `range`. Negative `indices` count backward from the end of the `node_set` (-1 is the last node). Returns nil if the `index` (or `start`) are out of range.\n\nAlias for: [\\[\\]](nodeset#method-i-5B-5D)\n\ntext()\n\nAlias for: [inner_text](nodeset#method-i-inner_text)\n\nto_a Show source\n\n``` c\nstatic VALUE\nto_array(VALUE self)\n{\n  xmlNodeSetPtr node_set ;\n  VALUE list;\n  int i;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  list = rb_ary_new2(node_set->nodeNr);\n  for (i = 0; i < node_set->nodeNr; i++) {\n    VALUE elt = noko_xml_node_wrap_node_set_result(node_set->nodeTab[i], self);\n    rb_ary_push(list, elt);\n  }\n\n  return list;\n}\n```\n\nReturn this list as an Array\n\nAlso aliased as: [to_ary](nodeset#method-i-to_ary)\n\nto_a\n\nAlias for: [to_a](nodeset#method-i-to_a)\n\nto_html(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 341\ndef to_html(*args)\n  if Nokogiri.jruby?\n    options = args.first.is_a?(Hash) ? args.shift : {}\n    options[:save_with] ||= Node::SaveOptions::DEFAULT_HTML\n    args.insert(0, options)\n  end\n  if empty?\n    encoding = (args.first.is_a?(Hash) ? args.first[:encoding] : nil)\n    encoding ||= document.encoding\n    encoding.nil? ? \"\" : \"\".encode(encoding)\n  else\n    map { |x| x.to_html(*args) }.join\n  end\nend\n```\n\nConvert this [`NodeSet`](nodeset) to [`HTML`](../html4)\n\nto_s() Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 335\ndef to_s\n  map(&:to_s).join\nend\n```\n\nConvert this [`NodeSet`](nodeset) to a string.\n\nto_xhtml(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 358\ndef to_xhtml(*args)\n  map { |x| x.to_xhtml(*args) }.join\nend\n```\n\nConvert this [`NodeSet`](nodeset) to XHTML\n\nto_xml(\\*args) Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 364\ndef to_xml(*args)\n  map { |x| x.to_xml(*args) }.join\nend\n```\n\nConvert this [`NodeSet`](nodeset) to [`XML`](../xml)\n\nunlink Show source\n\n``` c\nstatic VALUE\nunlink_nodeset(VALUE self)\n{\n  xmlNodeSetPtr node_set;\n  int j, nodeNr ;\n\n  Data_Get_Struct(self, xmlNodeSet, node_set);\n\n  nodeNr = node_set->nodeNr ;\n  for (j = 0 ; j < nodeNr ; j++) {\n    if (! NOKOGIRI_NAMESPACE_EH(node_set->nodeTab[j])) {\n      VALUE node ;\n      xmlNodePtr node_ptr;\n      node = noko_xml_node_wrap(Qnil, node_set->nodeTab[j]);\n      rb_funcall(node, rb_intern(\"unlink\"), 0); /* modifies the C struct out from under the object */\n      Noko_Node_Get_Struct(node, xmlNode, node_ptr);\n      node_set->nodeTab[j] = node_ptr ;\n    }\n  }\n  return self ;\n}\n```\n\nUnlink this [`NodeSet`](nodeset) and all [`Node`](node) objects it contains from their current context.\n\nAlso aliased as: [remove](nodeset#method-i-remove)\n\nwrap(markup) → self Show source\n\nwrap(node) → self\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 328\ndef wrap(node_or_tags)\n  map { |node| node.wrap(node_or_tags) }\n  self\nend\n```\n\nWrap each member of this [`NodeSet`](nodeset) with the node parsed from `markup` or a dup of the `node`.\n\nParameters\n\n- **markup** (String) Markup that is parsed, once per member of the [`NodeSet`](nodeset), and used as the wrapper. Each node’s parent, if it exists, is used as the context node for parsing; otherwise the associated document is used. If the parsed fragment has multiple roots, the first root node is used as the wrapper.\n\n- **node** ([`Nokogiri::XML::Node`](node)) An element that is ‘#dup\\`ed and used as the wrapper.\n\nReturns  \n`self`, to support chaining.\n\n⚠ Note that if a `String` is passed, the markup will be parsed **once per node** in the [`NodeSet`](nodeset). You can avoid this overhead in cases where you know exactly the wrapper you wish to use by passing a `Node` instead.\n\nAlso see [`Node#wrap`](node#method-i-wrap)\n\n**Example** with a `String` argument:\n\n``` ruby\ndoc = Nokogiri::HTML5(<<~HTML)\n  <html><body>\n    <a>a</a>\n    <a>b</a>\n    <a>c</a>\n    <a>d</a>\n  </body></html>\nHTML\ndoc.css(\"a\").wrap(\"<div></div>\")\ndoc.to_html\n# => <html><head></head><body>\n#      <div><a>a</a></div>\n#      <div><a>b</a></div>\n#      <div><a>c</a></div>\n#      <div><a>d</a></div>\n#    </body></html>\n```\n\n**Example** with a `Node` argument\n\n💡 Note that this is faster than the equivalent call passing a `String` because it avoids having to reparse the wrapper markup for each node.\n\n``` ruby\ndoc = Nokogiri::HTML5(<<~HTML)\n  <html><body>\n    <a>a</a>\n    <a>b</a>\n    <a>c</a>\n    <a>d</a>\n  </body></html>\nHTML\ndoc.css(\"a\").wrap(doc.create_element(\"div\"))\ndoc.to_html\n# => <html><head></head><body>\n#      <div><a>a</a></div>\n#      <div><a>b</a></div>\n#      <div><a>c</a></div>\n#      <div><a>d</a></div>\n#    </body></html>\n```\n\nxpath \\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\] Show source\n\n``` ruby\n# File lib/nokogiri/xml/node_set.rb, line 99\ndef xpath(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  inject(NodeSet.new(document)) do |set, node|\n    set + xpath_internal(node, paths, handler, ns, binds)\n  end\nend\n```\n\nSearch this node set for [`XPath`](xpath) `paths`. `paths` must be one or more [`XPath`](xpath) queries.\n\nFor more information see [`Nokogiri::XML::Searchable#xpath`](searchable#method-i-xpath)\n\n\\|(node_set) Show source\n\n``` c\nstatic VALUE\nrb_xml_node_set_union(VALUE rb_node_set, VALUE rb_other)\n{\n  xmlNodeSetPtr c_node_set, c_other;\n  xmlNodeSetPtr c_new_node_set;\n\n  if (!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet)) {\n    rb_raise(rb_eArgError, \"node_set must be a Nokogiri::XML::NodeSet\");\n  }\n\n  Data_Get_Struct(rb_node_set, xmlNodeSet, c_node_set);\n  Data_Get_Struct(rb_other, xmlNodeSet, c_other);\n\n  c_new_node_set = xmlXPathNodeSetMerge(NULL, c_node_set);\n  c_new_node_set = xmlXPathNodeSetMerge(c_new_node_set, c_other);\n\n  return noko_xml_node_set_wrap(c_new_node_set, rb_iv_get(rb_node_set, \"@document\"));\n}\n```\n\nReturns a new set built by merging the set and the elements of the given set.\n\nAlso aliased as: [+](nodeset#method-i-2B)\n\n## Searching via XPath or CSS Queries\n\n[↑ top](#top)\n\n### Public Instance Methods\n\n/(\\*args)\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nAlias for: [search](searchable#method-i-search)\n\n\\>(selector) → NodeSet Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 196\ndef >(selector) # rubocop:disable Naming/BinaryOperatorParameterName\n  ns = (document.root&.namespaces || {})\n  xpath(CSS.xpath_for(selector, prefix: \"./\", ns: ns).first)\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this node’s immediate children using [`CSS`](../css) selector `selector`\n\nat_css(\\*rules, \\[namespace-bindings, custom-pseudo-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 140\ndef at_css(*args)\n  css(*args).first\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for [`CSS`](../css) `rules`, and return only the first match. `rules` must be one or more [`CSS`](../css) selectors.\n\nSee [`Searchable#css`](searchable#method-i-css) for more information.\n\nat_xpath(\\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 188\ndef at_xpath(*args)\n  xpath(*args).first\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this node for [`XPath`](xpath) `paths`, and return only the first match. `paths` must be one or more [`XPath`](xpath) queries.\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) for more information.\n\nsearch(\\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 51\ndef search(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpaths = paths.map(&:to_s).map do |path|\n    LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)\n  end.flatten.uniq\n\n  xpath(*(xpaths + [ns, handler, binds].compact))\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries:\n\n``` ruby\nnode.search(\"div.employee\", \".//title\")\n```\n\nA hash of namespace bindings may be appended:\n\n``` ruby\nnode.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})\nnode.search('bike|tire', {'bike' => 'http://schwinn.com/'})\n```\n\nFor [`XPath`](xpath) queries, a hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions and [`CSS`](../css) pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex node_set, regex\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.search('.//title[regex(., \"\\w+\")]', 'div.employee:regex(\"[0-9]+\")', handler)\n```\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) and [`Searchable#css`](searchable#method-i-css) for further usage help.\n\nAlso aliased as: [/](searchable#method-i-2F)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/NodeSet.html](https://nokogiri.org/rdoc/Nokogiri/XML/NodeSet.html)"
- name: Nokogiri::XML::NodeSet#%
  id: nokogiri/xml/nodeset#method-i-25
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    search \*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\]

    Alias for: [at](nodeset#method-i-at)
- name: Nokogiri::XML::NodeSet#&
  id: nokogiri/xml/nodeset#method-i-26
  summary: Set Intersection — Returns a new NodeSet containing nodes common to the two NodeSets
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    &(node_set) Show source

    ``` c
    static VALUE
    intersection(VALUE self, VALUE rb_other)
    {
      xmlNodeSetPtr node_set, other ;
      xmlNodeSetPtr intersection;

      if (!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet)) {
        rb_raise(rb_eArgError, "node_set must be a Nokogiri::XML::NodeSet");
      }

      Data_Get_Struct(self, xmlNodeSet, node_set);
      Data_Get_Struct(rb_other, xmlNodeSet, other);

      intersection = xmlXPathIntersection(node_set, other);
      return noko_xml_node_set_wrap(intersection, rb_iv_get(self, "@document"));
    }
    ```

    Set Intersection — Returns a new [`NodeSet`](nodeset) containing nodes common to the two NodeSets.
- name: Nokogiri::XML::NodeSet#+
  id: nokogiri/xml/nodeset#method-i-2B
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    + (p1)

    Alias for: [\|](nodeset#method-i-7C)
- name: Nokogiri::XML::NodeSet#-
  id: nokogiri/xml/nodeset#method-i-2D
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    -(node_set) Show source

    ``` c
    static VALUE
    minus(VALUE self, VALUE rb_other)
    {
      xmlNodeSetPtr node_set, other;
      xmlNodeSetPtr new;
      int j ;

      if (!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet)) {
        rb_raise(rb_eArgError, "node_set must be a Nokogiri::XML::NodeSet");
      }

      Data_Get_Struct(self, xmlNodeSet, node_set);
      Data_Get_Struct(rb_other, xmlNodeSet, other);

      new = xmlXPathNodeSetMerge(NULL, node_set);
      for (j = 0 ; j < other->nodeNr ; ++j) {
        xpath_node_set_del(new, other->nodeTab[j]);
      }

      return noko_xml_node_set_wrap(new, rb_iv_get(self, "@document"));
    }
    ```

    Difference - returns a new [`NodeSet`](nodeset) that is a copy of this [`NodeSet`](nodeset), removing each item that also appears in `node_set`
- name: Nokogiri::XML::NodeSet#/
  id: nokogiri/xml/nodeset#method-i-2F
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    / (\*args)

    Included from [Nokogiri::XML::Searchable](searchable)

    Alias for: [search](searchable#method-i-search)
- name: Nokogiri::XML::NodeSet#<<
  id: nokogiri/xml/nodeset#method-i-3C-3C
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    \<\< (p1)

    Alias for: [push](nodeset#method-i-push)
- name: Nokogiri::XML::NodeSet#==
  id: nokogiri/xml/nodeset#method-i-3D-3D
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    == (other) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 393
    def ==(other)
      return false unless other.is_a?(Nokogiri::XML::NodeSet)
      return false unless length == other.length

      each_with_index do |node, i|
        return false unless node == other[i]
      end
      true
    end
    ```

    Equality – Two NodeSets are equal if the contain the same number of elements and if each element is equal to the corresponding element in the other [`NodeSet`](nodeset)
- name: Nokogiri::XML::NodeSet#>
  id: nokogiri/xml/nodeset#method-i-3E
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    \>(selector) → NodeSet Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 196
    def >(selector) # rubocop:disable Naming/BinaryOperatorParameterName
      ns = (document.root&.namespaces || {})
      xpath(CSS.xpath_for(selector, prefix: "./", ns: ns).first)
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this node’s immediate children using [`CSS`](../css) selector `selector`
- name: Nokogiri::XML::NodeSet#[]
  id: nokogiri/xml/nodeset#method-i-5B-5D
  summary: Element reference - returns the node at index, or returns a NodeSet containing nodes starting at start and continuing for length elements, or returns a NodeSet containing nodes specified by range
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    \[index\] → Node or nil Show source

    \[start, length\] → NodeSet or nil

    \[range\] → NodeSet or nil

    ``` c
    static VALUE
    slice(int argc, VALUE *argv, VALUE self)
    {
      VALUE arg ;
      long beg, len ;
      xmlNodeSetPtr node_set;

      Data_Get_Struct(self, xmlNodeSet, node_set);

      if (argc == 2) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        if (beg < 0) {
          beg += node_set->nodeNr ;
        }
        return subseq(self, beg, len);
      }

      if (argc != 1) {
        rb_scan_args(argc, argv, "11", NULL, NULL);
      }
      arg = argv[0];

      if (FIXNUM_P(arg)) {
        return index_at(self, FIX2LONG(arg));
      }

      /* if arg is Range */
      switch (rb_range_beg_len(arg, &beg, &len, (long)node_set->nodeNr, 0)) {
        case Qfalse:
          break;
        case Qnil:
          return Qnil;
        default:
          return subseq(self, beg, len);
      }

      return index_at(self, NUM2LONG(arg));
    }
    ```

    [`Element`](element) reference - returns the node at `index`, or returns a [`NodeSet`](nodeset) containing nodes starting at `start` and continuing for `length` elements, or returns a [`NodeSet`](nodeset) containing nodes specified by `range`. Negative `indices` count backward from the end of the `node_set` (-1 is the last node). Returns nil if the `index` (or `start`) are out of range.

    Also aliased as: [slice](nodeset#method-i-slice)
- name: Nokogiri::XML::NodeSet#add_class
  id: nokogiri/xml/nodeset#method-i-add_class
  summary: Add the class attribute name to all Node objects in the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    add_class (name) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 139
    def add_class(name)
      each do |el|
        el.add_class(name)
      end
      self
    end
    ```

    Add the class attribute `name` to all [`Node`](node) objects in the [`NodeSet`](nodeset).

    See [`Nokogiri::XML::Node#add_class`](node#method-i-add_class) for more information.
- name: Nokogiri::XML::NodeSet#after
  id: nokogiri/xml/nodeset#method-i-after
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    after (datum) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 69
    def after(datum)
      last.after(datum)
    end
    ```

    Insert `datum` after the last [`Node`](node) in this [`NodeSet`](nodeset)
- name: Nokogiri::XML::NodeSet#append_class
  id: nokogiri/xml/nodeset#method-i-append_class
  summary: Append the class attribute name to all Node objects in the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    append_class (name) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 151
    def append_class(name)
      each do |el|
        el.append_class(name)
      end
      self
    end
    ```

    Append the class attribute `name` to all [`Node`](node) objects in the [`NodeSet`](nodeset).

    See [`Nokogiri::XML::Node#append_class`](node#method-i-append_class) for more information.
- name: Nokogiri::XML::NodeSet#at
  id: nokogiri/xml/nodeset#method-i-at
  summary: Search this object for paths, and return only the first result
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    search \*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\] Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 119
    def at(*args)
      if args.length == 1 && args.first.is_a?(Numeric)
        return self[args.first]
      end

      super(*args)
    end
    ```

    Search this object for `paths`, and return only the first result. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.

    See [`Searchable#search`](searchable#method-i-search) for more information.

    Or, if passed an integer, index into the NodeSet:

    ``` ruby
    node_set.at(3) # same as node_set[3]
    ```

    Calls superclass method [`Nokogiri::XML::Searchable#at`](searchable#method-i-at)

    Also aliased as: [%](nodeset#method-i-25)
- name: Nokogiri::XML::NodeSet#at_css
  id: nokogiri/xml/nodeset#method-i-at_css
  summary: Search this object for CSS rules, and return only the first match
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    at_css(\*rules, \[namespace-bindings, custom-pseudo-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 140
    def at_css(*args)
      css(*args).first
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this object for [`CSS`](../css) `rules`, and return only the first match. `rules` must be one or more [`CSS`](../css) selectors.

    See [`Searchable#css`](searchable#method-i-css) for more information.
- name: Nokogiri::XML::NodeSet#at_xpath
  id: nokogiri/xml/nodeset#method-i-at_xpath
  summary: Search this node for XPath paths, and return only the first match
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    at_xpath(\*paths, \[namespace-bindings, variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 188
    def at_xpath(*args)
      xpath(*args).first
    end
    ```

    Included from [Nokogiri::XML::Searchable](searchable)

    Search this node for [`XPath`](xpath) `paths`, and return only the first match. `paths` must be one or more [`XPath`](xpath) queries.

    See [`Searchable#xpath`](searchable#method-i-xpath) for more information.
- name: Nokogiri::XML::NodeSet#attr
  id: nokogiri/xml/nodeset#method-i-attr
  summary: Set attributes on each Node in the NodeSet, or get an attribute from the first Node in the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    attr (key, value = nil) { \|node\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 203
    def attr(key, value = nil, &block)
      unless key.is_a?(Hash) || (key && (value || block))
        return first&.attribute(key)
      end

      hash = key.is_a?(Hash) ? key : { key => value }

      hash.each do |k, v|
        each do |node|
          node[k] = v || yield(node)
        end
      end

      self
    end
    ```

    Set attributes on each [`Node`](node) in the [`NodeSet`](nodeset), or get an attribute from the first [`Node`](node) in the [`NodeSet`](nodeset).

    To get an attribute from the first [`Node`](node) in a NodeSet:

    ``` ruby
    node_set.attr("href") # => "https://www.nokogiri.org"
    ```

    Note that an empty [`NodeSet`](nodeset) will return nil when `#attr` is called as a getter.

    To set an attribute on each node, `key` can either be an attribute name, or a Hash of attribute names and values. When called as a setter, `#attr` returns the [`NodeSet`](nodeset).

    If `key` is an attribute name, then either `value` or `block` must be passed.

    If `key` is a Hash then attributes will be set for each key/value pair:

    ``` ruby
    node_set.attr("href" => "https://www.nokogiri.org", "class" => "member")
    ```

    If `value` is passed, it will be used as the attribute value for all nodes:

    ``` ruby
    node_set.attr("href", "https://www.nokogiri.org")
    ```

    If `block` is passed, it will be called on each [`Node`](node) object in the [`NodeSet`](nodeset) and the return value used as the attribute value for that node:

    ``` ruby
    node_set.attr("class") { |node| node.name }
    ```

    Also aliased as: [set](nodeset#method-i-set), [attribute](nodeset#method-i-attribute)
- name: Nokogiri::XML::NodeSet#attribute
  id: nokogiri/xml/nodeset#method-i-attribute
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    attribute (key, value = nil, &block)

    Alias for: [attr](nodeset#method-i-attr)
- name: Nokogiri::XML::NodeSet#before
  id: nokogiri/xml/nodeset#method-i-before
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    before (datum) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 63
    def before(datum)
      first.before(datum)
    end
    ```

    Insert `datum` before the first [`Node`](node) in this [`NodeSet`](nodeset)
- name: Nokogiri::XML::NodeSet#children
  id: nokogiri/xml/nodeset#method-i-children
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    children () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 406
    def children
      node_set = NodeSet.new(document)
      each do |node|
        node.children.each { |n| node_set.push(n) }
      end
      node_set
    end
    ```

    Returns a new [`NodeSet`](nodeset) containing all the children of all the nodes in the [`NodeSet`](nodeset)
- name: Nokogiri::XML::NodeSet#clone
  id: nokogiri/xml/nodeset#method-i-clone
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    dup

    Alias for: [dup](nodeset#method-i-dup)
- name: Nokogiri::XML::NodeSet#css
  id: nokogiri/xml/nodeset#method-i-css
  summary: Search this node set for CSS rules
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    css \*rules, \[namespace-bindings, custom-pseudo-class\] Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 83
    def css(*args)
      rules, handler, ns, _ = extract_params(args)
      paths = css_rules_to_xpath(rules, ns)

      inject(NodeSet.new(document)) do |set, node|
        set + xpath_internal(node, paths, handler, ns, nil)
      end
    end
    ```

    Search this node set for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:

    For more information see [`Nokogiri::XML::Searchable#css`](searchable#method-i-css)
- name: Nokogiri::XML::NodeSet#deconstruct
  id: nokogiri/xml/nodeset#method-i-deconstruct
  summary: Returns the members of this NodeSet as an array, to use in pattern matching
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    deconstruct() → Array Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 440
    def deconstruct
      to_a
    end
    ```

    Returns the members of this [`NodeSet`](nodeset) as an array, to use in pattern matching.

    ⚡ This is an experimental feature, available since v1.14.0
- name: Nokogiri::XML::NodeSet#delete
  id: nokogiri/xml/nodeset#method-i-delete
  summary: Delete node from the Nodeset, if it is a member
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    delete(node) Show source

    ``` c
    static VALUE
    delete (VALUE self, VALUE rb_node)
    {
      xmlNodeSetPtr node_set;
      xmlNodePtr node;

      Check_Node_Set_Node_Type(rb_node);

      Data_Get_Struct(self, xmlNodeSet, node_set);
      Noko_Node_Get_Struct(rb_node, xmlNode, node);

      if (xmlXPathNodeSetContains(node_set, node)) {
        xpath_node_set_del(node_set, node);
        return rb_node;
      }
      return Qnil ;
    }
    ```

    Delete `node` from the Nodeset, if it is a member. Returns the deleted node if found, otherwise returns nil.
- name: Nokogiri::XML::NodeSet#document
  id: nokogiri/xml/nodeset#attribute-i-document
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    document \[RW\]

    The [`Document`](document) this [`NodeSet`](nodeset) is associated with

    ### Public Class Methods
- name: Nokogiri::XML::NodeSet#dup
  id: nokogiri/xml/nodeset#method-i-dup
  summary: Duplicate this NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    dup Show source

    ``` c
    static VALUE
    duplicate(VALUE self)
    {
      xmlNodeSetPtr node_set;
      xmlNodeSetPtr dupl;

      Data_Get_Struct(self, xmlNodeSet, node_set);

      dupl = xmlXPathNodeSetMerge(NULL, node_set);

      return noko_xml_node_set_wrap(dupl, rb_iv_get(self, "@document"));
    }
    ```

    Duplicate this [`NodeSet`](nodeset). Note that the Nodes contained in the [`NodeSet`](nodeset) are not duplicated (similar to how Array and other Enumerable classes work).

    Also aliased as: [clone](nodeset#method-i-clone)
- name: Nokogiri::XML::NodeSet#each
  id: nokogiri/xml/nodeset#method-i-each
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    each () { \|self\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 231
    def each
      return to_enum unless block_given?

      0.upto(length - 1) do |x|
        yield self[x]
      end
      self
    end
    ```

    Iterate over each node, yielding to `block`
- name: Nokogiri::XML::NodeSet#empty?
  id: nokogiri/xml/nodeset#method-i-empty-3F
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    empty? () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 45
    def empty?
      length == 0
    end
    ```

    Is this [`NodeSet`](nodeset) empty?
- name: Nokogiri::XML::NodeSet#filter
  id: nokogiri/xml/nodeset#method-i-filter
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    filter (expr) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 130
    def filter(expr)
      find_all { |node| node.matches?(expr) }
    end
    ```

    Filter this list for nodes that match `expr`
- name: Nokogiri::XML::NodeSet#first
  id: nokogiri/xml/nodeset#method-i-first
  summary: Get the first element of the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    first (n = nil) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 29
    def first(n = nil)
      return self[0] unless n

      list = []
      [n, length].min.times { |i| list << self[i] }
      list
    end
    ```

    Get the first element of the [`NodeSet`](nodeset).
- name: Nokogiri::XML::NodeSet#include?
  id: nokogiri/xml/nodeset#method-i-include-3F
  summary: Returns true if any member of node set equals node
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    include?(node) Show source

    ``` c
    static VALUE
    include_eh(VALUE self, VALUE rb_node)
    {
      xmlNodeSetPtr node_set;
      xmlNodePtr node;

      Check_Node_Set_Node_Type(rb_node);

      Data_Get_Struct(self, xmlNodeSet, node_set);
      Noko_Node_Get_Struct(rb_node, xmlNode, node);

      return (xmlXPathNodeSetContains(node_set, node) ? Qtrue : Qfalse);
    }
    ```

    Returns true if any member of node set equals `node`.
- name: Nokogiri::XML::NodeSet#index
  id: nokogiri/xml/nodeset#method-i-index
  summary: Returns the index of the first node in self that is == to node or meets the given block
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    index (node = nil) { \|member\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 51
    def index(node = nil)
      if node
        warn("given block not used") if block_given?
        each_with_index { |member, j| return j if member == node }
      elsif block_given?
        each_with_index { |member, j| return j if yield(member) }
      end
      nil
    end
    ```

    Returns the index of the first node in self that is == to `node` or meets the given block. Returns nil if no match is found.
- name: Nokogiri::XML::NodeSet#inner_html
  id: nokogiri/xml/nodeset#method-i-inner_html
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    inner_html (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 260
    def inner_html(*args)
      collect { |j| j.inner_html(*args) }.join("")
    end
    ```

    Get the inner html of all contained [`Node`](node) objects
- name: Nokogiri::XML::NodeSet#inner_text
  id: nokogiri/xml/nodeset#method-i-inner_text
  summary: See Nokogiri::XML::Node#content for more information
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    inner_text () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 253
    def inner_text
      collect(&:inner_text).join("")
    end
    ```

    Get the inner text of all contained [`Node`](node) objects

    Note: This joins the text of all [`Node`](node) objects in the NodeSet:

    ``` ruby
    doc = Nokogiri::XML('<xml><a><d>foo</d><d>bar</d></a></xml>')
    doc.css('d').text # => "foobar"
    ```

    Instead, if you want to return the text of all nodes in the NodeSet:

    ``` ruby
    doc.css('d').map(&:text) # => ["foo", "bar"]
    ```

    See [`Nokogiri::XML::Node#content`](node#method-i-content) for more information.

    Also aliased as: [text](nodeset#method-i-text)
- name: Nokogiri::XML::NodeSet#inspect
  id: nokogiri/xml/nodeset#method-i-inspect
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    inspect () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 427
    def inspect
      "[#{map(&:inspect).join(", ")}]"
    end
    ```

    Return a nicely formated string representation
- name: Nokogiri::XML::NodeSet#last
  id: nokogiri/xml/nodeset#method-i-last
  summary: Get the last element of the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    last () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 39
    def last
      self[-1]
    end
    ```

    Get the last element of the [`NodeSet`](nodeset).
- name: Nokogiri::XML::NodeSet#length
  id: nokogiri/xml/nodeset#method-i-length
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    length Show source

    ``` c
    static VALUE
    length(VALUE self)
    {
      xmlNodeSetPtr node_set;

      Data_Get_Struct(self, xmlNodeSet, node_set);

      return node_set ? INT2NUM(node_set->nodeNr) : INT2NUM(0);
    }
    ```

    Get the length of the node set

    Also aliased as: [size](nodeset#method-i-size)
- name: Nokogiri::XML::NodeSet#pop
  id: nokogiri/xml/nodeset#method-i-pop
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    pop () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 374
    def pop
      return nil if length == 0

      delete(last)
    end
    ```

    Removes the last element from set and returns it, or `nil` if the set is empty
- name: Nokogiri::XML::NodeSet#push
  id: nokogiri/xml/nodeset#method-i-push
  summary: Append node to the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    push(node) Show source

    ``` c
    static VALUE
    push(VALUE self, VALUE rb_node)
    {
      xmlNodeSetPtr node_set;
      xmlNodePtr node;

      Check_Node_Set_Node_Type(rb_node);

      Data_Get_Struct(self, xmlNodeSet, node_set);
      Noko_Node_Get_Struct(rb_node, xmlNode, node);

      xmlXPathNodeSetAdd(node_set, node);

      return self;
    }
    ```

    Append `node` to the [`NodeSet`](nodeset).

    Also aliased as: [\<\<](nodeset#method-i-3C-3C)
- name: Nokogiri::XML::NodeSet#remove
  id: nokogiri/xml/nodeset#method-i-remove
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    unlink

    Alias for: [unlink](nodeset#method-i-unlink)
- name: Nokogiri::XML::NodeSet#remove_attr
  id: nokogiri/xml/nodeset#method-i-remove_attr
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    remove_attr (name) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 223
    def remove_attr(name)
      each { |el| el.delete(name) }
      self
    end
    ```

    Remove the attributed named `name` from all [`Node`](node) objects in the [`NodeSet`](nodeset)

    Also aliased as: [remove_attribute](nodeset#method-i-remove_attribute)
- name: Nokogiri::XML::NodeSet#remove_attribute
  id: nokogiri/xml/nodeset#method-i-remove_attribute
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    remove_attribute (name)

    Alias for: [remove_attr](nodeset#method-i-remove_attr)
- name: Nokogiri::XML::NodeSet#remove_class
  id: nokogiri/xml/nodeset#method-i-remove_class
  summary: Remove the class attribute name from all Node objects in the NodeSet
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    remove_class (name = nil) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 163
    def remove_class(name = nil)
      each do |el|
        el.remove_class(name)
      end
      self
    end
    ```

    Remove the class attribute `name` from all [`Node`](node) objects in the [`NodeSet`](nodeset).

    See [`Nokogiri::XML::Node#remove_class`](node#method-i-remove_class) for more information.
- name: Nokogiri::XML::NodeSet#reverse
  id: nokogiri/xml/nodeset#method-i-reverse
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    reverse () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 417
    def reverse
      node_set = NodeSet.new(document)
      (length - 1).downto(0) do |x|
        node_set.push(self[x])
      end
      node_set
    end
    ```

    Returns a new [`NodeSet`](nodeset) containing all the nodes in the [`NodeSet`](nodeset) in reverse order
- name: Nokogiri::XML::NodeSet#search
  id: nokogiri/xml/nodeset#method-i-search
  summary: Search this object for paths
  belongs_to: Nokogiri::XML::NodeSet
  description: "search(\\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 51\ndef search(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpaths = paths.map(&:to_s).map do |path|\n    LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)\n  end.flatten.uniq\n\n  xpath(*(xpaths + [ns, handler, binds].compact))\nend\n```\n\nIncluded from [Nokogiri::XML::Searchable](searchable)\n\nSearch this object for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries:\n\n``` ruby\nnode.search(\"div.employee\", \".//title\")\n```\n\nA hash of namespace bindings may be appended:\n\n``` ruby\nnode.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})\nnode.search('bike|tire', {'bike' => 'http://schwinn.com/'})\n```\n\nFor [`XPath`](xpath) queries, a hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions and [`CSS`](../css) pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex node_set, regex\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.search('.//title[regex(., \"\\w+\")]', 'div.employee:regex(\"[0-9]+\")', handler)\n```\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) and [`Searchable#css`](searchable#method-i-css) for further usage help.\n\nAlso aliased as: [/](searchable#method-i-2F)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/NodeSet.html](https://nokogiri.org/rdoc/Nokogiri/XML/NodeSet.html)"
- name: Nokogiri::XML::NodeSet#set
  id: nokogiri/xml/nodeset#method-i-set
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    set (key, value = nil, &block)

    Alias for: [attr](nodeset#method-i-attr)
- name: Nokogiri::XML::NodeSet#shift
  id: nokogiri/xml/nodeset#method-i-shift
  summary: Returns the first element of the NodeSet and removes it
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    shift () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 383
    def shift
      return nil if length == 0

      delete(first)
    end
    ```

    Returns the first element of the [`NodeSet`](nodeset) and removes it. Returns `nil` if the set is empty.
- name: Nokogiri::XML::NodeSet#size
  id: nokogiri/xml/nodeset#method-i-size
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    length

    Alias for: [length](nodeset#method-i-length)
- name: Nokogiri::XML::NodeSet#slice
  id: nokogiri/xml/nodeset#method-i-slice
  summary: Element reference - returns the node at index, or returns a NodeSet containing nodes starting at start and continuing for length elements, or returns a NodeSet containing nodes specified by range
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    slice(index) → Node or nil

    slice(start, length) → NodeSet or nil

    slice(range) → NodeSet or nil

    [`Element`](element) reference - returns the node at `index`, or returns a [`NodeSet`](nodeset) containing nodes starting at `start` and continuing for `length` elements, or returns a [`NodeSet`](nodeset) containing nodes specified by `range`. Negative `indices` count backward from the end of the `node_set` (-1 is the last node). Returns nil if the `index` (or `start`) are out of range.

    Alias for: [\[\]](nodeset#method-i-5B-5D)
- name: Nokogiri::XML::NodeSet#text
  id: nokogiri/xml/nodeset#method-i-text
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    text ()

    Alias for: [inner_text](nodeset#method-i-inner_text)
- name: Nokogiri::XML::NodeSet#to_a
  id: nokogiri/xml/nodeset#method-i-to_a
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    to_a Show source

    ``` c
    static VALUE
    to_array(VALUE self)
    {
      xmlNodeSetPtr node_set ;
      VALUE list;
      int i;

      Data_Get_Struct(self, xmlNodeSet, node_set);

      list = rb_ary_new2(node_set->nodeNr);
      for (i = 0; i < node_set->nodeNr; i++) {
        VALUE elt = noko_xml_node_wrap_node_set_result(node_set->nodeTab[i], self);
        rb_ary_push(list, elt);
      }

      return list;
    }
    ```

    Return this list as an Array

    Also aliased as: [to_ary](nodeset#method-i-to_ary)
- name: Nokogiri::XML::NodeSet#to_ary
  id: nokogiri/xml/nodeset#method-i-to_ary
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    to_a

    Alias for: [to_a](nodeset#method-i-to_a)
- name: Nokogiri::XML::NodeSet#to_html
  id: nokogiri/xml/nodeset#method-i-to_html
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    to_html (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 341
    def to_html(*args)
      if Nokogiri.jruby?
        options = args.first.is_a?(Hash) ? args.shift : {}
        options[:save_with] ||= Node::SaveOptions::DEFAULT_HTML
        args.insert(0, options)
      end
      if empty?
        encoding = (args.first.is_a?(Hash) ? args.first[:encoding] : nil)
        encoding ||= document.encoding
        encoding.nil? ? "" : "".encode(encoding)
      else
        map { |x| x.to_html(*args) }.join
      end
    end
    ```

    Convert this [`NodeSet`](nodeset) to [`HTML`](../html4)
- name: Nokogiri::XML::NodeSet#to_s
  id: nokogiri/xml/nodeset#method-i-to_s
  summary: Convert this NodeSet to a string
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    to_s () Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 335
    def to_s
      map(&:to_s).join
    end
    ```

    Convert this [`NodeSet`](nodeset) to a string.
- name: Nokogiri::XML::NodeSet#to_xhtml
  id: nokogiri/xml/nodeset#method-i-to_xhtml
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    to_xhtml (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 358
    def to_xhtml(*args)
      map { |x| x.to_xhtml(*args) }.join
    end
    ```

    Convert this [`NodeSet`](nodeset) to XHTML
- name: Nokogiri::XML::NodeSet#to_xml
  id: nokogiri/xml/nodeset#method-i-to_xml
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    to_xml (\*args) Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 364
    def to_xml(*args)
      map { |x| x.to_xml(*args) }.join
    end
    ```

    Convert this [`NodeSet`](nodeset) to [`XML`](../xml)
- name: Nokogiri::XML::NodeSet#unlink
  id: nokogiri/xml/nodeset#method-i-unlink
  summary: Unlink this NodeSet and all Node objects it contains from their current context
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    unlink Show source

    ``` c
    static VALUE
    unlink_nodeset(VALUE self)
    {
      xmlNodeSetPtr node_set;
      int j, nodeNr ;

      Data_Get_Struct(self, xmlNodeSet, node_set);

      nodeNr = node_set->nodeNr ;
      for (j = 0 ; j < nodeNr ; j++) {
        if (! NOKOGIRI_NAMESPACE_EH(node_set->nodeTab[j])) {
          VALUE node ;
          xmlNodePtr node_ptr;
          node = noko_xml_node_wrap(Qnil, node_set->nodeTab[j]);
          rb_funcall(node, rb_intern("unlink"), 0); /* modifies the C struct out from under the object */
          Noko_Node_Get_Struct(node, xmlNode, node_ptr);
          node_set->nodeTab[j] = node_ptr ;
        }
      }
      return self ;
    }
    ```

    Unlink this [`NodeSet`](nodeset) and all [`Node`](node) objects it contains from their current context.

    Also aliased as: [remove](nodeset#method-i-remove)
- name: Nokogiri::XML::NodeSet#wrap
  id: nokogiri/xml/nodeset#method-i-wrap
  summary: Wrap each member of this NodeSet with the node parsed from markup or a dup of the node
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    wrap(markup) → self Show source

    wrap(node) → self

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 328
    def wrap(node_or_tags)
      map { |node| node.wrap(node_or_tags) }
      self
    end
    ```

    Wrap each member of this [`NodeSet`](nodeset) with the node parsed from `markup` or a dup of the `node`.

    Parameters

    - **markup** (String) Markup that is parsed, once per member of the [`NodeSet`](nodeset), and used as the wrapper. Each node’s parent, if it exists, is used as the context node for parsing; otherwise the associated document is used. If the parsed fragment has multiple roots, the first root node is used as the wrapper.

    - **node** ([`Nokogiri::XML::Node`](node)) An element that is ‘#dup\`ed and used as the wrapper.

    Returns

    `self`, to support chaining.

    ⚠ Note that if a `String` is passed, the markup will be parsed **once per node** in the [`NodeSet`](nodeset). You can avoid this overhead in cases where you know exactly the wrapper you wish to use by passing a `Node` instead.

    Also see [`Node#wrap`](node#method-i-wrap)

    **Example** with a `String` argument:

    ``` ruby
    doc = Nokogiri::HTML5(<<~HTML)
      <html><body>
        <a>a</a>
        <a>b</a>
        <a>c</a>
        <a>d</a>
      </body></html>
    HTML
    doc.css("a").wrap("<div></div>")
    doc.to_html
    # => <html><head></head><body>
    #      <div><a>a</a></div>
    #      <div><a>b</a></div>
    #      <div><a>c</a></div>
    #      <div><a>d</a></div>
    #    </body></html>
    ```

    **Example** with a `Node` argument

    💡 Note that this is faster than the equivalent call passing a `String` because it avoids having to reparse the wrapper markup for each node.

    ``` ruby
    doc = Nokogiri::HTML5(<<~HTML)
      <html><body>
        <a>a</a>
        <a>b</a>
        <a>c</a>
        <a>d</a>
      </body></html>
    HTML
    doc.css("a").wrap(doc.create_element("div"))
    doc.to_html
    # => <html><head></head><body>
    #      <div><a>a</a></div>
    #      <div><a>b</a></div>
    #      <div><a>c</a></div>
    #      <div><a>d</a></div>
    #    </body></html>
    ```
- name: Nokogiri::XML::NodeSet#xpath
  id: nokogiri/xml/nodeset#method-i-xpath
  summary: Search this node set for XPath paths
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    xpath \*paths, \[namespace-bindings, variable-bindings, custom-handler-class\] Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 99
    def xpath(*args)
      paths, handler, ns, binds = extract_params(args)

      inject(NodeSet.new(document)) do |set, node|
        set + xpath_internal(node, paths, handler, ns, binds)
      end
    end
    ```

    Search this node set for [`XPath`](xpath) `paths`. `paths` must be one or more [`XPath`](xpath) queries.

    For more information see [`Nokogiri::XML::Searchable#xpath`](searchable#method-i-xpath)
- name: Nokogiri::XML::NodeSet#|
  id: nokogiri/xml/nodeset#method-i-7C
  summary: Returns a new set built by merging the set and the elements of the given set
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    \|(node_set) Show source

    ``` c
    static VALUE
    rb_xml_node_set_union(VALUE rb_node_set, VALUE rb_other)
    {
      xmlNodeSetPtr c_node_set, c_other;
      xmlNodeSetPtr c_new_node_set;

      if (!rb_obj_is_kind_of(rb_other, cNokogiriXmlNodeSet)) {
        rb_raise(rb_eArgError, "node_set must be a Nokogiri::XML::NodeSet");
      }

      Data_Get_Struct(rb_node_set, xmlNodeSet, c_node_set);
      Data_Get_Struct(rb_other, xmlNodeSet, c_other);

      c_new_node_set = xmlXPathNodeSetMerge(NULL, c_node_set);
      c_new_node_set = xmlXPathNodeSetMerge(c_new_node_set, c_other);

      return noko_xml_node_set_wrap(c_new_node_set, rb_iv_get(rb_node_set, "@document"));
    }
    ```

    Returns a new set built by merging the set and the elements of the given set.

    Also aliased as: [+](nodeset#method-i-2B)

    ## Searching via XPath or CSS Queries

    [↑ top](#top)

    ### Public Instance Methods
- name: Nokogiri::XML::NodeSet::new
  id: nokogiri/xml/nodeset#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::NodeSet
  description: |-
    new (document, list = \[\]) { \|self\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/node_set.rb, line 20
    def initialize(document, list = [])
      @document = document
      document.decorate(self)
      list.each { |x| self << x }
      yield self if block_given?
    end
    ```

    Create a [`NodeSet`](nodeset) with `document` defaulting to `list`

    ### Public Instance Methods
- name: Nokogiri::XML::Notation
  id: nokogiri/xml/notation
  summary: The name for the element
  description: "# class Nokogiri::XML::Notation\n\nParent:  \nStruct.new(:name, :public_id, :system_id)\n\nStruct representing an [XML Schema Notation](https://www.w3.org/TR/xml/#Notations)\n\n### Attributes\n\nname\\[RW\\]\n\nThe name for the element.\n\npublic_id\\[RW\\]\n\nThe URI corresponding to the public identifier\n\nsystem_id\\[RW\\]\n\nThe URI corresponding to the system identifier\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Notation.html](https://nokogiri.org/rdoc/Nokogiri/XML/Notation.html)"
- name: Nokogiri::XML::Notation#name
  id: nokogiri/xml/notation#attribute-i-name
  summary: The name for the element
  belongs_to: Nokogiri::XML::Notation
  description: |-
    name \[RW\]

    The name for the element.
- name: Nokogiri::XML::Notation#public_id
  id: nokogiri/xml/notation#attribute-i-public_id
  summary: null
  belongs_to: Nokogiri::XML::Notation
  description: |-
    public_id \[RW\]

    The URI corresponding to the public identifier
- name: Nokogiri::XML::Notation#system_id
  id: nokogiri/xml/notation#attribute-i-system_id
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::Notation
  description: "system_id \\[RW\\]\n\nThe URI corresponding to the system identifier\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Notation.html](https://nokogiri.org/rdoc/Nokogiri/XML/Notation.html)"
- name: Nokogiri::XML::parse
  id: nokogiri/xml#method-c-parse
  summary: Parse XML
  belongs_to: Nokogiri::XML
  description: "parse (thing, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml.rb, line 36\ndef parse(thing, url = nil, encoding = nil, options = ParseOptions::DEFAULT_XML, &block)\n  Document.parse(thing, url, encoding, options, &block)\nend\n```\n\nParse [`XML`](xml). Convenience method for [`Nokogiri::XML::Document.parse`](xml/document#method-c-parse)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML.html](https://nokogiri.org/rdoc/Nokogiri/XML.html)"
- name: Nokogiri::XML::ParseOptions
  id: nokogiri/xml/parseoptions
  summary: Options that control the parsing behavior for XML::Document, XML::DocumentFragment, HTML4::Document, HTML4::DocumentFragment, XSLT::Stylesheet, and XML::Schema
  description: "# class Nokogiri::XML::ParseOptions\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nOptions that control the parsing behavior for [`XML::Document`](document), [`XML::DocumentFragment`](documentfragment), [`HTML4::Document`](../html4/document), [`HTML4::DocumentFragment`](../html4/documentfragment), [`XSLT::Stylesheet`](../xslt/stylesheet), and [`XML::Schema`](schema).\n\nThese options directly expose libxml2’s parse options, which are all boolean in the sense that an option is “on” or “off”.\n\n💡 Note that [`HTML5`](../html5) parsing has a separate, orthogonal set of options due to the nature of the [`HTML5`](../html5) specification. See [`Nokogiri::HTML5`](../html5).\n\n⚠ Not all parse options are supported on JRuby. [`Nokogiri`](../../nokogiri) will attempt to invoke the equivalent behavior in Xerces/NekoHTML on JRuby when it’s possible.\n\n## Setting and unsetting parse options\n\nYou can build your own combinations of parse options by using any of the following methods:\n\n[`ParseOptions`](parseoptions) method chaining  \nEvery option has an equivalent method in lowercase. You can chain these methods together to set various combinations.\n\n``` ruby\n# Set the HUGE & PEDANTIC options\npo = Nokogiri::XML::ParseOptions.new.huge.pedantic\ndoc = Nokogiri::XML::Document.parse(xml, nil, nil, po)\n```\n\nEvery option has an equivalent `no{option}` method in lowercase. You can call these methods on an instance of [`ParseOptions`](parseoptions) to unset the option.\n\n``` ruby\n# Set the HUGE & PEDANTIC options\npo = Nokogiri::XML::ParseOptions.new.huge.pedantic\n\n# later we want to modify the options\npo.nohuge # Unset the HUGE option\npo.nopedantic # Unset the PEDANTIC option\n```\n\n💡 Note that some options begin with “no” leading to the logical but perhaps unintuitive double negative:\n\n``` ruby\npo.nocdata # Set the NOCDATA parse option\npo.nonocdata # Unset the NOCDATA parse option\n```\n\n💡 Note that negation is not available for [`STRICT`](parseoptions#STRICT), which is itself a negation of all other features.\n\nUsing Ruby Blocks  \nMost parsing methods will accept a block for configuration of parse options, and we recommend chaining the setter methods:\n\n``` ruby\ndoc = Nokogiri::XML::Document.parse(xml) { |config| config.huge.pedantic }\n```\n\n[`ParseOptions`](parseoptions) constants  \nYou can also use the constants declared under [`Nokogiri::XML::ParseOptions`](parseoptions) to set various combinations. They are bits in a bitmask, and so can be combined with bitwise operators:\n\n``` ruby\npo = Nokogiri::XML::ParseOptions.new(Nokogiri::XML::ParseOptions::HUGE | Nokogiri::XML::ParseOptions::PEDANTIC)\ndoc = Nokogiri::XML::Document.parse(xml, nil, nil, po)\n```\n\n### Constants\n\nBIG_LINES  \nSupport line numbers up to `long int` (default is a `short int`). On by default for for [`XML::Document`](document), [`XML::DocumentFragment`](documentfragment), [`HTML4::Document`](../html4/document), [`HTML4::DocumentFragment`](../html4/documentfragment), [`XSLT::Stylesheet`](../xslt/stylesheet), and [`XML::Schema`](schema).\n\nCOMPACT  \nCompact small text nodes. Off by default.\n\n⚠ No modification of the DOM tree is allowed after parsing. libxml2 may crash if you try to modify the tree.\n\nDEFAULT_HTML  \nThe options mask used by default used for parsing [`HTML4::Document`](../html4/document) and [`HTML4::DocumentFragment`](../html4/documentfragment)\n\nDEFAULT_SCHEMA  \nThe options mask used by default used for parsing [`XML::Schema`](schema)\n\nDEFAULT_XML  \nThe options mask used by default for parsing [`XML::Document`](document) and [`XML::DocumentFragment`](documentfragment)\n\nDEFAULT_XSLT  \nThe options mask used by default used for parsing [`XSLT::Stylesheet`](../xslt/stylesheet)\n\nDTDATTR  \nDefault [`DTD`](dtd) attributes. On by default for [`XSLT::Stylesheet`](../xslt/stylesheet).\n\nDTDLOAD  \nLoad external subsets. On by default for [`XSLT::Stylesheet`](../xslt/stylesheet).\n\n⚠ **It is UNSAFE to set this option** when parsing untrusted documents.\n\nDTDVALID  \nValidate with the [`DTD`](dtd). Off by default.\n\nHUGE  \nRelax any hardcoded limit from the parser. Off by default.\n\n⚠ There may be a performance penalty when this option is set.\n\nNOBASEFIX  \nDo not fixup XInclude xml:base uris. Off by default\n\nNOBLANKS  \nRemove blank nodes. Off by default.\n\nNOCDATA  \nMerge [`CDATA`](cdata) as text nodes. On by default for [`XSLT::Stylesheet`](../xslt/stylesheet).\n\nNODICT  \nDo not reuse the context dictionary. Off by default.\n\nNOENT  \nSubstitute entities. Off by default.\n\n⚠ This option enables entity substitution, contrary to what the name implies.\n\n⚠ **It is UNSAFE to set this option** when parsing untrusted documents.\n\nNOERROR  \nSuppress error reports. On by default for [`HTML4::Document`](../html4/document) and [`HTML4::DocumentFragment`](../html4/documentfragment)\n\nNONET  \nForbid network access. On by default for [`XML::Document`](document), [`XML::DocumentFragment`](documentfragment), [`HTML4::Document`](../html4/document), [`HTML4::DocumentFragment`](../html4/documentfragment), [`XSLT::Stylesheet`](../xslt/stylesheet), and [`XML::Schema`](schema).\n\n⚠ **It is UNSAFE to unset this option** when parsing untrusted documents.\n\nNOWARNING  \nSuppress warning reports. On by default for [`HTML4::Document`](../html4/document) and [`HTML4::DocumentFragment`](../html4/documentfragment)\n\nNOXINCNODE  \nDo not generate XInclude START/END nodes. Off by default.\n\nNSCLEAN  \nRemove redundant namespaces declarations. Off by default.\n\nOLD10  \nParse using XML-1.0 before update 5. Off by default\n\nPEDANTIC  \nEnable pedantic error reporting. Off by default.\n\nRECOVER  \nRecover from errors. On by default for [`XML::Document`](document), [`XML::DocumentFragment`](documentfragment), [`HTML4::Document`](../html4/document), [`HTML4::DocumentFragment`](../html4/documentfragment), [`XSLT::Stylesheet`](../xslt/stylesheet), and [`XML::Schema`](schema).\n\nSAX1  \nUse the [`SAX1`](parseoptions#SAX1) interface internally. Off by default.\n\nSTRICT  \nStrict parsing\n\nXINCLUDE  \nImplement XInclude substitution. Off by default.\n\n### Attributes\n\noptions\\[RW\\]\n\nto_i\\[RW\\]\n\n### Public Class Methods\n\nnew(options = STRICT) Show source\n\n``` ruby\n# File lib/nokogiri/xml/parse_options.rb, line 165\ndef initialize(options = STRICT)\n  @options = options\nend\n```\n\n### Public Instance Methods\n\n==(other) Show source\n\n``` ruby\n# File lib/nokogiri/xml/parse_options.rb, line 198\ndef ==(other)\n  other.to_i == to_i\nend\n```\n\ninspect() Show source\n\n``` ruby\n# File lib/nokogiri/xml/parse_options.rb, line 204\ndef inspect\n  options = []\n  self.class.constants.each do |k|\n    options << k.downcase if send(:\"#{k.downcase}?\")\n  end\n  super.sub(/>$/, \" \" + options.join(\", \") + \">\")\nend\n```\n\nCalls superclass method\n\nstrict() Show source\n\n``` ruby\n# File lib/nokogiri/xml/parse_options.rb, line 189\ndef strict\n  @options &= ~RECOVER\n  self\nend\n```\n\nstrict?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/parse_options.rb, line 194\ndef strict?\n  @options & RECOVER == STRICT\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ParseOptions.html](https://nokogiri.org/rdoc/Nokogiri/XML/ParseOptions.html)"
- name: Nokogiri::XML::ParseOptions#==
  id: nokogiri/xml/parseoptions#method-i-3D-3D
  summary: null
  belongs_to: Nokogiri::XML::ParseOptions
  description: |-
    == (other) Show source

    ``` ruby
    # File lib/nokogiri/xml/parse_options.rb, line 198
    def ==(other)
      other.to_i == to_i
    end
    ```
- name: Nokogiri::XML::ParseOptions#inspect
  id: nokogiri/xml/parseoptions#method-i-inspect
  summary: null
  belongs_to: Nokogiri::XML::ParseOptions
  description: |-
    inspect () Show source

    ``` ruby
    # File lib/nokogiri/xml/parse_options.rb, line 204
    def inspect
      options = []
      self.class.constants.each do |k|
        options << k.downcase if send(:"#{k.downcase}?")
      end
      super.sub(/>$/, " " + options.join(", ") + ">")
    end
    ```

    Calls superclass method
- name: Nokogiri::XML::ParseOptions#options
  id: nokogiri/xml/parseoptions#attribute-i-options
  summary: null
  belongs_to: Nokogiri::XML::ParseOptions
  description: options \[RW\]
- name: Nokogiri::XML::ParseOptions#strict
  id: nokogiri/xml/parseoptions#method-i-strict
  summary: null
  belongs_to: Nokogiri::XML::ParseOptions
  description: |-
    strict () Show source

    ``` ruby
    # File lib/nokogiri/xml/parse_options.rb, line 189
    def strict
      @options &= ~RECOVER
      self
    end
    ```
- name: Nokogiri::XML::ParseOptions#strict?
  id: nokogiri/xml/parseoptions#method-i-strict-3F
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::ParseOptions
  description: "strict? () Show source\n\n``` ruby\n# File lib/nokogiri/xml/parse_options.rb, line 194\ndef strict?\n  @options & RECOVER == STRICT\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ParseOptions.html](https://nokogiri.org/rdoc/Nokogiri/XML/ParseOptions.html)"
- name: Nokogiri::XML::ParseOptions#to_i
  id: nokogiri/xml/parseoptions#attribute-i-to_i
  summary: null
  belongs_to: Nokogiri::XML::ParseOptions
  description: |-
    to_i \[RW\]

    ### Public Class Methods
- name: Nokogiri::XML::ParseOptions::new
  id: nokogiri/xml/parseoptions#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::ParseOptions
  description: |-
    new (options = STRICT) Show source

    ``` ruby
    # File lib/nokogiri/xml/parse_options.rb, line 165
    def initialize(options = STRICT)
      @options = options
    end
    ```

    ### Public Instance Methods
- name: Nokogiri::XML::PP::CharacterData
  id: nokogiri/xml/pp/characterdata
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# module Nokogiri::XML::PP::CharacterData\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/PP/CharacterData.html](https://nokogiri.org/rdoc/Nokogiri/XML/PP/CharacterData.html)"
- name: Nokogiri::XML::PP::Node
  id: nokogiri/xml/pp/node
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# module Nokogiri::XML::PP::Node\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/PP/Node.html](https://nokogiri.org/rdoc/Nokogiri/XML/PP/Node.html)"
- name: Nokogiri::XML::ProcessingInstruction
  id: nokogiri/xml/processinginstruction
  summary: ProcessingInstruction represents a ProcessingInstruction node in an xml document
  description: "# class Nokogiri::XML::ProcessingInstruction\n\nParent:  \ncNokogiriXmlNode\n\n[`ProcessingInstruction`](processinginstruction) represents a [`ProcessingInstruction`](processinginstruction) node in an xml document.\n\n### Public Class Methods\n\nnew(document, name, content) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr xml_doc;\n  xmlNodePtr node;\n  VALUE document;\n  VALUE name;\n  VALUE content;\n  VALUE rest;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"3*\", &document, &name, &content, &rest);\n\n  Data_Get_Struct(document, xmlDoc, xml_doc);\n\n  node = xmlNewDocPI(\n           xml_doc,\n           (const xmlChar *)StringValueCStr(name),\n           (const xmlChar *)StringValueCStr(content)\n         );\n\n  noko_xml_document_pin_node(node);\n\n  rb_node = noko_xml_node_wrap(klass, node);\n  rb_obj_call_init(rb_node, argc, argv);\n\n  if (rb_block_given_p()) { rb_yield(rb_node); }\n\n  return rb_node;\n}\n```\n\nCreate a new [`ProcessingInstruction`](processinginstruction) element on the `document` with `name` and `content`\n\nnew(document, name, content) Show source\n\n``` ruby\n# File lib/nokogiri/xml/processing_instruction.rb, line 6\ndef initialize(document, name, content)\n  super(document, name)\nend\n```\n\nCalls superclass method\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/ProcessingInstruction.html](https://nokogiri.org/rdoc/Nokogiri/XML/ProcessingInstruction.html)"
- name: Nokogiri::XML::ProcessingInstruction::new
  id: nokogiri/xml/processinginstruction#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::ProcessingInstruction
  description: |-
    new(document, name, content) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr xml_doc;
      xmlNodePtr node;
      VALUE document;
      VALUE name;
      VALUE content;
      VALUE rest;
      VALUE rb_node;

      rb_scan_args(argc, argv, "3*", &document, &name, &content, &rest);

      Data_Get_Struct(document, xmlDoc, xml_doc);

      node = xmlNewDocPI(
               xml_doc,
               (const xmlChar *)StringValueCStr(name),
               (const xmlChar *)StringValueCStr(content)
             );

      noko_xml_document_pin_node(node);

      rb_node = noko_xml_node_wrap(klass, node);
      rb_obj_call_init(rb_node, argc, argv);

      if (rb_block_given_p()) { rb_yield(rb_node); }

      return rb_node;
    }
    ```

    Create a new [`ProcessingInstruction`](processinginstruction) element on the `document` with `name` and `content`
- name: Nokogiri::XML::Reader
  id: nokogiri/xml#method-c-Reader
  summary: Parse an XML document using the Nokogiri::XML::Reader API
  belongs_to: Nokogiri::XML
  description: |-
    Reader (string_or_io, url = nil, encoding = nil, options = ParseOptions::STRICT) { \|options\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml.rb, line 23
    def Reader(string_or_io, url = nil, encoding = nil, options = ParseOptions::STRICT)
      options = Nokogiri::XML::ParseOptions.new(options) if Integer === options
      yield options if block_given?

      if string_or_io.respond_to?(:read)
        return Reader.from_io(string_or_io, url, encoding, options.to_i)
      end

      Reader.from_memory(string_or_io, url, encoding, options.to_i)
    end
    ```

    Parse an [`XML`](xml) document using the [`Nokogiri::XML::Reader`](xml/reader) API. See [`Nokogiri::XML::Reader`](xml/reader) for mor information
- name: Nokogiri::XML::Reader
  id: nokogiri/xml/reader
  summary: The Reader parser allows you to effectively pull parse an XML document
  description: "# class Nokogiri::XML::Reader\n\nParent:\n\n[Object](https://nokogiri.org/rdoc/Object.html)\n\nIncluded modules:\n\nThe [`Reader`](reader) parser allows you to effectively pull parse an [`XML`](../xml) document. Once instantiated, call [`Nokogiri::XML::Reader#each`](reader#method-i-each) to iterate over each node. Note that you may only iterate over the document once!\n\n[`Nokogiri::XML::Reader`](reader) parses an [`XML`](../xml) document similar to the way a cursor would move. The [`Reader`](reader) is given an [`XML`](../xml) document, and yields nodes to an each block.\n\nHere is an example of usage:\n\n``` ruby\nreader = Nokogiri::XML::Reader(<<-eoxml)\n  <x xmlns:tenderlove='http://tenderlovemaking.com/'>\n    <tenderlove:foo awesome='true'>snuggles!</tenderlove:foo>\n  </x>\neoxml\n\nreader.each do |node|\n\n  # node is an instance of Nokogiri::XML::Reader\n  puts node.name\n\nend\n```\n\nNote that [`Nokogiri::XML::Reader#each`](reader#method-i-each) can only be called once!! Once the cursor moves through the entire document, you must parse the document again. So make sure that you capture any information you need during the first iteration.\n\nThe [`Reader`](reader) parser is good for when you need the speed of a [`SAX`](sax) parser, but do not want to write a [`Document`](document) handler.\n\n### Constants\n\nTYPE_ATTRIBUTE  \nAttribute node type\n\nTYPE_CDATA  \n[`CDATA`](cdata) node type\n\nTYPE_COMMENT  \n[`Comment`](comment) node type\n\nTYPE_DOCUMENT  \n[`Document`](document) node type\n\nTYPE_DOCUMENT_FRAGMENT  \n[`Document`](document) Fragment node type\n\nTYPE_DOCUMENT_TYPE  \n[`Document`](document) Type node type\n\nTYPE_ELEMENT  \n[`Element`](element) node type\n\nTYPE_END_ELEMENT  \n[`Element`](element) end node type\n\nTYPE_END_ENTITY  \nEntity end node type\n\nTYPE_ENTITY  \nEntity node type\n\nTYPE_ENTITY_REFERENCE  \nEntity Reference node type\n\nTYPE_NONE  \nTYPE_NOTATION  \n[`Notation`](notation) node type\n\nTYPE_PROCESSING_INSTRUCTION  \nPI node type\n\nTYPE_SIGNIFICANT_WHITESPACE  \nSignificant Whitespace node type\n\nTYPE_TEXT  \n[`Text`](text) node type\n\nTYPE_WHITESPACE  \nWhitespace node type\n\nTYPE_XML_DECLARATION  \n[`XML`](../xml) Declaration node type\n\n### Attributes\n\nerrors\\[RW\\]\n\nA list of errors encountered while parsing\n\nsource\\[R\\]\n\nThe [`XML`](../xml) source\n\n### Public Class Methods\n\nfrom_io(io, url = nil, encoding = nil, options = 0) Show source\n\n``` c\nstatic VALUE\nfrom_io(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE rb_io, rb_url, encoding, rb_options;\n  xmlTextReaderPtr reader;\n  const char *c_url      = NULL;\n  const char *c_encoding = NULL;\n  int c_options           = 0;\n  VALUE rb_reader, args[3];\n\n  rb_scan_args(argc, argv, \"13\", &rb_io, &rb_url, &encoding, &rb_options);\n\n  if (!RTEST(rb_io)) { rb_raise(rb_eArgError, \"io cannot be nil\"); }\n  if (RTEST(rb_url)) { c_url = StringValueCStr(rb_url); }\n  if (RTEST(encoding)) { c_encoding = StringValueCStr(encoding); }\n  if (RTEST(rb_options)) { c_options = (int)NUM2INT(rb_options); }\n\n  reader = xmlReaderForIO(\n             (xmlInputReadCallback)noko_io_read,\n             (xmlInputCloseCallback)noko_io_close,\n             (void *)rb_io,\n             c_url,\n             c_encoding,\n             c_options\n           );\n\n  if (reader == NULL) {\n    xmlFreeTextReader(reader);\n    rb_raise(rb_eRuntimeError, \"couldn't create a parser\");\n  }\n\n  rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);\n  args[0] = rb_io;\n  args[1] = rb_url;\n  args[2] = encoding;\n  rb_obj_call_init(rb_reader, 3, args);\n\n  return rb_reader;\n}\n```\n\nCreate a new reader that parses `io`\n\nfrom_memory(string, url = nil, encoding = nil, options = 0) Show source\n\n``` c\nstatic VALUE\nfrom_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE rb_buffer, rb_url, encoding, rb_options;\n  xmlTextReaderPtr reader;\n  const char *c_url      = NULL;\n  const char *c_encoding = NULL;\n  int c_options           = 0;\n  VALUE rb_reader, args[3];\n\n  rb_scan_args(argc, argv, \"13\", &rb_buffer, &rb_url, &encoding, &rb_options);\n\n  if (!RTEST(rb_buffer)) { rb_raise(rb_eArgError, \"string cannot be nil\"); }\n  if (RTEST(rb_url)) { c_url = StringValueCStr(rb_url); }\n  if (RTEST(encoding)) { c_encoding = StringValueCStr(encoding); }\n  if (RTEST(rb_options)) { c_options = (int)NUM2INT(rb_options); }\n\n  reader = xmlReaderForMemory(\n             StringValuePtr(rb_buffer),\n             (int)RSTRING_LEN(rb_buffer),\n             c_url,\n             c_encoding,\n             c_options\n           );\n\n  if (reader == NULL) {\n    xmlFreeTextReader(reader);\n    rb_raise(rb_eRuntimeError, \"couldn't create a parser\");\n  }\n\n  rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);\n  args[0] = rb_buffer;\n  args[1] = rb_url;\n  args[2] = encoding;\n  rb_obj_call_init(rb_reader, 3, args);\n\n  return rb_reader;\n}\n```\n\nCreate a new reader that parses `string`\n\n### Public Instance Methods\n\nattribute(name) Show source\n\n``` c\nstatic VALUE\nreader_attribute(VALUE self, VALUE name)\n{\n  xmlTextReaderPtr reader;\n  xmlChar *value ;\n  VALUE rb_value;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n\n  if (NIL_P(name)) { return Qnil; }\n  name = StringValue(name) ;\n\n  value = xmlTextReaderGetAttribute(reader, (xmlChar *)StringValueCStr(name));\n  if (value == NULL) { return Qnil; }\n\n  rb_value = NOKOGIRI_STR_NEW2(value);\n  xmlFree(value);\n  return rb_value;\n}\n```\n\nGet the value of attribute named `name`\n\nattribute_at(index) Show source\n\n``` c\nstatic VALUE\nattribute_at(VALUE self, VALUE index)\n{\n  xmlTextReaderPtr reader;\n  xmlChar *value;\n  VALUE rb_value;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n\n  if (NIL_P(index)) { return Qnil; }\n  index = rb_Integer(index);\n\n  value = xmlTextReaderGetAttributeNo(\n            reader,\n            (int)NUM2INT(index)\n          );\n  if (value == NULL) { return Qnil; }\n\n  rb_value = NOKOGIRI_STR_NEW2(value);\n  xmlFree(value);\n  return rb_value;\n}\n```\n\nGet the value of attribute at `index`\n\nattribute_count Show source\n\n``` c\nstatic VALUE\nattribute_count(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  int count;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  count = xmlTextReaderAttributeCount(reader);\n  if (count == -1) { return Qnil; }\n\n  return INT2NUM(count);\n}\n```\n\nGet the number of attributes for the current node\n\nattribute_hash() → Hash\\<String ⇒ String\\> Show source\n\n``` c\nstatic VALUE\nrb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n  VALUE rb_errors;\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n\n  rb_errors = rb_funcall(rb_reader, rb_intern(\"errors\"), 0);\n\n  xmlSetStructuredErrorFunc((void *)rb_errors, Nokogiri_error_array_pusher);\n  c_node = xmlTextReaderExpand(c_reader);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  if (c_node == NULL) {\n    if (RARRAY_LEN(rb_errors) > 0) {\n      VALUE rb_error = rb_ary_entry(rb_errors, 0);\n      VALUE exception_message = rb_funcall(rb_error, rb_intern(\"to_s\"), 0);\n      rb_exc_raise(rb_class_new_instance(1, &exception_message, cNokogiriXmlSyntaxError));\n    }\n    return Qnil;\n  }\n\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n\n    c_property = c_property->next;\n  }\n\n  return rb_attributes;\n}\n```\n\nGet the attributes of the current node as a Hash of names and values.\n\nSee related: [`#attributes`](reader#method-i-attributes) and [`#namespaces`](reader#method-i-namespaces)\n\nattribute_nodes() → Array\\<Nokogiri::XML::Attr\\> Show source\n\n``` c\nstatic VALUE\nrb_xml_reader_attribute_nodes(VALUE rb_reader)\n{\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  VALUE attr_nodes;\n  int j;\n\n  // TODO: deprecated, remove in Nokogiri v1.15, see https://github.com/sparklemotion/nokogiri/issues/2598\n  // After removal, we can also remove all the \"node_has_a_document\" special handling from xml_node.c\n  NOKO_WARN_DEPRECATION(\"Reader#attribute_nodes is deprecated and will be removed in a future version of Nokogiri. Please use Reader#attribute_hash instead.\");\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  if (! has_attributes(c_reader)) {\n    return rb_ary_new() ;\n  }\n\n  c_node = xmlTextReaderExpand(c_reader);\n  if (c_node == NULL) {\n    return Qnil;\n  }\n\n  attr_nodes = noko_xml_node_attrs(c_node);\n\n  /* ensure that the Reader won't be GCed as long as a node is referenced */\n  for (j = 0 ; j < RARRAY_LEN(attr_nodes) ; j++) {\n    rb_iv_set(rb_ary_entry(attr_nodes, j), \"@reader\", rb_reader);\n  }\n\n  return attr_nodes;\n}\n```\n\nGet the attributes of the current node as an Array of XML:Attr\n\n⚠ This method is deprecated and unsafe to use. It will be removed in a future version of [`Nokogiri`](../../nokogiri).\n\nSee related: [`#attribute_hash`](reader#method-i-attribute_hash), [`#attributes`](reader#method-i-attributes)\n\nattributes() Show source\n\n``` ruby\n# File lib/nokogiri/xml/reader.rb, line 92\ndef attributes\n  attribute_hash.merge(namespaces)\nend\n```\n\nGet the attributes and namespaces of the current node as a Hash.\n\nThis is the union of [`Reader#attribute_hash`](reader#method-i-attribute_hash) and [`Reader#namespaces`](reader#method-i-namespaces)\n\nReturns  \n(Hash\\<String, String\\>) Attribute names and values, and namespace prefixes and hrefs.\n\nattributes? Show source\n\n``` c\nstatic VALUE\nattributes_eh(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  int eh;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  eh = has_attributes(reader);\n  if (eh == 0) { return Qfalse; }\n  if (eh == 1) { return Qtrue; }\n\n  return Qnil;\n}\n```\n\nDoes this node have attributes?\n\nbase_uri Show source\n\n``` c\nstatic VALUE\nrb_xml_reader_base_uri(VALUE rb_reader)\n{\n  VALUE rb_base_uri;\n  xmlTextReaderPtr c_reader;\n  xmlChar *c_base_uri;\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  c_base_uri = xmlTextReaderBaseUri(c_reader);\n  if (c_base_uri == NULL) {\n    return Qnil;\n  }\n\n  rb_base_uri = NOKOGIRI_STR_NEW2(c_base_uri);\n  xmlFree(c_base_uri);\n\n  return rb_base_uri;\n}\n```\n\nGet the xml:base of the node\n\ndefault? Show source\n\n``` c\nstatic VALUE\ndefault_eh(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  int eh;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  eh = xmlTextReaderIsDefault(reader);\n  if (eh == 0) { return Qfalse; }\n  if (eh == 1) { return Qtrue; }\n\n  return Qnil;\n}\n```\n\nWas an attribute generated from the default value in the [`DTD`](dtd) or schema?\n\ndepth Show source\n\n``` c\nstatic VALUE\ndepth(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  int depth;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  depth = xmlTextReaderDepth(reader);\n  if (depth == -1) { return Qnil; }\n\n  return INT2NUM(depth);\n}\n```\n\nGet the depth of the node\n\neach() { \\|cursor\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/reader.rb, line 98\ndef each\n  while (cursor = read)\n    yield cursor\n  end\nend\n```\n\nMove the cursor through the document yielding the cursor to the block\n\nempty_element? \\# → true or false Show source\n\n``` c\nstatic VALUE\nempty_element_p(VALUE self)\n{\n  xmlTextReaderPtr reader;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n\n  if (xmlTextReaderIsEmptyElement(reader)) {\n    return Qtrue;\n  }\n\n  return Qfalse;\n}\n```\n\nReturns true if the current node is empty, otherwise false.\n\nAlso aliased as: [self_closing?](reader#method-i-self_closing-3F)\n\nencoding() Show source\n\n``` c\nstatic VALUE\nrb_xml_reader_encoding(VALUE rb_reader)\n{\n  xmlTextReaderPtr c_reader;\n  const char *parser_encoding;\n  VALUE constructor_encoding;\n\n  constructor_encoding = rb_iv_get(rb_reader, \"@encoding\");\n  if (RTEST(constructor_encoding)) {\n    return constructor_encoding;\n  }\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n  parser_encoding = (const char *)xmlTextReaderConstEncoding(c_reader);\n  if (parser_encoding == NULL) { return Qnil; }\n  return NOKOGIRI_STR_NEW2(parser_encoding);\n}\n```\n\ninner_xml Show source\n\n``` c\nstatic VALUE\ninner_xml(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  xmlChar *value;\n  VALUE str;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n\n  value = xmlTextReaderReadInnerXml(reader);\n\n  str = Qnil;\n  if (value) {\n    str = NOKOGIRI_STR_NEW2((char *)value);\n    xmlFree(value);\n  }\n\n  return str;\n}\n```\n\nRead the contents of the current node, including child nodes and markup. Returns a utf-8 encoded string.\n\nlang Show source\n\n``` c\nstatic VALUE\nlang(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *lang;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  lang = (const char *)xmlTextReaderConstXmlLang(reader);\n  if (lang == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(lang);\n}\n```\n\nGet the xml:lang scope within which the node resides.\n\nlocal_name Show source\n\n``` c\nstatic VALUE\nlocal_name(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *name;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  name = (const char *)xmlTextReaderConstLocalName(reader);\n  if (name == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(name);\n}\n```\n\nGet the local name of the node\n\nname Show source\n\n``` c\nstatic VALUE\nname(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *name;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  name = (const char *)xmlTextReaderConstName(reader);\n  if (name == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(name);\n}\n```\n\nGet the name of the node. Returns a utf-8 encoded string.\n\nnamespace_uri Show source\n\n``` c\nstatic VALUE\nnamespace_uri(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *uri;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  uri = (const char *)xmlTextReaderConstNamespaceUri(reader);\n  if (uri == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(uri);\n}\n```\n\nGet the URI defining the namespace associated with the node\n\nnamespaces Show source\n\n``` c\nstatic VALUE\nrb_xml_reader_namespaces(VALUE rb_reader)\n{\n  VALUE rb_namespaces = rb_hash_new() ;\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  VALUE rb_errors;\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  if (! has_attributes(c_reader)) {\n    return rb_namespaces ;\n  }\n\n  rb_errors = rb_funcall(rb_reader, rb_intern(\"errors\"), 0);\n\n  xmlSetStructuredErrorFunc((void *)rb_errors, Nokogiri_error_array_pusher);\n  c_node = xmlTextReaderExpand(c_reader);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  if (c_node == NULL) {\n    if (RARRAY_LEN(rb_errors) > 0) {\n      VALUE rb_error = rb_ary_entry(rb_errors, 0);\n      VALUE exception_message = rb_funcall(rb_error, rb_intern(\"to_s\"), 0);\n      rb_exc_raise(rb_class_new_instance(1, &exception_message, cNokogiriXmlSyntaxError));\n    }\n    return Qnil;\n  }\n\n  Nokogiri_xml_node_namespaces(c_node, rb_namespaces);\n\n  return rb_namespaces ;\n}\n```\n\nGet a hash of namespaces for this [`Node`](node)\n\nnode_type Show source\n\n``` c\nstatic VALUE\nnode_type(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  Data_Get_Struct(self, xmlTextReader, reader);\n  return INT2NUM(xmlTextReaderNodeType(reader));\n}\n```\n\nGet the type of readers current node\n\nouter_xml Show source\n\n``` c\nstatic VALUE\nouter_xml(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  xmlChar *value;\n  VALUE str = Qnil;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n\n  value = xmlTextReaderReadOuterXml(reader);\n\n  if (value) {\n    str = NOKOGIRI_STR_NEW2((char *)value);\n    xmlFree(value);\n  }\n  return str;\n}\n```\n\nRead the current node and its contents, including child nodes and markup. Returns a utf-8 encoded string.\n\nprefix Show source\n\n``` c\nstatic VALUE\nprefix(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *prefix;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  prefix = (const char *)xmlTextReaderConstPrefix(reader);\n  if (prefix == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(prefix);\n}\n```\n\nGet the shorthand reference to the namespace associated with the node.\n\nread Show source\n\n``` c\nstatic VALUE\nread_more(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  xmlErrorPtr error;\n  VALUE error_list;\n  int ret;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n\n  error_list = rb_funcall(self, rb_intern(\"errors\"), 0);\n\n  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);\n  ret = xmlTextReaderRead(reader);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  if (ret == 1) { return self; }\n  if (ret == 0) { return Qnil; }\n\n  error = xmlGetLastError();\n  if (error) {\n    rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));\n  } else {\n    rb_raise(rb_eRuntimeError, \"Error pulling: %d\", ret);\n  }\n\n  return Qnil;\n}\n```\n\nMove the [`Reader`](reader) forward through the [`XML`](../xml) document.\n\nself_closing?()\n\nAlias for: [empty_element?](reader#method-i-empty_element-3F)\n\nstate Show source\n\n``` c\nstatic VALUE\nstate(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  Data_Get_Struct(self, xmlTextReader, reader);\n  return INT2NUM(xmlTextReaderReadState(reader));\n}\n```\n\nGet the state of the reader\n\nvalue Show source\n\n``` c\nstatic VALUE\nvalue(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *value;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  value = (const char *)xmlTextReaderConstValue(reader);\n  if (value == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(value);\n}\n```\n\nGet the text value of the node if present. Returns a utf-8 encoded string.\n\nvalue? Show source\n\n``` c\nstatic VALUE\nvalue_eh(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  int eh;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  eh = xmlTextReaderHasValue(reader);\n  if (eh == 0) { return Qfalse; }\n  if (eh == 1) { return Qtrue; }\n\n  return Qnil;\n}\n```\n\nDoes this node have a text value?\n\nxml_version Show source\n\n``` c\nstatic VALUE\nxml_version(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *version;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  version = (const char *)xmlTextReaderConstXmlVersion(reader);\n  if (version == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(version);\n}\n```\n\nGet the [`XML`](../xml) version of the document being read\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Reader.html](https://nokogiri.org/rdoc/Nokogiri/XML/Reader.html)"
- name: Nokogiri::XML::Reader#attribute
  id: nokogiri/xml/reader#method-i-attribute
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attribute(name) Show source

    ``` c
    static VALUE
    reader_attribute(VALUE self, VALUE name)
    {
      xmlTextReaderPtr reader;
      xmlChar *value ;
      VALUE rb_value;

      Data_Get_Struct(self, xmlTextReader, reader);

      if (NIL_P(name)) { return Qnil; }
      name = StringValue(name) ;

      value = xmlTextReaderGetAttribute(reader, (xmlChar *)StringValueCStr(name));
      if (value == NULL) { return Qnil; }

      rb_value = NOKOGIRI_STR_NEW2(value);
      xmlFree(value);
      return rb_value;
    }
    ```

    Get the value of attribute named `name`
- name: Nokogiri::XML::Reader#attribute_at
  id: nokogiri/xml/reader#method-i-attribute_at
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attribute_at(index) Show source

    ``` c
    static VALUE
    attribute_at(VALUE self, VALUE index)
    {
      xmlTextReaderPtr reader;
      xmlChar *value;
      VALUE rb_value;

      Data_Get_Struct(self, xmlTextReader, reader);

      if (NIL_P(index)) { return Qnil; }
      index = rb_Integer(index);

      value = xmlTextReaderGetAttributeNo(
                reader,
                (int)NUM2INT(index)
              );
      if (value == NULL) { return Qnil; }

      rb_value = NOKOGIRI_STR_NEW2(value);
      xmlFree(value);
      return rb_value;
    }
    ```

    Get the value of attribute at `index`
- name: Nokogiri::XML::Reader#attribute_count
  id: nokogiri/xml/reader#method-i-attribute_count
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attribute_count Show source

    ``` c
    static VALUE
    attribute_count(VALUE self)
    {
      xmlTextReaderPtr reader;
      int count;

      Data_Get_Struct(self, xmlTextReader, reader);
      count = xmlTextReaderAttributeCount(reader);
      if (count == -1) { return Qnil; }

      return INT2NUM(count);
    }
    ```

    Get the number of attributes for the current node
- name: Nokogiri::XML::Reader#attribute_hash
  id: nokogiri/xml/reader#method-i-attribute_hash
  summary: Get the attributes of the current node as a Hash of names and values
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attribute_hash() → Hash\<String ⇒ String\> Show source

    ``` c
    static VALUE
    rb_xml_reader_attribute_hash(VALUE rb_reader)
    {
      VALUE rb_attributes = rb_hash_new();
      xmlTextReaderPtr c_reader;
      xmlNodePtr c_node;
      xmlAttrPtr c_property;
      VALUE rb_errors;

      Data_Get_Struct(rb_reader, xmlTextReader, c_reader);

      if (!has_attributes(c_reader)) {
        return rb_attributes;
      }

      rb_errors = rb_funcall(rb_reader, rb_intern("errors"), 0);

      xmlSetStructuredErrorFunc((void *)rb_errors, Nokogiri_error_array_pusher);
      c_node = xmlTextReaderExpand(c_reader);
      xmlSetStructuredErrorFunc(NULL, NULL);

      if (c_node == NULL) {
        if (RARRAY_LEN(rb_errors) > 0) {
          VALUE rb_error = rb_ary_entry(rb_errors, 0);
          VALUE exception_message = rb_funcall(rb_error, rb_intern("to_s"), 0);
          rb_exc_raise(rb_class_new_instance(1, &exception_message, cNokogiriXmlSyntaxError));
        }
        return Qnil;
      }

      c_property = c_node->properties;
      while (c_property != NULL) {
        VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);
        VALUE rb_value = Qnil;
        xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);

        if (c_value) {
          rb_value = NOKOGIRI_STR_NEW2(c_value);
          xmlFree(c_value);
        }

        rb_hash_aset(rb_attributes, rb_name, rb_value);

        c_property = c_property->next;
      }

      return rb_attributes;
    }
    ```

    Get the attributes of the current node as a Hash of names and values.

    See related: [`#attributes`](reader#method-i-attributes) and [`#namespaces`](reader#method-i-namespaces)
- name: Nokogiri::XML::Reader#attribute_nodes
  id: nokogiri/xml/reader#method-i-attribute_nodes
  summary: ⚠ This method is deprecated and unsafe to use
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attribute_nodes() → Array\<Nokogiri::XML::Attr\> Show source

    ``` c
    static VALUE
    rb_xml_reader_attribute_nodes(VALUE rb_reader)
    {
      xmlTextReaderPtr c_reader;
      xmlNodePtr c_node;
      VALUE attr_nodes;
      int j;

      // TODO: deprecated, remove in Nokogiri v1.15, see https://github.com/sparklemotion/nokogiri/issues/2598
      // After removal, we can also remove all the "node_has_a_document" special handling from xml_node.c
      NOKO_WARN_DEPRECATION("Reader#attribute_nodes is deprecated and will be removed in a future version of Nokogiri. Please use Reader#attribute_hash instead.");

      Data_Get_Struct(rb_reader, xmlTextReader, c_reader);

      if (! has_attributes(c_reader)) {
        return rb_ary_new() ;
      }

      c_node = xmlTextReaderExpand(c_reader);
      if (c_node == NULL) {
        return Qnil;
      }

      attr_nodes = noko_xml_node_attrs(c_node);

      /* ensure that the Reader won't be GCed as long as a node is referenced */
      for (j = 0 ; j < RARRAY_LEN(attr_nodes) ; j++) {
        rb_iv_set(rb_ary_entry(attr_nodes, j), "@reader", rb_reader);
      }

      return attr_nodes;
    }
    ```

    Get the attributes of the current node as an Array of XML:Attr

    ⚠ This method is deprecated and unsafe to use. It will be removed in a future version of [`Nokogiri`](../../nokogiri).

    See related: [`#attribute_hash`](reader#method-i-attribute_hash), [`#attributes`](reader#method-i-attributes)
- name: Nokogiri::XML::Reader#attributes
  id: nokogiri/xml/reader#method-i-attributes
  summary: Get the attributes and namespaces of the current node as a Hash
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attributes () Show source

    ``` ruby
    # File lib/nokogiri/xml/reader.rb, line 92
    def attributes
      attribute_hash.merge(namespaces)
    end
    ```

    Get the attributes and namespaces of the current node as a Hash.

    This is the union of [`Reader#attribute_hash`](reader#method-i-attribute_hash) and [`Reader#namespaces`](reader#method-i-namespaces)

    Returns

    (Hash\<String, String\>) Attribute names and values, and namespace prefixes and hrefs.
- name: Nokogiri::XML::Reader#attributes?
  id: nokogiri/xml/reader#method-i-attributes-3F
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    attributes? Show source

    ``` c
    static VALUE
    attributes_eh(VALUE self)
    {
      xmlTextReaderPtr reader;
      int eh;

      Data_Get_Struct(self, xmlTextReader, reader);
      eh = has_attributes(reader);
      if (eh == 0) { return Qfalse; }
      if (eh == 1) { return Qtrue; }

      return Qnil;
    }
    ```

    Does this node have attributes?
- name: Nokogiri::XML::Reader#base_uri
  id: nokogiri/xml/reader#method-i-base_uri
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    base_uri Show source

    ``` c
    static VALUE
    rb_xml_reader_base_uri(VALUE rb_reader)
    {
      VALUE rb_base_uri;
      xmlTextReaderPtr c_reader;
      xmlChar *c_base_uri;

      Data_Get_Struct(rb_reader, xmlTextReader, c_reader);

      c_base_uri = xmlTextReaderBaseUri(c_reader);
      if (c_base_uri == NULL) {
        return Qnil;
      }

      rb_base_uri = NOKOGIRI_STR_NEW2(c_base_uri);
      xmlFree(c_base_uri);

      return rb_base_uri;
    }
    ```

    Get the xml:base of the node
- name: Nokogiri::XML::Reader#default?
  id: nokogiri/xml/reader#method-i-default-3F
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    default? Show source

    ``` c
    static VALUE
    default_eh(VALUE self)
    {
      xmlTextReaderPtr reader;
      int eh;

      Data_Get_Struct(self, xmlTextReader, reader);
      eh = xmlTextReaderIsDefault(reader);
      if (eh == 0) { return Qfalse; }
      if (eh == 1) { return Qtrue; }

      return Qnil;
    }
    ```

    Was an attribute generated from the default value in the [`DTD`](dtd) or schema?
- name: Nokogiri::XML::Reader#depth
  id: nokogiri/xml/reader#method-i-depth
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    depth Show source

    ``` c
    static VALUE
    depth(VALUE self)
    {
      xmlTextReaderPtr reader;
      int depth;

      Data_Get_Struct(self, xmlTextReader, reader);
      depth = xmlTextReaderDepth(reader);
      if (depth == -1) { return Qnil; }

      return INT2NUM(depth);
    }
    ```

    Get the depth of the node
- name: Nokogiri::XML::Reader#each
  id: nokogiri/xml/reader#method-i-each
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    each () { \|cursor\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/reader.rb, line 98
    def each
      while (cursor = read)
        yield cursor
      end
    end
    ```

    Move the cursor through the document yielding the cursor to the block
- name: Nokogiri::XML::Reader#empty_element?
  id: nokogiri/xml/reader#method-i-empty_element-3F
  summary: Returns true if the current node is empty, otherwise false
  belongs_to: Nokogiri::XML::Reader
  description: |-
    empty_element? \# → true or false Show source

    ``` c
    static VALUE
    empty_element_p(VALUE self)
    {
      xmlTextReaderPtr reader;

      Data_Get_Struct(self, xmlTextReader, reader);

      if (xmlTextReaderIsEmptyElement(reader)) {
        return Qtrue;
      }

      return Qfalse;
    }
    ```

    Returns true if the current node is empty, otherwise false.

    Also aliased as: [self_closing?](reader#method-i-self_closing-3F)
- name: Nokogiri::XML::Reader#encoding
  id: nokogiri/xml/reader#method-i-encoding
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    encoding () Show source

    ``` c
    static VALUE
    rb_xml_reader_encoding(VALUE rb_reader)
    {
      xmlTextReaderPtr c_reader;
      const char *parser_encoding;
      VALUE constructor_encoding;

      constructor_encoding = rb_iv_get(rb_reader, "@encoding");
      if (RTEST(constructor_encoding)) {
        return constructor_encoding;
      }

      Data_Get_Struct(rb_reader, xmlTextReader, c_reader);
      parser_encoding = (const char *)xmlTextReaderConstEncoding(c_reader);
      if (parser_encoding == NULL) { return Qnil; }
      return NOKOGIRI_STR_NEW2(parser_encoding);
    }
    ```
- name: Nokogiri::XML::Reader#errors
  id: nokogiri/xml/reader#attribute-i-errors
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    errors \[RW\]

    A list of errors encountered while parsing
- name: Nokogiri::XML::Reader#inner_xml
  id: nokogiri/xml/reader#method-i-inner_xml
  summary: Read the contents of the current node, including child nodes and markup
  belongs_to: Nokogiri::XML::Reader
  description: |-
    inner_xml Show source

    ``` c
    static VALUE
    inner_xml(VALUE self)
    {
      xmlTextReaderPtr reader;
      xmlChar *value;
      VALUE str;

      Data_Get_Struct(self, xmlTextReader, reader);

      value = xmlTextReaderReadInnerXml(reader);

      str = Qnil;
      if (value) {
        str = NOKOGIRI_STR_NEW2((char *)value);
        xmlFree(value);
      }

      return str;
    }
    ```

    Read the contents of the current node, including child nodes and markup. Returns a utf-8 encoded string.
- name: Nokogiri::XML::Reader#lang
  id: nokogiri/xml/reader#method-i-lang
  summary: Get the xml:lang scope within which the node resides
  belongs_to: Nokogiri::XML::Reader
  description: |-
    lang Show source

    ``` c
    static VALUE
    lang(VALUE self)
    {
      xmlTextReaderPtr reader;
      const char *lang;

      Data_Get_Struct(self, xmlTextReader, reader);
      lang = (const char *)xmlTextReaderConstXmlLang(reader);
      if (lang == NULL) { return Qnil; }

      return NOKOGIRI_STR_NEW2(lang);
    }
    ```

    Get the xml:lang scope within which the node resides.
- name: Nokogiri::XML::Reader#local_name
  id: nokogiri/xml/reader#method-i-local_name
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    local_name Show source

    ``` c
    static VALUE
    local_name(VALUE self)
    {
      xmlTextReaderPtr reader;
      const char *name;

      Data_Get_Struct(self, xmlTextReader, reader);
      name = (const char *)xmlTextReaderConstLocalName(reader);
      if (name == NULL) { return Qnil; }

      return NOKOGIRI_STR_NEW2(name);
    }
    ```

    Get the local name of the node
- name: Nokogiri::XML::Reader#name
  id: nokogiri/xml/reader#method-i-name
  summary: Get the name of the node
  belongs_to: Nokogiri::XML::Reader
  description: |-
    name Show source

    ``` c
    static VALUE
    name(VALUE self)
    {
      xmlTextReaderPtr reader;
      const char *name;

      Data_Get_Struct(self, xmlTextReader, reader);
      name = (const char *)xmlTextReaderConstName(reader);
      if (name == NULL) { return Qnil; }

      return NOKOGIRI_STR_NEW2(name);
    }
    ```

    Get the name of the node. Returns a utf-8 encoded string.
- name: Nokogiri::XML::Reader#namespace_uri
  id: nokogiri/xml/reader#method-i-namespace_uri
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    namespace_uri Show source

    ``` c
    static VALUE
    namespace_uri(VALUE self)
    {
      xmlTextReaderPtr reader;
      const char *uri;

      Data_Get_Struct(self, xmlTextReader, reader);
      uri = (const char *)xmlTextReaderConstNamespaceUri(reader);
      if (uri == NULL) { return Qnil; }

      return NOKOGIRI_STR_NEW2(uri);
    }
    ```

    Get the URI defining the namespace associated with the node
- name: Nokogiri::XML::Reader#namespaces
  id: nokogiri/xml/reader#method-i-namespaces
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    namespaces Show source

    ``` c
    static VALUE
    rb_xml_reader_namespaces(VALUE rb_reader)
    {
      VALUE rb_namespaces = rb_hash_new() ;
      xmlTextReaderPtr c_reader;
      xmlNodePtr c_node;
      VALUE rb_errors;

      Data_Get_Struct(rb_reader, xmlTextReader, c_reader);

      if (! has_attributes(c_reader)) {
        return rb_namespaces ;
      }

      rb_errors = rb_funcall(rb_reader, rb_intern("errors"), 0);

      xmlSetStructuredErrorFunc((void *)rb_errors, Nokogiri_error_array_pusher);
      c_node = xmlTextReaderExpand(c_reader);
      xmlSetStructuredErrorFunc(NULL, NULL);

      if (c_node == NULL) {
        if (RARRAY_LEN(rb_errors) > 0) {
          VALUE rb_error = rb_ary_entry(rb_errors, 0);
          VALUE exception_message = rb_funcall(rb_error, rb_intern("to_s"), 0);
          rb_exc_raise(rb_class_new_instance(1, &exception_message, cNokogiriXmlSyntaxError));
        }
        return Qnil;
      }

      Nokogiri_xml_node_namespaces(c_node, rb_namespaces);

      return rb_namespaces ;
    }
    ```

    Get a hash of namespaces for this [`Node`](node)
- name: Nokogiri::XML::Reader#node_type
  id: nokogiri/xml/reader#method-i-node_type
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    node_type Show source

    ``` c
    static VALUE
    node_type(VALUE self)
    {
      xmlTextReaderPtr reader;
      Data_Get_Struct(self, xmlTextReader, reader);
      return INT2NUM(xmlTextReaderNodeType(reader));
    }
    ```

    Get the type of readers current node
- name: Nokogiri::XML::Reader#outer_xml
  id: nokogiri/xml/reader#method-i-outer_xml
  summary: Read the current node and its contents, including child nodes and markup
  belongs_to: Nokogiri::XML::Reader
  description: |-
    outer_xml Show source

    ``` c
    static VALUE
    outer_xml(VALUE self)
    {
      xmlTextReaderPtr reader;
      xmlChar *value;
      VALUE str = Qnil;

      Data_Get_Struct(self, xmlTextReader, reader);

      value = xmlTextReaderReadOuterXml(reader);

      if (value) {
        str = NOKOGIRI_STR_NEW2((char *)value);
        xmlFree(value);
      }
      return str;
    }
    ```

    Read the current node and its contents, including child nodes and markup. Returns a utf-8 encoded string.
- name: Nokogiri::XML::Reader#prefix
  id: nokogiri/xml/reader#method-i-prefix
  summary: Get the shorthand reference to the namespace associated with the node
  belongs_to: Nokogiri::XML::Reader
  description: |-
    prefix Show source

    ``` c
    static VALUE
    prefix(VALUE self)
    {
      xmlTextReaderPtr reader;
      const char *prefix;

      Data_Get_Struct(self, xmlTextReader, reader);
      prefix = (const char *)xmlTextReaderConstPrefix(reader);
      if (prefix == NULL) { return Qnil; }

      return NOKOGIRI_STR_NEW2(prefix);
    }
    ```

    Get the shorthand reference to the namespace associated with the node.
- name: Nokogiri::XML::Reader#read
  id: nokogiri/xml/reader#method-i-read
  summary: Move the Reader forward through the XML document
  belongs_to: Nokogiri::XML::Reader
  description: |-
    read Show source

    ``` c
    static VALUE
    read_more(VALUE self)
    {
      xmlTextReaderPtr reader;
      xmlErrorPtr error;
      VALUE error_list;
      int ret;

      Data_Get_Struct(self, xmlTextReader, reader);

      error_list = rb_funcall(self, rb_intern("errors"), 0);

      xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
      ret = xmlTextReaderRead(reader);
      xmlSetStructuredErrorFunc(NULL, NULL);

      if (ret == 1) { return self; }
      if (ret == 0) { return Qnil; }

      error = xmlGetLastError();
      if (error) {
        rb_exc_raise(Nokogiri_wrap_xml_syntax_error(error));
      } else {
        rb_raise(rb_eRuntimeError, "Error pulling: %d", ret);
      }

      return Qnil;
    }
    ```

    Move the [`Reader`](reader) forward through the [`XML`](../xml) document.
- name: Nokogiri::XML::Reader#self_closing?
  id: nokogiri/xml/reader#method-i-self_closing-3F
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    self_closing? ()

    Alias for: [empty_element?](reader#method-i-empty_element-3F)
- name: Nokogiri::XML::Reader#source
  id: nokogiri/xml/reader#attribute-i-source
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    source \[R\]

    The [`XML`](../xml) source

    ### Public Class Methods
- name: Nokogiri::XML::Reader#state
  id: nokogiri/xml/reader#method-i-state
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    state Show source

    ``` c
    static VALUE
    state(VALUE self)
    {
      xmlTextReaderPtr reader;
      Data_Get_Struct(self, xmlTextReader, reader);
      return INT2NUM(xmlTextReaderReadState(reader));
    }
    ```

    Get the state of the reader
- name: Nokogiri::XML::Reader#value
  id: nokogiri/xml/reader#method-i-value
  summary: Get the text value of the node if present
  belongs_to: Nokogiri::XML::Reader
  description: |-
    value Show source

    ``` c
    static VALUE
    value(VALUE self)
    {
      xmlTextReaderPtr reader;
      const char *value;

      Data_Get_Struct(self, xmlTextReader, reader);
      value = (const char *)xmlTextReaderConstValue(reader);
      if (value == NULL) { return Qnil; }

      return NOKOGIRI_STR_NEW2(value);
    }
    ```

    Get the text value of the node if present. Returns a utf-8 encoded string.
- name: Nokogiri::XML::Reader#value?
  id: nokogiri/xml/reader#method-i-value-3F
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    value? Show source

    ``` c
    static VALUE
    value_eh(VALUE self)
    {
      xmlTextReaderPtr reader;
      int eh;

      Data_Get_Struct(self, xmlTextReader, reader);
      eh = xmlTextReaderHasValue(reader);
      if (eh == 0) { return Qfalse; }
      if (eh == 1) { return Qtrue; }

      return Qnil;
    }
    ```

    Does this node have a text value?
- name: Nokogiri::XML::Reader#xml_version
  id: nokogiri/xml/reader#method-i-xml_version
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::Reader
  description: "xml_version Show source\n\n``` c\nstatic VALUE\nxml_version(VALUE self)\n{\n  xmlTextReaderPtr reader;\n  const char *version;\n\n  Data_Get_Struct(self, xmlTextReader, reader);\n  version = (const char *)xmlTextReaderConstXmlVersion(reader);\n  if (version == NULL) { return Qnil; }\n\n  return NOKOGIRI_STR_NEW2(version);\n}\n```\n\nGet the [`XML`](../xml) version of the document being read\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Reader.html](https://nokogiri.org/rdoc/Nokogiri/XML/Reader.html)"
- name: Nokogiri::XML::Reader::from_io
  id: nokogiri/xml/reader#method-c-from_io
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    from_io(io, url = nil, encoding = nil, options = 0) Show source

    ``` c
    static VALUE
    from_io(int argc, VALUE *argv, VALUE klass)
    {
      VALUE rb_io, rb_url, encoding, rb_options;
      xmlTextReaderPtr reader;
      const char *c_url      = NULL;
      const char *c_encoding = NULL;
      int c_options           = 0;
      VALUE rb_reader, args[3];

      rb_scan_args(argc, argv, "13", &rb_io, &rb_url, &encoding, &rb_options);

      if (!RTEST(rb_io)) { rb_raise(rb_eArgError, "io cannot be nil"); }
      if (RTEST(rb_url)) { c_url = StringValueCStr(rb_url); }
      if (RTEST(encoding)) { c_encoding = StringValueCStr(encoding); }
      if (RTEST(rb_options)) { c_options = (int)NUM2INT(rb_options); }

      reader = xmlReaderForIO(
                 (xmlInputReadCallback)noko_io_read,
                 (xmlInputCloseCallback)noko_io_close,
                 (void *)rb_io,
                 c_url,
                 c_encoding,
                 c_options
               );

      if (reader == NULL) {
        xmlFreeTextReader(reader);
        rb_raise(rb_eRuntimeError, "couldn't create a parser");
      }

      rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);
      args[0] = rb_io;
      args[1] = rb_url;
      args[2] = encoding;
      rb_obj_call_init(rb_reader, 3, args);

      return rb_reader;
    }
    ```

    Create a new reader that parses `io`
- name: Nokogiri::XML::Reader::from_memory
  id: nokogiri/xml/reader#method-c-from_memory
  summary: null
  belongs_to: Nokogiri::XML::Reader
  description: |-
    from_memory(string, url = nil, encoding = nil, options = 0) Show source

    ``` c
    static VALUE
    from_memory(int argc, VALUE *argv, VALUE klass)
    {
      VALUE rb_buffer, rb_url, encoding, rb_options;
      xmlTextReaderPtr reader;
      const char *c_url      = NULL;
      const char *c_encoding = NULL;
      int c_options           = 0;
      VALUE rb_reader, args[3];

      rb_scan_args(argc, argv, "13", &rb_buffer, &rb_url, &encoding, &rb_options);

      if (!RTEST(rb_buffer)) { rb_raise(rb_eArgError, "string cannot be nil"); }
      if (RTEST(rb_url)) { c_url = StringValueCStr(rb_url); }
      if (RTEST(encoding)) { c_encoding = StringValueCStr(encoding); }
      if (RTEST(rb_options)) { c_options = (int)NUM2INT(rb_options); }

      reader = xmlReaderForMemory(
                 StringValuePtr(rb_buffer),
                 (int)RSTRING_LEN(rb_buffer),
                 c_url,
                 c_encoding,
                 c_options
               );

      if (reader == NULL) {
        xmlFreeTextReader(reader);
        rb_raise(rb_eRuntimeError, "couldn't create a parser");
      }

      rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);
      args[0] = rb_buffer;
      args[1] = rb_url;
      args[2] = encoding;
      rb_obj_call_init(rb_reader, 3, args);

      return rb_reader;
    }
    ```

    Create a new reader that parses `string`

    ### Public Instance Methods
- name: Nokogiri::XML::RelaxNG
  id: nokogiri/xml#method-c-RelaxNG
  summary: Create a new Nokogiri::XML::RelaxNG document from string_or_io
  belongs_to: Nokogiri::XML
  description: |-
    RelaxNG (string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Show source

    ``` ruby
    # File lib/nokogiri/xml/relax_ng.rb, line 9
    def RelaxNG(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)
      RelaxNG.new(string_or_io, options)
    end
    ```

    Create a new [`Nokogiri::XML::RelaxNG`](xml/relaxng) document from `string_or_io`. See [`Nokogiri::XML::RelaxNG`](xml/relaxng) for an example.
- name: Nokogiri::XML::RelaxNG
  id: nokogiri/xml/relaxng
  summary: Nokogiri::XML::RelaxNG is used for validating XML against a RelaxNG schema
  description: "# class Nokogiri::XML::RelaxNG\n\nParent:  \ncNokogiriXmlSchema\n\n[`Nokogiri::XML::RelaxNG`](relaxng) is used for validating [`XML`](../xml) against a [`RelaxNG`](relaxng) schema.\n\n## Synopsis\n\nValidate an [`XML`](../xml) document against a [`RelaxNG`](relaxng) schema. Loop over the errors that are returned and print them out:\n\n``` ruby\nschema  = Nokogiri::XML::RelaxNG(File.open(ADDRESS_SCHEMA_FILE))\ndoc     = Nokogiri::XML(File.open(ADDRESS_XML_FILE))\n\nschema.validate(doc).each do |error|\n  puts error.message\nend\n```\n\nThe list of errors are [`Nokogiri::XML::SyntaxError`](syntaxerror) objects.\n\nNOTE: [`RelaxNG`](relaxng) input is always treated as TRUSTED documents, meaning that they will cause the underlying parsing libraries to access network resources. This is counter to Nokogiri’s “untrusted by default” security policy, but is a limitation of the underlying libraries.\n\n### Public Class Methods\n\nfrom_document(doc) Show source\n\n``` c\nstatic VALUE\nfrom_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if (NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if (error) {\n      Nokogiri_error_raise(NULL, error);\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n```\n\nCreate a new [`RelaxNG`](relaxng) schema from the [`Nokogiri::XML::Document`](document) `doc`\n\nread_memory(string) Show source\n\n``` c\nstatic VALUE\nread_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if (NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if (error) {\n      Nokogiri_error_raise(NULL, error);\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n```\n\nCreate a new [`RelaxNG`](relaxng) from the contents of `string`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/RelaxNG.html](https://nokogiri.org/rdoc/Nokogiri/XML/RelaxNG.html)"
- name: Nokogiri::XML::RelaxNG::from_document
  id: nokogiri/xml/relaxng#method-c-from_document
  summary: null
  belongs_to: Nokogiri::XML::RelaxNG
  description: |-
    from_document(doc) Show source

    ``` c
    static VALUE
    from_document(int argc, VALUE *argv, VALUE klass)
    {
      VALUE document;
      VALUE parse_options;
      xmlDocPtr doc;
      xmlRelaxNGParserCtxtPtr ctx;
      xmlRelaxNGPtr schema;
      VALUE errors;
      VALUE rb_schema;
      int scanned_args = 0;

      scanned_args = rb_scan_args(argc, argv, "11", &document, &parse_options);

      Data_Get_Struct(document, xmlDoc, doc);
      doc = doc->doc; /* In case someone passes us a node. ugh. */

      if (scanned_args == 1) {
        parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern("ParseOptions")), rb_intern("DEFAULT_SCHEMA"));
      }

      ctx = xmlRelaxNGNewDocParserCtxt(doc);

      errors = rb_ary_new();
      xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

    #ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS
      xmlRelaxNGSetParserStructuredErrors(
        ctx,
        Nokogiri_error_array_pusher,
        (void *)errors
      );
    #endif

      schema = xmlRelaxNGParse(ctx);

      xmlSetStructuredErrorFunc(NULL, NULL);
      xmlRelaxNGFreeParserCtxt(ctx);

      if (NULL == schema) {
        xmlErrorPtr error = xmlGetLastError();
        if (error) {
          Nokogiri_error_raise(NULL, error);
        } else {
          rb_raise(rb_eRuntimeError, "Could not parse document");
        }

        return Qnil;
      }

      rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
      rb_iv_set(rb_schema, "@errors", errors);
      rb_iv_set(rb_schema, "@parse_options", parse_options);

      return rb_schema;
    }
    ```

    Create a new [`RelaxNG`](relaxng) schema from the [`Nokogiri::XML::Document`](document) `doc`
- name: Nokogiri::XML::RelaxNG::read_memory
  id: nokogiri/xml/relaxng#method-c-read_memory
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::RelaxNG
  description: "read_memory(string) Show source\n\n``` c\nstatic VALUE\nread_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if (NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if (error) {\n      Nokogiri_error_raise(NULL, error);\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n```\n\nCreate a new [`RelaxNG`](relaxng) from the contents of `string`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/RelaxNG.html](https://nokogiri.org/rdoc/Nokogiri/XML/RelaxNG.html)"
- name: Nokogiri::XML::SAX
  id: nokogiri/xml/sax
  summary: SAX Parsers are event driven parsers
  description: "# module Nokogiri::XML::SAX\n\n[`SAX`](sax) Parsers are event driven parsers. [`Nokogiri`](../../nokogiri) provides two different event based parsers when dealing with [`XML`](../xml). If you want to do [`SAX`](sax) style parsing using [`HTML`](../html4), check out [`Nokogiri::HTML4::SAX`](../html4/sax).\n\nThe basic way a [`SAX`](sax) style parser works is by creating a parser, telling the parser about the events we’re interested in, then giving the parser some [`XML`](../xml) to process. The parser will notify you when it encounters events you said you would like to know about.\n\nTo register for events, you simply subclass [`Nokogiri::XML::SAX::Document`](sax/document), and implement the methods for which you would like notification.\n\nFor example, if I want to be notified when a document ends, and when an element starts, I would write a class like this:\n\n``` ruby\nclass MyDocument < Nokogiri::XML::SAX::Document\n  def end_document\n    puts \"the document has ended\"\n  end\n\n  def start_element name, attributes = []\n    puts \"#{name} started\"\n  end\nend\n```\n\nThen I would instantiate a [`SAX`](sax) parser with this document, and feed the parser some [`XML`](../xml)\n\n``` ruby\n# Create a new parser\nparser = Nokogiri::XML::SAX::Parser.new(MyDocument.new)\n\n# Feed the parser some XML\nparser.parse(File.open(ARGV[0]))\n```\n\nNow my document handler will be called when each node starts, and when then document ends. To see what kinds of events are available, take a look at [`Nokogiri::XML::SAX::Document`](sax/document).\n\nTwo [`SAX`](sax) parsers for [`XML`](../xml) are available, a parser that reads from a string or IO object as it feels necessary, and a parser that lets you spoon feed it [`XML`](../xml). If you want to let [`Nokogiri`](../../nokogiri) deal with reading your [`XML`](../xml), use the [`Nokogiri::XML::SAX::Parser`](sax/parser). If you want to have fine grain control over the [`XML`](../xml) input, use the [`Nokogiri::XML::SAX::PushParser`](sax/pushparser).\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX.html)"
- name: Nokogiri::XML::SAX::Document
  id: nokogiri/xml/sax/document
  summary: This class is used for registering types of events you are interested in handling
  description: "# class Nokogiri::XML::SAX::Document\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nThis class is used for registering types of events you are interested in handling. All of the methods on this class are available as possible events while parsing an [`XML`](../../xml) document. To register for any particular event, just subclass this class and implement the methods you are interested in knowing about.\n\nTo only be notified about start and end element events, write a class like this:\n\n``` ruby\nclass MyDocument < Nokogiri::XML::SAX::Document\n  def start_element name, attrs = []\n    puts \"#{name} started!\"\n  end\n\n  def end_element name\n    puts \"#{name} ended\"\n  end\nend\n```\n\nYou can use this event handler for any [`SAX`](../sax) style parser included with [`Nokogiri`](../../../nokogiri). See [`Nokogiri::XML::SAX`](../sax), and [`Nokogiri::HTML4::SAX`](../../html4/sax).\n\n### Public Instance Methods\n\ncdata_block(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 155\ndef cdata_block(string)\nend\n```\n\nCalled when cdata blocks are found `string` contains the cdata content\n\ncharacters(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 131\ndef characters(string)\nend\n```\n\nCharacters read between a tag. This method might be called multiple times given one contiguous string of characters.\n\n`string` contains the character data\n\ncomment(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 137\ndef comment(string)\nend\n```\n\nCalled when comments are encountered `string` contains the comment data\n\nend_document() Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 79\ndef end_document\nend\n```\n\nCalled when document ends parsing\n\nend_element(name) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 93\ndef end_element(name)\nend\n```\n\nCalled at the end of an element `name` is the tag name\n\nend_element_namespace(name, prefix = nil, uri = nil) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 120\ndef end_element_namespace(name, prefix = nil, uri = nil)\n  ###\n  # Deal with SAX v1 interface\n  end_element([prefix, name].compact.join(\":\"))\nend\n```\n\nCalled at the end of an element `name` is the element’s name `prefix` is the namespace prefix associated with the element `uri` is the associated namespace URI\n\nerror(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 149\ndef error(string)\nend\n```\n\nCalled on document errors `string` contains the error\n\nprocessing_instruction(name, content) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 162\ndef processing_instruction(name, content)\nend\n```\n\nCalled when processing instructions are found `name` is the target of the instruction `content` is the value of the instruction\n\nstart_document() Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 74\ndef start_document\nend\n```\n\nCalled when document starts parsing\n\nstart_element(name, attrs = \\[\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 87\ndef start_element(name, attrs = [])\nend\n```\n\nCalled at the beginning of an element\n\n- `name` is the name of the tag\n\n- `attrs` are an assoc list of namespaces and attributes, e.g.:\n\n  ``` ruby\n  [ [\"xmlns:foo\", \"http://sample.net\"], [\"size\", \"large\"] ]\n  ```\n\nstart_element_namespace(name, attrs = \\[\\], prefix = nil, uri = nil, ns = \\[\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 103\ndef start_element_namespace(name, attrs = [], prefix = nil, uri = nil, ns = [])\n  ###\n  # Deal with SAX v1 interface\n  name = [prefix, name].compact.join(\":\")\n  attributes = ns.map do |ns_prefix, ns_uri|\n    [[\"xmlns\", ns_prefix].compact.join(\":\"), ns_uri]\n  end + attrs.map do |attr|\n    [[attr.prefix, attr.localname].compact.join(\":\"), attr.value]\n  end\n  start_element(name, attributes)\nend\n```\n\nCalled at the beginning of an element `name` is the element name `attrs` is a list of attributes `prefix` is the namespace prefix for the element `uri` is the associated namespace URI `ns` is a hash of namespace prefix:urls associated with the element\n\nwarning(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 143\ndef warning(string)\nend\n```\n\nCalled on document warnings `string` contains the warning\n\nxmldecl(version, encoding, standalone) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 69\ndef xmldecl(version, encoding, standalone)\nend\n```\n\nCalled when an [`XML`](../../xml) declaration is parsed\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Document.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Document.html)"
- name: Nokogiri::XML::SAX::Document#cdata_block
  id: nokogiri/xml/sax/document#method-i-cdata_block
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    cdata_block (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 155
    def cdata_block(string)
    end
    ```

    Called when cdata blocks are found `string` contains the cdata content
- name: Nokogiri::XML::SAX::Document#characters
  id: nokogiri/xml/sax/document#method-i-characters
  summary: Characters read between a tag
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    characters (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 131
    def characters(string)
    end
    ```

    Characters read between a tag. This method might be called multiple times given one contiguous string of characters.

    `string` contains the character data
- name: Nokogiri::XML::SAX::Document#comment
  id: nokogiri/xml/sax/document#method-i-comment
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    comment (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 137
    def comment(string)
    end
    ```

    Called when comments are encountered `string` contains the comment data
- name: Nokogiri::XML::SAX::Document#end_document
  id: nokogiri/xml/sax/document#method-i-end_document
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    end_document () Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 79
    def end_document
    end
    ```

    Called when document ends parsing
- name: Nokogiri::XML::SAX::Document#end_element
  id: nokogiri/xml/sax/document#method-i-end_element
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    end_element (name) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 93
    def end_element(name)
    end
    ```

    Called at the end of an element `name` is the tag name
- name: Nokogiri::XML::SAX::Document#end_element_namespace
  id: nokogiri/xml/sax/document#method-i-end_element_namespace
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    end_element_namespace (name, prefix = nil, uri = nil) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 120
    def end_element_namespace(name, prefix = nil, uri = nil)
      ###
      # Deal with SAX v1 interface
      end_element([prefix, name].compact.join(":"))
    end
    ```

    Called at the end of an element `name` is the element’s name `prefix` is the namespace prefix associated with the element `uri` is the associated namespace URI
- name: Nokogiri::XML::SAX::Document#error
  id: nokogiri/xml/sax/document#method-i-error
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    error (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 149
    def error(string)
    end
    ```

    Called on document errors `string` contains the error
- name: Nokogiri::XML::SAX::Document#processing_instruction
  id: nokogiri/xml/sax/document#method-i-processing_instruction
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    processing_instruction (name, content) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 162
    def processing_instruction(name, content)
    end
    ```

    Called when processing instructions are found `name` is the target of the instruction `content` is the value of the instruction
- name: Nokogiri::XML::SAX::Document#start_document
  id: nokogiri/xml/sax/document#method-i-start_document
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    start_document () Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 74
    def start_document
    end
    ```

    Called when document starts parsing
- name: Nokogiri::XML::SAX::Document#start_element
  id: nokogiri/xml/sax/document#method-i-start_element
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    start_element (name, attrs = \[\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 87
    def start_element(name, attrs = [])
    end
    ```

    Called at the beginning of an element

    - `name` is the name of the tag

    - `attrs` are an assoc list of namespaces and attributes, e.g.:

      ``` ruby
      [ ["xmlns:foo", "http://sample.net"], ["size", "large"] ]
      ```
- name: Nokogiri::XML::SAX::Document#start_element_namespace
  id: nokogiri/xml/sax/document#method-i-start_element_namespace
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    start_element_namespace (name, attrs = \[\], prefix = nil, uri = nil, ns = \[\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 103
    def start_element_namespace(name, attrs = [], prefix = nil, uri = nil, ns = [])
      ###
      # Deal with SAX v1 interface
      name = [prefix, name].compact.join(":")
      attributes = ns.map do |ns_prefix, ns_uri|
        [["xmlns", ns_prefix].compact.join(":"), ns_uri]
      end + attrs.map do |attr|
        [[attr.prefix, attr.localname].compact.join(":"), attr.value]
      end
      start_element(name, attributes)
    end
    ```

    Called at the beginning of an element `name` is the element name `attrs` is a list of attributes `prefix` is the namespace prefix for the element `uri` is the associated namespace URI `ns` is a hash of namespace prefix:urls associated with the element
- name: Nokogiri::XML::SAX::Document#warning
  id: nokogiri/xml/sax/document#method-i-warning
  summary: null
  belongs_to: Nokogiri::XML::SAX::Document
  description: |-
    warning (string) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/document.rb, line 143
    def warning(string)
    end
    ```

    Called on document warnings `string` contains the warning
- name: Nokogiri::XML::SAX::Document#xmldecl
  id: nokogiri/xml/sax/document#method-i-xmldecl
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::SAX::Document
  description: "xmldecl (version, encoding, standalone) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/document.rb, line 69\ndef xmldecl(version, encoding, standalone)\nend\n```\n\nCalled when an [`XML`](../../xml) declaration is parsed\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Document.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Document.html)"
- name: Nokogiri::XML::SAX::Parser
  id: nokogiri/xml/sax/parser
  summary: This parser is a SAX style parser that reads it’s input as it deems necessary
  description: "# class Nokogiri::XML::SAX::Parser\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nThis parser is a [`SAX`](../sax) style parser that reads it’s input as it deems necessary. The parser takes a [`Nokogiri::XML::SAX::Document`](document), an optional encoding, then given an [`XML`](../../xml) input, sends messages to the [`Nokogiri::XML::SAX::Document`](document).\n\nHere is an example of using this parser:\n\n``` ruby\n# Create a subclass of Nokogiri::XML::SAX::Document and implement\n# the events we care about:\nclass MyDoc < Nokogiri::XML::SAX::Document\n  def start_element name, attrs = []\n    puts \"starting: #{name}\"\n  end\n\n  def end_element name\n    puts \"ending: #{name}\"\n  end\nend\n\n# Create our parser\nparser = Nokogiri::XML::SAX::Parser.new(MyDoc.new)\n\n# Send some XML to the parser\nparser.parse(File.open(ARGV[0]))\n```\n\nFor more information about [`SAX`](../sax) parsers, see [`Nokogiri::XML::SAX`](../sax). Also see [`Nokogiri::XML::SAX::Document`](document) for the available events.\n\n### Constants\n\nENCODINGS  \nEncodinds this parser supports\n\n### Attributes\n\ndocument\\[RW\\]\n\nThe [`Nokogiri::XML::SAX::Document`](document) where events will be sent.\n\nencoding\\[RW\\]\n\nThe encoding beings used for this document.\n\n### Public Class Methods\n\nnew(doc = Nokogiri::XML::SAX::Document.new, encoding = \"UTF-8\") Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser.rb, line 72\ndef initialize(doc = Nokogiri::XML::SAX::Document.new, encoding = \"UTF-8\")\n  @encoding = check_encoding(encoding)\n  @document = doc\n  @warned   = false\nend\n```\n\nCreate a new [`Parser`](parser) with `doc` and `encoding`\n\n### Public Instance Methods\n\nparse(thing, &block) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser.rb, line 81\ndef parse(thing, &block)\n  if thing.respond_to?(:read) && thing.respond_to?(:close)\n    parse_io(thing, &block)\n  else\n    parse_memory(thing, &block)\n  end\nend\n```\n\nParse given `thing` which may be a string containing xml, or an IO object.\n\nparse_file(filename) { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser.rb, line 99\ndef parse_file(filename)\n  raise ArgumentError unless filename\n  raise Errno::ENOENT unless File.exist?(filename)\n  raise Errno::EISDIR if File.directory?(filename)\n\n  ctx = ParserContext.file(filename)\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\nParse a file with `filename`\n\nparse_io(io, encoding = @encoding) { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser.rb, line 91\ndef parse_io(io, encoding = @encoding)\n  ctx = ParserContext.io(io, ENCODINGS[check_encoding(encoding)])\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\nParse given `io`\n\nparse_memory(data) { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser.rb, line 109\ndef parse_memory(data)\n  ctx = ParserContext.memory(data)\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Parser.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Parser.html)"
- name: Nokogiri::XML::SAX::Parser#document
  id: nokogiri/xml/sax/parser#attribute-i-document
  summary: The Nokogiri::XML::SAX::Document where events will be sent
  belongs_to: Nokogiri::XML::SAX::Parser
  description: |-
    document \[RW\]

    The [`Nokogiri::XML::SAX::Document`](document) where events will be sent.
- name: Nokogiri::XML::SAX::Parser#encoding
  id: nokogiri/xml/sax/parser#attribute-i-encoding
  summary: The encoding beings used for this document
  belongs_to: Nokogiri::XML::SAX::Parser
  description: |-
    encoding \[RW\]

    The encoding beings used for this document.

    ### Public Class Methods
- name: Nokogiri::XML::SAX::Parser#parse
  id: nokogiri/xml/sax/parser#method-i-parse
  summary: Parse given thing which may be a string containing xml, or an IO object
  belongs_to: Nokogiri::XML::SAX::Parser
  description: |-
    parse (thing, &block) Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/parser.rb, line 81
    def parse(thing, &block)
      if thing.respond_to?(:read) && thing.respond_to?(:close)
        parse_io(thing, &block)
      else
        parse_memory(thing, &block)
      end
    end
    ```

    Parse given `thing` which may be a string containing xml, or an IO object.
- name: Nokogiri::XML::SAX::Parser#parse_file
  id: nokogiri/xml/sax/parser#method-i-parse_file
  summary: null
  belongs_to: Nokogiri::XML::SAX::Parser
  description: |-
    parse_file (filename) { \|ctx\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/parser.rb, line 99
    def parse_file(filename)
      raise ArgumentError unless filename
      raise Errno::ENOENT unless File.exist?(filename)
      raise Errno::EISDIR if File.directory?(filename)

      ctx = ParserContext.file(filename)
      yield ctx if block_given?
      ctx.parse_with(self)
    end
    ```

    Parse a file with `filename`
- name: Nokogiri::XML::SAX::Parser#parse_io
  id: nokogiri/xml/sax/parser#method-i-parse_io
  summary: null
  belongs_to: Nokogiri::XML::SAX::Parser
  description: |-
    parse_io (io, encoding = @encoding) { \|ctx\| ... } Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/parser.rb, line 91
    def parse_io(io, encoding = @encoding)
      ctx = ParserContext.io(io, ENCODINGS[check_encoding(encoding)])
      yield ctx if block_given?
      ctx.parse_with(self)
    end
    ```

    Parse given `io`
- name: Nokogiri::XML::SAX::Parser#parse_memory
  id: nokogiri/xml/sax/parser#method-i-parse_memory
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::SAX::Parser
  description: "parse_memory (data) { \\|ctx\\| ... } Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser.rb, line 109\ndef parse_memory(data)\n  ctx = ParserContext.memory(data)\n  yield ctx if block_given?\n  ctx.parse_with(self)\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Parser.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Parser.html)"
- name: Nokogiri::XML::SAX::Parser::Attribute
  id: nokogiri/xml/sax/parser/attribute
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::SAX::Parser::Attribute\n\nParent:  \nStruct.new(:localname, :prefix, :uri, :value)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Parser/Attribute.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/Parser/Attribute.html)"
- name: Nokogiri::XML::SAX::Parser::new
  id: nokogiri/xml/sax/parser#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::SAX::Parser
  description: |-
    new (doc = Nokogiri::XML::SAX::Document.new, encoding = "UTF-8") Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/parser.rb, line 72
    def initialize(doc = Nokogiri::XML::SAX::Document.new, encoding = "UTF-8")
      @encoding = check_encoding(encoding)
      @document = doc
      @warned   = false
    end
    ```

    Create a new [`Parser`](parser) with `doc` and `encoding`

    ### Public Instance Methods
- name: Nokogiri::XML::SAX::ParserContext
  id: nokogiri/xml/sax/parsercontext
  summary: Context for XML SAX parsers
  description: "# class Nokogiri::XML::SAX::ParserContext\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nContext for [`XML`](../../xml) [`SAX`](../sax) parsers. This class is usually not instantiated by the user. Instead, you should be looking at [`Nokogiri::XML::SAX::Parser`](parser)\n\n### Public Class Methods\n\nparse_file(filename) Show source\n\n``` c\nstatic VALUE\nparse_file(VALUE klass, VALUE filename)\n{\n  xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(StringValueCStr(filename));\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}\n```\n\nParse file given `filename`\n\nparse_io(io, encoding) Show source\n\n``` c\nstatic VALUE\nparse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n\n  if (!rb_respond_to(io, id_read)) {\n    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n  }\n\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}\n```\n\nParse `io` object with `encoding`\n\nparse_memory(data) Show source\n\n``` c\nstatic VALUE\nparse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  Check_Type(data, T_STRING);\n\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}\n```\n\nParse the [`XML`](../../xml) stored in memory in `data`\n\nnew(thing, encoding = \"UTF-8\") Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/parser_context.rb, line 11\ndef self.new(thing, encoding = \"UTF-8\")\n  if [:read, :close].all? { |x| thing.respond_to?(x) }\n    io(thing, Parser::ENCODINGS[encoding])\n  else\n    memory(thing)\n  end\nend\n```\n\n### Public Instance Methods\n\ncolumn Show source\n\n``` c\nstatic VALUE\ncolumn(VALUE self)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlParserInputPtr io;\n\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  io = ctxt->input;\n  if (io) {\n    return INT2NUM(io->col);\n  }\n\n  return Qnil;\n}\n```\n\nGet the current column the parser context is processing.\n\nline Show source\n\n``` c\nstatic VALUE\nline(VALUE self)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlParserInputPtr io;\n\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  io = ctxt->input;\n  if (io) {\n    return INT2NUM(io->line);\n  }\n\n  return Qnil;\n}\n```\n\nGet the current line the parser context is processing.\n\nparse_with(sax_handler) Show source\n\n``` c\nstatic VALUE\nparse_with(VALUE self, VALUE sax_handler)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlSAXHandlerPtr sax;\n\n  if (!rb_obj_is_kind_of(sax_handler, cNokogiriXmlSaxParser)) {\n    rb_raise(rb_eArgError, \"argument must be a Nokogiri::XML::SAX::Parser\");\n  }\n\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n  Data_Get_Struct(sax_handler, xmlSAXHandler, sax);\n\n  /* Free the sax handler since we'll assign our own */\n  if (ctxt->sax && ctxt->sax != (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) {\n    xmlFree(ctxt->sax);\n  }\n\n  ctxt->sax = sax;\n  ctxt->userData = (void *)NOKOGIRI_SAX_TUPLE_NEW(ctxt, sax_handler);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n\n  rb_ensure(parse_doc, (VALUE)ctxt, parse_doc_finalize, (VALUE)ctxt);\n\n  return Qnil;\n}\n```\n\nUse `sax_handler` and parse the current document\n\nrecovery Show source\n\n``` c\nstatic VALUE\nget_recovery(VALUE self)\n{\n  xmlParserCtxtPtr ctxt;\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  if (ctxt->recovery == 0) {\n    return Qfalse;\n  } else {\n    return Qtrue;\n  }\n}\n```\n\nShould this parser recover from structural errors? It will not stop processing file on structural errors if set to true\n\nrecovery=(boolean) Show source\n\n``` c\nstatic VALUE\nset_recovery(VALUE self, VALUE value)\n{\n  xmlParserCtxtPtr ctxt;\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  if (value == Qfalse) {\n    ctxt->recovery = 0;\n  } else {\n    ctxt->recovery = 1;\n  }\n\n  return value;\n}\n```\n\nShould this parser recover from structural errors? It will not stop processing file on structural errors if set to true\n\nreplace_entities Show source\n\n``` c\nstatic VALUE\nget_replace_entities(VALUE self)\n{\n  xmlParserCtxtPtr ctxt;\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  if (0 == ctxt->replaceEntities) {\n    return Qfalse;\n  } else {\n    return Qtrue;\n  }\n}\n```\n\nShould this parser replace entities? &amp; will get converted to ‘&’ if set to true\n\nreplace_entities=(boolean) Show source\n\n``` c\nstatic VALUE\nset_replace_entities(VALUE self, VALUE value)\n{\n  xmlParserCtxtPtr ctxt;\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  if (Qfalse == value) {\n    ctxt->replaceEntities = 0;\n  } else {\n    ctxt->replaceEntities = 1;\n  }\n\n  return value;\n}\n```\n\nShould this parser replace entities? &amp; will get converted to ‘&’ if set to true\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/ParserContext.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/ParserContext.html)"
- name: Nokogiri::XML::SAX::ParserContext#column
  id: nokogiri/xml/sax/parsercontext#method-i-column
  summary: Get the current column the parser context is processing
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    column Show source

    ``` c
    static VALUE
    column(VALUE self)
    {
      xmlParserCtxtPtr ctxt;
      xmlParserInputPtr io;

      Data_Get_Struct(self, xmlParserCtxt, ctxt);

      io = ctxt->input;
      if (io) {
        return INT2NUM(io->col);
      }

      return Qnil;
    }
    ```

    Get the current column the parser context is processing.
- name: Nokogiri::XML::SAX::ParserContext#line
  id: nokogiri/xml/sax/parsercontext#method-i-line
  summary: Get the current line the parser context is processing
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    line Show source

    ``` c
    static VALUE
    line(VALUE self)
    {
      xmlParserCtxtPtr ctxt;
      xmlParserInputPtr io;

      Data_Get_Struct(self, xmlParserCtxt, ctxt);

      io = ctxt->input;
      if (io) {
        return INT2NUM(io->line);
      }

      return Qnil;
    }
    ```

    Get the current line the parser context is processing.
- name: Nokogiri::XML::SAX::ParserContext#parse_with
  id: nokogiri/xml/sax/parsercontext#method-i-parse_with
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    parse_with(sax_handler) Show source

    ``` c
    static VALUE
    parse_with(VALUE self, VALUE sax_handler)
    {
      xmlParserCtxtPtr ctxt;
      xmlSAXHandlerPtr sax;

      if (!rb_obj_is_kind_of(sax_handler, cNokogiriXmlSaxParser)) {
        rb_raise(rb_eArgError, "argument must be a Nokogiri::XML::SAX::Parser");
      }

      Data_Get_Struct(self, xmlParserCtxt, ctxt);
      Data_Get_Struct(sax_handler, xmlSAXHandler, sax);

      /* Free the sax handler since we'll assign our own */
      if (ctxt->sax && ctxt->sax != (xmlSAXHandlerPtr)&xmlDefaultSAXHandler) {
        xmlFree(ctxt->sax);
      }

      ctxt->sax = sax;
      ctxt->userData = (void *)NOKOGIRI_SAX_TUPLE_NEW(ctxt, sax_handler);

      xmlSetStructuredErrorFunc(NULL, NULL);

      rb_ensure(parse_doc, (VALUE)ctxt, parse_doc_finalize, (VALUE)ctxt);

      return Qnil;
    }
    ```

    Use `sax_handler` and parse the current document
- name: Nokogiri::XML::SAX::ParserContext#recovery
  id: nokogiri/xml/sax/parsercontext#method-i-recovery
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    recovery Show source

    ``` c
    static VALUE
    get_recovery(VALUE self)
    {
      xmlParserCtxtPtr ctxt;
      Data_Get_Struct(self, xmlParserCtxt, ctxt);

      if (ctxt->recovery == 0) {
        return Qfalse;
      } else {
        return Qtrue;
      }
    }
    ```

    Should this parser recover from structural errors? It will not stop processing file on structural errors if set to true
- name: Nokogiri::XML::SAX::ParserContext#recovery=
  id: nokogiri/xml/sax/parsercontext#method-i-recovery-3D
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    recovery=(boolean) Show source

    ``` c
    static VALUE
    set_recovery(VALUE self, VALUE value)
    {
      xmlParserCtxtPtr ctxt;
      Data_Get_Struct(self, xmlParserCtxt, ctxt);

      if (value == Qfalse) {
        ctxt->recovery = 0;
      } else {
        ctxt->recovery = 1;
      }

      return value;
    }
    ```

    Should this parser recover from structural errors? It will not stop processing file on structural errors if set to true
- name: Nokogiri::XML::SAX::ParserContext#replace_entities
  id: nokogiri/xml/sax/parsercontext#method-i-replace_entities
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    replace_entities Show source

    ``` c
    static VALUE
    get_replace_entities(VALUE self)
    {
      xmlParserCtxtPtr ctxt;
      Data_Get_Struct(self, xmlParserCtxt, ctxt);

      if (0 == ctxt->replaceEntities) {
        return Qfalse;
      } else {
        return Qtrue;
      }
    }
    ```

    Should this parser replace entities? &amp; will get converted to ‘&’ if set to true
- name: Nokogiri::XML::SAX::ParserContext#replace_entities=
  id: nokogiri/xml/sax/parsercontext#method-i-replace_entities-3D
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: "replace_entities=(boolean) Show source\n\n``` c\nstatic VALUE\nset_replace_entities(VALUE self, VALUE value)\n{\n  xmlParserCtxtPtr ctxt;\n  Data_Get_Struct(self, xmlParserCtxt, ctxt);\n\n  if (Qfalse == value) {\n    ctxt->replaceEntities = 0;\n  } else {\n    ctxt->replaceEntities = 1;\n  }\n\n  return value;\n}\n```\n\nShould this parser replace entities? &amp; will get converted to ‘&’ if set to true\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/ParserContext.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/ParserContext.html)"
- name: Nokogiri::XML::SAX::ParserContext::file
  id: nokogiri/xml/sax/parsercontext#method-c-file
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    parse_file(filename) Show source

    ``` c
    static VALUE
    parse_file(VALUE klass, VALUE filename)
    {
      xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(StringValueCStr(filename));
      return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
    }
    ```

    Parse file given `filename`
- name: Nokogiri::XML::SAX::ParserContext::io
  id: nokogiri/xml/sax/parsercontext#method-c-io
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    parse_io(io, encoding) Show source

    ``` c
    static VALUE
    parse_io(VALUE klass, VALUE io, VALUE encoding)
    {
      xmlParserCtxtPtr ctxt;
      xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);

      if (!rb_respond_to(io, id_read)) {
        rb_raise(rb_eTypeError, "argument expected to respond to :read");
      }

      ctxt = xmlCreateIOParserCtxt(NULL, NULL,
                                   (xmlInputReadCallback)noko_io_read,
                                   (xmlInputCloseCallback)noko_io_close,
                                   (void *)io, enc);
      if (ctxt->sax) {
        xmlFree(ctxt->sax);
        ctxt->sax = NULL;
      }

      return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
    }
    ```

    Parse `io` object with `encoding`
- name: Nokogiri::XML::SAX::ParserContext::memory
  id: nokogiri/xml/sax/parsercontext#method-c-memory
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    parse_memory(data) Show source

    ``` c
    static VALUE
    parse_memory(VALUE klass, VALUE data)
    {
      xmlParserCtxtPtr ctxt;

      Check_Type(data, T_STRING);

      if (!(int)RSTRING_LEN(data)) {
        rb_raise(rb_eRuntimeError, "data cannot be empty");
      }

      ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),
                                       (int)RSTRING_LEN(data));
      if (ctxt->sax) {
        xmlFree(ctxt->sax);
        ctxt->sax = NULL;
      }

      return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
    }
    ```

    Parse the [`XML`](../../xml) stored in memory in `data`
- name: Nokogiri::XML::SAX::ParserContext::new
  id: nokogiri/xml/sax/parsercontext#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::SAX::ParserContext
  description: |-
    new (thing, encoding = "UTF-8") Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/parser_context.rb, line 11
    def self.new(thing, encoding = "UTF-8")
      if [:read, :close].all? { |x| thing.respond_to?(x) }
        io(thing, Parser::ENCODINGS[encoding])
      else
        memory(thing)
      end
    end
    ```

    ### Public Instance Methods
- name: Nokogiri::XML::SAX::PushParser
  id: nokogiri/xml/sax/pushparser
  summary: PushParser can parse a document that is fed to it manually
  description: "# class Nokogiri::XML::SAX::PushParser\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n[`PushParser`](pushparser) can parse a document that is fed to it manually. It must be given a [`SAX::Document`](document) object which will be called with [`SAX`](../sax) events as the document is being parsed.\n\nCalling [`PushParser#<<`](pushparser#method-i-3C-3C) writes [`XML`](../../xml) to the parser, calling any [`SAX`](../sax) callbacks it can.\n\n[`PushParser#finish`](pushparser#method-i-finish) tells the parser that the document is finished and calls the end_document [`SAX`](../sax) method.\n\nExample:\n\n``` ruby\nparser = PushParser.new(Class.new(XML::SAX::Document) {\n  def start_document\n    puts \"start document called\"\n  end\n}.new)\nparser << \"<div>hello<\"\nparser << \"/div>\"\nparser.finish\n```\n\n### Attributes\n\ndocument\\[RW\\]\n\nThe [`Nokogiri::XML::SAX::Document`](document) on which the [`PushParser`](pushparser) will be operating\n\n### Public Class Methods\n\nnew(doc = XML::SAX::Document.new, file_name = nil, encoding = \"UTF-8\") Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/push_parser.rb, line 35\ndef initialize(doc = XML::SAX::Document.new, file_name = nil, encoding = \"UTF-8\")\n  @document = doc\n  @encoding = encoding\n  @sax_parser = XML::SAX::Parser.new(doc)\n\n  ## Create our push parser context\n  initialize_native(@sax_parser, file_name)\nend\n```\n\nCreate a new [`PushParser`](pushparser) with `doc` as the [`SAX`](../sax) [`Document`](document), providing an optional `file_name` and `encoding`\n\n### Public Instance Methods\n\n\\<\\<(chunk, last_chunk = false)\n\nAlias for: [write](pushparser#method-i-write)\n\nfinish() Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/push_parser.rb, line 55\ndef finish\n  write(\"\", true)\nend\n```\n\nFinish the parsing. This method is only necessary for [`Nokogiri::XML::SAX::Document#end_document`](document#method-i-end_document) to be called.\n\noptions() Show source\n\n``` c\nstatic VALUE\nget_options(VALUE self)\n{\n  xmlParserCtxtPtr ctx;\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  return INT2NUM(ctx->options);\n}\n```\n\noptions=(p1) Show source\n\n``` c\nstatic VALUE\nset_options(VALUE self, VALUE options)\n{\n  xmlParserCtxtPtr ctx;\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  if (xmlCtxtUseOptions(ctx, (int)NUM2INT(options)) != 0) {\n    rb_raise(rb_eRuntimeError, \"Cannot set XML parser context options\");\n  }\n\n  return Qnil;\n}\n```\n\nreplace_entities Show source\n\n``` c\nstatic VALUE\nget_replace_entities(VALUE self)\n{\n  xmlParserCtxtPtr ctx;\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  if (0 == ctx->replaceEntities) {\n    return Qfalse;\n  } else {\n    return Qtrue;\n  }\n}\n```\n\nShould this parser replace entities? &amp; will get converted to ‘&’ if set to true\n\nreplace_entities=(boolean) Show source\n\n``` c\nstatic VALUE\nset_replace_entities(VALUE self, VALUE value)\n{\n  xmlParserCtxtPtr ctx;\n  Data_Get_Struct(self, xmlParserCtxt, ctx);\n\n  if (Qfalse == value) {\n    ctx->replaceEntities = 0;\n  } else {\n    ctx->replaceEntities = 1;\n  }\n\n  return value;\n}\n```\n\nShould this parser replace entities? &amp; will get converted to ‘&’ if set to true\n\nwrite(chunk, last_chunk = false) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/push_parser.rb, line 47\ndef write(chunk, last_chunk = false)\n  native_write(chunk, last_chunk)\nend\n```\n\nWrite a `chunk` of [`XML`](../../xml) to the [`PushParser`](pushparser). Any callback methods that can be called will be called immediately.\n\nAlso aliased as: [\\<\\<](pushparser#method-i-3C-3C)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/PushParser.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/PushParser.html)"
- name: Nokogiri::XML::SAX::PushParser#<<
  id: nokogiri/xml/sax/pushparser#method-i-3C-3C
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    \<\< (chunk, last_chunk = false)

    Alias for: [write](pushparser#method-i-write)
- name: Nokogiri::XML::SAX::PushParser#document
  id: nokogiri/xml/sax/pushparser#attribute-i-document
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    document \[RW\]

    The [`Nokogiri::XML::SAX::Document`](document) on which the [`PushParser`](pushparser) will be operating

    ### Public Class Methods
- name: Nokogiri::XML::SAX::PushParser#finish
  id: nokogiri/xml/sax/pushparser#method-i-finish
  summary: Finish the parsing
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    finish () Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/push_parser.rb, line 55
    def finish
      write("", true)
    end
    ```

    Finish the parsing. This method is only necessary for [`Nokogiri::XML::SAX::Document#end_document`](document#method-i-end_document) to be called.
- name: Nokogiri::XML::SAX::PushParser#options
  id: nokogiri/xml/sax/pushparser#method-i-options
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    options () Show source

    ``` c
    static VALUE
    get_options(VALUE self)
    {
      xmlParserCtxtPtr ctx;
      Data_Get_Struct(self, xmlParserCtxt, ctx);

      return INT2NUM(ctx->options);
    }
    ```
- name: Nokogiri::XML::SAX::PushParser#options=
  id: nokogiri/xml/sax/pushparser#method-i-options-3D
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    options= (p1) Show source

    ``` c
    static VALUE
    set_options(VALUE self, VALUE options)
    {
      xmlParserCtxtPtr ctx;
      Data_Get_Struct(self, xmlParserCtxt, ctx);

      if (xmlCtxtUseOptions(ctx, (int)NUM2INT(options)) != 0) {
        rb_raise(rb_eRuntimeError, "Cannot set XML parser context options");
      }

      return Qnil;
    }
    ```
- name: Nokogiri::XML::SAX::PushParser#replace_entities
  id: nokogiri/xml/sax/pushparser#method-i-replace_entities
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    replace_entities Show source

    ``` c
    static VALUE
    get_replace_entities(VALUE self)
    {
      xmlParserCtxtPtr ctx;
      Data_Get_Struct(self, xmlParserCtxt, ctx);

      if (0 == ctx->replaceEntities) {
        return Qfalse;
      } else {
        return Qtrue;
      }
    }
    ```

    Should this parser replace entities? &amp; will get converted to ‘&’ if set to true
- name: Nokogiri::XML::SAX::PushParser#replace_entities=
  id: nokogiri/xml/sax/pushparser#method-i-replace_entities-3D
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    replace_entities=(boolean) Show source

    ``` c
    static VALUE
    set_replace_entities(VALUE self, VALUE value)
    {
      xmlParserCtxtPtr ctx;
      Data_Get_Struct(self, xmlParserCtxt, ctx);

      if (Qfalse == value) {
        ctx->replaceEntities = 0;
      } else {
        ctx->replaceEntities = 1;
      }

      return value;
    }
    ```

    Should this parser replace entities? &amp; will get converted to ‘&’ if set to true
- name: Nokogiri::XML::SAX::PushParser#write
  id: nokogiri/xml/sax/pushparser#method-i-write
  summary: Write a chunk of XML to the PushParser
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: "write (chunk, last_chunk = false) Show source\n\n``` ruby\n# File lib/nokogiri/xml/sax/push_parser.rb, line 47\ndef write(chunk, last_chunk = false)\n  native_write(chunk, last_chunk)\nend\n```\n\nWrite a `chunk` of [`XML`](../../xml) to the [`PushParser`](pushparser). Any callback methods that can be called will be called immediately.\n\nAlso aliased as: [\\<\\<](pushparser#method-i-3C-3C)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SAX/PushParser.html](https://nokogiri.org/rdoc/Nokogiri/XML/SAX/PushParser.html)"
- name: Nokogiri::XML::SAX::PushParser::new
  id: nokogiri/xml/sax/pushparser#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::SAX::PushParser
  description: |-
    new (doc = XML::SAX::Document.new, file_name = nil, encoding = "UTF-8") Show source

    ``` ruby
    # File lib/nokogiri/xml/sax/push_parser.rb, line 35
    def initialize(doc = XML::SAX::Document.new, file_name = nil, encoding = "UTF-8")
      @document = doc
      @encoding = encoding
      @sax_parser = XML::SAX::Parser.new(doc)

      ## Create our push parser context
      initialize_native(@sax_parser, file_name)
    end
    ```

    Create a new [`PushParser`](pushparser) with `doc` as the [`SAX`](../sax) [`Document`](document), providing an optional `file_name` and `encoding`

    ### Public Instance Methods
- name: Nokogiri::XML::Schema
  id: nokogiri/xml#method-c-Schema
  summary: Create a new Nokogiri::XML::Schema object using a string_or_io object
  belongs_to: Nokogiri::XML
  description: |-
    Schema (string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Show source

    ``` ruby
    # File lib/nokogiri/xml/schema.rb, line 9
    def Schema(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)
      Schema.new(string_or_io, options)
    end
    ```

    Create a new [`Nokogiri::XML::Schema`](xml/schema) object using a `string_or_io` object.
- name: Nokogiri::XML::Schema
  id: nokogiri/xml/schema
  summary: Nokogiri::XML::Schema is used for validating XML against a schema (usually from an xsd file)
  description: "# class Nokogiri::XML::Schema\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n[`Nokogiri::XML::Schema`](schema) is used for validating [`XML`](../xml) against a schema (usually from an xsd file).\n\n## Synopsis\n\nValidate an [`XML`](../xml) document against a [`Schema`](schema). Loop over the errors that are returned and print them out:\n\n``` ruby\nxsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\ndoc = Nokogiri::XML(File.read(PO_XML_FILE))\n\nxsd.validate(doc).each do |error|\n  puts error.message\nend\n```\n\nThe list of errors are [`Nokogiri::XML::SyntaxError`](syntaxerror) objects.\n\nNOTE: As of v1.11.0, [`Schema`](schema) treats inputs as UNTRUSTED by default, and so external entities are not resolved from the network (‘http://\\` or \\`ftp://\\`). Previously, parsing treated documents as “trusted” by default which was counter to Nokogiri’s “untrusted by default” security policy. If a document is trusted, then the caller may turn off the NONET option via the [`ParseOptions`](parseoptions) to re-enable external entity resolution over a network connection.\n\n### Attributes\n\nerrors\\[RW\\]\n\nErrors while parsing the schema file\n\nparse_options\\[RW\\]\n\nThe [`Nokogiri::XML::ParseOptions`](parseoptions) used to parse the schema\n\n### Public Class Methods\n\nfrom_document(doc) Show source\n\n``` c\nstatic VALUE\nfrom_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  int parse_options_int;\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n  xmlExternalEntityLoader old_loader = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Noko_Node_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  if (parse_options_int & XML_PARSE_NONET) {\n    old_loader = xmlGetExternalEntityLoader();\n    xmlSetExternalEntityLoader(xmlNoNetExternalEntityLoader);\n  }\n\n  schema = xmlSchemaParse(ctx);\n\n  if (old_loader) {\n    xmlSetExternalEntityLoader(old_loader);\n  }\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if (NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if (error) {\n      Nokogiri_error_raise(NULL, error);\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n\n  return Qnil;\n}\n```\n\nCreate a new [`Schema`](schema) from the [`Nokogiri::XML::Document`](document) `doc`\n\nnew(string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Show source\n\n``` ruby\n# File lib/nokogiri/xml/schema.rb, line 46\ndef self.new(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n  from_document(Nokogiri::XML(string_or_io), options)\nend\n```\n\nCreate a new [`Nokogiri::XML::Schema`](schema) object using a `string_or_io` object.\n\nread_memory(string) Show source\n\n``` c\nstatic VALUE\nread_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  int parse_options_int;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n  xmlExternalEntityLoader old_loader = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n\n  ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  if (parse_options_int & XML_PARSE_NONET) {\n    old_loader = xmlGetExternalEntityLoader();\n    xmlSetExternalEntityLoader(xmlNoNetExternalEntityLoader);\n  }\n\n  schema = xmlSchemaParse(ctx);\n\n  if (old_loader) {\n    xmlSetExternalEntityLoader(old_loader);\n  }\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if (NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if (error) {\n      Nokogiri_error_raise(NULL, error);\n    } else {\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    }\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n```\n\nCreate a new [`Schema`](schema) from the contents of `string`\n\n### Public Instance Methods\n\nvalid?(thing) Show source\n\n``` ruby\n# File lib/nokogiri/xml/schema.rb, line 68\ndef valid?(thing)\n  validate(thing).empty?\nend\n```\n\nReturns true if `thing` is a valid [`Nokogiri::XML::Document`](document) or file.\n\nvalidate(thing) Show source\n\n``` ruby\n# File lib/nokogiri/xml/schema.rb, line 55\ndef validate(thing)\n  if thing.is_a?(Nokogiri::XML::Document)\n    validate_document(thing)\n  elsif File.file?(thing)\n    validate_file(thing)\n  else\n    raise ArgumentError, \"Must provide Nokogiri::Xml::Document or the name of an existing file\"\n  end\nend\n```\n\nValidate `thing` against this schema. `thing` can be a [`Nokogiri::XML::Document`](document) object, or a filename. An Array of [`Nokogiri::XML::SyntaxError`](syntaxerror) objects found while validating the `thing` is returned.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Schema.html](https://nokogiri.org/rdoc/Nokogiri/XML/Schema.html)"
- name: Nokogiri::XML::Schema#errors
  id: nokogiri/xml/schema#attribute-i-errors
  summary: null
  belongs_to: Nokogiri::XML::Schema
  description: |-
    errors \[RW\]

    Errors while parsing the schema file
- name: Nokogiri::XML::Schema#parse_options
  id: nokogiri/xml/schema#attribute-i-parse_options
  summary: null
  belongs_to: Nokogiri::XML::Schema
  description: |-
    parse_options \[RW\]

    The [`Nokogiri::XML::ParseOptions`](parseoptions) used to parse the schema

    ### Public Class Methods
- name: Nokogiri::XML::Schema#valid?
  id: nokogiri/xml/schema#method-i-valid-3F
  summary: Returns true if thing is a valid Nokogiri::XML::Document or file
  belongs_to: Nokogiri::XML::Schema
  description: |-
    valid? (thing) Show source

    ``` ruby
    # File lib/nokogiri/xml/schema.rb, line 68
    def valid?(thing)
      validate(thing).empty?
    end
    ```

    Returns true if `thing` is a valid [`Nokogiri::XML::Document`](document) or file.
- name: Nokogiri::XML::Schema#validate
  id: nokogiri/xml/schema#method-i-validate
  summary: Validate thing against this schema
  belongs_to: Nokogiri::XML::Schema
  description: "validate (thing) Show source\n\n``` ruby\n# File lib/nokogiri/xml/schema.rb, line 55\ndef validate(thing)\n  if thing.is_a?(Nokogiri::XML::Document)\n    validate_document(thing)\n  elsif File.file?(thing)\n    validate_file(thing)\n  else\n    raise ArgumentError, \"Must provide Nokogiri::Xml::Document or the name of an existing file\"\n  end\nend\n```\n\nValidate `thing` against this schema. `thing` can be a [`Nokogiri::XML::Document`](document) object, or a filename. An Array of [`Nokogiri::XML::SyntaxError`](syntaxerror) objects found while validating the `thing` is returned.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Schema.html](https://nokogiri.org/rdoc/Nokogiri/XML/Schema.html)"
- name: Nokogiri::XML::Schema::from_document
  id: nokogiri/xml/schema#method-c-from_document
  summary: null
  belongs_to: Nokogiri::XML::Schema
  description: |-
    from_document(doc) Show source

    ``` c
    static VALUE
    from_document(int argc, VALUE *argv, VALUE klass)
    {
      VALUE document;
      VALUE parse_options;
      int parse_options_int;
      xmlDocPtr doc;
      xmlSchemaParserCtxtPtr ctx;
      xmlSchemaPtr schema;
      VALUE errors;
      VALUE rb_schema;
      int scanned_args = 0;
      xmlExternalEntityLoader old_loader = 0;

      scanned_args = rb_scan_args(argc, argv, "11", &document, &parse_options);

      Noko_Node_Get_Struct(document, xmlDoc, doc);
      doc = doc->doc; /* In case someone passes us a node. ugh. */

      if (scanned_args == 1) {
        parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern("ParseOptions")), rb_intern("DEFAULT_SCHEMA"));
      }
      parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern("to_i"), 0));

      if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {
        rb_raise(rb_eArgError, "Creating a schema from a document that has blank nodes exposed to Ruby is dangerous");
      }

      ctx = xmlSchemaNewDocParserCtxt(doc);

      errors = rb_ary_new();
      xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

    #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS
      xmlSchemaSetParserStructuredErrors(
        ctx,
        Nokogiri_error_array_pusher,
        (void *)errors
      );
    #endif

      if (parse_options_int & XML_PARSE_NONET) {
        old_loader = xmlGetExternalEntityLoader();
        xmlSetExternalEntityLoader(xmlNoNetExternalEntityLoader);
      }

      schema = xmlSchemaParse(ctx);

      if (old_loader) {
        xmlSetExternalEntityLoader(old_loader);
      }

      xmlSetStructuredErrorFunc(NULL, NULL);
      xmlSchemaFreeParserCtxt(ctx);

      if (NULL == schema) {
        xmlErrorPtr error = xmlGetLastError();
        if (error) {
          Nokogiri_error_raise(NULL, error);
        } else {
          rb_raise(rb_eRuntimeError, "Could not parse document");
        }

        return Qnil;
      }

      rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
      rb_iv_set(rb_schema, "@errors", errors);
      rb_iv_set(rb_schema, "@parse_options", parse_options);

      return rb_schema;

      return Qnil;
    }
    ```

    Create a new [`Schema`](schema) from the [`Nokogiri::XML::Document`](document) `doc`
- name: Nokogiri::XML::Schema::new
  id: nokogiri/xml/schema#method-c-new
  summary: Create a new Nokogiri::XML::Schema object using a string_or_io object
  belongs_to: Nokogiri::XML::Schema
  description: |-
    new (string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Show source

    ``` ruby
    # File lib/nokogiri/xml/schema.rb, line 46
    def self.new(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)
      from_document(Nokogiri::XML(string_or_io), options)
    end
    ```

    Create a new [`Nokogiri::XML::Schema`](schema) object using a `string_or_io` object.
- name: Nokogiri::XML::Schema::read_memory
  id: nokogiri/xml/schema#method-c-read_memory
  summary: null
  belongs_to: Nokogiri::XML::Schema
  description: |-
    read_memory(string) Show source

    ``` c
    static VALUE
    read_memory(int argc, VALUE *argv, VALUE klass)
    {
      VALUE content;
      VALUE parse_options;
      int parse_options_int;
      xmlSchemaParserCtxtPtr ctx;
      xmlSchemaPtr schema;
      VALUE errors;
      VALUE rb_schema;
      int scanned_args = 0;
      xmlExternalEntityLoader old_loader = 0;

      scanned_args = rb_scan_args(argc, argv, "11", &content, &parse_options);
      if (scanned_args == 1) {
        parse_options = rb_const_get_at(rb_const_get_at(mNokogiriXml, rb_intern("ParseOptions")), rb_intern("DEFAULT_SCHEMA"));
      }
      parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern("to_i"), 0));

      ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));

      errors = rb_ary_new();
      xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

    #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS
      xmlSchemaSetParserStructuredErrors(
        ctx,
        Nokogiri_error_array_pusher,
        (void *)errors
      );
    #endif

      if (parse_options_int & XML_PARSE_NONET) {
        old_loader = xmlGetExternalEntityLoader();
        xmlSetExternalEntityLoader(xmlNoNetExternalEntityLoader);
      }

      schema = xmlSchemaParse(ctx);

      if (old_loader) {
        xmlSetExternalEntityLoader(old_loader);
      }

      xmlSetStructuredErrorFunc(NULL, NULL);
      xmlSchemaFreeParserCtxt(ctx);

      if (NULL == schema) {
        xmlErrorPtr error = xmlGetLastError();
        if (error) {
          Nokogiri_error_raise(NULL, error);
        } else {
          rb_raise(rb_eRuntimeError, "Could not parse document");
        }

        return Qnil;
      }

      rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
      rb_iv_set(rb_schema, "@errors", errors);
      rb_iv_set(rb_schema, "@parse_options", parse_options);

      return rb_schema;
    }
    ```

    Create a new [`Schema`](schema) from the contents of `string`

    ### Public Instance Methods
- name: Nokogiri::XML::Searchable
  id: nokogiri/xml/searchable
  summary: The Searchable module declares the interface used for searching your DOM
  description: "# module Nokogiri::XML::Searchable\n\nThe [`Searchable`](searchable) module declares the interface used for searching your DOM.\n\nIt implements the public methods [`#search`](searchable#method-i-search), [`#css`](searchable#method-i-css), and [`#xpath`](searchable#method-i-xpath), as well as allowing specific implementations to specialize some of the important behaviors.\n\n### Constants\n\nLOOKS_LIKE_XPATH  \nRegular expression used by [`Searchable#search`](searchable#method-i-search) to determine if a query string is [`CSS`](../css) or [`XPath`](xpath)\n\n## Searching via XPath or CSS Queries\n\n[↑ top](#top)\n\n### Public Instance Methods\n\n%(\\*args)\n\nAlias for: [at](searchable#method-i-at)\n\n/(\\*args)\n\nAlias for: [search](searchable#method-i-search)\n\n\\>(selector) → NodeSet Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 196\ndef >(selector) # rubocop:disable Naming/BinaryOperatorParameterName\n  ns = (document.root&.namespaces || {})\n  xpath(CSS.xpath_for(selector, prefix: \"./\", ns: ns).first)\nend\n```\n\nSearch this node’s immediate children using [`CSS`](../css) selector `selector`\n\nat(\\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 71\ndef at(*args)\n  search(*args).first\nend\n```\n\nSearch this object for `paths`, and return only the first result. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.\n\nSee [`Searchable#search`](searchable#method-i-search) for more information.\n\nAlso aliased as: [%](searchable#method-i-25)\n\nat_css(\\*rules, \\[namespace-bindings, custom-pseudo-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 140\ndef at_css(*args)\n  css(*args).first\nend\n```\n\nSearch this object for [`CSS`](../css) `rules`, and return only the first match. `rules` must be one or more [`CSS`](../css) selectors.\n\nSee [`Searchable#css`](searchable#method-i-css) for more information.\n\nat_xpath(\\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 188\ndef at_xpath(*args)\n  xpath(*args).first\nend\n```\n\nSearch this node for [`XPath`](xpath) `paths`, and return only the first match. `paths` must be one or more [`XPath`](xpath) queries.\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) for more information.\n\ncss(\\*rules, \\[namespace-bindings, custom-pseudo-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 126\ndef css(*args)\n  rules, handler, ns, _ = extract_params(args)\n\n  css_internal(self, rules, handler, ns)\nend\n```\n\nSearch this object for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:\n\n``` ruby\nnode.css('title')\nnode.css('body h1.bold')\nnode.css('div + p.green', 'div#one')\n```\n\nA hash of namespace bindings may be appended. For example:\n\n``` ruby\nnode.css('bike|tire', {'bike' => 'http://schwinn.com/'})\n```\n\n💡 Custom [`CSS`](../css) pseudo classes may also be defined which are mapped to a custom [`XPath`](xpath) function. To define custom pseudo classes, create a class and implement the custom pseudo class you want defined. The first argument to the method will be the matching context [`NodeSet`](nodeset). Any other arguments are ones that you pass in. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex(node_set, regex)\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.css('title:regex(\"\\w+\")', handler)\n```\n\n💡 Some [`XPath`](xpath) syntax is supported in [`CSS`](../css) queries. For example, to query for an attribute:\n\n``` ruby\nnode.css('img > @href') # returns all +href+ attributes on an +img+ element\nnode.css('img / @href') # same\n\n# ⚠ this returns +class+ attributes from all +div+ elements AND THEIR CHILDREN!\nnode.css('div @class')\n\nnode.css\n```\n\n💡 Array-like syntax is supported in [`CSS`](../css) queries as an alternative to using +:nth-child()+.\n\n⚠ NOTE that indices are 1-based like `:nth-child` and not 0-based like Ruby Arrays. For example:\n\n``` ruby\n# equivalent to 'li:nth-child(2)'\nnode.css('li[2]') # retrieve the second li element in a list\n```\n\n⚠ NOTE that the [`CSS`](../css) query string is case-sensitive with regards to your document type. [`HTML`](../html4) tags will match only lowercase [`CSS`](../css) queries, so if you search for “H1” in an [`HTML`](../html4) document, you’ll never find anything. However, “H1” might be found in an [`XML`](../xml) document, where tags names are case-sensitive (e.g., “H1” is distinct from “h1”).\n\nsearch(\\*paths, \\[namespace-bindings, xpath-variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 51\ndef search(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpaths = paths.map(&:to_s).map do |path|\n    LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)\n  end.flatten.uniq\n\n  xpath(*(xpaths + [ns, handler, binds].compact))\nend\n```\n\nSearch this object for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries:\n\n``` ruby\nnode.search(\"div.employee\", \".//title\")\n```\n\nA hash of namespace bindings may be appended:\n\n``` ruby\nnode.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})\nnode.search('bike|tire', {'bike' => 'http://schwinn.com/'})\n```\n\nFor [`XPath`](xpath) queries, a hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions and [`CSS`](../css) pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex node_set, regex\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.search('.//title[regex(., \"\\w+\")]', 'div.employee:regex(\"[0-9]+\")', handler)\n```\n\nSee [`Searchable#xpath`](searchable#method-i-xpath) and [`Searchable#css`](searchable#method-i-css) for further usage help.\n\nAlso aliased as: [/](searchable#method-i-2F)\n\nxpath(\\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 174\ndef xpath(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpath_internal(self, paths, handler, ns, binds)\nend\n```\n\nSearch this node for [`XPath`](xpath) `paths`. `paths` must be one or more [`XPath`](xpath) queries.\n\n``` ruby\nnode.xpath('.//title')\n```\n\nA hash of namespace bindings may be appended. For example:\n\n``` ruby\nnode.xpath('.//foo:name', {'foo' => 'http://example.org/'})\nnode.xpath('.//xmlns:name', node.root.namespaces)\n```\n\nA hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.xpath('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex(node_set, regex)\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.xpath('.//title[regex(., \"\\w+\")]', handler)\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Searchable.html](https://nokogiri.org/rdoc/Nokogiri/XML/Searchable.html)"
- name: Nokogiri::XML::Searchable#%
  id: nokogiri/xml/searchable#method-i-25
  summary: null
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    % (\*args)

    Alias for: [at](searchable#method-i-at)
- name: Nokogiri::XML::Searchable#/
  id: nokogiri/xml/searchable#method-i-2F
  summary: null
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    / (\*args)

    Alias for: [search](searchable#method-i-search)
- name: Nokogiri::XML::Searchable#>
  id: nokogiri/xml/searchable#method-i-3E
  summary: null
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    \>(selector) → NodeSet Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 196
    def >(selector) # rubocop:disable Naming/BinaryOperatorParameterName
      ns = (document.root&.namespaces || {})
      xpath(CSS.xpath_for(selector, prefix: "./", ns: ns).first)
    end
    ```

    Search this node’s immediate children using [`CSS`](../css) selector `selector`
- name: Nokogiri::XML::Searchable#at
  id: nokogiri/xml/searchable#method-i-at
  summary: Search this object for paths, and return only the first result
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    at(\*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 71
    def at(*args)
      search(*args).first
    end
    ```

    Search this object for `paths`, and return only the first result. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries.

    See [`Searchable#search`](searchable#method-i-search) for more information.

    Also aliased as: [%](searchable#method-i-25)
- name: Nokogiri::XML::Searchable#at_css
  id: nokogiri/xml/searchable#method-i-at_css
  summary: Search this object for CSS rules, and return only the first match
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    at_css(\*rules, \[namespace-bindings, custom-pseudo-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 140
    def at_css(*args)
      css(*args).first
    end
    ```

    Search this object for [`CSS`](../css) `rules`, and return only the first match. `rules` must be one or more [`CSS`](../css) selectors.

    See [`Searchable#css`](searchable#method-i-css) for more information.
- name: Nokogiri::XML::Searchable#at_xpath
  id: nokogiri/xml/searchable#method-i-at_xpath
  summary: Search this node for XPath paths, and return only the first match
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    at_xpath(\*paths, \[namespace-bindings, variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 188
    def at_xpath(*args)
      xpath(*args).first
    end
    ```

    Search this node for [`XPath`](xpath) `paths`, and return only the first match. `paths` must be one or more [`XPath`](xpath) queries.

    See [`Searchable#xpath`](searchable#method-i-xpath) for more information.
- name: Nokogiri::XML::Searchable#css
  id: nokogiri/xml/searchable#method-i-css
  summary: Search this object for CSS rules
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    css(\*rules, \[namespace-bindings, custom-pseudo-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 126
    def css(*args)
      rules, handler, ns, _ = extract_params(args)

      css_internal(self, rules, handler, ns)
    end
    ```

    Search this object for [`CSS`](../css) `rules`. `rules` must be one or more [`CSS`](../css) selectors. For example:

    ``` ruby
    node.css('title')
    node.css('body h1.bold')
    node.css('div + p.green', 'div#one')
    ```

    A hash of namespace bindings may be appended. For example:

    ``` ruby
    node.css('bike|tire', {'bike' => 'http://schwinn.com/'})
    ```

    💡 Custom [`CSS`](../css) pseudo classes may also be defined which are mapped to a custom [`XPath`](xpath) function. To define custom pseudo classes, create a class and implement the custom pseudo class you want defined. The first argument to the method will be the matching context [`NodeSet`](nodeset). Any other arguments are ones that you pass in. For example:

    ``` ruby
    handler = Class.new {
      def regex(node_set, regex)
        node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      end
    }.new
    node.css('title:regex("\w+")', handler)
    ```

    💡 Some [`XPath`](xpath) syntax is supported in [`CSS`](../css) queries. For example, to query for an attribute:

    ``` ruby
    node.css('img > @href') # returns all +href+ attributes on an +img+ element
    node.css('img / @href') # same

    # ⚠ this returns +class+ attributes from all +div+ elements AND THEIR CHILDREN!
    node.css('div @class')

    node.css
    ```

    💡 Array-like syntax is supported in [`CSS`](../css) queries as an alternative to using +:nth-child()+.

    ⚠ NOTE that indices are 1-based like `:nth-child` and not 0-based like Ruby Arrays. For example:

    ``` ruby
    # equivalent to 'li:nth-child(2)'
    node.css('li[2]') # retrieve the second li element in a list
    ```

    ⚠ NOTE that the [`CSS`](../css) query string is case-sensitive with regards to your document type. [`HTML`](../html4) tags will match only lowercase [`CSS`](../css) queries, so if you search for “H1” in an [`HTML`](../html4) document, you’ll never find anything. However, “H1” might be found in an [`XML`](../xml) document, where tags names are case-sensitive (e.g., “H1” is distinct from “h1”).
- name: Nokogiri::XML::Searchable#search
  id: nokogiri/xml/searchable#method-i-search
  summary: Search this object for paths
  belongs_to: Nokogiri::XML::Searchable
  description: |-
    search(\*paths, \[namespace-bindings, xpath-variable-bindings, custom-handler-class\]) Show source

    ``` ruby
    # File lib/nokogiri/xml/searchable.rb, line 51
    def search(*args)
      paths, handler, ns, binds = extract_params(args)

      xpaths = paths.map(&:to_s).map do |path|
        LOOKS_LIKE_XPATH.match?(path) ? path : xpath_query_from_css_rule(path, ns)
      end.flatten.uniq

      xpath(*(xpaths + [ns, handler, binds].compact))
    end
    ```

    Search this object for `paths`. `paths` must be one or more [`XPath`](xpath) or [`CSS`](../css) queries:

    ``` ruby
    node.search("div.employee", ".//title")
    ```

    A hash of namespace bindings may be appended:

    ``` ruby
    node.search('.//bike:tire', {'bike' => 'http://schwinn.com/'})
    node.search('bike|tire', {'bike' => 'http://schwinn.com/'})
    ```

    For [`XPath`](xpath) queries, a hash of variable bindings may also be appended to the namespace bindings. For example:

    ``` ruby
    node.search('.//address[@domestic=$value]', nil, {:value => 'Yes'})
    ```

    💡 Custom [`XPath`](xpath) functions and [`CSS`](../css) pseudo-selectors may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:

    ``` ruby
    handler = Class.new {
      def regex node_set, regex
        node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }
      end
    }.new
    node.search('.//title[regex(., "\w+")]', 'div.employee:regex("[0-9]+")', handler)
    ```

    See [`Searchable#xpath`](searchable#method-i-xpath) and [`Searchable#css`](searchable#method-i-css) for further usage help.

    Also aliased as: [/](searchable#method-i-2F)
- name: Nokogiri::XML::Searchable#xpath
  id: nokogiri/xml/searchable#method-i-xpath
  summary: Search this node for XPath paths
  belongs_to: Nokogiri::XML::Searchable
  description: "xpath(\\*paths, \\[namespace-bindings, variable-bindings, custom-handler-class\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xml/searchable.rb, line 174\ndef xpath(*args)\n  paths, handler, ns, binds = extract_params(args)\n\n  xpath_internal(self, paths, handler, ns, binds)\nend\n```\n\nSearch this node for [`XPath`](xpath) `paths`. `paths` must be one or more [`XPath`](xpath) queries.\n\n``` ruby\nnode.xpath('.//title')\n```\n\nA hash of namespace bindings may be appended. For example:\n\n``` ruby\nnode.xpath('.//foo:name', {'foo' => 'http://example.org/'})\nnode.xpath('.//xmlns:name', node.root.namespaces)\n```\n\nA hash of variable bindings may also be appended to the namespace bindings. For example:\n\n``` ruby\nnode.xpath('.//address[@domestic=$value]', nil, {:value => 'Yes'})\n```\n\n💡 Custom [`XPath`](xpath) functions may also be defined. To define custom functions create a class and implement the function you want to define. The first argument to the method will be the current matching [`NodeSet`](nodeset). Any other arguments are ones that you pass in. Note that this class may appear anywhere in the argument list. For example:\n\n``` ruby\nhandler = Class.new {\n  def regex(node_set, regex)\n    node_set.find_all { |node| node['some_attribute'] =~ /#{regex}/ }\n  end\n}.new\nnode.xpath('.//title[regex(., \"\\w+\")]', handler)\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Searchable.html](https://nokogiri.org/rdoc/Nokogiri/XML/Searchable.html)"
- name: Nokogiri::XML::SyntaxError
  id: nokogiri/xml/syntaxerror
  summary: This class provides information about XML SyntaxErrors
  description: "# class Nokogiri::XML::SyntaxError\n\nParent:  \ncNokogiriSyntaxError\n\nThe [`XML::SyntaxError`](syntaxerror) is raised on parse errors\n\nThis class provides information about [`XML`](../xml) SyntaxErrors. These exceptions are typically stored on [`Nokogiri::XML::Document#errors`](document#attribute-i-errors).\n\n### Attributes\n\ncode\\[R\\]\n\ncolumn\\[R\\]\n\ndomain\\[R\\]\n\nfile\\[R\\]\n\nint1\\[R\\]\n\nlevel\\[R\\]\n\nline\\[R\\]\n\nstr1\\[R\\]\n\nstr2\\[R\\]\n\nstr3\\[R\\]\n\n### Public Instance Methods\n\nerror?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/syntax_error.rb, line 34\ndef error?\n  level == 2\nend\n```\n\nreturn true if this is an error\n\nfatal?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/syntax_error.rb, line 40\ndef fatal?\n  level == 3\nend\n```\n\nreturn true if this error is fatal\n\nnone?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/syntax_error.rb, line 22\ndef none?\n  level == 0\nend\n```\n\nreturn true if this is a non error\n\nto_s() Show source\n\n``` ruby\n# File lib/nokogiri/xml/syntax_error.rb, line 44\ndef to_s\n  message = super.chomp\n  [location_to_s, level_to_s, message]\n    .compact.join(\": \")\n    .force_encoding(message.encoding)\nend\n```\n\nCalls superclass method\n\nwarning?() Show source\n\n``` ruby\n# File lib/nokogiri/xml/syntax_error.rb, line 28\ndef warning?\n  level == 1\nend\n```\n\nreturn true if this is a warning\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SyntaxError.html](https://nokogiri.org/rdoc/Nokogiri/XML/SyntaxError.html)"
- name: Nokogiri::XML::SyntaxError#code
  id: nokogiri/xml/syntaxerror#attribute-i-code
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: code \[R\]
- name: Nokogiri::XML::SyntaxError#column
  id: nokogiri/xml/syntaxerror#attribute-i-column
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: column \[R\]
- name: Nokogiri::XML::SyntaxError#domain
  id: nokogiri/xml/syntaxerror#attribute-i-domain
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: domain \[R\]
- name: Nokogiri::XML::SyntaxError#error?
  id: nokogiri/xml/syntaxerror#method-i-error-3F
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: |-
    error? () Show source

    ``` ruby
    # File lib/nokogiri/xml/syntax_error.rb, line 34
    def error?
      level == 2
    end
    ```

    return true if this is an error
- name: Nokogiri::XML::SyntaxError#fatal?
  id: nokogiri/xml/syntaxerror#method-i-fatal-3F
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: |-
    fatal? () Show source

    ``` ruby
    # File lib/nokogiri/xml/syntax_error.rb, line 40
    def fatal?
      level == 3
    end
    ```

    return true if this error is fatal
- name: Nokogiri::XML::SyntaxError#file
  id: nokogiri/xml/syntaxerror#attribute-i-file
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: file \[R\]
- name: Nokogiri::XML::SyntaxError#int1
  id: nokogiri/xml/syntaxerror#attribute-i-int1
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: int1 \[R\]
- name: Nokogiri::XML::SyntaxError#level
  id: nokogiri/xml/syntaxerror#attribute-i-level
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: level \[R\]
- name: Nokogiri::XML::SyntaxError#line
  id: nokogiri/xml/syntaxerror#attribute-i-line
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: line \[R\]
- name: Nokogiri::XML::SyntaxError#none?
  id: nokogiri/xml/syntaxerror#method-i-none-3F
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: |-
    none? () Show source

    ``` ruby
    # File lib/nokogiri/xml/syntax_error.rb, line 22
    def none?
      level == 0
    end
    ```

    return true if this is a non error
- name: Nokogiri::XML::SyntaxError#str1
  id: nokogiri/xml/syntaxerror#attribute-i-str1
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: str1 \[R\]
- name: Nokogiri::XML::SyntaxError#str2
  id: nokogiri/xml/syntaxerror#attribute-i-str2
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: str2 \[R\]
- name: Nokogiri::XML::SyntaxError#str3
  id: nokogiri/xml/syntaxerror#attribute-i-str3
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: |-
    str3 \[R\]

    ### Public Instance Methods
- name: Nokogiri::XML::SyntaxError#to_s
  id: nokogiri/xml/syntaxerror#method-i-to_s
  summary: null
  belongs_to: Nokogiri::XML::SyntaxError
  description: |-
    to_s () Show source

    ``` ruby
    # File lib/nokogiri/xml/syntax_error.rb, line 44
    def to_s
      message = super.chomp
      [location_to_s, level_to_s, message]
        .compact.join(": ")
        .force_encoding(message.encoding)
    end
    ```

    Calls superclass method
- name: Nokogiri::XML::SyntaxError#warning?
  id: nokogiri/xml/syntaxerror#method-i-warning-3F
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::SyntaxError
  description: "warning? () Show source\n\n``` ruby\n# File lib/nokogiri/xml/syntax_error.rb, line 28\ndef warning?\n  level == 1\nend\n```\n\nreturn true if this is a warning\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/SyntaxError.html](https://nokogiri.org/rdoc/Nokogiri/XML/SyntaxError.html)"
- name: Nokogiri::XML::Text
  id: nokogiri/xml/text
  summary: Wraps Text nodes
  description: "# class Nokogiri::XML::Text\n\nParent:  \ncNokogiriXmlCharacterData\n\nWraps [`Text`](text) nodes.\n\n### Public Class Methods\n\nnew(content, document) Show source\n\n``` c\nstatic VALUE\nnew (int argc, VALUE *argv, VALUE klass)\n{\n  xmlDocPtr doc;\n  xmlNodePtr node;\n  VALUE string;\n  VALUE document;\n  VALUE rest;\n  VALUE rb_node;\n\n  rb_scan_args(argc, argv, \"2*\", &string, &document, &rest);\n\n  Noko_Node_Get_Struct(document, xmlDoc, doc);\n\n  node = xmlNewText((xmlChar *)StringValueCStr(string));\n  node->doc = doc->doc;\n\n  noko_xml_document_pin_node(node);\n\n  rb_node = noko_xml_node_wrap(klass, node) ;\n  rb_obj_call_init(rb_node, argc, argv);\n\n  if (rb_block_given_p()) { rb_yield(rb_node); }\n\n  return rb_node;\n}\n```\n\nCreate a new [`Text`](text) element on the `document` with `content`\n\n### Public Instance Methods\n\ncontent=(string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/text.rb, line 6\ndef content=(string)\n  self.native_content = string.to_s\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Text.html](https://nokogiri.org/rdoc/Nokogiri/XML/Text.html)"
- name: Nokogiri::XML::Text#content=
  id: nokogiri/xml/text#method-i-content-3D
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::Text
  description: "content= (string) Show source\n\n``` ruby\n# File lib/nokogiri/xml/text.rb, line 6\ndef content=(string)\n  self.native_content = string.to_s\nend\n```\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/Text.html](https://nokogiri.org/rdoc/Nokogiri/XML/Text.html)"
- name: Nokogiri::XML::Text::new
  id: nokogiri/xml/text#method-c-new
  summary: null
  belongs_to: Nokogiri::XML::Text
  description: |-
    new(content, document) Show source

    ``` c
    static VALUE
    new (int argc, VALUE *argv, VALUE klass)
    {
      xmlDocPtr doc;
      xmlNodePtr node;
      VALUE string;
      VALUE document;
      VALUE rest;
      VALUE rb_node;

      rb_scan_args(argc, argv, "2*", &string, &document, &rest);

      Noko_Node_Get_Struct(document, xmlDoc, doc);

      node = xmlNewText((xmlChar *)StringValueCStr(string));
      node->doc = doc->doc;

      noko_xml_document_pin_node(node);

      rb_node = noko_xml_node_wrap(klass, node) ;
      rb_obj_call_init(rb_node, argc, argv);

      if (rb_block_given_p()) { rb_yield(rb_node); }

      return rb_node;
    }
    ```

    Create a new [`Text`](text) element on the `document` with `content`

    ### Public Instance Methods
- name: Nokogiri::XML::XPath
  id: nokogiri/xml/xpath
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# module Nokogiri::XML::XPath\n\n### Constants\n\nCURRENT_SEARCH_PREFIX  \nThe [`XPath`](xpath) search prefix to search direct descendants of the current element, `./`\n\nGLOBAL_SEARCH_PREFIX  \nThe [`XPath`](xpath) search prefix to search globally, `//`\n\nROOT_SEARCH_PREFIX  \nThe [`XPath`](xpath) search prefix to search direct descendants of the root element, `/`\n\nSUBTREE_SEARCH_PREFIX  \nThe [`XPath`](xpath) search prefix to search anywhere in the current element’s subtree, `.//`\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/XPath.html](https://nokogiri.org/rdoc/Nokogiri/XML/XPath.html)"
- name: Nokogiri::XML::XPath::SyntaxError
  id: nokogiri/xml/xpath/syntaxerror
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# class Nokogiri::XML::XPath::SyntaxError\n\nParent:  \ncNokogiriXmlSyntaxError\n\n### Public Instance Methods\n\nto_s() Show source\n\n``` ruby\n# File lib/nokogiri/xml/xpath/syntax_error.rb, line 7\ndef to_s\n  [super.chomp, str1].compact.join(\": \")\nend\n```\n\nCalls superclass method\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/XPath/SyntaxError.html](https://nokogiri.org/rdoc/Nokogiri/XML/XPath/SyntaxError.html)"
- name: Nokogiri::XML::XPath::SyntaxError#to_s
  id: nokogiri/xml/xpath/syntaxerror#method-i-to_s
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: Nokogiri::XML::XPath::SyntaxError
  description: "to_s () Show source\n\n``` ruby\n# File lib/nokogiri/xml/xpath/syntax_error.rb, line 7\ndef to_s\n  [super.chomp, str1].compact.join(\": \")\nend\n```\n\nCalls superclass method\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/XPath/SyntaxError.html](https://nokogiri.org/rdoc/Nokogiri/XML/XPath/SyntaxError.html)"
- name: Nokogiri::XML::XPathContext
  id: nokogiri/xml/xpathcontext
  summary: XPathContext is the entry point for searching a Document by using XPath
  description: "# class Nokogiri::XML::XPathContext\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\n[`XPathContext`](xpathcontext) is the entry point for searching a [`Document`](document) by using [`XPath`](xpath).\n\n### Public Class Methods\n\nnew(node) Show source\n\n``` c\nstatic VALUE\nrb_xml_xpath_context_new(VALUE klass, VALUE nodeobj)\n{\n  xmlNodePtr node;\n  xmlXPathContextPtr ctx;\n  VALUE self;\n\n  Noko_Node_Get_Struct(nodeobj, xmlNode, node);\n\n#if LIBXML_VERSION < 21000\n  /* deprecated in 40483d0 */\n  xmlXPathInit();\n#endif\n\n  ctx = xmlXPathNewContext(node->doc);\n  ctx->node = node;\n\n  xmlXPathRegisterNs(ctx, NOKOGIRI_PREFIX, NOKOGIRI_URI);\n  xmlXPathRegisterNs(ctx, NOKOGIRI_BUILTIN_PREFIX, NOKOGIRI_BUILTIN_URI);\n  xmlXPathRegisterFuncNS(ctx, (const xmlChar *)\"css-class\", NOKOGIRI_BUILTIN_URI,\n                         xpath_builtin_css_class);\n  xmlXPathRegisterFuncNS(ctx, (const xmlChar *)\"local-name-is\", NOKOGIRI_BUILTIN_URI,\n                         xpath_builtin_local_name_is);\n\n  self = Data_Wrap_Struct(klass, 0, xml_xpath_context_deallocate, ctx);\n  return self;\n}\n```\n\nCreate a new [`XPathContext`](xpathcontext) with `node` as the reference point.\n\n### Public Instance Methods\n\nevaluate(search_path, handler = nil) Show source\n\n``` c\nstatic VALUE\nrb_xml_xpath_context_evaluate(int argc, VALUE *argv, VALUE self)\n{\n  VALUE search_path, xpath_handler;\n  VALUE retval = Qnil;\n  xmlXPathContextPtr ctx;\n  xmlXPathObjectPtr xpath;\n  xmlChar *query;\n  VALUE errors = rb_ary_new();\n\n  Data_Get_Struct(self, xmlXPathContext, ctx);\n\n  if (rb_scan_args(argc, argv, \"11\", &search_path, &xpath_handler) == 1) {\n    xpath_handler = Qnil;\n  }\n\n  query = (xmlChar *)StringValueCStr(search_path);\n\n  if (Qnil != xpath_handler) {\n    /* FIXME: not sure if this is the correct place to shove private data. */\n    ctx->userData = (void *)xpath_handler;\n    xmlXPathRegisterFuncLookup(ctx, handler_lookup, (void *)xpath_handler);\n  }\n\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n  xmlSetGenericErrorFunc((void *)errors, generic_exception_pusher);\n\n  xpath = xmlXPathEvalExpression(query, ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSetGenericErrorFunc(NULL, NULL);\n\n  if (xpath == NULL) {\n    rb_exc_raise(rb_ary_entry(errors, 0));\n  }\n\n  retval = xpath2ruby(xpath, ctx);\n  if (retval == Qundef) {\n    retval = noko_xml_node_set_wrap(NULL, DOC_RUBY_OBJECT(ctx->doc));\n  }\n\n  xmlXPathFreeNodeSetList(xpath);\n\n  return retval;\n}\n```\n\nEvaluate the `search_path` returning an [`XML::XPath`](xpath) object.\n\nregister_namespaces(namespaces) Show source\n\n``` ruby\n# File lib/nokogiri/xml/xpath_context.rb, line 8\ndef register_namespaces(namespaces)\n  namespaces.each do |k, v|\n    k = k.to_s.gsub(/.*:/, \"\") # strip off 'xmlns:' or 'xml:'\n    register_ns(k, v)\n  end\nend\n```\n\nRegister namespaces in `namespaces`\n\nregister_ns(prefix, uri) Show source\n\n``` c\nstatic VALUE\nrb_xml_xpath_context_register_ns(VALUE self, VALUE prefix, VALUE uri)\n{\n  xmlXPathContextPtr ctx;\n  Data_Get_Struct(self, xmlXPathContext, ctx);\n\n  xmlXPathRegisterNs(ctx,\n                     (const xmlChar *)StringValueCStr(prefix),\n                     (const xmlChar *)StringValueCStr(uri)\n                    );\n  return self;\n}\n```\n\nRegister the namespace with `prefix` and `uri`.\n\nregister_variable(name, value) Show source\n\n``` c\nstatic VALUE\nrb_xml_xpath_context_register_variable(VALUE self, VALUE name, VALUE value)\n{\n  xmlXPathContextPtr ctx;\n  xmlXPathObjectPtr xmlValue;\n  Data_Get_Struct(self, xmlXPathContext, ctx);\n\n  xmlValue = xmlXPathNewCString(StringValueCStr(value));\n\n  xmlXPathRegisterVariable(ctx,\n                           (const xmlChar *)StringValueCStr(name),\n                           xmlValue\n                          );\n\n  return self;\n}\n```\n\nRegister the variable `name` with `value`.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/XPathContext.html](https://nokogiri.org/rdoc/Nokogiri/XML/XPathContext.html)"
- name: Nokogiri::XML::XPathContext#evaluate
  id: nokogiri/xml/xpathcontext#method-i-evaluate
  summary: Evaluate the search_path returning an XML::XPath object
  belongs_to: Nokogiri::XML::XPathContext
  description: |-
    evaluate(search_path, handler = nil) Show source

    ``` c
    static VALUE
    rb_xml_xpath_context_evaluate(int argc, VALUE *argv, VALUE self)
    {
      VALUE search_path, xpath_handler;
      VALUE retval = Qnil;
      xmlXPathContextPtr ctx;
      xmlXPathObjectPtr xpath;
      xmlChar *query;
      VALUE errors = rb_ary_new();

      Data_Get_Struct(self, xmlXPathContext, ctx);

      if (rb_scan_args(argc, argv, "11", &search_path, &xpath_handler) == 1) {
        xpath_handler = Qnil;
      }

      query = (xmlChar *)StringValueCStr(search_path);

      if (Qnil != xpath_handler) {
        /* FIXME: not sure if this is the correct place to shove private data. */
        ctx->userData = (void *)xpath_handler;
        xmlXPathRegisterFuncLookup(ctx, handler_lookup, (void *)xpath_handler);
      }

      xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);
      xmlSetGenericErrorFunc((void *)errors, generic_exception_pusher);

      xpath = xmlXPathEvalExpression(query, ctx);

      xmlSetStructuredErrorFunc(NULL, NULL);
      xmlSetGenericErrorFunc(NULL, NULL);

      if (xpath == NULL) {
        rb_exc_raise(rb_ary_entry(errors, 0));
      }

      retval = xpath2ruby(xpath, ctx);
      if (retval == Qundef) {
        retval = noko_xml_node_set_wrap(NULL, DOC_RUBY_OBJECT(ctx->doc));
      }

      xmlXPathFreeNodeSetList(xpath);

      return retval;
    }
    ```

    Evaluate the `search_path` returning an [`XML::XPath`](xpath) object.
- name: Nokogiri::XML::XPathContext#register_namespaces
  id: nokogiri/xml/xpathcontext#method-i-register_namespaces
  summary: null
  belongs_to: Nokogiri::XML::XPathContext
  description: |-
    register_namespaces (namespaces) Show source

    ``` ruby
    # File lib/nokogiri/xml/xpath_context.rb, line 8
    def register_namespaces(namespaces)
      namespaces.each do |k, v|
        k = k.to_s.gsub(/.*:/, "") # strip off 'xmlns:' or 'xml:'
        register_ns(k, v)
      end
    end
    ```

    Register namespaces in `namespaces`
- name: Nokogiri::XML::XPathContext#register_ns
  id: nokogiri/xml/xpathcontext#method-i-register_ns
  summary: Register the namespace with prefix and uri
  belongs_to: Nokogiri::XML::XPathContext
  description: |-
    register_ns(prefix, uri) Show source

    ``` c
    static VALUE
    rb_xml_xpath_context_register_ns(VALUE self, VALUE prefix, VALUE uri)
    {
      xmlXPathContextPtr ctx;
      Data_Get_Struct(self, xmlXPathContext, ctx);

      xmlXPathRegisterNs(ctx,
                         (const xmlChar *)StringValueCStr(prefix),
                         (const xmlChar *)StringValueCStr(uri)
                        );
      return self;
    }
    ```

    Register the namespace with `prefix` and `uri`.
- name: Nokogiri::XML::XPathContext#register_variable
  id: nokogiri/xml/xpathcontext#method-i-register_variable
  summary: Register the variable name with value
  belongs_to: Nokogiri::XML::XPathContext
  description: "register_variable(name, value) Show source\n\n``` c\nstatic VALUE\nrb_xml_xpath_context_register_variable(VALUE self, VALUE name, VALUE value)\n{\n  xmlXPathContextPtr ctx;\n  xmlXPathObjectPtr xmlValue;\n  Data_Get_Struct(self, xmlXPathContext, ctx);\n\n  xmlValue = xmlXPathNewCString(StringValueCStr(value));\n\n  xmlXPathRegisterVariable(ctx,\n                           (const xmlChar *)StringValueCStr(name),\n                           xmlValue\n                          );\n\n  return self;\n}\n```\n\nRegister the variable `name` with `value`.\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XML/XPathContext.html](https://nokogiri.org/rdoc/Nokogiri/XML/XPathContext.html)"
- name: Nokogiri::XML::XPathContext::new
  id: nokogiri/xml/xpathcontext#method-c-new
  summary: Create a new XPathContext with node as the reference point
  belongs_to: Nokogiri::XML::XPathContext
  description: |-
    new(node) Show source

    ``` c
    static VALUE
    rb_xml_xpath_context_new(VALUE klass, VALUE nodeobj)
    {
      xmlNodePtr node;
      xmlXPathContextPtr ctx;
      VALUE self;

      Noko_Node_Get_Struct(nodeobj, xmlNode, node);

    #if LIBXML_VERSION < 21000
      /* deprecated in 40483d0 */
      xmlXPathInit();
    #endif

      ctx = xmlXPathNewContext(node->doc);
      ctx->node = node;

      xmlXPathRegisterNs(ctx, NOKOGIRI_PREFIX, NOKOGIRI_URI);
      xmlXPathRegisterNs(ctx, NOKOGIRI_BUILTIN_PREFIX, NOKOGIRI_BUILTIN_URI);
      xmlXPathRegisterFuncNS(ctx, (const xmlChar *)"css-class", NOKOGIRI_BUILTIN_URI,
                             xpath_builtin_css_class);
      xmlXPathRegisterFuncNS(ctx, (const xmlChar *)"local-name-is", NOKOGIRI_BUILTIN_URI,
                             xpath_builtin_local_name_is);

      self = Data_Wrap_Struct(klass, 0, xml_xpath_context_deallocate, ctx);
      return self;
    }
    ```

    Create a new [`XPathContext`](xpathcontext) with `node` as the reference point.

    ### Public Instance Methods
- name: Nokogiri::XSLT
  id: nokogiri#method-c-XSLT
  summary: Create a Nokogiri::XSLT::Stylesheet with stylesheet
  belongs_to: Nokogiri
  description: |-
    XSLT (stylesheet, modules = {}) Show source

    ``` ruby
    # File lib/nokogiri/xslt.rb, line 13
    def XSLT(stylesheet, modules = {})
      XSLT.parse(stylesheet, modules)
    end
    ```

    Create a [`Nokogiri::XSLT::Stylesheet`](nokogiri/xslt/stylesheet) with `stylesheet`.

    Example:

    ``` ruby
    xslt = Nokogiri::XSLT(File.read(ARGV[0]))
    ```
- name: Nokogiri::XSLT
  id: nokogiri/xslt
  summary: See Nokogiri::XSLT::Stylesheet for creating and manipulating Stylesheet object
  description: "# module Nokogiri::XSLT\n\nSee [`Nokogiri::XSLT::Stylesheet`](xslt/stylesheet) for creating and manipulating [`Stylesheet`](xslt/stylesheet) object.\n\n### Public Class Methods\n\nparse(string, modules = {}) Show source\n\n``` ruby\n# File lib/nokogiri/xslt.rb, line 25\ndef parse(string, modules = {})\n  modules.each do |url, klass|\n    XSLT.register(url, klass)\n  end\n\n  doc = XML::Document.parse(string, nil, nil, XML::ParseOptions::DEFAULT_XSLT)\n  if Nokogiri.jruby?\n    Stylesheet.parse_stylesheet_doc(doc, string)\n  else\n    Stylesheet.parse_stylesheet_doc(doc)\n  end\nend\n```\n\nParse the stylesheet in `string`, register any `modules`\n\nquote_params(params) → Array Show source\n\n``` ruby\n# File lib/nokogiri/xslt.rb, line 49\ndef quote_params(params)\n  params.flatten.each_slice(2).with_object([]) do |kv, quoted_params|\n    key, value = kv.map(&:to_s)\n    value = if /'/.match?(value)\n      \"concat('#{value.gsub(/'/, %q{', \"'\", '})}')\"\n    else\n      \"'#{value}'\"\n    end\n    quoted_params << key\n    quoted_params << value\n  end\nend\n```\n\nQuote parameters in `params` for stylesheet safety. See [`Nokogiri::XSLT::Stylesheet.transform`](xslt/stylesheet#method-i-transform) for example usage.\n\nParameters\n\n- `params` (Hash, Array) [`XSLT`](xslt) parameters (key-\\>value, or tuples of \\[key, value\\])\n\nReturns  \nArray of string parameters, with quotes correctly escaped for use with [`XSLT::Stylesheet.transform`](xslt/stylesheet#method-i-transform)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XSLT.html](https://nokogiri.org/rdoc/Nokogiri/XSLT.html)"
- name: Nokogiri::XSLT::parse
  id: nokogiri/xslt#method-c-parse
  summary: null
  belongs_to: Nokogiri::XSLT
  description: |-
    parse (string, modules = {}) Show source

    ``` ruby
    # File lib/nokogiri/xslt.rb, line 25
    def parse(string, modules = {})
      modules.each do |url, klass|
        XSLT.register(url, klass)
      end

      doc = XML::Document.parse(string, nil, nil, XML::ParseOptions::DEFAULT_XSLT)
      if Nokogiri.jruby?
        Stylesheet.parse_stylesheet_doc(doc, string)
      else
        Stylesheet.parse_stylesheet_doc(doc)
      end
    end
    ```

    Parse the stylesheet in `string`, register any `modules`
- name: Nokogiri::XSLT::quote_params
  id: nokogiri/xslt#method-c-quote_params
  summary: Quote parameters in params for stylesheet safety
  belongs_to: Nokogiri::XSLT
  description: "quote_params(params) → Array Show source\n\n``` ruby\n# File lib/nokogiri/xslt.rb, line 49\ndef quote_params(params)\n  params.flatten.each_slice(2).with_object([]) do |kv, quoted_params|\n    key, value = kv.map(&:to_s)\n    value = if /'/.match?(value)\n      \"concat('#{value.gsub(/'/, %q{', \"'\", '})}')\"\n    else\n      \"'#{value}'\"\n    end\n    quoted_params << key\n    quoted_params << value\n  end\nend\n```\n\nQuote parameters in `params` for stylesheet safety. See [`Nokogiri::XSLT::Stylesheet.transform`](xslt/stylesheet#method-i-transform) for example usage.\n\nParameters\n\n- `params` (Hash, Array) [`XSLT`](xslt) parameters (key-\\>value, or tuples of \\[key, value\\])\n\nReturns\n\nArray of string parameters, with quotes correctly escaped for use with [`XSLT::Stylesheet.transform`](xslt/stylesheet#method-i-transform)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XSLT.html](https://nokogiri.org/rdoc/Nokogiri/XSLT.html)"
- name: Nokogiri::XSLT::Stylesheet
  id: nokogiri/xslt/stylesheet
  summary: A Stylesheet represents an XSLT Stylesheet object
  description: "# class Nokogiri::XSLT::Stylesheet\n\nParent:  \n[Object](https://nokogiri.org/rdoc/Object.html)\n\nA [`Stylesheet`](stylesheet) represents an [`XSLT`](../xslt) [`Stylesheet`](stylesheet) object. [`Stylesheet`](stylesheet) creation is done through [`Nokogiri.XSLT`](../../nokogiri#method-c-XSLT). Here is an example of transforming an [`XML::Document`](../xml/document) with a Stylesheet:\n\n``` ruby\ndoc   = Nokogiri::XML(File.read('some_file.xml'))\nxslt  = Nokogiri::XSLT(File.read('some_transformer.xslt'))\n\nputs xslt.transform(doc)\n```\n\nSee [`Nokogiri::XSLT::Stylesheet#transform`](stylesheet#method-i-transform) for more transformation information.\n\n### Public Class Methods\n\nparse_stylesheet_doc(document) Show source\n\n``` c\nstatic VALUE\nparse_stylesheet_doc(VALUE klass, VALUE xmldocobj)\n{\n  xmlDocPtr xml, xml_cpy;\n  VALUE errstr, exception;\n  xsltStylesheetPtr ss ;\n  Data_Get_Struct(xmldocobj, xmlDoc, xml);\n\n  errstr = rb_str_new(0, 0);\n  xsltSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);\n\n  xml_cpy = xmlCopyDoc(xml, 1); /* 1 => recursive */\n  ss = xsltParseStylesheetDoc(xml_cpy);\n\n  xsltSetGenericErrorFunc(NULL, NULL);\n\n  if (!ss) {\n    xmlFreeDoc(xml_cpy);\n    exception = rb_exc_new3(rb_eRuntimeError, errstr);\n    rb_exc_raise(exception);\n  }\n\n  return Nokogiri_wrap_xslt_stylesheet(ss);\n}\n```\n\nParse a stylesheet from `document`.\n\n### Public Instance Methods\n\napply_to(document, params = \\[\\]) Show source\n\n``` ruby\n# File lib/nokogiri/xslt/stylesheet.rb, line 22\ndef apply_to(document, params = [])\n  serialize(transform(document, params))\nend\n```\n\nApply an [`XSLT`](../xslt) stylesheet to an [`XML::Document`](../xml/document). `params` is an array of strings used as [`XSLT`](../xslt) parameters. returns serialized document\n\nserialize(document) Show source\n\n``` c\nstatic VALUE\nserialize(VALUE self, VALUE xmlobj)\n{\n  xmlDocPtr xml ;\n  nokogiriXsltStylesheetTuple *wrapper;\n  xmlChar *doc_ptr ;\n  int doc_len ;\n  VALUE rval ;\n\n  Data_Get_Struct(xmlobj, xmlDoc, xml);\n  Data_Get_Struct(self, nokogiriXsltStylesheetTuple, wrapper);\n  xsltSaveResultToString(&doc_ptr, &doc_len, xml, wrapper->ss);\n  rval = NOKOGIRI_STR_NEW(doc_ptr, doc_len);\n  xmlFree(doc_ptr);\n  return rval ;\n}\n```\n\nSerialize `document` to an xml string.\n\ntransform(document) Show source\n\ntransform(document, params = {})\n\n``` c\nstatic VALUE\ntransform(int argc, VALUE *argv, VALUE self)\n{\n  VALUE xmldoc, paramobj, errstr, exception ;\n  xmlDocPtr xml ;\n  xmlDocPtr result ;\n  nokogiriXsltStylesheetTuple *wrapper;\n  const char **params ;\n  long param_len, j ;\n  int parse_error_occurred ;\n\n  rb_scan_args(argc, argv, \"11\", &xmldoc, &paramobj);\n  if (NIL_P(paramobj)) { paramobj = rb_ary_new2(0L) ; }\n  if (!rb_obj_is_kind_of(xmldoc, cNokogiriXmlDocument)) {\n    rb_raise(rb_eArgError, \"argument must be a Nokogiri::XML::Document\");\n  }\n\n  /* handle hashes as arguments. */\n  if (T_HASH == TYPE(paramobj)) {\n    paramobj = rb_funcall(paramobj, rb_intern(\"to_a\"), 0);\n    paramobj = rb_funcall(paramobj, rb_intern(\"flatten\"), 0);\n  }\n\n  Check_Type(paramobj, T_ARRAY);\n\n  Data_Get_Struct(xmldoc, xmlDoc, xml);\n  Data_Get_Struct(self, nokogiriXsltStylesheetTuple, wrapper);\n\n  param_len = RARRAY_LEN(paramobj);\n  params = ruby_xcalloc((size_t)param_len + 1, sizeof(char *));\n  for (j = 0 ; j < param_len ; j++) {\n    VALUE entry = rb_ary_entry(paramobj, j);\n    const char *ptr = StringValueCStr(entry);\n    params[j] = ptr;\n  }\n  params[param_len] = 0 ;\n\n  errstr = rb_str_new(0, 0);\n  xsltSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);\n  xmlSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);\n\n  result = xsltApplyStylesheet(wrapper->ss, xml, params);\n  ruby_xfree(params);\n\n  xsltSetGenericErrorFunc(NULL, NULL);\n  xmlSetGenericErrorFunc(NULL, NULL);\n\n  parse_error_occurred = (Qfalse == rb_funcall(errstr, rb_intern(\"empty?\"), 0));\n\n  if (parse_error_occurred) {\n    exception = rb_exc_new3(rb_eRuntimeError, errstr);\n    rb_exc_raise(exception);\n  }\n\n  return noko_xml_document_wrap((VALUE)0, result) ;\n}\n```\n\nApply an [`XSLT`](../xslt) stylesheet to an [`XML::Document`](../xml/document).\n\nParameters\n\n- `document` ([`Nokogiri::XML::Document`](../xml/document)) the document to be transformed.\n\n- `params` (Hash, Array) strings used as [`XSLT`](../xslt) parameters.\n\nReturns  \n[`Nokogiri::XML::Document`](../xml/document)\n\n**Example** of basic transformation:\n\n``` ruby\nxslt = <<~XSLT\n  <xsl:stylesheet version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n  <xsl:param name=\"title\"/>\n\n  <xsl:template match=\"/\">\n    <html>\n      <body>\n        <h1><xsl:value-of select=\"$title\"/></h1>\n        <ol>\n          <xsl:for-each select=\"staff/employee\">\n            <li><xsl:value-of select=\"employeeId\"></li>\n          </xsl:for-each>\n        </ol>\n      </body>\n    </html>\n  </xsl:stylesheet>\nXSLT\n\nxml = <<~XML\n  <?xml version=\"1.0\"?>\n  <staff>\n    <employee>\n      <employeeId>EMP0001</employeeId>\n      <position>Accountant</position>\n    </employee>\n    <employee>\n      <employeeId>EMP0002</employeeId>\n      <position>Developer</position>\n    </employee>\n  </staff>\nXML\n\ndoc = Nokogiri::XML::Document.parse(xml)\nstylesheet = Nokogiri::XSLT.parse(xslt)\n```\n\n⚠ Note that the `h1` element is empty because no param has been provided!\n\n``` ruby\nstylesheet.transform(doc).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1></h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\n**Example** of using an input parameter hash:\n\n⚠ The title is populated, but note how we need to quote-escape the value.\n\n``` ruby\nstylesheet.transform(doc, { \"title\" => \"'Employee List'\" }).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Employee List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\n**Example** using the [`XSLT.quote_params`](../xslt#method-c-quote_params) helper method to safely quote-escape strings:\n\n``` ruby\nstylesheet.transform(doc, Nokogiri::XSLT.quote_params({ \"title\" => \"Aaron's List\" })).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Aaron's List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\n**Example** using an array of [`XSLT`](../xslt) parameters\n\nYou can also use an array if you want to.\n\n``` ruby\nstylesheet.transform(doc, [\"title\", \"'Employee List'\"]).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Employee List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\nOr pass an array to [`XSLT.quote_params`](../xslt#method-c-quote_params):\n\n``` ruby\nstylesheet.transform(doc, Nokogiri::XSLT.quote_params([\"title\", \"Aaron's List\"])).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Aaron's List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\nSee: [`Nokogiri::XSLT.quote_params`](../xslt#method-c-quote_params)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XSLT/Stylesheet.html](https://nokogiri.org/rdoc/Nokogiri/XSLT/Stylesheet.html)"
- name: Nokogiri::XSLT::Stylesheet#apply_to
  id: nokogiri/xslt/stylesheet#method-i-apply_to
  summary: Apply an XSLT stylesheet to an XML::Document
  belongs_to: Nokogiri::XSLT::Stylesheet
  description: |-
    apply_to (document, params = \[\]) Show source

    ``` ruby
    # File lib/nokogiri/xslt/stylesheet.rb, line 22
    def apply_to(document, params = [])
      serialize(transform(document, params))
    end
    ```

    Apply an [`XSLT`](../xslt) stylesheet to an [`XML::Document`](../xml/document). `params` is an array of strings used as [`XSLT`](../xslt) parameters. returns serialized document
- name: Nokogiri::XSLT::Stylesheet#serialize
  id: nokogiri/xslt/stylesheet#method-i-serialize
  summary: Serialize document to an xml string
  belongs_to: Nokogiri::XSLT::Stylesheet
  description: |-
    serialize(document) Show source

    ``` c
    static VALUE
    serialize(VALUE self, VALUE xmlobj)
    {
      xmlDocPtr xml ;
      nokogiriXsltStylesheetTuple *wrapper;
      xmlChar *doc_ptr ;
      int doc_len ;
      VALUE rval ;

      Data_Get_Struct(xmlobj, xmlDoc, xml);
      Data_Get_Struct(self, nokogiriXsltStylesheetTuple, wrapper);
      xsltSaveResultToString(&doc_ptr, &doc_len, xml, wrapper->ss);
      rval = NOKOGIRI_STR_NEW(doc_ptr, doc_len);
      xmlFree(doc_ptr);
      return rval ;
    }
    ```

    Serialize `document` to an xml string.
- name: Nokogiri::XSLT::Stylesheet#transform
  id: nokogiri/xslt/stylesheet#method-i-transform
  summary: Apply an XSLT stylesheet to an XML::Document
  belongs_to: Nokogiri::XSLT::Stylesheet
  description: "transform(document) Show source\n\ntransform(document, params = {})\n\n``` c\nstatic VALUE\ntransform(int argc, VALUE *argv, VALUE self)\n{\n  VALUE xmldoc, paramobj, errstr, exception ;\n  xmlDocPtr xml ;\n  xmlDocPtr result ;\n  nokogiriXsltStylesheetTuple *wrapper;\n  const char **params ;\n  long param_len, j ;\n  int parse_error_occurred ;\n\n  rb_scan_args(argc, argv, \"11\", &xmldoc, &paramobj);\n  if (NIL_P(paramobj)) { paramobj = rb_ary_new2(0L) ; }\n  if (!rb_obj_is_kind_of(xmldoc, cNokogiriXmlDocument)) {\n    rb_raise(rb_eArgError, \"argument must be a Nokogiri::XML::Document\");\n  }\n\n  /* handle hashes as arguments. */\n  if (T_HASH == TYPE(paramobj)) {\n    paramobj = rb_funcall(paramobj, rb_intern(\"to_a\"), 0);\n    paramobj = rb_funcall(paramobj, rb_intern(\"flatten\"), 0);\n  }\n\n  Check_Type(paramobj, T_ARRAY);\n\n  Data_Get_Struct(xmldoc, xmlDoc, xml);\n  Data_Get_Struct(self, nokogiriXsltStylesheetTuple, wrapper);\n\n  param_len = RARRAY_LEN(paramobj);\n  params = ruby_xcalloc((size_t)param_len + 1, sizeof(char *));\n  for (j = 0 ; j < param_len ; j++) {\n    VALUE entry = rb_ary_entry(paramobj, j);\n    const char *ptr = StringValueCStr(entry);\n    params[j] = ptr;\n  }\n  params[param_len] = 0 ;\n\n  errstr = rb_str_new(0, 0);\n  xsltSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);\n  xmlSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);\n\n  result = xsltApplyStylesheet(wrapper->ss, xml, params);\n  ruby_xfree(params);\n\n  xsltSetGenericErrorFunc(NULL, NULL);\n  xmlSetGenericErrorFunc(NULL, NULL);\n\n  parse_error_occurred = (Qfalse == rb_funcall(errstr, rb_intern(\"empty?\"), 0));\n\n  if (parse_error_occurred) {\n    exception = rb_exc_new3(rb_eRuntimeError, errstr);\n    rb_exc_raise(exception);\n  }\n\n  return noko_xml_document_wrap((VALUE)0, result) ;\n}\n```\n\nApply an [`XSLT`](../xslt) stylesheet to an [`XML::Document`](../xml/document).\n\nParameters\n\n- `document` ([`Nokogiri::XML::Document`](../xml/document)) the document to be transformed.\n\n- `params` (Hash, Array) strings used as [`XSLT`](../xslt) parameters.\n\nReturns\n\n[`Nokogiri::XML::Document`](../xml/document)\n\n**Example** of basic transformation:\n\n``` ruby\nxslt = <<~XSLT\n  <xsl:stylesheet version=\"1.0\"\n  xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n  <xsl:param name=\"title\"/>\n\n  <xsl:template match=\"/\">\n    <html>\n      <body>\n        <h1><xsl:value-of select=\"$title\"/></h1>\n        <ol>\n          <xsl:for-each select=\"staff/employee\">\n            <li><xsl:value-of select=\"employeeId\"></li>\n          </xsl:for-each>\n        </ol>\n      </body>\n    </html>\n  </xsl:stylesheet>\nXSLT\n\nxml = <<~XML\n  <?xml version=\"1.0\"?>\n  <staff>\n    <employee>\n      <employeeId>EMP0001</employeeId>\n      <position>Accountant</position>\n    </employee>\n    <employee>\n      <employeeId>EMP0002</employeeId>\n      <position>Developer</position>\n    </employee>\n  </staff>\nXML\n\ndoc = Nokogiri::XML::Document.parse(xml)\nstylesheet = Nokogiri::XSLT.parse(xslt)\n```\n\n⚠ Note that the `h1` element is empty because no param has been provided!\n\n``` ruby\nstylesheet.transform(doc).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1></h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\n**Example** of using an input parameter hash:\n\n⚠ The title is populated, but note how we need to quote-escape the value.\n\n``` ruby\nstylesheet.transform(doc, { \"title\" => \"'Employee List'\" }).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Employee List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\n**Example** using the [`XSLT.quote_params`](../xslt#method-c-quote_params) helper method to safely quote-escape strings:\n\n``` ruby\nstylesheet.transform(doc, Nokogiri::XSLT.quote_params({ \"title\" => \"Aaron's List\" })).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Aaron's List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\n**Example** using an array of [`XSLT`](../xslt) parameters\n\nYou can also use an array if you want to.\n\n``` ruby\nstylesheet.transform(doc, [\"title\", \"'Employee List'\"]).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Employee List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\nOr pass an array to [`XSLT.quote_params`](../xslt#method-c-quote_params):\n\n``` ruby\nstylesheet.transform(doc, Nokogiri::XSLT.quote_params([\"title\", \"Aaron's List\"])).to_xml\n# => \"<html><body>\\n\" +\n#    \"<h1>Aaron's List</h1>\\n\" +\n#    \"<ol>\\n\" +\n#    \"<li>EMP0001</li>\\n\" +\n#    \"<li>EMP0002</li>\\n\" +\n#    \"</ol>\\n\" +\n#    \"</body></html>\\n\"\n```\n\nSee: [`Nokogiri::XSLT.quote_params`](../xslt#method-c-quote_params)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/Nokogiri/XSLT/Stylesheet.html](https://nokogiri.org/rdoc/Nokogiri/XSLT/Stylesheet.html)"
- name: Nokogiri::XSLT::Stylesheet::parse_stylesheet_doc
  id: nokogiri/xslt/stylesheet#method-c-parse_stylesheet_doc
  summary: Parse a stylesheet from document
  belongs_to: Nokogiri::XSLT::Stylesheet
  description: |-
    parse_stylesheet_doc(document) Show source

    ``` c
    static VALUE
    parse_stylesheet_doc(VALUE klass, VALUE xmldocobj)
    {
      xmlDocPtr xml, xml_cpy;
      VALUE errstr, exception;
      xsltStylesheetPtr ss ;
      Data_Get_Struct(xmldocobj, xmlDoc, xml);

      errstr = rb_str_new(0, 0);
      xsltSetGenericErrorFunc((void *)errstr, xslt_generic_error_handler);

      xml_cpy = xmlCopyDoc(xml, 1); /* 1 => recursive */
      ss = xsltParseStylesheetDoc(xml_cpy);

      xsltSetGenericErrorFunc(NULL, NULL);

      if (!ss) {
        xmlFreeDoc(xml_cpy);
        exception = rb_exc_new3(rb_eRuntimeError, errstr);
        rb_exc_raise(exception);
      }

      return Nokogiri_wrap_xslt_stylesheet(ss);
    }
    ```

    Parse a stylesheet from `document`.

    ### Public Instance Methods
- name: XSD
  id: xsd
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# module XSD\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/XSD.html](https://nokogiri.org/rdoc/XSD.html)"
- name: XSD::XMLParser
  id: xsd/xmlparser
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  description: "# module XSD::XMLParser\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/XSD/XMLParser.html](https://nokogiri.org/rdoc/XSD/XMLParser.html)"
- name: XSD::XMLParser::Nokogiri
  id: xsd/xmlparser/nokogiri
  summary: Nokogiri XML parser for soap4r
  description: "# class XSD::XMLParser::Nokogiri\n\nParent:  \nXSD::XMLParser::Parser\n\n[`Nokogiri`](nokogiri) XML parser for soap4r.\n\n[`Nokogiri`](nokogiri) may be used as the XML parser in soap4r. Simply require ‘xsd/xmlparser/nokogiri’ in your soap4r applications, and soap4r will use [`Nokogiri`](nokogiri) as it’s XML parser. No other changes should be required to use [`Nokogiri`](nokogiri) as the XML parser.\n\nExample (using UW ITS Web Services):\n\n``` ruby\nrequire 'rubygems'\nrequire 'nokogiri'\ngem 'soap4r'\nrequire 'defaultDriver'\nrequire 'xsd/xmlparser/nokogiri'\n\nobj = AvlPortType.new\nobj.getLatestByRoute(obj.getAgencies.first, 8).each do |bus|\n  p \"#{bus.routeID}, #{bus.longitude}, #{bus.latitude}\"\nend\n```\n\n### Public Class Methods\n\nnew(host, opt = {}) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 31\ndef initialize(host, opt = {})\n  super\n  @parser = ::Nokogiri::XML::SAX::Parser.new(self, @charset || \"UTF-8\")\nend\n```\n\nCreate a new [`XSD`](../../xsd) parser with `host` and `opt`\n\nCalls superclass method\n\n### Public Instance Methods\n\ncdata_block(string) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 63\ndef cdata_block(string)\n  characters(string)\nend\n```\n\nHandle cdata_blocks containing `string`\n\ndo_parse(string_or_readable) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 38\ndef do_parse(string_or_readable)\n  @parser.parse(string_or_readable)\nend\n```\n\nStart parsing `string_or_readable`\n\nend_element(name) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 50\ndef end_element(name)\n  super\nend\n```\n\nHandle the [`end_element`](nokogiri#method-i-end_element) event with `name`\n\nCalls superclass method\n\nend_element_namespace(name, prefix = nil, uri = nil) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 91\ndef end_element_namespace(name, prefix = nil, uri = nil)\n  ###\n  # Deal with SAX v1 interface\n  end_element([prefix, name].compact.join(\":\"))\nend\n```\n\nCalled at the end of an element `name` is the element’s name `prefix` is the namespace prefix associated with the element `uri` is the associated namespace URI\n\nerror(msg) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 56\ndef error(msg)\n  raise ParseError, msg\nend\n```\n\nHandle errors with message `msg`\n\nAlso aliased as: [warning](nokogiri#method-i-warning)\n\nstart_element(name, attrs = \\[\\]) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 44\ndef start_element(name, attrs = [])\n  super(name, Hash[*attrs.flatten])\nend\n```\n\nHandle the [`start_element`](nokogiri#method-i-start_element) event with `name` and `attrs`\n\nCalls superclass method\n\nstart_element_namespace(name, attrs = \\[\\], prefix = nil, uri = nil, ns = \\[\\]) Show source\n\n``` ruby\n# File lib/xsd/xmlparser/nokogiri.rb, line 74\ndef start_element_namespace(name, attrs = [], prefix = nil, uri = nil, ns = [])\n  ###\n  # Deal with SAX v1 interface\n  name = [prefix, name].compact.join(\":\")\n  attributes = ns.map do |ns_prefix, ns_uri|\n    [[\"xmlns\", ns_prefix].compact.join(\":\"), ns_uri]\n  end + attrs.map do |attr|\n    [[attr.prefix, attr.localname].compact.join(\":\"), attr.value]\n  end.flatten\n  start_element(name, attributes)\nend\n```\n\nCalled at the beginning of an element `name` is the element name `attrs` is a list of attributes `prefix` is the namespace prefix for the element `uri` is the associated namespace URI `ns` is a hash of namespace prefix:urls associated with the element\n\nwarning(msg)\n\nAlias for: [error](nokogiri#method-i-error)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/XSD/XMLParser/Nokogiri.html](https://nokogiri.org/rdoc/XSD/XMLParser/Nokogiri.html)"
- name: XSD::XMLParser::Nokogiri#cdata_block
  id: xsd/xmlparser/nokogiri#method-i-cdata_block
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    cdata_block (string) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 63
    def cdata_block(string)
      characters(string)
    end
    ```

    Handle cdata_blocks containing `string`
- name: XSD::XMLParser::Nokogiri#do_parse
  id: xsd/xmlparser/nokogiri#method-i-do_parse
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    do_parse (string_or_readable) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 38
    def do_parse(string_or_readable)
      @parser.parse(string_or_readable)
    end
    ```

    Start parsing `string_or_readable`
- name: XSD::XMLParser::Nokogiri#end_element
  id: xsd/xmlparser/nokogiri#method-i-end_element
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    end_element (name) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 50
    def end_element(name)
      super
    end
    ```

    Handle the [`end_element`](nokogiri#method-i-end_element) event with `name`

    Calls superclass method
- name: XSD::XMLParser::Nokogiri#end_element_namespace
  id: xsd/xmlparser/nokogiri#method-i-end_element_namespace
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    end_element_namespace (name, prefix = nil, uri = nil) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 91
    def end_element_namespace(name, prefix = nil, uri = nil)
      ###
      # Deal with SAX v1 interface
      end_element([prefix, name].compact.join(":"))
    end
    ```

    Called at the end of an element `name` is the element’s name `prefix` is the namespace prefix associated with the element `uri` is the associated namespace URI
- name: XSD::XMLParser::Nokogiri#error
  id: xsd/xmlparser/nokogiri#method-i-error
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    error (msg) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 56
    def error(msg)
      raise ParseError, msg
    end
    ```

    Handle errors with message `msg`

    Also aliased as: [warning](nokogiri#method-i-warning)
- name: XSD::XMLParser::Nokogiri#start_element
  id: xsd/xmlparser/nokogiri#method-i-start_element
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    start_element (name, attrs = \[\]) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 44
    def start_element(name, attrs = [])
      super(name, Hash[*attrs.flatten])
    end
    ```

    Handle the [`start_element`](nokogiri#method-i-start_element) event with `name` and `attrs`

    Calls superclass method
- name: XSD::XMLParser::Nokogiri#start_element_namespace
  id: xsd/xmlparser/nokogiri#method-i-start_element_namespace
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    start_element_namespace (name, attrs = \[\], prefix = nil, uri = nil, ns = \[\]) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 74
    def start_element_namespace(name, attrs = [], prefix = nil, uri = nil, ns = [])
      ###
      # Deal with SAX v1 interface
      name = [prefix, name].compact.join(":")
      attributes = ns.map do |ns_prefix, ns_uri|
        [["xmlns", ns_prefix].compact.join(":"), ns_uri]
      end + attrs.map do |attr|
        [[attr.prefix, attr.localname].compact.join(":"), attr.value]
      end.flatten
      start_element(name, attributes)
    end
    ```

    Called at the beginning of an element `name` is the element name `attrs` is a list of attributes `prefix` is the namespace prefix for the element `uri` is the associated namespace URI `ns` is a hash of namespace prefix:urls associated with the element
- name: XSD::XMLParser::Nokogiri#warning
  id: xsd/xmlparser/nokogiri#method-i-warning
  summary: © 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid, Karol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo, Timothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License
  belongs_to: XSD::XMLParser::Nokogiri
  description: "warning (msg)\n\nAlias for: [error](nokogiri#method-i-error)\n\n© 2008–2023 by Mike Dalessio, Aaron Patterson, Yoko Harada, Akinori MUSHA, John Shahid,  \nKarol Bucek, Sam Ruby, Craig Barnes, Stephen Checkoway, Lars Kanis, Sergio Arbeo,  \nTimothy Elliott, Nobuyoshi Nakada, Charles Nutter, Patrick MahoneyLicensed under the MIT License.  \n[https://nokogiri.org/rdoc/XSD/XMLParser/Nokogiri.html](https://nokogiri.org/rdoc/XSD/XMLParser/Nokogiri.html)"
- name: XSD::XMLParser::Nokogiri::new
  id: xsd/xmlparser/nokogiri#method-c-new
  summary: null
  belongs_to: XSD::XMLParser::Nokogiri
  description: |-
    new (host, opt = {}) Show source

    ``` ruby
    # File lib/xsd/xmlparser/nokogiri.rb, line 31
    def initialize(host, opt = {})
      super
      @parser = ::Nokogiri::XML::SAX::Parser.new(self, @charset || "UTF-8")
    end
    ```

    Create a new [`XSD`](../../xsd) parser with `host` and `opt`

    Calls superclass method

    ### Public Instance Methods
