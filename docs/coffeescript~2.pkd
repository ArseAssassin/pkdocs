---
name: CoffeeScript
slug: coffeescript~2
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: '2'
copyright: |-
  © 2009–2022 Jeremy Ashkenas
  Licensed under the MIT License.
  https://coffeescript.org/
homepage: https://coffeescript.org

---
- name: '"text/coffeescript" Script Tags'
  id: index#scripts
  summary: While it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using <script type="text/coffeescript"> tags
  description: |-
    ## `"text/coffeescript"` Script Tags

    While it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type="text/coffeescript">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.

    The usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.
- name: '%%'
  id: index#mod
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: '**'
  id: index#pow
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: //
  id: index#floor
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: '@'
  id: index#this
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: and
  id: index#and
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Breaking Changes From 1.x
  id: index#breaking-changes
  summary: CoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible
  description: "## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Cake, and Cakefiles
  id: index#cake
  summary: CoffeeScript includes a (very) simple build system similar to Make and Rake
  description: |-
    ## Cake, and Cakefiles

    CoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.

    Task definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:

    ``` coffeescript
    fs = require 'fs'

    option '-o', '--output [DIR]', 'directory for compiled code'

    task 'build:parser', 'rebuild the Jison parser', (options) ->
      require 'jison'
      code = require('./lib/grammar').parser.generate()
      dir  = options.output or 'lib'
      fs.writeFile "#{dir}/parser.js", code
    ```

    ``` javascript
    var fs;

    fs = require('fs');

    option('-o', '--output [DIR]', 'directory for compiled code');

    task('build:parser', 'rebuild the Jison parser', function(options) {
      var code, dir;
      require('jison');
      code = require('./lib/grammar').parser.generate();
      dir = options.output || 'lib';
      return fs.writeFile(`${dir}/parser.js`, code);
    });
    ```

    If you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.
- name: Chained Comparisons
  id: index#comparisons
  summary: CoffeeScript borrows chained comparisons from Python — making it easy to test if a value falls within a certain range
  description: |-
    ## Chained Comparisons

    CoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.

    ``` coffeescript
    cholesterol = 127

    healthy = 200 > cholesterol > 60
    ```

    ``` javascript
    var cholesterol, healthy;

    cholesterol = 127;

    healthy = (200 > cholesterol && cholesterol > 60);
    ```
- name: Chaining Function Calls
  id: index#chaining
  summary: Leading . closes all open calls, allowing for simpler chaining syntax
  description: |-
    ## Chaining Function Calls

    Leading `.` closes all open calls, allowing for simpler chaining syntax.

    ``` coffeescript
    $ 'body'
    .click (e) ->
      $ '.box'
      .fadeIn 'fast'
      .addClass 'show'
    .css 'background', 'white'
    ```

    ``` javascript
    $('body').click(function(e) {
      return $('.box').fadeIn('fast').addClass('show');
    }).css('background', 'white');
    ```
- name: coffee command
  id: index#cli
  summary: Once installed, you should have access to the coffee command, which can execute scripts, compile .coffee files into .js, and provide an interactive REPL
  description: "### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/)."
- name: CoffeeScript 2
  id: index#coffeescript-2
  summary: The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later)
  description: |-
    ## CoffeeScript 2

    ### What’s New In CoffeeScript 2?

    The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).

    There are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.

    ### Compatibility

    Most modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:

    - [JSX](#jsx) always requires transpilation.
    - [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.
    - The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.
    - [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.
    - [Modules](#modules) are supported by Node 12+ with `"type": "module"` in your project’s `package.json`.

    This list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.

    For compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).
- name: Destructuring Assignment
  id: index#destructuring
  summary: Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax
  description: |-
    ## Destructuring Assignment

    Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:

    ``` coffeescript
    theBait   = 1000
    theSwitch = 0

    [theBait, theSwitch] = [theSwitch, theBait]
    ```

    ``` javascript
    var theBait, theSwitch;

    theBait = 1000;

    theSwitch = 0;

    [theBait, theSwitch] = [theSwitch, theBait];
    ```

    But it’s also helpful for dealing with functions that return multiple values.

    ``` coffeescript
    weatherReport = (location) ->
      # Make an Ajax request to fetch the weather...
      [location, 72, "Mostly Sunny"]

    [city, temp, forecast] = weatherReport "Berkeley, CA"
    ```

    ``` javascript
    var city, forecast, temp, weatherReport;

    weatherReport = function(location) {
      // Make an Ajax request to fetch the weather...
      return [location, 72, "Mostly Sunny"];
    };

    [city, temp, forecast] = weatherReport("Berkeley, CA");
    ```

    Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.

    ``` coffeescript
    futurists =
      sculptor: "Umberto Boccioni"
      painter:  "Vladimir Burliuk"
      poet:
        name:   "F.T. Marinetti"
        address: [
          "Via Roma 42R"
          "Bellagio, Italy 22021"
        ]

    {sculptor} = futurists

    {poet: {name, address: [street, city]}} = futurists
    ```

    ``` javascript
    var city, futurists, name, sculptor, street;

    futurists = {
      sculptor: "Umberto Boccioni",
      painter: "Vladimir Burliuk",
      poet: {
        name: "F.T. Marinetti",
        address: ["Via Roma 42R", "Bellagio, Italy 22021"]
      }
    };

    ({sculptor} = futurists);

    ({
      poet: {
        name,
        address: [street, city]
      }
    } = futurists);
    ```

    Destructuring assignment can even be combined with splats.

    ``` coffeescript
    tag = "<impossible>"

    [open, contents..., close] = tag.split("")
    ```

    ``` javascript
    var close, contents, open, ref, tag,
      splice = [].splice;

    tag = "<impossible>";

    ref = tag.split(""), [open, ...contents] = ref, [close] = splice.call(contents, -1);
    ```

    Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.

    ``` coffeescript
    text = "Every literary critic believes he will
            outwit history and have the last word"

    [first, ..., last] = text.split " "
    ```

    ``` javascript
    var first, last, ref, text,
      slice = [].slice;

    text = "Every literary critic believes he will outwit history and have the last word";

    ref = text.split(" "), [first] = ref, [last] = slice.call(ref, -1);
    ```

    Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.

    ``` coffeescript
    class Person
      constructor: (options) ->
        {@name, @age, @height = 'average'} = options

    tim = new Person name: 'Tim', age: 4
    ```

    ``` javascript
    var Person, tim;

    Person = class Person {
      constructor(options) {
        ({name: this.name, age: this.age, height: this.height = 'average'} = options);
      }

    };

    tim = new Person({
      name: 'Tim',
      age: 4
    });
    ```

    The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.
- name: Embedded JavaScript
  id: index#embedded
  summary: Hopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through
  description: |-
    ## Embedded JavaScript

    Hopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.

    ``` coffeescript
    hi = `function() {
      return [document.title, "Hello JavaScript"].join(": ");
    }`
    ```

    ``` javascript
    var hi;

    hi = function() {
      return [document.title, "Hello JavaScript"].join(": ");
    };
    ```

    Escape backticks with backslashes: ``  \`​ `` becomes ``  `​ ``.

    Escape backslashes before backticks with more backslashes: ``  \\\`​ `` becomes ``  \`​ ``.

    ``` coffeescript
    markdown = `function () {
      return \`In Markdown, write code like \\\`this\\\`\`;
    }`
    ```

    ``` javascript
    var markdown;

    markdown = function () {
      return `In Markdown, write code like \`this\``;
    };
    ```

    You can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.

    ```` coffeescript
    ```
    function time() {
      return `The time is ${new Date().toLocaleTimeString()}`;
    }
    ```
    ````

    ``` javascript
    function time() {
      return `The time is ${new Date().toLocaleTimeString()}`;
    }
    ;
    ```
- name: Everything is an Expression
  id: index#expressions
  summary: You might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value
  description: |-
    ## Everything is an Expression (at least, as much as possible)

    You might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.

    ``` coffeescript
    grade = (student) ->
      if student.excellentWork
        "A+"
      else if student.okayStuff
        if student.triedHard then "B" else "B-"
      else
        "C"

    eldest = if 24 > 21 then "Liz" else "Ike"
    ```

    ``` javascript
    var eldest, grade;

    grade = function(student) {
      if (student.excellentWork) {
        return "A+";
      } else if (student.okayStuff) {
        if (student.triedHard) {
          return "B";
        } else {
          return "B-";
        }
      } else {
        return "C";
      }
    };

    eldest = 24 > 21 ? "Liz" : "Ike";
    ```

    Even though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.

    Because variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:

    ``` coffeescript
    six = (one = 1) + (two = 2) + (three = 3)
    ```

    ``` javascript
    var one, six, three, two;

    six = (one = 1) + (two = 2) + (three = 3);
    ```

    Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:

    ``` coffeescript
    # The first ten global properties.

    globals = (name for name of window)[0...10]
    ```

    ``` javascript
    // The first ten global properties.
    var globals, name;

    globals = ((function() {
      var results;
      results = [];
      for (name in window) {
        results.push(name);
      }
      return results;
    })()).slice(0, 10);
    ```

    As well as silly things, like passing a `try`/`catch` statement directly into a function call:

    ``` coffeescript
    alert(
      try
        nonexistent / undefined
      catch error
        "And the error is ... #{error}"
    )
    ```

    ``` javascript
    var error;

    alert((function() {
      try {
        return nonexistent / void 0;
      } catch (error1) {
        error = error1;
        return `And the error is ... ${error}`;
      }
    })());
    ```

    There are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.
- name: for...from
  id: index#for-from
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: in
  id: index#in
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Installation
  id: index#installation
  summary: The command-line version of coffee is available as a Node.js utility, requiring Node 6 or later
  description: |-
    ## Installation

    The command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).

    To install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):

        npm install --global coffeescript

    This will make the `coffee` and `cake` commands available globally.

    If you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:

        npm install --save-dev coffeescript

    The `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.

    If you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.
- name: Integrations
  id: index#integrations
  summary: CoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript
  description: |-
    ## Integrations

    CoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.

    ### Build Tools

    - [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)

    - [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)

    - [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)

    - [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)

    - [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)

    - [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)

    ### Code Editors

    - [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)

    - [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)

    - [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)

    ### Frameworks

    - [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)

    - [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)

    ### Linters and Formatting

    - [CoffeeLint](https://coffeelint.github.io/)

    - [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)

    - [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)

    ### Testing

    - [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)

    &nbsp;
- name: is
  id: index#is
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: isnt
  id: index#isnt
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: JSX
  id: index#jsx
  summary: JSX is JavaScript containing interspersed XML elements
  description: |-
    ## JSX

    [JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.

    CoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.

    Just like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.

    ``` coffeescript
    renderStarRating = ({ rating, maxStars }) ->
      <aside title={"Rating: #{rating} of #{maxStars} stars"}>
        {for wholeStar in [0...Math.floor(rating)]
          <Star className="wholeStar" key={wholeStar} />}
        {if rating % 1 isnt 0
          <Star className="halfStar" />}
        {for emptyStar in [Math.ceil(rating)...maxStars]
          <Star className="emptyStar" key={emptyStar} />}
      </aside>
    ```

    ``` javascript
    var renderStarRating;

    renderStarRating = function({rating, maxStars}) {
      var emptyStar, wholeStar;
      return <aside title={`Rating: ${rating} of ${maxStars} stars`}>
        {(function() {
        var i, ref, results;
        results = [];
        for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {
          results.push(<Star className="wholeStar" key={wholeStar} />);
        }
        return results;
      })()}
        {rating % 1 !== 0 ? <Star className="halfStar" /> : void 0}
        {(function() {
        var i, ref, ref1, results;
        results = [];
        for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {
          results.push(<Star className="emptyStar" key={emptyStar} />);
        }
        return results;
      })()}
      </aside>;
    };
    ```

    Older plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.
- name: Language Reference
  id: index#language
  summary: This reference is structured so that it can be read from top to bottom, if you like
  description: "## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`"
- name: Lexical Scoping and Variable Safety
  id: index#lexical-scope
  summary: The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write var yourself
  description: |-
    ## Lexical Scoping and Variable Safety

    The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.

    ``` coffeescript
    outer = 1
    changeNumbers = ->
      inner = -1
      outer = 10
    inner = changeNumbers()
    ```

    ``` javascript
    var changeNumbers, inner, outer;

    outer = 1;

    changeNumbers = function() {
      var inner;
      inner = -1;
      return outer = 10;
    };

    inner = changeNumbers();
    ```

    Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.

    Because you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.

    Although suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)

    If you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.

    Since CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.
- name: Literate CoffeeScript
  id: index#literate
  summary: Besides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode
  description: |-
    ## Literate CoffeeScript

    Besides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.

    Just for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).

    A few caveats:

    - Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).
    - Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.
    - List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.
- name: not
  id: index#not
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Objects and Arrays
  id: index#objects-and-arrays
  summary: The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins
  description: |-
    ## Objects and Arrays

    The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).

    ``` coffeescript
    song = ["do", "re", "mi", "fa", "so"]

    singers = {Jagger: "Rock", Elvis: "Roll"}

    bitlist = [
      1, 0, 1
      0, 0, 1
      1, 1, 0
    ]

    kids =
      brother:
        name: "Max"
        age:  11
      sister:
        name: "Ida"
        age:  9
    ```

    ``` javascript
    var bitlist, kids, singers, song;

    song = ["do", "re", "mi", "fa", "so"];

    singers = {
      Jagger: "Rock",
      Elvis: "Roll"
    };

    bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];

    kids = {
      brother: {
        name: "Max",
        age: 11
      },
      sister: {
        name: "Ida",
        age: 9
      }
    };
    ```

    CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.

    ``` coffeescript
    name = "Michelangelo"
    mask = "orange"
    weapon = "nunchuks"
    turtle = {name, mask, weapon}
    output = "#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!"
    ```

    ``` javascript
    var mask, name, output, turtle, weapon;

    name = "Michelangelo";

    mask = "orange";

    weapon = "nunchuks";

    turtle = {name, mask, weapon};

    output = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;
    ```
- name: of
  id: index#of
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Operators and Aliases
  id: index#operators
  summary: Instead of a newline or semicolon, then can be used to separate conditions from expressions, in while, if/else, and switch/when statements
  description: |-
    ## Operators and Aliases

    Because the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.

    You can use `not` as an alias for `!`.

    For logic, `and` compiles to `&&`, and `or` into `||`.

    Instead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.

    As in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.

    `unless` can be used as the inverse of `if`.

    As a shortcut for `this.property`, you can use `@property`.

    You can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.

    In a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)

    To simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):

    ``` coffeescript
    -7 % 5 == -2 # The remainder of 7 / 5
    -7 %% 5 == 3 # n %% 5 is always between 0 and 4

    tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)
    ```

    ``` javascript
    var modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

    -7 % 5 === -2; // The remainder of 7 / 5

    modulo(-7, 5) === 3; // n %% 5 is always between 0 and 4

    tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));
    ```

    All together now:

    [TABLE]

    ``` coffeescript
    launch() if ignition is on

    volume = 10 if band isnt SpinalTap

    letTheWildRumpusBegin() unless answer is no

    if car.speed < limit then accelerate()

    winner = yes if pick in [47, 92, 13]

    print inspect "My name is #{@name}"
    ```

    ``` javascript
    var volume, winner;

    if (ignition === true) {
      launch();
    }

    if (band !== SpinalTap) {
      volume = 10;
    }

    if (answer !== false) {
      letTheWildRumpusBegin();
    }

    if (car.speed < limit) {
      accelerate();
    }

    if (pick === 47 || pick === 92 || pick === 13) {
      winner = true;
    }

    print(inspect(`My name is ${this.name}`));
    ```
- name: or
  id: index#or
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Resources
  id: index#resources
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Source Maps
  id: index#source-maps
  summary: CoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated
  description: |-
    ## Source Maps

    CoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.

    For a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).
- name: Tagged Template Literals
  id: index#tagged-template-literals
  summary: CoffeeScript supports ES2015 tagged template literals, which enable customized string interpolation
  description: |-
    ## Tagged Template Literals

    CoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.

    ``` coffeescript
    upperCaseExpr = (textParts, expressions...) ->
      textParts.reduce (text, textPart, i) ->
        text + expressions[i - 1].toUpperCase() + textPart

    greet = (name, adjective) ->
      upperCaseExpr"""
                   Hi #{name}. You look #{adjective}!
                   """
    ```

    ``` javascript
    var greet, upperCaseExpr;

    upperCaseExpr = function(textParts, ...expressions) {
      return textParts.reduce(function(text, textPart, i) {
        return text + expressions[i - 1].toUpperCase() + textPart;
      });
    };

    greet = function(name, adjective) {
      return upperCaseExpr`Hi ${name}. You look ${adjective}!`;
    };
    ```
- name: Try CoffeeScript
  id: index#try
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: try...catch...finally
  id: index#try
  summary: CoffeeScript is a little language that compiles into JavaScript
  description: "# CoffeeScript\n\n**CoffeeScript is a little language that compiles into JavaScript.** Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.\n\nThe golden rule of CoffeeScript is: *“It’s just JavaScript.”* The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.\n\n**Latest Version:** [2.7.0](https://github.com/jashkenas/coffeescript/tarball/2.7.0)\n\n``` coffeescript\n# Install locally for a project:\nnpm install --save-dev coffeescript\n\n# Install globally to execute .coffee files anywhere:\nnpm install --global coffeescript\n```\n\n## Overview\n\n*CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!*\n\n``` coffeescript\n# Assignment:\nnumber   = 42\nopposite = true\n\n# Conditions:\nnumber = -42 if opposite\n\n# Functions:\nsquare = (x) -> x * x\n\n# Arrays:\nlist = [1, 2, 3, 4, 5]\n\n# Objects:\nmath =\n  root:   Math.sqrt\n  square: square\n  cube:   (x) -> x * square x\n\n# Splats:\nrace = (winner, runners...) ->\n  print winner, runners\n\n# Existence:\nalert \"I knew it!\" if elvis?\n\n# Array comprehensions:\ncubes = (math.cube num for num in list)\n```\n\n``` javascript\n// Assignment:\nvar cubes, list, math, num, number, opposite, race, square;\n\nnumber = 42;\n\nopposite = true;\n\nif (opposite) {\n  // Conditions:\n  number = -42;\n}\n\n// Functions:\nsquare = function(x) {\n  return x * x;\n};\n\n// Arrays:\nlist = [1, 2, 3, 4, 5];\n\n// Objects:\nmath = {\n  root: Math.sqrt,\n  square: square,\n  cube: function(x) {\n    return x * square(x);\n  }\n};\n\n// Splats:\nrace = function(winner, ...runners) {\n  return print(winner, runners);\n};\n\nif (typeof elvis !== \"undefined\" && elvis !== null) {\n  // Existence:\n  alert(\"I knew it!\");\n}\n\n// Array comprehensions:\ncubes = (function() {\n  var i, len, results;\n  results = [];\n  for (i = 0, len = list.length; i < len; i++) {\n    num = list[i];\n    results.push(math.cube(num));\n  }\n  return results;\n})();\n```\n\n## CoffeeScript 2\n\n### What’s New In CoffeeScript 2?\n\nThe biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript `=>` becomes a JS `=>`, a CoffeeScript `class` becomes a JS `class` and so on. Major new features in CoffeeScript 2 include [async functions](#async-functions) and [JSX](#jsx). You can read more in the [announcement](https://coffeescript.org/announcing-coffeescript-2/).\n\nThere are very few [breaking changes from CoffeeScript 1.x to 2](#breaking-changes); we hope the upgrade process is smooth for most projects.\n\n### Compatibility\n\nMost modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript’s output without any further processing required. Here are some notable exceptions:\n\n- [JSX](#jsx) always requires transpilation.\n- [Splats, a.k.a. object rest/spread syntax, for objects](https://coffeescript.org/#splats) are supported by Node 8.6+.\n- The [regular expression `s` (dotall) flag](https://github.com/tc39/proposal-regexp-dotall-flag) is supported by Node 9+.\n- [Async generator functions](https://github.com/tc39/proposal-async-iteration) are supported by Node 10+.\n- [Modules](#modules) are supported by Node 12+ with `\"type\": \"module\"` in your project’s `package.json`.\n\nThis list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to [node.green](http://node.green/) for full details. You can [run the tests in your browser](https://coffeescript.org/test.html) to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you [transpile](#transpilation) your code. When in doubt, transpile.\n\nFor compatibility with other JavaScript frameworks and tools, see [Integrations](#integrations).\n\n## Installation\n\nThe command-line version of `coffee` is available as a [Node.js](https://nodejs.org/) utility, requiring Node 6 or later. The [core compiler](https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js) however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see [Try CoffeeScript](#try)).\n\nTo install, first make sure you have a working copy of the latest stable version of [Node.js](https://nodejs.org/). You can then install CoffeeScript globally with [npm](https://www.npmjs.com/):\n\n    npm install --global coffeescript\n\nThis will make the `coffee` and `cake` commands available globally.\n\nIf you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project’s dependencies. Within that project’s folder:\n\n    npm install --save-dev coffeescript\n\nThe `coffee` and `cake` commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.\n\nIf you plan to use the `--transpile` option (see [Transpilation](#transpilation)) you will need to also install `@babel/core` either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.\n\n## Usage\n\n### Command Line\n\nOnce installed, you should have access to the `coffee` command, which can execute scripts, compile `.coffee` files into `.js`, and provide an interactive REPL. The `coffee` command takes the following options:\n\n| Option                   | Description                                                                                                                                                                                                                                                                                                                      |\n|--------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-c, --compile`          | Compile a `.coffee` script into a `.js` JavaScript file of the same name.                                                                                                                                                                                                                                                        |\n| `-t, --transpile`        | Pipe the CoffeeScript compiler’s output through Babel before saving or running the generated JavaScript. Requires `@babel/core` to be installed, and options to pass to Babel in a `.babelrc` file or a `package.json` with a `babel` key in the path of the file or folder to be compiled. See [Transpilation](#transpilation). |\n| `-m, --map`              | Generate source maps alongside the compiled JavaScript files. Adds `sourceMappingURL` directives to the JavaScript as well.                                                                                                                                                                                                      |\n| `-M, --inline-map`       | Just like `--map`, but include the source map directly in the compiled JavaScript files, rather than in a separate file.                                                                                                                                                                                                         |\n| `-i, --interactive`      | Launch an interactive CoffeeScript session to try short snippets. Identical to calling `coffee` with no arguments.                                                                                                                                                                                                               |\n| `-o, --output [DIR]`     | Write out all compiled JavaScript files into the specified directory. Use in conjunction with `--compile` or `--watch`.                                                                                                                                                                                                          |\n| `-w, --watch`            | Watch files for changes, rerunning the specified command when any file is updated.                                                                                                                                                                                                                                               |\n| `-p, --print`            | Instead of writing out the JavaScript as a file, print it directly to **stdout**.                                                                                                                                                                                                                                                |\n| `-s, --stdio`            | Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example: `cat src/cake.coffee | coffee -sc`                                                                                                                                                        |\n| `-l, --literate`         | Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over **stdio**, or using some sort of extension-less file name.                                                                                                                                                            |\n| `-e, --eval`             | Compile and print a little snippet of CoffeeScript directly from the command line. For example: `coffee -e \"console.log num for num in [10..1]\"`                                                                                                                                                                                 |\n| `-r, --require [MODULE]` | `require()` the given module before starting the REPL or evaluating the code given with the `--eval` flag.                                                                                                                                                                                                                       |\n| `-b, --bare`             | Compile the JavaScript without the [top-level function safety wrapper](#lexical-scope).                                                                                                                                                                                                                                          |\n| `--no-header`            | Suppress the “Generated by CoffeeScript” header.                                                                                                                                                                                                                                                                                 |\n| `--nodejs`               | The `node` executable has some useful options you can set, such as `--debug`, `--debug-brk`, `--max-stack-size`, and `--expose-gc`. Use this flag to forward options directly to Node.js. To pass multiple flags, use `--nodejs` multiple times.                                                                                 |\n| `--ast`                  | Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.                                                                                                                                                                                                                 |\n| `--tokens`               | Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.                                                                                                                                                                                                               |\n| `-n, --nodes`            | Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.                                                                                                                                                                                                     |\n\n#### Examples:\n\n- Compile a directory tree of `.coffee` files in `src` into a parallel tree of `.js` files in `lib`:  \n  `coffee --compile --output lib/ src/`\n- Watch a file for changes, and recompile it every time the file is saved:  \n  `coffee --watch --compile experimental.coffee`\n- Concatenate a list of files into a single script:  \n  `coffee --join project.js --compile src/*.coffee`\n- Print out the compiled JS from a one-liner:  \n  `coffee -bpe \"alert i for i in [0..10]\"`\n- All together now, watch and recompile an entire project as you work on it:  \n  `coffee -o lib/ -cw src/`\n- Start the CoffeeScript REPL (`Ctrl-D` to exit, `Ctrl-V`for multi-line):  \n  `coffee`\n\nTo use `--transpile`, see [Transpilation](#transpilation).\n\n### Node.js\n\nIf you’d like to use Node.js’ CommonJS to `require` CoffeeScript files, e.g. `require './app.coffee'`, you must first “register” CoffeeScript as an extension:\n\n``` coffeescript\nrequire 'coffeescript/register'\n\nApp = require './app' # The .coffee extension is optional\n```\n\nIf you want to use the compiler’s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can `require` the full module:\n\n``` coffeescript\nCoffeeScript = require 'coffeescript'\n\neval CoffeeScript.compile 'console.log \"Mmmmm, I could really go for some #{Math.pi}\"'\n```\n\nThe `compile` method has the signature `compile(code, options)` where `code` is a string of CoffeeScript code, and the optional `options` is an object with some or all of the following properties:\n\n- `options.sourceMap`, boolean: if true, a source map will be generated; and instead of returning a string, `compile` will return an object of the form `{js, v3SourceMap, sourceMap}`.\n- `options.inlineMap`, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.\n- `options.filename`, string: the filename to use for the source map. It can include a path (relative or absolute).\n- `options.bare`, boolean: if true, output without the [top-level function safety wrapper](#lexical-scope).\n- `options.header`, boolean: if true, output the `Generated by CoffeeScript` header.\n- `options.transpile`, **object**: if set, this must be an object with the [options to pass to Babel](https://babeljs.io/docs/usage/api/#options). See [Transpilation](#transpilation).\n- `options.ast`, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.\n\n### Transpilation\n\nCoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run [might not support all of that syntax](#compatibility). In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, `{ a } = obj` into `a = obj.a`. This is done via transpilers like [Babel](https://babeljs.io/), [Bublé](https://buble.surge.sh/) or [Traceur Compiler](https://github.com/google/traceur-compiler). See [Build Tools](#build-tools).\n\n#### Quickstart\n\nFrom the root of your project:\n\n    npm install --save-dev @babel/core @babel/preset-env\n    echo '{ \"presets\": [\"@babel/env\"] }' > .babelrc\n    coffee --compile --transpile --inline-map some-file.coffee\n\n#### Transpiling with the CoffeeScript compiler\n\nTo make things easy, CoffeeScript has built-in support for the popular [Babel](https://babeljs.io/) transpiler. You can use it via the `--transpile` command-line option or the `transpile` Node API option. To use either, `@babel/core` must be installed in your project:\n\n    npm install --save-dev @babel/core\n\nOr if you’re running the `coffee` command outside of a project folder, using a globally-installed `coffeescript` module, `@babel/core` needs to be installed globally:\n\n    npm install --global @babel/core\n\nBy default, Babel doesn’t do anything—it doesn’t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a [`.babelrc` file](https://babeljs.io/docs/usage/babelrc/) in the folder containing the files you’re compiling, or in any parent folder up the path above those files. (Babel supports [other ways](https://babeljs.io/docs/usage/babelrc/), too.) A minimal `.babelrc` file would be just `{ \"presets\": [\"@babel/env\"] }`. This implies that you have installed [`@babel/preset-env`](https://babeljs.io/docs/plugins/preset-env/):\n\n    npm install --save-dev @babel/preset-env  # Or --global for non-project-based usage\n\nSee [Babel’s website to learn about presets and plugins](https://babeljs.io/docs/plugins/) and the multitude of options you have. Another preset you might need is [`@babel/plugin-transform-react-jsx`](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/) if you’re using JSX with React (JSX can also be used with other frameworks).\n\nOnce you have `@babel/core` and `@babel/preset-env` (or other presets or plugins) installed, and a `.babelrc` file (or other equivalent) in place, you can use `coffee --transpile` to pipe CoffeeScript’s output through Babel using the options you’ve saved.\n\nIf you’re using CoffeeScript via the [Node API](https://coffeescript.org/nodejs_usage), where you call `CoffeeScript.compile` with a string to be compiled and an `options` object, the `transpile` key of the `options` object should be the Babel options:\n\n``` coffeescript\nCoffeeScript.compile(code, {transpile: {presets: ['@babel/env']}})\n```\n\nYou can also transpile CoffeeScript’s output without using the `transpile` option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as [Gulp](http://gulpjs.com/), [Webpack](https://webpack.github.io/), [Grunt](https://gruntjs.com/) and [Broccoli](http://broccolijs.com/).\n\n#### Polyfills\n\nNote that transpiling doesn’t automatically supply [polyfills](https://developer.mozilla.org/en-US/docs/Glossary/Polyfill) for your code. CoffeeScript itself will output [`Array.indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) if you use the `in` operator, or destructuring or spread/rest syntax; and [`Function.bind`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) if you use a bound (`=>`) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You’ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is [`@babel/polyfill`](https://babeljs.io/docs/en/babel-polyfill/), though there are many [other](https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423) [strategies](https://philipwalton.com/articles/loading-polyfills-only-when-needed/).\n\n## Language Reference\n\n*This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.*\n\n*Many of the examples can be run (where it makes sense) by pressing the* ▶ *button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.*\n\nFirst, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons `;` to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces `{ }` to surround blocks of code in [functions](#literals), [if-statements](#conditionals), [switch](#switch), and [try/catch](#try-catch), use indentation.\n\nYou don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.  \n`console.log sys.inspect object` → `console.log(sys.inspect(object));`\n\n## Functions\n\nFunctions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: `->`\n\n``` coffeescript\nsquare = (x) -> x * x\ncube   = (x) -> square(x) * x\n```\n\n``` javascript\nvar cube, square;\n\nsquare = function(x) {\n  return x * x;\n};\n\ncube = function(x) {\n  return square(x) * x;\n};\n```\n\nFunctions may also have default values for arguments, which will be used if the incoming argument is missing (`undefined`).\n\n``` coffeescript\nfill = (container, liquid = \"coffee\") ->\n  \"Filling the #{container} with #{liquid}...\"\n```\n\n``` javascript\nvar fill;\n\nfill = function(container, liquid = \"coffee\") {\n  return `Filling the ${container} with ${liquid}...`;\n};\n```\n\n## Strings\n\nLike JavaScript and many other languages, CoffeeScript supports strings as delimited by the `\"` or `'` characters. CoffeeScript also supports string interpolation within `\"`-quoted strings, using `#{ … }`. Single-quoted strings are literal. You may even use interpolation in object keys.\n\n``` coffeescript\nauthor = \"Wittgenstein\"\nquote  = \"A picture is a fact. -- #{ author }\"\n\nsentence = \"#{ 22 / 7 } is a decent approximation of π\"\n```\n\n``` javascript\nvar author, quote, sentence;\n\nauthor = \"Wittgenstein\";\n\nquote = `A picture is a fact. -- ${author}`;\n\nsentence = `${22 / 7} is a decent approximation of π`;\n```\n\nMultiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.\n\n``` coffeescript\nmobyDick = \"Call me Ishmael. Some years ago --\n  never mind how long precisely -- having little\n  or no money in my purse, and nothing particular\n  to interest me on shore, I thought I would sail\n  about a little and see the watery part of the\n  world...\"\n```\n\n``` javascript\nvar mobyDick;\n\nmobyDick = \"Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...\";\n```\n\nBlock strings, delimited by `\"\"\"` or `'''`, can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.\n\n``` coffeescript\nhtml = \"\"\"\n       <strong>\n         cup of coffeescript\n       </strong>\n       \"\"\"\n```\n\n``` javascript\nvar html;\n\nhtml = `<strong>\n  cup of coffeescript\n</strong>`;\n```\n\nDouble-quoted block strings, like other double-quoted strings, allow interpolation.\n\n## Objects and Arrays\n\nThe CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to [YAML](http://yaml.org).\n\n``` coffeescript\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"]\n\nsingers = {Jagger: \"Rock\", Elvis: \"Roll\"}\n\nbitlist = [\n  1, 0, 1\n  0, 0, 1\n  1, 1, 0\n]\n\nkids =\n  brother:\n    name: \"Max\"\n    age:  11\n  sister:\n    name: \"Ida\"\n    age:  9\n```\n\n``` javascript\nvar bitlist, kids, singers, song;\n\nsong = [\"do\", \"re\", \"mi\", \"fa\", \"so\"];\n\nsingers = {\n  Jagger: \"Rock\",\n  Elvis: \"Roll\"\n};\n\nbitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];\n\nkids = {\n  brother: {\n    name: \"Max\",\n    age: 11\n  },\n  sister: {\n    name: \"Ida\",\n    age: 9\n  }\n};\n```\n\nCoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the `{` and `}` are required for this shorthand.\n\n``` coffeescript\nname = \"Michelangelo\"\nmask = \"orange\"\nweapon = \"nunchuks\"\nturtle = {name, mask, weapon}\noutput = \"#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!\"\n```\n\n``` javascript\nvar mask, name, output, turtle, weapon;\n\nname = \"Michelangelo\";\n\nmask = \"orange\";\n\nweapon = \"nunchuks\";\n\nturtle = {name, mask, weapon};\n\noutput = `${turtle.name} wears an ${turtle.mask} mask. Watch out for his ${turtle.weapon}!`;\n```\n\n## Comments\n\nIn CoffeeScript, comments are denoted by the `#` character to the end of a line, or from `###` to the next appearance of `###`. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.\n\n``` coffeescript\n###\nFortune Cookie Reader v1.0\nReleased under the MIT License\n###\n\nsayFortune = (fortune) ->\n  console.log fortune # in bed!\n```\n\n``` javascript\n/*\nFortune Cookie Reader v1.0\nReleased under the MIT License\n*/\nvar sayFortune;\n\nsayFortune = function(fortune) {\n  return console.log(fortune); // in bed!\n};\n```\n\nInline `###` comments make [type annotations](#type-annotations) possible.\n\n## Lexical Scoping and Variable Safety\n\nThe CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write `var` yourself.\n\n``` coffeescript\nouter = 1\nchangeNumbers = ->\n  inner = -1\n  outer = 10\ninner = changeNumbers()\n```\n\n``` javascript\nvar changeNumbers, inner, outer;\n\nouter = 1;\n\nchangeNumbers = function() {\n  var inner;\n  inner = -1;\n  return outer = 10;\n};\n\ninner = changeNumbers();\n```\n\nNotice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. `outer` is not redeclared within the inner function, because it’s already in scope; `inner` within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.\n\nBecause you don’t have direct access to the `var` keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.\n\nAlthough suppressed within this documentation for clarity, all CoffeeScript output (except in files with `import` or `export` statements) is wrapped in an anonymous function: `(function(){ … })();`. This safety wrapper, combined with the automatic generation of the `var` keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the [`bare` option](#usage), and is unnecessary and automatically disabled when using modules.)\n\nIf you’d like to create top-level variables for other scripts to use, attach them as properties on `window`; attach them as properties on the `exports` object in CommonJS; or use an [`export` statement](#modules). If you’re targeting both CommonJS and the browser, the [existential operator](#existential-operator) (covered below), gives you a reliable way to figure out where to add them: `exports ? this`.\n\nSince CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015’s `let` or `const`. [This is intentional](#unsupported-let-const); we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.\n\n## If, Else, Unless, and Conditional Assignment\n\n`if`/`else` statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the `if` or `unless` at the end.\n\nCoffeeScript can compile `if` statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular `if` statement on a single line.\n\n``` coffeescript\nmood = greatlyImproved if singing\n\nif happy and knowsIt\n  clapsHands()\n  chaChaCha()\nelse\n  showIt()\n\ndate = if friday then sue else jill\n```\n\n``` javascript\nvar date, mood;\n\nif (singing) {\n  mood = greatlyImproved;\n}\n\nif (happy && knowsIt) {\n  clapsHands();\n  chaChaCha();\n} else {\n  showIt();\n}\n\ndate = friday ? sue : jill;\n```\n\n## Splats, or Rest Parameters/Spread Syntax\n\nThe JavaScript `arguments` object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats `...`, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their [rest parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\n``` coffeescript\ngold = silver = rest = \"unknown\"\n\nawardMedals = (first, second, others...) ->\n  gold   = first\n  silver = second\n  rest   = others\n\ncontenders = [\n  \"Michael Phelps\"\n  \"Liu Xiang\"\n  \"Yao Ming\"\n  \"Allyson Felix\"\n  \"Shawn Johnson\"\n  \"Roman Sebrle\"\n  \"Guo Jingjing\"\n  \"Tyson Gay\"\n  \"Asafa Powell\"\n  \"Usain Bolt\"\n]\n\nawardMedals contenders...\n\nalert \"\"\"\nGold: #{gold}\nSilver: #{silver}\nThe Field: #{rest.join ', '}\n\"\"\"\n```\n\n``` javascript\nvar awardMedals, contenders, gold, rest, silver;\n\ngold = silver = rest = \"unknown\";\n\nawardMedals = function(first, second, ...others) {\n  gold = first;\n  silver = second;\n  return rest = others;\n};\n\ncontenders = [\"Michael Phelps\", \"Liu Xiang\", \"Yao Ming\", \"Allyson Felix\", \"Shawn Johnson\", \"Roman Sebrle\", \"Guo Jingjing\", \"Tyson Gay\", \"Asafa Powell\", \"Usain Bolt\"];\n\nawardMedals(...contenders);\n\nalert(`Gold: ${gold}\nSilver: ${silver}\nThe Field: ${rest.join(', ')}`);\n```\n\nSplats also let us elide array elements…\n\n``` coffeescript\npopular  = ['pepperoni', 'sausage', 'cheese']\nunwanted = ['anchovies', 'olives']\n\nall = [popular..., unwanted..., 'mushrooms']\n```\n\n``` javascript\nvar all, popular, unwanted;\n\npopular = ['pepperoni', 'sausage', 'cheese'];\n\nunwanted = ['anchovies', 'olives'];\n\nall = [...popular, ...unwanted, 'mushrooms'];\n```\n\n…and object properties.\n\n``` coffeescript\nuser =\n  name: 'Werner Heisenberg'\n  occupation: 'theoretical physicist'\n\ncurrentUser = { user..., status: 'Uncertain' }\n```\n\n``` javascript\nvar currentUser, user;\n\nuser = {\n  name: 'Werner Heisenberg',\n  occupation: 'theoretical physicist'\n};\n\ncurrentUser = {\n  ...user,\n  status: 'Uncertain'\n};\n```\n\nIn ECMAScript this is called [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator), and has been supported for arrays since ES2015 and objects since ES2018.\n\n## Loops and Comprehensions\n\nMost of the loops you’ll write in CoffeeScript will be **comprehensions** over arrays, objects, and ranges. Comprehensions replace (and compile into) `for` loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.\n\n``` coffeescript\n# Eat lunch.\neat = (food) -> \"#{food} eaten.\"\neat food for food in ['toast', 'cheese', 'wine']\n\n# Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake']\nmenu = (i, dish) -> \"Menu Item #{i}: #{dish}\" \nmenu i + 1, dish for dish, i in courses\n\n# Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate']\neat food for food in foods when food isnt 'chocolate'\n```\n\n``` javascript\n// Eat lunch.\nvar courses, dish, eat, food, foods, i, j, k, l, len, len1, len2, menu, ref;\n\neat = function(food) {\n  return `${food} eaten.`;\n};\n\nref = ['toast', 'cheese', 'wine'];\nfor (j = 0, len = ref.length; j < len; j++) {\n  food = ref[j];\n  eat(food);\n}\n\n// Fine five course dining.\ncourses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];\n\nmenu = function(i, dish) {\n  return `Menu Item ${i}: ${dish}`;\n};\n\nfor (i = k = 0, len1 = courses.length; k < len1; i = ++k) {\n  dish = courses[i];\n  menu(i + 1, dish);\n}\n\n// Health conscious meal.\nfoods = ['broccoli', 'spinach', 'chocolate'];\n\nfor (l = 0, len2 = foods.length; l < len2; l++) {\n  food = foods[l];\n  if (food !== 'chocolate') {\n    eat(food);\n  }\n}\n```\n\nComprehensions should be able to handle most places where you otherwise would use a loop, `each`/`forEach`, `map`, or `select`/`filter`, for example:  \n`shortNames = (name for name in list when name.length < 5)`  \nIf you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.\n\n``` coffeescript\ncountdown = (num for num in [10..1])\n```\n\n``` javascript\nvar countdown, num;\n\ncountdown = (function() {\n  var i, results;\n  results = [];\n  for (num = i = 10; i >= 1; num = --i) {\n    results.push(num);\n  }\n  return results;\n})();\n```\n\nNote how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like `true` — or `null`, to the bottom of your function.\n\nTo step through a range comprehension in fixed-size chunks, use `by`, for example: `evens = (x for x in [0..10] by 2)`\n\nIf you don’t need the current iteration value you may omit it: `browser.closeCurrentTab() for [0...count]`\n\nComprehensions can also be used to iterate over the keys and values in an object. Use `of` to signal comprehension over the properties of an object instead of the values in an array.\n\n``` coffeescript\nyearsOld = max: 10, ida: 9, tim: 11\n\nages = for child, age of yearsOld\n  \"#{child} is #{age}\"\n```\n\n``` javascript\nvar age, ages, child, yearsOld;\n\nyearsOld = {\n  max: 10,\n  ida: 9,\n  tim: 11\n};\n\nages = (function() {\n  var results;\n  results = [];\n  for (child in yearsOld) {\n    age = yearsOld[child];\n    results.push(`${child} is ${age}`);\n  }\n  return results;\n})();\n```\n\nIf you would like to iterate over just the keys that are defined on the object itself, by adding a `hasOwnProperty` check to avoid properties that may be inherited from the prototype, use `for own key, value of object`.\n\nTo iterate a generator function, use `from`. See [Generator Functions](#generator-iteration).\n\nThe only low-level loop that CoffeeScript provides is the `while` loop. The main difference from JavaScript is that the `while` loop can be used as an expression, returning an array containing the result of each iteration through the loop.\n\n``` coffeescript\n# Econ 101\nif this.studyingEconomics\n  buy()  while supply > demand\n  sell() until supply > demand\n\n# Nursery Rhyme\nnum = 6\nlyrics = while num -= 1\n  \"#{num} little monkeys, jumping on the bed.\n    One fell out and bumped his head.\"\n```\n\n``` javascript\n// Econ 101\nvar lyrics, num;\n\nif (this.studyingEconomics) {\n  while (supply > demand) {\n    buy();\n  }\n  while (!(supply > demand)) {\n    sell();\n  }\n}\n\n// Nursery Rhyme\nnum = 6;\n\nlyrics = (function() {\n  var results;\n  results = [];\n  while (num -= 1) {\n    results.push(`${num} little monkeys, jumping on the bed. One fell out and bumped his head.`);\n  }\n  return results;\n})();\n```\n\nFor readability, the `until` keyword is equivalent to `while not`, and the `loop` keyword is equivalent to `while true`.\n\nWhen using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the `do` keyword, which immediately invokes a passed function, forwarding any arguments.\n\n``` coffeescript\nfor filename in list\n  do (filename) ->\n    if filename not in ['.DS_Store', 'Thumbs.db', 'ehthumbs.db']\n      fs.readFile filename, (err, contents) ->\n        compile filename, contents.toString()\n```\n\n``` javascript\nvar filename, i, len;\n\nfor (i = 0, len = list.length; i < len; i++) {\n  filename = list[i];\n  (function(filename) {\n    if (filename !== '.DS_Store' && filename !== 'Thumbs.db' && filename !== 'ehthumbs.db') {\n      return fs.readFile(filename, function(err, contents) {\n        return compile(filename, contents.toString());\n      });\n    }\n  })(filename);\n}\n```\n\n## Array Slicing and Splicing with Ranges\n\nRanges can also be used to extract slices of arrays. With two dots (`3..6`), the range is inclusive (`3, 4, 5, 6`); with three dots (`3...6`), the range excludes the end (`3, 4, 5`). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.\n\n``` coffeescript\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nstart   = numbers[0..2]\n\nmiddle  = numbers[3...-2]\n\nend     = numbers[-2..]\n\ncopy    = numbers[..]\n```\n\n``` javascript\nvar copy, end, middle, numbers, start;\n\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nstart = numbers.slice(0, 3);\n\nmiddle = numbers.slice(3, -2);\n\nend = numbers.slice(-2);\n\ncopy = numbers.slice(0);\n```\n\nThe same syntax can be used with assignment to replace a segment of an array with new values, splicing it.\n\n``` coffeescript\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nnumbers[3..6] = [-3, -4, -5, -6]\n```\n\n``` javascript\nvar numbers, ref,\n  splice = [].splice;\n\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\nsplice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;\n```\n\nNote that JavaScript strings are immutable, and can’t be spliced.\n\n## Everything is an Expression (at least, as much as possible)\n\nYou might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the `return` gets pushed down into each possible branch of execution in the function below.\n\n``` coffeescript\ngrade = (student) ->\n  if student.excellentWork\n    \"A+\"\n  else if student.okayStuff\n    if student.triedHard then \"B\" else \"B-\"\n  else\n    \"C\"\n\neldest = if 24 > 21 then \"Liz\" else \"Ike\"\n```\n\n``` javascript\nvar eldest, grade;\n\ngrade = function(student) {\n  if (student.excellentWork) {\n    return \"A+\";\n  } else if (student.okayStuff) {\n    if (student.triedHard) {\n      return \"B\";\n    } else {\n      return \"B-\";\n    }\n  } else {\n    return \"C\";\n  }\n};\n\neldest = 24 > 21 ? \"Liz\" : \"Ike\";\n```\n\nEven though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (`return value`), when you know that you’re done.\n\nBecause variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:\n\n``` coffeescript\nsix = (one = 1) + (two = 2) + (three = 3)\n```\n\n``` javascript\nvar one, six, three, two;\n\nsix = (one = 1) + (two = 2) + (three = 3);\n```\n\nThings that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:\n\n``` coffeescript\n# The first ten global properties.\n\nglobals = (name for name of window)[0...10]\n```\n\n``` javascript\n// The first ten global properties.\nvar globals, name;\n\nglobals = ((function() {\n  var results;\n  results = [];\n  for (name in window) {\n    results.push(name);\n  }\n  return results;\n})()).slice(0, 10);\n```\n\nAs well as silly things, like passing a `try`/`catch` statement directly into a function call:\n\n``` coffeescript\nalert(\n  try\n    nonexistent / undefined\n  catch error\n    \"And the error is ... #{error}\"\n)\n```\n\n``` javascript\nvar error;\n\nalert((function() {\n  try {\n    return nonexistent / void 0;\n  } catch (error1) {\n    error = error1;\n    return `And the error is ... ${error}`;\n  }\n})());\n```\n\nThere are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely `break`, `continue`, and `return`. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.\n\n## Operators and Aliases\n\nBecause the `==` operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles `==` into `===`, and `!=` into `!==`. In addition, `is` compiles into `===`, and `isnt` into `!==`.\n\nYou can use `not` as an alias for `!`.\n\nFor logic, `and` compiles to `&&`, and `or` into `||`.\n\nInstead of a newline or semicolon, `then` can be used to separate conditions from expressions, in `while`, `if`/`else`, and `switch`/`when` statements.\n\nAs in [YAML](http://yaml.org/), `on` and `yes` are the same as boolean `true`, while `off` and `no` are boolean `false`.\n\n`unless` can be used as the inverse of `if`.\n\nAs a shortcut for `this.property`, you can use `@property`.\n\nYou can use `in` to test for array presence, and `of` to test for JavaScript object-key presence.\n\nIn a `for` loop, `from` compiles to the [ES2015 `of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of). (Yes, it’s unfortunate; the CoffeeScript `of` predates the ES2015 `of`.)\n\nTo simplify math expressions, `**` can be used for exponentiation and `//` performs floor division. `%` works just like in JavaScript, while `%%` provides [“dividend dependent modulo”](https://en.wikipedia.org/wiki/Modulo_operation):\n\n``` coffeescript\n-7 % 5 == -2 # The remainder of 7 / 5\n-7 %% 5 == 3 # n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)\n```\n\n``` javascript\nvar modulo = function(a, b) { return (+a % (b = +b) + b) % b; };\n\n-7 % 5 === -2; // The remainder of 7 / 5\n\nmodulo(-7, 5) === 3; // n %% 5 is always between 0 and 4\n\ntabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));\n```\n\nAll together now:\n\n| CoffeeScript         | JavaScript                   |\n|----------------------|------------------------------|\n| `is`                 | `===`                        |\n| `isnt`               | `!==`                        |\n| `not`                | `!`                          |\n| `and`                | `&&`                         |\n| `or`                 | `||`                         |\n| `true`, `yes`, `on`  | `true`                       |\n| `false`, `no`, `off` | `false`                      |\n| `@`, `this`          | `this`                       |\n| `a in b`             | `[].indexOf.call(b, a) >= 0` |\n| `a of b`             | `a in b`                     |\n| `for a from b`       | `for (a of b)`               |\n| `a ** b`             | `a ** b`                     |\n| `a // b`             | `Math.floor(a / b)`          |\n| `a %% b`             | `(a % b + b) % b`            |\n\n``` coffeescript\nlaunch() if ignition is on\n\nvolume = 10 if band isnt SpinalTap\n\nletTheWildRumpusBegin() unless answer is no\n\nif car.speed < limit then accelerate()\n\nwinner = yes if pick in [47, 92, 13]\n\nprint inspect \"My name is #{@name}\"\n```\n\n``` javascript\nvar volume, winner;\n\nif (ignition === true) {\n  launch();\n}\n\nif (band !== SpinalTap) {\n  volume = 10;\n}\n\nif (answer !== false) {\n  letTheWildRumpusBegin();\n}\n\nif (car.speed < limit) {\n  accelerate();\n}\n\nif (pick === 47 || pick === 92 || pick === 13) {\n  winner = true;\n}\n\nprint(inspect(`My name is ${this.name}`));\n```\n\n## The Existential Operator\n\nIt’s a little difficult to check for the existence of a variable in JavaScript. `if (variable) …` comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript’s existential operator `?` returns true unless a variable is `null` or `undefined` or undeclared, which makes it analogous to Ruby’s `nil?`.\n\nIt can also be used for safer conditional assignment than the JavaScript pattern `a = a || value` provides, for cases where you may be handling numbers or strings.\n\n``` coffeescript\nsolipsism = true if mind? and not world?\n\nspeed = 0\nspeed ?= 15\n\nfootprints = yeti ? \"bear\"\n```\n\n``` javascript\nvar footprints, solipsism, speed;\n\nif ((typeof mind !== \"undefined\" && mind !== null) && (typeof world === \"undefined\" || world === null)) {\n  solipsism = true;\n}\n\nspeed = 0;\n\nif (speed == null) {\n  speed = 15;\n}\n\nfootprints = typeof yeti !== \"undefined\" && yeti !== null ? yeti : \"bear\";\n```\n\nNote that if the compiler knows that `a` is in scope and therefore declared, `a?` compiles to `a != null`, *not* `a !== null`. The `!=` makes a loose comparison to `null`, which does double duty also comparing against `undefined`. The reverse also holds for `not a?` or `unless a?`.\n\n``` coffeescript\nmajor = 'Computer Science'\n\nunless major?\n  signUpForClass 'Introduction to Wines'\n```\n\n``` javascript\nvar major;\n\nmajor = 'Computer Science';\n\nif (major == null) {\n  signUpForClass('Introduction to Wines');\n}\n```\n\nIf a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders *should* be typing when they want to check if a mystery variable exists.\n\n``` coffeescript\nif window?\n  environment = 'browser (probably)'\n```\n\n``` javascript\nvar environment;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  environment = 'browser (probably)';\n}\n```\n\nThe accessor variant of the existential operator `?.` can be used to soak up null references in a chain of properties. Use it instead of the dot accessor `.` in cases where the base value may be `null` or `undefined`. If all of the properties exist then you’ll get the expected result, if the chain is broken, `undefined` is returned instead of the `TypeError` that would be raised otherwise.\n\n``` coffeescript\nzip = lottery.drawWinner?().address?.zipcode\n```\n\n``` javascript\nvar ref, zip;\n\nzip = typeof lottery.drawWinner === \"function\" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;\n```\n\nFor completeness:\n\n| Example                 | Definition                                                                                                             |\n|-------------------------|------------------------------------------------------------------------------------------------------------------------|\n| `a?`                    | tests that `a` is in scope and `a != null`                                                                             |\n| `a ? b`                 | returns `a` if `a` is in scope and `a != null`; otherwise, `b`                                                         |\n| `a?.b` or `a?['b']`     | returns `a.b` if `a` is in scope and `a != null`; otherwise, `undefined`                                               |\n| `a?(b, c)` or `a? b, c` | returns the result of calling `a` (with arguments `b` and `c`) if `a` is in scope and callable; otherwise, `undefined` |\n| `a ?= b`                | assigns the value of `b` to `a` if `a` is not in scope or if `a == null`; produces the new value of `a`                |\n\n## Chaining Function Calls\n\nLeading `.` closes all open calls, allowing for simpler chaining syntax.\n\n``` coffeescript\n$ 'body'\n.click (e) ->\n  $ '.box'\n  .fadeIn 'fast'\n  .addClass 'show'\n.css 'background', 'white'\n```\n\n``` javascript\n$('body').click(function(e) {\n  return $('.box').fadeIn('fast').addClass('show');\n}).css('background', 'white');\n```\n\n## Destructuring Assignment\n\nJust like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:\n\n``` coffeescript\ntheBait   = 1000\ntheSwitch = 0\n\n[theBait, theSwitch] = [theSwitch, theBait]\n```\n\n``` javascript\nvar theBait, theSwitch;\n\ntheBait = 1000;\n\ntheSwitch = 0;\n\n[theBait, theSwitch] = [theSwitch, theBait];\n```\n\nBut it’s also helpful for dealing with functions that return multiple values.\n\n``` coffeescript\nweatherReport = (location) ->\n  # Make an Ajax request to fetch the weather...\n  [location, 72, \"Mostly Sunny\"]\n\n[city, temp, forecast] = weatherReport \"Berkeley, CA\"\n```\n\n``` javascript\nvar city, forecast, temp, weatherReport;\n\nweatherReport = function(location) {\n  // Make an Ajax request to fetch the weather...\n  return [location, 72, \"Mostly Sunny\"];\n};\n\n[city, temp, forecast] = weatherReport(\"Berkeley, CA\");\n```\n\nDestructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.\n\n``` coffeescript\nfuturists =\n  sculptor: \"Umberto Boccioni\"\n  painter:  \"Vladimir Burliuk\"\n  poet:\n    name:   \"F.T. Marinetti\"\n    address: [\n      \"Via Roma 42R\"\n      \"Bellagio, Italy 22021\"\n    ]\n\n{sculptor} = futurists\n\n{poet: {name, address: [street, city]}} = futurists\n```\n\n``` javascript\nvar city, futurists, name, sculptor, street;\n\nfuturists = {\n  sculptor: \"Umberto Boccioni\",\n  painter: \"Vladimir Burliuk\",\n  poet: {\n    name: \"F.T. Marinetti\",\n    address: [\"Via Roma 42R\", \"Bellagio, Italy 22021\"]\n  }\n};\n\n({sculptor} = futurists);\n\n({\n  poet: {\n    name,\n    address: [street, city]\n  }\n} = futurists);\n```\n\nDestructuring assignment can even be combined with splats.\n\n``` coffeescript\ntag = \"<impossible>\"\n\n[open, contents..., close] = tag.split(\"\")\n```\n\n``` javascript\nvar close, contents, open, ref, tag,\n  splice = [].splice;\n\ntag = \"<impossible>\";\n\nref = tag.split(\"\"), [open, ...contents] = ref, [close] = splice.call(contents, -1);\n```\n\nExpansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.\n\n``` coffeescript\ntext = \"Every literary critic believes he will\n        outwit history and have the last word\"\n\n[first, ..., last] = text.split \" \"\n```\n\n``` javascript\nvar first, last, ref, text,\n  slice = [].slice;\n\ntext = \"Every literary critic believes he will outwit history and have the last word\";\n\nref = text.split(\" \"), [first] = ref, [last] = slice.call(ref, -1);\n```\n\nDestructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.\n\n``` coffeescript\nclass Person\n  constructor: (options) ->\n    {@name, @age, @height = 'average'} = options\n\ntim = new Person name: 'Tim', age: 4\n```\n\n``` javascript\nvar Person, tim;\n\nPerson = class Person {\n  constructor(options) {\n    ({name: this.name, age: this.age, height: this.height = 'average'} = options);\n  }\n\n};\n\ntim = new Person({\n  name: 'Tim',\n  age: 4\n});\n```\n\nThe above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or `undefined`—[passing `null` will set a value of `null`](#breaking-changes-default-values), not the default.\n\n## Bound (Fat Arrow) Functions\n\nIn JavaScript, the `this` keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of `this` will be lost. If you’re not familiar with this behavior, [this Digital Web article](https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript) gives a good overview of the quirks.\n\nThe fat arrow `=>` can be used to both define a function, and to bind it to the current value of `this`, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to `each`, or event-handler functions to use with `on`. Functions created with the fat arrow are able to access properties of the `this` where they’re defined.\n\n``` coffeescript\nAccount = (customer, cart) ->\n  @customer = customer\n  @cart = cart\n\n  $('.shopping_cart').on 'click', (event) =>\n    @customer.purchase @cart\n```\n\n``` javascript\nvar Account;\n\nAccount = function(customer, cart) {\n  this.customer = customer;\n  this.cart = cart;\n  return $('.shopping_cart').on('click', (event) => {\n    return this.customer.purchase(this.cart);\n  });\n};\n```\n\nIf we had used `->` in the callback above, `@customer` would have referred to the undefined “customer” property of the DOM element, and trying to call `purchase()` on it would have raised an exception.\n\nThe fat arrow was one of the most popular features of CoffeeScript, and ES2015 [adopted it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions); so CoffeeScript 2 compiles `=>` to ES `=>`.\n\n## Generator Functions\n\nCoffeeScript supports ES2015 [generator functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) through the `yield` keyword. There’s no `function*(){}` nonsense — a generator in CoffeeScript is simply a function that yields.\n\n``` coffeescript\nperfectSquares = ->\n  num = 0\n  loop\n    num += 1\n    yield num * num\n  return\n\nwindow.ps or= perfectSquares()\n```\n\n``` javascript\nvar perfectSquares;\n\nperfectSquares = function*() {\n  var num;\n  num = 0;\n  while (true) {\n    num += 1;\n    yield num * num;\n  }\n};\n\nwindow.ps || (window.ps = perfectSquares());\n```\n\n`yield*` is called `yield from`, and `yield return` may be used if you need to force a generator that doesn’t yield.\n\nYou can iterate over a generator function using `for…from`.\n\n``` coffeescript\nfibonacci = ->\n  [previous, current] = [1, 1]\n  loop\n    [previous, current] = [current, previous + current]\n    yield current\n  return\n\ngetFibonacciNumbers = (length) ->\n  results = [1]\n  for n from fibonacci()\n    results.push n\n    break if results.length is length\n  results\n```\n\n``` javascript\nvar fibonacci, getFibonacciNumbers;\n\nfibonacci = function*() {\n  var current, previous;\n  [previous, current] = [1, 1];\n  while (true) {\n    [previous, current] = [current, previous + current];\n    yield current;\n  }\n};\n\ngetFibonacciNumbers = function(length) {\n  var n, results;\n  results = [1];\n  for (n of fibonacci()) {\n    results.push(n);\n    if (results.length === length) {\n      break;\n    }\n  }\n  return results;\n};\n```\n\n## Async Functions\n\nES2017’s [async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) are supported through the `await` keyword. Like with generators, there’s no need for an `async` keyword; an async function in CoffeeScript is simply a function that awaits.\n\nSimilar to how `yield return` forces a generator, `await return` may be used to force a function to be async.\n\n``` coffeescript\n# Your browser must support async/await and speech synthesis\n# to run this example.\n\nsleep = (ms) ->\n  new Promise (resolve) ->\n    window.setTimeout resolve, ms\n\nsay = (text) ->\n  window.speechSynthesis.cancel()\n  window.speechSynthesis.speak new SpeechSynthesisUtterance text\n\ncountdown = (seconds) ->\n  for i in [seconds..1]\n    say i\n    await sleep 1000 # wait one second\n  say \"Blastoff!\"\n\ncountdown 3\n```\n\n``` javascript\n// Your browser must support async/await and speech synthesis\n// to run this example.\nvar countdown, say, sleep;\n\nsleep = function(ms) {\n  return new Promise(function(resolve) {\n    return window.setTimeout(resolve, ms);\n  });\n};\n\nsay = function(text) {\n  window.speechSynthesis.cancel();\n  return window.speechSynthesis.speak(new SpeechSynthesisUtterance(text));\n};\n\ncountdown = async function(seconds) {\n  var i, j, ref;\n  for (i = j = ref = seconds; (ref <= 1 ? j <= 1 : j >= 1); i = ref <= 1 ? ++j : --j) {\n    say(i);\n    await sleep(1000); // wait one second\n  }\n  return say(\"Blastoff!\");\n};\n\ncountdown(3);\n```\n\n## Classes\n\nCoffeeScript 1 provided the `class` and `extends` keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its `class` and `extends` keywords to ES2015 classes.\n\n``` coffeescript\nclass Animal\n  constructor: (@name) ->\n\n  move: (meters) ->\n    alert @name + \" moved #{meters}m.\"\n\nclass Snake extends Animal\n  move: ->\n    alert \"Slithering...\"\n    super 5\n\nclass Horse extends Animal\n  move: ->\n    alert \"Galloping...\"\n    super 45\n\nsam = new Snake \"Sammy the Python\"\ntom = new Horse \"Tommy the Palomino\"\n\nsam.move()\ntom.move()\n```\n\n``` javascript\nvar Animal, Horse, Snake, sam, tom;\n\nAnimal = class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n\n  move(meters) {\n    return alert(this.name + ` moved ${meters}m.`);\n  }\n\n};\n\nSnake = class Snake extends Animal {\n  move() {\n    alert(\"Slithering...\");\n    return super.move(5);\n  }\n\n};\n\nHorse = class Horse extends Animal {\n  move() {\n    alert(\"Galloping...\");\n    return super.move(45);\n  }\n\n};\n\nsam = new Snake(\"Sammy the Python\");\n\ntom = new Horse(\"Tommy the Palomino\");\n\nsam.move();\n\ntom.move();\n```\n\nStatic methods can be defined using `@` before the method name:\n\n``` coffeescript\nclass Teenager\n  @say: (speech) ->\n    words = speech.split ' '\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe']\n    output = []\n    for word, index in words\n      output.push word\n      output.push fillers[Math.floor(Math.random() * fillers.length)] unless index is words.length - 1\n    output.join ', '\n```\n\n``` javascript\nvar Teenager;\n\nTeenager = class Teenager {\n  static say(speech) {\n    var fillers, i, index, len, output, word, words;\n    words = speech.split(' ');\n    fillers = ['uh', 'um', 'like', 'actually', 'so', 'maybe'];\n    output = [];\n    for (index = i = 0, len = words.length; i < len; index = ++i) {\n      word = words[index];\n      output.push(word);\n      if (index !== words.length - 1) {\n        output.push(fillers[Math.floor(Math.random() * fillers.length)]);\n      }\n    }\n    return output.join(', ');\n  }\n\n};\n```\n\nFinally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, `this` is the class object itself; therefore, you can assign static properties by using `@property: value`.\n\n## Prototypal Inheritance\n\nIn addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The `::` operator gives you quick access to an object’s prototype:\n\n``` coffeescript\nString::dasherize = ->\n  this.replace /_/g, \"-\"\n```\n\n``` javascript\nString.prototype.dasherize = function() {\n  return this.replace(/_/g, \"-\");\n};\n```\n\n## Switch/When/Else\n\n`switch` statements in JavaScript are a bit awkward. You need to remember to `break` at the end of every `case` statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the `switch` into a returnable, assignable expression. The format is: `switch` condition, `when` clauses, `else` the default case.\n\nAs in Ruby, `switch` statements in CoffeeScript can take multiple values for each `when` clause. If any of the values match, the clause runs.\n\n``` coffeescript\nswitch day\n  when \"Mon\" then go work\n  when \"Tue\" then go relax\n  when \"Thu\" then go iceFishing\n  when \"Fri\", \"Sat\"\n    if day is bingoDay\n      go bingo\n      go dancing\n  when \"Sun\" then go church\n  else go work\n```\n\n``` javascript\nswitch (day) {\n  case \"Mon\":\n    go(work);\n    break;\n  case \"Tue\":\n    go(relax);\n    break;\n  case \"Thu\":\n    go(iceFishing);\n    break;\n  case \"Fri\":\n  case \"Sat\":\n    if (day === bingoDay) {\n      go(bingo);\n      go(dancing);\n    }\n    break;\n  case \"Sun\":\n    go(church);\n    break;\n  default:\n    go(work);\n}\n```\n\n`switch` statements can also be used without a control expression, turning them in to a cleaner alternative to `if`/`else` chains.\n\n``` coffeescript\nscore = 76\ngrade = switch\n  when score < 60 then 'F'\n  when score < 70 then 'D'\n  when score < 80 then 'C'\n  when score < 90 then 'B'\n  else 'A'\n# grade == 'C'\n```\n\n``` javascript\nvar grade, score;\n\nscore = 76;\n\ngrade = (function() {\n  switch (false) {\n    case !(score < 60):\n      return 'F';\n    case !(score < 70):\n      return 'D';\n    case !(score < 80):\n      return 'C';\n    case !(score < 90):\n      return 'B';\n    default:\n      return 'A';\n  }\n})();\n\n// grade == 'C'\n```\n\n## Try/Catch/Finally\n\n`try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.\n\n``` coffeescript\ntry\n  allHellBreaksLoose()\n  catsAndDogsLivingTogether()\ncatch error\n  print error\nfinally\n  cleanUp()\n```\n\n``` javascript\nvar error;\n\ntry {\n  allHellBreaksLoose();\n  catsAndDogsLivingTogether();\n} catch (error1) {\n  error = error1;\n  print(error);\n} finally {\n  cleanUp();\n}\n```\n\n## Chained Comparisons\n\nCoffeeScript borrows [chained comparisons](https://docs.python.org/3/reference/expressions.html#not-in) from Python — making it easy to test if a value falls within a certain range.\n\n``` coffeescript\ncholesterol = 127\n\nhealthy = 200 > cholesterol > 60\n```\n\n``` javascript\nvar cholesterol, healthy;\n\ncholesterol = 127;\n\nhealthy = (200 > cholesterol && cholesterol > 60);\n```\n\n## Block Regular Expressions\n\nSimilar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s `/x` modifier, CoffeeScript’s block regexes are delimited by `///` and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:\n\n``` coffeescript\nNUMBER     = ///\n  ^ 0b[01]+    |              # binary\n  ^ 0o[0-7]+   |              # octal\n  ^ 0x[\\da-f]+ |              # hex\n  ^ \\d*\\.?\\d+ (?:e[+-]?\\d+)?  # decimal\n///i\n```\n\n``` javascript\nvar NUMBER;\n\nNUMBER = /^0b[01]+|^0o[0-7]+|^0x[\\da-f]+|^\\d*\\.?\\d+(?:e[+-]?\\d+)?/i; // binary\n// octal\n// hex\n// decimal\n```\n\n## Tagged Template Literals\n\nCoffeeScript supports [ES2015 tagged template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals), which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will [behave accordingly](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals): the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.\n\n``` coffeescript\nupperCaseExpr = (textParts, expressions...) ->\n  textParts.reduce (text, textPart, i) ->\n    text + expressions[i - 1].toUpperCase() + textPart\n\ngreet = (name, adjective) ->\n  upperCaseExpr\"\"\"\n               Hi #{name}. You look #{adjective}!\n               \"\"\"\n```\n\n``` javascript\nvar greet, upperCaseExpr;\n\nupperCaseExpr = function(textParts, ...expressions) {\n  return textParts.reduce(function(text, textPart, i) {\n    return text + expressions[i - 1].toUpperCase() + textPart;\n  });\n};\n\ngreet = function(name, adjective) {\n  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;\n};\n```\n\n## Modules\n\n[ES2015 modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) are supported in CoffeeScript, with very similar `import` and `export` syntax:\n\n``` coffeescript\nimport './local-file.js' # Must be the filename of the generated file\nimport 'package'\n\nimport _ from 'underscore'\nimport * as underscore from 'underscore'\n\nimport { now } from 'underscore'\nimport { now as currentTimestamp } from 'underscore'\nimport { first, last } from 'underscore'\nimport utilityBelt, { each } from 'underscore'\n\nimport dates from './calendar.json' assert { type: 'json' }\n\nexport default Math\nexport square = (x) -> x * x\nexport class Mathematics\n  least: (x, y) -> if x < y then x else y\n\nexport { sqrt }\nexport { sqrt as squareRoot }\nexport { Mathematics as default, sqrt as squareRoot }\n\nexport * from 'underscore'\nexport { max, min } from 'underscore'\nexport { version } from './package.json' assert { type: 'json' }\n```\n\n``` javascript\nimport './local-file.js';\n\nimport 'package';\n\nimport _ from 'underscore';\n\nimport * as underscore from 'underscore';\n\nimport {\n  now\n} from 'underscore';\n\nimport {\n  now as currentTimestamp\n} from 'underscore';\n\nimport {\n  first,\n  last\n} from 'underscore';\n\nimport utilityBelt, {\n  each\n} from 'underscore';\n\nimport dates from './calendar.json' assert {\n  type: 'json'\n};\n\nexport default Math;\n\nexport var square = function(x) {\n  return x * x;\n};\n\nexport var Mathematics = class Mathematics {\n  least(x, y) {\n    if (x < y) {\n      return x;\n    } else {\n      return y;\n    }\n  }\n\n};\n\nexport {\n  sqrt\n};\n\nexport {\n  sqrt as squareRoot\n};\n\nexport {\n  Mathematics as default,\n  sqrt as squareRoot\n};\n\nexport * from 'underscore';\n\nexport {\n  max,\n  min\n} from 'underscore';\n\nexport {\n  version\n} from './package.json' assert {\n    type: 'json'\n  };\n```\n\n[Dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports) is also supported, with mandatory parentheses:\n\n``` coffeescript\n# Your browser must support dynamic import to run this example.\n\ndo ->\n  { run } = await import('./browser-compiler-modern/coffeescript.js')\n  run '''\n    if 5 < new Date().getHours() < 9\n      alert 'Time to make the coffee!'\n    else\n      alert 'Time to get some work done.'\n  '''\n```\n\n``` javascript\n// Your browser must support dynamic import to run this example.\n(async function() {\n  var run;\n  ({run} = (await import('./browser-compiler-modern/coffeescript.js')));\n  return run(`if 5 < new Date().getHours() < 9\n  alert 'Time to make the coffee!'\nelse\n  alert 'Time to get some work done.'`);\n})();\n```\n\nNote that the CoffeeScript compiler **does not resolve modules**; writing an `import` or `export` statement in CoffeeScript will produce an `import` or `export` statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via `<script type=\"module\">`) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output `.js` files are in a folder where the nearest parent `package.json` file contains `\"type\": \"module\"`. Because the runtime is evaluating the generated output, the `import` statements must reference the output files; so if `file.coffee` is output as `file.js`, it needs to be referenced as `file.js` in the `import` statement, with the `.js` extension included.\n\nAlso, any file with an `import` or `export` statement will be output without a [top-level function safety wrapper](#lexical-scope); in other words, importing or exporting modules will automatically trigger [bare](#usage) mode for that file. This is because per the ES2015 spec, `import` or `export` statements must occur at the topmost scope.\n\n## Embedded JavaScript\n\nHopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.\n\n``` coffeescript\nhi = `function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n}`\n```\n\n``` javascript\nvar hi;\n\nhi = function() {\n  return [document.title, \"Hello JavaScript\"].join(\": \");\n};\n```\n\nEscape backticks with backslashes: ``  \\`​ `` becomes ``  `​ ``.\n\nEscape backslashes before backticks with more backslashes: ``  \\\\\\`​ `` becomes ``  \\`​ ``.\n\n``` coffeescript\nmarkdown = `function () {\n  return \\`In Markdown, write code like \\\\\\`this\\\\\\`\\`;\n}`\n```\n\n``` javascript\nvar markdown;\n\nmarkdown = function () {\n  return `In Markdown, write code like \\`this\\``;\n};\n```\n\nYou can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.\n\n```` coffeescript\n```\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n```\n````\n\n``` javascript\nfunction time() {\n  return `The time is ${new Date().toLocaleTimeString()}`;\n}\n;\n```\n\n## JSX\n\n[JSX](https://facebook.github.io/react/docs/introducing-jsx.html) is JavaScript containing interspersed XML elements. While conceived for [React](https://facebook.github.io/react/), it is not specific to any particular library or framework.\n\nCoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by [Babel with the React JSX transform](https://babeljs.io/docs/plugins/transform-react-jsx/). CoffeeScript does *not* output `React.createElement` calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.\n\nJust like in JSX and HTML, denote XML tags using `<` and `>`. You can interpolate CoffeeScript code inside a tag using `{` and `}`. To avoid compiler errors, when using `<` and `>` to mean “less than” or “greater than,” you should wrap the operators in spaces to distinguish them from XML tags. So `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n``` coffeescript\nrenderStarRating = ({ rating, maxStars }) ->\n  <aside title={\"Rating: #{rating} of #{maxStars} stars\"}>\n    {for wholeStar in [0...Math.floor(rating)]\n      <Star className=\"wholeStar\" key={wholeStar} />}\n    {if rating % 1 isnt 0\n      <Star className=\"halfStar\" />}\n    {for emptyStar in [Math.ceil(rating)...maxStars]\n      <Star className=\"emptyStar\" key={emptyStar} />}\n  </aside>\n```\n\n``` javascript\nvar renderStarRating;\n\nrenderStarRating = function({rating, maxStars}) {\n  var emptyStar, wholeStar;\n  return <aside title={`Rating: ${rating} of ${maxStars} stars`}>\n    {(function() {\n    var i, ref, results;\n    results = [];\n    for (wholeStar = i = 0, ref = Math.floor(rating); (0 <= ref ? i < ref : i > ref); wholeStar = 0 <= ref ? ++i : --i) {\n      results.push(<Star className=\"wholeStar\" key={wholeStar} />);\n    }\n    return results;\n  })()}\n    {rating % 1 !== 0 ? <Star className=\"halfStar\" /> : void 0}\n    {(function() {\n    var i, ref, ref1, results;\n    results = [];\n    for (emptyStar = i = ref = Math.ceil(rating), ref1 = maxStars; (ref <= ref1 ? i < ref1 : i > ref1); emptyStar = ref <= ref1 ? ++i : --i) {\n      results.push(<Star className=\"emptyStar\" key={emptyStar} />);\n    }\n    return results;\n  })()}\n  </aside>;\n};\n```\n\nOlder plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a `.cjsx` file extension, but this is no longer necessary; regular `.coffee` will do.\n\n## Type Annotations\n\nStatic type checking can be achieved in CoffeeScript by using [Flow](https://flow.org/)’s [Comment Types syntax](https://flow.org/en/docs/types/comments/):\n\n``` coffeescript\n# @flow\n\n###::\ntype Obj = {\n  num: number,\n};\n###\n\nfn = (str ###: string ###, obj ###: Obj ###) ###: string ### ->\n  str + obj.num\n```\n\n``` javascript\n// @flow\n/*::\ntype Obj = {\n  num: number,\n};\n*/\nvar fn;\n\nfn = function(str/*: string */, obj/*: Obj */)/*: string */ {\n  return str + obj.num;\n};\n```\n\nCoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a [build tool](#es2015plus-output) for this, but here’s how to do it the simplest way possible using the [CoffeeScript](#cli) and [Flow](https://flow.org/en/docs/usage/) command-line tools, assuming you’ve already [installed Flow](https://flow.org/en/docs/install/) and the [latest CoffeeScript](#installation) in your project folder:\n\n    coffee --bare --no-header --compile app.coffee && npm run flow\n\n`--bare` and `--no-header` are important because Flow requires the first line of the file to be the comment `// @flow`. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.\n\nIf you know of another way to achieve static type checking with CoffeeScript, please [create an issue](https://github.com/jashkenas/coffeescript/issues/new) and let us know.\n\n## Literate CoffeeScript\n\nBesides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a `.litcoffee` extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.\n\nJust for kicks, a little bit of the compiler is currently implemented in this fashion: See it [as a document](https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df), [raw](https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee), and [properly highlighted in a text editor](https://cl.ly/LxEu).\n\nA few caveats:\n\n- Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don’t exist, with consistent indentation (including whether they are indented with tabs or spaces).\n- Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.\n- List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.\n\n## Source Maps\n\nCoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the `--map` or `-m` flag to the compiler.\n\nFor a full introduction to source maps, how they work, and how to hook them up in your browser, read the [HTML5 Tutorial](https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/).\n\n## Cake, and Cakefiles\n\nCoffeeScript includes a (very) simple build system similar to [Make](https://www.gnu.org/software/make/) and [Rake](http://rake.rubyforge.org/). Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named `Cakefile`, and can be invoked by running `cake [task]` from within the directory. To print a list of all the tasks and options, just type `cake`.\n\nTask definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the `options` object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:\n\n``` coffeescript\nfs = require 'fs'\n\noption '-o', '--output [DIR]', 'directory for compiled code'\n\ntask 'build:parser', 'rebuild the Jison parser', (options) ->\n  require 'jison'\n  code = require('./lib/grammar').parser.generate()\n  dir  = options.output or 'lib'\n  fs.writeFile \"#{dir}/parser.js\", code\n```\n\n``` javascript\nvar fs;\n\nfs = require('fs');\n\noption('-o', '--output [DIR]', 'directory for compiled code');\n\ntask('build:parser', 'rebuild the Jison parser', function(options) {\n  var code, dir;\n  require('jison');\n  code = require('./lib/grammar').parser.generate();\n  dir = options.output || 'lib';\n  return fs.writeFile(`${dir}/parser.js`, code);\n});\n```\n\nIf you need to invoke one task before another — for example, running `build` before `test`, you can use the `invoke` function: `invoke 'build'`. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so [don’t expect any fanciness built-in](https://coffeescript.org/v2/annotated-source/cake.html). If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.\n\n## `\"text/coffeescript\"` Script Tags\n\nWhile it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using `<script type=\"text/coffeescript\">` tags. The source includes a compressed and minified version of the compiler ([Download current version here, 77k when gzipped](https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js)) as `docs/v2/browser-compiler-legacy/coffeescript.js`. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.\n\nThe usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the `window` object.\n\n## Integrations\n\nCoffeeScript is part of the vast JavaScript ecosystem, and many libraries help integrate CoffeeScript with JavaScript. Major projects, especially projects updated to work with CoffeeScript 2, are listed here; more can be found in the [wiki pages](https://github.com/jashkenas/coffeescript/wiki). If there’s a project that you feel should be added to this section, please open an issue or [pull request](https://github.com/jashkenas/coffeescript/wiki/%5BHowTo%5D-Update-the-docs). Projects are listed in alphabetical order by category.\n\n### Build Tools\n\n- [Browserify](http://browserify.org) with [coffeeify](https://github.com/jnordberg/coffeeify)\n\n- [Grunt](https://gruntjs.com) with [grunt-contrib-coffee](https://github.com/gruntjs/grunt-contrib-coffee)\n\n- [Gulp](https://gulpjs.com) with [gulp-coffee](https://github.com/gulp-community/gulp-coffee)\n\n- [Parcel](https://parceljs.org) with [transformer-coffeescript](https://github.com/parcel-bundler/parcel/tree/v2/packages/transformers/coffeescript)\n\n- [Rollup](https://rollupjs.org) with [rollup-plugin-coffee-script](https://github.com/lautis/rollup-plugin-coffee-script)\n\n- [Webpack](https://webpack.js.org) with [coffee-loader](https://github.com/webpack-contrib/coffee-loader)\n\n### Code Editors\n\n- [Atom](https://atom.io) [packages](https://atom.io/packages/search?q=coffeescript)\n\n- [Sublime Text](https://sublimetext.com) [packages](https://packagecontrol.io/search/coffeescript)\n\n- [Visual Studio Code](https://code.visualstudio.com) [extensions](https://marketplace.visualstudio.com/search?target=VSCode&term=coffeescript)\n\n### Frameworks\n\n- [Ember](https://emberjs.com) with [ember-cli-coffeescript](https://github.com/kimroen/ember-cli-coffeescript)\n\n- [Meteor](https://meteor.com) with [coffeescript-compiler](https://atmospherejs.com/meteor/coffeescript-compiler)\n\n### Linters and Formatting\n\n- [CoffeeLint](https://coffeelint.github.io/)\n\n- [ESLint](https://eslint.org) with [eslint-plugin-coffee](https://github.com/helixbass/eslint-plugin-coffee)\n\n- [Prettier](https://prettier.io) with [prettier-plugin-coffeescript](https://github.com/helixbass/prettier-plugin-coffeescript)\n\n### Testing\n\n- [Jest](https://jestjs.io) with [jest-preset-coffeescript](https://github.com/danielbayley/jest-preset-coffeescript)\n\n## Unsupported ECMAScript Features\n\nThere are a few ECMAScript features that CoffeeScript intentionally doesn’t support.\n\n### `let` and `const`: block-scoped and reassignment-protected variables\n\nWhen CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.\n\n`let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.\n\nKeep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:\n\n``` coffeescript\nconst obj = {foo: 'bar'};\nobj.foo = 'baz'; // Allowed!\nobj = {}; // Throws error\n```\n\n### Named functions and function declarations\n\nNewcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).\n\nTechnically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.\n\n### `get` and `set` keyword shorthand syntax\n\n`get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.\n\nThis is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:\n\n``` coffeescript\nscreen =\n  width: 1200\n  ratio: 16/9\n\nObject.defineProperty screen, 'height',\n  get: ->\n    this.width / this.ratio\n  set: (val) ->\n    this.width = val * this.ratio\n```\n\n``` javascript\nvar screen;\n\nscreen = {\n  width: 1200,\n  ratio: 16 / 9\n};\n\nObject.defineProperty(screen, 'height', {\n  get: function() {\n    return this.width / this.ratio;\n  },\n  set: function(val) {\n    return this.width = val * this.ratio;\n  }\n});\n```\n\n## Breaking Changes From CoffeeScript 1.x to 2\n\nCoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.\n\n### Bound (fat arrow) functions\n\nIn CoffeeScript 1.x, `=>` compiled to a regular `function` but with references to `this`/`@` rewritten to use the outer scope’s `this`, or with the inner function bound to the outer scope via `.bind` (hence the name “bound function”). In CoffeeScript 2, `=>` compiles to [ES2015’s `=>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), which behaves slightly differently. The largest difference is that in ES2015, `=>` functions lack an `arguments` object:\n\n``` coffeescript\nouter = ->\n  inner = => Array.from arguments\n  inner()\n\nouter(1, 2)  # Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n``` javascript\nvar outer;\n\nouter = function() {\n  var inner;\n  inner = () => {\n    return Array.from(arguments);\n  };\n  return inner();\n};\n\nouter(1, 2); // Returns '' in CoffeeScript 1.x, '1, 2' in CoffeeScript 2\n```\n\n### Default values for function parameters and destructured elements\n\nPer the [ES2015 spec regarding function default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) and [destructuring default values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values), default values are only applied when a value is missing or `undefined`. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was `null`.\n\n``` coffeescript\nf = (a = 1) -> a\n\nf(null)  # Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar f;\n\nf = function(a = 1) {\n  return a;\n};\n\nf(null); // Returns 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` coffeescript\n{a = 1} = {a: null}\n\na  # Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n``` javascript\nvar a;\n\n({a = 1} = {\n  a: null\n});\n\na; // Equals 1 in CoffeeScript 1.x, null in CoffeeScript 2\n```\n\n### Bound generator functions\n\nBound generator functions, a.k.a. generator arrow functions, [aren’t allowed in ECMAScript](https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation). You can write `function*` or `=>`, but not both. Therefore, CoffeeScript code like this:\n\n``` coffeescript\nf = => yield this\n# Throws a compiler error\n```\n\nNeeds to be rewritten the old-fashioned way:\n\n``` coffeescript\nself = this\nf = -> yield self\n```\n\n``` javascript\nvar f, self;\n\nself = this;\n\nf = function*() {\n  return (yield self);\n};\n```\n\n### Classes are compiled to ES2015 classes\n\nES2015 classes and their methods have some restrictions beyond those on regular functions.\n\nClass constructors can’t be invoked without `new`:\n\n``` coffeescript\n(class)()\n# Throws a TypeError at runtime\n```\n\nES2015 classes don’t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can’t be accommodated is calling a bound method before it is bound:\n\n``` coffeescript\nclass Base\n  constructor: ->\n    @onClick()      # This works\n    clickHandler = @onClick\n    clickHandler()  # This throws a runtime error\n\nclass Component extends Base\n  onClick: =>\n    console.log 'Clicked!', @\n```\n\nClass methods can’t be used with `new` (uncommon):\n\n``` coffeescript\nclass Namespace\n  @Klass = ->\nnew Namespace.Klass  # Throws a TypeError at runtime\n```\n\nDue to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can’t use values from the executable class body unless the methods are assigned in prototype style.\n\n``` coffeescript\nclass A\n  name = 'method'\n  \"#{name}\": ->   # This method will be named 'undefined'\n  @::[name] = ->  # This will work; assigns to `A.prototype.method`\n```\n\n### `super` and `this`\n\nIn the constructor of a derived class (a class that `extends` another class), `this` cannot be used before calling `super`:\n\n``` coffeescript\nclass B extends A\n  constructor: -> this  # Throws a compiler error\n```\n\nThis also means you cannot pass a reference to `this` as an argument to `super` in the constructor of a derived class:\n\n``` coffeescript\nclass B extends A\n  constructor: (@arg) ->\n    super @arg  # Throws a compiler error\n```\n\nThis is a limitation of ES2015 classes. As a workaround, assign to `this` after the `super` call:\n\n``` coffeescript\nclass B extends A\n  constructor: (arg) ->\n    super arg\n    @arg = arg\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  constructor(arg) {\n    super(arg);\n    this.arg = arg;\n  }\n\n};\n```\n\n### `super` and `extends`\n\nDue to a syntax clash with `super` with accessors, “bare” `super` (the keyword `super` without parentheses) no longer compiles to a super call forwarding all arguments.\n\n``` coffeescript\nclass B extends A\n  foo: -> super\n  # Throws a compiler error\n```\n\nArguments can be forwarded explicitly using splats:\n\n``` coffeescript\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\nOr if you know that the parent function doesn’t require arguments, just call `super()`:\n\n``` coffeescript\nclass B extends A\n  foo: -> super()\n```\n\n``` javascript\nvar B;\n\nB = class B extends A {\n  foo() {\n    return super.foo();\n  }\n\n};\n```\n\nCoffeeScript 1.x allowed the `extends` keyword to set up prototypal inheritance between functions, and `super` could be used manually prototype-assigned functions:\n\n``` coffeescript\nA = ->\nB = ->\nB extends A\nB.prototype.foo = -> super arguments...\n# Last two lines each throw compiler errors in CoffeeScript 2\n```\n\nDue to the switch to ES2015 `extends` and `super`, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:\n\n``` coffeescript\n# Helper functions\nhasProp = {}.hasOwnProperty\nextend = (child, parent) ->\n  ctor = ->\n    @constructor = child\n    return\n  for key of parent\n    if hasProp.call(parent, key)\n      child[key] = parent[key]\n  ctor.prototype = parent.prototype\n  child.prototype = new ctor\n  child\n\n\nA = ->\nB = ->\nextend B, A\nB.prototype.foo = -> A::foo.apply this, arguments\n```\n\n``` javascript\n// Helper functions\nvar A, B, extend, hasProp;\n\nhasProp = {}.hasOwnProperty;\n\nextend = function(child, parent) {\n  var ctor, key;\n  ctor = function() {\n    this.constructor = child;\n  };\n  for (key in parent) {\n    if (hasProp.call(parent, key)) {\n      child[key] = parent[key];\n    }\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  return child;\n};\n\nA = function() {};\n\nB = function() {};\n\nextend(B, A);\n\nB.prototype.foo = function() {\n  return A.prototype.foo.apply(this, arguments);\n};\n```\n\nor\n\n``` coffeescript\nclass A\nclass B extends A\n  foo: -> super arguments...\n```\n\n``` javascript\nvar A, B;\n\nA = class A {};\n\nB = class B extends A {\n  foo() {\n    return super.foo(...arguments);\n  }\n\n};\n```\n\n### JSX and the `<` and `>` operators\n\nWith the addition of [JSX](#jsx), the `<` and `>` characters serve as both the “less than” and “greater than” operators and as the delimiters for XML tags, like `<div>`. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: `i < len`, not `i<len`. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the “less than” and “greater than” operators will remove ambiguity.\n\n### Literate CoffeeScript parsing\n\nCoffeeScript 2’s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.\n\nCode blocks should also now maintain a consistent indentation level—so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code’s “left margin,” with all code in the file relative to that column.\n\nCode blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.\n\n### Argument parsing and shebang (`#!`) lines\n\nIn CoffeeScript 1.x, `--` was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:\n\n    coffee [options] path/to/script.coffee -- [args]\n\nNow you would just type:\n\n    coffee [options] path/to/script.coffee [args]\n\nThe deprecated version will still work, but it will print a warning before running the script.\n\nOn non-Windows platforms, a `.coffee` file can be made executable by adding a shebang (`#!`) line at the top of the file and marking the file as executable. For example:\n\n``` coffeescript\n#!/usr/bin/env coffee\n\nx = 2 + 2\nconsole.log x\n```\n\nIf this were saved as `executable.coffee`, it could be made executable and run:\n\n``` coffeescript\n▶ chmod +x ./executable.coffee\n▶ ./executable.coffee\n4\n```\n\nIn CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using `#!/usr/bin/env coffee --` as the first line of the file. That didn’t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing `--`, we recommend simply changing the shebang lines in such scripts to just `#!/usr/bin/env coffee`.\n\n© 2009–2022 Jeremy Ashkenas  \nLicensed under the MIT License.  \n[https://coffeescript.org/](https://coffeescript.org/)"
- name: Try/Catch/Finally
  id: index#try-catch
  summary: try expressions have the same semantics as try statements in JavaScript, though in CoffeeScript, you may omit both the catch and finally parts
  description: |-
    ## Try/Catch/Finally

    `try` expressions have the same semantics as `try` statements in JavaScript, though in CoffeeScript, you may omit *both* the catch and finally parts. The catch part may also omit the error parameter if it is not needed.

    ``` coffeescript
    try
      allHellBreaksLoose()
      catsAndDogsLivingTogether()
    catch error
      print error
    finally
      cleanUp()
    ```

    ``` javascript
    var error;

    try {
      allHellBreaksLoose();
      catsAndDogsLivingTogether();
    } catch (error1) {
      error = error1;
      print(error);
    } finally {
      cleanUp();
    }
    ```
- name: Unsupported ECMAScript Features
  id: index#unsupported
  summary: There are a few ECMAScript features that CoffeeScript intentionally doesn’t support
  description: |-
    ## Unsupported ECMAScript Features

    There are a few ECMAScript features that CoffeeScript intentionally doesn’t support.

    ### `let` and `const`: block-scoped and reassignment-protected variables

    When CoffeeScript was designed, `var` was [intentionally omitted](https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502). This was to spare developers the mental housekeeping of needing to worry about variable *declaration* (`var foo`) as opposed to variable *assignment* (`foo = 1`). The CoffeeScript compiler automatically takes care of declaration for you, by generating `var` statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.

    `let` and `const` add a useful ability to JavaScript in that you can use them to declare variables within a *block* scope, for example within an `if` statement body or a `for` loop body, whereas `var` always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.

    Keep in mind that `const` only protects you from *reassigning* a variable; it doesn’t prevent the variable’s value from changing, the way constants usually do in other languages:

    ``` coffeescript
    const obj = {foo: 'bar'};
    obj.foo = 'baz'; // Allowed!
    obj = {}; // Throws error
    ```

    ### Named functions and function declarations

    Newcomers to CoffeeScript often wonder how to generate the JavaScript `function foo() {}`, as opposed to the `foo = function() {}` that CoffeeScript produces. The first form is a [function declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function), and the second is a [function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function). As stated above, in CoffeeScript [everything is an expression](#expressions), so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the [subtle differences between the two forms](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting).

    Technically, `foo = function() {}` is creating an anonymous function that gets assigned to a variable named `foo`. Some very early versions of CoffeeScript named this function, e.g. `foo = function foo() {}`, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes [infer the names of such anonymous functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name) from the names of the variables to which they’re assigned. Given that this is the case, it’s simplest to just preserve the current behavior.

    ### `get` and `set` keyword shorthand syntax

    `get` and `set`, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.

    This is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. `get(function foo() {})`); and because there is an [alternate syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) that is slightly more verbose but just as effective:

    ``` coffeescript
    screen =
      width: 1200
      ratio: 16/9

    Object.defineProperty screen, 'height',
      get: ->
        this.width / this.ratio
      set: (val) ->
        this.width = val * this.ratio
    ```

    ``` javascript
    var screen;

    screen = {
      width: 1200,
      ratio: 16 / 9
    };

    Object.defineProperty(screen, 'height', {
      get: function() {
        return this.width / this.ratio;
      },
      set: function(val) {
        return this.width = val * this.ratio;
      }
    });
    ```
- name: Usage
  id: index#usage
  summary: null
  description: '## Usage'
