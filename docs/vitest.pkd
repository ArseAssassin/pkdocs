---
name: Vitest
slug: vitest
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2021-Present Anthony Fu
  © 2021-Present Matias Capeletto
  Licensed under the MIT License.
  https://vitest.dev/
homepage: https://vitest.dev/

---
- name: afterAll ​
  id: api/index#afterall
  summary: Register a callback to be called once after all tests have run in the current context
  belongs_to: Test API Reference
  description: |-
    ### afterAll

    - **Type:** `afterAll(fn: () => Awaitable<void>, timeout?: number)`

    Register a callback to be called once after all tests have run in the current context. If the function returns a promise, Vitest waits until the promise resolve before continuing.

    Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.

    ts

    ``` javascript
    import { afterAll } from 'vitest'

    afterAll(async () => {
      await stopMocking() // this method is called after all tests run
    })
    ```

    Here the `afterAll` ensures that `stopMocking` method is called after all tests run.
- name: afterEach ​
  id: api/index#aftereach
  summary: Register a callback to be called after each one of the tests in the current context completes
  belongs_to: Test API Reference
  description: |-
    ### afterEach

    - **Type:** `afterEach(fn: () => Awaitable<void>, timeout?: number)`

    Register a callback to be called after each one of the tests in the current context completes. If the function returns a promise, Vitest waits until the promise resolve before continuing.

    Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.

    ts

    ``` javascript
    import { afterEach } from 'vitest'

    afterEach(async () => {
      await clearTestingData() // clear testing data after each test run
    })
    ```

    Here, the `afterEach` ensures that testing data is cleared after each test runs.

    **TIP**

    Vitest 1.3.0 added [`onTestFinished`](#ontestfinished) hook. You can call it during the test execution to cleanup any state after the test has finished running.
- name: alias ​
  id: config/index#alias
  summary: Define custom aliases when running inside tests
  belongs_to: Configuring Vitest
  description: |-
    ### alias

    - **Type:** `Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`

    Define custom aliases when running inside tests. They will be merged with aliases from `resolve.alias`.

    **WARNING**

    Vitest uses Vite SSR primitives to run tests which has [certain pitfalls](https://vitejs.dev/guide/ssr.html#ssr-externals).

    1.  Aliases affect only modules imported directly with an `import` keyword by an [inlined](#server-deps-inline) module (all source code is inlined by default).
    2.  Vitest does not support aliasing `require` calls.
    3.  If you are aliasing an external dependency (e.g., `react` -\> `preact`), you may want to alias the actual `node_modules` packages instead to make it work for externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.
- name: allowOnly ​
  id: config/index#allowonly
  summary: Allow tests and suites that are marked as only
  belongs_to: Configuring Vitest
  description: |-
    ### allowOnly

    - **Type**: `boolean`
    - **Default**: `!process.env.CI`
    - **CLI:**`--allowOnly`, `--allowOnly=false`

    Allow tests and suites that are marked as only.
- name: api ​
  id: config/index#api
  summary: Listen to port and serve API
  belongs_to: Configuring Vitest
  description: |-
    ### api

    - **Type:** `boolean | number`
    - **Default:** `false`
    - **CLI:**`--api`, `--api.port`, `--api.host`, `--api.strictPort`

    Listen to port and serve API. When set to true, the default port is 51204
- name: assert
  id: api/assert
  summary: Vitest reexports the assert method from chai for verifying invariants
  description: "# assert\n\nVitest reexports the `assert` method from [`chai`](https://www.chaijs.com/api/assert/) for verifying invariants.\n\n## assert\n\n- **Type:** `(expression: any, message?: string) => asserts expression`\n\nAssert that the given `expression` is truthy, otherwise the assertion fails.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert', () => {\n  assert('foo' !== 'bar', 'foo should not be equal to bar')\n})\n```\n\n## fail\n\n- **Type:**\n  - `(message?: string) => never`\n  - `<T>(actual: T, expected: T, message?: string, operator?: string) => never`\n\nForce an assertion failure.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.fail', () => {\n  assert.fail('error message on failure')\n  assert.fail('foo', 'bar', 'foo is not bar', '===')\n})\n```\n\n## isOk\n\n- **Type:** `<T>(value: T, message?: string) => void`\n- **Alias** `ok`\n\nAssert that the given `value` is truthy.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isOk', () => {\n  assert.isOk('foo', 'every truthy is ok')\n  assert.isOk(false, 'this will fail since false is not truthy')\n})\n```\n\n## isNotOk\n\n- **Type:** `<T>(value: T, message?: string) => void`\n- **Alias** `notOk`\n\nAssert that the given `value` is falsy.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotOk', () => {\n  assert.isNotOk('foo', 'this will fail, every truthy is not ok')\n  assert.isNotOk(false, 'this will pass since false is falsy')\n})\n```\n\n## equal\n\n- **Type:** `<T>(actual: T, expected: T, message?: string) => void`\n\nAsserts non-strict equality (==) of `actual` and `expected`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.equal', () => {\n  assert.equal(Math.sqrt(4), '2')\n})\n```\n\n## notEqual\n\n- **Type:** `<T>(actual: T, expected: T, message?: string) => void`\n\nAsserts non-strict inequality (!=) of `actual` and `expected`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.equal', () => {\n  assert.notEqual(Math.sqrt(4), 3)\n})\n```\n\n## strictEqual\n\n- **Type:** `<T>(actual: T, expected: T, message?: string) => void`\n\nAsserts strict equality (===) of `actual` and `expected`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.strictEqual', () => {\n  assert.strictEqual(Math.sqrt(4), 2)\n})\n```\n\n## deepEqual\n\n- **Type:** `<T>(actual: T, expected: T, message?: string) => void`\n\nAsserts that `actual` is deeply equal to `expected`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepEqual', () => {\n  assert.deepEqual({ color: 'green' }, { color: 'green' })\n})\n```\n\n## notDeepEqual\n\n- **Type:** `<T>(actual: T, expected: T, message?: string) => void`\n\nAssert that `actual` is not deeply equal to `expected`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepEqual', () => {\n  assert.notDeepEqual({ color: 'green' }, { color: 'red' })\n})\n```\n\n## isAbove\n\n- **Type:** `(valueToCheck: number, valueToBeAbove: number, message?: string) => void`\n\nAssert that `valueToCheck` is strictly greater than (\\>) `valueToBeAbove`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isAbove', () => {\n  assert.isAbove(5, 2, '5 is strictly greater than 2')\n})\n```\n\n## isAtLeast\n\n- **Type:** `(valueToCheck: number, valueToBeAtLeast: number, message?: string) => void`\n\nAssert that `valueToCheck` is greater than or equal to (\\>=) `valueToBeAtLeast`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isAtLeast', () => {\n  assert.isAtLeast(5, 2, '5 is greater or equal to 2')\n  assert.isAtLeast(3, 3, '3 is greater or equal to 3')\n})\n```\n\n## isBelow\n\n- **Type:** `(valueToCheck: number, valueToBeBelow: number, message?: string) => void`\n\nAsserts `valueToCheck` is strictly less than (\\<) `valueToBeBelow`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isBelow', () => {\n  assert.isBelow(3, 6, '3 is strictly less than 6')\n})\n```\n\n## isAtMost\n\n- **Type:** `(valueToCheck: number, valueToBeAtMost: number, message?: string) => void`\n\nAsserts `valueToCheck` is less than or equal to (\\<=) `valueToBeAtMost`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isAtMost', () => {\n  assert.isAtMost(3, 6, '3 is less than or equal to 6')\n  assert.isAtMost(4, 4, '4 is less than or equal to 4')\n})\n```\n\n## isTrue\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is true.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst testPassed = true\n\ntest('assert.isTrue', () => {\n  assert.isTrue(testPassed)\n})\n```\n\n## isNotTrue\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not true.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst testPassed = 'ok'\n\ntest('assert.isNotTrue', () => {\n  assert.isNotTrue(testPassed)\n})\n```\n\n## isFalse\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is false.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst testPassed = false\n\ntest('assert.isFalse', () => {\n  assert.isFalse(testPassed)\n})\n```\n\n## isNotFalse\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not false.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst testPassed = 'no'\n\ntest('assert.isNotFalse', () => {\n  assert.isNotFalse(testPassed)\n})\n```\n\n## isNull\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is null.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst error = null\n\ntest('assert.isNull', () => {\n  assert.isNull(error, 'error is null')\n})\n```\n\n## isNotNull\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not null.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst error = { message: 'error was occured' }\n\ntest('assert.isNotNull', () => {\n  assert.isNotNull(error, 'error is not null but object')\n})\n```\n\n## isNaN\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is NaN.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst calculation = 1 * 'viitest'\n\ntest('assert.isNaN', () => {\n  assert.isNaN(calculation, '1 * \"vitest\" is NaN')\n})\n```\n\n## isNotNaN\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not NaN.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst calculation = 1 * 2\n\ntest('assert.isNotNaN', () => {\n  assert.isNotNaN(calculation, '1 * 2 is Not NaN but 2')\n})\n```\n\n## exists\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is neither null nor undefined.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst name = 'foo'\n\ntest('assert.exists', () => {\n  assert.exists(name, 'foo is neither null nor undefined')\n})\n```\n\n## notExists\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is either null nor undefined.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst foo = null\nconst bar = undefined\n\ntest('assert.notExists', () => {\n  assert.notExists(foo, 'foo is null so not exist')\n  assert.notExists(bar, 'bar is undefined so not exist')\n})\n```\n\n## isUndefined\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is undefined.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst name = undefined\n\ntest('assert.isUndefined', () => {\n  assert.isUndefined(name, 'name is undefined')\n})\n```\n\n## isDefined\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not undefined.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst name = 'foo'\n\ntest('assert.isDefined', () => {\n  assert.isDefined(name, 'name is not undefined')\n})\n```\n\n## isFunction\n\n- **Type:** `<T>(value: T, message?: string) => void`\n- **Alias:** `isCallable` Asserts that `value` is a function.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nfunction name() { return 'foo' };\n\ntest('assert.isFunction', () => {\n  assert.isFunction(name, 'name is function')\n})\n```\n\n## isNotFunction\n\n- **Type:** `<T>(value: T, message?: string) => void`\n- **Alias:** `isNotCallable`\n\nAsserts that `value` is not a function.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst name = 'foo'\n\ntest('assert.isNotFunction', () => {\n  assert.isNotFunction(name, 'name is not function but string')\n})\n```\n\n## isObject\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is an object of type Object (as revealed by Object.prototype.toString). The assertion does not match subclassed objects.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst someThing = { color: 'red', shape: 'circle' }\n\ntest('assert.isObject', () => {\n  assert.isObject(someThing, 'someThing is object')\n})\n```\n\n## isNotObject\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not an object of type Object (as revealed by Object.prototype.toString). The assertion does not match subclassed objects.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst someThing = 'redCircle'\n\ntest('assert.isNotObject', () => {\n  assert.isNotObject(someThing, 'someThing is not object but string')\n})\n```\n\n## isArray\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is an array.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst color = ['red', 'green', 'yellow']\n\ntest('assert.isArray', () => {\n  assert.isArray(color, 'color is array')\n})\n```\n\n## isNotArray\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not an array.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst color = 'red'\n\ntest('assert.isNotArray', () => {\n  assert.isNotArray(color, 'color is not array but string')\n})\n```\n\n## isString\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is a string.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst color = 'red'\n\ntest('assert.isString', () => {\n  assert.isString(color, 'color is string')\n})\n```\n\n## isNotString\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not a string.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst color = ['red', 'green', 'yellow']\n\ntest('assert.isNotString', () => {\n  assert.isNotString(color, 'color is not string but array')\n})\n```\n\n## isNumber\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is a number.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst colors = 3\n\ntest('assert.isNumber', () => {\n  assert.isNumber(colors, 'colors is number')\n})\n```\n\n## isNotNumber\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not a number.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst colors = '3 colors'\n\ntest('assert.isNotNumber', () => {\n  assert.isNotNumber(colors, 'colors is not number but strings')\n})\n```\n\n## isFinite\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is a finite number (not NaN, Infinity).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst colors = 3\n\ntest('assert.isFinite', () => {\n  assert.isFinite(colors, 'colors is number not NaN or Infinity')\n})\n```\n\n## isBoolean\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is a boolean.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst isReady = true\n\ntest('assert.isBoolean', () => {\n  assert.isBoolean(isReady, 'isReady is a boolean')\n})\n```\n\n## isNotBoolean\n\n- **Type:** `<T>(value: T, message?: string) => void`\n\nAsserts that `value` is not a boolean.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst isReady = 'sure'\n\ntest('assert.isBoolean', () => {\n  assert.isBoolean(isReady, 'isReady is not a boolean but string')\n})\n```\n\n## typeOf\n\n- **Type:** `<T>(value: T, name: string, message?: string) => void`\n\nAsserts that `value`’s type is `name`, as determined by Object.prototype.toString.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.typeOf', () => {\n  assert.typeOf({ color: 'red' }, 'object', 'we have an object')\n  assert.typeOf(['red', 'green'], 'array', 'we have an array')\n  assert.typeOf('red', 'string', 'we have a string')\n  assert.typeOf(/red/, 'regexp', 'we have a regular expression')\n  assert.typeOf(null, 'null', 'we have a null')\n  assert.typeOf(undefined, 'undefined', 'we have an undefined')\n})\n```\n\n## notTypeOf\n\n- **Type:** `<T>(value: T, name: string, message?: string) => void`\n\nAsserts that `value`’s type is not `name`, as determined by Object.prototype.toString.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notTypeOf', () => {\n  assert.notTypeOf('red', 'number', '\"red\" is not a number')\n})\n```\n\n## instanceOf\n\n- **Type:** `<T>(value: T, constructor: Function, message?: string) => void`\n\nAsserts that `value` is an instance of `constructor`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nfunction Person(name) { this.name = name }\nconst foo = new Person('foo')\n\nclass Tea {\n  constructor(name) {\n    this.name = name\n  }\n}\nconst coffee = new Tea('coffee')\n\ntest('assert.instanceOf', () => {\n  assert.instanceOf(foo, Person, 'foo is an instance of Person')\n  assert.instanceOf(coffee, Tea, 'coffee is an instance of Tea')\n})\n```\n\n## notInstanceOf\n\n- **Type:** `<T>(value: T, constructor: Function, message?: string) => void`\n\nAsserts that `value` is not an instance of `constructor`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nfunction Person(name) { this.name = name }\nconst foo = new Person('foo')\n\nclass Tea {\n  constructor(name) {\n    this.name = name\n  }\n}\nconst coffee = new Tea('coffee')\n\ntest('assert.instanceOf', () => {\n  assert.instanceOf(foo, Tea, 'foo is not an instance of Tea')\n})\n```\n\n## include\n\n- **Type:**\n  - `(haystack: string, needle: string, message?: string) => void`\n  - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`\n  - `<T extends object>(haystack: WeakSet<T>, needle: T, message?: string) => void`\n  - `<T>(haystack: T, needle: Partial<T>, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array, a substring in a string, or a subset of properties in an object.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.include', () => {\n  assert.include([1, 2, 3], 2, 'array contains value')\n  assert.include('foobar', 'foo', 'string contains substring')\n  assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property')\n})\n```\n\n## notInclude\n\n- **Type:**\n  - `(haystack: string, needle: string, message?: string) => void`\n  - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`\n  - `<T extends object>(haystack: WeakSet<T>, needle: T, message?: string) => void`\n  - `<T>(haystack: T, needle: Partial<T>, message?: string) => void`\n\nAsserts that `haystack` does not include `needle`. It can be used to assert the absence of a value in an array, a substring in a string, or a subset of properties in an object.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notInclude', () => {\n  assert.notInclude([1, 2, 3], 4, 'array doesn\\'t contain 4')\n  assert.notInclude('foobar', 'baz', 'foobar doesn\\'t contain baz')\n  assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn\\'t contain property')\n})\n```\n\n## deepInclude\n\n- **Type:**\n- `(haystack: string, needle: string, message?: string) => void`\n- `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`\n- `<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array or a subset of properties in an object. Deep equality is used.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst obj1 = { a: 1 }\nconst obj2 = { b: 2 }\n\ntest('assert.deepInclude', () => {\n  assert.deepInclude([obj1, obj2], { a: 1 })\n  assert.deepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 1 } })\n})\n```\n\n## notDeepInclude\n\n- **Type:**\n  - `(haystack: string, needle: string, message?: string) => void`\n  - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`\n  - `<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string) => void`\n\nAsserts that `haystack` does not include `needle`. It can be used to assert the absence of a value in an array or a subset of properties in an object. Deep equality is used.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst obj1 = { a: 1 }\nconst obj2 = { b: 2 }\n\ntest('assert.notDeepInclude', () => {\n  assert.notDeepInclude([obj1, obj2], { a: 10 })\n  assert.notDeepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 10 } })\n})\n```\n\n## nestedInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.nestedInclude', () => {\n  assert.nestedInclude({ '.a': { b: 'x' } }, { '\\\\.a.[b]': 'x' })\n  assert.nestedInclude({ a: { '[b]': 'x' } }, { 'a.\\\\[b\\\\]': 'x' })\n})\n```\n\n## notNestedInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` does not include `needle`. Can be used to assert the inclusion of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.nestedInclude', () => {\n  assert.notNestedInclude({ '.a': { b: 'x' } }, { '\\\\.a.b': 'y' })\n  assert.notNestedInclude({ a: { '[b]': 'x' } }, { 'a.\\\\[b\\\\]': 'y' })\n})\n```\n\n## deepNestedInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepNestedInclude', () => {\n  assert.deepNestedInclude({ a: { b: [{ x: 1 }] } }, { 'a.b[0]': { x: 1 } })\n  assert.deepNestedInclude({ '.a': { '[b]': { x: 1 } } }, { '\\\\.a.\\\\[b\\\\]': { x: 1 } })\n})\n```\n\n## notDeepNestedInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` not includes `needle`. Can be used to assert the absence of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\\[\\]’ and ‘.’ in property names can be escaped using double backslashes.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepNestedInclude', () => {\n  assert.notDeepNestedInclude({ a: { b: [{ x: 1 }] } }, { 'a.b[0]': { y: 1 } })\n  assert.notDeepNestedInclude({ '.a': { '[b]': { x: 1 } } }, { '\\\\.a.\\\\[b\\\\]': { y: 2 } })\n})\n```\n\n## ownInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.ownInclude', () => {\n  assert.ownInclude({ a: 1 }, { a: 1 })\n})\n```\n\n## notOwnInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst obj1 = {\n  b: 2\n}\n\nconst obj2 = object.create(obj1)\nobj2.a = 1\n\ntest('assert.notOwnInclude', () => {\n  assert.notOwnInclude(obj2, { b: 2 })\n})\n```\n\n## deepOwnInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep equality.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepOwnInclude', () => {\n  assert.deepOwnInclude({ a: { b: 2 } }, { a: { b: 2 } })\n})\n```\n\n## notDeepOwnInclude\n\n- **Type:** `(haystack: any, needle: any, message?: string) => void`\n\nAsserts that `haystack` not includes `needle`. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepOwnInclude', () => {\n  assert.notDeepOwnInclude({ a: { b: 2 } }, { a: { c: 3 } })\n})\n```\n\n## match\n\n- **Type:** `(value: string, regexp: RegExp, message?: string) => void`\n\nAsserts that `value` matches the regular expression `regexp`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.match', () => {\n  assert.match('foobar', /^foo/, 'regexp matches')\n})\n```\n\n## notMatch\n\n- **Type:** `(value: string, regexp: RegExp, message?: string) => void`\n\nAsserts that `value` does not matches the regular expression `regexp`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notMatch', () => {\n  assert.notMatch('foobar', /^foo/, 'regexp does not match')\n})\n```\n\n## property\n\n- **Type:** `<T>(object: T, property: string, message?: string) => void`\n\nAsserts that `object` has a direct or inherited property named by `property`\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.property', () => {\n  assert.property({ tea: { green: 'matcha' } }, 'tea')\n  assert.property({ tea: { green: 'matcha' } }, 'toString')\n})\n```\n\n## notProperty\n\n- **Type:** `<T>(object: T, property: string, message?: string) => void`\n\nAsserts that `object` does not have a direct or inherited property named by `property`\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notProperty', () => {\n  assert.notProperty({ tea: { green: 'matcha' } }, 'coffee')\n})\n```\n\n## propertyVal\n\n- **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`\n\nAsserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notPropertyVal', () => {\n  assert.propertyVal({ tea: 'is good' }, 'tea', 'is good')\n})\n```\n\n## notPropertyVal\n\n- **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`\n\nAsserts that `object` does not have a direct or inherited property named by `property` with a value given by `value`. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notPropertyVal', () => {\n  assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad')\n  assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good')\n})\n```\n\n## deepPropertyVal\n\n- **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`\n\nAsserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => {\n  assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' })\n})\n```\n\n## notDeepPropertyVal\n\n- **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`\n\nAsserts that `object` does not have a direct or inherited property named by `property` with a value given by `value`. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => {\n  assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' })\n  assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' })\n  assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' })\n})\n```\n\n## nestedProperty\n\n- **Type:** `<T>(object: T, property: string, message?: string) => void`\n\nAsserts that `object` has a direct or inherited property named by `property`, which can be a string using dot- and bracket-notation for nested reference.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => {\n  assert.nestedProperty({ tea: { green: 'matcha' } }, 'tea.green')\n})\n```\n\n## notNestedProperty\n\n- **Type:** `<T>(object: T, property: string, message?: string) => void`\n\nAsserts that `object` does not have a direct or inherited property named by `property`, which can be a string using dot- and bracket-notation for nested reference.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.deepPropertyVal', () => {\n  assert.notNestedProperty({ tea: { green: 'matcha' } }, 'tea.oolong')\n})\n```\n\n## nestedPropertyVal\n\n- **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`\n\nAsserts that `object` has a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.nestedPropertyVal', () => {\n  assert.nestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'matcha')\n})\n```\n\n## notNestedPropertyVal\n\n- **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`\n\nAsserts that `object` does not have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notNestedPropertyVal', () => {\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'konacha')\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'coffee.green', 'matcha')\n})\n```\n\n## deepNestedPropertyVal\n\n- **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`\n\nAsserts that `object` has a property named by `property` with a value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notNestedPropertyVal', () => {\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'konacha')\n  assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'coffee.green', 'matcha')\n})\n```\n\n## notDeepNestedPropertyVal\n\n- **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`\n\nAsserts that `object` does not have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notDeepNestedPropertyVal', () => {\n  assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' })\n  assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' })\n  assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' })\n})\n```\n\n## lengthOf\n\n- **Type:** `<T extends { readonly length?: number | undefined } | { readonly size?: number | undefined }>(object: T, length: number, message?: string) => void`\n\nAsserts that `object` has a `length` or `size` with the expected value.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.lengthOf', () => {\n  assert.lengthOf([1, 2, 3], 3, 'array has length of 3')\n  assert.lengthOf('foobar', 6, 'string has length of 6')\n  assert.lengthOf(new Set([1, 2, 3]), 3, 'set has size of 3')\n  assert.lengthOf(new Map([['a', 1], ['b', 2], ['c', 3]]), 3, 'map has size of 3')\n})\n```\n\n## hasAnyKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has at least one of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyKeys', () => {\n  assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'iDontExist', 'baz'])\n  assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, iDontExist: 99, baz: 1337 })\n  assert.hasAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])\n  assert.hasAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ foo: 'bar' }, 'anotherKey'])\n})\n```\n\n## hasAllKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has all and only all of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAllKeys', () => {\n  assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])\n  assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })\n  assert.hasAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])\n  assert.hasAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))\n})\n```\n\n## containsAllKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has all of the `keys` provided but may have more keys not listed. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.containsAllKeys', () => {\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'baz'])\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, baz: 1337 })\n  assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })\n  assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }])\n  assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])\n  assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }]))\n  assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))\n})\n```\n\n## doesNotHaveAnyKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has none of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotHaveAnyKeys', () => {\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example'])\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' })\n  assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example'])\n  assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ one: 'two' }, 'example']))\n})\n```\n\n## doesNotHaveAllKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` does not have at least one of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyKeys', () => {\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example'])\n  assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' })\n  assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example'])\n  assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ one: 'two' }, 'example'])\n})\n```\n\n## hasAnyDeepKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyDeepKeys', () => {\n  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })\n  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), [{ one: 'one' }, { two: 'two' }])\n  assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])\n  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })\n  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { three: 'three' }])\n  assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])\n})\n```\n\n## hasAllDeepKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has all and only all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.hasAnyDeepKeys', () => {\n  assert.hasAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne']]), { one: 'one' })\n  assert.hasAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])\n  assert.hasAllDeepKeys(new Set([{ one: 'one' }]), { one: 'one' })\n  assert.hasAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])\n})\n```\n\n## containsAllDeepKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` contains all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.containsAllDeepKeys', () => {\n  assert.containsAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })\n  assert.containsAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])\n  assert.containsAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })\n  assert.containsAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])\n})\n```\n\n## doesNotHaveAnyDeepKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` has none of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotHaveAnyDeepKeys', () => {\n  assert.doesNotHaveAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { thisDoesNot: 'exist' })\n  assert.doesNotHaveAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ twenty: 'twenty' }, { fifty: 'fifty' }])\n  assert.doesNotHaveAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { twenty: 'twenty' })\n  assert.doesNotHaveAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ twenty: 'twenty' }, { fifty: 'fifty' }])\n})\n```\n\n## doesNotHaveAllDeepKeys\n\n- **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`\n\nAsserts that `object` does not have at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotHaveAllDeepKeys', () => {\n  assert.doesNotHaveAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { thisDoesNot: 'exist' })\n  assert.doesNotHaveAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ twenty: 'twenty' }, { one: 'one' }])\n  assert.doesNotHaveAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { twenty: 'twenty' })\n  assert.doesNotHaveAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { fifty: 'fifty' }])\n})\n```\n\n## throws\n\n- **Type:**\n  - `(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string) => void`\n  - `(fn: () => void, errorLike?: ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string) => void`\n- **Alias:**\n  - `throw`\n  - `Throw`\n\nIf `errorLike` is an Error constructor, asserts that `fn` will throw an error that is an instance of `errorLike`. If errorLike is an Error instance, asserts that the error thrown is the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will have a message matching `errMsgMatcher`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.throws', () => {\n  assert.throws(fn, 'Error thrown must have this msg')\n  assert.throws(fn, /Error thrown must have a msg that matches this/)\n  assert.throws(fn, ReferenceError)\n  assert.throws(fn, errorInstance)\n  assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg')\n  assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg')\n  assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/)\n  assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/)\n})\n```\n\n## doesNotThrow\n\n- **Type:** `(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string) => void`\n- **Type:** `(fn: () => void, errorLike?: ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string) => void`\n\nIf `errorLike` is an Error constructor, asserts that `fn` will not throw an error that is an instance of `errorLike`. If errorLike is an Error instance, asserts that the error thrown is not the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will not have a message matching `errMsgMatcher`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotThrow', () => {\n  assert.doesNotThrow(fn, 'Any Error thrown must not have this message')\n  assert.doesNotThrow(fn, /Any Error thrown must not match this/)\n  assert.doesNotThrow(fn, Error)\n  assert.doesNotThrow(fn, errorInstance)\n  assert.doesNotThrow(fn, Error, 'Error must not have this message')\n  assert.doesNotThrow(fn, errorInstance, 'Error must not have this message')\n  assert.doesNotThrow(fn, Error, /Error must not match this/)\n  assert.doesNotThrow(fn, errorInstance, /Error must not match this/)\n})\n```\n\n## operator\n\n- **Type:** `(val1: OperatorComparable, operator: Operator, val2: OperatorComparable, message?: string) => void`\n\nCompare `val1` and `val2` using `operator`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.operator', () => {\n  assert.operator(1, '<', 2, 'everything is ok')\n})\n```\n\n## closeTo\n\n- **Type:** `(actual: number, expected: number, delta: number, message?: string) => void`\n- **Alias:** `approximately`\n\nAsserts that the `actual` is equal `expected`, to within a +/- `delta` range.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.closeTo', () => {\n  assert.closeTo(1.5, 1, 0.5, 'numbers are close')\n})\n```\n\n## sameMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` have the same members in any order. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.sameMembers', () => {\n  assert.sameMembers([1, 2, 3], [2, 1, 3], 'same members')\n})\n```\n\n## notSameMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` don't have the same members in any order. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.sameMembers', () => {\n  assert.notSameMembers([1, 2, 3], [5, 1, 3], 'not same members')\n})\n```\n\n## sameDeepMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` have the same members in any order. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.sameDeepMembers', () => {\n  assert.sameDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members')\n})\n```\n\n## notSameDeepMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` don’t have the same members in any order. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.sameDeepMembers', () => {\n  assert.sameDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members')\n})\n```\n\n## sameOrderedMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` have the same members in the same order. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.sameOrderedMembers', () => {\n  assert.sameOrderedMembers([1, 2, 3], [1, 2, 3], 'same ordered members')\n})\n```\n\n## notSameOrderedMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` have the same members in the same order. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notSameOrderedMembers', () => {\n  assert.notSameOrderedMembers([1, 2, 3], [2, 1, 3], 'not same ordered members')\n})\n```\n\n## sameDeepOrderedMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` have the same members in the same order. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.sameDeepOrderedMembers', () => {\n  assert.sameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }, { c: 3 }], 'same deep ordered members')\n})\n```\n\n## notSameDeepOrderedMembers\n\n- **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`\n\nAsserts that `set1` and `set2` don’t have the same members in the same order. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notSameDeepOrderedMembers', () => {\n  assert.notSameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }, { z: 5 }], 'not same deep ordered members')\n  assert.notSameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'not same deep ordered members')\n})\n```\n\n## includeMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` is included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.includeMembers', () => {\n  assert.includeMembers([1, 2, 3], [2, 1, 2], 'include members')\n})\n```\n\n## notIncludeMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` isn't included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notIncludeMembers', () => {\n  assert.notIncludeMembers([1, 2, 3], [5, 1], 'not include members')\n})\n```\n\n## includeDeepMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` is included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.includeDeepMembers', () => {\n  assert.includeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { b: 2 }], 'include deep members')\n})\n```\n\n## notIncludeDeepMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` isn’t included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notIncludeDeepMembers', () => {\n  assert.notIncludeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { f: 5 }], 'not include deep members')\n})\n```\n\n## includeOrderedMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.includeOrderedMembers', () => {\n  assert.includeOrderedMembers([1, 2, 3], [1, 2], 'include ordered members')\n})\n```\n\n## notIncludeOrderedMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` isn't included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.notIncludeOrderedMembers', () => {\n  assert.notIncludeOrderedMembers([1, 2, 3], [2, 1], 'not include ordered members')\n  assert.notIncludeOrderedMembers([1, 2, 3], [2, 3], 'not include ordered members')\n})\n```\n\n## includeDeepOrderedMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.includeDeepOrderedMembers', () => {\n  assert.includeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }], 'include deep ordered members')\n})\n```\n\n## notIncludeDeepOrderedMembers\n\n- **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`\n\nAsserts that `subset` isn’t included in `superset` in the same order beginning with the first element in superset. Uses a deep equality check.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.includeDeepOrderedMembers', () => {\n  assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { f: 5 }], 'not include deep ordered members')\n  assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }], 'not include deep ordered members')\n  assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { c: 3 }], 'not include deep ordered members')\n})\n```\n\n## oneOf\n\n- **Type:** `<T>(inList: T, list: T[], message?: string) => void`\n\nAsserts that non-object, non-array value `inList` appears in the flat array `list`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.oneOf', () => {\n  assert.oneOf(1, [2, 1], 'Not found in list')\n})\n```\n\n## changes\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`\n\nAsserts that a `modifier` changes the `object` of a `property`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.changes', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 22 };\n  assert.changes(fn, obj, 'val')\n})\n```\n\n## changesBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`\n\nAsserts that a `modifier` changes the `object` of a `property` by a `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.changesBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 2 };\n  assert.changesBy(fn, obj, 'val', 2)\n})\n```\n\n## doesNotChange\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`\n\nAsserts that a `modifier` does not changes the `object` of a `property`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotChange', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 2 };\n  assert.doesNotChange(fn, obj, 'val', 2)\n})\n```\n\n## changesButNotBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change:number, message?: string) => void`\n\nAsserts that a `modifier` does not change the `object` of a `property` or of a `modifier` return value by a `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.changesButNotBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 10 };\n  assert.changesButNotBy(fn, obj, 'val', 5)\n})\n```\n\n## increases\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`\n\nAsserts that a `modifier` increases a numeric `object`'s `property`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.increases', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 13 };\n  assert.increases(fn, obj, 'val')\n})\n```\n\n## increasesBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`\n\nAsserts that a `modifier` increases a numeric `object`'s `property` or a `modifier` return value by an `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.increases', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 10 };\n  assert.increases(fn, obj, 'val', 10)\n})\n```\n\n## doesNotIncrease\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`\n\nAsserts that a `modifier` does not increases a numeric `object`'s `property`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotIncrease', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 8 }\n  assert.doesNotIncrease(fn, obj, 'val')\n})\n```\n\n## increasesButNotBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`\n\nAsserts that a `modifier` does not increases a numeric `object`'s `property` or a `modifier` return value by an `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.increasesButNotBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val += 15 };\n  assert.increasesButNotBy(fn, obj, 'val', 10)\n})\n```\n\n## decreases\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`\n\nAsserts that a `modifier` decreases a numeric `object`'s `property`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.decreases', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 5 };\n  assert.decreases(fn, obj, 'val')\n})\n```\n\n## decreasesBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`\n\nAsserts that a `modifier` decreases a numeric `object`'s `property` or a `modifier` return value by a `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.decreasesBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val -= 5 };\n  assert.decreasesBy(fn, obj, 'val', 5)\n})\n```\n\n## doesNotDecrease\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`\n\nAsserts that a `modifier` dose not decrease a numeric `object`'s `property`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotDecrease', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 15 }\n  assert.doesNotDecrease(fn, obj, 'val')\n})\n```\n\n## doesNotDecreaseBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`\n\nAsserts that a `modifier` does not decrease a numeric `object`'s `property` or a `modifier` return value by a `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.doesNotDecreaseBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 5 };\n  assert.doesNotDecreaseBy(fn, obj, 'val', 1)\n})\n```\n\n## decreasesButNotBy\n\n- **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`\n\nAsserts that a `modifier` does not decrease a numeric `object`'s `property` or a `modifier` return value by a `change`.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.decreasesButNotBy', () => {\n  const obj = { val: 10 }\n  function fn() { obj.val = 5 };\n  assert.decreasesButNotBy(fn, obj, 'val', 1)\n})\n```\n\n## ifError\n\n- **Type:** `<T>(object: T, message?: string) => void`\n\nAsserts if `object` is not a false value, and throws if it is a true value. This is added to allow for chai to be a drop-in replacement for Node’s assert class.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.ifError', () => {\n  const err = new Error('I am a custom error')\n  assert.ifError(err) // Rethrows err!\n})\n```\n\n## isExtensible\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `extensible`\n\nAsserts that `object` is extensible (can have new properties added to it).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isExtensible', () => {\n  assert.isExtensible({})\n})\n```\n\n## isNotExtensible\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `notExtensible`\n\nAsserts that `object` is not extensible (can not have new properties added to it).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotExtensible', () => {\n  const nonExtensibleObject = Object.preventExtensions({})\n  const sealedObject = Object.seal({})\n  const frozenObject = Object.freeze({})\n\n  assert.isNotExtensible(nonExtensibleObject)\n  assert.isNotExtensible(sealedObject)\n  assert.isNotExtensible(frozenObject)\n})\n```\n\n## isSealed\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `sealed`\n\nAsserts that `object` is sealed (cannot have new properties added to it and its existing properties cannot be removed).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isSealed', () => {\n  const sealedObject = Object.seal({})\n  const frozenObject = Object.seal({})\n\n  assert.isSealed(sealedObject)\n  assert.isSealed(frozenObject)\n})\n```\n\n## isNotSealed\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `notSealed`\n\nAsserts that `object` is not sealed (can have new properties added to it and its existing properties can be removed).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotSealed', () => {\n  assert.isNotSealed({})\n})\n```\n\n## isFrozen\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `frozen`\n\nAsserts that object is frozen (cannot have new properties added to it and its existing properties cannot be modified).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isFrozen', () => {\n  const frozenObject = Object.freeze({})\n  assert.frozen(frozenObject)\n})\n```\n\n## isNotFrozen\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `notFrozen`\n\nAsserts that `object` is not frozen (can have new properties added to it and its existing properties can be modified).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotFrozen', () => {\n  assert.isNotFrozen({})\n})\n```\n\n## isEmpty\n\n- **Type:** `<T>(target: T, message?: string) => void`\n- **Alias:** `empty`\n\nAsserts that the `target` does not contain any values. For arrays and strings, it checks the length property. For Map and Set instances, it checks the size property. For non-function objects, it gets the count of its own enumerable string keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isEmpty', () => {\n  assert.isEmpty([])\n  assert.isEmpty('')\n  assert.isEmpty(new Map())\n  assert.isEmpty({})\n})\n```\n\n## isNotEmpty\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `notEmpty`\n\nAsserts that the `target` contains values. For arrays and strings, it checks the length property. For Map and Set instances, it checks the size property. For non-function objects, it gets the count of its own enumerable string keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotEmpty', () => {\n  assert.isNotEmpty([1, 2])\n  assert.isNotEmpty('34')\n  assert.isNotEmpty(new Set([5, 6]))\n  assert.isNotEmpty({ key: 7 })\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/assert](https://vitest.dev/api/assert)"
- name: assert ​
  id: api/assert#assert-1
  summary: Assert that the given expression is truthy, otherwise the assertion fails
  belongs_to: assert
  description: |-
    ## assert

    - **Type:** `(expression: any, message?: string) => asserts expression`

    Assert that the given `expression` is truthy, otherwise the assertion fails.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert', () => {
      assert('foo' !== 'bar', 'foo should not be equal to bar')
    })
    ```
- name: Assertion API
  id: guide/browser/assertion-api
  summary: Vitest bundles @testing-library/jest-dom library to provide a wide range of DOM assertions out of the box
  description: "# Assertion API\n\nVitest bundles [`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom) library to provide a wide range of DOM assertions out of the box. For detailed documentation, you can read the `jest-dom` readme:\n\n- [`toBeDisabled`](https://github.com/testing-library/jest-dom#toBeDisabled)\n- [`toBeEnabled`](https://github.com/testing-library/jest-dom#toBeEnabled)\n- [`toBeEmptyDOMElement`](https://github.com/testing-library/jest-dom#toBeEmptyDOMElement)\n- [`toBeInTheDocument`](https://github.com/testing-library/jest-dom#toBeInTheDocument)\n- [`toBeInvalid`](https://github.com/testing-library/jest-dom#toBeInvalid)\n- [`toBeRequired`](https://github.com/testing-library/jest-dom#toBeRequired)\n- [`toBeValid`](https://github.com/testing-library/jest-dom#toBeValid)\n- [`toBeVisible`](https://github.com/testing-library/jest-dom#toBeVisible)\n- [`toContainElement`](https://github.com/testing-library/jest-dom#toContainElement)\n- [`toContainHTML`](https://github.com/testing-library/jest-dom#toContainHTML)\n- [`toHaveAccessibleDescription`](https://github.com/testing-library/jest-dom#toHaveAccessibleDescription)\n- [`toHaveAccessibleErrorMessage`](https://github.com/testing-library/jest-dom#toHaveAccessibleErrorMessage)\n- [`toHaveAccessibleName`](https://github.com/testing-library/jest-dom#toHaveAccessibleName)\n- [`toHaveAttribute`](https://github.com/testing-library/jest-dom#toHaveAttribute)\n- [`toHaveClass`](https://github.com/testing-library/jest-dom#toHaveClass)\n- [`toHaveFocus`](https://github.com/testing-library/jest-dom#toHaveFocus)\n- [`toHaveFormValues`](https://github.com/testing-library/jest-dom#toHaveFormValues)\n- [`toHaveStyle`](https://github.com/testing-library/jest-dom#toHaveStyle)\n- [`toHaveTextContent`](https://github.com/testing-library/jest-dom#toHaveTextContent)\n- [`toHaveValue`](https://github.com/testing-library/jest-dom#toHaveValue)\n- [`toHaveDisplayValue`](https://github.com/testing-library/jest-dom#toHaveDisplayValue)\n- [`toBeChecked`](https://github.com/testing-library/jest-dom#toBeChecked)\n- [`toBePartiallyChecked`](https://github.com/testing-library/jest-dom#toBePartiallyChecked)\n- [`toHaveRole`](https://github.com/testing-library/jest-dom#toHaveRole)\n- [`toHaveErrorMessage`](https://github.com/testing-library/jest-dom#toHaveErrorMessage)\n\nIf you are using TypeScript or want to have correct type hints in `expect`, make sure you have either `@vitest/browser/providers/playwright` or `@vitest/browser/providers/webdriverio` specified in your `tsconfig` depending on the provider you use. If you use the default `preview` provider, you can specify `@vitest/browser/matchers` instead.\n\npreviewplaywrightwebdriverio\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/matchers\"\n    ]\n  }\n}\n```\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/playwright\"\n    ]\n  }\n}\n```\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/webdriverio\"\n    ]\n  }\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/assertion-api](https://vitest.dev/guide/browser/assertion-api)"
- name: asserts ​
  id: api/expect-typeof#asserts
  summary: This matcher extracts assert value (e.g., assert v is number), so you can perform assertions on it
  belongs_to: expectTypeOf
  description: |-
    ## asserts

    - **Type:** `ExpectTypeOf<Assert>`

    This matcher extracts assert value (e.g., `assert v is number`), so you can perform assertions on it.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    function assertNumber(v: any): asserts v is number {
      if (typeof v !== 'number') {
        throw new TypeError('Nope !')
      }
    }

    expectTypeOf(assertNumber).asserts.toBeNumber()
    ```

    **WARNING**

    Returns `never`, if the value is not an assert function, so you won't be able to chain it with other matchers.
- name: assertType
  id: api/assert-type
  summary: During runtime this function doesn't do anything
  description: "# assertType\n\n**WARNING**\n\nDuring runtime this function doesn't do anything. To [enable typechecking](../guide/testing-types#run-typechecking), don't forget to pass down `--typecheck` flag.\n\n- **Type:** `<T>(value: T): void`\n\nYou can use this function as an alternative for [`expectTypeOf`](expect-typeof) to easily assert that the argument type is equal to the generic provided.\n\nts\n\n``` javascript\nimport { assertType } from 'vitest'\n\nfunction concat(a: string, b: string): string\nfunction concat(a: number, b: number): number\nfunction concat(a: string | number, b: string | number): string | number\n\nassertType<string>(concat('a', 'b'))\nassertType<number>(concat(1, 2))\n// @ts-expect-error wrong types\nassertType(concat('a', 2))\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/assert-type](https://vitest.dev/api/assert-type)"
- name: bail ​
  id: config/index#bail
  summary: Stop test execution when given number of tests have failed
  belongs_to: Configuring Vitest
  description: |-
    ### bail

    - **Type:** `number`
    - **Default:** `0`
    - **CLI**: `--bail=<value>`

    Stop test execution when given number of tests have failed.

    By default Vitest will run all of your test cases even if some of them fail. This may not be desired for CI builds where you are only interested in 100% successful builds and would like to stop test execution as early as possible when test failures occur. The `bail` option can be used to speed up CI runs by preventing it from running more tests when failures have occurred.
- name: beforeAll ​
  id: api/index#beforeall
  summary: Register a callback to be called once before starting to run all tests in the current context
  belongs_to: Test API Reference
  description: |-
    ### beforeAll

    - **Type:** `beforeAll(fn: () => Awaitable<void>, timeout?: number)`

    Register a callback to be called once before starting to run all tests in the current context. If the function returns a promise, Vitest waits until the promise resolve before running tests.

    Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.

    ts

    ``` javascript
    import { beforeAll } from 'vitest'

    beforeAll(async () => {
      await startMocking() // called once before all tests run
    })
    ```

    Here the `beforeAll` ensures that the mock data is set up before tests run.

    `beforeAll` also accepts an optional cleanup function (equivalent to `afterAll`).

    ts

    ``` javascript
    import { beforeAll } from 'vitest'

    beforeAll(async () => {
      // called once before all tests run
      await startMocking()

      // clean up function, called once after all tests run
      return async () => {
        await stopMocking()
      }
    })
    ```
- name: beforeEach ​
  id: api/index#beforeeach
  summary: Register a callback to be called before each of the tests in the current context runs
  belongs_to: Test API Reference
  description: |-
    ### beforeEach

    - **Type:** `beforeEach(fn: () => Awaitable<void>, timeout?: number)`

    Register a callback to be called before each of the tests in the current context runs. If the function returns a promise, Vitest waits until the promise resolve before running the test.

    Optionally, you can pass a timeout (in milliseconds) defining how long to wait before terminating. The default is 5 seconds.

    ts

    ``` javascript
    import { beforeEach } from 'vitest'

    beforeEach(async () => {
      // Clear mocks and add some testing data after before each test run
      await stopMocking()
      await addUser({ name: 'John' })
    })
    ```

    Here, the `beforeEach` ensures that user is added for each test.

    `beforeEach` also accepts an optional cleanup function (equivalent to `afterEach`).

    ts

    ``` javascript
    import { beforeEach } from 'vitest'

    beforeEach(async () => {
      // called once before each test run
      await prepareSomething()

      // clean up function, called once after each test run
      return async () => {
        await resetSomething()
      }
    })
    ```
- name: bench ​
  id: api/index#bench
  summary: bench defines a benchmark
  belongs_to: Test API Reference
  description: |-
    ## bench

    - **Type:** `(name: string | Function, fn: BenchFunction, options?: BenchOptions) => void`

    `bench` defines a benchmark. In Vitest terms benchmark is a function that defines a series of operations. Vitest runs this function multiple times to display different performance results.

    Vitest uses [`tinybench`](https://github.com/tinylibs/tinybench) library under the hood, inheriting all its options that can be used as a third argument.

    ts

    ``` javascript
    import { bench } from 'vitest'

    bench('normal sorting', () => {
      const x = [1, 5, 4, 2, 3]
      x.sort((a, b) => {
        return a - b
      })
    }, { time: 1000 })
    ```

    ts

    ``` javascript
    export interface Options {
      /**
       * time needed for running a benchmark task (milliseconds)
       * @default 500
       */
      time?: number

      /**
       * number of times that a task should run if even the time option is finished
       * @default 10
       */
      iterations?: number

      /**
       * function to get the current timestamp in milliseconds
       */
      now?: () => number

      /**
       * An AbortSignal for aborting the benchmark
       */
      signal?: AbortSignal

      /**
       * warmup time (milliseconds)
       * @default 100ms
       */
      warmupTime?: number

      /**
       * warmup iterations
       * @default 5
       */
      warmupIterations?: number

      /**
       * setup function to run before each benchmark task (cycle)
       */
      setup?: Hook

      /**
       * teardown function to run after each benchmark task (cycle)
       */
      teardown?: Hook
    }
    ```
- name: bench.only ​
  id: api/index#bench-only
  summary: Use bench.only to only run certain benchmarks in a given suite
  belongs_to: Test API Reference
  description: |-
    ### bench.only

    - **Type:** `(name: string | Function, fn: BenchFunction, options?: BenchOptions) => void`

    Use `bench.only` to only run certain benchmarks in a given suite. This is useful when debugging.

    ts

    ``` javascript
    import { bench } from 'vitest'

    bench.only('normal sorting', () => {
      const x = [1, 5, 4, 2, 3]
      x.sort((a, b) => {
        return a - b
      })
    })
    ```
- name: bench.skip ​
  id: api/index#bench-skip
  summary: You can use bench.skip syntax to skip running certain benchmarks
  belongs_to: Test API Reference
  description: |-
    ### bench.skip

    - **Type:** `(name: string | Function, fn: BenchFunction, options?: BenchOptions) => void`

    You can use `bench.skip` syntax to skip running certain benchmarks.

    ts

    ``` javascript
    import { bench } from 'vitest'

    bench.skip('normal sorting', () => {
      const x = [1, 5, 4, 2, 3]
      x.sort((a, b) => {
        return a - b
      })
    })
    ```
- name: bench.todo ​
  id: api/index#bench-todo
  summary: Use bench.todo to stub benchmarks to be implemented later
  belongs_to: Test API Reference
  description: |-
    ### bench.todo

    - **Type:** `(name: string | Function) => void`

    Use `bench.todo` to stub benchmarks to be implemented later.

    ts

    ``` javascript
    import { bench } from 'vitest'

    bench.todo('unimplemented test')
    ```
- name: benchmark ​
  id: config/index#benchmark
  summary: Options used when running vitest bench
  belongs_to: Configuring Vitest
  description: |-
    ### benchmark

    - **Type:** `{ include?, exclude?, ... }`

    Options used when running `vitest bench`.

    #### benchmark.include

    - **Type:** `string[]`
    - **Default:** `['**/*.{bench,benchmark}.?(c|m)[jt]s?(x)']`

    Include globs for benchmark test files

    #### benchmark.exclude

    - **Type:** `string[]`
    - **Default:** `['node_modules', 'dist', '.idea', '.git', '.cache']`

    Exclude globs for benchmark test files

    #### benchmark.includeSource

    - **Type:** `string[]`
    - **Default:** `[]`

    Include globs for in-source benchmark test files. This option is similar to [`includeSource`](#includesource).

    When defined, Vitest will run all matched files with `import.meta.vitest` inside.

    #### benchmark.reporters

    - **Type:** `Arrayable<BenchmarkBuiltinReporters | Reporter>`
    - **Default:** `'default'`

    Custom reporter for output. Can contain one or more built-in report names, reporter instances, and/or paths to custom reporters.

    #### benchmark.outputFile

    - **Type:** `string | Record<string, string>`

    Write benchmark results to a file when the `--reporter=json` option is also specified. By providing an object instead of a string you can define individual outputs when using multiple reporters.

    To provide object via CLI command, use the following syntax: `--outputFile.json=./path --outputFile.junit=./other-path`.

    #### benchmark.outputJson

    - **Type:** `string | undefined`
    - **Default:** `undefined`

    A file path to store the benchmark result, which can be used for `--compare` option later.

    For example:

    sh

    ``` javascript
    # save main branch's result
    git checkout main
    vitest bench --outputJson main.json

    # change a branch and compare against main
    git checkout feature
    vitest bench --compare main.json
    ```

    #### benchmark.compare

    - **Type:** `string | undefined`
    - **Default:** `undefined`

    A file path to a previous benchmark result to compare against current runs.
- name: Browser Mode Experimental
  id: guide/browser/index
  summary: This page provides information about the experimental browser mode feature in the Vitest API, which allows you to run your tests in the browser natively, providing access to browser globals like window and document
  description: "# Browser Mode Experimental\n\nThis page provides information about the experimental browser mode feature in the Vitest API, which allows you to run your tests in the browser natively, providing access to browser globals like window and document. This feature is currently under development, and APIs may change in the future.\n\n## Installation\n\nFor easier setup, you can use `vitest init browser` command to install required dependencies and create browser configuration.\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpx vitest init browser\n```\n\nbash\n\n``` javascript\nyarn exec vitest init browser\n```\n\nbash\n\n``` javascript\npnpx vitest init browser\n```\n\nbash\n\n``` javascript\nbunx vitest init browser\n```\n\n### Manual Installation\n\nYou can also install packages manually. By default, Browser Mode doesn't require any additional E2E provider to run tests locally because it reuses your existing browser.\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpm install -D vitest @vitest/browser\n```\n\nbash\n\n``` javascript\nyarn add -D vitest @vitest/browser\n```\n\nbash\n\n``` javascript\npnpm add -D vitest @vitest/browser\n```\n\nbash\n\n``` javascript\nbun add -D vitest @vitest/browser\n```\n\n**WARNING**\n\nHowever, to run tests in CI you need to install either [`playwright`](https://npmjs.com/package/playwright) or [`webdriverio`](https://www.npmjs.com/package/webdriverio). We also recommend switching to either one of them for testing locally instead of using the default `preview` provider since it relies on simulating events instead of using Chrome DevTools Protocol.\n\n### Using Playwright\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpm install -D vitest @vitest/browser playwright\n```\n\nbash\n\n``` javascript\nyarn add -D vitest @vitest/browser playwright\n```\n\nbash\n\n``` javascript\npnpm add -D vitest @vitest/browser playwright\n```\n\nbash\n\n``` javascript\nbun add -D vitest @vitest/browser playwright\n```\n\n### Using Webdriverio\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpm install -D vitest @vitest/browser webdriverio\n```\n\nbash\n\n``` javascript\nyarn add -D vitest @vitest/browser webdriverio\n```\n\nbash\n\n``` javascript\npnpm add -D vitest @vitest/browser webdriverio\n```\n\nbash\n\n``` javascript\nbun add -D vitest @vitest/browser webdriverio\n```\n\n## Configuration\n\nTo activate browser mode in your Vitest configuration, you can use the `--browser` flag or set the `browser.enabled` field to `true` in your Vitest configuration file. Here is an example configuration using the browser field:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    browser: {\n      provider: 'playwright', // or 'webdriverio'\n      enabled: true,\n      name: 'chrome', // browser name is required\n    },\n  }\n})\n```\n\nIf you have not used Vite before, make sure you have your framework's plugin installed and specified in the config. Some frameworks might require extra configuration to work - check their Vite related documentation to be sure.\n\nvuesveltesolidmarko\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [vue()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      name: 'chrome',\n    }\n  }\n})\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport { svelte } from '@sveltejs/vite-plugin-svelte'\n\nexport default defineConfig({\n  plugins: [svelte()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      name: 'chrome',\n    }\n  }\n})\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport solidPlugin from 'vite-plugin-solid'\n\nexport default defineConfig({\n  plugins: [solidPlugin()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      name: 'chrome',\n    }\n  }\n})\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport marko from '@marko/vite'\n\nexport default defineConfig({\n  plugins: [marko()],\n  test: {\n    browser: {\n      enabled: true,\n      provider: 'playwright',\n      name: 'chrome',\n    }\n  }\n})\n```\n\n**TIP**\n\n`react` doesn't require a plugin to work, but `preact` requires [extra configuration](https://preactjs.com/guide/v10/getting-started/#create-a-vite-powered-preact-app) to make aliases work.\n\nIf you need to run some tests using Node-based runner, you can define a [workspace](../workspace) file with separate configurations for different testing strategies:\n\nts\n\n``` javascript\n// vitest.workspace.ts\nimport { defineWorkspace } from 'vitest/config'\n\nexport default defineWorkspace([\n  {\n    test: {\n      // an example of file based convention,\n      // you don't have to follow it\n      include: [\n        'tests/unit/**/*.{test,spec}.ts',\n        'tests/**/*.unit.{test,spec}.ts',\n      ],\n      name: 'unit',\n      environment: 'node',\n    },\n  },\n  {\n    test: {\n      // an example of file based convention,\n      // you don't have to follow it\n      include: [\n        'tests/browser/**/*.{test,spec}.ts',\n        'tests/**/*.browser.{test,spec}.ts',\n      ],\n      name: 'browser',\n      browser: {\n        enabled: true,\n        name: 'chrome',\n      },\n    },\n  },\n])\n```\n\n## Browser Option Types\n\nThe browser option in Vitest depends on the provider. Vitest will fail, if you pass `--browser` and don't specify its name in the config file. Available options:\n\n- `webdriverio` supports these browsers:\n  - `firefox`\n  - `chrome`\n  - `edge`\n  - `safari`\n- `playwright` supports these browsers:\n  - `firefox`\n  - `webkit`\n  - `chromium`\n\n## Browser Compatibility\n\nVitest uses [Vite dev server](https://vitejs.dev/guide/#browser-support) to run your tests, so we only support features specified in the [`esbuild.target`](https://vitejs.dev/config/shared-options.html#esbuild) option (`esnext` by default).\n\nBy default, Vite targets browsers which support the native [ES Modules](https://caniuse.com/es6-module), native [ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). On top of that, we utilize [`BroadcastChannel`](https://caniuse.com/?search=BroadcastChannel) to communicate between iframes:\n\n- Chrome \\>=87\n- Firefox \\>=78\n- Safari \\>=15.4\n- Edge \\>=88\n\n## Motivation\n\nWe developed the Vitest browser mode feature to help improve testing workflows and achieve more accurate and reliable test results. This experimental addition to our testing API allows developers to run tests in a native browser environment. In this section, we'll explore the motivations behind this feature and its benefits for testing.\n\n### Different Ways of Testing\n\nThere are different ways to test JavaScript code. Some testing frameworks simulate browser environments in Node.js, while others run tests in real browsers. In this context, [jsdom](https://www.npmjs.com/package/jsdom) is an example of a spec implementation that simulates a browser environment by being used with a test runner like Jest or Vitest, while other testing tools such as [WebdriverIO](https://webdriver.io/) or [Cypress](https://www.cypress.io/) allow developers to test their applications in a real browser or in case of [Playwright](https://playwright.dev/) provide you a browser engine.\n\n### The Simulation Caveat\n\nTesting JavaScript programs in simulated environments such as jsdom or happy-dom has simplified the test setup and provided an easy-to-use API, making them suitable for many projects and increasing confidence in test results. However, it is crucial to keep in mind that these tools only simulate a browser environment and not an actual browser, which may result in some discrepancies between the simulated environment and the real environment. Therefore, false positives or negatives in test results may occur.\n\nTo achieve the highest level of confidence in our tests, it's crucial to test in a real browser environment. This is why we developed the browser mode feature in Vitest, allowing developers to run tests natively in a browser and gain more accurate and reliable test results. With browser-level testing, developers can be more confident that their application will work as intended in a real-world scenario.\n\n## Drawbacks\n\nWhen using Vitest browser, it is important to consider the following drawbacks:\n\n### Early Development\n\nThe browser mode feature of Vitest is still in its early stages of development. As such, it may not yet be fully optimized, and there may be some bugs or issues that have not yet been ironed out. It is recommended that users augment their Vitest browser experience with a standalone browser-side test runner like WebdriverIO, Cypress or Playwright.\n\n### Longer Initialization\n\nVitest browser requires spinning up the provider and the browser during the initialization process, which can take some time. This can result in longer initialization times compared to other testing patterns.\n\n## Cross-Browser Testing\n\nWhen you specify a browser name in the browser option, Vitest will try to run the specified browser using [WebdriverIO](https://webdriver.io/) by default, and then run the tests there. This feature makes cross-browser testing easy to use and configure in environments like a CI. If you don't want to use WebdriverIO, you can configure the custom browser provider by using `browser.provider` option.\n\nTo specify a browser using the CLI, use the `--browser` flag followed by the browser name, like this:\n\nsh\n\n``` javascript\nnpx vitest --browser=chrome\n```\n\nOr you can provide browser options to CLI with dot notation:\n\nsh\n\n``` javascript\nnpx vitest --browser.name=chrome --browser.headless\n```\n\n## Headless\n\nHeadless mode is another option available in the browser mode. In headless mode, the browser runs in the background without a user interface, which makes it useful for running automated tests. The headless option in Vitest can be set to a boolean value to enable or disable headless mode.\n\nHere's an example configuration enabling headless mode:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    browser: {\n      provider: 'playwright',\n      enabled: true,\n      headless: true,\n    },\n  }\n})\n```\n\nYou can also set headless mode using the `--browser.headless` flag in the CLI, like this:\n\nsh\n\n``` javascript\nnpx vitest --browser.name=chrome --browser.headless\n```\n\nIn this case, Vitest will run in headless mode using the Chrome browser.\n\n**WARNING**\n\nHeadless mode is not available by default. You need to use either [`playwright`](https://npmjs.com/package/playwright) or [`webdriverio`](https://www.npmjs.com/package/webdriverio) providers to enable this feature.\n\n## Limitations\n\n### Thread Blocking Dialogs\n\nWhen using Vitest Browser, it's important to note that thread blocking dialogs like `alert` or `confirm` cannot be used natively. This is because they block the web page, which means Vitest cannot continue communicating with the page, causing the execution to hang.\n\nIn such situations, Vitest provides default mocks with default returned values for these APIs. This ensures that if the user accidentally uses synchronous popup web APIs, the execution would not hang. However, it's still recommended for the user to mock these web APIs for better experience. Read more in [Mocking](../mocking).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/](https://vitest.dev/guide/browser/)"
- name: 'Browser Mode Experimental: Browser Compatibility ​'
  id: guide/browser/index#browser-compatibility
  summary: Vitest uses Vite dev server to run your tests, so we only support features specified in the esbuild.target option (esnext by default)
  belongs_to: Browser Mode Experimental
  description: |-
    ## Browser Compatibility

    Vitest uses [Vite dev server](https://vitejs.dev/guide/#browser-support) to run your tests, so we only support features specified in the [`esbuild.target`](https://vitejs.dev/config/shared-options.html#esbuild) option (`esnext` by default).

    By default, Vite targets browsers which support the native [ES Modules](https://caniuse.com/es6-module), native [ESM dynamic import](https://caniuse.com/es6-module-dynamic-import), and [`import.meta`](https://caniuse.com/mdn-javascript_operators_import_meta). On top of that, we utilize [`BroadcastChannel`](https://caniuse.com/?search=BroadcastChannel) to communicate between iframes:

    - Chrome \>=87
    - Firefox \>=78
    - Safari \>=15.4
    - Edge \>=88

    &nbsp;
- name: 'Browser Mode Experimental: Browser Option Types ​'
  id: guide/browser/index#browser-option-types
  summary: The browser option in Vitest depends on the provider
  belongs_to: Browser Mode Experimental
  description: |-
    ## Browser Option Types

    The browser option in Vitest depends on the provider. Vitest will fail, if you pass `--browser` and don't specify its name in the config file. Available options:

    - `webdriverio` supports these browsers:
      - `firefox`
      - `chrome`
      - `edge`
      - `safari`
    - `playwright` supports these browsers:
      - `firefox`
      - `webkit`
      - `chromium`
- name: 'Browser Mode Experimental: Configuration ​'
  id: guide/browser/index#configuration
  summary: To activate browser mode in your Vitest configuration, you can use the --browser flag or set the browser.enabled field to true in your Vitest configuration file
  belongs_to: Browser Mode Experimental
  description: |-
    ## Configuration

    To activate browser mode in your Vitest configuration, you can use the `--browser` flag or set the `browser.enabled` field to `true` in your Vitest configuration file. Here is an example configuration using the browser field:

    ts

    ``` javascript
    export default defineConfig({
      test: {
        browser: {
          provider: 'playwright', // or 'webdriverio'
          enabled: true,
          name: 'chrome', // browser name is required
        },
      }
    })
    ```

    If you have not used Vite before, make sure you have your framework's plugin installed and specified in the config. Some frameworks might require extra configuration to work - check their Vite related documentation to be sure.

    vue svelte solid marko

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'
    import vue from '@vitejs/plugin-vue'

    export default defineConfig({
      plugins: [vue()],
      test: {
        browser: {
          enabled: true,
          provider: 'playwright',
          name: 'chrome',
        }
      }
    })
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'
    import { svelte } from '@sveltejs/vite-plugin-svelte'

    export default defineConfig({
      plugins: [svelte()],
      test: {
        browser: {
          enabled: true,
          provider: 'playwright',
          name: 'chrome',
        }
      }
    })
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'
    import solidPlugin from 'vite-plugin-solid'

    export default defineConfig({
      plugins: [solidPlugin()],
      test: {
        browser: {
          enabled: true,
          provider: 'playwright',
          name: 'chrome',
        }
      }
    })
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'
    import marko from '@marko/vite'

    export default defineConfig({
      plugins: [marko()],
      test: {
        browser: {
          enabled: true,
          provider: 'playwright',
          name: 'chrome',
        }
      }
    })
    ```

    **TIP**

    `react` doesn't require a plugin to work, but `preact` requires [extra configuration](https://preactjs.com/guide/v10/getting-started/#create-a-vite-powered-preact-app) to make aliases work.

    If you need to run some tests using Node-based runner, you can define a [workspace](../workspace) file with separate configurations for different testing strategies:

    ts

    ``` javascript
    // vitest.workspace.ts
    import { defineWorkspace } from 'vitest/config'

    export default defineWorkspace([
      {
        test: {
          // an example of file based convention,
          // you don't have to follow it
          include: [
            'tests/unit/**/*.{test,spec}.ts',
            'tests/**/*.unit.{test,spec}.ts',
          ],
          name: 'unit',
          environment: 'node',
        },
      },
      {
        test: {
          // an example of file based convention,
          // you don't have to follow it
          include: [
            'tests/browser/**/*.{test,spec}.ts',
            'tests/**/*.browser.{test,spec}.ts',
          ],
          name: 'browser',
          browser: {
            enabled: true,
            name: 'chrome',
          },
        },
      },
    ])
    ```
- name: 'Browser Mode Experimental: Cross-Browser Testing ​'
  id: guide/browser/index#cross-browser-testing
  summary: When you specify a browser name in the browser option, Vitest will try to run the specified browser using WebdriverIO by default, and then run the tests there
  belongs_to: Browser Mode Experimental
  description: |-
    ## Cross-Browser Testing

    When you specify a browser name in the browser option, Vitest will try to run the specified browser using [WebdriverIO](https://webdriver.io/) by default, and then run the tests there. This feature makes cross-browser testing easy to use and configure in environments like a CI. If you don't want to use WebdriverIO, you can configure the custom browser provider by using `browser.provider` option.

    To specify a browser using the CLI, use the `--browser` flag followed by the browser name, like this:

    sh

    ``` javascript
    npx vitest --browser=chrome
    ```

    Or you can provide browser options to CLI with dot notation:

    sh

    ``` javascript
    npx vitest --browser.name=chrome --browser.headless
    ```
- name: 'Browser Mode Experimental: Different Ways of Testing ​'
  id: guide/browser/index#different-ways-of-testing
  summary: There are different ways to test JavaScript code
  belongs_to: Browser Mode Experimental
  description: |-
    ### Different Ways of Testing

    There are different ways to test JavaScript code. Some testing frameworks simulate browser environments in Node.js, while others run tests in real browsers. In this context, [jsdom](https://www.npmjs.com/package/jsdom) is an example of a spec implementation that simulates a browser environment by being used with a test runner like Jest or Vitest, while other testing tools such as [WebdriverIO](https://webdriver.io/) or [Cypress](https://www.cypress.io/) allow developers to test their applications in a real browser or in case of [Playwright](https://playwright.dev/) provide you a browser engine.
- name: 'Browser Mode Experimental: Drawbacks ​'
  id: guide/browser/index#drawbacks
  summary: null
  belongs_to: Browser Mode Experimental
  description: |-
    ## Drawbacks

    When using Vitest browser, it is important to consider the following drawbacks:
- name: 'Browser Mode Experimental: Early Development ​'
  id: guide/browser/index#early-development
  summary: The browser mode feature of Vitest is still in its early stages of development
  belongs_to: Browser Mode Experimental
  description: |-
    ### Early Development

    The browser mode feature of Vitest is still in its early stages of development. As such, it may not yet be fully optimized, and there may be some bugs or issues that have not yet been ironed out. It is recommended that users augment their Vitest browser experience with a standalone browser-side test runner like WebdriverIO, Cypress or Playwright.
- name: 'Browser Mode Experimental: Headless ​'
  id: guide/browser/index#headless
  summary: Headless mode is another option available in the browser mode
  belongs_to: Browser Mode Experimental
  description: |-
    ## Headless

    Headless mode is another option available in the browser mode. In headless mode, the browser runs in the background without a user interface, which makes it useful for running automated tests. The headless option in Vitest can be set to a boolean value to enable or disable headless mode.

    Here's an example configuration enabling headless mode:

    ts

    ``` javascript
    export default defineConfig({
      test: {
        browser: {
          provider: 'playwright',
          enabled: true,
          headless: true,
        },
      }
    })
    ```

    You can also set headless mode using the `--browser.headless` flag in the CLI, like this:

    sh

    ``` javascript
    npx vitest --browser.name=chrome --browser.headless
    ```

    In this case, Vitest will run in headless mode using the Chrome browser.

    **WARNING**

    Headless mode is not available by default. You need to use either [`playwright`](https://npmjs.com/package/playwright) or [`webdriverio`](https://www.npmjs.com/package/webdriverio) providers to enable this feature.
- name: 'Browser Mode Experimental: Installation ​'
  id: guide/browser/index#installation
  summary: For easier setup, you can use vitest init browser command to install required dependencies and create browser configuration
  belongs_to: Browser Mode Experimental
  description: |-
    ## Installation

    For easier setup, you can use `vitest init browser` command to install required dependencies and create browser configuration.

    npm yarn pnpm bun

    bash

    ``` javascript
    npx vitest init browser
    ```

    bash

    ``` javascript
    yarn exec vitest init browser
    ```

    bash

    ``` javascript
    pnpx vitest init browser
    ```

    bash

    ``` javascript
    bunx vitest init browser
    ```
- name: 'Browser Mode Experimental: Limitations ​'
  id: guide/browser/index#limitations
  summary: null
  belongs_to: Browser Mode Experimental
  description: '## Limitations'
- name: 'Browser Mode Experimental: Longer Initialization ​'
  id: guide/browser/index#longer-initialization
  summary: Vitest browser requires spinning up the provider and the browser during the initialization process, which can take some time
  belongs_to: Browser Mode Experimental
  description: |-
    ### Longer Initialization

    Vitest browser requires spinning up the provider and the browser during the initialization process, which can take some time. This can result in longer initialization times compared to other testing patterns.
- name: 'Browser Mode Experimental: Manual Installation ​'
  id: guide/browser/index#manual-installation
  summary: You can also install packages manually
  belongs_to: Browser Mode Experimental
  description: |-
    ### Manual Installation

    You can also install packages manually. By default, Browser Mode doesn't require any additional E2E provider to run tests locally because it reuses your existing browser.

    npm yarn pnpm bun

    bash

    ``` javascript
    npm install -D vitest @vitest/browser
    ```

    bash

    ``` javascript
    yarn add -D vitest @vitest/browser
    ```

    bash

    ``` javascript
    pnpm add -D vitest @vitest/browser
    ```

    bash

    ``` javascript
    bun add -D vitest @vitest/browser
    ```

    **WARNING**

    However, to run tests in CI you need to install either [`playwright`](https://npmjs.com/package/playwright) or [`webdriverio`](https://www.npmjs.com/package/webdriverio). We also recommend switching to either one of them for testing locally instead of using the default `preview` provider since it relies on simulating events instead of using Chrome DevTools Protocol.
- name: 'Browser Mode Experimental: Motivation ​'
  id: guide/browser/index#motivation
  summary: We developed the Vitest browser mode feature to help improve testing workflows and achieve more accurate and reliable test results
  belongs_to: Browser Mode Experimental
  description: |-
    ## Motivation

    We developed the Vitest browser mode feature to help improve testing workflows and achieve more accurate and reliable test results. This experimental addition to our testing API allows developers to run tests in a native browser environment. In this section, we'll explore the motivations behind this feature and its benefits for testing.
- name: 'Browser Mode Experimental: The Simulation Caveat ​'
  id: guide/browser/index#the-simulation-caveat
  summary: Testing JavaScript programs in simulated environments such as jsdom or happy-dom has simplified the test setup and provided an easy-to-use API, making them suitable for many projects and increasing confidence in test results
  belongs_to: Browser Mode Experimental
  description: |-
    ### The Simulation Caveat

    Testing JavaScript programs in simulated environments such as jsdom or happy-dom has simplified the test setup and provided an easy-to-use API, making them suitable for many projects and increasing confidence in test results. However, it is crucial to keep in mind that these tools only simulate a browser environment and not an actual browser, which may result in some discrepancies between the simulated environment and the real environment. Therefore, false positives or negatives in test results may occur.

    To achieve the highest level of confidence in our tests, it's crucial to test in a real browser environment. This is why we developed the browser mode feature in Vitest, allowing developers to run tests natively in a browser and gain more accurate and reliable test results. With browser-level testing, developers can be more confident that their application will work as intended in a real-world scenario.
- name: 'Browser Mode Experimental: Thread Blocking Dialogs ​'
  id: guide/browser/index#thread-blocking-dialogs
  summary: When using Vitest Browser, it's important to note that thread blocking dialogs like alert or confirm cannot be used natively
  belongs_to: Browser Mode Experimental
  description: "### Thread Blocking Dialogs\n\nWhen using Vitest Browser, it's important to note that thread blocking dialogs like `alert` or `confirm` cannot be used natively. This is because they block the web page, which means Vitest cannot continue communicating with the page, causing the execution to hang.\n\nIn such situations, Vitest provides default mocks with default returned values for these APIs. This ensures that if the user accidentally uses synchronous popup web APIs, the execution would not hang. However, it's still recommended for the user to mock these web APIs for better experience. Read more in [Mocking](../mocking).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/](https://vitest.dev/guide/browser/)"
- name: 'Browser Mode Experimental: Using Playwright ​'
  id: guide/browser/index#using-playwright
  summary: null
  belongs_to: Browser Mode Experimental
  description: |-
    ### Using Playwright

    npm yarn pnpm bun

    bash

    ``` javascript
    npm install -D vitest @vitest/browser playwright
    ```

    bash

    ``` javascript
    yarn add -D vitest @vitest/browser playwright
    ```

    bash

    ``` javascript
    pnpm add -D vitest @vitest/browser playwright
    ```

    bash

    ``` javascript
    bun add -D vitest @vitest/browser playwright
    ```
- name: 'Browser Mode Experimental: Using Webdriverio ​'
  id: guide/browser/index#using-webdriverio
  summary: null
  belongs_to: Browser Mode Experimental
  description: |-
    ### Using Webdriverio

    npm yarn pnpm bun

    bash

    ``` javascript
    npm install -D vitest @vitest/browser webdriverio
    ```

    bash

    ``` javascript
    yarn add -D vitest @vitest/browser webdriverio
    ```

    bash

    ``` javascript
    pnpm add -D vitest @vitest/browser webdriverio
    ```

    bash

    ``` javascript
    bun add -D vitest @vitest/browser webdriverio
    ```
- name: browser ​
  id: config/index#browser
  summary: Run Vitest tests in a browser
  belongs_to: Configuring Vitest
  description: |-
    ### browser

    - **Type:** `{ enabled?, name?, provider?, headless?, api? }`
    - **Default:** `{ enabled: false, headless: process.env.CI, api: 63315 }`
    - **CLI:**`--browser`, `--browser=<name>`, `--browser.name=chrome --browser.headless`

    Run Vitest tests in a browser. We use [WebdriverIO](https://webdriver.io/) for running tests by default, but it can be configured with [browser.provider](#browser-provider) option.

    **NOTE**

    Read more about testing in a real browser in the [guide page](../guide/browser/index).

    **WARNING**

    This is an experimental feature. Breaking changes might not follow SemVer, please pin Vitest's version when using it.

    #### browser.enabled

    - **Type:** `boolean`
    - **Default:** `false`
    - **CLI:**`--browser`, `--browser.enabled=false`

    Run all tests inside a browser by default. Can be overridden with [`poolMatchGlobs`](#poolmatchglobs) option.

    #### browser.name

    - **Type:** `string`
    - **CLI:** `--browser=safari`

    Run all tests in a specific browser. Possible options in different providers:

    - `webdriverio`: `firefox`, `chrome`, `edge`, `safari`
    - `playwright`: `firefox`, `webkit`, `chromium`
    - custom: any string that will be passed to the provider

    #### browser.headless

    - **Type:** `boolean`
    - **Default:** `process.env.CI`
    - **CLI:**`--browser.headless`, `--browser.headless=false`

    Run the browser in a `headless` mode. If you are running Vitest in CI, it will be enabled by default.

    #### browser.isolate

    - **Type:** `boolean`
    - **Default:** `true`
    - **CLI:**`--browser.isolate`, `--browser.isolate=false`

    Run every test in a separate iframe.

    #### browser.api

    - **Type:** `number | { port?, strictPort?, host? }`
    - **Default:** `63315`
    - **CLI:**`--browser.api=63315`, `--browser.api.port=1234, --browser.api.host=example.com`

    Configure options for Vite server that serves code in the browser. Does not affect [`test.api`](#api) option.

    #### browser.provider

    - **Type:** `'webdriverio' | 'playwright' | string`
    - **Default:** `'webdriverio'`
    - **CLI:** `--browser.provider=playwright`

    Path to a provider that will be used when running browser tests. Vitest provides two providers which are `webdriverio` (default) and `playwright`. Custom providers should be exported using `default` export and have this shape:

    ts

    ``` javascript
    export interface BrowserProvider {
      name: string
      getSupportedBrowsers: () => readonly string[]
      initialize: (ctx: Vitest, options: { browser: string; options?: BrowserProviderOptions }) => Awaitable<void>
      openPage: (url: string) => Awaitable<void>
      close: () => Awaitable<void>
    }
    ```

    **WARNING**

    This is an advanced API for library authors. If you just need to run tests in a browser, use the [browser](#browser) option.

    #### browser.providerOptions

    - **Type:** `BrowserProviderOptions`

    Options that will be passed down to provider when calling `provider.initialize`.

    ts

    ``` javascript
    export default defineConfig({
      test: {
        browser: {
          providerOptions: {
            launch: {
              devtools: true,
            }
          }
        }
      }
    })
    ```

    **TIP**

    To have a better type safety when using built-in providers, you can add one of these types (for provider that you are using) to your tsconfig's `compilerOptions.types` field:

    json

    ``` javascript
    {
      "compilerOptions": {
        "types": [
          "@vitest/browser/providers/webdriverio",
          "@vitest/browser/providers/playwright"
        ]
      }
    }
    ```

    #### browser.ui

    - **Type:** `boolean`
    - **Default:** `!isCI`
    - **CLI:** `--browser.ui=false`

    Should Vitest UI be injected into the page. By default, injects UI iframe during development.

    #### browser.viewport

    - **Type:** `{ width, height }`
    - **Default:** `414x896`

    Default iframe's viewport.

    #### browser.screenshotDirectory

    - **Type:** `string`
    - **Default:**`__snapshots__` in the test file directory

    Path to the snapshots directory relative to the `root`.

    #### browser.screenshotFailures

    - **Type:** `boolean`
    - **Default:** `!browser.ui`

    Should Vitest take screenshots if the test fails.

    #### browser.orchestratorScripts

    - **Type:** `BrowserScript[]`
    - **Default:** `[]`

    Custom scripts that should be injected into the orchestrator HTML before test iframes are initiated. This HTML document only sets up iframes and doesn't actually import your code.

    The script `src` and `content` will be processed by Vite plugins. Script should be provided in the following shape:

    ts

    ``` javascript
    export interface BrowserScript {
      /**
       * If "content" is provided and type is "module", this will be its identifier.
       *
       * If you are using TypeScript, you can add `.ts` extension here for example.
       * @default `injected-${index}.js`
       */
      id?: string
      /**
       * JavaScript content to be injected. This string is processed by Vite plugins if type is "module".
       *
       * You can use `id` to give Vite a hint about the file extension.
       */
      content?: string
      /**
       * Path to the script. This value is resolved by Vite so it can be a node module or a file path.
       */
      src?: string
      /**
       * If the script should be loaded asynchronously.
       */
      async?: boolean
      /**
       * Script type.
       * @default 'module'
       */
      type?: string
    }
    ```

    #### browser.testerScripts

    - **Type:** `BrowserScript[]`
    - **Default:** `[]`

    Custom scripts that should be injected into the tester HTML before the tests environment is initiated. This is useful to inject polyfills required for Vitest browser implementation. It is recommended to use [`setupFiles`](#setupfiles) in almost all cases instead of this.

    The script `src` and `content` will be processed by Vite plugins.

    #### browser.commands

    - **Type:** `Record<string, BrowserCommand>`
    - **Default:** `{ readFile, writeFile, ... }`

    Custom [commands](../guide/browser/commands) that can be import during browser tests from `@vitest/browser/commands`.
- name: cache *  ​
  id: config/index#cache
  summary: Use this option if you want to disable the cache feature
  belongs_to: Configuring Vitest
  description: "### cache \\* \n\n- **Type**: `false`\n- **CLI**: `--no-cache`, `--cache=false`\n\nUse this option if you want to disable the cache feature. At the moment Vitest stores cache for test results to run the longer and failed tests first.\n\nThe cache directory is controlled by the Vite's [`cacheDir`](https://vitejs.dev/config/shared-options.html#cachedir) option:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  cacheDir: 'custom-folder/.vitest'\n})\n```\n\nYou can limit the directory only for Vitest by using `process.env.VITEST`:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  cacheDir: process.env.VITEST ? 'custom-folder/.vitest' : undefined\n})\n```"
- name: chaiConfig ​
  id: config/index#chaiconfig
  summary: Equivalent to Chai config
  belongs_to: Configuring Vitest
  description: |-
    ### chaiConfig

    - **Type:** `{ includeStack?, showDiff?, truncateThreshold? }`
    - **Default:** `{ includeStack: false, showDiff: true, truncateThreshold: 40 }`

    Equivalent to [Chai config](https://github.com/chaijs/chai/blob/4.x.x/lib/chai/config.js).

    #### chaiConfig.includeStack

    - **Type:** `boolean`
    - **Default:** `false`

    Influences whether stack trace is included in Assertion error message. Default of false suppresses stack trace in the error message.

    #### chaiConfig.showDiff

    - **Type:** `boolean`
    - **Default:** `true`

    Influences whether or not the `showDiff` flag should be included in the thrown AssertionErrors. `false` will always be `false`; `true` will be true when the assertion has requested a diff to be shown.

    #### chaiConfig.truncateThreshold

    - **Type:** `number`
    - **Default:** `40`

    Sets length threshold for actual and expected values in assertion errors. If this threshold is exceeded, for example for large data structures, the value is replaced with something like `[ Array(3) ]` or `{ Object (prop1, prop2) }`. Set it to `0` if you want to disable truncating altogether.

    This config option affects truncating values in `test.each` titles and inside the assertion error message.
- name: changes ​
  id: api/assert#changes
  summary: Asserts that a modifier changes the object of a property
  belongs_to: assert
  description: |-
    ## changes

    - **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`

    Asserts that a `modifier` changes the `object` of a `property`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.changes', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 22 };
      assert.changes(fn, obj, 'val')
    })
    ```
- name: changesButNotBy ​
  id: api/assert#changesbutnotby
  summary: Asserts that a modifier does not change the object of a property or of a modifier return value by a change
  belongs_to: assert
  description: |-
    ## changesButNotBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change:number, message?: string) => void`

    Asserts that a `modifier` does not change the `object` of a `property` or of a `modifier` return value by a `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.changesButNotBy', () => {
      const obj = { val: 10 }
      function fn() { obj.val += 10 };
      assert.changesButNotBy(fn, obj, 'val', 5)
    })
    ```
- name: changesBy ​
  id: api/assert#changesby
  summary: Asserts that a modifier changes the object of a property by a change
  belongs_to: assert
  description: |-
    ## changesBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`

    Asserts that a `modifier` changes the `object` of a `property` by a `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.changesBy', () => {
      const obj = { val: 10 }
      function fn() { obj.val += 2 };
      assert.changesBy(fn, obj, 'val', 2)
    })
    ```
- name: clearMocks ​
  id: config/index#clearmocks
  summary: Will call .mockClear() on all spies before each test
  belongs_to: Configuring Vitest
  description: |-
    ### clearMocks

    - **Type:** `boolean`
    - **Default:** `false`

    Will call [`.mockClear()`](../api/mock#mockclear) on all spies before each test. This will clear mock history, but not reset its implementation to the default one.
- name: closeTo ​
  id: api/assert#closeto
  summary: Asserts that the actual is equal expected, to within a +/- delta range
  belongs_to: assert
  description: |-
    ## closeTo

    - **Type:** `(actual: number, expected: number, delta: number, message?: string) => void`
    - **Alias:** `approximately`

    Asserts that the `actual` is equal `expected`, to within a +/- `delta` range.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.closeTo', () => {
      assert.closeTo(1.5, 1, 0.5, 'numbers are close')
    })
    ```
- name: Command Line Interface
  id: guide/cli
  summary: Start Vitest in the current directory
  description: "# Command Line Interface\n\n## Commands\n\n### `vitest`\n\nStart Vitest in the current directory. Will enter the watch mode in development environment and run mode in CI automatically.\n\nYou can pass an additional argument as the filter of the test files to run. For example:\n\nbash\n\n``` javascript\nvitest foobar\n```\n\nWill run only the test file that contains `foobar` in their paths. This filter only checks inclusion and doesn't support regexp or glob patterns (unless your terminal processes it before Vitest receives the filter).\n\n### `vitest run`\n\nPerform a single run without watch mode.\n\n### `vitest watch`\n\nRun all test suites but watch for changes and rerun tests when they change. Same as calling `vitest` without an argument. Will fallback to `vitest run` in CI.\n\n### `vitest dev`\n\nAlias to `vitest watch`.\n\n### `vitest related`\n\nRun only tests that cover a list of source files. Works with static imports (e.g., `import('./index.js')` or `import index from './index.js`), but not the dynamic ones (e.g., `import(filepath)`). All files should be relative to root folder.\n\nUseful to run with [`lint-staged`](https://github.com/okonet/lint-staged) or with your CI setup.\n\nbash\n\n``` javascript\nvitest related /src/index.ts /src/hello-world.js\n```\n\n**TIP**\n\nDon't forget that Vitest runs with enabled watch mode by default. If you are using tools like `lint-staged`, you should also pass `--run` option, so that command can exit normally.\n\njs\n\n``` javascript\n// .lintstagedrc.js\nexport default {\n  '*.{js,ts}': 'vitest related --run',\n}\n```\n\n### `vitest bench`\n\nRun only [benchmark](features#benchmarking-experimental) tests, which compare performance results.\n\n### `vitest init`\n\n`vitest init <name>` can be used to setup project configuration. At the moment, it only supports [`browser`](browser/index) value:\n\nbash\n\n``` javascript\nvitest init browser\n```\n\n### `vitest list`\n\n`vitest list` command inherits all `vitest` options to print the list of all matching tests. This command ignores `reporters` option. By default, it will print the names of all tests that matched the file filter and name pattern:\n\nshell\n\n``` javascript\nvitest list filename.spec.ts -t=\"some-test\"\n```\n\ntxt\n\n``` javascript\ndescribe > some-test\ndescribe > some-test > test 1\ndescribe > some-test > test 2\n```\n\nYou can pass down `--json` flag to print tests in JSON format or save it in a separate file:\n\nbash\n\n``` javascript\nvitest list filename.spec.ts -t=\"some-test\" --json=./file.json\n```\n\nIf `--json` flag doesn't receive a value, it will output the JSON into stdout.\n\n## Options\n\n| Options                                         |                                                                                                                                                                                                                                                                                        |\n|-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `-r, --root <path>`                             | Root path                                                                                                                                                                                                                                                                              |\n| `-c, --config <path>`                           | Path to config file                                                                                                                                                                                                                                                                    |\n| `-u, --update`                                  | Update snapshot                                                                                                                                                                                                                                                                        |\n| `-w, --watch`                                   | Enable watch mode                                                                                                                                                                                                                                                                      |\n| `-t, --testNamePattern <pattern>`               | Run tests with full names matching the specified regexp pattern                                                                                                                                                                                                                        |\n| `--dir <path>`                                  | Base directory to scan for the test files                                                                                                                                                                                                                                              |\n| `--ui`                                          | Enable UI                                                                                                                                                                                                                                                                              |\n| `--open`                                        | Open UI automatically (default: `!process.env.CI`)                                                                                                                                                                                                                                     |\n| `--api.port [port]`                             | Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to `51204`                                                                    |\n| `--api.host [host]`                             | Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses                                                                                                                                 |\n| `--api.strictPort`                              | Set to true to exit if port is already in use, instead of automatically trying the next available port                                                                                                                                                                                 |\n| `--silent`                                      | Silent console output from tests                                                                                                                                                                                                                                                       |\n| `--hideSkippedTests`                            | Hide logs for skipped tests                                                                                                                                                                                                                                                            |\n| `--reporter <name>`                             | Specify reporters                                                                                                                                                                                                                                                                      |\n| `--outputFile <filename/-s>`                    | Write test results to a file when supporter reporter is also specified, use cac's dot notation for individual outputs of multiple reporters (example: --outputFile.tap=./tap.txt)                                                                                                      |\n| `--coverage.all`                                | Whether to include all files, including the untested ones into report                                                                                                                                                                                                                  |\n| `--coverage.provider <name>`                    | Select the tool for coverage collection, available values are: \"v8\", \"istanbul\" and \"custom\"                                                                                                                                                                                           |\n| `--coverage.enabled`                            | Enables coverage collection. Can be overridden using the `--coverage` CLI option (default: `false`)                                                                                                                                                                                    |\n| `--coverage.include <pattern>`                  | Files included in coverage as glob patterns. May be specified more than once when using multiple patterns (default: `**`)                                                                                                                                                              |\n| `--coverage.exclude <pattern>`                  | Files to be excluded in coverage. May be specified more than once when using multiple extensions (default: Visit [`coverage.exclude`](../config/index#coverage-exclude))                                                                                                               |\n| `--coverage.extension <extension>`              | Extension to be included in coverage. May be specified more than once when using multiple extensions (default: `[\".js\", \".cjs\", \".mjs\", \".ts\", \".mts\", \".cts\", \".tsx\", \".jsx\", \".vue\", \".svelte\"]`)                                                                                    |\n| `--coverage.clean`                              | Clean coverage results before running tests (default: true)                                                                                                                                                                                                                            |\n| `--coverage.cleanOnRerun`                       | Clean coverage report on watch rerun (default: true)                                                                                                                                                                                                                                   |\n| `--coverage.reportsDirectory <path>`            | Directory to write coverage report to (default: ./coverage)                                                                                                                                                                                                                            |\n| `--coverage.reporter <name>`                    | Coverage reporters to use. Visit [`coverage.reporter`](../config/index#coverage-reporter) for more information (default: `[\"text\", \"html\", \"clover\", \"json\"]`)                                                                                                                         |\n| `--coverage.reportOnFailure`                    | Generate coverage report even when tests fail (default: `false`)                                                                                                                                                                                                                       |\n| `--coverage.allowExternal`                      | Collect coverage of files outside the project root (default: `false`)                                                                                                                                                                                                                  |\n| `--coverage.skipFull`                           | Do not show files with 100% statement, branch, and function coverage (default: `false`)                                                                                                                                                                                                |\n| `--coverage.thresholds.100`                     | Shortcut to set all coverage thresholds to 100 (default: `false`)                                                                                                                                                                                                                      |\n| `--coverage.thresholds.perFile`                 | Check thresholds per file. See `--coverage.thresholds.lines`, `--coverage.thresholds.functions`, `--coverage.thresholds.branches` and `--coverage.thresholds.statements` for the actual thresholds (default: `false`)                                                                  |\n| `--coverage.thresholds.autoUpdate`              | Update threshold values: \"lines\", \"functions\", \"branches\" and \"statements\" to configuration file when current coverage is above the configured thresholds (default: `false`)                                                                                                           |\n| `--coverage.thresholds.lines <number>`          | Threshold for lines. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                                 |\n| `--coverage.thresholds.functions <number>`      | Threshold for functions. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                             |\n| `--coverage.thresholds.branches <number>`       | Threshold for branches. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                              |\n| `--coverage.thresholds.statements <number>`     | Threshold for statements. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                            |\n| `--coverage.ignoreClassMethods <name>`          | Array of class method names to ignore for coverage. Visit [istanbuljs](https://github.com/istanbuljs/nyc#ignoring-methods) for more information. This option is only available for the istanbul providers (default: `[]`)                                                              |\n| `--coverage.processingConcurrency <number>`     | Concurrency limit used when processing the coverage results. (default min between 20 and the number of CPUs)                                                                                                                                                                           |\n| `--coverage.customProviderModule <path>`        | Specifies the module name or path for the custom coverage provider module. Visit [Custom Coverage Provider](coverage#custom-coverage-provider) for more information. This option is only available for custom providers                                                                |\n| `--coverage.watermarks.statements <watermarks>` | High and low watermarks for statements in the format of `<high>,<low>`                                                                                                                                                                                                                 |\n| `--coverage.watermarks.lines <watermarks>`      | High and low watermarks for lines in the format of `<high>,<low>`                                                                                                                                                                                                                      |\n| `--coverage.watermarks.branches <watermarks>`   | High and low watermarks for branches in the format of `<high>,<low>`                                                                                                                                                                                                                   |\n| `--coverage.watermarks.functions <watermarks>`  | High and low watermarks for functions in the format of `<high>,<low>`                                                                                                                                                                                                                  |\n| `--mode <name>`                                 | Override Vite mode (default: `test` or `benchmark`)                                                                                                                                                                                                                                    |\n| `--workspace <path>`                            | Path to a workspace configuration file                                                                                                                                                                                                                                                 |\n| `--isolate`                                     | Run every test file in isolation. To disable isolation, use `--no-isolate` (default: `true`)                                                                                                                                                                                           |\n| `--globals`                                     | Inject apis globally                                                                                                                                                                                                                                                                   |\n| `--dom`                                         | Mock browser API with happy-dom                                                                                                                                                                                                                                                        |\n| `--browser.enabled`                             | Run tests in the browser. Equivalent to `--browser.enabled` (default: `false`)                                                                                                                                                                                                         |\n| `--browser.name <name>`                         | Run all tests in a specific browser. Some browsers are only available for specific providers (see `--browser.provider`). Visit [`browser.name`](../config/index#browser-name) for more information                                                                                     |\n| `--browser.headless`                            | Run the browser in headless mode (i.e. without opening the GUI (Graphical User Interface)). If you are running Vitest in CI, it will be enabled by default (default: `process.env.CI`)                                                                                                 |\n| `--browser.api.port [port]`                     | Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to `63315`                                                                    |\n| `--browser.api.host [host]`                     | Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses                                                                                                                                 |\n| `--browser.api.strictPort`                      | Set to true to exit if port is already in use, instead of automatically trying the next available port                                                                                                                                                                                 |\n| `--browser.provider <name>`                     | Provider used to run browser tests. Some browsers are only available for specific providers. Can be \"webdriverio\", \"playwright\", \"preview\", or the path to a custom provider. Visit [`browser.provider`](../config/index#browser-provider) for more information (default: `\"preview\"`) |\n| `--browser.providerOptions <options>`           | Options that are passed down to a browser provider. Visit [`browser.providerOptions`](../config/index#browser-provideroptions) for more information                                                                                                                                    |\n| `--browser.isolate`                             | Run every browser test file in isolation. To disable isolation, use `--browser.isolate=false` (default: `true`)                                                                                                                                                                        |\n| `--browser.ui`                                  | Show Vitest UI when running tests (default: `!process.env.CI`)                                                                                                                                                                                                                         |\n| `--browser.fileParallelism`                     | Should browser test files run in parallel. Use `--browser.fileParallelism=false` to disable (default: `true`)                                                                                                                                                                          |\n| `--pool <pool>`                                 | Specify pool, if not running in the browser (default: `threads`)                                                                                                                                                                                                                       |\n| `--poolOptions.threads.isolate`                 | Isolate tests in threads pool (default: `true`)                                                                                                                                                                                                                                        |\n| `--poolOptions.threads.singleThread`            | Run tests inside a single thread (default: `false`)                                                                                                                                                                                                                                    |\n| `--poolOptions.threads.maxThreads <workers>`    | Maximum number or percentage of threads to run tests in                                                                                                                                                                                                                                |\n| `--poolOptions.threads.minThreads <workers>`    | Minimum number or percentage of threads to run tests in                                                                                                                                                                                                                                |\n| `--poolOptions.threads.useAtomics`              | Use Atomics to synchronize threads. This can improve performance in some cases, but might cause segfault in older Node versions (default: `false`)                                                                                                                                     |\n| `--poolOptions.vmThreads.isolate`               | Isolate tests in threads pool (default: `true`)                                                                                                                                                                                                                                        |\n| `--poolOptions.vmThreads.singleThread`          | Run tests inside a single thread (default: `false`)                                                                                                                                                                                                                                    |\n| `--poolOptions.vmThreads.maxThreads <workers>`  | Maximum number or percentage of threads to run tests in                                                                                                                                                                                                                                |\n| `--poolOptions.vmThreads.minThreads <workers>`  | Minimum number or percentage of threads to run tests in                                                                                                                                                                                                                                |\n| `--poolOptions.vmThreads.useAtomics`            | Use Atomics to synchronize threads. This can improve performance in some cases, but might cause segfault in older Node versions (default: `false`)                                                                                                                                     |\n| `--poolOptions.vmThreads.memoryLimit <limit>`   | Memory limit for VM threads pool. If you see memory leaks, try to tinker this value.                                                                                                                                                                                                   |\n| `--poolOptions.forks.isolate`                   | Isolate tests in forks pool (default: `true`)                                                                                                                                                                                                                                          |\n| `--poolOptions.forks.singleFork`                | Run tests inside a single child_process (default: `false`)                                                                                                                                                                                                                             |\n| `--poolOptions.forks.maxForks <workers>`        | Maximum number or percentage of processes to run tests in                                                                                                                                                                                                                              |\n| `--poolOptions.forks.minForks <workers>`        | Minimum number or percentage of processes to run tests in                                                                                                                                                                                                                              |\n| `--poolOptions.vmForks.isolate`                 | Isolate tests in forks pool (default: `true`)                                                                                                                                                                                                                                          |\n| `--poolOptions.vmForks.singleFork`              | Run tests inside a single child_process (default: `false`)                                                                                                                                                                                                                             |\n| `--poolOptions.vmForks.maxForks <workers>`      | Maximum number or percentage of processes to run tests in                                                                                                                                                                                                                              |\n| `--poolOptions.vmForks.minForks <workers>`      | Minimum number or percentage of processes to run tests in                                                                                                                                                                                                                              |\n| `--poolOptions.vmForks.memoryLimit <limit>`     | Memory limit for VM forks pool. If you see memory leaks, try to tinker this value.                                                                                                                                                                                                     |\n| `--fileParallelism`                             | Should all test files run in parallel. Use `--no-file-parallelism` to disable (default: `true`)                                                                                                                                                                                        |\n| `--maxWorkers <workers>`                        | Maximum number of workers to run tests in                                                                                                                                                                                                                                              |\n| `--minWorkers <workers>`                        | Minimum number of workers to run tests in                                                                                                                                                                                                                                              |\n| `--environment <name>`                          | Specify runner environment, if not running in the browser (default: `node`)                                                                                                                                                                                                            |\n| `--passWithNoTests`                             | Pass when no tests are found                                                                                                                                                                                                                                                           |\n| `--logHeapUsage`                                | Show the size of heap for each test when running in node                                                                                                                                                                                                                               |\n| `--allowOnly`                                   | Allow tests and suites that are marked as only (default: `!process.env.CI`)                                                                                                                                                                                                            |\n| `--dangerouslyIgnoreUnhandledErrors`            | Ignore any unhandled errors that occur                                                                                                                                                                                                                                                 |\n| `--shard <shards>`                              | Test suite shard to execute in a format of `<index>/<count>`                                                                                                                                                                                                                           |\n| `--changed [since]`                             | Run tests that are affected by the changed files (default: `false`)                                                                                                                                                                                                                    |\n| `--sequence.shuffle.files`                      | Run files in a random order. Long running tests will not start earlier if you enable this option. (default: `false`)                                                                                                                                                                   |\n| `--sequence.shuffle.tests`                      | Run tests in a random order (default: `false`)                                                                                                                                                                                                                                         |\n| `--sequence.concurrent`                         | Make tests run in parallel (default: `false`)                                                                                                                                                                                                                                          |\n| `--sequence.seed <seed>`                        | Set the randomization seed. This option will have no effect if --sequence.shuffle is falsy. Visit [\"Random Seed\" page](https://en.wikipedia.org/wiki/Random_seed) for more information                                                                                                 |\n| `--sequence.hooks <order>`                      | Changes the order in which hooks are executed. Accepted values are: \"stack\", \"list\" and \"parallel\". Visit [`sequence.hooks`](../config/index#sequence-hooks) for more information (default: `\"parallel\"`)                                                                              |\n| `--sequence.setupFiles <order>`                 | Changes the order in which setup files are executed. Accepted values are: \"list\" and \"parallel\". If set to \"list\", will run setup files in the order they are defined. If set to \"parallel\", will run setup files in parallel (default: `\"parallel\"`)                                  |\n| `--inspect [[host:]port]`                       | Enable Node.js inspector (default: `127.0.0.1:9229`)                                                                                                                                                                                                                                   |\n| `--inspectBrk [[host:]port]`                    | Enable Node.js inspector and break before the test starts                                                                                                                                                                                                                              |\n| `--testTimeout <timeout>`                       | Default timeout of a test in milliseconds (default: `5000`)                                                                                                                                                                                                                            |\n| `--hookTimeout <timeout>`                       | Default hook timeout in milliseconds (default: `10000`)                                                                                                                                                                                                                                |\n| `--bail <number>`                               | Stop test execution when given number of tests have failed (default: `0`)                                                                                                                                                                                                              |\n| `--retry <times>`                               | Retry the test specific number of times if it fails (default: `0`)                                                                                                                                                                                                                     |\n| `--diff <path>`                                 | Path to a diff config that will be used to generate diff interface                                                                                                                                                                                                                     |\n| `--exclude <glob>`                              | Additional file globs to be excluded from test                                                                                                                                                                                                                                         |\n| `--expandSnapshotDiff`                          | Show full diff when snapshot fails                                                                                                                                                                                                                                                     |\n| `--disableConsoleIntercept`                     | Disable automatic interception of console logging (default: `false`)                                                                                                                                                                                                                   |\n| `--typecheck.enabled`                           | Enable typechecking alongside tests (default: `false`)                                                                                                                                                                                                                                 |\n| `--typecheck.only`                              | Run only typecheck tests. This automatically enables typecheck (default: `false`)                                                                                                                                                                                                      |\n| `--typecheck.checker <name>`                    | Specify the typechecker to use. Available values are: \"tsc\" and \"vue-tsc\" and a path to an executable (default: `\"tsc\"`)                                                                                                                                                               |\n| `--typecheck.allowJs`                           | Allow JavaScript files to be typechecked. By default takes the value from tsconfig.json                                                                                                                                                                                                |\n| `--typecheck.ignoreSourceErrors`                | Ignore type errors from source files                                                                                                                                                                                                                                                   |\n| `--typecheck.tsconfig <path>`                   | Path to a custom tsconfig file                                                                                                                                                                                                                                                         |\n| `--project <name>`                              | The name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: `--project=1 --project=2`. You can also filter projects using wildcards like `--project=packages*`                                                               |\n| `--slowTestThreshold <threshold>`               | Threshold in milliseconds for a test to be considered slow (default: `300`)                                                                                                                                                                                                            |\n| `--teardownTimeout <timeout>`                   | Default timeout of a teardown function in milliseconds (default: `10000`)                                                                                                                                                                                                              |\n| `--maxConcurrency <number>`                     | Maximum number of concurrent tests in a suite (default: `5`)                                                                                                                                                                                                                           |\n| `--expect.requireAssertions`                    | Require that all tests have at least one assertion                                                                                                                                                                                                                                     |\n| `--expect.poll.interval <interval>`             | Poll interval in milliseconds for `expect.poll()` assertions (default: `50`)                                                                                                                                                                                                           |\n| `--expect.poll.timeout <timeout>`               | Poll timeout in milliseconds for `expect.poll()` assertions (default: `1000`)                                                                                                                                                                                                          |\n| `--printConsoleTrace`                           | Always print console stack traces                                                                                                                                                                                                                                                      |\n| `--run`                                         | Disable watch mode                                                                                                                                                                                                                                                                     |\n| `--no-color`                                    | Removes colors from the console output                                                                                                                                                                                                                                                 |\n| `--clearScreen`                                 | Clear terminal screen when re-running tests during watch mode (default: `true`)                                                                                                                                                                                                        |\n| `--standalone`                                  | Start Vitest without running tests. File filters will be ignored, tests will be running only on change (default: `false`)                                                                                                                                                              |\n| `--mergeReports [path]`                         | Paths to blob reports directory. If this options is used, Vitest won't run any tests, it will only report previously recorded tests                                                                                                                                                    |\n\n**TIP**\n\nVitest supports both camel case and kebab case for CLI arguments. For example, `--passWithNoTests` and `--pass-with-no-tests` will both work (`--no-color` and `--inspect-brk` are the exceptions).\n\nVitest also supports different ways of specifying the value: `--reporter dot` and `--reporter=dot` are both valid.\n\nIf option supports an array of values, you need to pass the option multiple times:\n\n``` javascript\nvitest --reporter=dot --reporter=default\n```\n\nBoolean options can be negated with `no-` prefix. Specifying the value as `false` also works:\n\n``` javascript\nvitest --no-api\nvitest --api=false\n```\n\n### changed\n\n- **Type**: `boolean | string`\n\n- **Default**: false\n\n  Run tests only against changed files. If no value is provided, it will run tests against uncommitted changes (including staged and unstaged).\n\n  To run tests against changes made in the last commit, you can use `--changed HEAD~1`. You can also pass commit hash (e.g. `--changed 09a9920`) or branch name (e.g. `--changed origin/develop`).\n\n  When used with code coverage the report will contain only the files that were related to the changes.\n\n  If paired with the [`forceRerunTriggers`](../config/index#forcereruntriggers) config option it will run the whole test suite if at least one of the files listed in the `forceRerunTriggers` list changes. By default, changes to the Vitest config file and `package.json` will always rerun the whole suite.\n\n### shard\n\n- **Type**: `string`\n\n- **Default**: disabled\n\n  Test suite shard to execute in a format of `<index>`/`<count>`, where\n\n  - `count` is a positive integer, count of divided parts\n  - `index` is a positive integer, index of divided part\n\n  This command will divide all tests into `count` equal parts, and will run only those that happen to be in an `index` part. For example, to split your tests suite into three parts, use this:\n\n  sh\n  ``` javascript\n  vitest run --shard=1/3\n  vitest run --shard=2/3\n  vitest run --shard=3/3\n  ```\n\n**WARNING**\n\nYou cannot use this option with `--watch` enabled (enabled in dev by default).\n\n**TIP**\n\nIf `--reporter=blob` is used without an output file, the default path will include the current shard config to avoid collisions with other Vitest processes.\n\n### merge-reports\n\n- **Type:** `boolean | string`\n\nMerges every blob report located in the specified folder (`.vitest-reports` by default). You can use any reporters with this command (except [`blob`](reporters#blob-reporter)):\n\nsh\n\n``` javascript\nvitest --merge-reports --reporter=junit\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/cli](https://vitest.dev/guide/cli)"
- name: 'Command Line Interface: changed ​'
  id: guide/cli#changed
  summary: Run tests only against changed files
  belongs_to: Command Line Interface
  description: |-
    ### changed

    - **Type**: `boolean | string`

    - **Default**: false

      Run tests only against changed files. If no value is provided, it will run tests against uncommitted changes (including staged and unstaged).

      To run tests against changes made in the last commit, you can use `--changed HEAD~1`. You can also pass commit hash (e.g. `--changed 09a9920`) or branch name (e.g. `--changed origin/develop`).

      When used with code coverage the report will contain only the files that were related to the changes.

      If paired with the [`forceRerunTriggers`](../config/index#forcereruntriggers) config option it will run the whole test suite if at least one of the files listed in the `forceRerunTriggers` list changes. By default, changes to the Vitest config file and `package.json` will always rerun the whole suite.
- name: 'Command Line Interface: Commands ​'
  id: guide/cli#commands
  summary: null
  belongs_to: Command Line Interface
  description: '## Commands'
- name: 'Command Line Interface: merge-reports ​'
  id: guide/cli#merge-reports
  summary: Merges every blob report located in the specified folder (.vitest-reports by default)
  belongs_to: Command Line Interface
  description: "### merge-reports\n\n- **Type:** `boolean | string`\n\nMerges every blob report located in the specified folder (`.vitest-reports` by default). You can use any reporters with this command (except [`blob`](reporters#blob-reporter)):\n\nsh\n\n``` javascript\nvitest --merge-reports --reporter=junit\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/cli](https://vitest.dev/guide/cli)"
- name: 'Command Line Interface: Options ​'
  id: guide/cli#options
  summary: Vitest supports both camel case and kebab case for CLI arguments
  belongs_to: Command Line Interface
  description: |-
    ## Options

    | Options                                         |                                                                                                                                                                                                                                                                                        |
    |-------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    | `-r, --root <path>`                             | Root path                                                                                                                                                                                                                                                                              |
    | `-c, --config <path>`                           | Path to config file                                                                                                                                                                                                                                                                    |
    | `-u, --update`                                  | Update snapshot                                                                                                                                                                                                                                                                        |
    | `-w, --watch`                                   | Enable watch mode                                                                                                                                                                                                                                                                      |
    | `-t, --testNamePattern <pattern>`               | Run tests with full names matching the specified regexp pattern                                                                                                                                                                                                                        |
    | `--dir <path>`                                  | Base directory to scan for the test files                                                                                                                                                                                                                                              |
    | `--ui`                                          | Enable UI                                                                                                                                                                                                                                                                              |
    | `--open`                                        | Open UI automatically (default: `!process.env.CI`)                                                                                                                                                                                                                                     |
    | `--api.port [port]`                             | Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to `51204`                                                                    |
    | `--api.host [host]`                             | Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses                                                                                                                                 |
    | `--api.strictPort`                              | Set to true to exit if port is already in use, instead of automatically trying the next available port                                                                                                                                                                                 |
    | `--silent`                                      | Silent console output from tests                                                                                                                                                                                                                                                       |
    | `--hideSkippedTests`                            | Hide logs for skipped tests                                                                                                                                                                                                                                                            |
    | `--reporter <name>`                             | Specify reporters                                                                                                                                                                                                                                                                      |
    | `--outputFile <filename/-s>`                    | Write test results to a file when supporter reporter is also specified, use cac's dot notation for individual outputs of multiple reporters (example: --outputFile.tap=./tap.txt)                                                                                                      |
    | `--coverage.all`                                | Whether to include all files, including the untested ones into report                                                                                                                                                                                                                  |
    | `--coverage.provider <name>`                    | Select the tool for coverage collection, available values are: "v8", "istanbul" and "custom"                                                                                                                                                                                           |
    | `--coverage.enabled`                            | Enables coverage collection. Can be overridden using the `--coverage` CLI option (default: `false`)                                                                                                                                                                                    |
    | `--coverage.include <pattern>`                  | Files included in coverage as glob patterns. May be specified more than once when using multiple patterns (default: `**`)                                                                                                                                                              |
    | `--coverage.exclude <pattern>`                  | Files to be excluded in coverage. May be specified more than once when using multiple extensions (default: Visit [`coverage.exclude`](../config/index#coverage-exclude))                                                                                                               |
    | `--coverage.extension <extension>`              | Extension to be included in coverage. May be specified more than once when using multiple extensions (default: `[".js", ".cjs", ".mjs", ".ts", ".mts", ".cts", ".tsx", ".jsx", ".vue", ".svelte"]`)                                                                                    |
    | `--coverage.clean`                              | Clean coverage results before running tests (default: true)                                                                                                                                                                                                                            |
    | `--coverage.cleanOnRerun`                       | Clean coverage report on watch rerun (default: true)                                                                                                                                                                                                                                   |
    | `--coverage.reportsDirectory <path>`            | Directory to write coverage report to (default: ./coverage)                                                                                                                                                                                                                            |
    | `--coverage.reporter <name>`                    | Coverage reporters to use. Visit [`coverage.reporter`](../config/index#coverage-reporter) for more information (default: `["text", "html", "clover", "json"]`)                                                                                                                         |
    | `--coverage.reportOnFailure`                    | Generate coverage report even when tests fail (default: `false`)                                                                                                                                                                                                                       |
    | `--coverage.allowExternal`                      | Collect coverage of files outside the project root (default: `false`)                                                                                                                                                                                                                  |
    | `--coverage.skipFull`                           | Do not show files with 100% statement, branch, and function coverage (default: `false`)                                                                                                                                                                                                |
    | `--coverage.thresholds.100`                     | Shortcut to set all coverage thresholds to 100 (default: `false`)                                                                                                                                                                                                                      |
    | `--coverage.thresholds.perFile`                 | Check thresholds per file. See `--coverage.thresholds.lines`, `--coverage.thresholds.functions`, `--coverage.thresholds.branches` and `--coverage.thresholds.statements` for the actual thresholds (default: `false`)                                                                  |
    | `--coverage.thresholds.autoUpdate`              | Update threshold values: "lines", "functions", "branches" and "statements" to configuration file when current coverage is above the configured thresholds (default: `false`)                                                                                                           |
    | `--coverage.thresholds.lines <number>`          | Threshold for lines. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                                 |
    | `--coverage.thresholds.functions <number>`      | Threshold for functions. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                             |
    | `--coverage.thresholds.branches <number>`       | Threshold for branches. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                              |
    | `--coverage.thresholds.statements <number>`     | Threshold for statements. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers                                                                                                            |
    | `--coverage.ignoreClassMethods <name>`          | Array of class method names to ignore for coverage. Visit [istanbuljs](https://github.com/istanbuljs/nyc#ignoring-methods) for more information. This option is only available for the istanbul providers (default: `[]`)                                                              |
    | `--coverage.processingConcurrency <number>`     | Concurrency limit used when processing the coverage results. (default min between 20 and the number of CPUs)                                                                                                                                                                           |
    | `--coverage.customProviderModule <path>`        | Specifies the module name or path for the custom coverage provider module. Visit [Custom Coverage Provider](coverage#custom-coverage-provider) for more information. This option is only available for custom providers                                                                |
    | `--coverage.watermarks.statements <watermarks>` | High and low watermarks for statements in the format of `<high>,<low>`                                                                                                                                                                                                                 |
    | `--coverage.watermarks.lines <watermarks>`      | High and low watermarks for lines in the format of `<high>,<low>`                                                                                                                                                                                                                      |
    | `--coverage.watermarks.branches <watermarks>`   | High and low watermarks for branches in the format of `<high>,<low>`                                                                                                                                                                                                                   |
    | `--coverage.watermarks.functions <watermarks>`  | High and low watermarks for functions in the format of `<high>,<low>`                                                                                                                                                                                                                  |
    | `--mode <name>`                                 | Override Vite mode (default: `test` or `benchmark`)                                                                                                                                                                                                                                    |
    | `--workspace <path>`                            | Path to a workspace configuration file                                                                                                                                                                                                                                                 |
    | `--isolate`                                     | Run every test file in isolation. To disable isolation, use `--no-isolate` (default: `true`)                                                                                                                                                                                           |
    | `--globals`                                     | Inject apis globally                                                                                                                                                                                                                                                                   |
    | `--dom`                                         | Mock browser API with happy-dom                                                                                                                                                                                                                                                        |
    | `--browser.enabled`                             | Run tests in the browser. Equivalent to `--browser.enabled` (default: `false`)                                                                                                                                                                                                         |
    | `--browser.name <name>`                         | Run all tests in a specific browser. Some browsers are only available for specific providers (see `--browser.provider`). Visit [`browser.name`](../config/index#browser-name) for more information                                                                                     |
    | `--browser.headless`                            | Run the browser in headless mode (i.e. without opening the GUI (Graphical User Interface)). If you are running Vitest in CI, it will be enabled by default (default: `process.env.CI`)                                                                                                 |
    | `--browser.api.port [port]`                     | Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to `63315`                                                                    |
    | `--browser.api.host [host]`                     | Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses                                                                                                                                 |
    | `--browser.api.strictPort`                      | Set to true to exit if port is already in use, instead of automatically trying the next available port                                                                                                                                                                                 |
    | `--browser.provider <name>`                     | Provider used to run browser tests. Some browsers are only available for specific providers. Can be "webdriverio", "playwright", "preview", or the path to a custom provider. Visit [`browser.provider`](../config/index#browser-provider) for more information (default: `"preview"`) |
    | `--browser.providerOptions <options>`           | Options that are passed down to a browser provider. Visit [`browser.providerOptions`](../config/index#browser-provideroptions) for more information                                                                                                                                    |
    | `--browser.isolate`                             | Run every browser test file in isolation. To disable isolation, use `--browser.isolate=false` (default: `true`)                                                                                                                                                                        |
    | `--browser.ui`                                  | Show Vitest UI when running tests (default: `!process.env.CI`)                                                                                                                                                                                                                         |
    | `--browser.fileParallelism`                     | Should browser test files run in parallel. Use `--browser.fileParallelism=false` to disable (default: `true`)                                                                                                                                                                          |
    | `--pool <pool>`                                 | Specify pool, if not running in the browser (default: `threads`)                                                                                                                                                                                                                       |
    | `--poolOptions.threads.isolate`                 | Isolate tests in threads pool (default: `true`)                                                                                                                                                                                                                                        |
    | `--poolOptions.threads.singleThread`            | Run tests inside a single thread (default: `false`)                                                                                                                                                                                                                                    |
    | `--poolOptions.threads.maxThreads <workers>`    | Maximum number or percentage of threads to run tests in                                                                                                                                                                                                                                |
    | `--poolOptions.threads.minThreads <workers>`    | Minimum number or percentage of threads to run tests in                                                                                                                                                                                                                                |
    | `--poolOptions.threads.useAtomics`              | Use Atomics to synchronize threads. This can improve performance in some cases, but might cause segfault in older Node versions (default: `false`)                                                                                                                                     |
    | `--poolOptions.vmThreads.isolate`               | Isolate tests in threads pool (default: `true`)                                                                                                                                                                                                                                        |
    | `--poolOptions.vmThreads.singleThread`          | Run tests inside a single thread (default: `false`)                                                                                                                                                                                                                                    |
    | `--poolOptions.vmThreads.maxThreads <workers>`  | Maximum number or percentage of threads to run tests in                                                                                                                                                                                                                                |
    | `--poolOptions.vmThreads.minThreads <workers>`  | Minimum number or percentage of threads to run tests in                                                                                                                                                                                                                                |
    | `--poolOptions.vmThreads.useAtomics`            | Use Atomics to synchronize threads. This can improve performance in some cases, but might cause segfault in older Node versions (default: `false`)                                                                                                                                     |
    | `--poolOptions.vmThreads.memoryLimit <limit>`   | Memory limit for VM threads pool. If you see memory leaks, try to tinker this value.                                                                                                                                                                                                   |
    | `--poolOptions.forks.isolate`                   | Isolate tests in forks pool (default: `true`)                                                                                                                                                                                                                                          |
    | `--poolOptions.forks.singleFork`                | Run tests inside a single child_process (default: `false`)                                                                                                                                                                                                                             |
    | `--poolOptions.forks.maxForks <workers>`        | Maximum number or percentage of processes to run tests in                                                                                                                                                                                                                              |
    | `--poolOptions.forks.minForks <workers>`        | Minimum number or percentage of processes to run tests in                                                                                                                                                                                                                              |
    | `--poolOptions.vmForks.isolate`                 | Isolate tests in forks pool (default: `true`)                                                                                                                                                                                                                                          |
    | `--poolOptions.vmForks.singleFork`              | Run tests inside a single child_process (default: `false`)                                                                                                                                                                                                                             |
    | `--poolOptions.vmForks.maxForks <workers>`      | Maximum number or percentage of processes to run tests in                                                                                                                                                                                                                              |
    | `--poolOptions.vmForks.minForks <workers>`      | Minimum number or percentage of processes to run tests in                                                                                                                                                                                                                              |
    | `--poolOptions.vmForks.memoryLimit <limit>`     | Memory limit for VM forks pool. If you see memory leaks, try to tinker this value.                                                                                                                                                                                                     |
    | `--fileParallelism`                             | Should all test files run in parallel. Use `--no-file-parallelism` to disable (default: `true`)                                                                                                                                                                                        |
    | `--maxWorkers <workers>`                        | Maximum number of workers to run tests in                                                                                                                                                                                                                                              |
    | `--minWorkers <workers>`                        | Minimum number of workers to run tests in                                                                                                                                                                                                                                              |
    | `--environment <name>`                          | Specify runner environment, if not running in the browser (default: `node`)                                                                                                                                                                                                            |
    | `--passWithNoTests`                             | Pass when no tests are found                                                                                                                                                                                                                                                           |
    | `--logHeapUsage`                                | Show the size of heap for each test when running in node                                                                                                                                                                                                                               |
    | `--allowOnly`                                   | Allow tests and suites that are marked as only (default: `!process.env.CI`)                                                                                                                                                                                                            |
    | `--dangerouslyIgnoreUnhandledErrors`            | Ignore any unhandled errors that occur                                                                                                                                                                                                                                                 |
    | `--shard <shards>`                              | Test suite shard to execute in a format of `<index>/<count>`                                                                                                                                                                                                                           |
    | `--changed [since]`                             | Run tests that are affected by the changed files (default: `false`)                                                                                                                                                                                                                    |
    | `--sequence.shuffle.files`                      | Run files in a random order. Long running tests will not start earlier if you enable this option. (default: `false`)                                                                                                                                                                   |
    | `--sequence.shuffle.tests`                      | Run tests in a random order (default: `false`)                                                                                                                                                                                                                                         |
    | `--sequence.concurrent`                         | Make tests run in parallel (default: `false`)                                                                                                                                                                                                                                          |
    | `--sequence.seed <seed>`                        | Set the randomization seed. This option will have no effect if --sequence.shuffle is falsy. Visit ["Random Seed" page](https://en.wikipedia.org/wiki/Random_seed) for more information                                                                                                 |
    | `--sequence.hooks <order>`                      | Changes the order in which hooks are executed. Accepted values are: "stack", "list" and "parallel". Visit [`sequence.hooks`](../config/index#sequence-hooks) for more information (default: `"parallel"`)                                                                              |
    | `--sequence.setupFiles <order>`                 | Changes the order in which setup files are executed. Accepted values are: "list" and "parallel". If set to "list", will run setup files in the order they are defined. If set to "parallel", will run setup files in parallel (default: `"parallel"`)                                  |
    | `--inspect [[host:]port]`                       | Enable Node.js inspector (default: `127.0.0.1:9229`)                                                                                                                                                                                                                                   |
    | `--inspectBrk [[host:]port]`                    | Enable Node.js inspector and break before the test starts                                                                                                                                                                                                                              |
    | `--testTimeout <timeout>`                       | Default timeout of a test in milliseconds (default: `5000`)                                                                                                                                                                                                                            |
    | `--hookTimeout <timeout>`                       | Default hook timeout in milliseconds (default: `10000`)                                                                                                                                                                                                                                |
    | `--bail <number>`                               | Stop test execution when given number of tests have failed (default: `0`)                                                                                                                                                                                                              |
    | `--retry <times>`                               | Retry the test specific number of times if it fails (default: `0`)                                                                                                                                                                                                                     |
    | `--diff <path>`                                 | Path to a diff config that will be used to generate diff interface                                                                                                                                                                                                                     |
    | `--exclude <glob>`                              | Additional file globs to be excluded from test                                                                                                                                                                                                                                         |
    | `--expandSnapshotDiff`                          | Show full diff when snapshot fails                                                                                                                                                                                                                                                     |
    | `--disableConsoleIntercept`                     | Disable automatic interception of console logging (default: `false`)                                                                                                                                                                                                                   |
    | `--typecheck.enabled`                           | Enable typechecking alongside tests (default: `false`)                                                                                                                                                                                                                                 |
    | `--typecheck.only`                              | Run only typecheck tests. This automatically enables typecheck (default: `false`)                                                                                                                                                                                                      |
    | `--typecheck.checker <name>`                    | Specify the typechecker to use. Available values are: "tsc" and "vue-tsc" and a path to an executable (default: `"tsc"`)                                                                                                                                                               |
    | `--typecheck.allowJs`                           | Allow JavaScript files to be typechecked. By default takes the value from tsconfig.json                                                                                                                                                                                                |
    | `--typecheck.ignoreSourceErrors`                | Ignore type errors from source files                                                                                                                                                                                                                                                   |
    | `--typecheck.tsconfig <path>`                   | Path to a custom tsconfig file                                                                                                                                                                                                                                                         |
    | `--project <name>`                              | The name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: `--project=1 --project=2`. You can also filter projects using wildcards like `--project=packages*`                                                               |
    | `--slowTestThreshold <threshold>`               | Threshold in milliseconds for a test to be considered slow (default: `300`)                                                                                                                                                                                                            |
    | `--teardownTimeout <timeout>`                   | Default timeout of a teardown function in milliseconds (default: `10000`)                                                                                                                                                                                                              |
    | `--maxConcurrency <number>`                     | Maximum number of concurrent tests in a suite (default: `5`)                                                                                                                                                                                                                           |
    | `--expect.requireAssertions`                    | Require that all tests have at least one assertion                                                                                                                                                                                                                                     |
    | `--expect.poll.interval <interval>`             | Poll interval in milliseconds for `expect.poll()` assertions (default: `50`)                                                                                                                                                                                                           |
    | `--expect.poll.timeout <timeout>`               | Poll timeout in milliseconds for `expect.poll()` assertions (default: `1000`)                                                                                                                                                                                                          |
    | `--printConsoleTrace`                           | Always print console stack traces                                                                                                                                                                                                                                                      |
    | `--run`                                         | Disable watch mode                                                                                                                                                                                                                                                                     |
    | `--no-color`                                    | Removes colors from the console output                                                                                                                                                                                                                                                 |
    | `--clearScreen`                                 | Clear terminal screen when re-running tests during watch mode (default: `true`)                                                                                                                                                                                                        |
    | `--standalone`                                  | Start Vitest without running tests. File filters will be ignored, tests will be running only on change (default: `false`)                                                                                                                                                              |
    | `--mergeReports [path]`                         | Paths to blob reports directory. If this options is used, Vitest won't run any tests, it will only report previously recorded tests                                                                                                                                                    |

    **TIP**

    Vitest supports both camel case and kebab case for CLI arguments. For example, `--passWithNoTests` and `--pass-with-no-tests` will both work (`--no-color` and `--inspect-brk` are the exceptions).

    Vitest also supports different ways of specifying the value: `--reporter dot` and `--reporter=dot` are both valid.

    If option supports an array of values, you need to pass the option multiple times:

    ``` javascript
    vitest --reporter=dot --reporter=default
    ```

    Boolean options can be negated with `no-` prefix. Specifying the value as `false` also works:

    ``` javascript
    vitest --no-api
    vitest --api=false
    ```
- name: 'Command Line Interface: shard ​'
  id: guide/cli#shard
  summary: This command will divide all tests into count equal parts, and will run only those that happen to be in an index part
  belongs_to: Command Line Interface
  description: |-
    ### shard

    - **Type**: `string`

    - **Default**: disabled

      Test suite shard to execute in a format of `<index>`/`<count>`, where

      - `count` is a positive integer, count of divided parts
      - `index` is a positive integer, index of divided part

      This command will divide all tests into `count` equal parts, and will run only those that happen to be in an `index` part. For example, to split your tests suite into three parts, use this:

      sh
      ``` javascript
      vitest run --shard=1/3
      vitest run --shard=2/3
      vitest run --shard=3/3
      ```

    **WARNING**

    You cannot use this option with `--watch` enabled (enabled in dev by default).

    **TIP**

    If `--reporter=blob` is used without an output file, the default path will include the current shard config to avoid collisions with other Vitest processes.
- name: 'Command Line Interface: vitest bench ​'
  id: guide/cli#vitest-bench
  summary: Run only benchmark tests, which compare performance results
  belongs_to: Command Line Interface
  description: |-
    ### `vitest bench`

    Run only [benchmark](features#benchmarking-experimental) tests, which compare performance results.
- name: 'Command Line Interface: vitest dev ​'
  id: guide/cli#vitest-dev
  summary: Alias to vitest watch
  belongs_to: Command Line Interface
  description: |-
    ### `vitest dev`

    Alias to `vitest watch`.
- name: 'Command Line Interface: vitest init ​'
  id: guide/cli#vitest-init
  summary: vitest init <name> can be used to setup project configuration
  belongs_to: Command Line Interface
  description: |-
    ### `vitest init`

    `vitest init <name>` can be used to setup project configuration. At the moment, it only supports [`browser`](browser/index) value:

    bash

    ``` javascript
    vitest init browser
    ```
- name: 'Command Line Interface: vitest list ​'
  id: guide/cli#vitest-list
  summary: vitest list command inherits all vitest options to print the list of all matching tests
  belongs_to: Command Line Interface
  description: |-
    ### `vitest list`

    `vitest list` command inherits all `vitest` options to print the list of all matching tests. This command ignores `reporters` option. By default, it will print the names of all tests that matched the file filter and name pattern:

    shell

    ``` javascript
    vitest list filename.spec.ts -t="some-test"
    ```

    txt

    ``` javascript
    describe > some-test
    describe > some-test > test 1
    describe > some-test > test 2
    ```

    You can pass down `--json` flag to print tests in JSON format or save it in a separate file:

    bash

    ``` javascript
    vitest list filename.spec.ts -t="some-test" --json=./file.json
    ```

    If `--json` flag doesn't receive a value, it will output the JSON into stdout.
- name: 'Command Line Interface: vitest related ​'
  id: guide/cli#vitest-related
  summary: Run only tests that cover a list of source files
  belongs_to: Command Line Interface
  description: |-
    ### `vitest related`

    Run only tests that cover a list of source files. Works with static imports (e.g., `import('./index.js')` or `import index from './index.js`), but not the dynamic ones (e.g., `import(filepath)`). All files should be relative to root folder.

    Useful to run with [`lint-staged`](https://github.com/okonet/lint-staged) or with your CI setup.

    bash

    ``` javascript
    vitest related /src/index.ts /src/hello-world.js
    ```

    **TIP**

    Don't forget that Vitest runs with enabled watch mode by default. If you are using tools like `lint-staged`, you should also pass `--run` option, so that command can exit normally.

    js

    ``` javascript
    // .lintstagedrc.js
    export default {
      '*.{js,ts}': 'vitest related --run',
    }
    ```
- name: 'Command Line Interface: vitest run ​'
  id: guide/cli#vitest-run
  summary: Perform a single run without watch mode
  belongs_to: Command Line Interface
  description: |-
    ### `vitest run`

    Perform a single run without watch mode.
- name: 'Command Line Interface: vitest watch ​'
  id: guide/cli#vitest-watch
  summary: Run all test suites but watch for changes and rerun tests when they change
  belongs_to: Command Line Interface
  description: |-
    ### `vitest watch`

    Run all test suites but watch for changes and rerun tests when they change. Same as calling `vitest` without an argument. Will fallback to `vitest run` in CI.
- name: 'Command Line Interface: vitest ​'
  id: guide/cli#vitest
  summary: Start Vitest in the current directory
  belongs_to: Command Line Interface
  description: |-
    ### `vitest`

    Start Vitest in the current directory. Will enter the watch mode in development environment and run mode in CI automatically.

    You can pass an additional argument as the filter of the test files to run. For example:

    bash

    ``` javascript
    vitest foobar
    ```

    Will run only the test file that contains `foobar` in their paths. This filter only checks inclusion and doesn't support regexp or glob patterns (unless your terminal processes it before Vitest receives the filter).
- name: Commands
  id: guide/browser/commands
  summary: Command is a function that invokes another function on the server and passes down the result back to the browser
  description: "# Commands\n\nCommand is a function that invokes another function on the server and passes down the result back to the browser. Vitest exposes several built-in commands you can use in your browser tests.\n\n## Built-in Commands\n\n### Files Handling\n\nYou can use `readFile`, `writeFile` and `removeFile` API to handle files inside your browser tests. All paths are resolved relative to the test file even if they are called in a helper function located in another file.\n\nBy default, Vitest uses `utf-8` encoding but you can override it with options.\n\n**TIP**\n\nThis API follows [`server.fs`](https://vitejs.dev/config/server-options.html#server-fs-allow) limitations for security reasons.\n\nts\n\n``` javascript\nimport { server } from '@vitest/browser/context'\n\nconst { readFile, writeFile, removeFile } = server.commands\n\nit('handles files', async () => {\n  const file = './test.txt'\n\n  await writeFile(file, 'hello world')\n  const content = await readFile(file)\n\n  expect(content).toBe('hello world')\n\n  await removeFile(file)\n})\n```\n\n## CDP Session\n\nVitest exposes access to raw Chrome Devtools Protocol via the `cdp` method exported from `@vitest/browser/context`. It is mostly useful to library authors to build tools on top of it.\n\nts\n\n``` javascript\nimport { cdp } from '@vitest/browser/context'\n\nconst input = document.createElement('input')\ndocument.body.appendChild(input)\ninput.focus()\n\nawait cdp().send('Input.dispatchKeyEvent', {\n  type: 'keyDown',\n  text: 'a',\n})\n\nexpect(input).toHaveValue('a')\n```\n\n**WARNING**\n\nCDP session works only with `playwright` provider and only when using `chromium` browser. You can read more about it in playwright's [`CDPSession`](https://playwright.dev/docs/api/class-cdpsession) documentation.\n\n## Custom Commands\n\nYou can also add your own commands via [`browser.commands`](../../config/index#browser-commands) config option. If you develop a library, you can provide them via a `config` hook inside a plugin:\n\nts\n\n``` javascript\nimport type { Plugin } from 'vitest/config'\nimport type { BrowserCommand } from 'vitest/node'\n\nconst myCustomCommand: BrowserCommand<[arg1: string, arg2: string]> = ({\n  testPath,\n  provider\n}, arg1, arg2) => {\n  if (provider.name === 'playwright') {\n    console.log(testPath, arg1, arg2)\n    return { someValue: true }\n  }\n\n  throw new Error(`provider ${provider.name} is not supported`)\n}\n\nexport default function BrowserCommands(): Plugin {\n  return {\n    name: 'vitest:custom-commands',\n    config() {\n      return {\n        test: {\n          browser: {\n            commands: {\n              myCustomCommand,\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nThen you can call it inside your test by importing it from `@vitest/browser/context`:\n\nts\n\n``` javascript\nimport { commands } from '@vitest/browser/context'\nimport { expect, test } from 'vitest'\n\ntest('custom command works correctly', async () => {\n  const result = await commands.myCustomCommand('test1', 'test2')\n  expect(result).toEqual({ someValue: true })\n})\n\n// if you are using TypeScript, you can augment the module\ndeclare module '@vitest/browser/context' {\n  interface BrowserCommands {\n    myCustomCommand: (arg1: string, arg2: string) => Promise<{\n      someValue: true\n    }>\n  }\n}\n```\n\n**WARNING**\n\nCustom functions will override built-in ones if they have the same name.\n\n### Custom `playwright` commands\n\nVitest exposes several `playwright` specific properties on the command context.\n\n- `page` references the full page that contains the test iframe. This is the orchestrator HTML and you most likely shouldn't touch it to not break things.\n- `frame` is an async method that will resolve tester [`Frame`](https://playwright.dev/docs/api/class-frame). It has a simillar API to the `page`, but it doesn't support certain methods. If you need to query an element, you should prefer using `context.iframe` instead because it is more stable and faster.\n- `iframe` is a [`FrameLocator`](https://playwright.dev/docs/api/class-framelocator) that should be used to query other elements on the page.\n- `context` refers to the unique [BrowserContext](https://playwright.dev/docs/api/class-browsercontext).\n\nts\n\n``` javascript\nimport { defineCommand } from '@vitest/browser'\n\nexport const myCommand = defineCommand(async (ctx, arg1, arg2) => {\n  if (ctx.provider.name === 'playwright') {\n    const element = await ctx.iframe.findByRole('alert')\n    const screenshot = await element.screenshot()\n    // do something with the screenshot\n    return difference\n  }\n})\n```\n\n**TIP**\n\nIf you are using TypeScript, don't forget to add `@vitest/browser/providers/playwright` to your `tsconfig` \"compilerOptions.types\" field to get autocompletion in the config and on `userEvent` and `page` options:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/playwright\"\n    ]\n  }\n}\n```\n\n### Custom `webdriverio` commands\n\nVitest exposes some `webdriverio` specific properties on the context object.\n\n- `browser` is the `WebdriverIO.Browser` API.\n\nVitest automatically switches the `webdriver` context to the test iframe by calling `browser.switchToFrame` before the command is called, so `$` and `$$` methods refer to the elements inside the iframe, not in the orchestrator, but non-webdriver APIs will still refer to the parent frame context.\n\n**TIP**\n\nIf you are using TypeScript, don't forget to add `@vitest/browser/providers/webdriverio` to your `tsconfig` \"compilerOptions.types\" field to get autocompletion:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/webdriverio\"\n    ]\n  }\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/commands](https://vitest.dev/guide/browser/commands)"
- name: 'Commands: Built-in Commands ​'
  id: guide/browser/commands#built-in-commands
  summary: null
  belongs_to: Commands
  description: '## Built-in Commands'
- name: 'Commands: CDP Session ​'
  id: guide/browser/commands#cdp-session
  summary: Vitest exposes access to raw Chrome Devtools Protocol via the cdp method exported from @vitest/browser/context
  belongs_to: Commands
  description: |-
    ## CDP Session

    Vitest exposes access to raw Chrome Devtools Protocol via the `cdp` method exported from `@vitest/browser/context`. It is mostly useful to library authors to build tools on top of it.

    ts

    ``` javascript
    import { cdp } from '@vitest/browser/context'

    const input = document.createElement('input')
    document.body.appendChild(input)
    input.focus()

    await cdp().send('Input.dispatchKeyEvent', {
      type: 'keyDown',
      text: 'a',
    })

    expect(input).toHaveValue('a')
    ```

    **WARNING**

    CDP session works only with `playwright` provider and only when using `chromium` browser. You can read more about it in playwright's [`CDPSession`](https://playwright.dev/docs/api/class-cdpsession) documentation.
- name: 'Commands: Custom Commands ​'
  id: guide/browser/commands#custom-commands
  summary: You can also add your own commands via browser.commands config option
  belongs_to: Commands
  description: |-
    ## Custom Commands

    You can also add your own commands via [`browser.commands`](../../config/index#browser-commands) config option. If you develop a library, you can provide them via a `config` hook inside a plugin:

    ts

    ``` javascript
    import type { Plugin } from 'vitest/config'
    import type { BrowserCommand } from 'vitest/node'

    const myCustomCommand: BrowserCommand<[arg1: string, arg2: string]> = ({
      testPath,
      provider
    }, arg1, arg2) => {
      if (provider.name === 'playwright') {
        console.log(testPath, arg1, arg2)
        return { someValue: true }
      }

      throw new Error(`provider ${provider.name} is not supported`)
    }

    export default function BrowserCommands(): Plugin {
      return {
        name: 'vitest:custom-commands',
        config() {
          return {
            test: {
              browser: {
                commands: {
                  myCustomCommand,
                }
              }
            }
          }
        }
      }
    }
    ```

    Then you can call it inside your test by importing it from `@vitest/browser/context`:

    ts

    ``` javascript
    import { commands } from '@vitest/browser/context'
    import { expect, test } from 'vitest'

    test('custom command works correctly', async () => {
      const result = await commands.myCustomCommand('test1', 'test2')
      expect(result).toEqual({ someValue: true })
    })

    // if you are using TypeScript, you can augment the module
    declare module '@vitest/browser/context' {
      interface BrowserCommands {
        myCustomCommand: (arg1: string, arg2: string) => Promise<{
          someValue: true
        }>
      }
    }
    ```

    **WARNING**

    Custom functions will override built-in ones if they have the same name.
- name: 'Commands: Custom playwright commands ​'
  id: guide/browser/commands#custom-playwright-commands
  summary: Vitest exposes several playwright specific properties on the command context
  belongs_to: Commands
  description: |-
    ### Custom `playwright` commands

    Vitest exposes several `playwright` specific properties on the command context.

    - `page` references the full page that contains the test iframe. This is the orchestrator HTML and you most likely shouldn't touch it to not break things.
    - `frame` is an async method that will resolve tester [`Frame`](https://playwright.dev/docs/api/class-frame). It has a simillar API to the `page`, but it doesn't support certain methods. If you need to query an element, you should prefer using `context.iframe` instead because it is more stable and faster.
    - `iframe` is a [`FrameLocator`](https://playwright.dev/docs/api/class-framelocator) that should be used to query other elements on the page.
    - `context` refers to the unique [BrowserContext](https://playwright.dev/docs/api/class-browsercontext).

    ts

    ``` javascript
    import { defineCommand } from '@vitest/browser'

    export const myCommand = defineCommand(async (ctx, arg1, arg2) => {
      if (ctx.provider.name === 'playwright') {
        const element = await ctx.iframe.findByRole('alert')
        const screenshot = await element.screenshot()
        // do something with the screenshot
        return difference
      }
    })
    ```

    **TIP**

    If you are using TypeScript, don't forget to add `@vitest/browser/providers/playwright` to your `tsconfig` "compilerOptions.types" field to get autocompletion in the config and on `userEvent` and `page` options:

    json

    ``` javascript
    {
      "compilerOptions": {
        "types": [
          "@vitest/browser/providers/playwright"
        ]
      }
    }
    ```
- name: 'Commands: Custom webdriverio commands ​'
  id: guide/browser/commands#custom-webdriverio-commands
  summary: Vitest exposes some webdriverio specific properties on the context object
  belongs_to: Commands
  description: "### Custom `webdriverio` commands\n\nVitest exposes some `webdriverio` specific properties on the context object.\n\n- `browser` is the `WebdriverIO.Browser` API.\n\nVitest automatically switches the `webdriver` context to the test iframe by calling `browser.switchToFrame` before the command is called, so `$` and `$$` methods refer to the elements inside the iframe, not in the orchestrator, but non-webdriver APIs will still refer to the parent frame context.\n\n**TIP**\n\nIf you are using TypeScript, don't forget to add `@vitest/browser/providers/webdriverio` to your `tsconfig` \"compilerOptions.types\" field to get autocompletion:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/webdriverio\"\n    ]\n  }\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/commands](https://vitest.dev/guide/browser/commands)"
- name: 'Commands: Files Handling ​'
  id: guide/browser/commands#files-handling
  summary: You can use readFile, writeFile and removeFile API to handle files inside your browser tests
  belongs_to: Commands
  description: |-
    ### Files Handling

    You can use `readFile`, `writeFile` and `removeFile` API to handle files inside your browser tests. All paths are resolved relative to the test file even if they are called in a helper function located in another file.

    By default, Vitest uses `utf-8` encoding but you can override it with options.

    **TIP**

    This API follows [`server.fs`](https://vitejs.dev/config/server-options.html#server-fs-allow) limitations for security reasons.

    ts

    ``` javascript
    import { server } from '@vitest/browser/context'

    const { readFile, writeFile, removeFile } = server.commands

    it('handles files', async () => {
      const file = './test.txt'

      await writeFile(file, 'hello world')
      const content = await readFile(file)

      expect(content).toBe('hello world')

      await removeFile(file)
    })
    ```
- name: Common Errors
  id: guide/common-errors
  summary: This error happens when vi.mock method is called on a module that was already loaded
  description: "# Common Errors\n\n## Cannot find module './relative-path'\n\nIf you receive an error that module cannot be found, it might mean several different things:\n\n- 1.  You misspelled the path. Make sure the path is correct.\n- 2.  It's possible that your rely on `baseUrl` in your `tsconfig.json`. Vite doesn't take into account `tsconfig.json` by default, so you might need to install [`vite-tsconfig-paths`](https://www.npmjs.com/package/vite-tsconfig-paths) yourself, if you rely on this behaviour.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport tsconfigPaths from 'vite-tsconfig-paths'\n\nexport default defineConfig({\n  plugins: [tsconfigPaths()]\n})\n```\n\nOr rewrite your path to not be relative to root:\n\ndiff\n\n``` javascript\n- import helpers from 'src/helpers'\n+ import helpers from '../src/helpers'\n```\n\n- 3.  Make sure you don't have relative [aliases](../config/index#alias). Vite treats them as relative to the file where the import is instead of the root.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    alias: {\n      '@/': './src/', \n      '@/': new URL('./src/', import.meta.url).pathname, \n    }\n  }\n})\n```\n\n## Cannot mock \"./mocked-file.js\" because it is already loaded\n\nThis error happens when `vi.mock` method is called on a module that was already loaded. Vitest throws this error because this call has no effect since cached modules are preferred.\n\nRemember that `vi.mock` is always hoisted - it means that the module was loaded before the test file started executing - most likely in a setup file. To fix the error, remove the import or clear the cache at the end of a setup file - beware that setup file and your test file will reference different modules in that case.\n\nts\n\n``` javascript\n// setupFile.js\nimport { vi } from 'vitest'\nimport { sideEffect } from './mocked-file.js'\n\nsideEffect()\n\nvi.resetModules()\n```\n\n## Failed to terminate worker\n\nThis error can happen when NodeJS's `fetch` is used with default [`pool: 'threads'`](../config/index#threads). This issue is tracked on issue [Timeout abort can leave process(es) running in the background \\#3077](https://github.com/vitest-dev/vitest/issues/3077).\n\nAs work-around you can switch to [`pool: 'forks'`](../config/index#forks) or [`pool: 'vmForks'`](../config/index#vmforks).\n\nvitest.config.jsCLI\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'forks',\n  },\n})\n```\n\nbash\n\n``` javascript\nvitest --pool=forks\n```\n\n## Segfaults and native code errors\n\nRunning [native NodeJS modules](https://nodejs.org/api/addons.html) in `pool: 'threads'` can run into cryptic errors coming from the native code.\n\n- `Segmentation fault (core dumped)`\n- `thread '<unnamed>' panicked at 'assertion failed`\n- `Abort trap: 6`\n- `internal error: entered unreachable code`\n\nIn these cases the native module is likely not built to be multi-thread safe. As work-around, you can switch to `pool: 'forks'` which runs the test cases in multiple `node:child_process` instead of multiple `node:worker_threads`.\n\nvitest.config.jsCLI\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'forks',\n  },\n})\n```\n\nbash\n\n``` javascript\nvitest --pool=forks\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/common-errors](https://vitest.dev/guide/common-errors)"
- name: 'Common Errors: Cannot find module ''./relative-path'' ​'
  id: guide/common-errors#cannot-find-module-relative-path
  summary: null
  belongs_to: Common Errors
  description: "## Cannot find module './relative-path'\n\nIf you receive an error that module cannot be found, it might mean several different things:\n\n- 1.  You misspelled the path. Make sure the path is correct.\n- 2.  It's possible that your rely on `baseUrl` in your `tsconfig.json`. Vite doesn't take into account `tsconfig.json` by default, so you might need to install [`vite-tsconfig-paths`](https://www.npmjs.com/package/vite-tsconfig-paths) yourself, if you rely on this behaviour.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport tsconfigPaths from 'vite-tsconfig-paths'\n\nexport default defineConfig({\n  plugins: [tsconfigPaths()]\n})\n```\n\nOr rewrite your path to not be relative to root:\n\ndiff\n\n``` javascript\n- import helpers from 'src/helpers'\n+ import helpers from '../src/helpers'\n```\n\n- 3.  Make sure you don't have relative [aliases](../config/index#alias). Vite treats them as relative to the file where the import is instead of the root.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    alias: {\n      '@/': './src/', \n      '@/': new URL('./src/', import.meta.url).pathname, \n    }\n  }\n})\n```"
- name: 'Common Errors: Cannot mock "./mocked-file.js" because it is already loaded ​'
  id: guide/common-errors#cannot-mock-mocked-file-js-because-it-is-already-loaded
  summary: This error happens when vi.mock method is called on a module that was already loaded
  belongs_to: Common Errors
  description: |-
    ## Cannot mock "./mocked-file.js" because it is already loaded

    This error happens when `vi.mock` method is called on a module that was already loaded. Vitest throws this error because this call has no effect since cached modules are preferred.

    Remember that `vi.mock` is always hoisted - it means that the module was loaded before the test file started executing - most likely in a setup file. To fix the error, remove the import or clear the cache at the end of a setup file - beware that setup file and your test file will reference different modules in that case.

    ts

    ``` javascript
    // setupFile.js
    import { vi } from 'vitest'
    import { sideEffect } from './mocked-file.js'

    sideEffect()

    vi.resetModules()
    ```
- name: 'Common Errors: Failed to terminate worker ​'
  id: guide/common-errors#failed-to-terminate-worker
  summary: 'This error can happen when NodeJS''s fetch is used with default pool: ''threads''. This issue is tracked on issue Timeout abort can leave process(es) running in the background #3077'
  belongs_to: Common Errors
  description: |-
    ## Failed to terminate worker

    This error can happen when NodeJS's `fetch` is used with default [`pool: 'threads'`](../config/index#threads). This issue is tracked on issue [Timeout abort can leave process(es) running in the background \#3077](https://github.com/vitest-dev/vitest/issues/3077).

    As work-around you can switch to [`pool: 'forks'`](../config/index#forks) or [`pool: 'vmForks'`](../config/index#vmforks).

    vitest.config.js CLI

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        pool: 'forks',
      },
    })
    ```

    bash

    ``` javascript
    vitest --pool=forks
    ```
- name: 'Common Errors: Segfaults and native code errors ​'
  id: guide/common-errors#segfaults-and-native-code-errors
  summary: 'Running native NodeJS modules in pool: ''threads'' can run into cryptic errors coming from the native code'
  belongs_to: Common Errors
  description: "## Segfaults and native code errors\n\nRunning [native NodeJS modules](https://nodejs.org/api/addons.html) in `pool: 'threads'` can run into cryptic errors coming from the native code.\n\n- `Segmentation fault (core dumped)`\n- `thread '<unnamed>' panicked at 'assertion failed`\n- `Abort trap: 6`\n- `internal error: entered unreachable code`\n\nIn these cases the native module is likely not built to be multi-thread safe. As work-around, you can switch to `pool: 'forks'` which runs the test cases in multiple `node:child_process` instead of multiple `node:worker_threads`.\n\nvitest.config.js CLI\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'forks',\n  },\n})\n```\n\nbash\n\n``` javascript\nvitest --pool=forks\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/common-errors](https://vitest.dev/guide/common-errors)"
- name: Comparisons with Other Test Runners
  id: guide/comparisons
  summary: Jest took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (it and expect), and the full pack of testing features that most setups would require (snapshots, mocks, coverage)
  description: "# Comparisons with Other Test Runners\n\n## Jest\n\n[Jest](https://jestjs.io/) took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (`it` and `expect`), and the full pack of testing features that most setups would require (snapshots, mocks, coverage). We are thankful to the Jest team and community for creating a delightful testing API and pushing forward a lot of the testing patterns that are now a standard in the web ecosystem.\n\nIt is possible to use Jest in Vite setups. [@sodatea](https://twitter.com/haoqunjiang) built [vite-jest](https://github.com/sodatea/vite-jest#readme), which aims to provide first-class Vite integration for [Jest](https://jestjs.io/). The last [blockers in Jest](https://github.com/sodatea/vite-jest/blob/main/packages/vite-jest/README.md#vite-jest) have been solved, so this is a valid option for your unit tests.\n\nHowever, in a world where we have [Vite](https://vitejs.dev) providing support for the most common web tooling (TypeScript, JSX, most popular UI Frameworks), Jest represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same vite.config.js.\n\nEven if your library is not using Vite (for example, if it is built with esbuild or Rollup), Vitest is an interesting option as it gives you a faster run for your unit tests and a jump in DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR). Vitest offers compatibility with most of the Jest API and ecosystem libraries, so in most projects, it should be a drop-in replacement for Jest.\n\n## Cypress\n\n[Cypress](https://www.cypress.io/) is a browser-based test runner and a complementary tool to Vitest. If you'd like to use Cypress, we suggest using Vitest for all headless logic in your application and Cypress for all browser-based logic.\n\nCypress is known as an end-to-end testing tool, but their [new component test runner](https://on.cypress.io/component) has great support for testing Vite components and is an ideal choice to test anything that renders in a browser.\n\nBrowser-based runners, like Cypress, WebdriverIO and Web Test Runner, will catch issues that Vitest cannot because they use the real browser and real browser APIs.\n\nCypress's test driver is focused on determining if elements are visible, accessible, and interactive. Cypress is purpose-built for UI development and testing and its DX is centered around test driving your visual components. You see your component rendered alongside the test reporter. Once the test is complete, the component remains interactive and you can debug any failures that occur using your browser devtools.\n\nIn contrast, Vitest is focused on delivering the best DX possible for lightning fast, *headless* testing. Node-based runners like Vitest support various partially-implemented browser environments, like `jsdom`, which implement enough for you to quickly unit test any code that references browser APIs. The tradeoff is that these browser environments have limitations in what they can implement. For example, [jsdom is missing a number of features](https://github.com/jsdom/jsdom/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc) like `window.navigation` or a layout engine (`offsetTop`, etc).\n\nLastly, in contrast to the Web Test Runner, the Cypress test runner is more like an IDE than a test runner because you also see the real rendered component in the browser, along with its test results and logs.\n\nCypress has also been [integrating Vite in their products](https://www.youtube.com/watch?v=7S5cbY8iYLk): re-building their App's UI using [Vitesse](https://github.com/antfu/vitesse) and using Vite to test drive their project's development.\n\nWe believe that Cypress isn't a good option for unit testing headless code, but that using Cypress (for E2E and Component Testing) and Vitest (for unit tests) would cover your app's testing needs.\n\n## WebdriverIO\n\n[WebdriverIO](https://webdriver.io/) is, similar to Cypress, a browser-based alternative test runner and a complementary tool to Vitest. It can be used as an end-to-end testing tool as well as for testing [web components](https://webdriver.io/docs/component-testing). It even uses components of Vitest under the hood, e.g. for [mocking and stubbing](https://webdriver.io/docs/mocksandspies/) within component tests.\n\nWebdriverIO comes with the same advantages as Cypress allowing you to test your logic in real browser. However, it uses actual [web standards](https://w3c.github.io/webdriver/) for automation, which overcomes some of the tradeoffs and limitation when running tests in Cypress. Furthermore, it allows you to run tests on mobile as well, giving you access to test your application in even more environments.\n\n## Web Test Runner\n\n[@web/test-runner](https://modern-web.dev/docs/test-runner/overview/) runs tests inside a headless browser, providing the same execution environment as your web application without the need for mocking out browser APIs or the DOM. This also makes it possible to debug inside a real browser using the devtools, although there is no UI shown for stepping through the test, as there is in Cypress tests.\n\nTo use @web/test-runner with a Vite project, use [@remcovaes/web-test-runner-vite-plugin](https://github.com/remcovaes/web-test-runner-vite-plugin). @web/test-runner does not include assertion or mocking libraries, so it is up to you to add them.\n\n## uvu\n\n[uvu](https://github.com/lukeed/uvu) is a test runner for Node.js and the browser. It runs tests in a single thread, so tests are not isolated and can leak across files. Vitest, however, uses worker threads to isolate tests and run them in parallel.\n\nFor transforming your code, uvu relies on require and loader hooks. Vitest uses [Vite](https://vitejs.dev), so files are transformed with the full power of Vite's plugin system. In a world where we have Vite providing support for the most common web tooling (TypeScript, JSX, most popular UI Frameworks), uvu represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same configuration.\n\nuvu does not provide an intelligent watch mode to rerun the changed tests, while Vitest gives you amazing DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR).\n\nuvu is a fast option for running simple tests, but Vitest can be faster and more reliable for more complex tests and projects.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/comparisons](https://vitest.dev/guide/comparisons)"
- name: 'Comparisons with Other Test Runners: Cypress ​'
  id: guide/comparisons#cypress
  summary: Cypress is a browser-based test runner and a complementary tool to Vitest
  belongs_to: Comparisons with Other Test Runners
  description: |-
    ## Cypress

    [Cypress](https://www.cypress.io/) is a browser-based test runner and a complementary tool to Vitest. If you'd like to use Cypress, we suggest using Vitest for all headless logic in your application and Cypress for all browser-based logic.

    Cypress is known as an end-to-end testing tool, but their [new component test runner](https://on.cypress.io/component) has great support for testing Vite components and is an ideal choice to test anything that renders in a browser.

    Browser-based runners, like Cypress, WebdriverIO and Web Test Runner, will catch issues that Vitest cannot because they use the real browser and real browser APIs.

    Cypress's test driver is focused on determining if elements are visible, accessible, and interactive. Cypress is purpose-built for UI development and testing and its DX is centered around test driving your visual components. You see your component rendered alongside the test reporter. Once the test is complete, the component remains interactive and you can debug any failures that occur using your browser devtools.

    In contrast, Vitest is focused on delivering the best DX possible for lightning fast, *headless* testing. Node-based runners like Vitest support various partially-implemented browser environments, like `jsdom`, which implement enough for you to quickly unit test any code that references browser APIs. The tradeoff is that these browser environments have limitations in what they can implement. For example, [jsdom is missing a number of features](https://github.com/jsdom/jsdom/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc) like `window.navigation` or a layout engine (`offsetTop`, etc).

    Lastly, in contrast to the Web Test Runner, the Cypress test runner is more like an IDE than a test runner because you also see the real rendered component in the browser, along with its test results and logs.

    Cypress has also been [integrating Vite in their products](https://www.youtube.com/watch?v=7S5cbY8iYLk): re-building their App's UI using [Vitesse](https://github.com/antfu/vitesse) and using Vite to test drive their project's development.

    We believe that Cypress isn't a good option for unit testing headless code, but that using Cypress (for E2E and Component Testing) and Vitest (for unit tests) would cover your app's testing needs.
- name: 'Comparisons with Other Test Runners: Jest ​'
  id: guide/comparisons#jest
  summary: Jest took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (it and expect), and the full pack of testing features that most setups would require (snapshots, mocks, coverage)
  belongs_to: Comparisons with Other Test Runners
  description: |-
    ## Jest

    [Jest](https://jestjs.io/) took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (`it` and `expect`), and the full pack of testing features that most setups would require (snapshots, mocks, coverage). We are thankful to the Jest team and community for creating a delightful testing API and pushing forward a lot of the testing patterns that are now a standard in the web ecosystem.

    It is possible to use Jest in Vite setups. [@sodatea](https://twitter.com/haoqunjiang) built [vite-jest](https://github.com/sodatea/vite-jest#readme), which aims to provide first-class Vite integration for [Jest](https://jestjs.io/). The last [blockers in Jest](https://github.com/sodatea/vite-jest/blob/main/packages/vite-jest/README.md#vite-jest) have been solved, so this is a valid option for your unit tests.

    However, in a world where we have [Vite](https://vitejs.dev) providing support for the most common web tooling (TypeScript, JSX, most popular UI Frameworks), Jest represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same vite.config.js.

    Even if your library is not using Vite (for example, if it is built with esbuild or Rollup), Vitest is an interesting option as it gives you a faster run for your unit tests and a jump in DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR). Vitest offers compatibility with most of the Jest API and ecosystem libraries, so in most projects, it should be a drop-in replacement for Jest.
- name: 'Comparisons with Other Test Runners: uvu ​'
  id: guide/comparisons#uvu
  summary: uvu is a test runner for Node.js and the browser
  belongs_to: Comparisons with Other Test Runners
  description: "## uvu\n\n[uvu](https://github.com/lukeed/uvu) is a test runner for Node.js and the browser. It runs tests in a single thread, so tests are not isolated and can leak across files. Vitest, however, uses worker threads to isolate tests and run them in parallel.\n\nFor transforming your code, uvu relies on require and loader hooks. Vitest uses [Vite](https://vitejs.dev), so files are transformed with the full power of Vite's plugin system. In a world where we have Vite providing support for the most common web tooling (TypeScript, JSX, most popular UI Frameworks), uvu represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same configuration.\n\nuvu does not provide an intelligent watch mode to rerun the changed tests, while Vitest gives you amazing DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR).\n\nuvu is a fast option for running simple tests, but Vitest can be faster and more reliable for more complex tests and projects.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/comparisons](https://vitest.dev/guide/comparisons)"
- name: 'Comparisons with Other Test Runners: Web Test Runner ​'
  id: guide/comparisons#web-test-runner
  summary: '@web/test-runner runs tests inside a headless browser, providing the same execution environment as your web application without the need for mocking out browser APIs or the DOM'
  belongs_to: Comparisons with Other Test Runners
  description: |-
    ## Web Test Runner

    [@web/test-runner](https://modern-web.dev/docs/test-runner/overview/) runs tests inside a headless browser, providing the same execution environment as your web application without the need for mocking out browser APIs or the DOM. This also makes it possible to debug inside a real browser using the devtools, although there is no UI shown for stepping through the test, as there is in Cypress tests.

    To use @web/test-runner with a Vite project, use [@remcovaes/web-test-runner-vite-plugin](https://github.com/remcovaes/web-test-runner-vite-plugin). @web/test-runner does not include assertion or mocking libraries, so it is up to you to add them.
- name: 'Comparisons with Other Test Runners: WebdriverIO ​'
  id: guide/comparisons#webdriverio
  summary: WebdriverIO is, similar to Cypress, a browser-based alternative test runner and a complementary tool to Vitest
  belongs_to: Comparisons with Other Test Runners
  description: |-
    ## WebdriverIO

    [WebdriverIO](https://webdriver.io/) is, similar to Cypress, a browser-based alternative test runner and a complementary tool to Vitest. It can be used as an end-to-end testing tool as well as for testing [web components](https://webdriver.io/docs/component-testing). It even uses components of Vitest under the hood, e.g. for [mocking and stubbing](https://webdriver.io/docs/mocksandspies/) within component tests.

    WebdriverIO comes with the same advantages as Cypress allowing you to test your logic in real browser. However, it uses actual [web standards](https://w3c.github.io/webdriver/) for automation, which overcomes some of the tradeoffs and limitation when running tests in Cypress. Furthermore, it allows you to run tests on mobile as well, giving you access to test your application in even more environments.
- name: Configuring Vitest
  id: config/index
  summary: To create a Vitest configuration file, follow the guide
  description: "# Configuring Vitest\n\nTo create a Vitest configuration file, follow [the guide](file). Make sure you understand how Vitest config resolution works before proceeding.\n\n**WARNING**\n\n*All* listed options here are located on a `test` property inside the config:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    exclude: [],\n  },\n})\n```\n\n**TIP**\n\nIn addition to the following options, you can also use any configuration option from [Vite](https://vitejs.dev/config/). For example, `define` to define global variables, or `resolve.alias` to define aliases.\n\nAll configuration options that are not supported inside a [workspace](../guide/workspace) project config have \\* sign next to them.\n\n### include\n\n- **Type:** `string[]`\n- **Default:** `['**/*.{test,spec}.?(c|m)[jt]s?(x)']`\n- **CLI:** `vitest [...include]`, `vitest **/*.test.js`\n\nA list of glob patterns that match your test files.\n\n**NOTE**\n\nWhen using coverage, Vitest automatically adds test files `include` patterns to coverage's default `exclude` patterns. See [`coverage.exclude`](#coverage-exclude).\n\n### exclude\n\n- **Type:** `string[]`\n- **Default:** `['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**', '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*']`\n- **CLI:** `vitest --exclude \"**/excluded-file\"`\n\nA list of glob patterns that should be excluded from your test files.\n\n**WARNING**\n\nThis option does not affect coverage. If you need to remove certain files from the coverage report, use [`coverage.exclude`](#coverage-exclude).\n\nThis is the only option that doesn't override your configuration if you provide it with a CLI flag. All glob patterns added via `--exclude` flag will be added to the config's `exclude`.\n\n### includeSource\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nInclude globs for in-source test files.\n\nWhen defined, Vitest will run all matched files with `import.meta.vitest` inside.\n\n### server\n\n- **Type:** `{ sourcemap?, deps?, ... }`\n\nVite-Node server options.\n\n#### server.sourcemap\n\n- **Type:** `'inline' | boolean`\n- **Default:** `'inline'`\n\nInject inline source map to modules.\n\n#### server.debug\n\n- **Type:** `{ dumpModules?, loadDumppedModules? }`\n\nVite-Node debugger options.\n\n#### server.debug.dumpModules\n\n- **Type:** `boolean | string`\n\nDump the transformed module to filesystem. Passing a string will dump to the specified path.\n\n#### server.debug.loadDumppedModules\n\n- **Type:** `boolean`\n\nRead dumped module from filesystem whenever exists. Useful for debugging by modifying the dump result from the filesystem.\n\n#### server.deps\n\n- **Type:** `{ external?, inline?, ... }`\n\nHandling for dependencies resolution.\n\n#### server.deps.external\n\n- **Type:** `(string | RegExp)[]`\n- **Default:** `[/\\/node_modules\\//]`\n\nExternalize means that Vite will bypass the package to the native Node. Externalized dependencies will not be applied to Vite's transformers and resolvers, so they do not support HMR on reload. By default, all packages inside `node_modules` are externalized.\n\nThese options support package names as they are written in `node_modules` or specified inside [`deps.moduleDirectories`](#deps-moduledirectories). For example, package `@company/some-name` located inside `packages/some-name` should be specified as `some-name`, and `packages` should be included in `deps.moduleDirectories`. Basically, Vitest always checks the file path, not the actual package name.\n\nIf regexp is used, Vitest calls it on the *file path*, not the package name.\n\n#### server.deps.inline\n\n- **Type:** `(string | RegExp)[] | true`\n- **Default:** `[]`\n\nVite will process inlined modules. This could be helpful to handle packages that ship `.js` in ESM format (that Node can't handle).\n\nIf `true`, every dependency will be inlined. All dependencies, specified in [`ssr.noExternal`](https://vitejs.dev/guide/ssr.html#ssr-externals) will be inlined by default.\n\n#### server.deps.fallbackCJS\n\n- **Type** `boolean`\n- **Default:** `false`\n\nWhen a dependency is a valid ESM package, try to guess the cjs version based on the path. This might be helpful, if a dependency has the wrong ESM file.\n\nThis might potentially cause some misalignment if a package has different logic in ESM and CJS mode.\n\n#### server.deps.cacheDir\n\n- **Type** `string`\n- **Default**: `'node_modules/.vite'`\n\nDirectory to save cache files.\n\n### deps\n\n- **Type:** `{ optimizer?, ... }`\n\nHandling for dependencies resolution.\n\n#### deps.optimizer\n\n- **Type:** `{ ssr?, web? }`\n- **See also:** [Dep Optimization Options](https://vitejs.dev/config/dep-optimization-options.html)\n\nEnable dependency optimization. If you have a lot of tests, this might improve their performance.\n\nWhen Vitest encounters the external library listed in `include`, it will be bundled into a single file using esbuild and imported as a whole module. This is good for several reasons:\n\n- Importing packages with a lot of imports is expensive. By bundling them into one file we can save a lot of time\n- Importing UI libraries is expensive because they are not meant to run inside Node.js\n- Your `alias` configuration is now respected inside bundled packages\n- Code in your tests is running closer to how it's running in the browser\n\nBe aware that only packages in `deps.optimizer?.[mode].include` option are bundled (some plugins populate this automatically, like Svelte). You can read more about available options in [Vite](https://vitejs.dev/config/dep-optimization-options.html) docs (Vitest doesn't support `disable` and `noDiscovery` options). By default, Vitest uses `optimizer.web` for `jsdom` and `happy-dom` environments, and `optimizer.ssr` for `node` and `edge` environments, but it is configurable by [`transformMode`](#testtransformmode).\n\nThis options also inherits your `optimizeDeps` configuration (for web Vitest will extend `optimizeDeps`, for ssr - `ssr.optimizeDeps`). If you redefine `include`/`exclude` option in `deps.optimizer` it will extend your `optimizeDeps` when running tests. Vitest automatically removes the same options from `include`, if they are listed in `exclude`.\n\n**TIP**\n\nYou will not be able to edit your `node_modules` code for debugging, since the code is actually located in your `cacheDir` or `test.cache.dir` directory. If you want to debug with `console.log` statements, edit it directly or force rebundling with `deps.optimizer?.[mode].force` option.\n\n#### deps.optimizer.{mode}.enabled\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nEnable dependency optimization.\n\n#### deps.web\n\n- **Type:** `{ transformAssets?, ... }`\n\nOptions that are applied to external files when transform mode is set to `web`. By default, `jsdom` and `happy-dom` use `web` mode, while `node` and `edge` environments use `ssr` transform mode, so these options will have no affect on files inside those environments.\n\nUsually, files inside `node_modules` are externalized, but these options also affect files in [`server.deps.external`](#server-deps-external).\n\n#### deps.web.transformAssets\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nShould Vitest process assets (.png, .svg, .jpg, etc) files and resolve them like Vite does in the browser.\n\nThis module will have a default export equal to the path to the asset, if no query is specified.\n\n**WARNING**\n\nAt the moment, this option only works with [`vmThreads`](#vmthreads) and [`vmForks`](#vmforks) pools.\n\n#### deps.web.transformCss\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nShould Vitest process CSS (.css, .scss, .sass, etc) files and resolve them like Vite does in the browser.\n\nIf CSS files are disabled with [`css`](#css) options, this option will just silence `ERR_UNKNOWN_FILE_EXTENSION` errors.\n\n**WARNING**\n\nAt the moment, this option only works with [`vmThreads`](#vmthreads) and [`vmForks`](#vmforks) pools.\n\n#### deps.web.transformGlobPattern\n\n- **Type:** `RegExp | RegExp[]`\n- **Default:** `[]`\n\nRegexp pattern to match external files that should be transformed.\n\nBy default, files inside `node_modules` are externalized and not transformed, unless it's CSS or an asset, and corresponding option is not disabled.\n\n**WARNING**\n\nAt the moment, this option only works with [`vmThreads`](#vmthreads) and [`vmForks`](#vmforks) pools.\n\n#### deps.interopDefault\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nInterpret CJS module's default as named exports. Some dependencies only bundle CJS modules and don't use named exports that Node.js can statically analyze when a package is imported using `import` syntax instead of `require`. When importing such dependencies in Node environment using named exports, you will see this error:\n\n``` javascript\nimport { read } from 'fs-jetpack';\n         ^^^^\nSyntaxError: Named export 'read' not found. The requested module 'fs-jetpack' is a CommonJS module, which may not support all module.exports as named exports.\nCommonJS modules can always be imported via the default export.\n```\n\nVitest doesn't do static analysis, and cannot fail before your running code, so you will most likely see this error when running tests, if this feature is disabled:\n\n``` javascript\nTypeError: createAsyncThunk is not a function\nTypeError: default is not a function\n```\n\nBy default, Vitest assumes you are using a bundler to bypass this and will not fail, but you can disable this behaviour manually, if you code is not processed.\n\n#### deps.moduleDirectories\n\n- **Type:** `string[]`\n- **Default**: `['node_modules']`\n\nA list of directories that should be treated as module directories. This config option affects the behavior of [`vi.mock`](../api/vi#vi-mock): when no factory is provided and the path of what you are mocking matches one of the `moduleDirectories` values, Vitest will try to resolve the mock by looking for a `__mocks__` folder in the [root](#root) of the project.\n\nThis option will also affect if a file should be treated as a module when externalizing dependencies. By default, Vitest imports external modules with native Node.js bypassing Vite transformation step.\n\nSetting this option will *override* the default, if you wish to still search `node_modules` for packages include it along with any other options:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    deps: {\n      moduleDirectories: ['node_modules', path.resolve('../../packages')],\n    }\n  },\n})\n```\n\n### runner\n\n- **Type**: `VitestRunnerConstructor`\n- **Default**: `node`, when running tests, or `benchmark`, when running benchmarks\n\nPath to a custom test runner. This is an advanced feature and should be used with custom library runners. You can read more about it in [the documentation](../advanced/runner).\n\n### benchmark\n\n- **Type:** `{ include?, exclude?, ... }`\n\nOptions used when running `vitest bench`.\n\n#### benchmark.include\n\n- **Type:** `string[]`\n- **Default:** `['**/*.{bench,benchmark}.?(c|m)[jt]s?(x)']`\n\nInclude globs for benchmark test files\n\n#### benchmark.exclude\n\n- **Type:** `string[]`\n- **Default:** `['node_modules', 'dist', '.idea', '.git', '.cache']`\n\nExclude globs for benchmark test files\n\n#### benchmark.includeSource\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nInclude globs for in-source benchmark test files. This option is similar to [`includeSource`](#includesource).\n\nWhen defined, Vitest will run all matched files with `import.meta.vitest` inside.\n\n#### benchmark.reporters\n\n- **Type:** `Arrayable<BenchmarkBuiltinReporters | Reporter>`\n- **Default:** `'default'`\n\nCustom reporter for output. Can contain one or more built-in report names, reporter instances, and/or paths to custom reporters.\n\n#### benchmark.outputFile\n\n- **Type:** `string | Record<string, string>`\n\nWrite benchmark results to a file when the `--reporter=json` option is also specified. By providing an object instead of a string you can define individual outputs when using multiple reporters.\n\nTo provide object via CLI command, use the following syntax: `--outputFile.json=./path --outputFile.junit=./other-path`.\n\n#### benchmark.outputJson\n\n- **Type:** `string | undefined`\n- **Default:** `undefined`\n\nA file path to store the benchmark result, which can be used for `--compare` option later.\n\nFor example:\n\nsh\n\n``` javascript\n# save main branch's result\ngit checkout main\nvitest bench --outputJson main.json\n\n# change a branch and compare against main\ngit checkout feature\nvitest bench --compare main.json\n```\n\n#### benchmark.compare\n\n- **Type:** `string | undefined`\n- **Default:** `undefined`\n\nA file path to a previous benchmark result to compare against current runs.\n\n### alias\n\n- **Type:** `Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>`\n\nDefine custom aliases when running inside tests. They will be merged with aliases from `resolve.alias`.\n\n**WARNING**\n\nVitest uses Vite SSR primitives to run tests which has [certain pitfalls](https://vitejs.dev/guide/ssr.html#ssr-externals).\n\n1.  Aliases affect only modules imported directly with an `import` keyword by an [inlined](#server-deps-inline) module (all source code is inlined by default).\n2.  Vitest does not support aliasing `require` calls.\n3.  If you are aliasing an external dependency (e.g., `react` -\\> `preact`), you may want to alias the actual `node_modules` packages instead to make it work for externalized dependencies. Both [Yarn](https://classic.yarnpkg.com/en/docs/cli/add/#toc-yarn-add-alias) and [pnpm](https://pnpm.io/aliases/) support aliasing via the `npm:` prefix.\n\n### globals\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **CLI:** `--globals`, `--globals=false`\n\nBy default, `vitest` does not provide global APIs for explicitness. If you prefer to use the APIs globally like Jest, you can pass the `--globals` option to CLI or add `globals: true` in the config.\n\nts\n\n``` javascript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n  },\n})\n```\n\nTo get TypeScript working with the global APIs, add `vitest/globals` to the `types` field in your `tsconfig.json`\n\njson\n\n``` javascript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\"]\n  }\n}\n```\n\nIf you are already using [`unplugin-auto-import`](https://github.com/antfu/unplugin-auto-import) in your project, you can also use it directly for auto importing those APIs.\n\nts\n\n``` javascript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\nimport AutoImport from 'unplugin-auto-import/vite'\n\nexport default defineConfig({\n  plugins: [\n    AutoImport({\n      imports: ['vitest'],\n      dts: true, // generate TypeScript declaration\n    }),\n  ],\n})\n```\n\n### environment\n\n- **Type:** `'node' | 'jsdom' | 'happy-dom' | 'edge-runtime' | string`\n- **Default:** `'node'`\n- **CLI:** `--environment=<env>`\n\nThe environment that will be used for testing. The default environment in Vitest is a Node.js environment. If you are building a web application, you can use browser-like environment through either [`jsdom`](https://github.com/jsdom/jsdom) or [`happy-dom`](https://github.com/capricorn86/happy-dom) instead. If you are building edge functions, you can use [`edge-runtime`](https://edge-runtime.vercel.app/packages/vm) environment\n\n**TIP**\n\nYou can also use [Browser Mode](../guide/browser/index) to run integration or unit tests in the browser without mocking the environment.\n\nBy adding a `@vitest-environment` docblock or comment at the top of the file, you can specify another environment to be used for all tests in that file:\n\nDocblock style:\n\njs\n\n``` javascript\n/**\n * @vitest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n```\n\nComment style:\n\njs\n\n``` javascript\n// @vitest-environment happy-dom\n\ntest('use happy-dom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n```\n\nFor compatibility with Jest, there is also a `@jest-environment`:\n\njs\n\n``` javascript\n/**\n * @jest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n```\n\nIf you are running Vitest with [`--isolate=false`](#isolate) flag, your tests will be run in this order: `node`, `jsdom`, `happy-dom`, `edge-runtime`, `custom environments`. Meaning, that every test with the same environment is grouped, but is still running sequentially.\n\nStarting from 0.23.0, you can also define custom environment. When non-builtin environment is used, Vitest will try to load package `vitest-environment-${name}`. That package should export an object with the shape of `Environment`:\n\nts\n\n``` javascript\nimport type { Environment } from 'vitest'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n```\n\nVitest also exposes `builtinEnvironments` through `vitest/environments` entry, in case you just want to extend it. You can read more about extending environments in [our guide](../guide/environment).\n\n**TIP**\n\njsdom environment exposes `jsdom` global variable equal to the current [JSDOM](https://github.com/jsdom/jsdom) instance. If you want TypeScript to recognize it, you can add `vitest/jsdom` to your `tsconfig.json` when you use this environment:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/jsdom\"]\n  }\n}\n```\n\n### environmentOptions\n\n- **Type:** `Record<'jsdom' | string, unknown>`\n- **Default:** `{}`\n\nThese options are passed down to `setup` method of current [`environment`](#environment). By default, you can configure only JSDOM options, if you are using it as your test environment.\n\n### environmentMatchGlobs\n\n- **Type:** `[string, EnvironmentName][]`\n- **Default:** `[]`\n\nAutomatically assign environment based on globs. The first match will be used.\n\nFor example:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    environmentMatchGlobs: [\n      // all tests in tests/dom will run in jsdom\n      ['tests/dom/**', 'jsdom'],\n      // all tests in tests/ with .edge.test.ts will run in edge-runtime\n      ['**\\/*.edge.test.ts', 'edge-runtime'],\n      // ...\n    ]\n  }\n})\n```\n\n### poolMatchGlobs\n\n- **Type:** `[string, 'threads' | 'forks' | 'vmThreads' | 'vmForks' | 'typescript'][]`\n- **Default:** `[]`\n\nAutomatically assign pool in which tests will run based on globs. The first match will be used.\n\nFor example:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolMatchGlobs: [\n      // all tests in \"worker-specific\" directory will run inside a worker as if you enabled `--pool=threads` for them,\n      ['**/tests/worker-specific/**', 'threads'],\n      // run all tests in \"browser\" directory in an actual browser\n      ['**/tests/browser/**', 'browser'],\n      // all other tests will run based on \"browser.enabled\" and \"threads\" options, if you didn't specify other globs\n      // ...\n    ]\n  }\n})\n```\n\n### update \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n- **CLI:** `-u`, `--update`, `--update=false`\n\nUpdate snapshot files. This will update all changed snapshots and delete obsolete ones.\n\n### watch \\* \n\n- **Type:** `boolean`\n- **Default:** `!process.env.CI`\n- **CLI:** `-w`, `--watch`, `--watch=false`\n\nEnable watch mode\n\n### root\n\n- **Type:** `string`\n- **CLI:** `-r <path>`, `--root=<path>`\n\nProject root\n\n### reporters \\* \n\n- **Type:** `Reporter | Reporter[]`\n- **Default:** `'default'`\n- **CLI:** `--reporter=<name>`, `--reporter=<name1> --reporter=<name2>`\n\nCustom [reporters](../guide/reporters) for output. Reporters can be [a Reporter instance](https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/types/reporter.ts), a string to select built-in reporters, or a path to a custom implementation (e.g. `'./path/to/reporter.ts'`, `'@scope/reporter'`).\n\n### outputFile \\* \n\n- **Type:** `string | Record<string, string>`\n- **CLI:** `--outputFile=<path>`, `--outputFile.json=./path`\n\nWrite test results to a file when the `--reporter=json`, `--reporter=html` or `--reporter=junit` option is also specified. By providing an object instead of a string you can define individual outputs when using multiple reporters.\n\n### pool \\* \n\n- **Type:** `'threads' | 'forks' | 'vmThreads' | 'vmForks'`\n- **Default:** `'forks'`\n- **CLI:** `--pool=threads`\n\nPool used to run tests in.\n\n#### threads \\* \n\nEnable multi-threading using [tinypool](https://github.com/tinylibs/tinypool) (a lightweight fork of [Piscina](https://github.com/piscinajs/piscina)). When using threads you are unable to use process related APIs such as `process.chdir()`. Some libraries written in native languages, such as Prisma, `bcrypt` and `canvas`, have problems when running in multiple threads and run into segfaults. In these cases it is advised to use `forks` pool instead.\n\n#### forks \\* \n\nSimilar as `threads` pool but uses `child_process` instead of `worker_threads` via [tinypool](https://github.com/tinylibs/tinypool). Communication between tests and main process is not as fast as with `threads` pool. Process related APIs such as `process.chdir()` are available in `forks` pool.\n\n#### vmThreads \\* \n\nRun tests using [VM context](https://nodejs.org/api/vm.html) (inside a sandboxed environment) in a `threads` pool.\n\nThis makes tests run faster, but the VM module is unstable when running [ESM code](https://github.com/nodejs/node/issues/37648). Your tests will [leak memory](https://github.com/nodejs/node/issues/33439) - to battle that, consider manually editing [`poolOptions.vmThreads.memoryLimit`](#pooloptions-vmthreads-memorylimit) value.\n\n**WARNING**\n\nRunning code in a sandbox has some advantages (faster tests), but also comes with a number of disadvantages.\n\n- The globals within native modules, such as (`fs`, `path`, etc), differ from the globals present in your test environment. As a result, any error thrown by these native modules will reference a different Error constructor compared to the one used in your code:\n\nts\n\n``` javascript\ntry {\n  fs.writeFileSync('/doesnt exist')\n}\ncatch (err) {\n  console.log(err instanceof Error) // false\n}\n```\n\n- Importing ES modules caches them indefinitely which introduces memory leaks if you have a lot of contexts (test files). There is no API in Node.js that clears that cache.\n- Accessing globals [takes longer](https://github.com/nodejs/node/issues/31658) in a sandbox environment.\n\nPlease, be aware of these issues when using this option. Vitest team cannot fix any of the issues on our side.\n\n#### vmForks \\* \n\nSimilar as `vmThreads` pool but uses `child_process` instead of `worker_threads` via [tinypool](https://github.com/tinylibs/tinypool). Communication between tests and the main process is not as fast as with `vmThreads` pool. Process related APIs such as `process.chdir()` are available in `vmForks` pool. Please be aware that this pool has the same pitfalls listed in `vmThreads`.\n\n### poolOptions \\* \n\n- **Type:** `Record<'threads' | 'forks' | 'vmThreads' | 'vmForks', {}>`\n- **Default:** `{}`\n\n#### poolOptions.threads\n\nOptions for `threads` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: {\n        // Threads related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.threads.maxThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of threads. You can also use `VITEST_MAX_THREADS` environment variable.\n\n##### poolOptions.threads.minThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of threads. You can also use `VITEST_MIN_THREADS` environment variable.\n\n##### poolOptions.threads.singleThread\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nRun all tests with the same environment inside a single worker thread. This will disable built-in module isolation (your source code or [inlined](#server-deps-inline) code will still be reevaluated for each test), but can improve test performance.\n\n**WARNING**\n\nEven though this option will force tests to run one after another, this option is different from Jest's `--runInBand`. Vitest uses workers not only for running tests in parallel, but also to provide isolation. By disabling this option, your tests will run sequentially, but in the same global context, so you must provide isolation yourself.\n\nThis might cause all sorts of issues, if you are relying on global state (frontend frameworks usually do) or your code relies on environment to be defined separately for each test. But can be a speed boost for your tests (up to 3 times faster), that don't necessarily rely on global state or can easily bypass that.\n\n##### poolOptions.threads.useAtomics \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n\nUse Atomics to synchronize threads.\n\nThis can improve performance in some cases, but might cause segfault in older Node versions.\n\n##### poolOptions.threads.isolate\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nIsolate environment for each test file.\n\n##### poolOptions.threads.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` in the threads. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n#### poolOptions.forks\n\nOptions for `forks` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      forks: {\n        // Forks related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.forks.maxForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of forks.\n\n##### poolOptions.forks.minForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of forks.\n\n##### poolOptions.forks.isolate\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nIsolate environment for each test file.\n\n##### poolOptions.forks.singleFork\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nRun all tests with the same environment inside a single child process. This will disable built-in module isolation (your source code or [inlined](#server-deps-inline) code will still be reevaluated for each test), but can improve test performance.\n\n**WARNING**\n\nEven though this option will force tests to run one after another, this option is different from Jest's `--runInBand`. Vitest uses child processes not only for running tests in parallel, but also to provide isolation. By disabling this option, your tests will run sequentially, but in the same global context, so you must provide isolation yourself.\n\nThis might cause all sorts of issues, if you are relying on global state (frontend frameworks usually do) or your code relies on environment to be defined separately for each test. But can be a speed boost for your tests (up to 3 times faster), that don't necessarily rely on global state or can easily bypass that.\n\n##### poolOptions.forks.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` process in the child processes. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n#### poolOptions.vmThreads\n\nOptions for `vmThreads` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmThreads: {\n        // VM threads related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.vmThreads.maxThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of threads. You can also use `VITEST_MAX_THREADS` environment variable.\n\n##### poolOptions.vmThreads.minThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of threads. You can also use `VITEST_MIN_THREADS` environment variable.\n\n##### poolOptions.vmThreads.memoryLimit \\* \n\n- **Type:** `string | number`\n- **Default:** `1 / CPU Cores`\n\nSpecifies the memory limit for workers before they are recycled. This value heavily depends on your environment, so it's better to specify it manually instead of relying on the default.\n\n**TIP**\n\nThe implementation is based on Jest's [`workerIdleMemoryLimit`](https://jestjs.io/docs/configuration#workeridlememorylimit-numberstring).\n\nThe limit can be specified in a number of different ways and whatever the result is `Math.floor` is used to turn it into an integer value:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use 1.1.\n- With units\n  - `50%` - As above, a percentage of total system memory\n  - `100KB`, `65MB`, etc - With units to denote a fixed memory limit.\n    - `K` / `KB` - Kilobytes (x1000)\n    - `KiB` - Kibibytes (x1024)\n    - `M` / `MB` - Megabytes\n    - `MiB` - Mebibytes\n    - `G` / `GB` - Gigabytes\n    - `GiB` - Gibibytes\n\n**WARNING**\n\nPercentage based memory limit [does not work on Linux CircleCI](https://github.com/jestjs/jest/issues/11956#issuecomment-1212925677) workers due to incorrect system memory being reported.\n\n##### poolOptions.vmThreads.useAtomics \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n\nUse Atomics to synchronize threads.\n\nThis can improve performance in some cases, but might cause segfault in older Node versions.\n\n##### poolOptions.vmThreads.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` process in the VM context. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n#### poolOptions.vmForks \\* \n\nOptions for `vmForks` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmForks: {\n        // VM forks related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.vmForks.maxForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of threads. You can also use `VITEST_MAX_FORKS` environment variable.\n\n##### poolOptions.vmForks.minForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of threads. You can also use `VITEST_MIN_FORKS` environment variable.\n\n##### poolOptions.vmForks.memoryLimit \\* \n\n- **Type:** `string | number`\n- **Default:** `1 / CPU Cores`\n\nSpecifies the memory limit for workers before they are recycled. This value heavily depends on your environment, so it's better to specify it manually instead of relying on the default. How the value is calculated is described in [`poolOptions.vmThreads.memoryLimit`](#pooloptions-vmthreads-memorylimit)\n\n##### poolOptions.vmForks.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` process in the VM context. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n### fileParallelism \\* \n\n- **Type:** `boolean`\n- **Default:** `true`\n- **CLI:** `--no-file-parallelism`, `--fileParallelism=false`\n\nShould all test files run in parallel. Setting this to `false` will override `maxWorkers` and `minWorkers` options to `1`.\n\n**TIP**\n\nThis option doesn't affect tests running in the same file. If you want to run those in parallel, use `concurrent` option on [describe](../api/index#describe-concurrent) or via [a config](#sequence-concurrent).\n\n### maxWorkers \\* \n\n- **Type:** `number | string`\n\nMaximum number or percentage of workers to run tests in. `poolOptions.{threads,vmThreads}.maxThreads`/`poolOptions.forks.maxForks` has higher priority.\n\n### minWorkers \\* \n\n- **Type:** `number | string`\n\nMinimum number or percentage of workers to run tests in. `poolOptions.{threads,vmThreads}.minThreads`/`poolOptions.forks.minForks` has higher priority.\n\n### testTimeout\n\n- **Type:** `number`\n- **Default:** `5_000` in Node.js, `15_000` if `browser.enabled` is `true`\n- **CLI:** `--test-timeout=5000`, `--testTimeout=5000`\n\nDefault timeout of a test in milliseconds\n\n### hookTimeout\n\n- **Type:** `number`\n- **Default:** `10_000` in Node.js, `30_000` if `browser.enabled` is `true`\n- **CLI:** `--hook-timeout=10000`, `--hookTimeout=10000`\n\nDefault timeout of a hook in milliseconds\n\n### teardownTimeout \\* \n\n- **Type:** `number`\n- **Default:** `10000`\n- **CLI:** `--teardown-timeout=5000`, `--teardownTimeout=5000`\n\nDefault timeout to wait for close when Vitest shuts down, in milliseconds\n\n### silent \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n- **CLI:** `--silent`, `--silent=false`\n\nSilent console output from tests\n\n### setupFiles\n\n- **Type:** `string | string[]`\n\nPath to setup files. They will be run before each test file.\n\n**INFO**\n\nChanging setup files will trigger rerun of all tests.\n\nYou can use `process.env.VITEST_POOL_ID` (integer-like string) inside to distinguish between threads.\n\n**TIP**\n\nNote, that if you are running [`--isolate=false`](#isolate), this setup file will be run in the same global scope multiple times. Meaning, that you are accessing the same global object before each test, so make sure you are not doing the same thing more than you need.\n\nFor example, you may rely on a global variable:\n\nts\n\n``` javascript\nimport { config } from '@some-testing-lib'\n\nif (!globalThis.defined) {\n  config.plugins = [myCoolPlugin]\n  computeHeavyThing()\n  globalThis.defined = true\n}\n\n// hooks are reset before each suite\nafterEach(() => {\n  cleanup()\n})\n\nglobalThis.resetBeforeEachTest = true\n```\n\n### globalSetup\n\n- **Type:** `string | string[]`\n\nPath to global setup files, relative to project root.\n\nA global setup file can either export named functions `setup` and `teardown` or a `default` function that returns a teardown function ([example](https://github.com/vitest-dev/vitest/blob/main/test/global-setup/vitest.config.ts)).\n\n**INFO**\n\nMultiple globalSetup files are possible. setup and teardown are executed sequentially with teardown in reverse order.\n\n**WARNING**\n\nGlobal setup runs only if there is at least one running test. This means that global setup might start running during watch mode after test file is changed (the test file will wait for global setup to finish before running).\n\nBeware that the global setup is running in a different global scope, so your tests don't have access to variables defined here. However, you can pass down serializable data to tests via `provide` method:\n\nglobalSetup.jsglobalSetup.tsexample.test.js\n\njs\n\n``` javascript\nexport default function setup({ provide }) {\n  provide('wsPort', 3000)\n}\n```\n\nts\n\n``` javascript\nimport type { GlobalSetupContext } from 'vitest/node'\n\nexport default function setup({ provide }: GlobalSetupContext) {\n  provide('wsPort', 3000)\n}\n\n// You can also extend `ProvidedContext` type\n// to have type safe access to `provide/inject` methods:\ndeclare module 'vitest' {\n  export interface ProvidedContext {\n    wsPort: number\n  }\n}\n```\n\nts\n\n``` javascript\nimport { inject } from 'vitest'\n\ninject('wsPort') === 3000\n```\n\n### forceRerunTriggers \\* \n\n- **Type**: `string[]`\n- **Default:** `['**/package.json/**', '**/vitest.config.*/**', '**/vite.config.*/**']`\n\nGlob pattern of file paths that will trigger the whole suite rerun. When paired with the `--changed` argument will run the whole test suite if the trigger is found in the git diff.\n\nUseful if you are testing calling CLI commands, because Vite cannot construct a module graph:\n\nts\n\n``` javascript\ntest('execute a script', async () => {\n  // Vitest cannot rerun this test, if content of `dist/index.js` changes\n  await execa('node', ['dist/index.js'])\n})\n```\n\n**TIP**\n\nMake sure that your files are not excluded by [`server.watch.ignored`](https://vitejs.dev/config/server-options.html#server-watch).\n\n### coverage \\* \n\nYou can use [`v8`](https://v8.dev/blog/javascript-code-coverage), [`istanbul`](https://istanbul.js.org/) or [a custom coverage solution](../guide/coverage#custom-coverage-provider) for coverage collection.\n\nYou can provide coverage options to CLI with dot notation:\n\nsh\n\n``` javascript\nnpx vitest --coverage.enabled --coverage.provider=istanbul --coverage.all\n```\n\n**WARNING**\n\nIf you are using coverage options with dot notation, don't forget to specify `--coverage.enabled`. Do not provide a single `--coverage` option in that case.\n\n#### coverage.provider\n\n- **Type:** `'v8' | 'istanbul' | 'custom'`\n- **Default:** `'v8'`\n- **CLI:** `--coverage.provider=<provider>`\n\nUse `provider` to select the tool for coverage collection.\n\n#### coverage.enabled\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.enabled`, `--coverage.enabled=false`\n\nEnables coverage collection. Can be overridden using `--coverage` CLI option.\n\n#### coverage.include\n\n- **Type:** `string[]`\n- **Default:** `['**']`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.include=<path>`, `--coverage.include=<path1> --coverage.include=<path2>`\n\nList of files included in coverage as glob patterns\n\n#### coverage.extension\n\n- **Type:** `string | string[]`\n- **Default:** `['.js', '.cjs', '.mjs', '.ts', '.mts', '.cts', '.tsx', '.jsx', '.vue', '.svelte', '.marko']`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.extension=<extension>`, `--coverage.extension=<extension1> --coverage.extension=<extension2>`\n\n#### coverage.exclude\n\n- **Type:** `string[]`\n- **Default:**\n\njs\n\n``` javascript\n[\n  'coverage/**',\n  'dist/**',\n  '**/node_modules/**',\n  '**/[.]**',\n  'packages/*/test?(s)/**',\n  '**/*.d.ts',\n  '**/virtual:*',\n  '**/__x00__*',\n  '**/\\x00*',\n  'cypress/**',\n  'test?(s)/**',\n  'test?(-*).?(c|m)[jt]s?(x)',\n  '**/*{.,-}{test,spec,bench,benchmark}?(-d).?(c|m)[jt]s?(x)',\n  '**/__tests__/**',\n  '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build,eslint,prettier}.config.*',\n  '**/vitest.{workspace,projects}.[jt]s?(on)',\n  '**/.{eslint,mocha,prettier}rc.{?(c|m)js,yml}',\n]\n```\n\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.exclude=<path>`, `--coverage.exclude=<path1> --coverage.exclude=<path2>`\n\nList of files excluded from coverage as glob patterns.\n\nThis option overrides all default options. Extend the default options when adding new patterns to ignore:\n\nts\n\n``` javascript\nimport { coverageConfigDefaults, defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      exclude: ['**/custom-pattern/**', ...coverageConfigDefaults.exclude]\n    },\n  },\n})\n```\n\n**NOTE**\n\nVitest automatically adds test files `include` patterns to the default value of `coverage.exclude`.\n\n#### coverage.all\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.all`, `--coverage.all=false`\n\nWhether to include all files, including the untested ones into report.\n\n#### coverage.clean\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.clean`, `--coverage.clean=false`\n\nClean coverage results before running tests\n\n#### coverage.cleanOnRerun\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.cleanOnRerun`, `--coverage.cleanOnRerun=false`\n\nClean coverage report on watch rerun\n\n#### coverage.reportsDirectory\n\n- **Type:** `string`\n- **Default:** `'./coverage'`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.reportsDirectory=<path>`\n\n**WARNING**\n\nVitest will delete this directory before running tests if `coverage.clean` is enabled (default value).\n\nDirectory to write coverage report to.\n\nTo preview the coverage report in the output of [HTML reporter](../guide/reporters#html-reporter), this option must be set as a sub-directory of the html report directory (for example `./html/coverage`).\n\n#### coverage.reporter\n\n- **Type:** `string | string[] | [string, {}][]`\n- **Default:** `['text', 'html', 'clover', 'json']`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.reporter=<reporter>`, `--coverage.reporter=<reporter1> --coverage.reporter=<reporter2>`\n\nCoverage reporters to use. See [istanbul documentation](https://istanbul.js.org/docs/advanced/alternative-reporters/) for detailed list of all reporters. See [`@types/istanbul-reporter`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/276d95e4304b3670eaf6e8e5a7ea9e265a14e338/types/istanbul-reports/index.d.ts) for details about reporter specific options.\n\nThe reporter has three different types:\n\n- A single reporter: `{ reporter: 'html' }`\n- Multiple reporters without options: `{ reporter: ['html', 'json'] }`\n- A single or multiple reporters with reporter options:\n  ts\n  ``` javascript\n  {\n    reporter: [\n      ['lcov', { 'projectRoot': './src' }],\n      ['json', { 'file': 'coverage.json' }],\n      ['text']\n    ]\n  }\n  ```\n\nYou can also pass custom coverage reporters. See [Guide - Custom Coverage Reporter](../guide/coverage#custom-coverage-reporter) for more information.\n\nts\n\n``` javascript\n{\n    reporter: [\n      // Specify reporter using name of the NPM package\n      '@vitest/custom-coverage-reporter',\n      ['@vitest/custom-coverage-reporter', { someOption: true }],\n\n      // Specify reporter using local path\n      '/absolute/path/to/custom-reporter.cjs',\n      ['/absolute/path/to/custom-reporter.cjs', { someOption: true }],\n    ]\n  }\n```\n\nYou can check your coverage report in Vitest UI: check [Vitest UI Coverage](../guide/coverage#vitest-ui) for more details.\n\n#### coverage.reportOnFailure\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.reportOnFailure`, `--coverage.reportOnFailure=false`\n\nGenerate coverage report even when tests fail.\n\n#### coverage.allowExternal\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.allowExternal`, `--coverage.allowExternal=false`\n\nCollect coverage of files outside the [project `root`](#root).\n\n#### coverage.skipFull\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.skipFull`, `--coverage.skipFull=false`\n\nDo not show files with 100% statement, branch, and function coverage.\n\n#### coverage.thresholds\n\nOptions for coverage thresholds\n\n##### coverage.thresholds.lines\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.lines=<number>`\n\nGlobal threshold for lines. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.functions\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.functions=<number>`\n\nGlobal threshold for functions. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.branches\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.branches=<number>`\n\nGlobal threshold for branches. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.statements\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.statements=<number>`\n\nGlobal threshold for statements. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.perFile\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.perFile`, `--coverage.thresholds.perFile=false`\n\nCheck thresholds per file.\n\n##### coverage.thresholds.autoUpdate\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.autoUpdate=<boolean>`\n\nUpdate all threshold values `lines`, `functions`, `branches` and `statements` to configuration file when current coverage is above the configured thresholds. This option helps to maintain thresholds when coverage is improved.\n\n##### coverage.thresholds.100\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.100`, `--coverage.thresholds.100=false`\n\nSets global thresholds to 100. Shortcut for `--coverage.thresholds.lines 100 --coverage.thresholds.functions 100 --coverage.thresholds.branches 100 --coverage.thresholds.statements 100`.\n\n##### coverage.thresholds\\[glob-pattern\\]\n\n- **Type:** `{ statements?: number functions?: number branches?: number lines?: number }`\n- **Default:** `undefined`\n- **Available for providers:** `'v8' | 'istanbul'`\n\nSets thresholds for files matching the glob pattern.\n\nts\n\n``` javascript\n{\n  coverage: {\n    thresholds: {\n      // Thresholds for all files\n      functions: 95,\n      branches: 70,\n\n      // Thresholds for matching glob pattern\n      'src/utils/**.ts': {\n        statements: 95,\n        functions: 90,\n        branches: 85,\n        lines: 80,\n      },\n\n      // Files matching this pattern will only have lines thresholds set.\n      // Global thresholds are not inherited.\n      '**/math.ts': {\n        lines: 100,\n      }\n    }\n  }\n}\n```\n\n#### coverage.ignoreEmptyLines\n\n- **Type:** `boolean`\n- **Default:** `true` (`false` in v1)\n- **Available for providers:** `'v8'`\n- **CLI:** `--coverage.ignoreEmptyLines=<boolean>`\n\nIgnore empty lines, comments and other non-runtime code, e.g. Typescript types.\n\nThis option works only if the used compiler removes comments and other non-runtime code from the transpiled code. By default Vite uses ESBuild which removes comments and Typescript types from `.ts`, `.tsx` and `.jsx` files.\n\nIf you want to apply ESBuild to other files as well, define them in [`esbuild` options](https://vitejs.dev/config/shared-options.html#esbuild):\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  esbuild: {\n    // Transpile all files with ESBuild to remove comments from code coverage.\n    // Required for `test.coverage.ignoreEmptyLines` to work:\n    include: ['**/*.js', '**/*.jsx', '**/*.mjs', '**/*.ts', '**/*.tsx'],\n  },\n  test: {\n    coverage: {\n      provider: 'v8',\n      ignoreEmptyLines: true,\n    },\n  },\n})\n```\n\n#### coverage.ignoreClassMethods\n\n- **Type:** `string[]`\n- **Default:** `[]`\n- **Available for providers:** `'istanbul'`\n- **CLI:** `--coverage.ignoreClassMethods=<method>`\n\nSet to array of class method names to ignore for coverage. See [istanbul documentation](https://github.com/istanbuljs/nyc#ignoring-methods) for more information.\n\n#### coverage.watermarks\n\n- **Type:**\n\nts\n\n``` javascript\n{\n  statements?: [number, number],\n  functions?: [number, number],\n  branches?: [number, number],\n  lines?: [number, number]\n}\n```\n\n- **Default:**\n\nts\n\n``` javascript\n{\n  statements: [50, 80],\n  functions: [50, 80],\n  branches: [50, 80],\n  lines: [50, 80]\n}\n```\n\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.watermarks.statements=50,80`, `--coverage.watermarks.branches=50,80`\n\nWatermarks for statements, lines, branches and functions. See [istanbul documentation](https://github.com/istanbuljs/nyc#high-and-low-watermarks) for more information.\n\n#### coverage.processingConcurrency\n\n- **Type:** `boolean`\n- **Default:** `Math.min(20, os.availableParallelism?.() ?? os.cpus().length)`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.processingConcurrency=<number>`\n\nConcurrency limit used when processing the coverage results.\n\n#### coverage.customProviderModule\n\n- **Type:** `string`\n- **Available for providers:** `'custom'`\n- **CLI:** `--coverage.customProviderModule=<path or module name>`\n\nSpecifies the module name or path for the custom coverage provider module. See [Guide - Custom Coverage Provider](../guide/coverage#custom-coverage-provider) for more information.\n\n### testNamePattern \\* \n\n- **Type** `string | RegExp`\n- **CLI:** `-t <pattern>`, `--testNamePattern=<pattern>`, `--test-name-pattern=<pattern>`\n\nRun tests with full names matching the pattern. If you add `OnlyRunThis` to this property, tests not containing the word `OnlyRunThis` in the test name will be skipped.\n\njs\n\n``` javascript\nimport { expect, test } from 'vitest'\n\n// run\ntest('OnlyRunThis', () => {\n  expect(true).toBe(true)\n})\n\n// skipped\ntest('doNotRun', () => {\n  expect(true).toBe(true)\n})\n```\n\n### open \\* \n\n- **Type:** `boolean`\n- **Default:** `!process.env.CI`\n- **CLI:** `--open`, `--open=false`\n\nOpen Vitest UI (WIP)\n\n### api\n\n- **Type:** `boolean | number`\n- **Default:** `false`\n- **CLI:** `--api`, `--api.port`, `--api.host`, `--api.strictPort`\n\nListen to port and serve API. When set to true, the default port is 51204\n\n### browser\n\n- **Type:** `{ enabled?, name?, provider?, headless?, api? }`\n- **Default:** `{ enabled: false, headless: process.env.CI, api: 63315 }`\n- **CLI:** `--browser`, `--browser=<name>`, `--browser.name=chrome --browser.headless`\n\nRun Vitest tests in a browser. We use [WebdriverIO](https://webdriver.io/) for running tests by default, but it can be configured with [browser.provider](#browser-provider) option.\n\n**NOTE**\n\nRead more about testing in a real browser in the [guide page](../guide/browser/index).\n\n**WARNING**\n\nThis is an experimental feature. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\n#### browser.enabled\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **CLI:** `--browser`, `--browser.enabled=false`\n\nRun all tests inside a browser by default. Can be overridden with [`poolMatchGlobs`](#poolmatchglobs) option.\n\n#### browser.name\n\n- **Type:** `string`\n- **CLI:** `--browser=safari`\n\nRun all tests in a specific browser. Possible options in different providers:\n\n- `webdriverio`: `firefox`, `chrome`, `edge`, `safari`\n- `playwright`: `firefox`, `webkit`, `chromium`\n- custom: any string that will be passed to the provider\n\n#### browser.headless\n\n- **Type:** `boolean`\n- **Default:** `process.env.CI`\n- **CLI:** `--browser.headless`, `--browser.headless=false`\n\nRun the browser in a `headless` mode. If you are running Vitest in CI, it will be enabled by default.\n\n#### browser.isolate\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **CLI:** `--browser.isolate`, `--browser.isolate=false`\n\nRun every test in a separate iframe.\n\n#### browser.api\n\n- **Type:** `number | { port?, strictPort?, host? }`\n- **Default:** `63315`\n- **CLI:** `--browser.api=63315`, `--browser.api.port=1234, --browser.api.host=example.com`\n\nConfigure options for Vite server that serves code in the browser. Does not affect [`test.api`](#api) option.\n\n#### browser.provider\n\n- **Type:** `'webdriverio' | 'playwright' | string`\n- **Default:** `'webdriverio'`\n- **CLI:** `--browser.provider=playwright`\n\nPath to a provider that will be used when running browser tests. Vitest provides two providers which are `webdriverio` (default) and `playwright`. Custom providers should be exported using `default` export and have this shape:\n\nts\n\n``` javascript\nexport interface BrowserProvider {\n  name: string\n  getSupportedBrowsers: () => readonly string[]\n  initialize: (ctx: Vitest, options: { browser: string; options?: BrowserProviderOptions }) => Awaitable<void>\n  openPage: (url: string) => Awaitable<void>\n  close: () => Awaitable<void>\n}\n```\n\n**WARNING**\n\nThis is an advanced API for library authors. If you just need to run tests in a browser, use the [browser](#browser) option.\n\n#### browser.providerOptions\n\n- **Type:** `BrowserProviderOptions`\n\nOptions that will be passed down to provider when calling `provider.initialize`.\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    browser: {\n      providerOptions: {\n        launch: {\n          devtools: true,\n        }\n      }\n    }\n  }\n})\n```\n\n**TIP**\n\nTo have a better type safety when using built-in providers, you can add one of these types (for provider that you are using) to your tsconfig's `compilerOptions.types` field:\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/webdriverio\",\n      \"@vitest/browser/providers/playwright\"\n    ]\n  }\n}\n```\n\n#### browser.ui\n\n- **Type:** `boolean`\n- **Default:** `!isCI`\n- **CLI:** `--browser.ui=false`\n\nShould Vitest UI be injected into the page. By default, injects UI iframe during development.\n\n#### browser.viewport\n\n- **Type:** `{ width, height }`\n- **Default:** `414x896`\n\nDefault iframe's viewport.\n\n#### browser.screenshotDirectory\n\n- **Type:** `string`\n- **Default:** `__snapshots__` in the test file directory\n\nPath to the snapshots directory relative to the `root`.\n\n#### browser.screenshotFailures\n\n- **Type:** `boolean`\n- **Default:** `!browser.ui`\n\nShould Vitest take screenshots if the test fails.\n\n#### browser.orchestratorScripts\n\n- **Type:** `BrowserScript[]`\n- **Default:** `[]`\n\nCustom scripts that should be injected into the orchestrator HTML before test iframes are initiated. This HTML document only sets up iframes and doesn't actually import your code.\n\nThe script `src` and `content` will be processed by Vite plugins. Script should be provided in the following shape:\n\nts\n\n``` javascript\nexport interface BrowserScript {\n  /**\n   * If \"content\" is provided and type is \"module\", this will be its identifier.\n   *\n   * If you are using TypeScript, you can add `.ts` extension here for example.\n   * @default `injected-${index}.js`\n   */\n  id?: string\n  /**\n   * JavaScript content to be injected. This string is processed by Vite plugins if type is \"module\".\n   *\n   * You can use `id` to give Vite a hint about the file extension.\n   */\n  content?: string\n  /**\n   * Path to the script. This value is resolved by Vite so it can be a node module or a file path.\n   */\n  src?: string\n  /**\n   * If the script should be loaded asynchronously.\n   */\n  async?: boolean\n  /**\n   * Script type.\n   * @default 'module'\n   */\n  type?: string\n}\n```\n\n#### browser.testerScripts\n\n- **Type:** `BrowserScript[]`\n- **Default:** `[]`\n\nCustom scripts that should be injected into the tester HTML before the tests environment is initiated. This is useful to inject polyfills required for Vitest browser implementation. It is recommended to use [`setupFiles`](#setupfiles) in almost all cases instead of this.\n\nThe script `src` and `content` will be processed by Vite plugins.\n\n#### browser.commands\n\n- **Type:** `Record<string, BrowserCommand>`\n- **Default:** `{ readFile, writeFile, ... }`\n\nCustom [commands](../guide/browser/commands) that can be import during browser tests from `@vitest/browser/commands`.\n\n### clearMocks\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nWill call [`.mockClear()`](../api/mock#mockclear) on all spies before each test. This will clear mock history, but not reset its implementation to the default one.\n\n### mockReset\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nWill call [`.mockReset()`](../api/mock#mockreset) on all spies before each test. This will clear mock history and reset its implementation to an empty function (will return `undefined`).\n\n### restoreMocks\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nWill call [`.mockRestore()`](../api/mock#mockrestore) on all spies before each test. This will clear mock history and reset its implementation to the original one.\n\n### unstubEnvs\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nWill call [`vi.unstubAllEnvs`](../api/vi#vi-unstuballenvs) before each test.\n\n### unstubGlobals\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nWill call [`vi.unstubAllGlobals`](../api/vi#vi-unstuballglobals) before each test.\n\n### testTransformMode\n\n- **Type:** `{ web?, ssr? }`\n\nDetermine the transform method for all modules imported inside a test that matches the glob pattern. By default, relies on the environment. For example, tests with JSDOM environment will process all files with `ssr: false` flag and tests with Node environment process all modules with `ssr: true`.\n\n#### testTransformMode.ssr\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nUse SSR transform pipeline for all modules inside specified tests.  \nVite plugins will receive `ssr: true` flag when processing those files.\n\n#### testTransformMode.web\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nFirst do a normal transform pipeline (targeting browser), then do a SSR rewrite to run the code in Node.  \nVite plugins will receive `ssr: false` flag when processing those files.\n\n### snapshotFormat \\* \n\n- **Type:** `PrettyFormatOptions`\n\nFormat options for snapshot testing. These options are passed down to [`pretty-format`](https://www.npmjs.com/package/pretty-format).\n\n**TIP**\n\nBeware that `plugins` field on this object will be ignored.\n\nIf you need to extend snapshot serializer via pretty-format plugins, please, use [`expect.addSnapshotSerializer`](../api/expect#expect-addsnapshotserializer) API or [snapshotSerializers](#snapshotserializers) option.\n\n### snapshotSerializers \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nA list of paths to snapshot serializer modules for snapshot testing, useful if you want add custom snapshot serializers. See [Custom Serializer](../guide/snapshot#custom-serializer) for more information.\n\n### resolveSnapshotPath \\* \n\n- **Type**: `(testPath: string, snapExtension: string) => string`\n- **Default**: stores snapshot files in `__snapshots__` directory\n\nOverrides default snapshot path. For example, to store snapshots next to test files:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    resolveSnapshotPath: (testPath, snapExtension) => testPath + snapExtension,\n  },\n})\n```\n\n### allowOnly\n\n- **Type**: `boolean`\n- **Default**: `!process.env.CI`\n- **CLI:** `--allowOnly`, `--allowOnly=false`\n\nAllow tests and suites that are marked as only.\n\n### dangerouslyIgnoreUnhandledErrors \\* \n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI:** `--dangerouslyIgnoreUnhandledErrors` `--dangerouslyIgnoreUnhandledErrors=false`\n\nIgnore any unhandled errors that occur.\n\n### passWithNoTests \\* \n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI:** `--passWithNoTests`, `--passWithNoTests=false`\n\nVitest will not fail, if no tests will be found.\n\n### logHeapUsage\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI:** `--logHeapUsage`, `--logHeapUsage=false`\n\nShow heap usage after each test. Useful for debugging memory leaks.\n\n### css\n\n- **Type**: `boolean | { include?, exclude?, modules? }`\n\nConfigure if CSS should be processed. When excluded, CSS files will be replaced with empty strings to bypass the subsequent processing. CSS Modules will return a proxy to not affect runtime.\n\n#### css.include\n\n- **Type**: `RegExp | RegExp[]`\n- **Default**: `[]`\n\nRegExp pattern for files that should return actual CSS and will be processed by Vite pipeline.\n\n**TIP**\n\nTo process all CSS files, use `/.+/`.\n\n#### css.exclude\n\n- **Type**: `RegExp | RegExp[]`\n- **Default**: `[]`\n\nRegExp pattern for files that will return an empty CSS file.\n\n#### css.modules\n\n- **Type**: `{ classNameStrategy? }`\n- **Default**: `{}`\n\n#### css.modules.classNameStrategy\n\n- **Type**: `'stable' | 'scoped' | 'non-scoped'`\n- **Default**: `'stable'`\n\nIf you decide to process CSS files, you can configure if class names inside CSS modules should be scoped. You can choose one of the options:\n\n- `stable`: class names will be generated as `_${name}_${hashedFilename}`, which means that generated class will stay the same, if CSS content is changed, but will change, if the name of the file is modified, or file is moved to another folder. This setting is useful, if you use snapshot feature.\n- `scoped`: class names will be generated as usual, respecting `css.modules.generateScopeName` method, if you have one and CSS processing is enabled. By default, filename will be generated as `_${name}_${hash}`, where hash includes filename and content of the file.\n- `non-scoped`: class names will not be hashed.\n\n**WARNING**\n\nBy default, Vitest exports a proxy, bypassing CSS Modules processing. If you rely on CSS properties on your classes, you have to enable CSS processing using `include` option.\n\n### maxConcurrency\n\n- **Type**: `number`\n- **Default**: `5`\n- **CLI**: `--max-concurrency=10`, `--maxConcurrency=10`\n\nA number of tests that are allowed to run at the same time marked with `test.concurrent`.\n\nTest above this limit will be queued to run when available slot appears.\n\n### cache \\* \n\n- **Type**: `false`\n- **CLI**: `--no-cache`, `--cache=false`\n\nUse this option if you want to disable the cache feature. At the moment Vitest stores cache for test results to run the longer and failed tests first.\n\nThe cache directory is controlled by the Vite's [`cacheDir`](https://vitejs.dev/config/shared-options.html#cachedir) option:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  cacheDir: 'custom-folder/.vitest'\n})\n```\n\nYou can limit the directory only for Vitest by using `process.env.VITEST`:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  cacheDir: process.env.VITEST ? 'custom-folder/.vitest' : undefined\n})\n```\n\n### sequence\n\n- **Type**: `{ sequencer?, shuffle?, seed?, hooks?, setupFiles? }`\n\nOptions for how tests should be sorted.\n\nYou can provide sequence options to CLI with dot notation:\n\nsh\n\n``` javascript\nnpx vitest --sequence.shuffle --sequence.seed=1000\n```\n\n#### sequence.sequencer \\* \n\n- **Type**: `TestSequencerConstructor`\n- **Default**: `BaseSequencer`\n\nA custom class that defines methods for sharding and sorting. You can extend `BaseSequencer` from `vitest/node`, if you only need to redefine one of the `sort` and `shard` methods, but both should exist.\n\nSharding is happening before sorting, and only if `--shard` option is provided.\n\n#### sequence.shuffle\n\n- **Type**: `boolean | { files?, tests? }`\n- **Default**: `false`\n- **CLI**: `--sequence.shuffle`, `--sequence.shuffle=false`\n\nIf you want files and tests to run randomly, you can enable it with this option, or CLI argument [`--sequence.shuffle`](../guide/cli).\n\nVitest usually uses cache to sort tests, so long running tests start earlier - this makes tests run faster. If your files and tests will run in random order you will lose this performance improvement, but it may be useful to track tests that accidentally depend on another run previously.\n\n#### sequence.shuffle.files\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--sequence.shuffle.files`, `--sequence.shuffle.files=false`\n\nWhether to randomize files, be aware that long running tests will not start earlier if you enable this option.\n\n#### sequence.shuffle.tests\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--sequence.shuffle.tests`, `--sequence.shuffle.tests=false`\n\nWhether to randomize tests.\n\n#### sequence.concurrent\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--sequence.concurrent`, `--sequence.concurrent=false`\n\nIf you want tests to run in parallel, you can enable it with this option, or CLI argument [`--sequence.concurrent`](../guide/cli).\n\n#### sequence.seed \\* \n\n- **Type**: `number`\n- **Default**: `Date.now()`\n- **CLI**: `--sequence.seed=1000`\n\nSets the randomization seed, if tests are running in random order.\n\n#### sequence.hooks\n\n- **Type**: `'stack' | 'list' | 'parallel'`\n- **Default**: `'parallel'`\n- **CLI**: `--sequence.hooks=<value>`\n\nChanges the order in which hooks are executed.\n\n- `stack` will order \"after\" hooks in reverse order, \"before\" hooks will run in the order they were defined\n- `list` will order all hooks in the order they are defined\n- `parallel` will run hooks in a single group in parallel (hooks in parent suites will still run before the current suite's hooks)\n\n**TIP**\n\nThis option doesn't affect [`onTestFinished`](../api/index#ontestfinished). It is always called in reverse order.\n\n#### sequence.setupFiles\n\n- **Type**: `'list' | 'parallel'`\n- **Default**: `'parallel'`\n- **CLI**: `--sequence.setupFiles=<value>`\n\nChanges the order in which setup files are executed.\n\n- `list` will run setup files in the order they are defined\n- `parallel` will run setup files in parallel\n\n### typecheck\n\nOptions for configuring [typechecking](../guide/testing-types) test environment.\n\n#### typecheck.enabled\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--typecheck`, `--typecheck.enabled`\n\nEnable typechecking alongside your regular tests.\n\n#### typecheck.only\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--typecheck.only`\n\nRun only typecheck tests, when typechecking is enabled. When using CLI, this option will automatically enable typechecking.\n\n#### typecheck.checker\n\n- **Type**: `'tsc' | 'vue-tsc' | string`\n- **Default**: `tsc`\n\nWhat tools to use for type checking. Vitest will spawn a process with certain parameters for easier parsing, depending on the type. Checker should implement the same output format as `tsc`.\n\nYou need to have a package installed to use typechecker:\n\n- `tsc` requires `typescript` package\n- `vue-tsc` requires `vue-tsc` package\n\nYou can also pass down a path to custom binary or command name that produces the same output as `tsc --noEmit --pretty false`.\n\n#### typecheck.include\n\n- **Type**: `string[]`\n- **Default**: `['**/*.{test,spec}-d.?(c|m)[jt]s?(x)']`\n\nGlob pattern for files that should be treated as test files\n\n#### typecheck.exclude\n\n- **Type**: `string[]`\n- **Default**: `['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**']`\n\nGlob pattern for files that should not be treated as test files\n\n#### typecheck.allowJs\n\n- **Type**: `boolean`\n- **Default**: `false`\n\nCheck JS files that have `@ts-check` comment. If you have it enabled in tsconfig, this will not overwrite it.\n\n#### typecheck.ignoreSourceErrors\n\n- **Type**: `boolean`\n- **Default**: `false`\n\nDo not fail, if Vitest found errors outside the test files. This will not show you non-test errors at all.\n\nBy default, if Vitest finds source error, it will fail test suite.\n\n#### typecheck.tsconfig\n\n- **Type**: `string`\n- **Default**: *tries to find closest tsconfig.json*\n\nPath to custom tsconfig, relative to the project root.\n\n### slowTestThreshold \\* \n\n- **Type**: `number`\n- **Default**: `300`\n- **CLI**: `--slow-test-threshold=<number>`, `--slowTestThreshold=<number>`\n\nThe number of milliseconds after which a test is considered slow and reported as such in the results.\n\n### chaiConfig\n\n- **Type:** `{ includeStack?, showDiff?, truncateThreshold? }`\n- **Default:** `{ includeStack: false, showDiff: true, truncateThreshold: 40 }`\n\nEquivalent to [Chai config](https://github.com/chaijs/chai/blob/4.x.x/lib/chai/config.js).\n\n#### chaiConfig.includeStack\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nInfluences whether stack trace is included in Assertion error message. Default of false suppresses stack trace in the error message.\n\n#### chaiConfig.showDiff\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nInfluences whether or not the `showDiff` flag should be included in the thrown AssertionErrors. `false` will always be `false`; `true` will be true when the assertion has requested a diff to be shown.\n\n#### chaiConfig.truncateThreshold\n\n- **Type:** `number`\n- **Default:** `40`\n\nSets length threshold for actual and expected values in assertion errors. If this threshold is exceeded, for example for large data structures, the value is replaced with something like `[ Array(3) ]` or `{ Object (prop1, prop2) }`. Set it to `0` if you want to disable truncating altogether.\n\nThis config option affects truncating values in `test.each` titles and inside the assertion error message.\n\n### bail\n\n- **Type:** `number`\n- **Default:** `0`\n- **CLI**: `--bail=<value>`\n\nStop test execution when given number of tests have failed.\n\nBy default Vitest will run all of your test cases even if some of them fail. This may not be desired for CI builds where you are only interested in 100% successful builds and would like to stop test execution as early as possible when test failures occur. The `bail` option can be used to speed up CI runs by preventing it from running more tests when failures have occurred.\n\n### retry\n\n- **Type:** `number`\n- **Default:** `0`\n- **CLI:** `--retry=<value>`\n\nRetry the test specific number of times if it fails.\n\n### onConsoleLog \\* \n\n- **Type**: `(log: string, type: 'stdout' | 'stderr') => boolean | void`\n\nCustom handler for `console.log` in tests. If you return `false`, Vitest will not print the log to the console.\n\nCan be useful for filtering out logs from third-party libraries.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onConsoleLog(log: string, type: 'stdout' | 'stderr'): boolean | void {\n      return !(log === 'message from third party library' && type === 'stdout')\n    },\n  },\n})\n```\n\n### onStackTrace \\* \n\n- **Type**: `(error: Error, frame: ParsedStack) => boolean | void`\n\nApply a filtering function to each frame of each stack trace when handling errors. The first argument, `error`, is an object with the same properties as a standard `Error`, but it is not an actual instance.\n\nCan be useful for filtering out stack trace frames from third-party libraries.\n\nts\n\n``` javascript\nimport type { ParsedStack } from 'vitest'\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onStackTrace(error: Error, { file }: ParsedStack): boolean | void {\n      // If we've encountered a ReferenceError, show the whole stack.\n      if (error.name === 'ReferenceError') {\n        return\n      }\n\n      // Reject all frames from third party libraries.\n      if (file.includes('node_modules')) {\n        return false\n      }\n    },\n  },\n})\n```\n\n### diff\n\n- **Type:** `string`\n- **CLI:** `--diff=<value>`\n\nPath to a diff config that will be used to generate diff interface. Useful if you want to customize diff display.\n\nvitest.diff.tsvitest.config.js\n\nts\n\n``` javascript\nimport type { DiffOptions } from 'vitest'\nimport c from 'picocolors'\n\nexport default {\n  aIndicator: c.bold('--'),\n  bIndicator: c.bold('++'),\n  omitAnnotationLines: true,\n} satisfies DiffOptions\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    diff: './vitest.diff.ts'\n  }\n})\n```\n\n#### diff.truncateThreshold\n\n- **Type**: `number`\n- **Default**: `0`\n\nThe maximum length of diff result to be displayed. Diffs above this threshold will be truncated. Truncation won't take effect with default value 0.\n\n#### diff.truncateAnnotation\n\n- **Type**: `string`\n- **Default**: `'... Diff result is truncated'`\n\nAnnotation that is output at the end of diff result if it's truncated.\n\n#### diff.truncateAnnotationColor\n\n- **Type**: `DiffOptionsColor = (arg: string) => string`\n- **Default**: `noColor = (string: string): string => string`\n\nColor of truncate annotation, default is output with no color.\n\n### fakeTimers\n\n- **Type:** `FakeTimerInstallOpts`\n\nOptions that Vitest will pass down to [`@sinon/fake-timers`](https://www.npmjs.com/package/@sinonjs/fake-timers) when using [`vi.useFakeTimers()`](../api/vi#vi-usefaketimers).\n\n#### fakeTimers.now\n\n- **Type:** `number | Date`\n- **Default:** `Date.now()`\n\nInstalls fake timers with the specified Unix epoch.\n\n#### fakeTimers.toFake\n\n- **Type:** `('setTimeout' | 'clearTimeout' | 'setImmediate' | 'clearImmediate' | 'setInterval' | 'clearInterval' | 'Date' | 'nextTick' | 'hrtime' | 'requestAnimationFrame' | 'cancelAnimationFrame' | 'requestIdleCallback' | 'cancelIdleCallback' | 'performance' | 'queueMicrotask')[]`\n- **Default:** `['setTimeout', 'clearTimeout', 'setImmediate', 'clearImmediate', 'setInterval', 'clearInterval', 'Date']`\n\nAn array with names of global methods and APIs to fake.\n\nTo only mock `setTimeout()` and `nextTick()`, specify this property as `['setTimeout', 'nextTick']`.\n\nMocking `nextTick` is not supported when running Vitest inside `node:child_process` by using `--pool=forks`. NodeJS uses `process.nextTick` internally in `node:child_process` and hangs when it is mocked. Mocking `nextTick` is supported when running Vitest with `--pool=threads`.\n\n#### fakeTimers.loopLimit\n\n- **Type:** `number`\n- **Default:** `10_000`\n\nThe maximum number of timers that will be run when calling [`vi.runAllTimers()`](../api/vi#vi-runalltimers).\n\n#### fakeTimers.shouldAdvanceTime\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nTells @sinonjs/fake-timers to increment mocked time automatically based on the real system time shift (e.g. the mocked time will be incremented by 20ms for every 20ms change in the real system time).\n\n#### fakeTimers.advanceTimeDelta\n\n- **Type:** `number`\n- **Default:** `20`\n\nRelevant only when using with `shouldAdvanceTime: true`. increment mocked time by advanceTimeDelta ms every advanceTimeDelta ms change in the real system time.\n\n#### fakeTimers.shouldClearNativeTimers\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nTells fake timers to clear \"native\" (i.e. not fake) timers by delegating to their respective handlers. These are not cleared by default, leading to potentially unexpected behavior if timers existed prior to starting fake timers session.\n\n### workspace \\* \n\n- **Type:** `string`\n- **CLI:** `--workspace=./file.js`\n- **Default:** `vitest.{workspace,projects}.{js,ts,json}` close to the config file or root\n\nPath to a [workspace](../guide/workspace) config file relative to [root](#root).\n\n### isolate\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **CLI:** `--no-isolate`, `--isolate=false`\n\nRun tests in an isolated environment. This option has no effect on `vmThreads` and `vmForks` pools.\n\nDisabling this option might [improve performance](../guide/improving-performance) if your code doesn't rely on side effects (which is usually true for projects with `node` environment).\n\n**TIP**\n\nYou can disable isolation for specific pools by using [`poolOptions`](#pooloptions) property.\n\n### includeTaskLocation\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nShould `location` property be included when Vitest API receives tasks in [reporters](#reporters). If you have a lot of tests, this might cause a small performance regression.\n\nThe `location` property has `column` and `line` values that correspond to the `test` or `describe` position in the original file.\n\nThis option will be auto-enabled if you don't disable it explicitly, and you are running Vitest with:\n\n- [Vitest UI](../guide/ui)\n- or using the [Browser Mode](../guide/browser/index) without [headless](../guide/browser/index#headless) mode\n- or using [HTML Reporter](../guide/reporters#html-reporter)\n\n**TIP**\n\nThis option has no effect if you do not use custom code that relies on this.\n\n### snapshotEnvironment\n\n- **Type:** `string`\n\nPath to a custom snapshot environment implementation. This is useful if you are running your tests in an environment that doesn't support Node.js APIs. This option doesn't have any effect on a browser runner.\n\nThis object should have the shape of `SnapshotEnvironment` and is used to resolve and read/write snapshot files:\n\nts\n\n``` javascript\nexport interface SnapshotEnvironment {\n  getVersion: () => string\n  getHeader: () => string\n  resolvePath: (filepath: string) => Promise<string>\n  resolveRawPath: (testPath: string, rawPath: string) => Promise<string>\n  saveSnapshotFile: (filepath: string, snapshot: string) => Promise<void>\n  readSnapshotFile: (filepath: string) => Promise<string | null>\n  removeSnapshotFile: (filepath: string) => Promise<void>\n}\n```\n\nYou can extend default `VitestSnapshotEnvironment` from `vitest/snapshot` entry point if you need to overwrite only a part of the API.\n\n**WARNING**\n\nThis is a low-level option and should be used only for advanced cases where you don't have access to default Node.js APIs.\n\nIf you just need to configure snapshots feature, use [`snapshotFormat`](#snapshotformat) or [`resolveSnapshotPath`](#resolvesnapshotpath) options.\n\n### env\n\n- **Type:** `Partial<NodeJS.ProcessEnv>`\n\nEnvironment variables available on `process.env` and `import.meta.env` during tests. These variables will not be available in the main process (in `globalSetup`, for example).\n\n### expect\n\n- **Type:** `ExpectOptions`\n\n#### expect.requireAssertions\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nThe same as calling [`expect.hasAssertions()`](../api/expect#expect-hasassertions) at the start of every test. This makes sure that no test will pass accidentally.\n\n**TIP**\n\nThis only works with Vitest's `expect`. If you use `assert` ot `.should` assertions, they will not count, and your test will fail due to the lack of expect assertions.\n\nYou can change the value of this by calling `vi.setConfig({ expect: { requireAssertions: false } })`. The config will be applied to every subsequent `expect` call until the `vi.resetConfig` is called manually.\n\n#### expect.poll\n\nGlobal configuration options for [`expect.poll`](../api/expect#poll). These are the same options you can pass down to `expect.poll(condition, options)`.\n\n##### expect.poll.interval\n\n- **Type:** `number`\n- **Default:** `50`\n\nPolling interval in milliseconds\n\n##### expect.poll.timeout\n\n- **Type:** `number`\n- **Default:** `1000`\n\nPolling timeout in milliseconds\n\n### printConsoleTrace\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nAlways print console traces when calling any `console` method. This is useful for debugging.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/config/](https://vitest.dev/config/)"
- name: constructorParameters ​
  id: api/expect-typeof#constructorparameters
  summary: You can extract constructor parameters as an array of values and perform assertions on them with this method
  belongs_to: expectTypeOf
  description: |-
    ## constructorParameters

    - **Type:** `ExpectTypeOf<ConstructorParameters>`

    You can extract constructor parameters as an array of values and perform assertions on them with this method.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(Date).constructorParameters.toEqualTypeOf<[] | [string | number | Date]>()
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.

    **TIP**

    You can also use [`.toBeConstructibleWith`](#tobeconstructiblewith) matcher as a more expressive assertion.
- name: containsAllDeepKeys ​
  id: api/assert#containsalldeepkeys
  summary: Asserts that object contains all of the keys provided
  belongs_to: assert
  description: |-
    ## containsAllDeepKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` contains all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.containsAllDeepKeys', () => {
      assert.containsAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })
      assert.containsAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])
      assert.containsAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })
      assert.containsAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])
    })
    ```
- name: containsAllKeys ​
  id: api/assert#containsallkeys
  summary: Asserts that object has all of the keys provided but may have more keys not listed
  belongs_to: assert
  description: |-
    ## containsAllKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has all of the `keys` provided but may have more keys not listed. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.containsAllKeys', () => {
      assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'baz'])
      assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])
      assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, baz: 1337 })
      assert.containsAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })
      assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }])
      assert.containsAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])
      assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }]))
      assert.containsAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))
    })
    ```
- name: Context
  id: guide/browser/context
  summary: Vitest exposes a context module via @vitest/browser/context entry point
  description: "# Context\n\nVitest exposes a context module via `@vitest/browser/context` entry point. As of 2.0, it exposes a small set of utilities that might be useful to you in tests.\n\nts\n\n``` javascript\nexport const server: {\n  /**\n   * Platform the Vitest server is running on.\n   * The same as calling `process.platform` on the server.\n   */\n  platform: Platform\n  /**\n   * Runtime version of the Vitest server.\n   * The same as calling `process.version` on the server.\n   */\n  version: string\n  /**\n   * Name of the browser provider.\n   */\n  provider: string\n  /**\n   * Name of the current browser.\n   */\n  browser: string\n  /**\n   * Available commands for the browser.\n   */\n  commands: BrowserCommands\n}\n\n/**\n * Handler for user interactions. The support is implemented by the browser provider (`playwright` or `webdriverio`).\n * If used with `preview` provider, fallbacks to simulated events via `@testing-library/user-event`.\n * @experimental\n */\nexport const userEvent: {\n  setup: () => UserEvent\n  click: (element: Element, options?: UserEventClickOptions) => Promise<void>\n  dblClick: (element: Element, options?: UserEventDoubleClickOptions) => Promise<void>\n  tripleClick: (element: Element, options?: UserEventTripleClickOptions) => Promise<void>\n  selectOptions: (\n    element: Element,\n    values: HTMLElement | HTMLElement[] | string | string[],\n    options?: UserEventSelectOptions,\n  ) => Promise<void>\n  keyboard: (text: string) => Promise<void>\n  type: (element: Element, text: string, options?: UserEventTypeOptions) => Promise<void>\n  clear: (element: Element) => Promise<void>\n  tab: (options?: UserEventTabOptions) => Promise<void>\n  hover: (element: Element, options?: UserEventHoverOptions) => Promise<void>\n  unhover: (element: Element, options?: UserEventHoverOptions) => Promise<void>\n  fill: (element: Element, text: string, options?: UserEventFillOptions) => Promise<void>\n  dragAndDrop: (source: Element, target: Element, options?: UserEventDragAndDropOptions) => Promise<void>\n}\n\n/**\n * Available commands for the browser.\n * A shortcut to `server.commands`.\n */\nexport const commands: BrowserCommands\n\nexport const page: {\n  /**\n   * Serialized test config.\n   */\n  config: ResolvedConfig\n  /**\n   * Change the size of iframe's viewport.\n   */\n  viewport(width: number, height: number): Promise<void>\n  /**\n   * Make a screenshot of the test iframe or a specific element.\n   * @returns Path to the screenshot file or path and base64.\n   */\n  screenshot(options: Omit<ScreenshotOptions, 'base64'> & { base64: true }): Promise<{\n    path: string\n    base64: string\n  }>\n  screenshot(options?: ScreenshotOptions): Promise<string>\n}\n\nexport const cdp: () => CDPSession\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/context](https://vitest.dev/guide/browser/context)"
- name: Coverage
  id: guide/coverage
  summary: Vitest supports Native code coverage via v8 and instrumented code coverage via istanbul
  description: "# Coverage\n\nVitest supports Native code coverage via [`v8`](https://v8.dev/blog/javascript-code-coverage) and instrumented code coverage via [`istanbul`](https://istanbul.js.org/).\n\n## Coverage Providers\n\nBoth `v8` and `istanbul` support are optional. By default, `v8` will be used.\n\nYou can select the coverage tool by setting `test.coverage.provider` to `v8` or `istanbul`:\n\nts\n\n``` javascript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'istanbul' // or 'v8'\n    },\n  },\n})\n```\n\nWhen you start the Vitest process, it will prompt you to install the corresponding support package automatically.\n\nOr if you prefer to install them manually:\n\nbash\n\n``` javascript\n# For v8\nnpm i -D @vitest/coverage-v8\n\n# For istanbul\nnpm i -D @vitest/coverage-istanbul\n```\n\n## Coverage Setup\n\n**TIP**\n\nIt's recommended to always define [`coverage.include`](../config/index#coverage-include) in your configuration file. This helps Vitest to reduce the amount of files picked by [`coverage.all`](../config/index#coverage-all).\n\nTo test with coverage enabled, you can pass the `--coverage` flag in CLI. By default, reporter `['text', 'html', 'clover', 'json']` will be used.\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\nTo configure it, set `test.coverage` options in your config file:\n\nts\n\n``` javascript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n    },\n  },\n})\n```\n\n## Custom Coverage Reporter\n\nYou can use custom coverage reporters by passing either the name of the package or absolute path in `test.coverage.reporter`:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reporter: [\n        // Specify reporter using name of the NPM package\n        ['@vitest/custom-coverage-reporter', { someOption: true }],\n\n        // Specify reporter using local path\n        '/absolute/path/to/custom-reporter.cjs',\n      ],\n    },\n  },\n})\n```\n\nCustom reporters are loaded by Istanbul and must match its reporter interface. See [built-in reporters' implementation](https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib) for reference.\n\njs\n\n``` javascript\n// custom-reporter.cjs\nconst { ReportBase } = require('istanbul-lib-report')\n\nmodule.exports = class CustomReporter extends ReportBase {\n  constructor(opts) {\n    super()\n\n    // Options passed from configuration are available here\n    this.file = opts.file\n  }\n\n  onStart(root, context) {\n    this.contentWriter = context.writer.writeFile(this.file)\n    this.contentWriter.println('Start of custom coverage report')\n  }\n\n  onEnd() {\n    this.contentWriter.println('End of custom coverage report')\n    this.contentWriter.close()\n  }\n}\n```\n\n## Custom Coverage Provider\n\nIt's also possible to provide your custom coverage provider by passing `'custom'` in `test.coverage.provider`:\n\nts\n\n``` javascript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'custom',\n      customProviderModule: 'my-custom-coverage-provider'\n    },\n  },\n})\n```\n\nThe custom providers require a `customProviderModule` option which is a module name or path where to load the `CoverageProviderModule` from. It must export an object that implements `CoverageProviderModule` as default export:\n\nts\n\n``` javascript\n// my-custom-coverage-provider.ts\nimport type { CoverageProvider, CoverageProviderModule, ResolvedCoverageOptions, Vitest } from 'vitest'\n\nconst CustomCoverageProviderModule: CoverageProviderModule = {\n  getProvider(): CoverageProvider {\n    return new CustomCoverageProvider()\n  },\n\n  // Implements rest of the CoverageProviderModule ...\n}\n\nclass CustomCoverageProvider implements CoverageProvider {\n  name = 'custom-coverage-provider'\n  options!: ResolvedCoverageOptions\n\n  initialize(ctx: Vitest) {\n    this.options = ctx.config.coverage\n  }\n\n  // Implements rest of the CoverageProvider ...\n}\n\nexport default CustomCoverageProviderModule\n```\n\nPlease refer to the type definition for more details.\n\n## Changing the Default Coverage Folder Location\n\nWhen running a coverage report, a `coverage` folder is created in the root directory of your project. If you want to move it to a different directory, use the `test.coverage.reportsDirectory` property in the `vite.config.js` file.\n\njs\n\n``` javascript\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reportsDirectory: './tests/unit/coverage'\n    }\n  }\n})\n```\n\n## Ignoring Code\n\nBoth coverage providers have their own ways how to ignore code from coverage reports:\n\n- [`v8`](https://github.com/istanbuljs/v8-to-istanbul#ignoring-uncovered-lines)\n- [`ìstanbul`](https://github.com/istanbuljs/nyc#parsing-hints-ignoring-lines)\n\nWhen using TypeScript the source codes are transpiled using `esbuild`, which strips all comments from the source codes ([esbuild#516](https://github.com/evanw/esbuild/issues/516)). Comments which are considered as [legal comments](https://esbuild.github.io/api/#legal-comments) are preserved.\n\nFor `istanbul` provider you can include a `@preserve` keyword in the ignore hint. Beware that these ignore hints may now be included in final production build as well.\n\ndiff\n\n``` javascript\n-/* istanbul ignore if */\n+/* istanbul ignore if -- @preserve */\nif (condition) {\n```\n\nFor `v8` this does not cause any issues. You can use `v8 ignore` comments with Typescript as usual:\n\nts\n\n``` javascript\n/* v8 ignore next 3 */\nif (condition) {\n```\n\n## Other Options\n\nTo see all configurable options for coverage, see the [coverage Config Reference](../config/index#coverage).\n\n## Vitest UI\n\nYou can check your coverage report in [Vitest UI](ui).\n\nVitest UI will enable coverage report when it is enabled explicitly and the html coverage reporter is present, otherwise it will not be available:\n\n- enable `coverage.enabled=true` in your configuration or run Vitest with `--coverage.enabled=true` flag\n- add `html` to the `coverage.reporter` list: you can also enable `subdir` option to put coverage report in a subdirectory\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/coverage](https://vitest.dev/guide/coverage)"
- name: coverage *  ​
  id: config/index#coverage
  summary: You can use v8, istanbul or a custom coverage solution for coverage collection
  belongs_to: Configuring Vitest
  description: "### coverage \\* \n\nYou can use [`v8`](https://v8.dev/blog/javascript-code-coverage), [`istanbul`](https://istanbul.js.org/) or [a custom coverage solution](../guide/coverage#custom-coverage-provider) for coverage collection.\n\nYou can provide coverage options to CLI with dot notation:\n\nsh\n\n``` javascript\nnpx vitest --coverage.enabled --coverage.provider=istanbul --coverage.all\n```\n\n**WARNING**\n\nIf you are using coverage options with dot notation, don't forget to specify `--coverage.enabled`. Do not provide a single `--coverage` option in that case.\n\n#### coverage.provider\n\n- **Type:** `'v8' | 'istanbul' | 'custom'`\n- **Default:** `'v8'`\n- **CLI:** `--coverage.provider=<provider>`\n\nUse `provider` to select the tool for coverage collection.\n\n#### coverage.enabled\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.enabled`, `--coverage.enabled=false`\n\nEnables coverage collection. Can be overridden using `--coverage` CLI option.\n\n#### coverage.include\n\n- **Type:** `string[]`\n- **Default:** `['**']`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.include=<path>`, `--coverage.include=<path1> --coverage.include=<path2>`\n\nList of files included in coverage as glob patterns\n\n#### coverage.extension\n\n- **Type:** `string | string[]`\n- **Default:** `['.js', '.cjs', '.mjs', '.ts', '.mts', '.cts', '.tsx', '.jsx', '.vue', '.svelte', '.marko']`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.extension=<extension>`, `--coverage.extension=<extension1> --coverage.extension=<extension2>`\n\n#### coverage.exclude\n\n- **Type:** `string[]`\n- **Default:**\n\njs\n\n``` javascript\n[\n  'coverage/**',\n  'dist/**',\n  '**/node_modules/**',\n  '**/[.]**',\n  'packages/*/test?(s)/**',\n  '**/*.d.ts',\n  '**/virtual:*',\n  '**/__x00__*',\n  '**/\\x00*',\n  'cypress/**',\n  'test?(s)/**',\n  'test?(-*).?(c|m)[jt]s?(x)',\n  '**/*{.,-}{test,spec,bench,benchmark}?(-d).?(c|m)[jt]s?(x)',\n  '**/__tests__/**',\n  '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build,eslint,prettier}.config.*',\n  '**/vitest.{workspace,projects}.[jt]s?(on)',\n  '**/.{eslint,mocha,prettier}rc.{?(c|m)js,yml}',\n]\n```\n\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.exclude=<path>`, `--coverage.exclude=<path1> --coverage.exclude=<path2>`\n\nList of files excluded from coverage as glob patterns.\n\nThis option overrides all default options. Extend the default options when adding new patterns to ignore:\n\nts\n\n``` javascript\nimport { coverageConfigDefaults, defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      exclude: ['**/custom-pattern/**', ...coverageConfigDefaults.exclude]\n    },\n  },\n})\n```\n\n**NOTE**\n\nVitest automatically adds test files `include` patterns to the default value of `coverage.exclude`.\n\n#### coverage.all\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.all`, `--coverage.all=false`\n\nWhether to include all files, including the untested ones into report.\n\n#### coverage.clean\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.clean`, `--coverage.clean=false`\n\nClean coverage results before running tests\n\n#### coverage.cleanOnRerun\n\n- **Type:** `boolean`\n- **Default:** `true`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.cleanOnRerun`, `--coverage.cleanOnRerun=false`\n\nClean coverage report on watch rerun\n\n#### coverage.reportsDirectory\n\n- **Type:** `string`\n- **Default:** `'./coverage'`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.reportsDirectory=<path>`\n\n**WARNING**\n\nVitest will delete this directory before running tests if `coverage.clean` is enabled (default value).\n\nDirectory to write coverage report to.\n\nTo preview the coverage report in the output of [HTML reporter](../guide/reporters#html-reporter), this option must be set as a sub-directory of the html report directory (for example `./html/coverage`).\n\n#### coverage.reporter\n\n- **Type:** `string | string[] | [string, {}][]`\n- **Default:** `['text', 'html', 'clover', 'json']`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.reporter=<reporter>`, `--coverage.reporter=<reporter1> --coverage.reporter=<reporter2>`\n\nCoverage reporters to use. See [istanbul documentation](https://istanbul.js.org/docs/advanced/alternative-reporters/) for detailed list of all reporters. See [`@types/istanbul-reporter`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/276d95e4304b3670eaf6e8e5a7ea9e265a14e338/types/istanbul-reports/index.d.ts) for details about reporter specific options.\n\nThe reporter has three different types:\n\n- A single reporter: `{ reporter: 'html' }`\n- Multiple reporters without options: `{ reporter: ['html', 'json'] }`\n- A single or multiple reporters with reporter options:\n  ts\n  ``` javascript\n  {\n    reporter: [\n      ['lcov', { 'projectRoot': './src' }],\n      ['json', { 'file': 'coverage.json' }],\n      ['text']\n    ]\n  }\n  ```\n\nYou can also pass custom coverage reporters. See [Guide - Custom Coverage Reporter](../guide/coverage#custom-coverage-reporter) for more information.\n\nts\n\n``` javascript\n{\n    reporter: [\n      // Specify reporter using name of the NPM package\n      '@vitest/custom-coverage-reporter',\n      ['@vitest/custom-coverage-reporter', { someOption: true }],\n\n      // Specify reporter using local path\n      '/absolute/path/to/custom-reporter.cjs',\n      ['/absolute/path/to/custom-reporter.cjs', { someOption: true }],\n    ]\n  }\n```\n\nYou can check your coverage report in Vitest UI: check [Vitest UI Coverage](../guide/coverage#vitest-ui) for more details.\n\n#### coverage.reportOnFailure\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.reportOnFailure`, `--coverage.reportOnFailure=false`\n\nGenerate coverage report even when tests fail.\n\n#### coverage.allowExternal\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.allowExternal`, `--coverage.allowExternal=false`\n\nCollect coverage of files outside the [project `root`](#root).\n\n#### coverage.skipFull\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.skipFull`, `--coverage.skipFull=false`\n\nDo not show files with 100% statement, branch, and function coverage.\n\n#### coverage.thresholds\n\nOptions for coverage thresholds\n\n##### coverage.thresholds.lines\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.lines=<number>`\n\nGlobal threshold for lines. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.functions\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.functions=<number>`\n\nGlobal threshold for functions. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.branches\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.branches=<number>`\n\nGlobal threshold for branches. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.statements\n\n- **Type:** `number`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.statements=<number>`\n\nGlobal threshold for statements. See [istanbul documentation](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information.\n\n##### coverage.thresholds.perFile\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.thresholds.perFile`, `--coverage.thresholds.perFile=false`\n\nCheck thresholds per file.\n\n##### coverage.thresholds.autoUpdate\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.thresholds.autoUpdate=<boolean>`\n\nUpdate all threshold values `lines`, `functions`, `branches` and `statements` to configuration file when current coverage is above the configured thresholds. This option helps to maintain thresholds when coverage is improved.\n\n##### coverage.thresholds.100\n\n- **Type:** `boolean`\n- **Default:** `false`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.thresholds.100`, `--coverage.thresholds.100=false`\n\nSets global thresholds to 100. Shortcut for `--coverage.thresholds.lines 100 --coverage.thresholds.functions 100 --coverage.thresholds.branches 100 --coverage.thresholds.statements 100`.\n\n##### coverage.thresholds\\[glob-pattern\\]\n\n- **Type:** `{ statements?: number functions?: number branches?: number lines?: number }`\n- **Default:** `undefined`\n- **Available for providers:** `'v8' | 'istanbul'`\n\nSets thresholds for files matching the glob pattern.\n\nts\n\n``` javascript\n{\n  coverage: {\n    thresholds: {\n      // Thresholds for all files\n      functions: 95,\n      branches: 70,\n\n      // Thresholds for matching glob pattern\n      'src/utils/**.ts': {\n        statements: 95,\n        functions: 90,\n        branches: 85,\n        lines: 80,\n      },\n\n      // Files matching this pattern will only have lines thresholds set.\n      // Global thresholds are not inherited.\n      '**/math.ts': {\n        lines: 100,\n      }\n    }\n  }\n}\n```\n\n#### coverage.ignoreEmptyLines\n\n- **Type:** `boolean`\n- **Default:**`true` (`false` in v1)\n- **Available for providers:** `'v8'`\n- **CLI:** `--coverage.ignoreEmptyLines=<boolean>`\n\nIgnore empty lines, comments and other non-runtime code, e.g. Typescript types.\n\nThis option works only if the used compiler removes comments and other non-runtime code from the transpiled code. By default Vite uses ESBuild which removes comments and Typescript types from `.ts`, `.tsx` and `.jsx` files.\n\nIf you want to apply ESBuild to other files as well, define them in [`esbuild` options](https://vitejs.dev/config/shared-options.html#esbuild):\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  esbuild: {\n    // Transpile all files with ESBuild to remove comments from code coverage.\n    // Required for `test.coverage.ignoreEmptyLines` to work:\n    include: ['**/*.js', '**/*.jsx', '**/*.mjs', '**/*.ts', '**/*.tsx'],\n  },\n  test: {\n    coverage: {\n      provider: 'v8',\n      ignoreEmptyLines: true,\n    },\n  },\n})\n```\n\n#### coverage.ignoreClassMethods\n\n- **Type:** `string[]`\n- **Default:** `[]`\n- **Available for providers:** `'istanbul'`\n- **CLI:** `--coverage.ignoreClassMethods=<method>`\n\nSet to array of class method names to ignore for coverage. See [istanbul documentation](https://github.com/istanbuljs/nyc#ignoring-methods) for more information.\n\n#### coverage.watermarks\n\n- **Type:**\n\nts\n\n``` javascript\n{\n  statements?: [number, number],\n  functions?: [number, number],\n  branches?: [number, number],\n  lines?: [number, number]\n}\n```\n\n- **Default:**\n\nts\n\n``` javascript\n{\n  statements: [50, 80],\n  functions: [50, 80],\n  branches: [50, 80],\n  lines: [50, 80]\n}\n```\n\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:**`--coverage.watermarks.statements=50,80`, `--coverage.watermarks.branches=50,80`\n\nWatermarks for statements, lines, branches and functions. See [istanbul documentation](https://github.com/istanbuljs/nyc#high-and-low-watermarks) for more information.\n\n#### coverage.processingConcurrency\n\n- **Type:** `boolean`\n- **Default:** `Math.min(20, os.availableParallelism?.() ?? os.cpus().length)`\n- **Available for providers:** `'v8' | 'istanbul'`\n- **CLI:** `--coverage.processingConcurrency=<number>`\n\nConcurrency limit used when processing the coverage results.\n\n#### coverage.customProviderModule\n\n- **Type:** `string`\n- **Available for providers:** `'custom'`\n- **CLI:** `--coverage.customProviderModule=<path or module name>`\n\nSpecifies the module name or path for the custom coverage provider module. See [Guide - Custom Coverage Provider](../guide/coverage#custom-coverage-provider) for more information."
- name: 'Coverage: Changing the Default Coverage Folder Location ​'
  id: guide/coverage#changing-the-default-coverage-folder-location
  summary: When running a coverage report, a coverage folder is created in the root directory of your project
  belongs_to: Coverage
  description: |-
    ## Changing the Default Coverage Folder Location

    When running a coverage report, a `coverage` folder is created in the root directory of your project. If you want to move it to a different directory, use the `test.coverage.reportsDirectory` property in the `vite.config.js` file.

    js

    ``` javascript
    import { defineConfig } from 'vite'

    export default defineConfig({
      test: {
        coverage: {
          reportsDirectory: './tests/unit/coverage'
        }
      }
    })
    ```
- name: 'Coverage: Coverage Providers ​'
  id: guide/coverage#coverage-providers
  summary: Both v8 and istanbul support are optional
  belongs_to: Coverage
  description: |-
    ## Coverage Providers

    Both `v8` and `istanbul` support are optional. By default, `v8` will be used.

    You can select the coverage tool by setting `test.coverage.provider` to `v8` or `istanbul`:

    ts

    ``` javascript
    // vitest.config.ts
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        coverage: {
          provider: 'istanbul' // or 'v8'
        },
      },
    })
    ```

    When you start the Vitest process, it will prompt you to install the corresponding support package automatically.

    Or if you prefer to install them manually:

    bash

    ``` javascript
    # For v8
    npm i -D @vitest/coverage-v8

    # For istanbul
    npm i -D @vitest/coverage-istanbul
    ```
- name: 'Coverage: Coverage Setup ​'
  id: guide/coverage#coverage-setup
  summary: It's recommended to always define coverage.include in your configuration file
  belongs_to: Coverage
  description: |-
    ## Coverage Setup

    **TIP**

    It's recommended to always define [`coverage.include`](../config/index#coverage-include) in your configuration file. This helps Vitest to reduce the amount of files picked by [`coverage.all`](../config/index#coverage-all).

    To test with coverage enabled, you can pass the `--coverage` flag in CLI. By default, reporter `['text', 'html', 'clover', 'json']` will be used.

    json

    ``` javascript
    {
      "scripts": {
        "test": "vitest",
        "coverage": "vitest run --coverage"
      }
    }
    ```

    To configure it, set `test.coverage` options in your config file:

    ts

    ``` javascript
    // vitest.config.ts
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        coverage: {
          reporter: ['text', 'json', 'html'],
        },
      },
    })
    ```
- name: 'Coverage: Custom Coverage Provider ​'
  id: guide/coverage#custom-coverage-provider
  summary: The custom providers require a customProviderModule option which is a module name or path where to load the CoverageProviderModule from
  belongs_to: Coverage
  description: |-
    ## Custom Coverage Provider

    It's also possible to provide your custom coverage provider by passing `'custom'` in `test.coverage.provider`:

    ts

    ``` javascript
    // vitest.config.ts
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        coverage: {
          provider: 'custom',
          customProviderModule: 'my-custom-coverage-provider'
        },
      },
    })
    ```

    The custom providers require a `customProviderModule` option which is a module name or path where to load the `CoverageProviderModule` from. It must export an object that implements `CoverageProviderModule` as default export:

    ts

    ``` javascript
    // my-custom-coverage-provider.ts
    import type { CoverageProvider, CoverageProviderModule, ResolvedCoverageOptions, Vitest } from 'vitest'

    const CustomCoverageProviderModule: CoverageProviderModule = {
      getProvider(): CoverageProvider {
        return new CustomCoverageProvider()
      },

      // Implements rest of the CoverageProviderModule ...
    }

    class CustomCoverageProvider implements CoverageProvider {
      name = 'custom-coverage-provider'
      options!: ResolvedCoverageOptions

      initialize(ctx: Vitest) {
        this.options = ctx.config.coverage
      }

      // Implements rest of the CoverageProvider ...
    }

    export default CustomCoverageProviderModule
    ```

    Please refer to the type definition for more details.
- name: 'Coverage: Custom Coverage Reporter ​'
  id: guide/coverage#custom-coverage-reporter
  summary: Custom reporters are loaded by Istanbul and must match its reporter interface
  belongs_to: Coverage
  description: |-
    ## Custom Coverage Reporter

    You can use custom coverage reporters by passing either the name of the package or absolute path in `test.coverage.reporter`:

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        coverage: {
          reporter: [
            // Specify reporter using name of the NPM package
            ['@vitest/custom-coverage-reporter', { someOption: true }],

            // Specify reporter using local path
            '/absolute/path/to/custom-reporter.cjs',
          ],
        },
      },
    })
    ```

    Custom reporters are loaded by Istanbul and must match its reporter interface. See [built-in reporters' implementation](https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib) for reference.

    js

    ``` javascript
    // custom-reporter.cjs
    const { ReportBase } = require('istanbul-lib-report')

    module.exports = class CustomReporter extends ReportBase {
      constructor(opts) {
        super()

        // Options passed from configuration are available here
        this.file = opts.file
      }

      onStart(root, context) {
        this.contentWriter = context.writer.writeFile(this.file)
        this.contentWriter.println('Start of custom coverage report')
      }

      onEnd() {
        this.contentWriter.println('End of custom coverage report')
        this.contentWriter.close()
      }
    }
    ```
- name: 'Coverage: Ignoring Code ​'
  id: guide/coverage#ignoring-code
  summary: When using TypeScript the source codes are transpiled using esbuild, which strips all comments from the source codes (esbuild#516)
  belongs_to: Coverage
  description: |-
    ## Ignoring Code

    Both coverage providers have their own ways how to ignore code from coverage reports:

    - [`v8`](https://github.com/istanbuljs/v8-to-istanbul#ignoring-uncovered-lines)
    - [`ìstanbul`](https://github.com/istanbuljs/nyc#parsing-hints-ignoring-lines)

    When using TypeScript the source codes are transpiled using `esbuild`, which strips all comments from the source codes ([esbuild#516](https://github.com/evanw/esbuild/issues/516)). Comments which are considered as [legal comments](https://esbuild.github.io/api/#legal-comments) are preserved.

    For `istanbul` provider you can include a `@preserve` keyword in the ignore hint. Beware that these ignore hints may now be included in final production build as well.

    diff

    ``` javascript
    -/* istanbul ignore if */
    +/* istanbul ignore if -- @preserve */
    if (condition) {
    ```

    For `v8` this does not cause any issues. You can use `v8 ignore` comments with Typescript as usual:

    ts

    ``` javascript
    /* v8 ignore next 3 */
    if (condition) {
    ```
- name: 'Coverage: Other Options ​'
  id: guide/coverage#other-options
  summary: To see all configurable options for coverage, see the coverage Config Reference
  belongs_to: Coverage
  description: |-
    ## Other Options

    To see all configurable options for coverage, see the [coverage Config Reference](../config/index#coverage).
- name: 'Coverage: Vitest UI ​'
  id: guide/coverage#vitest-ui
  summary: You can check your coverage report in Vitest UI
  belongs_to: Coverage
  description: "## Vitest UI\n\nYou can check your coverage report in [Vitest UI](ui).\n\nVitest UI will enable coverage report when it is enabled explicitly and the html coverage reporter is present, otherwise it will not be available:\n\n- enable `coverage.enabled=true` in your configuration or run Vitest with `--coverage.enabled=true` flag\n- add `html` to the `coverage.reporter` list: you can also enable `subdir` option to put coverage report in a subdirectory\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/coverage](https://vitest.dev/guide/coverage)"
- name: css ​
  id: config/index#css
  summary: Configure if CSS should be processed
  belongs_to: Configuring Vitest
  description: |-
    ### css

    - **Type**: `boolean | { include?, exclude?, modules? }`

    Configure if CSS should be processed. When excluded, CSS files will be replaced with empty strings to bypass the subsequent processing. CSS Modules will return a proxy to not affect runtime.

    #### css.include

    - **Type**: `RegExp | RegExp[]`
    - **Default**: `[]`

    RegExp pattern for files that should return actual CSS and will be processed by Vite pipeline.

    **TIP**

    To process all CSS files, use `/.+/`.

    #### css.exclude

    - **Type**: `RegExp | RegExp[]`
    - **Default**: `[]`

    RegExp pattern for files that will return an empty CSS file.

    #### css.modules

    - **Type**: `{ classNameStrategy? }`
    - **Default**: `{}`

    #### css.modules.classNameStrategy

    - **Type**: `'stable' | 'scoped' | 'non-scoped'`
    - **Default**: `'stable'`

    If you decide to process CSS files, you can configure if class names inside CSS modules should be scoped. You can choose one of the options:

    - `stable`: class names will be generated as `_${name}_${hashedFilename}`, which means that generated class will stay the same, if CSS content is changed, but will change, if the name of the file is modified, or file is moved to another folder. This setting is useful, if you use snapshot feature.
    - `scoped`: class names will be generated as usual, respecting `css.modules.generateScopeName` method, if you have one and CSS processing is enabled. By default, filename will be generated as `_${name}_${hash}`, where hash includes filename and content of the file.
    - `non-scoped`: class names will not be hashed.

    **WARNING**

    By default, Vitest exports a proxy, bypassing CSS Modules processing. If you rely on CSS properties on your classes, you have to enable CSS processing using `include` option.
- name: Custom Pool
  id: advanced/pool
  summary: This is advanced API
  description: "# Custom Pool\n\n**WARNING**\n\nThis is advanced API. If you are just running tests, you probably don't need this. It is primarily used by library authors.\n\nVitest runs tests in pools. By default, there are several pools:\n\n- `threads` to run tests using `node:worker_threads` (isolation is provided with a new worker context)\n- `forks` to run tests using `node:child_process` (isolation is provided with a new `child_process.fork` process)\n- `vmThreads` to run tests using `node:worker_threads` (but isolation is provided with `vm` module instead of a new worker context)\n- `browser` to run tests using browser providers\n- `typescript` to run typechecking on tests\n\nYou can provide your own pool by specifying a file path:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    // will run every file with a custom pool by default\n    pool: './my-custom-pool.ts',\n    // you can provide options using `poolOptions` object\n    poolOptions: {\n      myCustomPool: {\n        customProperty: true,\n      },\n    },\n    // you can also specify pool for a subset of files\n    poolMatchGlobs: [\n      ['**/*.custom.test.ts', './my-custom-pool.ts'],\n    ],\n  },\n})\n```\n\n## API\n\nThe file specified in `pool` option should export a function (can be async) that accepts `Vitest` interface as its first option. This function needs to return an object matching `ProcessPool` interface:\n\nts\n\n``` javascript\nimport { ProcessPool, WorkspaceProject } from 'vitest/node'\n\nexport interface ProcessPool {\n  name: string\n  runTests: (files: [project: WorkspaceProject, testFile: string][], invalidates?: string[]) => Promise<void>\n  collectTests: (files: [project: WorkspaceProject, testFile: string][], invalidates?: string[]) => Promise<void>\n  close?: () => Promise<void>\n}\n```\n\nThe function is called only once (unless the server config was updated), and it's generally a good idea to initialize everything you need for tests inside that function and reuse it when `runTests` is called.\n\nVitest calls `runTest` when new tests are scheduled to run. It will not call it if `files` is empty. The first argument is an array of tuples: the first element is a reference to a workspace project and the second one is an absolute path to a test file. Files are sorted using [`sequencer`](../config/index#sequence-sequencer) before `runTests` is called. It's possible (but unlikely) to have the same file twice, but it will always have a different project - this is implemented via [`vitest.workspace.ts`](../guide/workspace) configuration.\n\nVitest will wait until `runTests` is executed before finishing a run (i.e., it will emit [`onFinished`](../guide/reporters) only after `runTests` is resolved).\n\nIf you are using a custom pool, you will have to provide test files and their results yourself - you can reference [`vitest.state`](https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/node/state.ts) for that (most important are `collectFiles` and `updateTasks`). Vitest uses `startTests` function from `@vitest/runner` package to do that.\n\nVitest will call `collectTests` if `vitest.collect` is called or `vitest list` is invoked via a CLI command. It works the same way as `runTests`, but you don't have to run test callbacks, only report their tasks by calling `vitest.state.collectFiles(files)`.\n\nTo communicate between different processes, you can create methods object using `createMethodsRPC` from `vitest/node`, and use any form of communication that you prefer. For example, to use WebSockets with `birpc` you can write something like this:\n\nts\n\n``` javascript\nimport { createBirpc } from 'birpc'\nimport { parse, stringify } from 'flatted'\nimport { WorkspaceProject, createMethodsRPC } from 'vitest/node'\n\nfunction createRpc(project: WorkspaceProject, wss: WebSocketServer) {\n  return createBirpc(\n    createMethodsRPC(project),\n    {\n      post: msg => wss.send(msg),\n      on: fn => wss.on('message', fn),\n      serialize: stringify,\n      deserialize: parse,\n    },\n  )\n}\n```\n\nTo make sure every test is collected, you would call `ctx.state.collectFiles` and report it to Vitest reporters:\n\nts\n\n``` javascript\nasync function runTests(project: WorkspaceProject, tests: string[]) {\n  // ... running tests, put into \"files\" and \"tasks\"\n  const methods = createMethodsRPC(project)\n  await methods.onCollected(files)\n  // most reporters rely on results being updated in \"onTaskUpdate\"\n  await methods.onTaskUpdate(tasks)\n}\n```\n\nYou can see a simple example in [pool/custom-pool.ts](https://github.com/vitest-dev/vitest/blob/main/test/run/pool-custom-fixtures/pool/custom-pool.ts).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/pool](https://vitest.dev/advanced/pool)"
- name: 'Custom Pool: API ​'
  id: advanced/pool#api
  summary: The file specified in pool option should export a function (can be async) that accepts Vitest interface as its first option
  belongs_to: Custom Pool
  description: "## API\n\nThe file specified in `pool` option should export a function (can be async) that accepts `Vitest` interface as its first option. This function needs to return an object matching `ProcessPool` interface:\n\nts\n\n``` javascript\nimport { ProcessPool, WorkspaceProject } from 'vitest/node'\n\nexport interface ProcessPool {\n  name: string\n  runTests: (files: [project: WorkspaceProject, testFile: string][], invalidates?: string[]) => Promise<void>\n  collectTests: (files: [project: WorkspaceProject, testFile: string][], invalidates?: string[]) => Promise<void>\n  close?: () => Promise<void>\n}\n```\n\nThe function is called only once (unless the server config was updated), and it's generally a good idea to initialize everything you need for tests inside that function and reuse it when `runTests` is called.\n\nVitest calls `runTest` when new tests are scheduled to run. It will not call it if `files` is empty. The first argument is an array of tuples: the first element is a reference to a workspace project and the second one is an absolute path to a test file. Files are sorted using [`sequencer`](../config/index#sequence-sequencer) before `runTests` is called. It's possible (but unlikely) to have the same file twice, but it will always have a different project - this is implemented via [`vitest.workspace.ts`](../guide/workspace) configuration.\n\nVitest will wait until `runTests` is executed before finishing a run (i.e., it will emit [`onFinished`](../guide/reporters) only after `runTests` is resolved).\n\nIf you are using a custom pool, you will have to provide test files and their results yourself - you can reference [`vitest.state`](https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/node/state.ts) for that (most important are `collectFiles` and `updateTasks`). Vitest uses `startTests` function from `@vitest/runner` package to do that.\n\nVitest will call `collectTests` if `vitest.collect` is called or `vitest list` is invoked via a CLI command. It works the same way as `runTests`, but you don't have to run test callbacks, only report their tasks by calling `vitest.state.collectFiles(files)`.\n\nTo communicate between different processes, you can create methods object using `createMethodsRPC` from `vitest/node`, and use any form of communication that you prefer. For example, to use WebSockets with `birpc` you can write something like this:\n\nts\n\n``` javascript\nimport { createBirpc } from 'birpc'\nimport { parse, stringify } from 'flatted'\nimport { WorkspaceProject, createMethodsRPC } from 'vitest/node'\n\nfunction createRpc(project: WorkspaceProject, wss: WebSocketServer) {\n  return createBirpc(\n    createMethodsRPC(project),\n    {\n      post: msg => wss.send(msg),\n      on: fn => wss.on('message', fn),\n      serialize: stringify,\n      deserialize: parse,\n    },\n  )\n}\n```\n\nTo make sure every test is collected, you would call `ctx.state.collectFiles` and report it to Vitest reporters:\n\nts\n\n``` javascript\nasync function runTests(project: WorkspaceProject, tests: string[]) {\n  // ... running tests, put into \"files\" and \"tasks\"\n  const methods = createMethodsRPC(project)\n  await methods.onCollected(files)\n  // most reporters rely on results being updated in \"onTaskUpdate\"\n  await methods.onTaskUpdate(tasks)\n}\n```\n\nYou can see a simple example in [pool/custom-pool.ts](https://github.com/vitest-dev/vitest/blob/main/test/run/pool-custom-fixtures/pool/custom-pool.ts).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/pool](https://vitest.dev/advanced/pool)"
- name: dangerouslyIgnoreUnhandledErrors *  ​
  id: config/index#dangerouslyignoreunhandlederrors
  summary: Ignore any unhandled errors that occur
  belongs_to: Configuring Vitest
  description: "### dangerouslyIgnoreUnhandledErrors \\* \n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI:** `--dangerouslyIgnoreUnhandledErrors` `--dangerouslyIgnoreUnhandledErrors=false`\n\nIgnore any unhandled errors that occur."
- name: Debugging
  id: guide/debugging
  summary: When debugging tests you might want to use --test-timeout CLI argument to prevent tests from timing out when stopping at breakpoints
  description: "# Debugging\n\n**TIP**\n\nWhen debugging tests you might want to use `--test-timeout` CLI argument to prevent tests from timing out when stopping at breakpoints.\n\n## VS Code\n\nQuick way to debug tests in VS Code is via `JavaScript Debug Terminal`. Open a new `JavaScript Debug Terminal` and run `npm run test` or `vitest` directly. *this works with any code ran in Node, so will work with most JS testing frameworks*\n\nYou can also add a dedicated launch configuration to debug a test file in VS Code:\n\njson\n\n``` javascript\n{\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Debug Current Test File\",\n      \"autoAttachChildProcesses\": true,\n      \"skipFiles\": [\"<node_internals>/**\", \"**/node_modules/**\"],\n      \"program\": \"${workspaceRoot}/node_modules/vitest/vitest.mjs\",\n      \"args\": [\"run\", \"${relativeFile}\"],\n      \"smartStep\": true,\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n```\n\nThen in the debug tab, ensure 'Debug Current Test File' is selected. You can then open the test file you want to debug and press F5 to start debugging.\n\n## IntelliJ IDEA\n\nCreate a 'Node.js' run configuration. Use the following settings to run all tests in debug mode:\n\n| Setting                | Value                              |\n|------------------------|------------------------------------|\n| Working directory      | `/path/to/your-project-root`       |\n| JavaScript file        | `./node_modules/vitest/vitest.mjs` |\n| Application parameters | `run --pool forks`                 |\n\nThen run this configuration in debug mode. The IDE will stop at JS/TS breakpoints set in the editor.\n\n## Node Inspector, e.g. Chrome DevTools\n\nVitest also supports debugging tests without IDEs. However this requires that tests are not run parallel. Use one of the following commands to launch Vitest.\n\nsh\n\n``` javascript\n# To run in a single worker\nvitest --inspect-brk --pool threads --poolOptions.threads.singleThread\n\n# To run in a single child process\nvitest --inspect-brk --pool forks --poolOptions.forks.singleFork\n```\n\nIf you are using Vitest 1.1 or higher, you can also just provide `--no-file-parallelism` flag:\n\nsh\n\n``` javascript\n# If pool is unknown\nvitest --inspect-brk --no-file-parallelism\n```\n\nOnce Vitest starts it will stop execution and wait for you to open developer tools that can connect to [Node.js inspector](https://nodejs.org/en/docs/guides/debugging-getting-started/). You can use Chrome DevTools for this by opening `chrome://inspect` on browser.\n\nIn watch mode you can keep the debugger open during test re-runs by using the `--poolOptions.threads.isolate false` options.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/debugging](https://vitest.dev/guide/debugging)"
- name: 'Debugging: IntelliJ IDEA ​'
  id: guide/debugging#intellij-idea
  summary: Create a 'Node.js' run configuration
  belongs_to: Debugging
  description: |-
    ## IntelliJ IDEA

    Create a 'Node.js' run configuration. Use the following settings to run all tests in debug mode:

    | Setting                | Value                              |
    |------------------------|------------------------------------|
    | Working directory      | `/path/to/your-project-root`       |
    | JavaScript file        | `./node_modules/vitest/vitest.mjs` |
    | Application parameters | `run --pool forks`                 |

    Then run this configuration in debug mode. The IDE will stop at JS/TS breakpoints set in the editor.
- name: 'Debugging: Node Inspector, e.g. Chrome DevTools ​'
  id: guide/debugging#node-inspector-e-g-chrome-devtools
  summary: Vitest also supports debugging tests without IDEs
  belongs_to: Debugging
  description: "## Node Inspector, e.g. Chrome DevTools\n\nVitest also supports debugging tests without IDEs. However this requires that tests are not run parallel. Use one of the following commands to launch Vitest.\n\nsh\n\n``` javascript\n# To run in a single worker\nvitest --inspect-brk --pool threads --poolOptions.threads.singleThread\n\n# To run in a single child process\nvitest --inspect-brk --pool forks --poolOptions.forks.singleFork\n```\n\nIf you are using Vitest 1.1 or higher, you can also just provide `--no-file-parallelism` flag:\n\nsh\n\n``` javascript\n# If pool is unknown\nvitest --inspect-brk --no-file-parallelism\n```\n\nOnce Vitest starts it will stop execution and wait for you to open developer tools that can connect to [Node.js inspector](https://nodejs.org/en/docs/guides/debugging-getting-started/). You can use Chrome DevTools for this by opening `chrome://inspect` on browser.\n\nIn watch mode you can keep the debugger open during test re-runs by using the `--poolOptions.threads.isolate false` options.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/debugging](https://vitest.dev/guide/debugging)"
- name: 'Debugging: VS Code ​'
  id: guide/debugging#vs-code
  summary: Quick way to debug tests in VS Code is via JavaScript Debug Terminal
  belongs_to: Debugging
  description: |-
    ## VS Code

    Quick way to debug tests in VS Code is via `JavaScript Debug Terminal`. Open a new `JavaScript Debug Terminal` and run `npm run test` or `vitest` directly. *this works with any code ran in Node, so will work with most JS testing frameworks*

    You can also add a dedicated launch configuration to debug a test file in VS Code:

    json

    ``` javascript
    {
      // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
        {
          "type": "node",
          "request": "launch",
          "name": "Debug Current Test File",
          "autoAttachChildProcesses": true,
          "skipFiles": ["<node_internals>/**", "**/node_modules/**"],
          "program": "${workspaceRoot}/node_modules/vitest/vitest.mjs",
          "args": ["run", "${relativeFile}"],
          "smartStep": true,
          "console": "integratedTerminal"
        }
      ]
    }
    ```

    Then in the debug tab, ensure 'Debug Current Test File' is selected. You can then open the test file you want to debug and press F5 to start debugging.
- name: decreases ​
  id: api/assert#decreases
  summary: Asserts that a modifier decreases a numeric object's property
  belongs_to: assert
  description: |-
    ## decreases

    - **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`

    Asserts that a `modifier` decreases a numeric `object`'s `property`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.decreases', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 5 };
      assert.decreases(fn, obj, 'val')
    })
    ```
- name: decreasesButNotBy ​
  id: api/assert#decreasesbutnotby
  summary: Asserts that a modifier does not decrease a numeric object's property or a modifier return value by a change
  belongs_to: assert
  description: |-
    ## decreasesButNotBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`

    Asserts that a `modifier` does not decrease a numeric `object`'s `property` or a `modifier` return value by a `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.decreasesButNotBy', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 5 };
      assert.decreasesButNotBy(fn, obj, 'val', 1)
    })
    ```
- name: decreasesBy ​
  id: api/assert#decreasesby
  summary: Asserts that a modifier decreases a numeric object's property or a modifier return value by a change
  belongs_to: assert
  description: |-
    ## decreasesBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`

    Asserts that a `modifier` decreases a numeric `object`'s `property` or a `modifier` return value by a `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.decreasesBy', () => {
      const obj = { val: 10 }
      function fn() { obj.val -= 5 };
      assert.decreasesBy(fn, obj, 'val', 5)
    })
    ```
- name: deepEqual ​
  id: api/assert#deepequal
  summary: Asserts that actual is deeply equal to expected
  belongs_to: assert
  description: |-
    ## deepEqual

    - **Type:** `<T>(actual: T, expected: T, message?: string) => void`

    Asserts that `actual` is deeply equal to `expected`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepEqual', () => {
      assert.deepEqual({ color: 'green' }, { color: 'green' })
    })
    ```
- name: deepInclude ​
  id: api/assert#deepinclude
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## deepInclude

    - **Type:**
    - `(haystack: string, needle: string, message?: string) => void`
    - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`
    - `<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array or a subset of properties in an object. Deep equality is used.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const obj1 = { a: 1 }
    const obj2 = { b: 2 }

    test('assert.deepInclude', () => {
      assert.deepInclude([obj1, obj2], { a: 1 })
      assert.deepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 1 } })
    })
    ```
- name: deepNestedInclude ​
  id: api/assert#deepnestedinclude
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## deepNestedInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepNestedInclude', () => {
      assert.deepNestedInclude({ a: { b: [{ x: 1 }] } }, { 'a.b[0]': { x: 1 } })
      assert.deepNestedInclude({ '.a': { '[b]': { x: 1 } } }, { '\\.a.\\[b\\]': { x: 1 } })
    })
    ```
- name: deepNestedPropertyVal ​
  id: api/assert#deepnestedpropertyval
  summary: Asserts that object has a property named by property with a value given by value
  belongs_to: assert
  description: |-
    ## deepNestedPropertyVal

    - **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`

    Asserts that `object` has a property named by `property` with a value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notNestedPropertyVal', () => {
      assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'konacha')
      assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'coffee.green', 'matcha')
    })
    ```
- name: deepOwnInclude ​
  id: api/assert#deepowninclude
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## deepOwnInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep equality.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepOwnInclude', () => {
      assert.deepOwnInclude({ a: { b: 2 } }, { a: { b: 2 } })
    })
    ```
- name: deepPropertyVal ​
  id: api/assert#deeppropertyval
  summary: Asserts that object has a direct or inherited property named by property with a value given by value
  belongs_to: assert
  description: |-
    ## deepPropertyVal

    - **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`

    Asserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepPropertyVal', () => {
      assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' })
    })
    ```
- name: deps ​
  id: config/index#deps
  summary: Handling for dependencies resolution
  belongs_to: Configuring Vitest
  description: |-
    ### deps

    - **Type:** `{ optimizer?, ... }`

    Handling for dependencies resolution.

    #### deps.optimizer

    - **Type:** `{ ssr?, web? }`
    - **See also:** [Dep Optimization Options](https://vitejs.dev/config/dep-optimization-options.html)

    Enable dependency optimization. If you have a lot of tests, this might improve their performance.

    When Vitest encounters the external library listed in `include`, it will be bundled into a single file using esbuild and imported as a whole module. This is good for several reasons:

    - Importing packages with a lot of imports is expensive. By bundling them into one file we can save a lot of time
    - Importing UI libraries is expensive because they are not meant to run inside Node.js
    - Your `alias` configuration is now respected inside bundled packages
    - Code in your tests is running closer to how it's running in the browser

    Be aware that only packages in `deps.optimizer?.[mode].include` option are bundled (some plugins populate this automatically, like Svelte). You can read more about available options in [Vite](https://vitejs.dev/config/dep-optimization-options.html) docs (Vitest doesn't support `disable` and `noDiscovery` options). By default, Vitest uses `optimizer.web` for `jsdom` and `happy-dom` environments, and `optimizer.ssr` for `node` and `edge` environments, but it is configurable by [`transformMode`](#testtransformmode).

    This options also inherits your `optimizeDeps` configuration (for web Vitest will extend `optimizeDeps`, for ssr - `ssr.optimizeDeps`). If you redefine `include`/`exclude` option in `deps.optimizer` it will extend your `optimizeDeps` when running tests. Vitest automatically removes the same options from `include`, if they are listed in `exclude`.

    **TIP**

    You will not be able to edit your `node_modules` code for debugging, since the code is actually located in your `cacheDir` or `test.cache.dir` directory. If you want to debug with `console.log` statements, edit it directly or force rebundling with `deps.optimizer?.[mode].force` option.

    #### deps.optimizer.{mode}.enabled

    - **Type:** `boolean`
    - **Default:** `false`

    Enable dependency optimization.

    #### deps.web

    - **Type:** `{ transformAssets?, ... }`

    Options that are applied to external files when transform mode is set to `web`. By default, `jsdom` and `happy-dom` use `web` mode, while `node` and `edge` environments use `ssr` transform mode, so these options will have no affect on files inside those environments.

    Usually, files inside `node_modules` are externalized, but these options also affect files in [`server.deps.external`](#server-deps-external).

    #### deps.web.transformAssets

    - **Type:** `boolean`
    - **Default:** `true`

    Should Vitest process assets (.png, .svg, .jpg, etc) files and resolve them like Vite does in the browser.

    This module will have a default export equal to the path to the asset, if no query is specified.

    **WARNING**

    At the moment, this option only works with [`vmThreads`](#vmthreads) and [`vmForks`](#vmforks) pools.

    #### deps.web.transformCss

    - **Type:** `boolean`
    - **Default:** `true`

    Should Vitest process CSS (.css, .scss, .sass, etc) files and resolve them like Vite does in the browser.

    If CSS files are disabled with [`css`](#css) options, this option will just silence `ERR_UNKNOWN_FILE_EXTENSION` errors.

    **WARNING**

    At the moment, this option only works with [`vmThreads`](#vmthreads) and [`vmForks`](#vmforks) pools.

    #### deps.web.transformGlobPattern

    - **Type:** `RegExp | RegExp[]`
    - **Default:** `[]`

    Regexp pattern to match external files that should be transformed.

    By default, files inside `node_modules` are externalized and not transformed, unless it's CSS or an asset, and corresponding option is not disabled.

    **WARNING**

    At the moment, this option only works with [`vmThreads`](#vmthreads) and [`vmForks`](#vmforks) pools.

    #### deps.interopDefault

    - **Type:** `boolean`
    - **Default:** `true`

    Interpret CJS module's default as named exports. Some dependencies only bundle CJS modules and don't use named exports that Node.js can statically analyze when a package is imported using `import` syntax instead of `require`. When importing such dependencies in Node environment using named exports, you will see this error:

    ``` javascript
    import { read } from 'fs-jetpack';
             ^^^^
    SyntaxError: Named export 'read' not found. The requested module 'fs-jetpack' is a CommonJS module, which may not support all module.exports as named exports.
    CommonJS modules can always be imported via the default export.
    ```

    Vitest doesn't do static analysis, and cannot fail before your running code, so you will most likely see this error when running tests, if this feature is disabled:

    ``` javascript
    TypeError: createAsyncThunk is not a function
    TypeError: default is not a function
    ```

    By default, Vitest assumes you are using a bundler to bypass this and will not fail, but you can disable this behaviour manually, if you code is not processed.

    #### deps.moduleDirectories

    - **Type:** `string[]`
    - **Default**: `['node_modules']`

    A list of directories that should be treated as module directories. This config option affects the behavior of [`vi.mock`](../api/vi#vi-mock): when no factory is provided and the path of what you are mocking matches one of the `moduleDirectories` values, Vitest will try to resolve the mock by looking for a `__mocks__` folder in the [root](#root) of the project.

    This option will also affect if a file should be treated as a module when externalizing dependencies. By default, Vitest imports external modules with native Node.js bypassing Vite transformation step.

    Setting this option will *override* the default, if you wish to still search `node_modules` for packages include it along with any other options:

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        deps: {
          moduleDirectories: ['node_modules', path.resolve('../../packages')],
        }
      },
    })
    ```
- name: describe ​
  id: api/index#describe
  summary: When you use test or bench in the top level of file, they are collected as part of the implicit suite for it
  belongs_to: Test API Reference
  description: |-
    ## describe

    When you use `test` or `bench` in the top level of file, they are collected as part of the implicit suite for it. Using `describe` you can define a new suite in the current context, as a set of related tests or benchmarks and other nested suites. A suite lets you organize your tests and benchmarks so reports are more clear.

    ts

    ``` javascript
    // basic.spec.ts
    // organizing tests

    import { describe, expect, test } from 'vitest'

    const person = {
      isActive: true,
      age: 32,
    }

    describe('person', () => {
      test('person is defined', () => {
        expect(person).toBeDefined()
      })

      test('is active', () => {
        expect(person.isActive).toBeTruthy()
      })

      test('age limit', () => {
        expect(person.age).toBeLessThanOrEqual(32)
      })
    })
    ```

    ts

    ``` javascript
    // basic.bench.ts
    // organizing benchmarks

    import { bench, describe } from 'vitest'

    describe('sort', () => {
      bench('normal', () => {
        const x = [1, 5, 4, 2, 3]
        x.sort((a, b) => {
          return a - b
        })
      })

      bench('reverse', () => {
        const x = [1, 5, 4, 2, 3]
        x.reverse().sort((a, b) => {
          return a - b
        })
      })
    })
    ```

    You can also nest describe blocks if you have a hierarchy of tests or benchmarks:

    ts

    ``` javascript
    import { describe, expect, test } from 'vitest'

    function numberToCurrency(value: number | string) {
      if (typeof value !== 'number') {
        throw new TypeError('Value must be a number')
      }

      return value.toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
    }

    describe('numberToCurrency', () => {
      describe('given an invalid number', () => {
        test('composed of non-numbers to throw error', () => {
          expect(() => numberToCurrency('abc')).toThrowError()
        })
      })

      describe('given a valid number', () => {
        test('returns the correct currency format', () => {
          expect(numberToCurrency(10000)).toBe('10,000.00')
        })
      })
    })
    ```
- name: describe.concurrent ​
  id: api/index#describe-concurrent
  summary: .skip, .only, and .todo works with concurrent suites
  belongs_to: Test API Reference
  description: |-
    ### describe.concurrent

    - **Alias:** `suite.concurrent`

    `describe.concurrent` runs all inner suites and tests in parallel

    ts

    ``` javascript
    // All suites and tests within this suite will be run in parallel
    describe.concurrent('suite', () => {
      test('concurrent test 1', async () => { /* ... */ })
      describe('concurrent suite 2', async () => {
        test('concurrent test inner 1', async () => { /* ... */ })
        test('concurrent test inner 2', async () => { /* ... */ })
      })
      test.concurrent('concurrent test 3', async () => { /* ... */ })
    })
    ```

    `.skip`, `.only`, and `.todo` works with concurrent suites. All the following combinations are valid:

    ts

    ``` javascript
    describe.concurrent(/* ... */)
    describe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)
    describe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)
    describe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)
    ```

    When running concurrent tests, Snapshots and Assertions must use `expect` from the local [Test Context](../guide/test-context) to ensure the right test is detected.

    ts

    ``` javascript
    describe.concurrent('suite', () => {
      test('concurrent test 1', async ({ expect }) => {
        expect(foo).toMatchSnapshot()
      })
      test('concurrent test 2', async ({ expect }) => {
        expect(foo).toMatchSnapshot()
      })
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: describe.each ​
  id: api/index#describe-each
  summary: Use describe.each if you have more than one test that depends on the same data
  belongs_to: Test API Reference
  description: |-
    ### describe.each

    - **Alias:** `suite.each`

    Use `describe.each` if you have more than one test that depends on the same data.

    ts

    ``` javascript
    describe.each([
      { a: 1, b: 1, expected: 2 },
      { a: 1, b: 2, expected: 3 },
      { a: 2, b: 1, expected: 3 },
    ])('describe object add($a, $b)', ({ a, b, expected }) => {
      test(`returns ${expected}`, () => {
        expect(a + b).toBe(expected)
      })

      test(`returned value not be greater than ${expected}`, () => {
        expect(a + b).not.toBeGreaterThan(expected)
      })

      test(`returned value not be less than ${expected}`, () => {
        expect(a + b).not.toBeLessThan(expected)
      })
    })
    ```

    Starting from Vitest 0.25.3, you can also use template string table.

    - First row should be column names, separated by `|`;
    - One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.

    ts

    ``` javascript
    describe.each`
      a               | b      | expected
      ${1}            | ${1}   | ${2}
      ${'a'}          | ${'b'} | ${'ab'}
      ${[]}           | ${'b'} | ${'b'}
      ${{}}           | ${'b'} | ${'[object Object]b'}
      ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}
    `('describe template string add($a, $b)', ({ a, b, expected }) => {
      test(`returns ${expected}`, () => {
        expect(a + b).toBe(expected)
      })
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: describe.only ​
  id: api/index#describe-only
  summary: Sometimes it is very useful to run only tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output
  belongs_to: Test API Reference
  description: |-
    ### describe.only

    - **Type:** `(name: string | Function, fn: TestFunction, options?: number | TestOptions) => void`

    Use `describe.only` to only run certain suites

    ts

    ``` javascript
    // Only this suite (and others marked with only) are run
    describe.only('suite', () => {
      test('sqrt', () => {
        assert.equal(Math.sqrt(4), 3)
      })
    })

    describe('other suite', () => {
      // ... will be skipped
    })
    ```

    Sometimes it is very useful to run `only` tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.

    In order to do that run `vitest` with specific file containing the tests in question.

    ``` javascript
    # vitest interesting.test.ts
    ```
- name: describe.runIf ​
  id: api/index#describe-runif
  summary: Opposite of describe.skipIf
  belongs_to: Test API Reference
  description: |-
    ### describe.runIf

    - **Alias:** `suite.runIf`

    Opposite of [describe.skipIf](#describe-skipif).

    ts

    ``` javascript
    import { assert, describe, test } from 'vitest'

    const isDev = process.env.NODE_ENV === 'development'

    describe.runIf(isDev)('dev only test suite', () => {
      // this test suite only runs in development
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: describe.sequential ​
  id: api/index#describe-sequential
  summary: describe.sequential in a suite marks every test as sequential
  belongs_to: Test API Reference
  description: |-
    ### describe.sequential

    - **Alias:** `suite.sequential`

    `describe.sequential` in a suite marks every test as sequential. This is useful if you want to run tests in sequence within `describe.concurrent` or with the `--sequence.concurrent` command option.

    ts

    ``` javascript
    describe.concurrent('suite', () => {
      test('concurrent test 1', async () => { /* ... */ })
      test('concurrent test 2', async () => { /* ... */ })

      describe.sequential('', () => {
        test('sequential test 1', async () => { /* ... */ })
        test('sequential test 2', async () => { /* ... */ })
      })
    })
    ```
- name: describe.shuffle ​
  id: api/index#describe-shuffle
  summary: Vitest provides a way to run all tests in random order via CLI flag --sequence.shuffle or config option sequence.shuffle, but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag
  belongs_to: Test API Reference
  description: |-
    ### describe.shuffle

    - **Alias:** `suite.shuffle`

    Vitest provides a way to run all tests in random order via CLI flag [`--sequence.shuffle`](../guide/cli) or config option [`sequence.shuffle`](../config/index#sequence-shuffle), but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag.

    ts

    ``` javascript
    describe.shuffle('suite', () => {
      test('random test 1', async () => { /* ... */ })
      test('random test 2', async () => { /* ... */ })
      test('random test 3', async () => { /* ... */ })
    })
    // order depends on sequence.seed option in config (Date.now() by default)
    ```

    `.skip`, `.only`, and `.todo` works with random suites.

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: describe.skip ​
  id: api/index#describe-skip
  summary: Use describe.skip in a suite to avoid running a particular describe block
  belongs_to: Test API Reference
  description: |-
    ### describe.skip

    - **Alias:** `suite.skip`

    Use `describe.skip` in a suite to avoid running a particular describe block.

    ts

    ``` javascript
    import { assert, describe, test } from 'vitest'

    describe.skip('skipped suite', () => {
      test('sqrt', () => {
        // Suite skipped, no error
        assert.equal(Math.sqrt(4), 3)
      })
    })
    ```
- name: describe.skipIf ​
  id: api/index#describe-skipif
  summary: In some cases, you might run suites multiple times with different environments, and some of the suites might be environment-specific
  belongs_to: Test API Reference
  description: |-
    ### describe.skipIf

    - **Alias:** `suite.skipIf`

    In some cases, you might run suites multiple times with different environments, and some of the suites might be environment-specific. Instead of wrapping the suite with `if`, you can use `describe.skipIf` to skip the suite whenever the condition is truthy.

    ts

    ``` javascript
    import { describe, test } from 'vitest'

    const isDev = process.env.NODE_ENV === 'development'

    describe.skipIf(isDev)('prod only test suite', () => {
      // this test suite only runs in production
    })
    ```

    **WARNING**

    You cannot use this syntax when using Vitest as [type checker](../guide/testing-types).
- name: describe.todo ​
  id: api/index#describe-todo
  summary: Use describe.todo to stub suites to be implemented later
  belongs_to: Test API Reference
  description: |-
    ### describe.todo

    - **Alias:** `suite.todo`

    Use `describe.todo` to stub suites to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.

    ts

    ``` javascript
    // An entry will be shown in the report for this suite
    describe.todo('unimplemented suite')
    ```
- name: diff ​
  id: config/index#diff
  summary: Path to a diff config that will be used to generate diff interface
  belongs_to: Configuring Vitest
  description: |-
    ### diff

    - **Type:** `string`
    - **CLI:** `--diff=<value>`

    Path to a diff config that will be used to generate diff interface. Useful if you want to customize diff display.

    vitest.diff.ts vitest.config.js

    ts

    ``` javascript
    import type { DiffOptions } from 'vitest'
    import c from 'picocolors'

    export default {
      aIndicator: c.bold('--'),
      bIndicator: c.bold('++'),
      omitAnnotationLines: true,
    } satisfies DiffOptions
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        diff: './vitest.diff.ts'
      }
    })
    ```

    #### diff.truncateThreshold

    - **Type**: `number`
    - **Default**: `0`

    The maximum length of diff result to be displayed. Diffs above this threshold will be truncated. Truncation won't take effect with default value 0.

    #### diff.truncateAnnotation

    - **Type**: `string`
    - **Default**: `'... Diff result is truncated'`

    Annotation that is output at the end of diff result if it's truncated.

    #### diff.truncateAnnotationColor

    - **Type**: `DiffOptionsColor = (arg: string) => string`
    - **Default**: `noColor = (string: string): string => string`

    Color of truncate annotation, default is output with no color.
- name: doesNotChange ​
  id: api/assert#doesnotchange
  summary: Asserts that a modifier does not changes the object of a property
  belongs_to: assert
  description: |-
    ## doesNotChange

    - **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`

    Asserts that a `modifier` does not changes the `object` of a `property`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotChange', () => {
      const obj = { val: 10 }
      function fn() { obj.val += 2 };
      assert.doesNotChange(fn, obj, 'val', 2)
    })
    ```
- name: doesNotDecrease ​
  id: api/assert#doesnotdecrease
  summary: Asserts that a modifier dose not decrease a numeric object's property
  belongs_to: assert
  description: |-
    ## doesNotDecrease

    - **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`

    Asserts that a `modifier` dose not decrease a numeric `object`'s `property`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotDecrease', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 15 }
      assert.doesNotDecrease(fn, obj, 'val')
    })
    ```
- name: doesNotDecreaseBy ​
  id: api/assert#doesnotdecreaseby
  summary: Asserts that a modifier does not decrease a numeric object's property or a modifier return value by a change
  belongs_to: assert
  description: |-
    ## doesNotDecreaseBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`

    Asserts that a `modifier` does not decrease a numeric `object`'s `property` or a `modifier` return value by a `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotDecreaseBy', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 5 };
      assert.doesNotDecreaseBy(fn, obj, 'val', 1)
    })
    ```
- name: doesNotHaveAllDeepKeys ​
  id: api/assert#doesnothavealldeepkeys
  summary: Asserts that object does not have at least one of the keys provided
  belongs_to: assert
  description: |-
    ## doesNotHaveAllDeepKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` does not have at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotHaveAllDeepKeys', () => {
      assert.doesNotHaveAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { thisDoesNot: 'exist' })
      assert.doesNotHaveAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ twenty: 'twenty' }, { one: 'one' }])
      assert.doesNotHaveAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { twenty: 'twenty' })
      assert.doesNotHaveAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { fifty: 'fifty' }])
    })
    ```
- name: doesNotHaveAllKeys ​
  id: api/assert#doesnothaveallkeys
  summary: Asserts that object does not have at least one of the keys provided
  belongs_to: assert
  description: |-
    ## doesNotHaveAllKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` does not have at least one of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.hasAnyKeys', () => {
      assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example'])
      assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' })
      assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example'])
      assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ one: 'two' }, 'example'])
    })
    ```
- name: doesNotHaveAnyDeepKeys ​
  id: api/assert#doesnothaveanydeepkeys
  summary: Asserts that object has none of the keys provided
  belongs_to: assert
  description: |-
    ## doesNotHaveAnyDeepKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has none of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotHaveAnyDeepKeys', () => {
      assert.doesNotHaveAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { thisDoesNot: 'exist' })
      assert.doesNotHaveAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ twenty: 'twenty' }, { fifty: 'fifty' }])
      assert.doesNotHaveAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { twenty: 'twenty' })
      assert.doesNotHaveAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ twenty: 'twenty' }, { fifty: 'fifty' }])
    })
    ```
- name: doesNotHaveAnyKeys ​
  id: api/assert#doesnothaveanykeys
  summary: Asserts that object has none of the keys provided
  belongs_to: assert
  description: |-
    ## doesNotHaveAnyKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has none of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotHaveAnyKeys', () => {
      assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['one', 'two', 'example'])
      assert.doesNotHaveAnyKeys({ foo: 1, bar: 2, baz: 3 }, { one: 1, two: 2, example: 'foo' })
      assert.doesNotHaveAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ one: 'two' }, 'example'])
      assert.doesNotHaveAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ one: 'two' }, 'example']))
    })
    ```
- name: doesNotIncrease ​
  id: api/assert#doesnotincrease
  summary: Asserts that a modifier does not increases a numeric object's property
  belongs_to: assert
  description: |-
    ## doesNotIncrease

    - **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`

    Asserts that a `modifier` does not increases a numeric `object`'s `property`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotIncrease', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 8 }
      assert.doesNotIncrease(fn, obj, 'val')
    })
    ```
- name: doesNotThrow ​
  id: api/assert#doesnotthrow
  summary: If errorLike is an Error constructor, asserts that fn will not throw an error that is an instance of errorLike
  belongs_to: assert
  description: |-
    ## doesNotThrow

    - **Type:** `(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string) => void`
    - **Type:** `(fn: () => void, errorLike?: ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string) => void`

    If `errorLike` is an Error constructor, asserts that `fn` will not throw an error that is an instance of `errorLike`. If errorLike is an Error instance, asserts that the error thrown is not the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will not have a message matching `errMsgMatcher`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.doesNotThrow', () => {
      assert.doesNotThrow(fn, 'Any Error thrown must not have this message')
      assert.doesNotThrow(fn, /Any Error thrown must not match this/)
      assert.doesNotThrow(fn, Error)
      assert.doesNotThrow(fn, errorInstance)
      assert.doesNotThrow(fn, Error, 'Error must not have this message')
      assert.doesNotThrow(fn, errorInstance, 'Error must not have this message')
      assert.doesNotThrow(fn, Error, /Error must not match this/)
      assert.doesNotThrow(fn, errorInstance, /Error must not match this/)
    })
    ```
- name: env ​
  id: config/index#env
  summary: Environment variables available on process.env and import.meta.env during tests
  belongs_to: Configuring Vitest
  description: |-
    ### env

    - **Type:** `Partial<NodeJS.ProcessEnv>`

    Environment variables available on `process.env` and `import.meta.env` during tests. These variables will not be available in the main process (in `globalSetup`, for example).
- name: environment ​
  id: config/index#environment
  summary: The environment that will be used for testing
  belongs_to: Configuring Vitest
  description: |-
    ### environment

    - **Type:** `'node' | 'jsdom' | 'happy-dom' | 'edge-runtime' | string`
    - **Default:** `'node'`
    - **CLI:** `--environment=<env>`

    The environment that will be used for testing. The default environment in Vitest is a Node.js environment. If you are building a web application, you can use browser-like environment through either [`jsdom`](https://github.com/jsdom/jsdom) or [`happy-dom`](https://github.com/capricorn86/happy-dom) instead. If you are building edge functions, you can use [`edge-runtime`](https://edge-runtime.vercel.app/packages/vm) environment

    **TIP**

    You can also use [Browser Mode](../guide/browser/index) to run integration or unit tests in the browser without mocking the environment.

    By adding a `@vitest-environment` docblock or comment at the top of the file, you can specify another environment to be used for all tests in that file:

    Docblock style:

    js

    ``` javascript
    /**
     * @vitest-environment jsdom
     */

    test('use jsdom in this test file', () => {
      const element = document.createElement('div')
      expect(element).not.toBeNull()
    })
    ```

    Comment style:

    js

    ``` javascript
    // @vitest-environment happy-dom

    test('use happy-dom in this test file', () => {
      const element = document.createElement('div')
      expect(element).not.toBeNull()
    })
    ```

    For compatibility with Jest, there is also a `@jest-environment`:

    js

    ``` javascript
    /**
     * @jest-environment jsdom
     */

    test('use jsdom in this test file', () => {
      const element = document.createElement('div')
      expect(element).not.toBeNull()
    })
    ```

    If you are running Vitest with [`--isolate=false`](#isolate) flag, your tests will be run in this order: `node`, `jsdom`, `happy-dom`, `edge-runtime`, `custom environments`. Meaning, that every test with the same environment is grouped, but is still running sequentially.

    Starting from 0.23.0, you can also define custom environment. When non-builtin environment is used, Vitest will try to load package `vitest-environment-${name}`. That package should export an object with the shape of `Environment`:

    ts

    ``` javascript
    import type { Environment } from 'vitest'

    export default <Environment>{
      name: 'custom',
      transformMode: 'ssr',
      setup() {
        // custom setup
        return {
          teardown() {
            // called after all tests with this env have been run
          }
        }
      }
    }
    ```

    Vitest also exposes `builtinEnvironments` through `vitest/environments` entry, in case you just want to extend it. You can read more about extending environments in [our guide](../guide/environment).

    **TIP**

    jsdom environment exposes `jsdom` global variable equal to the current [JSDOM](https://github.com/jsdom/jsdom) instance. If you want TypeScript to recognize it, you can add `vitest/jsdom` to your `tsconfig.json` when you use this environment:

    json

    ``` javascript
    {
      "compilerOptions": {
        "types": ["vitest/jsdom"]
      }
    }
    ```
- name: environmentMatchGlobs ​
  id: config/index#environmentmatchglobs
  summary: Automatically assign environment based on globs
  belongs_to: Configuring Vitest
  description: |-
    ### environmentMatchGlobs

    - **Type:** `[string, EnvironmentName][]`
    - **Default:** `[]`

    Automatically assign environment based on globs. The first match will be used.

    For example:

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        environmentMatchGlobs: [
          // all tests in tests/dom will run in jsdom
          ['tests/dom/**', 'jsdom'],
          // all tests in tests/ with .edge.test.ts will run in edge-runtime
          ['**\/*.edge.test.ts', 'edge-runtime'],
          // ...
        ]
      }
    })
    ```
- name: environmentOptions ​
  id: config/index#environmentoptions
  summary: These options are passed down to setup method of current environment
  belongs_to: Configuring Vitest
  description: |-
    ### environmentOptions

    - **Type:** `Record<'jsdom' | string, unknown>`
    - **Default:** `{}`

    These options are passed down to `setup` method of current [`environment`](#environment). By default, you can configure only JSDOM options, if you are using it as your test environment.
- name: equal ​
  id: api/assert#equal
  summary: Asserts non-strict equality (==) of actual and expected
  belongs_to: assert
  description: |-
    ## equal

    - **Type:** `<T>(actual: T, expected: T, message?: string) => void`

    Asserts non-strict equality (==) of `actual` and `expected`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.equal', () => {
      assert.equal(Math.sqrt(4), '2')
    })
    ```
- name: Examples
  id: guide/browser/examples
  summary: Browser Mode is framework agnostic so it doesn't provide any method to render your components
  description: "# Examples\n\nBrowser Mode is framework agnostic so it doesn't provide any method to render your components. However, you should be able to use your framework's test utils packages.\n\nWe recommend using `testing-library` packages depending on your framework:\n\n- [`@testing-library/dom`](https://testing-library.com/docs/dom-testing-library/intro) if you don't use a framework\n- [`@testing-library/vue`](https://testing-library.com/docs/vue-testing-library/intro) to render [vue](https://vuejs.org) components\n- [`@testing-library/svelte`](https://testing-library.com/docs/svelte-testing-library/intro) to render [svelte](https://svelte.dev) components\n- [`@testing-library/react`](https://testing-library.com/docs/react-testing-library/intro) to render [react](https://react.dev) components\n- [`@testing-library/preact`](https://testing-library.com/docs/preact-testing-library/intro) to render [preact](https://preactjs.com) components\n- [`solid-testing-library`](https://testing-library.com/docs/solid-testing-library/intro) to render [solid](https://www.solidjs.com) components\n- [`@marko/testing-library`](https://testing-library.com/docs/marko-testing-library/intro) to render [marko](https://markojs.com) components\n\n**WARNING**\n\n`testing-library` provides a package `@testing-library/user-event`. We do not recommend using it directly because it simulates events instead of actually triggering them - instead, use [`userEvent`](#interactivity-api) imported from `@vitest/browser/context` that uses Chrome DevTools Protocol or Webdriver (depending on the provider) under the hood.\n\nvuesveltereactpreactsolidmarko\n\nts\n\n``` javascript\n// based on @testing-library/vue example\n// https://testing-library.com/docs/vue-testing-library/examples\n\nimport { userEvent } from '@vitest/browser/context'\nimport { render, screen } from '@testing-library/vue'\nimport Component from './Component.vue'\n\ntest('properly handles v-model', async () => {\n  render(Component)\n\n  // Asserts initial state.\n  expect(screen.getByText('Hi, my name is Alice')).toBeInTheDocument()\n\n  // Get the input DOM node by querying the associated label.\n  const usernameInput = await screen.findByLabelText(/username/i)\n\n  // Type the name into the input. This already validates that the input\n  // is filled correctly, no need to check the value manually.\n  await userEvent.fill(usernameInput, 'Bob')\n\n  expect(screen.getByText('Hi, my name is Alice')).toBeInTheDocument()\n})\n```\n\nts\n\n``` javascript\n// based on @testing-library/svelte\n// https://testing-library.com/docs/svelte-testing-library/example\n\nimport { render, screen } from '@testing-library/svelte'\nimport { userEvent } from '@vitest/browser/context'\nimport { expect, test } from 'vitest'\n\nimport Greeter from './greeter.svelte'\n\ntest('greeting appears on click', async () => {\n  const user = userEvent.setup()\n  render(Greeter, { name: 'World' })\n\n  const button = screen.getByRole('button')\n  await user.click(button)\n  const greeting = await screen.findByText(/hello world/iu)\n\n  expect(greeting).toBeInTheDocument()\n})\n```\n\ntsx\n\n``` javascript\n// based on @testing-library/react example\n// https://testing-library.com/docs/react-testing-library/example-intro\n\nimport { userEvent } from '@vitest/browser/context'\nimport { render, screen } from '@testing-library/react'\nimport Fetch from './fetch'\n\ntest('loads and displays greeting', async () => {\n  // Render a React element into the DOM\n  render(<Fetch url=\"/greeting\" />)\n\n  await userEvent.click(screen.getByText('Load Greeting'))\n  // wait before throwing an error if it cannot find an element\n  const heading = await screen.findByRole('heading')\n\n  // assert that the alert message is correct\n  expect(heading).toHaveTextContent('hello there')\n  expect(screen.getByRole('button')).toBeDisabled()\n})\n```\n\ntsx\n\n``` javascript\n// based on @testing-library/preact example\n// https://testing-library.com/docs/preact-testing-library/example\n\nimport { h } from 'preact'\nimport { userEvent } from '@vitest/browser/context'\nimport { render } from '@testing-library/preact'\n\nimport HiddenMessage from '../hidden-message'\n\ntest('shows the children when the checkbox is checked', async () => {\n  const testMessage = 'Test Message'\n\n  const { queryByText, getByLabelText, getByText } = render(\n    <HiddenMessage>{testMessage}</HiddenMessage>,\n  )\n\n  // query* functions will return the element or null if it cannot be found.\n  // get* functions will return the element or throw an error if it cannot be found.\n  expect(queryByText(testMessage)).not.toBeInTheDocument()\n\n  // The queries can accept a regex to make your selectors more\n  // resilient to content tweaks and changes.\n  await userEvent.click(getByLabelText(/show/i))\n\n  expect(getByText(testMessage)).toBeInTheDocument()\n})\n```\n\ntsx\n\n``` javascript\n// baed on @testing-library/solid API\n// https://testing-library.com/docs/solid-testing-library/api\n\nimport { render } from '@testing-library/solid'\n\nit('uses params', async () => {\n  const App = () => (\n    <>\n      <Route\n        path=\"/ids/:id\"\n        component={() => (\n          <p>\n            Id:\n            {useParams()?.id}\n          </p>\n        )}\n      />\n      <Route path=\"/\" component={() => <p>Start</p>} />\n    </>\n  )\n  const { findByText } = render(() => <App />, { location: 'ids/1234' })\n  expect(await findByText('Id: 1234')).toBeInTheDocument()\n})\n```\n\nts\n\n``` javascript\n// baed on @testing-library/marko API\n// https://testing-library.com/docs/marko-testing-library/api\n\nimport { render, screen } from '@marko/testing-library'\nimport Greeting from './greeting.marko'\n\ntest('renders a message', async () => {\n  const { container } = await render(Greeting, { name: 'Marko' })\n  expect(screen.getByText(/Marko/)).toBeInTheDocument()\n  expect(container.firstChild).toMatchInlineSnapshot(`\n    <h1>Hello, Marko!</h1>\n  `)\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/examples](https://vitest.dev/guide/browser/examples)"
- name: exclude ​
  id: api/expect-typeof#exclude
  summary: You can use .exclude to remove types from a union for further testing
  belongs_to: expectTypeOf
  description: |-
    ## exclude

    - **Type:** `ExpectTypeOf<NonExcludedUnion>`

    You can use `.exclude` to remove types from a union for further testing.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    type ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }

    interface CSSProperties { margin?: string; padding?: string }

    function getResponsiveProp<T>(_props: T): ResponsiveProp<T> {
      return {}
    }

    const cssProperties: CSSProperties = { margin: '1px', padding: '2px' }

    expectTypeOf(getResponsiveProp(cssProperties))
      .exclude<unknown[]>()
      .exclude<{ xs?: unknown }>() // or just .exclude<unknown[] | { xs?: unknown }>()
      .toEqualTypeOf<CSSProperties>()
    ```

    **WARNING**

    If no type is found in the union, `.exclude` will return `never`.
- name: exclude ​
  id: config/index#exclude
  summary: A list of glob patterns that should be excluded from your test files
  belongs_to: Configuring Vitest
  description: |-
    ### exclude

    - **Type:** `string[]`
    - **Default:** `['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**', '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*']`
    - **CLI:** `vitest --exclude "**/excluded-file"`

    A list of glob patterns that should be excluded from your test files.

    **WARNING**

    This option does not affect coverage. If you need to remove certain files from the coverage report, use [`coverage.exclude`](#coverage-exclude).

    This is the only option that doesn't override your configuration if you provide it with a CLI flag. All glob patterns added via `--exclude` flag will be added to the config's `exclude`.
- name: exists ​
  id: api/assert#exists
  summary: Asserts that value is neither null nor undefined
  belongs_to: assert
  description: |-
    ## exists

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is neither null nor undefined.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const name = 'foo'

    test('assert.exists', () => {
      assert.exists(name, 'foo is neither null nor undefined')
    })
    ```
- name: expect
  id: api/expect
  summary: expect is used to create assertions
  description: "# expect\n\nThe following types are used in the type signatures below\n\nts\n\n``` javascript\ntype Awaitable<T> = T | PromiseLike<T>\n```\n\n`expect` is used to create assertions. In this context `assertions` are functions that can be called to assert a statement. Vitest provides `chai` assertions by default and also `Jest` compatible assertions build on top of `chai`.\n\nFor example, this code asserts that an `input` value is equal to `2`. If it's not, the assertion will throw an error, and the test will fail.\n\nts\n\n``` javascript\nimport { expect } from 'vitest'\n\nconst input = Math.sqrt(4)\n\nexpect(input).to.equal(2) // chai API\nexpect(input).toBe(2) // jest API\n```\n\nTechnically this example doesn't use [`test`](index#test) function, so in the console you will see Node.js error instead of Vitest output. To learn more about `test`, please read [Test API Reference](index).\n\nAlso, `expect` can be used statically to access matcher functions, described later, and more.\n\n**WARNING**\n\n`expect` has no effect on testing types, if the expression doesn't have a type error. If you want to use Vitest as [type checker](../guide/testing-types), use [`expectTypeOf`](expect-typeof) or [`assertType`](assert-type).\n\n## soft\n\n- **Type:** `ExpectStatic & (actual: any) => Assertions`\n\n`expect.soft` functions similarly to `expect`, but instead of terminating the test execution upon a failed assertion, it continues running and marks the failure as a test failure. All errors encountered during the test will be displayed until the test is completed.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('expect.soft test', () => {\n  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue\n  expect.soft(1 + 2).toBe(4) // mark the test as fail and continue\n})\n// At the end of the test, the above errors will be output.\n```\n\nIt can also be used with `expect`. if `expect` assertion fails, the test will be terminated and all errors will be displayed.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('expect.soft test', () => {\n  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue\n  expect(1 + 2).toBe(4) // failed and terminate the test, all previous errors will be output\n  expect.soft(1 + 3).toBe(5) // do not run\n})\n```\n\n**WARNING**\n\n`expect.soft` can only be used inside the [`test`](index#test) function.\n\n## poll\n\n- **Type:** `ExpectStatic & (actual: () => any, options: { interval, timeout, message }) => Assertions`\n\n`expect.poll` reruns the *assertion* until it is succeeded. You can configure how many times Vitest should rerun the `expect.poll` callback by setting `interval` and `timeout` options.\n\nIf an error is thrown inside the `expect.poll` callback, Vitest will retry again until the timeout runs out.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('element exists', async () => {\n  asyncInjectElement()\n\n  await expect.poll(() => document.querySelector('.element')).toBeTruthy()\n})\n```\n\n**WARNING**\n\n`expect.poll` makes every assertion asynchronous, so do not forget to await it otherwise you might get unhandled promise rejections.\n\n`expect.poll` doesn't work with several matchers:\n\n- Snapshot matchers are not supported because they will always succeed. If your condition is flaky, consider using [`vi.waitFor`](vi#vi-waitfor) instead to resolve it first:\n\nts\n\n``` javascript\nimport { expect, vi } from 'vitest'\n\nconst flakyValue = await vi.waitFor(() => getFlakyValue())\nexpect(flakyValue).toMatchSnapshot()\n```\n\n- `.resolves` and `.rejects` are not supported. `expect.poll` already awaits the condition if it's asynchronous.\n- `toThrow` and its aliases are not supported because the `expect.poll` condition is always resolved before the matcher gets the value\n\n## not\n\nUsing `not` will negate the assertion. For example, this code asserts that an `input` value is not equal to `2`. If it's equal, the assertion will throw an error, and the test will fail.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst input = Math.sqrt(16)\n\nexpect(input).not.to.equal(2) // chai API\nexpect(input).not.toBe(2) // jest API\n```\n\n## toBe\n\n- **Type:** `(value: any) => Awaitable<void>`\n\n`toBe` can be used to assert if primitives are equal or that objects share the same reference. It is equivalent of calling `expect(Object.is(3, 3)).toBe(true)`. If the objects are not the same, but you want to check if their structures are identical, you can use [`toEqual`](#toequal).\n\nFor example, the code below checks if the trader has 13 apples.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst stock = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stock has 13 apples', () => {\n  expect(stock.type).toBe('apples')\n  expect(stock.count).toBe(13)\n})\n\ntest('stocks are the same', () => {\n  const refStock = stock // same reference\n\n  expect(stock).toBe(refStock)\n})\n```\n\nTry not to use `toBe` with floating-point numbers. Since JavaScript rounds them, `0.1 + 0.2` is not strictly `0.3`. To reliably assert floating-point numbers, use [`toBeCloseTo`](#tobecloseto) assertion.\n\n## toBeCloseTo\n\n- **Type:** `(value: number, numDigits?: number) => Awaitable<void>`\n\nUse `toBeCloseTo` to compare floating-point numbers. The optional `numDigits` argument limits the number of digits to check *after* the decimal point. For example:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest.fails('decimals are not equal in javascript', () => {\n  expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004\n})\n\ntest('decimals are rounded to 5 after the point', () => {\n  // 0.2 + 0.1 is 0.30000 | \"000000000004\" removed\n  expect(0.2 + 0.1).toBeCloseTo(0.3, 5)\n  // nothing from 0.30000000000000004 is removed\n  expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)\n})\n```\n\n## toBeDefined\n\n- **Type:** `() => Awaitable<void>`\n\n`toBeDefined` asserts that the value is not equal to `undefined`. Useful use case would be to check if function *returned* anything.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nfunction getApples() {\n  return 3\n}\n\ntest('function returned something', () => {\n  expect(getApples()).toBeDefined()\n})\n```\n\n## toBeUndefined\n\n- **Type:** `() => Awaitable<void>`\n\nOpposite of `toBeDefined`, `toBeUndefined` asserts that the value *is* equal to `undefined`. Useful use case would be to check if function hasn't *returned* anything.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nfunction getApplesFromStock(stock: string) {\n  if (stock === 'Bill') {\n    return 13\n  }\n}\n\ntest('mary doesn\\'t have a stock', () => {\n  expect(getApplesFromStock('Mary')).toBeUndefined()\n})\n```\n\n## toBeTruthy\n\n- **Type:** `() => Awaitable<void>`\n\n`toBeTruthy` asserts that the value is true when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to `true`.\n\nFor example, having this code you don't care for the return value of `stocks.getInfo` - it maybe a complex object, a string, or anything else. The code will still work.\n\nts\n\n``` javascript\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\nstocks.sync('Bill')\nif (stocks.getInfo('Bill')) {\n  stocks.sell('apples', 'Bill')\n}\n```\n\nSo if you want to test that `stocks.getInfo` will be truthy, you could write:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('if we know Bill stock, sell apples to him', () => {\n  stocks.sync('Bill')\n  expect(stocks.getInfo('Bill')).toBeTruthy()\n})\n```\n\nEverything in JavaScript is truthy, except `false`, `null`, `undefined`, `NaN`, `0`, `-0`, `0n`, `\"\"` and `document.all`.\n\n## toBeFalsy\n\n- **Type:** `() => Awaitable<void>`\n\n`toBeFalsy` asserts that the value is false when converted to boolean. Useful if you don't care for the value, but just want to know if it can be converted to `false`.\n\nFor example, having this code you don't care for the return value of `stocks.stockFailed` - it may return any falsy value, but the code will still work.\n\nts\n\n``` javascript\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\nstocks.sync('Bill')\nif (!stocks.stockFailed('Bill')) {\n  stocks.sell('apples', 'Bill')\n}\n```\n\nSo if you want to test that `stocks.stockFailed` will be falsy, you could write:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('if Bill stock hasn\\'t failed, sell apples to him', () => {\n  stocks.syncStocks('Bill')\n  expect(stocks.stockFailed('Bill')).toBeFalsy()\n})\n```\n\nEverything in JavaScript is truthy, except `false`, `null`, `undefined`, `NaN`, `0`, `-0`, `0n`, `\"\"` and `document.all`.\n\n## toBeNull\n\n- **Type:** `() => Awaitable<void>`\n\n`toBeNull` simply asserts if something is `null`. Alias for `.toBe(null)`.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nfunction apples() {\n  return null\n}\n\ntest('we don\\'t have apples', () => {\n  expect(apples()).toBeNull()\n})\n```\n\n## toBeNaN\n\n- **Type:** `() => Awaitable<void>`\n\n`toBeNaN` simply asserts if something is `NaN`. Alias for `.toBe(NaN)`.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nlet i = 0\n\nfunction getApplesCount() {\n  i++\n  return i > 1 ? Number.NaN : i\n}\n\ntest('getApplesCount has some unusual side effects...', () => {\n  expect(getApplesCount()).not.toBeNaN()\n  expect(getApplesCount()).toBeNaN()\n})\n```\n\n## toBeTypeOf\n\n- **Type:** `(c: 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') => Awaitable<void>`\n\n`toBeTypeOf` asserts if an actual value is of type of received type.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst actual = 'stock'\n\ntest('stock is type of string', () => {\n  expect(actual).toBeTypeOf('string')\n})\n```\n\n## toBeInstanceOf\n\n- **Type:** `(c: any) => Awaitable<void>`\n\n`toBeInstanceOf` asserts if an actual value is instance of received class.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('stocks are instance of Stocks', () => {\n  expect(stocks).toBeInstanceOf(Stocks)\n})\n```\n\n## toBeGreaterThan\n\n- **Type:** `(n: number | bigint) => Awaitable<void>`\n\n`toBeGreaterThan` asserts if actual value is greater than received one. Equal values will fail the test.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have more then 10 apples', () => {\n  expect(getApples()).toBeGreaterThan(10)\n})\n```\n\n## toBeGreaterThanOrEqual\n\n- **Type:** `(n: number | bigint) => Awaitable<void>`\n\n`toBeGreaterThanOrEqual` asserts if actual value is greater than received one or equal to it.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or more', () => {\n  expect(getApples()).toBeGreaterThanOrEqual(11)\n})\n```\n\n## toBeLessThan\n\n- **Type:** `(n: number | bigint) => Awaitable<void>`\n\n`toBeLessThan` asserts if actual value is less than received one. Equal values will fail the test.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have less then 20 apples', () => {\n  expect(getApples()).toBeLessThan(20)\n})\n```\n\n## toBeLessThanOrEqual\n\n- **Type:** `(n: number | bigint) => Awaitable<void>`\n\n`toBeLessThanOrEqual` asserts if actual value is less than received one or equal to it.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or less', () => {\n  expect(getApples()).toBeLessThanOrEqual(11)\n})\n```\n\n## toEqual\n\n- **Type:** `(received: any) => Awaitable<void>`\n\n`toEqual` asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively). You can see the difference between `toEqual` and [`toBe`](#tobe) in this example:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst stockBill = {\n  type: 'apples',\n  count: 13,\n}\n\nconst stockMary = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stocks have the same properties', () => {\n  expect(stockBill).toEqual(stockMary)\n})\n\ntest('stocks are not the same', () => {\n  expect(stockBill).not.toBe(stockMary)\n})\n```\n\n**WARNING**\n\nA *deep equality* will not be performed for `Error` objects. Only the `message` property of an Error is considered for equality. To customize equality to check properties other than `message`, use [`expect.addEqualityTesters`](#expect-addequalitytesters). To test if something was thrown, use [`toThrowError`](#tothrowerror) assertion.\n\n## toStrictEqual\n\n- **Type:** `(received: any) => Awaitable<void>`\n\n`toStrictEqual` asserts if the actual value is equal to the received one or has the same structure if it is an object (compares them recursively), and of the same type.\n\nDifferences from [`.toEqual`](#toequal):\n\n- Keys with `undefined` properties are checked. e.g. `{a: undefined, b: 2}` does not match `{b: 2}` when using `.toStrictEqual`.\n- Array sparseness is checked. e.g. `[, 1]` does not match `[undefined, 1]` when using `.toStrictEqual`.\n- Object types are checked to be equal. e.g. A class instance with fields `a` and` b` will not equal a literal object with fields `a` and `b`.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nclass Stock {\n  constructor(type) {\n    this.type = type\n  }\n}\n\ntest('structurally the same, but semantically different', () => {\n  expect(new Stock('apples')).toEqual({ type: 'apples' })\n  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })\n})\n```\n\n## toContain\n\n- **Type:** `(received: string) => Awaitable<void>`\n\n`toContain` asserts if the actual value is in an array. `toContain` can also check whether a string is a substring of another string. Since Vitest 1.0, if you are running tests in a browser-like environment, this assertion can also check if class is contained in a `classList`, or an element is inside another one.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { getAllFruits } from './stocks.js'\n\ntest('the fruit list contains orange', () => {\n  expect(getAllFruits()).toContain('orange')\n\n  const element = document.querySelector('#el')\n  // element has a class\n  expect(element.classList).toContain('flex')\n  // element is inside another one\n  expect(document.querySelector('#wrapper')).toContain(element)\n})\n```\n\n## toContainEqual\n\n- **Type:** `(received: any) => Awaitable<void>`\n\n`toContainEqual` asserts if an item with a specific structure and values is contained in an array. It works like [`toEqual`](#toequal) inside for each element.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { getFruitStock } from './stocks.js'\n\ntest('apple available', () => {\n  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })\n})\n```\n\n## toHaveLength\n\n- **Type:** `(received: number) => Awaitable<void>`\n\n`toHaveLength` asserts if an object has a `.length` property and it is set to a certain numeric value.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('toHaveLength', () => {\n  expect('abc').toHaveLength(3)\n  expect([1, 2, 3]).toHaveLength(3)\n\n  expect('').not.toHaveLength(3) // doesn't have .length of 3\n  expect({ length: 3 }).toHaveLength(3)\n})\n```\n\n## toHaveProperty\n\n- **Type:** `(key: any, received?: any) => Awaitable<void>`\n\n`toHaveProperty` asserts if a property at provided reference `key` exists for an object.\n\nYou can provide an optional value argument also known as deep equality, like the `toEqual` matcher to compare the received property value.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst invoice = {\n  'isActive': true,\n  'P.O': '12345',\n  'customer': {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  'total_amount': 5000,\n  'items': [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\ntest('John Doe Invoice', () => {\n  expect(invoice).toHaveProperty('isActive') // assert that the key exists\n  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal\n\n  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist\n\n  // Deep referencing using dot notation\n  expect(invoice).toHaveProperty('customer.first_name')\n  expect(invoice).toHaveProperty('customer.last_name', 'Doe')\n  expect(invoice).not.toHaveProperty('customer.location', 'India')\n\n  // Deep referencing using an array containing the key\n  expect(invoice).toHaveProperty('items[0].type', 'apples')\n  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works\n\n  // Deep referencing using an array containing the keyPath\n  expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')\n  expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works\n\n  // Wrap your key in an array to avoid the key from being parsed as a deep reference\n  expect(invoice).toHaveProperty(['P.O'], '12345')\n})\n```\n\n## toMatch\n\n- **Type:** `(received: string | regexp) => Awaitable<void>`\n\n`toMatch` asserts if a string matches a regular expression or a string.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('top fruits', () => {\n  expect('top fruits include apple, orange and grape').toMatch(/apple/)\n  expect('applefruits').toMatch('fruit') // toMatch also accepts a string\n})\n```\n\n## toMatchObject\n\n- **Type:** `(received: object | array) => Awaitable<void>`\n\n`toMatchObject` asserts if an object matches a subset of the properties of an object.\n\nYou can also pass an array of objects. This is useful if you want to check that two arrays match in their number of elements, as opposed to `arrayContaining`, which allows for extra elements in the received array.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst johnInvoice = {\n  isActive: true,\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  total_amount: 5000,\n  items: [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\nconst johnDetails = {\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n}\n\ntest('invoice has john personal details', () => {\n  expect(johnInvoice).toMatchObject(johnDetails)\n})\n\ntest('the number of elements must match exactly', () => {\n  // Assert that an array of object matches\n  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([\n    { foo: 'bar' },\n    { baz: 1 },\n  ])\n})\n```\n\n## toThrowError\n\n- **Type:** `(received: any) => Awaitable<void>`\n\n- **Alias:** `toThrow`\n\n`toThrowError` asserts if a function throws an error when it is called.\n\nYou can provide an optional argument to test that a specific error is thrown:\n\n- regular expression: error message matches the pattern\n- string: error message includes the substring\n\n**TIP**\n\nYou must wrap the code in a function, otherwise the error will not be caught, and test will fail.\n\nFor example, if we want to test that `getFruitStock('pineapples')` throws, we could write:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nfunction getFruitStock(type: string) {\n  if (type === 'pineapples') {\n    throw new Error('Pineapples are not in stock')\n  }\n\n  // Do some other stuff\n}\n\ntest('throws on pineapples', () => {\n  // Test that the error message says \"stock\" somewhere: these are equivalent\n  expect(() => getFruitStock('pineapples')).toThrowError(/stock/)\n  expect(() => getFruitStock('pineapples')).toThrowError('stock')\n\n  // Test the exact error message\n  expect(() => getFruitStock('pineapples')).toThrowError(\n    /^Pineapples are not in stock$/,\n  )\n})\n```\n\n**TIP**\n\nTo test async functions, use in combination with [rejects](#rejects).\n\njs\n\n``` javascript\nfunction getAsyncFruitStock() {\n  return Promise.reject(new Error('empty'))\n}\n\ntest('throws on pineapples', async () => {\n  await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')\n})\n```\n\n## toMatchSnapshot\n\n- **Type:** `<T>(shape?: Partial<T> | string, message?: string) => void`\n\nThis ensures that a value matches the most recent snapshot.\n\nYou can provide an optional `hint` string argument that is appended to the test name. Although Vitest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate multiple snapshots in a single it or test block. Vitest sorts snapshots by name in the corresponding `.snap` file.\n\n**TIP**\n\nWhen snapshot mismatch and causing the test failing, if the mismatch is expected, you can press `u` key to update the snapshot for once. Or you can pass `-u` or `--update` CLI options to make Vitest always update the tests.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot()\n})\n```\n\nYou can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot({ foo: expect.any(Set) })\n})\n```\n\n## toMatchInlineSnapshot\n\n- **Type:** `<T>(shape?: Partial<T> | string, snapshot?: string, message?: string) => void`\n\nThis ensures that a value matches the most recent snapshot.\n\nVitest adds and updates the inlineSnapshot string argument to the matcher in the test file (instead of an external `.snap` file).\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('matches inline snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  // Vitest will update following content when updating the snapshot\n  expect(data).toMatchInlineSnapshot(`\n    {\n      \"foo\": Set {\n        \"bar\",\n        \"snapshot\",\n      },\n    }\n  `)\n})\n```\n\nYou can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchInlineSnapshot(\n    { foo: expect.any(Set) },\n    `\n    {\n      \"foo\": Any<Set>,\n    }\n  `\n  )\n})\n```\n\n## toMatchFileSnapshot\n\n- **Type:** `<T>(filepath: string, message?: string) => Promise<void>`\n\nCompare or update the snapshot with the content of a file explicitly specified (instead of the `.snap` file).\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n```\n\nNote that since file system operation is async, you need to use `await` with `toMatchFileSnapshot()`.\n\n## toThrowErrorMatchingSnapshot\n\n- **Type:** `(message?: string) => void`\n\nThe same as [`toMatchSnapshot`](#tomatchsnapshot), but expects the same value as [`toThrowError`](#tothrowerror).\n\n## toThrowErrorMatchingInlineSnapshot\n\n- **Type:** `(snapshot?: string, message?: string) => void`\n\nThe same as [`toMatchInlineSnapshot`](#tomatchinlinesnapshot), but expects the same value as [`toThrowError`](#tothrowerror).\n\n## toHaveBeenCalled\n\n- **Type:** `() => Awaitable<void>`\n\nThis assertion is useful for testing that a function has been called. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  expect(buySpy).not.toHaveBeenCalled()\n\n  market.buy('apples', 10)\n\n  expect(buySpy).toHaveBeenCalled()\n})\n```\n\n## toHaveBeenCalledTimes\n\n- **Type**: `(amount: number) => Awaitable<void>`\n\nThis assertion checks if a function was called a certain amount of times. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function called two times', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledTimes(2)\n})\n```\n\n## toHaveBeenCalledWith\n\n- **Type**: `(...args: any[]) => Awaitable<void>`\n\nThis assertion checks if a function was called at least once with certain parameters. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenCalledWith('apples', 20)\n})\n```\n\n## toHaveBeenLastCalledWith\n\n- **Type**: `(...args: any[]) => Awaitable<void>`\n\nThis assertion checks if a function was called with certain parameters at its last invocation. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)\n})\n```\n\n## toHaveBeenNthCalledWith\n\n- **Type**: `(time: number, ...args: any[]) => Awaitable<void>`\n\nThis assertion checks if a function was called with certain parameters at the certain time. The count starts at 1. So, to check the second entry, you would write `.toHaveBeenNthCalledWith(2, ...)`.\n\nRequires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('first call of spy function called with right params', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)\n})\n```\n\n## toHaveReturned\n\n- **Type**: `() => Awaitable<void>`\n\nThis assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error). Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\nfunction getApplesPrice(amount: number) {\n  const PRICE = 10\n  return amount * PRICE\n}\n\ntest('spy function returned a value', () => {\n  const getPriceSpy = vi.fn(getApplesPrice)\n\n  const price = getPriceSpy(10)\n\n  expect(price).toBe(100)\n  expect(getPriceSpy).toHaveReturned()\n})\n```\n\n## toHaveReturnedTimes\n\n- **Type**: `(amount: number) => Awaitable<void>`\n\nThis assertion checks if a function has successfully returned a value an exact amount of times (i.e., did not throw an error). Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a value two times', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveReturnedTimes(2)\n})\n```\n\n## toHaveReturnedWith\n\n- **Type**: `(returnValue: any) => Awaitable<void>`\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters at least once. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a product', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n\n  expect(sell).toHaveReturnedWith({ product: 'apples' })\n})\n```\n\n## toHaveLastReturnedWith\n\n- **Type**: `(returnValue: any) => Awaitable<void>`\n\nYou can call this assertion to check if a function has successfully returned a certain value when it was last invoked. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on a last call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })\n})\n```\n\n## toHaveNthReturnedWith\n\n- **Type**: `(time: number, returnValue: any) => Awaitable<void>`\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call. Requires a spy function to be passed to `expect`.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on second call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })\n})\n```\n\n## toHaveResolved\n\n- **Type**: `() => Awaitable<void>`\n\nThis assertion checks if a function has successfully resolved a value at least once (i.e., did not reject). Requires a spy function to be passed to `expect`.\n\nIf the function returned a promise, but it was not resolved yet, this will fail.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\nimport db from './db/apples.js'\n\nasync function getApplesPrice(amount: number) {\n  return amount * await db.get('price')\n}\n\ntest('spy function resolved a value', async () => {\n  const getPriceSpy = vi.fn(getApplesPrice)\n\n  const price = await getPriceSpy(10)\n\n  expect(price).toBe(100)\n  expect(getPriceSpy).toHaveResolved()\n})\n```\n\n## toHaveResolvedTimes\n\n- **Type**: `(amount: number) => Awaitable<void>`\n\nThis assertion checks if a function has successfully resolved a value an exact amount of times (i.e., did not reject). Requires a spy function to be passed to `expect`.\n\nThis will only count resolved promises. If the function returned a promise, but it was not resolved yet, it will not be counted.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function resolved a value two times', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n  await sell('bananas')\n\n  expect(sell).toHaveResolvedTimes(2)\n})\n```\n\n## toHaveResolvedWith\n\n- **Type**: `(returnValue: any) => Awaitable<void>`\n\nYou can call this assertion to check if a function has successfully resolved a certain value at least once. Requires a spy function to be passed to `expect`.\n\nIf the function returned a promise, but it was not resolved yet, this will fail.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function resolved a product', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n\n  expect(sell).toHaveResolvedWith({ product: 'apples' })\n})\n```\n\n## toHaveLastResolvedWith\n\n- **Type**: `(returnValue: any) => Awaitable<void>`\n\nYou can call this assertion to check if a function has successfully resolved a certain value when it was last invoked. Requires a spy function to be passed to `expect`.\n\nIf the function returned a promise, but it was not resolved yet, this will fail.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function resolves bananas on a last call', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n  await sell('bananas')\n\n  expect(sell).toHaveLastResolvedWith({ product: 'bananas' })\n})\n```\n\n## toHaveNthResolvedWith\n\n- **Type**: `(time: number, returnValue: any) => Awaitable<void>`\n\nYou can call this assertion to check if a function has successfully resolved a certain value on a specific invokation. Requires a spy function to be passed to `expect`.\n\nIf the function returned a promise, but it was not resolved yet, this will fail.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on second call', async () => {\n  const sell = vi.fn((product: string) => Promise.resolve({ product }))\n\n  await sell('apples')\n  await sell('bananas')\n\n  expect(sell).toHaveNthResolvedWith(2, { product: 'bananas' })\n})\n```\n\n## toSatisfy\n\n- **Type:** `(predicate: (value: any) => boolean) => Awaitable<void>`\n\nThis assertion checks if a value satisfies a certain predicate.\n\nts\n\n``` javascript\nimport { describe, expect, it } from 'vitest'\ndescribe('toSatisfy()', () => {\n  const isOdd = (value: number) => value % 2 !== 0\n\n  it('pass with 0', () => {\n    expect(1).toSatisfy(isOdd)\n  })\n\n  it('pass with negation', () => {\n    expect(2).not.toSatisfy(isOdd)\n  })\n})\n```\n\n## resolves\n\n- **Type:** `Promisify<Assertions>`\n\n`resolves` is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail.\n\nIt returns the same `Assertions` object, but all matchers now return `Promise`, so you would need to `await` it. Also works with `chai` assertions.\n\nFor example, if you have a function, that makes an API call and returns some data, you may use this code to assert its return value:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nasync function buyApples() {\n  return fetch('/buy/apples').then(r => r.json())\n}\n\ntest('buyApples returns new stock id', async () => {\n  // toEqual returns a promise now, so you HAVE to await it\n  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API\n  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API\n})\n```\n\n**WARNING**\n\nIf the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually called, you may use [`expect.assertions(number)`](#expect-assertions).\n\n## rejects\n\n- **Type:** `Promisify<Assertions>`\n\n`rejects` is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap reason why the promise was rejected, and assert its value with usual assertions. If the promise successfully resolves, the assertion will fail.\n\nIt returns the same `Assertions` object, but all matchers now return `Promise`, so you would need to `await` it. Also works with `chai` assertions.\n\nFor example, if you have a function that fails when you call it, you may use this code to assert the reason:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nasync function buyApples(id) {\n  if (!id) {\n    throw new Error('no id')\n  }\n}\n\ntest('buyApples throws an error when no id provided', async () => {\n  // toThrow returns a promise now, so you HAVE to await it\n  await expect(buyApples()).rejects.toThrow('no id')\n})\n```\n\n**WARNING**\n\nIf the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions were actually called, you can use [`expect.assertions(number)`](#expect-assertions).\n\n## expect.assertions\n\n- **Type:** `(count: number) => void`\n\nAfter the test has passed or failed verify that a certain number of assertions was called during a test. A useful case would be to check if an asynchronous code was called.\n\nFor example, if we have a function that asynchronously calls two matchers, we can assert that they were actually called.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nasync function doAsync(...cbs) {\n  await Promise.all(\n    cbs.map((cb, index) => cb({ index })),\n  )\n}\n\ntest('all assertions are called', async () => {\n  expect.assertions(2)\n  function callback1(data) {\n    expect(data).toBeTruthy()\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy()\n  }\n\n  await doAsync(callback1, callback2)\n})\n```\n\n**WARNING**\n\nWhen using `assertions` with async concurrent tests, `expect` from the local [Test Context](../guide/test-context) must be used to ensure the right test is detected.\n\n## expect.hasAssertions\n\n- **Type:** `() => void`\n\nAfter the test has passed or failed verify that at least one assertion was called during a test. A useful case would be to check if an asynchronous code was called.\n\nFor example, if you have a code that calls a callback, we can make an assertion inside a callback, but the test will always pass if we don't check if an assertion was called.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { db } from './db.js'\n\nconst cbs = []\n\nfunction onSelect(cb) {\n  cbs.push(cb)\n}\n\n// after selecting from db, we call all callbacks\nfunction select(id) {\n  return db.select({ id }).then((data) => {\n    return Promise.all(\n      cbs.map(cb => cb(data)),\n    )\n  })\n}\n\ntest('callback was called', async () => {\n  expect.hasAssertions()\n  onSelect((data) => {\n    // should be called on select\n    expect(data).toBeTruthy()\n  })\n  // if not awaited, test will fail\n  // if you don't have expect.hasAssertions(), test will pass\n  await select(3)\n})\n```\n\n## expect.unreachable\n\n- **Type:** `(message?: string) => never`\n\nThis method is used to asserting that a line should never be reached.\n\nFor example, if we want to test that `build()` throws due to receiving directories having no `src` folder, and also handle each error separately, we could do this:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nasync function build(dir) {\n  if (dir.includes('no-src')) {\n    throw new Error(`${dir}/src does not exist`)\n  }\n}\n\nconst errorDirs = [\n  'no-src-folder',\n  // ...\n]\n\ntest.each(errorDirs)('build fails with \"%s\"', async (dir) => {\n  try {\n    await build(dir)\n    expect.unreachable('Should not pass build')\n  }\n  catch (err: any) {\n    expect(err).toBeInstanceOf(Error)\n    expect(err.stack).toContain('build')\n\n    switch (dir) {\n      case 'no-src-folder':\n        expect(err.message).toBe(`${dir}/src does not exist`)\n        break\n      default:\n        // to exhaust all error tests\n        expect.unreachable('All error test must be handled')\n        break\n    }\n  }\n})\n```\n\n## expect.anything\n\n- **Type:** `() => any`\n\nThis asymmetric matcher, when used with equality check, will always return `true`. Useful, if you just want to be sure that the property exist.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('object has \"apples\" key', () => {\n  expect({ apples: 22 }).toEqual({ apples: expect.anything() })\n})\n```\n\n## expect.any\n\n- **Type:** `(constructor: unknown) => any`\n\nThis asymmetric matcher, when used with an equality check, will return `true` only if the value is an instance of a specified constructor. Useful, if you have a value that is generated each time, and you only want to know that it exists with a proper type.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { generateId } from './generators.js'\n\ntest('\"id\" is a number', () => {\n  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })\n})\n```\n\n## expect.closeTo\n\n- **Type:** `(expected: any, precision?: number) => any`\n\n`expect.closeTo` is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use `.toBeCloseTo` instead.\n\nThe optional `numDigits` argument limits the number of digits to check **after** the decimal point. For the default value `2`, the test criterion is `Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2)`.\n\nFor example, this test passes with a precision of 5 digits:\n\njs\n\n``` javascript\ntest('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  })\n})\n```\n\n## expect.arrayContaining\n\n- **Type:** `<T>(expected: T[]) => any`\n\nWhen used with an equality check, this asymmetric matcher will return `true` if the value is an array and contains specified items.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('basket includes fuji', () => {\n  const basket = {\n    varieties: [\n      'Empire',\n      'Fuji',\n      'Gala',\n    ],\n    count: 3\n  }\n  expect(basket).toEqual({\n    count: 3,\n    varieties: expect.arrayContaining(['Fuji'])\n  })\n})\n```\n\n**TIP**\n\nYou can use `expect.not` with this matcher to negate the expected value.\n\n## expect.objectContaining\n\n- **Type:** `(expected: any) => any`\n\nWhen used with an equality check, this asymmetric matcher will return `true` if the value has a similar shape.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('basket has empire apples', () => {\n  const basket = {\n    varieties: [\n      {\n        name: 'Empire',\n        count: 1,\n      }\n    ],\n  }\n  expect(basket).toEqual({\n    varieties: [\n      expect.objectContaining({ name: 'Empire' }),\n    ]\n  })\n})\n```\n\n**TIP**\n\nYou can use `expect.not` with this matcher to negate the expected value.\n\n## expect.stringContaining\n\n- **Type:** `(expected: any) => any`\n\nWhen used with an equality check, this asymmetric matcher will return `true` if the value is a string and contains a specified substring.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('variety has \"Emp\" in its name', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringContaining('Emp'),\n    count: 1,\n  })\n})\n```\n\n**TIP**\n\nYou can use `expect.not` with this matcher to negate the expected value.\n\n## expect.stringMatching\n\n- **Type:** `(expected: any) => any`\n\nWhen used with an equality check, this asymmetric matcher will return `true` if the value is a string and contains a specified substring or if the string matches a regular expression.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('variety ends with \"re\"', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringMatching(/re$/),\n    count: 1,\n  })\n})\n```\n\n**TIP**\n\nYou can use `expect.not` with this matcher to negate the expected value.\n\n## expect.addSnapshotSerializer\n\n- **Type:** `(plugin: PrettyFormatPlugin) => void`\n\nThis method adds custom serializers that are called when creating a snapshot. This is an advanced feature - if you want to know more, please read a [guide on custom serializers](../guide/snapshot#custom-serializer).\n\nIf you are adding custom serializers, you should call this method inside [`setupFiles`](../config/index#setupfiles). This will affect every snapshot.\n\n**TIP**\n\nIf you previously used Vue CLI with Jest, you might want to install [jest-serializer-vue](https://www.npmjs.com/package/jest-serializer-vue). Otherwise, your snapshots will be wrapped in a string, which cases `\"` to be escaped.\n\n## expect.extend\n\n- **Type:** `(matchers: MatchersObject) => void`\n\nYou can extend default matchers with your own. This function is used to extend the matchers object with custom matchers.\n\nWhen you define matchers that way, you also create asymmetric matchers that can be used like `expect.stringContaining`.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('custom matchers', () => {\n  expect.extend({\n    toBeFoo: (received, expected) => {\n      if (received !== 'foo') {\n        return {\n          message: () => `expected ${received} to be foo`,\n          pass: false,\n        }\n      }\n    },\n  })\n\n  expect('foo').toBeFoo()\n  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })\n})\n```\n\n**TIP**\n\nIf you want your matchers to appear in every test, you should call this method inside [`setupFiles`](../config/index#setupfiles).\n\nThis function is compatible with Jest's `expect.extend`, so any library that uses it to create custom matchers will work with Vitest.\n\nIf you are using TypeScript, since Vitest 0.31.0 you can extend default `Assertion` interface in an ambient declaration file (e.g: `vitest.d.ts`) with the code below:\n\nts\n\n``` javascript\ninterface CustomMatchers<R = unknown> {\n  toBeFoo: () => R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n```\n\n**WARNING**\n\nDon't forget to include the ambient declaration file in your `tsconfig.json`.\n\n**TIP**\n\nIf you want to know more, checkout [guide on extending matchers](../guide/extending-matchers).\n\n## expect.addEqualityTesters\n\n- **Type:** `(tester: Array<Tester>) => void`\n\nYou can use this method to define custom testers, which are methods used by matchers, to test if two objects are equal. It is compatible with Jest's `expect.addEqualityTesters`.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nclass AnagramComparator {\n  public word: string\n\n  constructor(word: string) {\n    this.word = word\n  }\n\n  equals(other: AnagramComparator): boolean {\n    const cleanStr1 = this.word.replace(/ /g, '').toLowerCase()\n    const cleanStr2 = other.word.replace(/ /g, '').toLowerCase()\n\n    const sortedStr1 = cleanStr1.split('').sort().join('')\n    const sortedStr2 = cleanStr2.split('').sort().join('')\n\n    return sortedStr1 === sortedStr2\n  }\n}\n\nfunction isAnagramComparator(a: unknown): a is AnagramComparator {\n  return a instanceof AnagramComparator\n}\n\nfunction areAnagramsEqual(a: unknown, b: unknown): boolean | undefined {\n  const isAAnagramComparator = isAnagramComparator(a)\n  const isBAnagramComparator = isAnagramComparator(b)\n\n  if (isAAnagramComparator && isBAnagramComparator) {\n    return a.equals(b)\n  }\n  else if (isAAnagramComparator === isBAnagramComparator) {\n    return undefined\n  }\n  else {\n    return false\n  }\n}\n\nexpect.addEqualityTesters([areAnagramsEqual])\n\ntest('custom equality tester', () => {\n  expect(new AnagramComparator('listen')).toEqual(new AnagramComparator('silent'))\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/expect](https://vitest.dev/api/expect)"
- name: expect ​
  id: config/index#expect
  summary: The same as calling expect.hasAssertions() at the start of every test
  belongs_to: Configuring Vitest
  description: |-
    ### expect

    - **Type:** `ExpectOptions`

    #### expect.requireAssertions

    - **Type:** `boolean`
    - **Default:** `false`

    The same as calling [`expect.hasAssertions()`](../api/expect#expect-hasassertions) at the start of every test. This makes sure that no test will pass accidentally.

    **TIP**

    This only works with Vitest's `expect`. If you use `assert` ot `.should` assertions, they will not count, and your test will fail due to the lack of expect assertions.

    You can change the value of this by calling `vi.setConfig({ expect: { requireAssertions: false } })`. The config will be applied to every subsequent `expect` call until the `vi.resetConfig` is called manually.

    #### expect.poll

    Global configuration options for [`expect.poll`](../api/expect#poll). These are the same options you can pass down to `expect.poll(condition, options)`.

    ##### expect.poll.interval

    - **Type:** `number`
    - **Default:** `50`

    Polling interval in milliseconds

    ##### expect.poll.timeout

    - **Type:** `number`
    - **Default:** `1000`

    Polling timeout in milliseconds
- name: expect.addEqualityTesters ​
  id: api/expect#expect-addequalitytesters
  summary: You can use this method to define custom testers, which are methods used by matchers, to test if two objects are equal
  belongs_to: expect
  description: "## expect.addEqualityTesters\n\n- **Type:** `(tester: Array<Tester>) => void`\n\nYou can use this method to define custom testers, which are methods used by matchers, to test if two objects are equal. It is compatible with Jest's `expect.addEqualityTesters`.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nclass AnagramComparator {\n  public word: string\n\n  constructor(word: string) {\n    this.word = word\n  }\n\n  equals(other: AnagramComparator): boolean {\n    const cleanStr1 = this.word.replace(/ /g, '').toLowerCase()\n    const cleanStr2 = other.word.replace(/ /g, '').toLowerCase()\n\n    const sortedStr1 = cleanStr1.split('').sort().join('')\n    const sortedStr2 = cleanStr2.split('').sort().join('')\n\n    return sortedStr1 === sortedStr2\n  }\n}\n\nfunction isAnagramComparator(a: unknown): a is AnagramComparator {\n  return a instanceof AnagramComparator\n}\n\nfunction areAnagramsEqual(a: unknown, b: unknown): boolean | undefined {\n  const isAAnagramComparator = isAnagramComparator(a)\n  const isBAnagramComparator = isAnagramComparator(b)\n\n  if (isAAnagramComparator && isBAnagramComparator) {\n    return a.equals(b)\n  }\n  else if (isAAnagramComparator === isBAnagramComparator) {\n    return undefined\n  }\n  else {\n    return false\n  }\n}\n\nexpect.addEqualityTesters([areAnagramsEqual])\n\ntest('custom equality tester', () => {\n  expect(new AnagramComparator('listen')).toEqual(new AnagramComparator('silent'))\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/expect](https://vitest.dev/api/expect)"
- name: expect.addSnapshotSerializer ​
  id: api/expect#expect-addsnapshotserializer
  summary: This method adds custom serializers that are called when creating a snapshot
  belongs_to: expect
  description: |-
    ## expect.addSnapshotSerializer

    - **Type:** `(plugin: PrettyFormatPlugin) => void`

    This method adds custom serializers that are called when creating a snapshot. This is an advanced feature - if you want to know more, please read a [guide on custom serializers](../guide/snapshot#custom-serializer).

    If you are adding custom serializers, you should call this method inside [`setupFiles`](../config/index#setupfiles). This will affect every snapshot.

    **TIP**

    If you previously used Vue CLI with Jest, you might want to install [jest-serializer-vue](https://www.npmjs.com/package/jest-serializer-vue). Otherwise, your snapshots will be wrapped in a string, which cases `"` to be escaped.
- name: expect.any ​
  id: api/expect#expect-any
  summary: This asymmetric matcher, when used with an equality check, will return true only if the value is an instance of a specified constructor
  belongs_to: expect
  description: |-
    ## expect.any

    - **Type:** `(constructor: unknown) => any`

    This asymmetric matcher, when used with an equality check, will return `true` only if the value is an instance of a specified constructor. Useful, if you have a value that is generated each time, and you only want to know that it exists with a proper type.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { generateId } from './generators.js'

    test('"id" is a number', () => {
      expect({ id: generateId() }).toEqual({ id: expect.any(Number) })
    })
    ```
- name: expect.anything ​
  id: api/expect#expect-anything
  summary: This asymmetric matcher, when used with equality check, will always return true
  belongs_to: expect
  description: |-
    ## expect.anything

    - **Type:** `() => any`

    This asymmetric matcher, when used with equality check, will always return `true`. Useful, if you just want to be sure that the property exist.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('object has "apples" key', () => {
      expect({ apples: 22 }).toEqual({ apples: expect.anything() })
    })
    ```
- name: expect.arrayContaining ​
  id: api/expect#expect-arraycontaining
  summary: When used with an equality check, this asymmetric matcher will return true if the value is an array and contains specified items
  belongs_to: expect
  description: |-
    ## expect.arrayContaining

    - **Type:** `<T>(expected: T[]) => any`

    When used with an equality check, this asymmetric matcher will return `true` if the value is an array and contains specified items.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('basket includes fuji', () => {
      const basket = {
        varieties: [
          'Empire',
          'Fuji',
          'Gala',
        ],
        count: 3
      }
      expect(basket).toEqual({
        count: 3,
        varieties: expect.arrayContaining(['Fuji'])
      })
    })
    ```

    **TIP**

    You can use `expect.not` with this matcher to negate the expected value.
- name: expect.assertions ​
  id: api/expect#expect-assertions
  summary: After the test has passed or failed verify that a certain number of assertions was called during a test
  belongs_to: expect
  description: |-
    ## expect.assertions

    - **Type:** `(count: number) => void`

    After the test has passed or failed verify that a certain number of assertions was called during a test. A useful case would be to check if an asynchronous code was called.

    For example, if we have a function that asynchronously calls two matchers, we can assert that they were actually called.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    async function doAsync(...cbs) {
      await Promise.all(
        cbs.map((cb, index) => cb({ index })),
      )
    }

    test('all assertions are called', async () => {
      expect.assertions(2)
      function callback1(data) {
        expect(data).toBeTruthy()
      }
      function callback2(data) {
        expect(data).toBeTruthy()
      }

      await doAsync(callback1, callback2)
    })
    ```

    **WARNING**

    When using `assertions` with async concurrent tests, `expect` from the local [Test Context](../guide/test-context) must be used to ensure the right test is detected.
- name: expect.closeTo ​
  id: api/expect#expect-closeto
  summary: expect.closeTo is useful when comparing floating point numbers in object properties or array item
  belongs_to: expect
  description: |-
    ## expect.closeTo

    - **Type:** `(expected: any, precision?: number) => any`

    `expect.closeTo` is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use `.toBeCloseTo` instead.

    The optional `numDigits` argument limits the number of digits to check **after** the decimal point. For the default value `2`, the test criterion is `Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2)`.

    For example, this test passes with a precision of 5 digits:

    js

    ``` javascript
    test('compare float in object properties', () => {
      expect({
        title: '0.1 + 0.2',
        sum: 0.1 + 0.2,
      }).toEqual({
        title: '0.1 + 0.2',
        sum: expect.closeTo(0.3, 5),
      })
    })
    ```
- name: expect.extend ​
  id: api/expect#expect-extend
  summary: You can extend default matchers with your own
  belongs_to: expect
  description: |-
    ## expect.extend

    - **Type:** `(matchers: MatchersObject) => void`

    You can extend default matchers with your own. This function is used to extend the matchers object with custom matchers.

    When you define matchers that way, you also create asymmetric matchers that can be used like `expect.stringContaining`.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('custom matchers', () => {
      expect.extend({
        toBeFoo: (received, expected) => {
          if (received !== 'foo') {
            return {
              message: () => `expected ${received} to be foo`,
              pass: false,
            }
          }
        },
      })

      expect('foo').toBeFoo()
      expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })
    })
    ```

    **TIP**

    If you want your matchers to appear in every test, you should call this method inside [`setupFiles`](../config/index#setupfiles).

    This function is compatible with Jest's `expect.extend`, so any library that uses it to create custom matchers will work with Vitest.

    If you are using TypeScript, since Vitest 0.31.0 you can extend default `Assertion` interface in an ambient declaration file (e.g: `vitest.d.ts`) with the code below:

    ts

    ``` javascript
    interface CustomMatchers<R = unknown> {
      toBeFoo: () => R
    }

    declare module 'vitest' {
      interface Assertion<T = any> extends CustomMatchers<T> {}
      interface AsymmetricMatchersContaining extends CustomMatchers {}
    }
    ```

    **WARNING**

    Don't forget to include the ambient declaration file in your `tsconfig.json`.

    **TIP**

    If you want to know more, checkout [guide on extending matchers](../guide/extending-matchers).
- name: expect.hasAssertions ​
  id: api/expect#expect-hasassertions
  summary: After the test has passed or failed verify that at least one assertion was called during a test
  belongs_to: expect
  description: |-
    ## expect.hasAssertions

    - **Type:** `() => void`

    After the test has passed or failed verify that at least one assertion was called during a test. A useful case would be to check if an asynchronous code was called.

    For example, if you have a code that calls a callback, we can make an assertion inside a callback, but the test will always pass if we don't check if an assertion was called.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { db } from './db.js'

    const cbs = []

    function onSelect(cb) {
      cbs.push(cb)
    }

    // after selecting from db, we call all callbacks
    function select(id) {
      return db.select({ id }).then((data) => {
        return Promise.all(
          cbs.map(cb => cb(data)),
        )
      })
    }

    test('callback was called', async () => {
      expect.hasAssertions()
      onSelect((data) => {
        // should be called on select
        expect(data).toBeTruthy()
      })
      // if not awaited, test will fail
      // if you don't have expect.hasAssertions(), test will pass
      await select(3)
    })
    ```
- name: expect.objectContaining ​
  id: api/expect#expect-objectcontaining
  summary: When used with an equality check, this asymmetric matcher will return true if the value has a similar shape
  belongs_to: expect
  description: |-
    ## expect.objectContaining

    - **Type:** `(expected: any) => any`

    When used with an equality check, this asymmetric matcher will return `true` if the value has a similar shape.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('basket has empire apples', () => {
      const basket = {
        varieties: [
          {
            name: 'Empire',
            count: 1,
          }
        ],
      }
      expect(basket).toEqual({
        varieties: [
          expect.objectContaining({ name: 'Empire' }),
        ]
      })
    })
    ```

    **TIP**

    You can use `expect.not` with this matcher to negate the expected value.
- name: expect.stringContaining ​
  id: api/expect#expect-stringcontaining
  summary: When used with an equality check, this asymmetric matcher will return true if the value is a string and contains a specified substring
  belongs_to: expect
  description: |-
    ## expect.stringContaining

    - **Type:** `(expected: any) => any`

    When used with an equality check, this asymmetric matcher will return `true` if the value is a string and contains a specified substring.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('variety has "Emp" in its name', () => {
      const variety = {
        name: 'Empire',
        count: 1,
      }
      expect(variety).toEqual({
        name: expect.stringContaining('Emp'),
        count: 1,
      })
    })
    ```

    **TIP**

    You can use `expect.not` with this matcher to negate the expected value.
- name: expect.stringMatching ​
  id: api/expect#expect-stringmatching
  summary: When used with an equality check, this asymmetric matcher will return true if the value is a string and contains a specified substring or if the string matches a regular expression
  belongs_to: expect
  description: |-
    ## expect.stringMatching

    - **Type:** `(expected: any) => any`

    When used with an equality check, this asymmetric matcher will return `true` if the value is a string and contains a specified substring or if the string matches a regular expression.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('variety ends with "re"', () => {
      const variety = {
        name: 'Empire',
        count: 1,
      }
      expect(variety).toEqual({
        name: expect.stringMatching(/re$/),
        count: 1,
      })
    })
    ```

    **TIP**

    You can use `expect.not` with this matcher to negate the expected value.
- name: expect.unreachable ​
  id: api/expect#expect-unreachable
  summary: This method is used to asserting that a line should never be reached
  belongs_to: expect
  description: |-
    ## expect.unreachable

    - **Type:** `(message?: string) => never`

    This method is used to asserting that a line should never be reached.

    For example, if we want to test that `build()` throws due to receiving directories having no `src` folder, and also handle each error separately, we could do this:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    async function build(dir) {
      if (dir.includes('no-src')) {
        throw new Error(`${dir}/src does not exist`)
      }
    }

    const errorDirs = [
      'no-src-folder',
      // ...
    ]

    test.each(errorDirs)('build fails with "%s"', async (dir) => {
      try {
        await build(dir)
        expect.unreachable('Should not pass build')
      }
      catch (err: any) {
        expect(err).toBeInstanceOf(Error)
        expect(err.stack).toContain('build')

        switch (dir) {
          case 'no-src-folder':
            expect(err.message).toBe(`${dir}/src does not exist`)
            break
          default:
            // to exhaust all error tests
            expect.unreachable('All error test must be handled')
            break
        }
      }
    })
    ```
- name: expectTypeOf
  id: api/expect-typeof
  summary: During runtime this function doesn't do anything
  description: "# expectTypeOf\n\n**WARNING**\n\nDuring runtime this function doesn't do anything. To [enable typechecking](../guide/testing-types#run-typechecking), don't forget to pass down `--typecheck` flag.\n\n- **Type:** `<T>(a: unknown) => ExpectTypeOf`\n\n## not\n\n- **Type:** `ExpectTypeOf`\n\nYou can negate all assertions, using `.not` property.\n\n## toEqualTypeOf\n\n- **Type:** `<T>(expected: T) => void`\n\nThis matcher will check if the types are fully equal to each other. This matcher will not fail if two objects have different values, but the same type. It will fail however if an object is missing a property.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })\nexpectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()\n```\n\n## toMatchTypeOf\n\n- **Type:** `<T>(expected: T) => void`\n\nThis matcher checks if expect type extends provided type. It is different from `toEqual` and is more similar to [expect's](expect) `toMatchObject()`. With this matcher, you can check if an object “matches” a type.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1, b: 1 }).toMatchTypeOf({ a: 1 })\nexpectTypeOf<number>().toMatchTypeOf<string | number>()\nexpectTypeOf<string | number>().not.toMatchTypeOf<number>()\n```\n\n## extract\n\n- **Type:** `ExpectTypeOf<ExtractedUnion>`\n\nYou can use `.extract` to narrow down types for further testing.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<{ xs?: any }>() // extracts the last type from a union\n  .toEqualTypeOf<{ xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties }>()\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<unknown[]>() // extracts an array from a union\n  .toEqualTypeOf<CSSProperties[]>()\n```\n\n**WARNING**\n\nIf no type is found in the union, `.extract` will return `never`.\n\n## exclude\n\n- **Type:** `ExpectTypeOf<NonExcludedUnion>`\n\nYou can use `.exclude` to remove types from a union for further testing.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .exclude<unknown[]>()\n  .exclude<{ xs?: unknown }>() // or just .exclude<unknown[] | { xs?: unknown }>()\n  .toEqualTypeOf<CSSProperties>()\n```\n\n**WARNING**\n\nIf no type is found in the union, `.exclude` will return `never`.\n\n## returns\n\n- **Type:** `ExpectTypeOf<ReturnValue>`\n\nYou can use `.returns` to extract return value of a function type.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n## parameters\n\n- **Type:** `ExpectTypeOf<Parameters>`\n\nYou can extract function arguments with `.parameters` to perform assertions on its value. Parameters are returned as an array.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()\nexpectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n**TIP**\n\nYou can also use [`.toBeCallableWith`](#tobecallablewith) matcher as a more expressive assertion.\n\n## parameter\n\n- **Type:** `(nth: number) => ExpectTypeOf`\n\nYou can extract a certain function argument with `.parameter(number)` call to perform other assertions on it.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nfunction foo(a: number, b: string) {\n  return [a, b]\n}\n\nexpectTypeOf(foo).parameter(0).toBeNumber()\nexpectTypeOf(foo).parameter(1).toBeString()\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n## constructorParameters\n\n- **Type:** `ExpectTypeOf<ConstructorParameters>`\n\nYou can extract constructor parameters as an array of values and perform assertions on them with this method.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).constructorParameters.toEqualTypeOf<[] | [string | number | Date]>()\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n**TIP**\n\nYou can also use [`.toBeConstructibleWith`](#tobeconstructiblewith) matcher as a more expressive assertion.\n\n## instance\n\n- **Type:** `ExpectTypeOf<ConstructableInstance>`\n\nThis property gives access to matchers that can be performed on an instance of the provided class.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).instance.toHaveProperty('toISOString')\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n## items\n\n- **Type:** `ExpectTypeOf<T>`\n\nYou can get array item type with `.items` to perform further assertions.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf([1, 2, 3]).items.toEqualTypeOf<number>()\nexpectTypeOf([1, 2, 3]).items.not.toEqualTypeOf<string>()\n```\n\n## resolves\n\n- **Type:** `ExpectTypeOf<ResolvedPromise>`\n\nThis matcher extracts resolved value of a `Promise`, so you can perform other assertions on it.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nasync function asyncFunc() {\n  return 123\n}\n\nexpectTypeOf(asyncFunc).returns.resolves.toBeNumber()\nexpectTypeOf(Promise.resolve('string')).resolves.toBeString()\n```\n\n**WARNING**\n\nIf used on a non-promise type, it will return `never`, so you won't be able to chain it with other matchers.\n\n## guards\n\n- **Type:** `ExpectTypeOf<Guard>`\n\nThis matcher extracts guard value (e.g., `v is number`), so you can perform assertions on it.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nfunction isString(v: any): v is string {\n  return typeof v === 'string'\n}\nexpectTypeOf(isString).guards.toBeString()\n```\n\n**WARNING**\n\nReturns `never`, if the value is not a guard function, so you won't be able to chain it with other matchers.\n\n## asserts\n\n- **Type:** `ExpectTypeOf<Assert>`\n\nThis matcher extracts assert value (e.g., `assert v is number`), so you can perform assertions on it.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nfunction assertNumber(v: any): asserts v is number {\n  if (typeof v !== 'number') {\n    throw new TypeError('Nope !')\n  }\n}\n\nexpectTypeOf(assertNumber).asserts.toBeNumber()\n```\n\n**WARNING**\n\nReturns `never`, if the value is not an assert function, so you won't be able to chain it with other matchers.\n\n## toBeAny\n\n- **Type:** `() => void`\n\nWith this matcher you can check, if provided type is `any` type. If the type is too specific, the test will fail.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<any>().toBeAny()\nexpectTypeOf({} as any).toBeAny()\nexpectTypeOf('string').not.toBeAny()\n```\n\n## toBeUnknown\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is `unknown` type.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf().toBeUnknown()\nexpectTypeOf({} as unknown).toBeUnknown()\nexpectTypeOf('string').not.toBeUnknown()\n```\n\n## toBeNever\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is a `never` type.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<never>().toBeNever()\nexpectTypeOf((): never => {}).returns.toBeNever()\n```\n\n## toBeFunction\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is a `function`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeFunction()\nexpectTypeOf((): never => {}).toBeFunction()\n```\n\n## toBeObject\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is an `object`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeObject()\nexpectTypeOf({}).toBeObject()\n```\n\n## toBeArray\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is `Array<T>`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeArray()\nexpectTypeOf([]).toBeArray()\nexpectTypeOf([1, 2]).toBeArray()\nexpectTypeOf([{}, 42]).toBeArray()\n```\n\n## toBeString\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is a `string`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeString()\nexpectTypeOf('').toBeString()\nexpectTypeOf('a').toBeString()\n```\n\n## toBeBoolean\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is `boolean`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeBoolean()\nexpectTypeOf(true).toBeBoolean()\nexpectTypeOf<boolean>().toBeBoolean()\n```\n\n## toBeVoid\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is `void`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf<void>().toBeVoid()\n```\n\n## toBeSymbol\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is a `symbol`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Symbol(1)).toBeSymbol()\nexpectTypeOf<symbol>().toBeSymbol()\n```\n\n## toBeNull\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is `null`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(null).toBeNull()\nexpectTypeOf<null>().toBeNull()\nexpectTypeOf(undefined).not.toBeNull()\n```\n\n## toBeUndefined\n\n- **Type:** `() => void`\n\nThis matcher checks, if provided type is `undefined`.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(undefined).toBeUndefined()\nexpectTypeOf<undefined>().toBeUndefined()\nexpectTypeOf(null).not.toBeUndefined()\n```\n\n## toBeNullable\n\n- **Type:** `() => void`\n\nThis matcher checks, if you can use `null` or `undefined` with provided type.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<1 | undefined>().toBeNullable()\nexpectTypeOf<1 | null>().toBeNullable()\nexpectTypeOf<1 | undefined | null>().toBeNullable()\n```\n\n## toBeCallableWith\n\n- **Type:** `() => void`\n\nThis matcher ensures you can call provided function with a set of parameters.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().toBeCallableWith()\nexpectTypeOf<HasParam>().toBeCallableWith('some string')\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n## toBeConstructibleWith\n\n- **Type:** `() => void`\n\nThis matcher ensures you can create a new instance with a set of constructor parameters.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).toBeConstructibleWith(new Date())\nexpectTypeOf(Date).toBeConstructibleWith('01-01-2000')\n```\n\n**WARNING**\n\nIf used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.\n\n## toHaveProperty\n\n- **Type:** `<K extends keyof T>(property: K) => ExpectTypeOf<T[K>`\n\nThis matcher checks if a property exists on the provided object. If it exists, it also returns the same set of matchers for the type of this property, so you can chain assertions one after another.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nconst obj = { a: 1, b: '' }\n\nexpectTypeOf(obj).toHaveProperty('a')\nexpectTypeOf(obj).not.toHaveProperty('c')\n\nexpectTypeOf(obj).toHaveProperty('a').toBeNumber()\nexpectTypeOf(obj).toHaveProperty('b').toBeString()\nexpectTypeOf(obj).toHaveProperty('a').not.toBeString()\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/expect-typeof](https://vitest.dev/api/expect-typeof)"
- name: Extending Matchers
  id: guide/extending-matchers
  summary: Since Vitest is compatible with both Chai and Jest, you can use either the chai.use API or expect.extend, whichever you prefer
  description: "# Extending Matchers\n\nSince Vitest is compatible with both Chai and Jest, you can use either the `chai.use` API or `expect.extend`, whichever you prefer.\n\nThis guide will explore extending matchers with `expect.extend`. If you are interested in Chai's API, check [their guide](https://www.chaijs.com/guide/plugins/).\n\nTo extend default matchers, call `expect.extend` with an object containing your matchers.\n\nts\n\n``` javascript\nexpect.extend({\n  toBeFoo(received, expected) {\n    const { isNot } = this\n    return {\n      // do not alter your \"pass\" based on isNot. Vitest does it for you\n      pass: received === 'foo',\n      message: () => `${received} is${isNot ? ' not' : ''} foo`\n    }\n  }\n})\n```\n\nIf you are using TypeScript, you can extend default `Assertion` interface in an ambient declaration file (e.g: `vitest.d.ts`) with the code below:\n\nts\n\n``` javascript\nimport type { Assertion, AsymmetricMatchersContaining } from 'vitest'\n\ninterface CustomMatchers<R = unknown> {\n  toBeFoo: () => R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n```\n\n**WARNING**\n\nDon't forget to include the ambient declaration file in your `tsconfig.json`.\n\nThe return value of a matcher should be compatible with the following interface:\n\nts\n\n``` javascript\ninterface MatcherResult {\n  pass: boolean\n  message: () => string\n  // If you pass these, they will automatically appear inside a diff when\n  // the matcher does not pass, so you don't need to print the diff yourself\n  actual?: unknown\n  expected?: unknown\n}\n```\n\n**WARNING**\n\nIf you create an asynchronous matcher, don't forget to `await` the result (`await expect('foo').toBeFoo()`) in the test itself.\n\nThe first argument inside a matcher's function is the received value (the one inside `expect(received)`). The rest are arguments passed directly to the matcher.\n\nMatcher function have access to `this` context with the following properties:\n\n- `isNot`\n\n  Returns true, if matcher was called on `not` (`expect(received).not.toBeFoo()`).\n\n- `promise`\n\n  If matcher was called on `resolved/rejected`, this value will contain the name of modifier. Otherwise, it will be an empty string.\n\n- `equals`\n\n  This is a utility function that allows you to compare two values. It will return `true` if values are equal, `false` otherwise. This function is used internally for almost every matcher. It supports objects with asymmetric matchers by default.\n\n- `utils`\n\n  This contains a set of utility functions that you can use to display messages.\n\n`this` context also contains information about the current test. You can also get it by calling `expect.getState()`. The most useful properties are:\n\n- `currentTestName`\n\n  Full name of the current test (including describe block).\n\n- `testPath`\n\n  Path to the current test.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/extending-matchers](https://vitest.dev/guide/extending-matchers)"
- name: Extending Reporters
  id: advanced/reporters
  summary: You can import reporters from vitest/reporters and extend them to create your custom reporters
  description: "# Extending Reporters\n\nYou can import reporters from `vitest/reporters` and extend them to create your custom reporters.\n\n## Extending Built-in Reporters\n\nIn general, you don't need to create your reporter from scratch. `vitest` comes with several default reporting programs that you can extend.\n\nts\n\n``` javascript\nimport { DefaultReporter } from 'vitest/reporters'\n\nexport default class MyDefaultReporter extends DefaultReporter {\n  // do something\n}\n```\n\nOf course, you can create your reporter from scratch. Just extend the `BaseReporter` class and implement the methods you need.\n\nAnd here is an example of a custom reporter:\n\nts\n\n``` javascript\n// ./custom-reporter.js\nimport { BaseReporter } from 'vitest/reporters'\n\nexport default class CustomReporter extends BaseReporter {\n  onCollected() {\n    const files = this.ctx.state.getFiles(this.watchFilters)\n    this.reportTestSummary(files)\n  }\n}\n```\n\nOr implement the `Reporter` interface:\n\nts\n\n``` javascript\n// ./custom-reporter.js\nimport { Reporter } from 'vitest/reporters'\n\nexport default class CustomReporter implements Reporter {\n  onCollected() {\n    // print something\n  }\n}\n```\n\nThen you can use your custom reporter in the `vitest.config.ts` file:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\nimport CustomReporter from './custom-reporter.js'\n\nexport default defineConfig({\n  test: {\n    reporters: [new CustomReporter()],\n  },\n})\n```\n\n## Exported Reporters\n\n`vitest` comes with a few [built-in reporters](../guide/reporters) that you can use out of the box.\n\n### Built-in reporters:\n\n1.  `BasicReporter`\n2.  `DefaultReporter`\n3.  `DotReporter`\n4.  `JsonReporter`\n5.  `VerboseReporter`\n6.  `TapReporter`\n7.  `JUnitReporter`\n8.  `TapFlatReporter`\n9.  `HangingProcessReporter`\n\n### Base Abstract reporters:\n\n1.  `BaseReporter`\n\n### Interface reporters:\n\n1.  `Reporter`\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/reporters](https://vitest.dev/advanced/reporters)"
- name: 'Extending Reporters: Base Abstract reporters: ​'
  id: advanced/reporters#base-abstract-reporters
  summary: null
  belongs_to: Extending Reporters
  description: |-
    ### Base Abstract reporters:

    1.  `BaseReporter`

    &nbsp;
- name: 'Extending Reporters: Built-in reporters: ​'
  id: advanced/reporters#built-in-reporters
  summary: null
  belongs_to: Extending Reporters
  description: |-
    ### Built-in reporters:

    1.  `BasicReporter`
    2.  `DefaultReporter`
    3.  `DotReporter`
    4.  `JsonReporter`
    5.  `VerboseReporter`
    6.  `TapReporter`
    7.  `JUnitReporter`
    8.  `TapFlatReporter`
    9.  `HangingProcessReporter`
- name: 'Extending Reporters: Exported Reporters ​'
  id: advanced/reporters#exported-reporters
  summary: vitest comes with a few built-in reporters that you can use out of the box
  belongs_to: Extending Reporters
  description: |-
    ## Exported Reporters

    `vitest` comes with a few [built-in reporters](../guide/reporters) that you can use out of the box.
- name: 'Extending Reporters: Extending Built-in Reporters ​'
  id: advanced/reporters#extending-built-in-reporters
  summary: In general, you don't need to create your reporter from scratch
  belongs_to: Extending Reporters
  description: |-
    ## Extending Built-in Reporters

    In general, you don't need to create your reporter from scratch. `vitest` comes with several default reporting programs that you can extend.

    ts

    ``` javascript
    import { DefaultReporter } from 'vitest/reporters'

    export default class MyDefaultReporter extends DefaultReporter {
      // do something
    }
    ```

    Of course, you can create your reporter from scratch. Just extend the `BaseReporter` class and implement the methods you need.

    And here is an example of a custom reporter:

    ts

    ``` javascript
    // ./custom-reporter.js
    import { BaseReporter } from 'vitest/reporters'

    export default class CustomReporter extends BaseReporter {
      onCollected() {
        const files = this.ctx.state.getFiles(this.watchFilters)
        this.reportTestSummary(files)
      }
    }
    ```

    Or implement the `Reporter` interface:

    ts

    ``` javascript
    // ./custom-reporter.js
    import { Reporter } from 'vitest/reporters'

    export default class CustomReporter implements Reporter {
      onCollected() {
        // print something
      }
    }
    ```

    Then you can use your custom reporter in the `vitest.config.ts` file:

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'
    import CustomReporter from './custom-reporter.js'

    export default defineConfig({
      test: {
        reporters: [new CustomReporter()],
      },
    })
    ```
- name: 'Extending Reporters: Interface reporters: ​'
  id: advanced/reporters#interface-reporters
  summary: © 2021-Present Anthony Fu © 2021-Present Matias Capeletto Licensed under the MIT License
  belongs_to: Extending Reporters
  description: "### Interface reporters:\n\n1.  `Reporter`\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/reporters](https://vitest.dev/advanced/reporters)"
- name: extract ​
  id: api/expect-typeof#extract
  summary: You can use .extract to narrow down types for further testing
  belongs_to: expectTypeOf
  description: |-
    ## extract

    - **Type:** `ExpectTypeOf<ExtractedUnion>`

    You can use `.extract` to narrow down types for further testing.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    type ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }

    interface CSSProperties { margin?: string; padding?: string }

    function getResponsiveProp<T>(_props: T): ResponsiveProp<T> {
      return {}
    }

    const cssProperties: CSSProperties = { margin: '1px', padding: '2px' }

    expectTypeOf(getResponsiveProp(cssProperties))
      .extract<{ xs?: any }>() // extracts the last type from a union
      .toEqualTypeOf<{ xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties }>()

    expectTypeOf(getResponsiveProp(cssProperties))
      .extract<unknown[]>() // extracts an array from a union
      .toEqualTypeOf<CSSProperties[]>()
    ```

    **WARNING**

    If no type is found in the union, `.extract` will return `never`.
- name: fail ​
  id: api/assert#fail
  summary: Force an assertion failure
  belongs_to: assert
  description: |-
    ## fail

    - **Type:**
      - `(message?: string) => never`
      - `<T>(actual: T, expected: T, message?: string, operator?: string) => never`

    Force an assertion failure.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.fail', () => {
      assert.fail('error message on failure')
      assert.fail('foo', 'bar', 'foo is not bar', '===')
    })
    ```
- name: Fake Timers ​
  id: api/vi#fake-timers
  summary: This sections descibes how to work with fake timers
  belongs_to: Vi
  description: |-
    ## Fake Timers

    This sections descibes how to work with [fake timers](../guide/mocking#timers).
- name: fakeTimers ​
  id: config/index#faketimers
  summary: Options that Vitest will pass down to @sinon/fake-timers when using vi.useFakeTimers()
  belongs_to: Configuring Vitest
  description: |-
    ### fakeTimers

    - **Type:** `FakeTimerInstallOpts`

    Options that Vitest will pass down to [`@sinon/fake-timers`](https://www.npmjs.com/package/@sinonjs/fake-timers) when using [`vi.useFakeTimers()`](../api/vi#vi-usefaketimers).

    #### fakeTimers.now

    - **Type:** `number | Date`
    - **Default:** `Date.now()`

    Installs fake timers with the specified Unix epoch.

    #### fakeTimers.toFake

    - **Type:** `('setTimeout' | 'clearTimeout' | 'setImmediate' | 'clearImmediate' | 'setInterval' | 'clearInterval' | 'Date' | 'nextTick' | 'hrtime' | 'requestAnimationFrame' | 'cancelAnimationFrame' | 'requestIdleCallback' | 'cancelIdleCallback' | 'performance' | 'queueMicrotask')[]`
    - **Default:** `['setTimeout', 'clearTimeout', 'setImmediate', 'clearImmediate', 'setInterval', 'clearInterval', 'Date']`

    An array with names of global methods and APIs to fake.

    To only mock `setTimeout()` and `nextTick()`, specify this property as `['setTimeout', 'nextTick']`.

    Mocking `nextTick` is not supported when running Vitest inside `node:child_process` by using `--pool=forks`. NodeJS uses `process.nextTick` internally in `node:child_process` and hangs when it is mocked. Mocking `nextTick` is supported when running Vitest with `--pool=threads`.

    #### fakeTimers.loopLimit

    - **Type:** `number`
    - **Default:** `10_000`

    The maximum number of timers that will be run when calling [`vi.runAllTimers()`](../api/vi#vi-runalltimers).

    #### fakeTimers.shouldAdvanceTime

    - **Type:** `boolean`
    - **Default:** `false`

    Tells @sinonjs/fake-timers to increment mocked time automatically based on the real system time shift (e.g. the mocked time will be incremented by 20ms for every 20ms change in the real system time).

    #### fakeTimers.advanceTimeDelta

    - **Type:** `number`
    - **Default:** `20`

    Relevant only when using with `shouldAdvanceTime: true`. increment mocked time by advanceTimeDelta ms every advanceTimeDelta ms change in the real system time.

    #### fakeTimers.shouldClearNativeTimers

    - **Type:** `boolean`
    - **Default:** `false`

    Tells fake timers to clear "native" (i.e. not fake) timers by delegating to their respective handlers. These are not cleared by default, leading to potentially unexpected behavior if timers existed prior to starting fake timers session.
- name: Features
  id: guide/features
  summary: Vite's config, transformers, resolvers, and plugins
  description: "# Features\n\n- [Vite](https://vitejs.dev)'s config, transformers, resolvers, and plugins\n\n- Use the same setup from your app to run the tests!\n\n- [Smart & instant watch mode, like HMR for tests!](https://twitter.com/antfu7/status/1468233216939245579)\n\n- Component testing for Vue, React, Svelte, Lit, Marko and more\n\n- Out-of-the-box TypeScript / JSX support\n\n- ESM first, top level await\n\n- Workers multi-threading via [Tinypool](https://github.com/tinylibs/tinypool)\n\n- Benchmarking support with [Tinybench](https://github.com/tinylibs/tinybench)\n\n- Filtering, timeouts, concurrent for suite and tests\n\n- [Workspace](workspace) support\n\n- [Jest-compatible Snapshot](snapshot)\n\n- [Chai](https://www.chaijs.com/) built-in for assertions + [Jest expect](https://jestjs.io/docs/expect) compatible APIs\n\n- [Tinyspy](https://github.com/tinylibs/tinyspy) built-in for mocking\n\n- [happy-dom](https://github.com/capricorn86/happy-dom) or [jsdom](https://github.com/jsdom/jsdom) for DOM mocking\n\n- Code coverage via [v8](https://v8.dev/blog/javascript-code-coverage) or [istanbul](https://istanbul.js.org/)\n\n- Rust-like [in-source testing](in-source)\n\n- Type Testing via [expect-type](https://github.com/mmkal/expect-type)\n\n- Sharding support\n\n[Learn how to write your first test by Video](https://vueschool.io/lessons/your-first-test?friend=vueuse)\n\n## Shared Config between Test, Dev and Build\n\nVite's config, transformers, resolvers, and plugins. Use the same setup from your app to run the tests.\n\nLearn more at [Configuring Vitest](index#configuring-vitest).\n\n## Watch Mode\n\nbash\n\n``` javascript\n$ vitest\n```\n\nWhen you modify your source code or the test files, Vitest smartly searches the module graph and only reruns the related tests, [just like how HMR works in Vite!](https://twitter.com/antfu7/status/1468233216939245579)\n\n`vitest` starts in `watch mode` **by default in development environment** and `run mode` in CI environment (when `process.env.CI` presents) smartly. You can use `vitest watch` or `vitest run` to explicitly specify the desired mode.\n\nStart Vitest with the `--standalone` flag to keep it running in the background. It won't run any tests until they change. Vitest will not run tests if the source code is changed until the test that imports the source has been run\n\n## Common Web Idioms Out-Of-The-Box\n\nOut-of-the-box ES Module / TypeScript / JSX support / PostCSS\n\n## Threads\n\nBy default Vitest runs test files in multiple threads using [`node:worker_threads`](https://nodejs.org/api/worker_threads.html) via [Tinypool](https://github.com/tinylibs/tinypool) (a lightweight fork of [Piscina](https://github.com/piscinajs/piscina)), allowing tests to run simultaneously. If your tests are running code that is not compatible with multi-threading, you can switch to [`--pool=forks`](../config/index#pool) which runs tests in multiple processes using [`node:child_process`](https://nodejs.org/api/child_process.html) via Tinypool.\n\nTo run tests in a single thread or process, see [`poolOptions`](../config/index#pooloptions).\n\nVitest also isolates each file's environment so env mutations in one file don't affect others. Isolation can be disabled by passing `--no-isolate` to the CLI (trading correctness for run performance).\n\n## Test Filtering\n\nVitest provides many ways to narrow down the tests to run in order to speed up testing so you can focus on development.\n\nLearn more about [Test Filtering](filtering).\n\n## Running Tests Concurrently\n\nUse `.concurrent` in consecutive tests to run them in parallel.\n\nts\n\n``` javascript\nimport { describe, it } from 'vitest'\n\n// The two tests marked with concurrent will be run in parallel\ndescribe('suite', () => {\n  it('serial test', async () => { /* ... */ })\n  it.concurrent('concurrent test 1', async ({ expect }) => { /* ... */ })\n  it.concurrent('concurrent test 2', async ({ expect }) => { /* ... */ })\n})\n```\n\nIf you use `.concurrent` on a suite, every test in it will be run in parallel.\n\nts\n\n``` javascript\nimport { describe, it } from 'vitest'\n\n// All tests within this suite will be run in parallel\ndescribe.concurrent('suite', () => {\n  it('concurrent test 1', async ({ expect }) => { /* ... */ })\n  it('concurrent test 2', async ({ expect }) => { /* ... */ })\n  it.concurrent('concurrent test 3', async ({ expect }) => { /* ... */ })\n})\n```\n\nYou can also use `.skip`, `.only`, and `.todo` with concurrent suites and tests. Read more in the [API Reference](../api/index#test-concurrent).\n\n**WARNING**\n\nWhen running concurrent tests, Snapshots and Assertions must use `expect` from the local [Test Context](test-context) to ensure the right test is detected.\n\n## Snapshot\n\n[Jest-compatible](https://jestjs.io/docs/snapshot-testing) snapshot support.\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('renders correctly', () => {\n  const result = render()\n  expect(result).toMatchSnapshot()\n})\n```\n\nLearn more at [Snapshot](snapshot).\n\n## Chai and Jest `expect` Compatibility\n\n[Chai](https://www.chaijs.com/) is built-in for assertions plus [Jest `expect`](https://jestjs.io/docs/expect)-compatible APIs.\n\nNotice that if you are using third-party libraries that add matchers, setting `test.globals` to `true` will provide better compatibility.\n\n## Mocking\n\n[Tinyspy](https://github.com/tinylibs/tinyspy) is built-in for mocking with `jest`-compatible APIs on `vi` object.\n\nts\n\n``` javascript\nimport { expect, vi } from 'vitest'\n\nconst fn = vi.fn()\n\nfn('hello', 1)\n\nexpect(vi.isMockFunction(fn)).toBe(true)\nexpect(fn.mock.calls[0]).toEqual(['hello', 1])\n\nfn.mockImplementation(arg => arg)\n\nfn('world', 2)\n\nexpect(fn.mock.results[1].value).toBe('world')\n```\n\nVitest supports both [happy-dom](https://github.com/capricorn86/happy-dom) or [jsdom](https://github.com/jsdom/jsdom) for mocking DOM and browser APIs. They don't come with Vitest, you might need to install them:\n\nbash\n\n``` javascript\n$ npm i -D happy-dom\n# or\n$ npm i -D jsdom\n```\n\nAfter that, change the `environment` option in your config file:\n\nts\n\n``` javascript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    environment: 'happy-dom', // or 'jsdom', 'node'\n  },\n})\n```\n\nLearn more at [Mocking](mocking).\n\n## Coverage\n\nVitest supports Native code coverage via [`v8`](https://v8.dev/blog/javascript-code-coverage) and instrumented code coverage via [`istanbul`](https://istanbul.js.org/).\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\nLearn more at [Coverage](coverage).\n\n## In-Source Testing\n\nVitest also provides a way to run tests within your source code along with the implementation, similar to [Rust's module tests](https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest).\n\nThis makes the tests share the same closure as the implementations and able to test against private states without exporting. Meanwhile, it also brings the feedback loop closer for development.\n\nts\n\n``` javascript\n// src/index.ts\n\n// the implementation\nexport function add(...args: number[]) {\n  return args.reduce((a, b) => a + b, 0)\n}\n\n// in-source test suites\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n```\n\nLearn more at [In-source testing](in-source).\n\n## Benchmarking Experimental\n\nYou can run benchmark tests with [`bench`](../api/index#bench) function via [Tinybench](https://github.com/tinylibs/tinybench) to compare performance results.\n\nts\n\n``` javascript\nimport { bench, describe } from 'vitest'\n\ndescribe('sort', () => {\n  bench('normal', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.sort((a, b) => {\n      return a - b\n    })\n  })\n\n  bench('reverse', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.reverse().sort((a, b) => {\n      return a - b\n    })\n  })\n})\n```\n\n## Type Testing Experimental\n\nYou can [write tests](testing-types) to catch type regressions. Vitest comes with [`expect-type`](https://github.com/mmkal/expect-type) package to provide you with a similar and easy to understand API.\n\nts\n\n``` javascript\nimport { assertType, expectTypeOf } from 'vitest'\nimport { mount } from './mount.js'\n\ntest('my types work properly', () => {\n  expectTypeOf(mount).toBeFunction()\n  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()\n\n  // @ts-expect-error name is a string\n  assertType(mount({ name: 42 }))\n})\n```\n\n## Sharding\n\nRun tests on different machines using [`--shard`](cli#shard) and [`--reporter=blob`](reporters#blob-reporter) flags. All test and coverage results can be merged at the end of your CI pipeline using `--merge-reports` command:\n\nbash\n\n``` javascript\nvitest --shard=1/2 --reporter=blob\nvitest --shard=2/2 --reporter=blob\nvitest --merge-reports --reporter=junit --coverage.reporter=text\n```\n\nSee [`Improving Performance | Sharding`](improving-performance#sharding) for more information.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/features](https://vitest.dev/guide/features)"
- name: 'Features: Benchmarking Experimental ​'
  id: guide/features#benchmarking
  summary: You can run benchmark tests with bench function via Tinybench to compare performance results
  belongs_to: Features
  description: |-
    ## Benchmarking Experimental

    You can run benchmark tests with [`bench`](../api/index#bench) function via [Tinybench](https://github.com/tinylibs/tinybench) to compare performance results.

    ts

    ``` javascript
    import { bench, describe } from 'vitest'

    describe('sort', () => {
      bench('normal', () => {
        const x = [1, 5, 4, 2, 3]
        x.sort((a, b) => {
          return a - b
        })
      })

      bench('reverse', () => {
        const x = [1, 5, 4, 2, 3]
        x.reverse().sort((a, b) => {
          return a - b
        })
      })
    })
    ```
- name: 'Features: Chai and Jest expect Compatibility ​'
  id: guide/features#chai-and-jest-expect-compatibility
  summary: Chai is built-in for assertions plus Jest expect-compatible APIs
  belongs_to: Features
  description: |-
    ## Chai and Jest `expect` Compatibility

    [Chai](https://www.chaijs.com/) is built-in for assertions plus [Jest `expect`](https://jestjs.io/docs/expect)-compatible APIs.

    Notice that if you are using third-party libraries that add matchers, setting `test.globals` to `true` will provide better compatibility.
- name: 'Features: Common Web Idioms Out-Of-The-Box ​'
  id: guide/features#common-web-idioms-out-of-the-box
  summary: null
  belongs_to: Features
  description: |-
    ## Common Web Idioms Out-Of-The-Box

    Out-of-the-box ES Module / TypeScript / JSX support / PostCSS
- name: 'Features: Coverage ​'
  id: guide/features#coverage
  summary: Vitest supports Native code coverage via v8 and instrumented code coverage via istanbul
  belongs_to: Features
  description: |-
    ## Coverage

    Vitest supports Native code coverage via [`v8`](https://v8.dev/blog/javascript-code-coverage) and instrumented code coverage via [`istanbul`](https://istanbul.js.org/).

    json

    ``` javascript
    {
      "scripts": {
        "test": "vitest",
        "coverage": "vitest run --coverage"
      }
    }
    ```

    Learn more at [Coverage](coverage).
- name: 'Features: In-Source Testing ​'
  id: guide/features#in-source-testing
  summary: Vitest also provides a way to run tests within your source code along with the implementation, similar to Rust's module tests
  belongs_to: Features
  description: |-
    ## In-Source Testing

    Vitest also provides a way to run tests within your source code along with the implementation, similar to [Rust's module tests](https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest).

    This makes the tests share the same closure as the implementations and able to test against private states without exporting. Meanwhile, it also brings the feedback loop closer for development.

    ts

    ``` javascript
    // src/index.ts

    // the implementation
    export function add(...args: number[]) {
      return args.reduce((a, b) => a + b, 0)
    }

    // in-source test suites
    if (import.meta.vitest) {
      const { it, expect } = import.meta.vitest
      it('add', () => {
        expect(add()).toBe(0)
        expect(add(1)).toBe(1)
        expect(add(1, 2, 3)).toBe(6)
      })
    }
    ```

    Learn more at [In-source testing](in-source).
- name: 'Features: Mocking ​'
  id: guide/features#mocking
  summary: Tinyspy is built-in for mocking with jest-compatible APIs on vi object
  belongs_to: Features
  description: |-
    ## Mocking

    [Tinyspy](https://github.com/tinylibs/tinyspy) is built-in for mocking with `jest`-compatible APIs on `vi` object.

    ts

    ``` javascript
    import { expect, vi } from 'vitest'

    const fn = vi.fn()

    fn('hello', 1)

    expect(vi.isMockFunction(fn)).toBe(true)
    expect(fn.mock.calls[0]).toEqual(['hello', 1])

    fn.mockImplementation(arg => arg)

    fn('world', 2)

    expect(fn.mock.results[1].value).toBe('world')
    ```

    Vitest supports both [happy-dom](https://github.com/capricorn86/happy-dom) or [jsdom](https://github.com/jsdom/jsdom) for mocking DOM and browser APIs. They don't come with Vitest, you might need to install them:

    bash

    ``` javascript
    $ npm i -D happy-dom
    # or
    $ npm i -D jsdom
    ```

    After that, change the `environment` option in your config file:

    ts

    ``` javascript
    // vitest.config.ts
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        environment: 'happy-dom', // or 'jsdom', 'node'
      },
    })
    ```

    Learn more at [Mocking](mocking).
- name: 'Features: Running Tests Concurrently ​'
  id: guide/features#running-tests-concurrently
  summary: Use .concurrent in consecutive tests to run them in parallel
  belongs_to: Features
  description: |-
    ## Running Tests Concurrently

    Use `.concurrent` in consecutive tests to run them in parallel.

    ts

    ``` javascript
    import { describe, it } from 'vitest'

    // The two tests marked with concurrent will be run in parallel
    describe('suite', () => {
      it('serial test', async () => { /* ... */ })
      it.concurrent('concurrent test 1', async ({ expect }) => { /* ... */ })
      it.concurrent('concurrent test 2', async ({ expect }) => { /* ... */ })
    })
    ```

    If you use `.concurrent` on a suite, every test in it will be run in parallel.

    ts

    ``` javascript
    import { describe, it } from 'vitest'

    // All tests within this suite will be run in parallel
    describe.concurrent('suite', () => {
      it('concurrent test 1', async ({ expect }) => { /* ... */ })
      it('concurrent test 2', async ({ expect }) => { /* ... */ })
      it.concurrent('concurrent test 3', async ({ expect }) => { /* ... */ })
    })
    ```

    You can also use `.skip`, `.only`, and `.todo` with concurrent suites and tests. Read more in the [API Reference](../api/index#test-concurrent).

    **WARNING**

    When running concurrent tests, Snapshots and Assertions must use `expect` from the local [Test Context](test-context) to ensure the right test is detected.
- name: 'Features: Sharding ​'
  id: guide/features#sharding
  summary: Run tests on different machines using --shard and --reporter=blob flags
  belongs_to: Features
  description: "## Sharding\n\nRun tests on different machines using [`--shard`](cli#shard) and [`--reporter=blob`](reporters#blob-reporter) flags. All test and coverage results can be merged at the end of your CI pipeline using `--merge-reports` command:\n\nbash\n\n``` javascript\nvitest --shard=1/2 --reporter=blob\nvitest --shard=2/2 --reporter=blob\nvitest --merge-reports --reporter=junit --coverage.reporter=text\n```\n\nSee [`Improving Performance | Sharding`](improving-performance#sharding) for more information.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/features](https://vitest.dev/guide/features)"
- name: 'Features: Shared Config between Test, Dev and Build ​'
  id: guide/features#shared-config-between-test-dev-and-build
  summary: Vite's config, transformers, resolvers, and plugins
  belongs_to: Features
  description: |-
    ## Shared Config between Test, Dev and Build

    Vite's config, transformers, resolvers, and plugins. Use the same setup from your app to run the tests.

    Learn more at [Configuring Vitest](index#configuring-vitest).
- name: 'Features: Snapshot ​'
  id: guide/features#snapshot
  summary: Jest-compatible snapshot support
  belongs_to: Features
  description: |-
    ## Snapshot

    [Jest-compatible](https://jestjs.io/docs/snapshot-testing) snapshot support.

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('renders correctly', () => {
      const result = render()
      expect(result).toMatchSnapshot()
    })
    ```

    Learn more at [Snapshot](snapshot).
- name: 'Features: Test Filtering ​'
  id: guide/features#test-filtering
  summary: Vitest provides many ways to narrow down the tests to run in order to speed up testing so you can focus on development
  belongs_to: Features
  description: |-
    ## Test Filtering

    Vitest provides many ways to narrow down the tests to run in order to speed up testing so you can focus on development.

    Learn more about [Test Filtering](filtering).
- name: 'Features: Threads ​'
  id: guide/features#threads
  summary: By default Vitest runs test files in multiple threads using node:worker_threads via Tinypool (a lightweight fork of Piscina), allowing tests to run simultaneously
  belongs_to: Features
  description: |-
    ## Threads

    By default Vitest runs test files in multiple threads using [`node:worker_threads`](https://nodejs.org/api/worker_threads.html) via [Tinypool](https://github.com/tinylibs/tinypool) (a lightweight fork of [Piscina](https://github.com/piscinajs/piscina)), allowing tests to run simultaneously. If your tests are running code that is not compatible with multi-threading, you can switch to [`--pool=forks`](../config/index#pool) which runs tests in multiple processes using [`node:child_process`](https://nodejs.org/api/child_process.html) via Tinypool.

    To run tests in a single thread or process, see [`poolOptions`](../config/index#pooloptions).

    Vitest also isolates each file's environment so env mutations in one file don't affect others. Isolation can be disabled by passing `--no-isolate` to the CLI (trading correctness for run performance).
- name: 'Features: Type Testing Experimental ​'
  id: guide/features#type-testing
  summary: You can write tests to catch type regressions
  belongs_to: Features
  description: |-
    ## Type Testing Experimental

    You can [write tests](testing-types) to catch type regressions. Vitest comes with [`expect-type`](https://github.com/mmkal/expect-type) package to provide you with a similar and easy to understand API.

    ts

    ``` javascript
    import { assertType, expectTypeOf } from 'vitest'
    import { mount } from './mount.js'

    test('my types work properly', () => {
      expectTypeOf(mount).toBeFunction()
      expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()

      // @ts-expect-error name is a string
      assertType(mount({ name: 42 }))
    })
    ```
- name: 'Features: Watch Mode ​'
  id: guide/features#watch-mode
  summary: vitest starts in watch mode by default in development environment and run mode in CI environment (when process.env.CI presents) smartly
  belongs_to: Features
  description: |-
    ## Watch Mode

    bash

    ``` javascript
    $ vitest
    ```

    When you modify your source code or the test files, Vitest smartly searches the module graph and only reruns the related tests, [just like how HMR works in Vite!](https://twitter.com/antfu7/status/1468233216939245579)

    `vitest` starts in `watch mode` **by default in development environment** and `run mode` in CI environment (when `process.env.CI` presents) smartly. You can use `vitest watch` or `vitest run` to explicitly specify the desired mode.

    Start Vitest with the `--standalone` flag to keep it running in the background. It won't run any tests until they change. Vitest will not run tests if the source code is changed until the test that imports the source has been run
- name: fileParallelism *  ​
  id: config/index#fileparallelism
  summary: Should all test files run in parallel
  belongs_to: Configuring Vitest
  description: "### fileParallelism \\* \n\n- **Type:** `boolean`\n- **Default:** `true`\n- **CLI:**`--no-file-parallelism`, `--fileParallelism=false`\n\nShould all test files run in parallel. Setting this to `false` will override `maxWorkers` and `minWorkers` options to `1`.\n\n**TIP**\n\nThis option doesn't affect tests running in the same file. If you want to run those in parallel, use `concurrent` option on [describe](../api/index#describe-concurrent) or via [a config](#sequence-concurrent)."
- name: forceRerunTriggers *  ​
  id: config/index#forcereruntriggers
  summary: Glob pattern of file paths that will trigger the whole suite rerun
  belongs_to: Configuring Vitest
  description: "### forceRerunTriggers \\* \n\n- **Type**: `string[]`\n- **Default:** `['**/package.json/**', '**/vitest.config.*/**', '**/vite.config.*/**']`\n\nGlob pattern of file paths that will trigger the whole suite rerun. When paired with the `--changed` argument will run the whole test suite if the trigger is found in the git diff.\n\nUseful if you are testing calling CLI commands, because Vite cannot construct a module graph:\n\nts\n\n``` javascript\ntest('execute a script', async () => {\n  // Vitest cannot rerun this test, if content of `dist/index.js` changes\n  await execa('node', ['dist/index.js'])\n})\n```\n\n**TIP**\n\nMake sure that your files are not excluded by [`server.watch.ignored`](https://vitejs.dev/config/server-options.html#server-watch)."
- name: getMockImplementation ​
  id: api/mock#getmockimplementation
  summary: Returns current mock implementation if there is one
  belongs_to: Mock Functions
  description: |-
    ## getMockImplementation

    - **Type:** `(...args: any) => any`

    Returns current mock implementation if there is one.

    If mock was created with [`vi.fn`](vi#vi-fn), it will consider passed down method as a mock implementation.

    If mock was created with [`vi.spyOn`](vi#vi-spyon), it will return `undefined` unless a custom implementation was provided.
- name: getMockName ​
  id: api/mock#getmockname
  summary: Use it to return the name given to mock with method .mockName(name)
  belongs_to: Mock Functions
  description: |-
    ## getMockName

    - **Type:** `() => string`

    Use it to return the name given to mock with method `.mockName(name)`.
- name: Getting Started
  id: guide/index
  summary: Vitest is a next generation testing framework powered by Vite
  description: "# Getting Started\n\n## Overview\n\nVitest is a next generation testing framework powered by Vite.\n\nYou can learn more about the rationale behind the project in the [Why Vitest](why) section.\n\n## Trying Vitest Online\n\nYou can try Vitest online on [StackBlitz](https://vitest.new). It runs Vitest directly in the browser, and it is almost identical to the local setup but doesn't require installing anything on your machine.\n\n## Adding Vitest to Your Project\n\n[Learn how to install by Video](https://vueschool.io/lessons/how-to-install-vitest?friend=vueuse)\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpm install -D vitest\n```\n\nbash\n\n``` javascript\nyarn add -D vitest\n```\n\nbash\n\n``` javascript\npnpm add -D vitest\n```\n\nbash\n\n``` javascript\nbun add -D vitest\n```\n\n**TIP**\n\nVitest 1.0 requires Vite \\>=v5.0.0 and Node \\>=v18.0.0\n\nIt is recommended that you install a copy of `vitest` in your `package.json`, using one of the methods listed above. However, if you would prefer to run `vitest` directly, you can use `npx vitest` (the `npx` command comes with npm and Node.js).\n\nThe `npx` command will execute the command either from a local `node_modules/.bin` installing any packages needed in order for the command to run. By default, npx will check whether command exists in $PATH, or in the local project binaries, and execute that. If command is not found, it will be installed prior to execution.\n\n## Writing Tests\n\nAs an example, we will write a simple test that verifies the output of a function that adds two numbers.\n\njs\n\n``` javascript\n// sum.js\nexport function sum(a, b) {\n  return a + b\n}\n```\n\njs\n\n``` javascript\n// sum.test.js\nimport { expect, test } from 'vitest'\nimport { sum } from './sum'\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3)\n})\n```\n\n**TIP**\n\nBy default, tests must contain \".test.\" or \".spec.\" in their file name.\n\nNext, in order to execute the test, add the following section to your `package.json`:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n```\n\nFinally, run `npm run test`, `yarn test`, or `pnpm test`, depending on your package manager, and Vitest will print this message:\n\ntxt\n\n``` javascript\n✓ sum.test.js (1)\n  ✓ adds 1 + 2 to equal 3\n\nTest Files  1 passed (1)\n    Tests  1 passed (1)\n  Start at  02:15:44\n  Duration  311ms\n```\n\nLearn more about the usage of Vitest, see the [API](../api/index) section.\n\n## Configuring Vitest\n\nOne of the main advantages of Vitest is its unified configuration with Vite. If present, `vitest` will read your root `vite.config.ts` to match with the plugins and setup as your Vite app. For example, your Vite [resolve.alias](https://vitejs.dev/config/shared-options.html#resolve-alias) and [plugins](https://vitejs.dev/guide/using-plugins) configuration will work out-of-the-box. If you want a different configuration during testing, you can:\n\n- Create `vitest.config.ts`, which will have the higher priority\n- Pass `--config` option to CLI, e.g. `vitest --config ./path/to/vitest.config.ts`\n- Use `process.env.VITEST` or `mode` property on `defineConfig` (will be set to `test` if not overridden) to conditionally apply different configuration in `vite.config.ts`\n\nVitest supports the same extensions for your configuration file as Vite does: `.js`, `.mjs`, `.cjs`, `.ts`, `.cts`, `.mts`. Vitest does not support `.json` extension.\n\nIf you are not using Vite as your build tool, you can configure Vitest using the `test` property in your config file:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // ...\n  },\n})\n```\n\n**TIP**\n\nEven if you do not use Vite yourself, Vitest relies heavily on it for its transformation pipeline. For that reason, you can also configure any property described in [Vite documentation](https://vitejs.dev/config/).\n\nIf you are already using Vite, add `test` property in your Vite config. You'll also need to add a reference to Vitest types using a [triple slash directive](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-) at the top of your config file.\n\nts\n\n``` javascript\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ...\n  },\n})\n```\n\nSee the list of config options in the [Config Reference](../config/index)\n\n**WARNING**\n\nIf you decide to have two separate config files for Vite and Vitest, make sure to define the same Vite options in your Vitest config file since it will override your Vite file, not extend it. You can also use `mergeConfig` method from `vite` or `vitest/config` entries to merge Vite config with Vitest config:\n\nvitest.config.mjsvite.config.mjs\n\nts\n\n``` javascript\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config.mjs'\n\nexport default mergeConfig(viteConfig, defineConfig({\n  test: {\n    // ...\n  }\n}))\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vite'\nimport Vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [Vue()],\n})\n```\n\nBut we recommend to use the same file for both Vite and Vitest instead of creating two separate files.\n\n## Workspaces Support\n\nRun different project configurations inside the same project with [Vitest Workspaces](workspace). You can define a list of files and folders that define your workspace in `vitest.workspace` file. The file supports `js`/`ts`/`json` extensions. This feature works great with monorepo setups.\n\nts\n\n``` javascript\nimport { defineWorkspace } from 'vitest/config'\n\nexport default defineWorkspace([\n  // you can use a list of glob patterns to define your workspaces\n  // Vitest expects a list of config files\n  // or directories where there is a config file\n  'packages/*',\n  'tests/*/vitest.config.{e2e,unit}.ts',\n  // you can even run the same tests,\n  // but with different configs in the same \"vitest\" process\n  {\n    test: {\n      name: 'happy-dom',\n      root: './shared_tests',\n      environment: 'happy-dom',\n      setupFiles: ['./setup.happy-dom.ts'],\n    },\n  },\n  {\n    test: {\n      name: 'node',\n      root: './shared_tests',\n      environment: 'node',\n      setupFiles: ['./setup.node.ts'],\n    },\n  },\n])\n```\n\n## Command Line Interface\n\nIn a project where Vitest is installed, you can use the `vitest` binary in your npm scripts, or run it directly with `npx vitest`. Here are the default npm scripts in a scaffolded Vitest project:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n```\n\nTo run tests once without watching for file changes, use `vitest run`. You can specify additional CLI options like `--port` or `--https`. For a full list of CLI options, run `npx vitest --help` in your project.\n\nLearn more about the [Command Line Interface](cli)\n\n## IDE Integrations\n\nWe also provided a official extension for Visual Studio Code to enhance your testing experience with Vitest.\n\n[Install from VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=vitest.explorer)\n\nLearn more about [IDE Integrations](ide)\n\n## Examples\n\n| Example     | Source                                                                         | Playground                                                                                                               |\n|-------------|--------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| `basic`     | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/basic)        | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/basic?initialPath=__vitest__/)     |\n| `fastify`   | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/fastify)      | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/fastify?initialPath=__vitest__/)   |\n| `lit`       | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/lit)          | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/lit?initialPath=__vitest__/)       |\n| `marko`     | [GitHub](https://github.com/marko-js/examples/tree/master/examples/library-ts) | [Play Online](https://stackblitz.com/fork/github/marko-js/examples/tree/master/examples/library-ts/)                     |\n| `preact`    | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/preact)       | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/preact?initialPath=__vitest__/)    |\n| `react`     | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/react)        | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/react?initialPath=__vitest__/)     |\n| `solid`     | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/solid)        | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/solid?initialPath=__vitest__/)     |\n| `sveltekit` | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/sveltekit)    | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/sveltekit?initialPath=__vitest__/) |\n| `typecheck` | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/typecheck)    | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/typecheck?initialPath=__vitest__/) |\n| `workspace` | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/workspace)    | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/workspace?initialPath=__vitest__/) |\n\n## Projects using Vitest\n\n- [unocss](https://github.com/unocss/unocss)\n- [unplugin-auto-import](https://github.com/antfu/unplugin-auto-import)\n- [unplugin-vue-components](https://github.com/antfu/unplugin-vue-components)\n- [vue](https://github.com/vuejs/core)\n- [vite](https://github.com/vitejs/vite)\n- [vitesse](https://github.com/antfu/vitesse)\n- [vitesse-lite](https://github.com/antfu/vitesse-lite)\n- [fluent-vue](https://github.com/demivan/fluent-vue)\n- [vueuse](https://github.com/vueuse/vueuse)\n- [milkdown](https://github.com/Saul-Mirone/milkdown)\n- [gridjs-svelte](https://github.com/iamyuu/gridjs-svelte)\n- [spring-easing](https://github.com/okikio/spring-easing)\n- [bytemd](https://github.com/bytedance/bytemd)\n- [faker](https://github.com/faker-js/faker)\n- [million](https://github.com/aidenybai/million)\n- [Vitamin](https://github.com/wtchnm/Vitamin)\n- [neodrag](https://github.com/PuruVJ/neodrag)\n- [svelte-multiselect](https://github.com/janosh/svelte-multiselect)\n- [iconify](https://github.com/iconify/iconify)\n- [tdesign-vue-next](https://github.com/Tencent/tdesign-vue-next)\n- [cz-git](https://github.com/Zhengqbbb/cz-git)\n\n## Using Unreleased Commits\n\nIf you can't wait for a new release to test the latest features, you will need to clone the [vitest repo](https://github.com/vitest-dev/vitest) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):\n\nbash\n\n``` javascript\ngit clone https://github.com/vitest-dev/vitest.git\ncd vitest\npnpm install\ncd packages/vitest\npnpm run build\npnpm link --global # you can use your preferred package manager for this step\n```\n\nThen go to the project where you are using Vitest and run `pnpm link --global vitest` (or the package manager that you used to link `vitest` globally).\n\n## Community\n\nIf you have questions or need help, reach out to the community at [Discord](https://chat.vitest.dev) and [GitHub Discussions](https://github.com/vitest-dev/vitest/discussions).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/](https://vitest.dev/guide/)"
- name: 'Getting Started: Adding Vitest to Your Project ​'
  id: guide/index#adding-vitest-to-your-project
  summary: It is recommended that you install a copy of vitest in your package.json, using one of the methods listed above
  belongs_to: Getting Started
  description: |-
    ## Adding Vitest to Your Project

    [Learn how to install by Video](https://vueschool.io/lessons/how-to-install-vitest?friend=vueuse)

    npm yarn pnpm bun

    bash

    ``` javascript
    npm install -D vitest
    ```

    bash

    ``` javascript
    yarn add -D vitest
    ```

    bash

    ``` javascript
    pnpm add -D vitest
    ```

    bash

    ``` javascript
    bun add -D vitest
    ```

    **TIP**

    Vitest 1.0 requires Vite \>=v5.0.0 and Node \>=v18.0.0

    It is recommended that you install a copy of `vitest` in your `package.json`, using one of the methods listed above. However, if you would prefer to run `vitest` directly, you can use `npx vitest` (the `npx` command comes with npm and Node.js).

    The `npx` command will execute the command either from a local `node_modules/.bin` installing any packages needed in order for the command to run. By default, npx will check whether command exists in $PATH, or in the local project binaries, and execute that. If command is not found, it will be installed prior to execution.
- name: 'Getting Started: Command Line Interface ​'
  id: guide/index#command-line-interface
  summary: In a project where Vitest is installed, you can use the vitest binary in your npm scripts, or run it directly with npx vitest
  belongs_to: Getting Started
  description: |-
    ## Command Line Interface

    In a project where Vitest is installed, you can use the `vitest` binary in your npm scripts, or run it directly with `npx vitest`. Here are the default npm scripts in a scaffolded Vitest project:

    json

    ``` javascript
    {
      "scripts": {
        "test": "vitest",
        "coverage": "vitest run --coverage"
      }
    }
    ```

    To run tests once without watching for file changes, use `vitest run`. You can specify additional CLI options like `--port` or `--https`. For a full list of CLI options, run `npx vitest --help` in your project.

    Learn more about the [Command Line Interface](cli)
- name: 'Getting Started: Community ​'
  id: guide/index#community
  summary: If you have questions or need help, reach out to the community at Discord and GitHub Discussions
  belongs_to: Getting Started
  description: "## Community\n\nIf you have questions or need help, reach out to the community at [Discord](https://chat.vitest.dev) and [GitHub Discussions](https://github.com/vitest-dev/vitest/discussions).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/](https://vitest.dev/guide/)"
- name: 'Getting Started: Configuring Vitest ​'
  id: guide/index#configuring-vitest
  summary: One of the main advantages of Vitest is its unified configuration with Vite
  belongs_to: Getting Started
  description: |-
    ## Configuring Vitest

    One of the main advantages of Vitest is its unified configuration with Vite. If present, `vitest` will read your root `vite.config.ts` to match with the plugins and setup as your Vite app. For example, your Vite [resolve.alias](https://vitejs.dev/config/shared-options.html#resolve-alias) and [plugins](https://vitejs.dev/guide/using-plugins) configuration will work out-of-the-box. If you want a different configuration during testing, you can:

    - Create `vitest.config.ts`, which will have the higher priority
    - Pass `--config` option to CLI, e.g. `vitest --config ./path/to/vitest.config.ts`
    - Use `process.env.VITEST` or `mode` property on `defineConfig` (will be set to `test` if not overridden) to conditionally apply different configuration in `vite.config.ts`

    Vitest supports the same extensions for your configuration file as Vite does: `.js`, `.mjs`, `.cjs`, `.ts`, `.cts`, `.mts`. Vitest does not support `.json` extension.

    If you are not using Vite as your build tool, you can configure Vitest using the `test` property in your config file:

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        // ...
      },
    })
    ```

    **TIP**

    Even if you do not use Vite yourself, Vitest relies heavily on it for its transformation pipeline. For that reason, you can also configure any property described in [Vite documentation](https://vitejs.dev/config/).

    If you are already using Vite, add `test` property in your Vite config. You'll also need to add a reference to Vitest types using a [triple slash directive](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-) at the top of your config file.

    ts

    ``` javascript
    /// <reference types="vitest" />
    import { defineConfig } from 'vite'

    export default defineConfig({
      test: {
        // ...
      },
    })
    ```

    See the list of config options in the [Config Reference](../config/index)

    **WARNING**

    If you decide to have two separate config files for Vite and Vitest, make sure to define the same Vite options in your Vitest config file since it will override your Vite file, not extend it. You can also use `mergeConfig` method from `vite` or `vitest/config` entries to merge Vite config with Vitest config:

    vitest.config.mjs vite.config.mjs

    ts

    ``` javascript
    import { defineConfig, mergeConfig } from 'vitest/config'
    import viteConfig from './vite.config.mjs'

    export default mergeConfig(viteConfig, defineConfig({
      test: {
        // ...
      }
    }))
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vite'
    import Vue from '@vitejs/plugin-vue'

    export default defineConfig({
      plugins: [Vue()],
    })
    ```

    But we recommend to use the same file for both Vite and Vitest instead of creating two separate files.
- name: 'Getting Started: Examples ​'
  id: guide/index#examples
  summary: null
  belongs_to: Getting Started
  description: |-
    ## Examples

    | Example     | Source                                                                         | Playground                                                                                                               |
    |-------------|--------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
    | `basic`     | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/basic)        | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/basic?initialPath=__vitest__/)     |
    | `fastify`   | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/fastify)      | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/fastify?initialPath=__vitest__/)   |
    | `lit`       | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/lit)          | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/lit?initialPath=__vitest__/)       |
    | `marko`     | [GitHub](https://github.com/marko-js/examples/tree/master/examples/library-ts) | [Play Online](https://stackblitz.com/fork/github/marko-js/examples/tree/master/examples/library-ts/)                     |
    | `preact`    | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/preact)       | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/preact?initialPath=__vitest__/)    |
    | `react`     | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/react)        | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/react?initialPath=__vitest__/)     |
    | `solid`     | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/solid)        | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/solid?initialPath=__vitest__/)     |
    | `sveltekit` | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/sveltekit)    | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/sveltekit?initialPath=__vitest__/) |
    | `typecheck` | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/typecheck)    | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/typecheck?initialPath=__vitest__/) |
    | `workspace` | [GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/workspace)    | [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/workspace?initialPath=__vitest__/) |
- name: 'Getting Started: IDE Integrations ​'
  id: guide/index#ide-integrations
  summary: We also provided a official extension for Visual Studio Code to enhance your testing experience with Vitest
  belongs_to: Getting Started
  description: |-
    ## IDE Integrations

    We also provided a official extension for Visual Studio Code to enhance your testing experience with Vitest.

    [Install from VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=vitest.explorer)

    Learn more about [IDE Integrations](ide)
- name: 'Getting Started: Overview ​'
  id: guide/index#overview
  summary: Vitest is a next generation testing framework powered by Vite
  belongs_to: Getting Started
  description: |-
    ## Overview

    Vitest is a next generation testing framework powered by Vite.

    You can learn more about the rationale behind the project in the [Why Vitest](why) section.
- name: 'Getting Started: Projects using Vitest ​'
  id: guide/index#projects-using-vitest
  summary: null
  belongs_to: Getting Started
  description: |-
    ## Projects using Vitest

    - [unocss](https://github.com/unocss/unocss)
    - [unplugin-auto-import](https://github.com/antfu/unplugin-auto-import)
    - [unplugin-vue-components](https://github.com/antfu/unplugin-vue-components)
    - [vue](https://github.com/vuejs/core)
    - [vite](https://github.com/vitejs/vite)
    - [vitesse](https://github.com/antfu/vitesse)
    - [vitesse-lite](https://github.com/antfu/vitesse-lite)
    - [fluent-vue](https://github.com/demivan/fluent-vue)
    - [vueuse](https://github.com/vueuse/vueuse)
    - [milkdown](https://github.com/Saul-Mirone/milkdown)
    - [gridjs-svelte](https://github.com/iamyuu/gridjs-svelte)
    - [spring-easing](https://github.com/okikio/spring-easing)
    - [bytemd](https://github.com/bytedance/bytemd)
    - [faker](https://github.com/faker-js/faker)
    - [million](https://github.com/aidenybai/million)
    - [Vitamin](https://github.com/wtchnm/Vitamin)
    - [neodrag](https://github.com/PuruVJ/neodrag)
    - [svelte-multiselect](https://github.com/janosh/svelte-multiselect)
    - [iconify](https://github.com/iconify/iconify)
    - [tdesign-vue-next](https://github.com/Tencent/tdesign-vue-next)
    - [cz-git](https://github.com/Zhengqbbb/cz-git)
- name: 'Getting Started: Trying Vitest Online ​'
  id: guide/index#trying-vitest-online
  summary: You can try Vitest online on StackBlitz
  belongs_to: Getting Started
  description: |-
    ## Trying Vitest Online

    You can try Vitest online on [StackBlitz](https://vitest.new). It runs Vitest directly in the browser, and it is almost identical to the local setup but doesn't require installing anything on your machine.
- name: 'Getting Started: Using Unreleased Commits ​'
  id: guide/index#using-unreleased-commits
  summary: Then go to the project where you are using Vitest and run pnpm link --global vitest (or the package manager that you used to link vitest globally)
  belongs_to: Getting Started
  description: |-
    ## Using Unreleased Commits

    If you can't wait for a new release to test the latest features, you will need to clone the [vitest repo](https://github.com/vitest-dev/vitest) to your local machine and then build and link it yourself ([pnpm](https://pnpm.io/) is required):

    bash

    ``` javascript
    git clone https://github.com/vitest-dev/vitest.git
    cd vitest
    pnpm install
    cd packages/vitest
    pnpm run build
    pnpm link --global # you can use your preferred package manager for this step
    ```

    Then go to the project where you are using Vitest and run `pnpm link --global vitest` (or the package manager that you used to link `vitest` globally).
- name: 'Getting Started: Workspaces Support ​'
  id: guide/index#workspaces-support
  summary: Run different project configurations inside the same project with Vitest Workspaces
  belongs_to: Getting Started
  description: |-
    ## Workspaces Support

    Run different project configurations inside the same project with [Vitest Workspaces](workspace). You can define a list of files and folders that define your workspace in `vitest.workspace` file. The file supports `js`/`ts`/`json` extensions. This feature works great with monorepo setups.

    ts

    ``` javascript
    import { defineWorkspace } from 'vitest/config'

    export default defineWorkspace([
      // you can use a list of glob patterns to define your workspaces
      // Vitest expects a list of config files
      // or directories where there is a config file
      'packages/*',
      'tests/*/vitest.config.{e2e,unit}.ts',
      // you can even run the same tests,
      // but with different configs in the same "vitest" process
      {
        test: {
          name: 'happy-dom',
          root: './shared_tests',
          environment: 'happy-dom',
          setupFiles: ['./setup.happy-dom.ts'],
        },
      },
      {
        test: {
          name: 'node',
          root: './shared_tests',
          environment: 'node',
          setupFiles: ['./setup.node.ts'],
        },
      },
    ])
    ```
- name: 'Getting Started: Writing Tests ​'
  id: guide/index#writing-tests
  summary: As an example, we will write a simple test that verifies the output of a function that adds two numbers
  belongs_to: Getting Started
  description: |-
    ## Writing Tests

    As an example, we will write a simple test that verifies the output of a function that adds two numbers.

    js

    ``` javascript
    // sum.js
    export function sum(a, b) {
      return a + b
    }
    ```

    js

    ``` javascript
    // sum.test.js
    import { expect, test } from 'vitest'
    import { sum } from './sum'

    test('adds 1 + 2 to equal 3', () => {
      expect(sum(1, 2)).toBe(3)
    })
    ```

    **TIP**

    By default, tests must contain ".test." or ".spec." in their file name.

    Next, in order to execute the test, add the following section to your `package.json`:

    json

    ``` javascript
    {
      "scripts": {
        "test": "vitest"
      }
    }
    ```

    Finally, run `npm run test`, `yarn test`, or `pnpm test`, depending on your package manager, and Vitest will print this message:

    txt

    ``` javascript
    ✓ sum.test.js (1)
      ✓ adds 1 + 2 to equal 3

    Test Files  1 passed (1)
        Tests  1 passed (1)
      Start at  02:15:44
      Duration  311ms
    ```

    Learn more about the usage of Vitest, see the [API](../api/index) section.
- name: globals ​
  id: config/index#globals
  summary: By default, vitest does not provide global APIs for explicitness
  belongs_to: Configuring Vitest
  description: |-
    ### globals

    - **Type:** `boolean`
    - **Default:** `false`
    - **CLI:**`--globals`, `--globals=false`

    By default, `vitest` does not provide global APIs for explicitness. If you prefer to use the APIs globally like Jest, you can pass the `--globals` option to CLI or add `globals: true` in the config.

    ts

    ``` javascript
    // vitest.config.ts
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        globals: true,
      },
    })
    ```

    To get TypeScript working with the global APIs, add `vitest/globals` to the `types` field in your `tsconfig.json`

    json

    ``` javascript
    // tsconfig.json
    {
      "compilerOptions": {
        "types": ["vitest/globals"]
      }
    }
    ```

    If you are already using [`unplugin-auto-import`](https://github.com/antfu/unplugin-auto-import) in your project, you can also use it directly for auto importing those APIs.

    ts

    ``` javascript
    // vitest.config.ts
    import { defineConfig } from 'vitest/config'
    import AutoImport from 'unplugin-auto-import/vite'

    export default defineConfig({
      plugins: [
        AutoImport({
          imports: ['vitest'],
          dts: true, // generate TypeScript declaration
        }),
      ],
    })
    ```
- name: globalSetup ​
  id: config/index#globalsetup
  summary: Path to global setup files, relative to project root
  belongs_to: Configuring Vitest
  description: |-
    ### globalSetup

    - **Type:** `string | string[]`

    Path to global setup files, relative to project root.

    A global setup file can either export named functions `setup` and `teardown` or a `default` function that returns a teardown function ([example](https://github.com/vitest-dev/vitest/blob/main/test/global-setup/vitest.config.ts)).

    **INFO**

    Multiple globalSetup files are possible. setup and teardown are executed sequentially with teardown in reverse order.

    **WARNING**

    Global setup runs only if there is at least one running test. This means that global setup might start running during watch mode after test file is changed (the test file will wait for global setup to finish before running).

    Beware that the global setup is running in a different global scope, so your tests don't have access to variables defined here. However, you can pass down serializable data to tests via `provide` method:

    globalSetup.js globalSetup.ts example.test.js

    js

    ``` javascript
    export default function setup({ provide }) {
      provide('wsPort', 3000)
    }
    ```

    ts

    ``` javascript
    import type { GlobalSetupContext } from 'vitest/node'

    export default function setup({ provide }: GlobalSetupContext) {
      provide('wsPort', 3000)
    }

    // You can also extend `ProvidedContext` type
    // to have type safe access to `provide/inject` methods:
    declare module 'vitest' {
      export interface ProvidedContext {
        wsPort: number
      }
    }
    ```

    ts

    ``` javascript
    import { inject } from 'vitest'

    inject('wsPort') === 3000
    ```
- name: guards ​
  id: api/expect-typeof#guards
  summary: This matcher extracts guard value (e.g., v is number), so you can perform assertions on it
  belongs_to: expectTypeOf
  description: |-
    ## guards

    - **Type:** `ExpectTypeOf<Guard>`

    This matcher extracts guard value (e.g., `v is number`), so you can perform assertions on it.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    function isString(v: any): v is string {
      return typeof v === 'string'
    }
    expectTypeOf(isString).guards.toBeString()
    ```

    **WARNING**

    Returns `never`, if the value is not a guard function, so you won't be able to chain it with other matchers.
- name: hasAllDeepKeys ​
  id: api/assert#hasalldeepkeys
  summary: Asserts that object has all and only all of the keys provided
  belongs_to: assert
  description: |-
    ## hasAllDeepKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has all and only all of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.hasAnyDeepKeys', () => {
      assert.hasAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne']]), { one: 'one' })
      assert.hasAllDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])
      assert.hasAllDeepKeys(new Set([{ one: 'one' }]), { one: 'one' })
      assert.hasAllDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])
    })
    ```
- name: hasAllKeys ​
  id: api/assert#hasallkeys
  summary: Asserts that object has all and only all of the keys provided
  belongs_to: assert
  description: |-
    ## hasAllKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has all and only all of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.hasAllKeys', () => {
      assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'bar', 'baz'])
      assert.hasAllKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, bar: 99, baz: 1337 })
      assert.hasAllKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])
      assert.hasAllKeys(new Set([{ foo: 'bar' }, 'anotherKey'], [{ foo: 'bar' }, 'anotherKey']))
    })
    ```
- name: hasAnyDeepKeys ​
  id: api/assert#hasanydeepkeys
  summary: Asserts that object has at least one of the keys provided
  belongs_to: assert
  description: |-
    ## hasAnyDeepKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has at least one of the `keys` provided. Since Sets and Maps can have objects as keys you can use this assertion to perform a deep comparison. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.hasAnyDeepKeys', () => {
      assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), { one: 'one' })
      assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [1, 2]]), [{ one: 'one' }, { two: 'two' }])
      assert.hasAnyDeepKeys(new Map([[{ one: 'one' }, 'valueOne'], [{ two: 'two' }, 'valueTwo']]), [{ one: 'one' }, { two: 'two' }])
      assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), { one: 'one' })
      assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { three: 'three' }])
      assert.hasAnyDeepKeys(new Set([{ one: 'one' }, { two: 'two' }]), [{ one: 'one' }, { two: 'two' }])
    })
    ```
- name: hasAnyKeys ​
  id: api/assert#hasanykeys
  summary: Asserts that object has at least one of the keys provided
  belongs_to: assert
  description: |-
    ## hasAnyKeys

    - **Type:** `<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string) => void`

    Asserts that `object` has at least one of the `keys` provided. You can also provide a single object instead of a keys array and its keys will be used as the expected set of keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.hasAnyKeys', () => {
      assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, ['foo', 'iDontExist', 'baz'])
      assert.hasAnyKeys({ foo: 1, bar: 2, baz: 3 }, { foo: 30, iDontExist: 99, baz: 1337 })
      assert.hasAnyKeys(new Map([[{ foo: 1 }, 'bar'], ['key', 'value']]), [{ foo: 1 }, 'key'])
      assert.hasAnyKeys(new Set([{ foo: 'bar' }, 'anotherKey']), [{ foo: 'bar' }, 'anotherKey'])
    })
    ```
- name: hookTimeout ​
  id: config/index#hooktimeout
  summary: null
  belongs_to: Configuring Vitest
  description: |-
    ### hookTimeout

    - **Type:** `number`
    - **Default:**`10_000` in Node.js, `30_000` if `browser.enabled` is `true`
    - **CLI:**`--hook-timeout=10000`, `--hookTimeout=10000`

    Default timeout of a hook in milliseconds
- name: IDE Integrations
  id: guide/ide
  summary: WebStorm, PhpStorm, IntelliJ IDEA Ultimate, and other JetBrains IDEs come with built-in support for Vitest
  description: "# IDE Integrations\n\n## VS Code Official\n\n[GitHub](https://github.com/vitest-dev/vscode) \\| [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=vitest.explorer)\n\n## JetBrains IDE\n\nWebStorm, PhpStorm, IntelliJ IDEA Ultimate, and other JetBrains IDEs come with built-in support for Vitest.\n\n[WebStorm Help](https://www.jetbrains.com/help/webstorm/vitest.html) \\| [IntelliJ IDEA Ultimate Help](https://www.jetbrains.com/help/idea/vitest.html) \\| [PhpStorm Help](https://www.jetbrains.com/help/phpstorm/vitest.html)\n\n## Wallaby.js Paid (free for OSS)\n\nCreated by [The Wallaby Team](https://wallabyjs.com)\n\n[Wallaby.js](https://wallabyjs.com) runs your Vitest tests immediately as you type, highlighting results in your IDE right next to your code.\n\n[VS Code](https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode) \\| [JetBrains](https://plugins.jetbrains.com/plugin/15742-wallaby) \\| [Visual Studio](https://marketplace.visualstudio.com/items?itemName=vs-publisher-999439.WallabyjsforVisualStudio2022) \\| [Sublime Text](https://packagecontrol.io/packages/Wallaby)\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/ide](https://vitest.dev/guide/ide)"
- name: 'IDE Integrations: JetBrains IDE ​'
  id: guide/ide#jetbrains-ide
  summary: WebStorm, PhpStorm, IntelliJ IDEA Ultimate, and other JetBrains IDEs come with built-in support for Vitest
  belongs_to: IDE Integrations
  description: |-
    ## JetBrains IDE

    WebStorm, PhpStorm, IntelliJ IDEA Ultimate, and other JetBrains IDEs come with built-in support for Vitest.

    [WebStorm Help](https://www.jetbrains.com/help/webstorm/vitest.html) \| [IntelliJ IDEA Ultimate Help](https://www.jetbrains.com/help/idea/vitest.html) \| [PhpStorm Help](https://www.jetbrains.com/help/phpstorm/vitest.html)
- name: 'IDE Integrations: VS Code Official ​'
  id: guide/ide#vs-code
  summary: null
  belongs_to: IDE Integrations
  description: |-
    ## VS Code Official

    [GitHub](https://github.com/vitest-dev/vscode) \| [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=vitest.explorer)
- name: 'IDE Integrations: Wallaby.js Paid (free for OSS) ​'
  id: guide/ide#wallaby-js-paid-free-for-oss
  summary: Wallaby.js runs your Vitest tests immediately as you type, highlighting results in your IDE right next to your code
  belongs_to: IDE Integrations
  description: "## Wallaby.js Paid (free for OSS)\n\nCreated by [The Wallaby Team](https://wallabyjs.com)\n\n[Wallaby.js](https://wallabyjs.com) runs your Vitest tests immediately as you type, highlighting results in your IDE right next to your code.\n\n[VS Code](https://marketplace.visualstudio.com/items?itemName=WallabyJs.wallaby-vscode) \\| [JetBrains](https://plugins.jetbrains.com/plugin/15742-wallaby) \\| [Visual Studio](https://marketplace.visualstudio.com/items?itemName=vs-publisher-999439.WallabyjsforVisualStudio2022) \\| [Sublime Text](https://packagecontrol.io/packages/Wallaby)\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/ide](https://vitest.dev/guide/ide)"
- name: ifError ​
  id: api/assert#iferror
  summary: Asserts if object is not a false value, and throws if it is a true value
  belongs_to: assert
  description: |-
    ## ifError

    - **Type:** `<T>(object: T, message?: string) => void`

    Asserts if `object` is not a false value, and throws if it is a true value. This is added to allow for chai to be a drop-in replacement for Node’s assert class.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.ifError', () => {
      const err = new Error('I am a custom error')
      assert.ifError(err) // Rethrows err!
    })
    ```
- name: Improving Performance
  id: guide/improving-performance
  summary: This greatly increases test times, which might not be desirable for projects that don't rely on side effects and properly cleanup their state (which is usually true for projects with node environment)
  description: "# Improving Performance\n\n## Test isolation\n\nBy default Vitest runs every test file in an isolated environment based on the [pool](../config/index#pool):\n\n- `threads` pool runs every test file in a separate [`Worker`](https://nodejs.org/api/worker_threads.html#class-worker)\n- `forks` pool runs every test file in a separate [forked child process](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)\n- `vmThreads` pool runs every test file in a separate [VM context](https://nodejs.org/api/vm.html#vmcreatecontextcontextobject-options), but it uses workers for parallelism\n\nThis greatly increases test times, which might not be desirable for projects that don't rely on side effects and properly cleanup their state (which is usually true for projects with `node` environment). In this case disabling isolation will improve the speed of your tests. To do that, you can provide `--no-isolate` flag to the CLI or set [`test.isolate`](../config/index#isolate) property in the config to `false`. If you are using several pools at once with `poolMatchGlobs`, you can also disable isolation for a specific pool you are using.\n\nCLIvitest.config.js\n\nbash\n\n``` javascript\nvitest --no-isolate\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    isolate: false,\n    // you can also disable isolation only for specific pools\n    poolOptions: {\n      forks: {\n        isolate: false,\n      },\n    },\n  },\n})\n```\n\n**TIP**\n\nIf you are using `vmThreads` pool, you cannot disable isolation. Use `threads` pool instead to improve your tests performance.\n\nFor some projects, it might also be desirable to disable parallelism to improve startup time. To do that, provide `--no-file-parallelism` flag to the CLI or set [`test.fileParallelism`](../config/index#fileparallelism) property in the config to `false`.\n\nCLIvitest.config.js\n\nbash\n\n``` javascript\nvitest --no-file-parallelism\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    fileParallelism: false,\n  },\n})\n```\n\n## Pool\n\nBy default Vitest runs tests in `pool: 'forks'`. While `'forks'` pool is better for compatibility issues ([hanging process](common-errors#failed-to-terminate-worker) and [segfaults](common-errors#segfaults-and-native-code-errors)), it may be slightly slower than `pool: 'threads'` in larger projects.\n\nYou can try to improve test run time by switching `pool` option in configuration:\n\nCLIvitest.config.js\n\nbash\n\n``` javascript\nvitest --pool=threads\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    pool: 'threads',\n  },\n})\n```\n\n## Sharding\n\nTest sharding means running a small subset of test cases at a time. It can be useful when you have multiple machines that could be used to run tests simultaneously.\n\nTo split Vitest tests on multiple different runs, use [`--shard`](cli#shard) option with [`--reporter=blob`](reporters#blob-reporter) option:\n\nsh\n\n``` javascript\nvitest run --reporter=blob --shard=1/3 # 1st machine\nvitest run --reporter=blob --shard=2/3 # 2nd machine\nvitest run --reporter=blob --shard=3/3 # 3rd machine\n```\n\nCollect the results stored in `.vitest-reports` directory from each machine and merge them with [`--merge-reports`](cli#merge-reports) option:\n\nsh\n\n``` javascript\nvitest --merge-reports\n```\n\nGithub action example\n\nThis setup is also used at [https://github.com/vitest-tests/test-sharding](https://github.com/vitest-tests/test-sharding).\n\nyaml\n\n``` javascript\n# Inspired from https://playwright.dev/docs/test-sharding\nname: Tests\non:\n  push:\n    branches:\n      - main\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        shardIndex: [1, 2, 3, 4]\n        shardTotal: [4]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n\n      - name: Install pnpm\n        uses: pnpm/action-setup@v4\n\n      - name: Install dependencies\n        run: pnpm i\n\n      - name: Run tests\n        run: pnpm run test --reporter=blob --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}\n\n      - name: Upload blob report to GitHub Actions Artifacts\n        if: ${{ !cancelled() }}\n        uses: actions/upload-artifact@v4\n        with:\n          name: blob-report-${{ matrix.shardIndex }}\n          path: .vitest-reports/*\n          retention-days: 1\n\n  merge-reports:\n    if: ${{ !cancelled() }}\n    needs: [tests]\n\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n\n      - name: Install pnpm\n        uses: pnpm/action-setup@v4\n\n      - name: Install dependencies\n        run: pnpm i\n\n      - name: Download blob reports from GitHub Actions Artifacts\n        uses: actions/download-artifact@v4\n        with:\n          path: .vitest-reports\n          pattern: blob-report-*\n          merge-multiple: true\n\n      - name: Merge reports\n        run: npx vitest --merge-reports\n```\n\n**TIP**\n\nTest sharding can also become useful on high CPU-count machines.\n\nVitest will run only a single Vite server in its main thread. Rest of the threads are used to run test files. In a high CPU-count machine the main thread can become a bottleneck as it cannot handle all the requests coming from the threads. For example in 32 CPU machine the main thread is responsible to handle load coming from 31 test threads.\n\nTo reduce the load from main thread's Vite server you can use test sharding. The load can be balanced on multiple Vite server.\n\nsh\n\n``` javascript\n# Example for splitting tests on 32 CPU to 4 shards.\n# As each process needs 1 main thread, there's 7 threads for test runners (1+7)*4 = 32\n# Use VITEST_MAX_THREADS or VITEST_MAX_FORKS depending on the pool:\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=1/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=2/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=3/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=4/4 & \\\nwait # https://man7.org/linux/man-pages/man2/waitpid.2.html\n\nvitest --merge-reports\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/improving-performance](https://vitest.dev/guide/improving-performance)"
- name: 'Improving Performance: Pool ​'
  id: guide/improving-performance#pool
  summary: 'By default Vitest runs tests in pool: ''forks''. While ''forks'' pool is better for compatibility issues (hanging process and segfaults), it may be slightly slower than pool: ''threads'' in larger projects'
  belongs_to: Improving Performance
  description: |-
    ## Pool

    By default Vitest runs tests in `pool: 'forks'`. While `'forks'` pool is better for compatibility issues ([hanging process](common-errors#failed-to-terminate-worker) and [segfaults](common-errors#segfaults-and-native-code-errors)), it may be slightly slower than `pool: 'threads'` in larger projects.

    You can try to improve test run time by switching `pool` option in configuration:

    CLI vitest.config.js

    bash

    ``` javascript
    vitest --pool=threads
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        pool: 'threads',
      },
    })
    ```
- name: 'Improving Performance: Sharding ​'
  id: guide/improving-performance#sharding
  summary: Test sharding means running a small subset of test cases at a time
  belongs_to: Improving Performance
  description: "## Sharding\n\nTest sharding means running a small subset of test cases at a time. It can be useful when you have multiple machines that could be used to run tests simultaneously.\n\nTo split Vitest tests on multiple different runs, use [`--shard`](cli#shard) option with [`--reporter=blob`](reporters#blob-reporter) option:\n\nsh\n\n``` javascript\nvitest run --reporter=blob --shard=1/3 # 1st machine\nvitest run --reporter=blob --shard=2/3 # 2nd machine\nvitest run --reporter=blob --shard=3/3 # 3rd machine\n```\n\nCollect the results stored in `.vitest-reports` directory from each machine and merge them with [`--merge-reports`](cli#merge-reports) option:\n\nsh\n\n``` javascript\nvitest --merge-reports\n```\n\nGithub action example\n\nThis setup is also used at [https://github.com/vitest-tests/test-sharding](https://github.com/vitest-tests/test-sharding).\n\nyaml\n\n``` javascript\n# Inspired from https://playwright.dev/docs/test-sharding\nname: Tests\non:\n  push:\n    branches:\n      - main\njobs:\n  tests:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        shardIndex: [1, 2, 3, 4]\n        shardTotal: [4]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n\n      - name: Install pnpm\n        uses: pnpm/action-setup@v4\n\n      - name: Install dependencies\n        run: pnpm i\n\n      - name: Run tests\n        run: pnpm run test --reporter=blob --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}\n\n      - name: Upload blob report to GitHub Actions Artifacts\n        if: ${{ !cancelled() }}\n        uses: actions/upload-artifact@v4\n        with:\n          name: blob-report-${{ matrix.shardIndex }}\n          path: .vitest-reports/*\n          retention-days: 1\n\n  merge-reports:\n    if: ${{ !cancelled() }}\n    needs: [tests]\n\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n\n      - name: Install pnpm\n        uses: pnpm/action-setup@v4\n\n      - name: Install dependencies\n        run: pnpm i\n\n      - name: Download blob reports from GitHub Actions Artifacts\n        uses: actions/download-artifact@v4\n        with:\n          path: .vitest-reports\n          pattern: blob-report-*\n          merge-multiple: true\n\n      - name: Merge reports\n        run: npx vitest --merge-reports\n```\n\n**TIP**\n\nTest sharding can also become useful on high CPU-count machines.\n\nVitest will run only a single Vite server in its main thread. Rest of the threads are used to run test files. In a high CPU-count machine the main thread can become a bottleneck as it cannot handle all the requests coming from the threads. For example in 32 CPU machine the main thread is responsible to handle load coming from 31 test threads.\n\nTo reduce the load from main thread's Vite server you can use test sharding. The load can be balanced on multiple Vite server.\n\nsh\n\n``` javascript\n# Example for splitting tests on 32 CPU to 4 shards.\n# As each process needs 1 main thread, there's 7 threads for test runners (1+7)*4 = 32\n# Use VITEST_MAX_THREADS or VITEST_MAX_FORKS depending on the pool:\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=1/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=2/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=3/4 & \\\nVITEST_MAX_THREADS=7 vitest run --reporter=blob --shard=4/4 & \\\nwait # https://man7.org/linux/man-pages/man2/waitpid.2.html\n\nvitest --merge-reports\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/improving-performance](https://vitest.dev/guide/improving-performance)"
- name: 'Improving Performance: Test isolation ​'
  id: guide/improving-performance#test-isolation
  summary: This greatly increases test times, which might not be desirable for projects that don't rely on side effects and properly cleanup their state (which is usually true for projects with node environment)
  belongs_to: Improving Performance
  description: |-
    ## Test isolation

    By default Vitest runs every test file in an isolated environment based on the [pool](../config/index#pool):

    - `threads` pool runs every test file in a separate [`Worker`](https://nodejs.org/api/worker_threads.html#class-worker)
    - `forks` pool runs every test file in a separate [forked child process](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options)
    - `vmThreads` pool runs every test file in a separate [VM context](https://nodejs.org/api/vm.html#vmcreatecontextcontextobject-options), but it uses workers for parallelism

    This greatly increases test times, which might not be desirable for projects that don't rely on side effects and properly cleanup their state (which is usually true for projects with `node` environment). In this case disabling isolation will improve the speed of your tests. To do that, you can provide `--no-isolate` flag to the CLI or set [`test.isolate`](../config/index#isolate) property in the config to `false`. If you are using several pools at once with `poolMatchGlobs`, you can also disable isolation for a specific pool you are using.

    CLI vitest.config.js

    bash

    ``` javascript
    vitest --no-isolate
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        isolate: false,
        // you can also disable isolation only for specific pools
        poolOptions: {
          forks: {
            isolate: false,
          },
        },
      },
    })
    ```

    **TIP**

    If you are using `vmThreads` pool, you cannot disable isolation. Use `threads` pool instead to improve your tests performance.

    For some projects, it might also be desirable to disable parallelism to improve startup time. To do that, provide `--no-file-parallelism` flag to the CLI or set [`test.fileParallelism`](../config/index#fileparallelism) property in the config to `false`.

    CLI vitest.config.js

    bash

    ``` javascript
    vitest --no-file-parallelism
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        fileParallelism: false,
      },
    })
    ```
- name: In-Source Testing
  id: guide/in-source
  summary: Vitest also provides a way to run tests within your source code along side the implementation, similar to Rust's module tests
  description: "# In-Source Testing\n\nVitest also provides a way to run tests within your source code along side the implementation, similar to [Rust's module tests](https://doc.rust-lang.org/book/ch11-03-test-organization.html#the-tests-module-and-cfgtest).\n\nThis makes the tests share the same closure as the implementations and able to test against private states without exporting. Meanwhile, it also brings a closer feedback loop for development.\n\n## Setup\n\nTo get started, put a `if (import.meta.vitest)` block at the end of your source file and write some tests inside it. For example:\n\nts\n\n``` javascript\n// src/index.ts\n\n// the implementation\nexport function add(...args: number[]) {\n  return args.reduce((a, b) => a + b, 0)\n}\n\n// in-source test suites\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n```\n\nUpdate the `includeSource` config for Vitest to grab the files under `src/`:\n\nts\n\n``` javascript\n// vite.config.ts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'], \n  },\n})\n```\n\nThen you can start to test!\n\nbash\n\n``` javascript\n$ npx vitest\n```\n\n## Production Build\n\nFor the production build, you will need to set the `define` options in your config file, letting the bundler do the dead code elimination. For example, in Vite\n\nts\n\n``` javascript\n// vite.config.ts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'],\n  },\n  define: { \n    'import.meta.vitest': 'undefined', \n  }, \n})\n```\n\n### Other Bundlers\n\nunbuild\n\nts\n\n``` javascript\n// build.config.ts\nimport { defineBuildConfig } from 'unbuild'\n\nexport default defineBuildConfig({\n  replace: { \n    'import.meta.vitest': 'undefined', \n  }, \n  // other options\n})\n```\n\nLearn more: [unbuild](https://github.com/unjs/unbuild)\n\nRollup\n\nts\n\n``` javascript\n// rollup.config.js\nimport replace from '@rollup/plugin-replace'\n\nexport default {\n  plugins: [\n    replace({ \n      'import.meta.vitest': 'undefined', \n    }) \n  ],\n  // other options\n}\n```\n\nLearn more: [Rollup](https://rollupjs.org/)\n\n## TypeScript\n\nTo get TypeScript support for `import.meta.vitest`, add `vitest/importMeta` to your `tsconfig.json`:\n\njson\n\n``` javascript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"vitest/importMeta\"\n    ]\n  }\n}\n```\n\nReference to [`test/import-meta`](https://github.com/vitest-dev/vitest/tree/main/test/import-meta) for the full example.\n\n## Notes\n\nThis feature could be useful for:\n\n- Unit testing for small-scoped functions or utilities\n- Prototyping\n- Inline Assertion\n\nIt's recommended to **use separate test files instead** for more complex tests like components or E2E testing.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/in-source](https://vitest.dev/guide/in-source)"
- name: 'In-Source Testing: Notes ​'
  id: guide/in-source#notes
  summary: It's recommended to use separate test files instead for more complex tests like components or E2E testing
  belongs_to: In-Source Testing
  description: "## Notes\n\nThis feature could be useful for:\n\n- Unit testing for small-scoped functions or utilities\n- Prototyping\n- Inline Assertion\n\nIt's recommended to **use separate test files instead** for more complex tests like components or E2E testing.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/in-source](https://vitest.dev/guide/in-source)"
- name: 'In-Source Testing: Other Bundlers ​'
  id: guide/in-source#other-bundlers
  summary: null
  belongs_to: In-Source Testing
  description: "### Other Bundlers\n\nunbuild\n\nts\n\n``` javascript\n// build.config.ts\nimport { defineBuildConfig } from 'unbuild'\n\nexport default defineBuildConfig({\n  replace: { \n    'import.meta.vitest': 'undefined', \n  }, \n  // other options\n})\n```\n\nLearn more: [unbuild](https://github.com/unjs/unbuild)\n\nRollup\n\nts\n\n``` javascript\n// rollup.config.js\nimport replace from '@rollup/plugin-replace'\n\nexport default {\n  plugins: [\n    replace({ \n      'import.meta.vitest': 'undefined', \n    }) \n  ],\n  // other options\n}\n```\n\nLearn more: [Rollup](https://rollupjs.org/)"
- name: 'In-Source Testing: Production Build ​'
  id: guide/in-source#production-build
  summary: For the production build, you will need to set the define options in your config file, letting the bundler do the dead code elimination
  belongs_to: In-Source Testing
  description: "## Production Build\n\nFor the production build, you will need to set the `define` options in your config file, letting the bundler do the dead code elimination. For example, in Vite\n\nts\n\n``` javascript\n// vite.config.ts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'],\n  },\n  define: { \n    'import.meta.vitest': 'undefined', \n  }, \n})\n```"
- name: 'In-Source Testing: Setup ​'
  id: guide/in-source#setup
  summary: To get started, put a if (import.meta.vitest) block at the end of your source file and write some tests inside it
  belongs_to: In-Source Testing
  description: "## Setup\n\nTo get started, put a `if (import.meta.vitest)` block at the end of your source file and write some tests inside it. For example:\n\nts\n\n``` javascript\n// src/index.ts\n\n// the implementation\nexport function add(...args: number[]) {\n  return args.reduce((a, b) => a + b, 0)\n}\n\n// in-source test suites\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n```\n\nUpdate the `includeSource` config for Vitest to grab the files under `src/`:\n\nts\n\n``` javascript\n// vite.config.ts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'], \n  },\n})\n```\n\nThen you can start to test!\n\nbash\n\n``` javascript\n$ npx vitest\n```"
- name: 'In-Source Testing: TypeScript ​'
  id: guide/in-source#typescript
  summary: Reference to test/import-meta for the full example
  belongs_to: In-Source Testing
  description: |-
    ## TypeScript

    To get TypeScript support for `import.meta.vitest`, add `vitest/importMeta` to your `tsconfig.json`:

    json

    ``` javascript
    // tsconfig.json
    {
      "compilerOptions": {
        "types": [
          "vitest/importMeta"
        ]
      }
    }
    ```

    Reference to [`test/import-meta`](https://github.com/vitest-dev/vitest/tree/main/test/import-meta) for the full example.
- name: include ​
  id: api/assert#include
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## include

    - **Type:**
      - `(haystack: string, needle: string, message?: string) => void`
      - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`
      - `<T extends object>(haystack: WeakSet<T>, needle: T, message?: string) => void`
      - `<T>(haystack: T, needle: Partial<T>, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a value in an array, a substring in a string, or a subset of properties in an object.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.include', () => {
      assert.include([1, 2, 3], 2, 'array contains value')
      assert.include('foobar', 'foo', 'string contains substring')
      assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property')
    })
    ```
- name: include ​
  id: config/index#include
  summary: A list of glob patterns that match your test files
  belongs_to: Configuring Vitest
  description: |-
    ### include

    - **Type:** `string[]`
    - **Default:** `['**/*.{test,spec}.?(c|m)[jt]s?(x)']`
    - **CLI:**`vitest [...include]`, `vitest **/*.test.js`

    A list of glob patterns that match your test files.

    **NOTE**

    When using coverage, Vitest automatically adds test files `include` patterns to coverage's default `exclude` patterns. See [`coverage.exclude`](#coverage-exclude).
- name: includeDeepMembers ​
  id: api/assert#includedeepmembers
  summary: Asserts that subset is included in superset in any order
  belongs_to: assert
  description: |-
    ## includeDeepMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` is included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.includeDeepMembers', () => {
      assert.includeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { b: 2 }], 'include deep members')
    })
    ```
- name: includeDeepOrderedMembers ​
  id: api/assert#includedeeporderedmembers
  summary: Asserts that subset is included in superset in the same order beginning with the first element in superset
  belongs_to: assert
  description: |-
    ## includeDeepOrderedMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.includeDeepOrderedMembers', () => {
      assert.includeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }], 'include deep ordered members')
    })
    ```
- name: includeMembers ​
  id: api/assert#includemembers
  summary: Asserts that subset is included in superset in any order
  belongs_to: assert
  description: |-
    ## includeMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` is included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.includeMembers', () => {
      assert.includeMembers([1, 2, 3], [2, 1, 2], 'include members')
    })
    ```
- name: includeOrderedMembers ​
  id: api/assert#includeorderedmembers
  summary: Asserts that subset is included in superset in the same order beginning with the first element in superset
  belongs_to: assert
  description: |-
    ## includeOrderedMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` is included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.includeOrderedMembers', () => {
      assert.includeOrderedMembers([1, 2, 3], [1, 2], 'include ordered members')
    })
    ```
- name: includeSource ​
  id: config/index#includesource
  summary: Include globs for in-source test files
  belongs_to: Configuring Vitest
  description: |-
    ### includeSource

    - **Type:** `string[]`
    - **Default:** `[]`

    Include globs for in-source test files.

    When defined, Vitest will run all matched files with `import.meta.vitest` inside.
- name: includeTaskLocation ​
  id: config/index#includeTaskLocation
  summary: Should location property be included when Vitest API receives tasks in reporters
  belongs_to: Configuring Vitest
  description: |-
    ### includeTaskLocation

    - **Type:** `boolean`
    - **Default:** `false`

    Should `location` property be included when Vitest API receives tasks in [reporters](#reporters). If you have a lot of tests, this might cause a small performance regression.

    The `location` property has `column` and `line` values that correspond to the `test` or `describe` position in the original file.

    This option will be auto-enabled if you don't disable it explicitly, and you are running Vitest with:

    - [Vitest UI](../guide/ui)
    - or using the [Browser Mode](../guide/browser/index) without [headless](../guide/browser/index#headless) mode
    - or using [HTML Reporter](../guide/reporters#html-reporter)

    **TIP**

    This option has no effect if you do not use custom code that relies on this.
- name: increases ​
  id: api/assert#increases
  summary: Asserts that a modifier increases a numeric object's property
  belongs_to: assert
  description: |-
    ## increases

    - **Type:** `<T>(modifier: Function, object: T, property: string, message?: string) => void`

    Asserts that a `modifier` increases a numeric `object`'s `property`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.increases', () => {
      const obj = { val: 10 }
      function fn() { obj.val = 13 };
      assert.increases(fn, obj, 'val')
    })
    ```
- name: increasesButNotBy ​
  id: api/assert#increasesbutnotby
  summary: Asserts that a modifier does not increases a numeric object's property or a modifier return value by an change
  belongs_to: assert
  description: |-
    ## increasesButNotBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`

    Asserts that a `modifier` does not increases a numeric `object`'s `property` or a `modifier` return value by an `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.increasesButNotBy', () => {
      const obj = { val: 10 }
      function fn() { obj.val += 15 };
      assert.increasesButNotBy(fn, obj, 'val', 10)
    })
    ```
- name: increasesBy ​
  id: api/assert#increasesby
  summary: Asserts that a modifier increases a numeric object's property or a modifier return value by an change
  belongs_to: assert
  description: |-
    ## increasesBy

    - **Type:** `<T>(modifier: Function, object: T, property: string, change: number, message?: string) => void`

    Asserts that a `modifier` increases a numeric `object`'s `property` or a `modifier` return value by an `change`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.increases', () => {
      const obj = { val: 10 }
      function fn() { obj.val += 10 };
      assert.increases(fn, obj, 'val', 10)
    })
    ```
- name: instance ​
  id: api/expect-typeof#instance
  summary: This property gives access to matchers that can be performed on an instance of the provided class
  belongs_to: expectTypeOf
  description: |-
    ## instance

    - **Type:** `ExpectTypeOf<ConstructableInstance>`

    This property gives access to matchers that can be performed on an instance of the provided class.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(Date).instance.toHaveProperty('toISOString')
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.
- name: instanceOf ​
  id: api/assert#instanceof
  summary: Asserts that value is an instance of constructor
  belongs_to: assert
  description: |-
    ## instanceOf

    - **Type:** `<T>(value: T, constructor: Function, message?: string) => void`

    Asserts that `value` is an instance of `constructor`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    function Person(name) { this.name = name }
    const foo = new Person('foo')

    class Tea {
      constructor(name) {
        this.name = name
      }
    }
    const coffee = new Tea('coffee')

    test('assert.instanceOf', () => {
      assert.instanceOf(foo, Person, 'foo is an instance of Person')
      assert.instanceOf(coffee, Tea, 'coffee is an instance of Tea')
    })
    ```
- name: Interactivity API
  id: guide/browser/interactivity-api
  summary: Vitest implements a subset of @testing-library/user-event APIs using Chrome DevTools Protocol or webdriver APIs instead of faking events which makes the browser behaviour more reliable and consistent with how users interact with a page
  description: "# Interactivity API\n\nVitest implements a subset of [`@testing-library/user-event`](https://testing-library.com/docs/user-event) APIs using [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/) or [webdriver](https://www.w3.org/TR/webdriver/) APIs instead of faking events which makes the browser behaviour more reliable and consistent with how users interact with a page.\n\nAlmost every `userEvent` method inherits its provider options. To see all available options in your IDE, add `webdriver` or `playwright` types to your `tsconfig.json` file:\n\nplaywrightwebdriverio\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/playwright\"\n    ]\n  }\n}\n```\n\njson\n\n``` javascript\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/webdriverio\"\n    ]\n  }\n}\n```\n\n## userEvent.click\n\n- **Type:** `(element: Element, options?: UserEventClickOptions) => Promise<void>`\n\nClick on an element. Inherits provider's options. Please refer to your provider's documentation for detailed explanation about how this method works.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('clicks on an element', async () => {\n  const logo = screen.getByRole('img', { name: /logo/ })\n\n  await userEvent.click(logo)\n})\n```\n\nReferences:\n\n- [Playwright `locator.click` API](https://playwright.dev/docs/api/class-locator#locator-click)\n- [WebdriverIO `element.click` API](https://webdriver.io/docs/api/element/click/)\n- [testing-library `click` API](https://testing-library.com/docs/user-event/convenience/#click)\n\n## userEvent.dblClick\n\n- **Type:** `(element: Element, options?: UserEventDoubleClickOptions) => Promise<void>`\n\nTriggers a double click event on an element.\n\nPlease refer to your provider's documentation for detailed explanation about how this method works.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('triggers a double click on an element', async () => {\n  const logo = screen.getByRole('img', { name: /logo/ })\n\n  await userEvent.dblClick(logo)\n})\n```\n\nReferences:\n\n- [Playwright `locator.dblclick` API](https://playwright.dev/docs/api/class-locator#locator-dblclick)\n- [WebdriverIO `element.doubleClick` API](https://webdriver.io/docs/api/element/doubleClick/)\n- [testing-library `dblClick` API](https://testing-library.com/docs/user-event/convenience/#dblClick)\n\n## userEvent.tripleClick\n\n- **Type:** `(element: Element, options?: UserEventTripleClickOptions) => Promise<void>`\n\nTriggers a triple click event on an element. Since there is no `tripleclick` in browser api, this method will fire three click events in a row, and so you must check [click event detail](https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#usage_notes) to filter the event: `evt.detail === 3`.\n\nPlease refer to your provider's documentation for detailed explanation about how this method works.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('triggers a triple click on an element', async () => {\n  const logo = screen.getByRole('img', { name: /logo/ })\n  let tripleClickFired = false\n  logo.addEventListener('click', (evt) => {\n    if (evt.detail === 3) {\n      tripleClickFired = true\n    }\n  })\n\n  await userEvent.tripleClick(logo)\n  expect(tripleClickFired).toBe(true)\n})\n```\n\nReferences:\n\n- [Playwright `locator.click` API](https://playwright.dev/docs/api/class-locator#locator-click): implemented via `click` with `clickCount: 3` .\n- [WebdriverIO `browser.action` API](https://webdriver.io/docs/api/browser/action/): implemented via actions api with `move` plus three `down + up + pause` events in a row\n- [testing-library `tripleClick` API](https://testing-library.com/docs/user-event/convenience/#tripleClick)\n\n## userEvent.fill\n\n- **Type:** `(element: Element, text: string) => Promise<void>`\n\nFill an `input/textarea/conteneditable` element with text. This will remove any existing text in the input before typing the new value.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('update input', async () => {\n  const input = screen.getByRole('input')\n\n  await userEvent.fill(input, 'foo') // input.value == foo\n  await userEvent.fill(input, '{{a[[') // input.value == {{a[[\n  await userEvent.fill(input, '{Shift}') // input.value == {Shift}\n})\n```\n\n**TIP**\n\nThis API is faster than using [`userEvent.type`](#userevent-type) or [`userEvent.keyboard`](#userevent-keyboard), but it **doesn't support** [user-event `keyboard` syntax](https://testing-library.com/docs/user-event/keyboard) (e.g., `{Shift}{selectall}`).\n\nWe recommend using this API over [`userEvent.type`](#userevent-type) in situations when you don't need to enter special characters.\n\nReferences:\n\n- [Playwright `locator.fill` API](https://playwright.dev/docs/api/class-locator#locator-fill)\n- [WebdriverIO `element.setValue` API](https://webdriver.io/docs/api/element/setValue)\n- [testing-library `type` API](https://testing-library.com/docs/user-event/utility/#type)\n\n## userEvent.keyboard\n\n- **Type:** `(text: string) => Promise<void>`\n\nThe `userEvent.keyboard` allows you to trigger keyboard strokes. If any input has a focus, it will type characters into that input. Otherwise, it will trigger keyboard events on the currently focused element (`document.body` if there are no focused elements).\n\nThis API supports [user-event `keyboard` syntax](https://testing-library.com/docs/user-event/keyboard).\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('trigger keystrokes', async () => {\n  await userEvent.keyboard('foo') // translates to: f, o, o\n  await userEvent.keyboard('{{a[[') // translates to: {, a, [\n  await userEvent.keyboard('{Shift}{f}{o}{o}') // translates to: Shift, f, o, o\n  await userEvent.keyboard('{a>5}') // press a without releasing it and trigger 5 keydown\n  await userEvent.keyboard('{a>5/}') // press a for 5 keydown and then release it\n})\n```\n\nReferences:\n\n- [Playwright `locator.press` API](https://playwright.dev/docs/api/class-locator#locator-press)\n- [WebdriverIO `action('key')` API](https://webdriver.io/docs/api/browser/action#key-input-source)\n- [testing-library `type` API](https://testing-library.com/docs/user-event/utility/#type)\n\n## userEvent.tab\n\n- **Type:** `(options?: UserEventTabOptions) => Promise<void>`\n\nSends a `Tab` key event. This is a shorthand for `userEvent.keyboard('{tab}')`.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('tab works', async () => {\n  const [input1, input2] = screen.getAllByRole('input')\n\n  expect(input1).toHaveFocus()\n\n  await userEvent.tab()\n\n  expect(input2).toHaveFocus()\n\n  await userEvent.tab({ shift: true })\n\n  expect(input1).toHaveFocus()\n})\n```\n\nReferences:\n\n- [Playwright `locator.press` API](https://playwright.dev/docs/api/class-locator#locator-press)\n- [WebdriverIO `action('key')` API](https://webdriver.io/docs/api/browser/action#key-input-source)\n- [testing-library `tab` API](https://testing-library.com/docs/user-event/convenience/#tab)\n\n## userEvent.type\n\n- **Type:** `(element: Element, text: string, options?: UserEventTypeOptions) => Promise<void>`\n\n**WARNING**\n\nIf you don't rely on [special characters](https://testing-library.com/docs/user-event/keyboard) (e.g., `{shift}` or `{selectall}`), it is recommended to use [`userEvent.fill`](#userevent-fill) instead.\n\nThe `type` method implements `@testing-library/user-event`'s [`type`](https://testing-library.com/docs/user-event/utility/#type) utility built on top of [`keyboard`](https://testing-library.com/docs/user-event/keyboard) API.\n\nThis function allows you to type characters into an input/textarea/conteneditable element. It supports [user-event `keyboard` syntax](https://testing-library.com/docs/user-event/keyboard).\n\nIf you just need to press characters without an input, use [`userEvent.keyboard`](#userevent-keyboard) API.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('update input', async () => {\n  const input = screen.getByRole('input')\n\n  await userEvent.type(input, 'foo') // input.value == foo\n  await userEvent.type(input, '{{a[[') // input.value == foo{a[\n  await userEvent.type(input, '{Shift}') // input.value == foo{a[\n})\n```\n\nReferences:\n\n- [Playwright `locator.press` API](https://playwright.dev/docs/api/class-locator#locator-press)\n- [WebdriverIO `action('key')` API](https://webdriver.io/docs/api/browser/action#key-input-source)\n- [testing-library `type` API](https://testing-library.com/docs/user-event/utility/#type)\n\n## userEvent.clear\n\n- **Type:** `(element: Element) => Promise<void>`\n\nThis method clears the input element content.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('clears input', async () => {\n  const input = screen.getByRole('input')\n\n  await userEvent.fill(input, 'foo')\n  expect(input).toHaveValue('foo')\n\n  await userEvent.clear(input)\n  expect(input).toHaveValue('')\n})\n```\n\nReferences:\n\n- [Playwright `locator.clear` API](https://playwright.dev/docs/api/class-locator#locator-clear)\n- [WebdriverIO `element.clearValue` API](https://webdriver.io/docs/api/element/clearValue)\n- [testing-library `clear` API](https://testing-library.com/docs/user-event/utility/#clear)\n\n## userEvent.selectOptions\n\n- **Type:** `(element: Element, values: HTMLElement | HTMLElement[] | string | string[], options?: UserEventSelectOptions) => Promise<void>`\n\nThe `userEvent.selectOptions` allows selecting a value in a `<select>` element.\n\n**WARNING**\n\nIf select element doesn't have [`multiple`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#attr-multiple) attribute, Vitest will select only the first element in the array.\n\nUnlike `@testing-library`, Vitest doesn't support [listbox](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role) at the moment, but we plan to add support for it in the future.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('clears input', async () => {\n  const select = screen.getByRole('select')\n\n  await userEvent.selectOptions(select, 'Option 1')\n  expect(select).toHaveValue('option-1')\n\n  await userEvent.selectOptions(select, 'option-1')\n  expect(select).toHaveValue('option-1')\n\n  await userEvent.selectOptions(select, [\n    screen.getByRole('option', { name: 'Option 1' }),\n    screen.getByRole('option', { name: 'Option 2' }),\n  ])\n  expect(select).toHaveValue(['option-1', 'option-2'])\n})\n```\n\n**WARNING**\n\n`webdriverio` provider doesn't support selecting multiple elements because it doesn't provide API to do so.\n\nReferences:\n\n- [Playwright `locator.selectOption` API](https://playwright.dev/docs/api/class-locator#locator-select-option)\n- [WebdriverIO `element.selectByIndex` API](https://webdriver.io/docs/api/element/selectByIndex)\n- [testing-library `selectOptions` API](https://testing-library.com/docs/user-event/utility/#-selectoptions-deselectoptions)\n\n## userEvent.hover\n\n- **Type:** `(element: Element, options?: UserEventHoverOptions) => Promise<void>`\n\nThis method moves the cursor position to the selected element. Please refer to your provider's documentation for detailed explanation about how this method works.\n\n**WARNING**\n\nIf you are using `webdriverio` provider, the cursor will move to the center of the element by default.\n\nIf you are using `playwright` provider, the cursor moves to \"some\" visible point of the element.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('hovers logo element', async () => {\n  const logo = screen.getByRole('img', { name: /logo/ })\n\n  await userEvent.hover(logo)\n})\n```\n\nReferences:\n\n- [Playwright `locator.hover` API](https://playwright.dev/docs/api/class-locator#locator-hover)\n- [WebdriverIO `element.moveTo` API](https://webdriver.io/docs/api/element/moveTo/)\n- [testing-library `hover` API](https://testing-library.com/docs/user-event/convenience/#hover)\n\n## userEvent.unhover\n\n- **Type:** `(element: Element, options?: UserEventHoverOptions) => Promise<void>`\n\nThis works the same as [`userEvent.hover`](#userevent-hover), but moves the cursor to the `document.body` element instead.\n\n**WARNING**\n\nBy default, the cursor position is in the center (in `webdriverio` provider) or in \"some\" visible place (in `playwright` provider) of the body element, so if the currently hovered element is already in the same position, this method will have no effect.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\n\ntest('unhover logo element', async () => {\n  const logo = screen.getByRole('img', { name: /logo/ })\n\n  await userEvent.unhover(logo)\n})\n```\n\nReferences:\n\n- [Playwright `locator.hover` API](https://playwright.dev/docs/api/class-locator#locator-hover)\n- [WebdriverIO `element.moveTo` API](https://webdriver.io/docs/api/element/moveTo/)\n- [testing-library `hover` API](https://testing-library.com/docs/user-event/convenience/#hover)\n\n## userEvent.dragAndDrop\n\n- **Type:** `(source: Element, target: Element, options?: UserEventDragAndDropOptions) => Promise<void>`\n\nDrags the source element on top of the target element. Don't forget that the `source` element has to have the `draggable` attribute set to `true`.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\nimport '@testing-library/jest-dom' // adds support for \"toHaveTextContent\"\n\ntest('drag and drop works', async () => {\n  const source = screen.getByRole('img', { name: /logo/ })\n  const target = screen.getByTestId('logo-target')\n\n  await userEvent.dragAndDrop(source, target)\n\n  expect(target).toHaveTextContent('Logo is processed')\n})\n```\n\n**WARNING**\n\nThis API is not supported by the default `preview` provider.\n\nReferences:\n\n- [Playwright `frame.dragAndDrop` API](https://playwright.dev/docs/api/class-frame#frame-drag-and-drop)\n- [WebdriverIO `element.dragAndDrop` API](https://webdriver.io/docs/api/element/dragAndDrop/)\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/interactivity-api](https://vitest.dev/guide/browser/interactivity-api)"
- name: 'Interactivity API: userEvent.clear ​'
  id: guide/browser/interactivity-api#userevent-clear
  summary: This method clears the input element content
  belongs_to: Interactivity API
  description: |-
    ## userEvent.clear

    - **Type:** `(element: Element) => Promise<void>`

    This method clears the input element content.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('clears input', async () => {
      const input = screen.getByRole('input')

      await userEvent.fill(input, 'foo')
      expect(input).toHaveValue('foo')

      await userEvent.clear(input)
      expect(input).toHaveValue('')
    })
    ```

    References:

    - [Playwright `locator.clear` API](https://playwright.dev/docs/api/class-locator#locator-clear)
    - [WebdriverIO `element.clearValue` API](https://webdriver.io/docs/api/element/clearValue)
    - [testing-library `clear` API](https://testing-library.com/docs/user-event/utility/#clear)

    &nbsp;
- name: 'Interactivity API: userEvent.click ​'
  id: guide/browser/interactivity-api#userevent-click
  summary: Click on an element
  belongs_to: Interactivity API
  description: |-
    ## userEvent.click

    - **Type:** `(element: Element, options?: UserEventClickOptions) => Promise<void>`

    Click on an element. Inherits provider's options. Please refer to your provider's documentation for detailed explanation about how this method works.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('clicks on an element', async () => {
      const logo = screen.getByRole('img', { name: /logo/ })

      await userEvent.click(logo)
    })
    ```

    References:

    - [Playwright `locator.click` API](https://playwright.dev/docs/api/class-locator#locator-click)
    - [WebdriverIO `element.click` API](https://webdriver.io/docs/api/element/click/)
    - [testing-library `click` API](https://testing-library.com/docs/user-event/convenience/#click)
- name: 'Interactivity API: userEvent.dblClick ​'
  id: guide/browser/interactivity-api#userevent-dblclick
  summary: Triggers a double click event on an element
  belongs_to: Interactivity API
  description: |-
    ## userEvent.dblClick

    - **Type:** `(element: Element, options?: UserEventDoubleClickOptions) => Promise<void>`

    Triggers a double click event on an element.

    Please refer to your provider's documentation for detailed explanation about how this method works.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('triggers a double click on an element', async () => {
      const logo = screen.getByRole('img', { name: /logo/ })

      await userEvent.dblClick(logo)
    })
    ```

    References:

    - [Playwright `locator.dblclick` API](https://playwright.dev/docs/api/class-locator#locator-dblclick)
    - [WebdriverIO `element.doubleClick` API](https://webdriver.io/docs/api/element/doubleClick/)
    - [testing-library `dblClick` API](https://testing-library.com/docs/user-event/convenience/#dblClick)

    &nbsp;
- name: 'Interactivity API: userEvent.dragAndDrop ​'
  id: guide/browser/interactivity-api#userevent-draganddrop
  summary: Drags the source element on top of the target element
  belongs_to: Interactivity API
  description: "## userEvent.dragAndDrop\n\n- **Type:** `(source: Element, target: Element, options?: UserEventDragAndDropOptions) => Promise<void>`\n\nDrags the source element on top of the target element. Don't forget that the `source` element has to have the `draggable` attribute set to `true`.\n\nts\n\n``` javascript\nimport { userEvent } from '@vitest/browser/context'\nimport { screen } from '@testing-library/dom'\nimport '@testing-library/jest-dom' // adds support for \"toHaveTextContent\"\n\ntest('drag and drop works', async () => {\n  const source = screen.getByRole('img', { name: /logo/ })\n  const target = screen.getByTestId('logo-target')\n\n  await userEvent.dragAndDrop(source, target)\n\n  expect(target).toHaveTextContent('Logo is processed')\n})\n```\n\n**WARNING**\n\nThis API is not supported by the default `preview` provider.\n\nReferences:\n\n- [Playwright `frame.dragAndDrop` API](https://playwright.dev/docs/api/class-frame#frame-drag-and-drop)\n- [WebdriverIO `element.dragAndDrop` API](https://webdriver.io/docs/api/element/dragAndDrop/)\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/interactivity-api](https://vitest.dev/guide/browser/interactivity-api)"
- name: 'Interactivity API: userEvent.fill ​'
  id: guide/browser/interactivity-api#userevent-fill
  summary: Fill an input/textarea/conteneditable element with text
  belongs_to: Interactivity API
  description: |-
    ## userEvent.fill

    - **Type:** `(element: Element, text: string) => Promise<void>`

    Fill an `input/textarea/conteneditable` element with text. This will remove any existing text in the input before typing the new value.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('update input', async () => {
      const input = screen.getByRole('input')

      await userEvent.fill(input, 'foo') // input.value == foo
      await userEvent.fill(input, '{{a[[') // input.value == {{a[[
      await userEvent.fill(input, '{Shift}') // input.value == {Shift}
    })
    ```

    **TIP**

    This API is faster than using [`userEvent.type`](#userevent-type) or [`userEvent.keyboard`](#userevent-keyboard), but it **doesn't support** [user-event `keyboard` syntax](https://testing-library.com/docs/user-event/keyboard) (e.g., `{Shift}{selectall}`).

    We recommend using this API over [`userEvent.type`](#userevent-type) in situations when you don't need to enter special characters.

    References:

    - [Playwright `locator.fill` API](https://playwright.dev/docs/api/class-locator#locator-fill)
    - [WebdriverIO `element.setValue` API](https://webdriver.io/docs/api/element/setValue)
    - [testing-library `type` API](https://testing-library.com/docs/user-event/utility/#type)

    &nbsp;
- name: 'Interactivity API: userEvent.hover ​'
  id: guide/browser/interactivity-api#userevent-hover
  summary: This method moves the cursor position to the selected element
  belongs_to: Interactivity API
  description: |-
    ## userEvent.hover

    - **Type:** `(element: Element, options?: UserEventHoverOptions) => Promise<void>`

    This method moves the cursor position to the selected element. Please refer to your provider's documentation for detailed explanation about how this method works.

    **WARNING**

    If you are using `webdriverio` provider, the cursor will move to the center of the element by default.

    If you are using `playwright` provider, the cursor moves to "some" visible point of the element.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('hovers logo element', async () => {
      const logo = screen.getByRole('img', { name: /logo/ })

      await userEvent.hover(logo)
    })
    ```

    References:

    - [Playwright `locator.hover` API](https://playwright.dev/docs/api/class-locator#locator-hover)
    - [WebdriverIO `element.moveTo` API](https://webdriver.io/docs/api/element/moveTo/)
    - [testing-library `hover` API](https://testing-library.com/docs/user-event/convenience/#hover)

    &nbsp;
- name: 'Interactivity API: userEvent.keyboard ​'
  id: guide/browser/interactivity-api#userevent-keyboard
  summary: The userEvent.keyboard allows you to trigger keyboard strokes
  belongs_to: Interactivity API
  description: |-
    ## userEvent.keyboard

    - **Type:** `(text: string) => Promise<void>`

    The `userEvent.keyboard` allows you to trigger keyboard strokes. If any input has a focus, it will type characters into that input. Otherwise, it will trigger keyboard events on the currently focused element (`document.body` if there are no focused elements).

    This API supports [user-event `keyboard` syntax](https://testing-library.com/docs/user-event/keyboard).

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('trigger keystrokes', async () => {
      await userEvent.keyboard('foo') // translates to: f, o, o
      await userEvent.keyboard('{{a[[') // translates to: {, a, [
      await userEvent.keyboard('{Shift}{f}{o}{o}') // translates to: Shift, f, o, o
      await userEvent.keyboard('{a>5}') // press a without releasing it and trigger 5 keydown
      await userEvent.keyboard('{a>5/}') // press a for 5 keydown and then release it
    })
    ```

    References:

    - [Playwright `locator.press` API](https://playwright.dev/docs/api/class-locator#locator-press)
    - [WebdriverIO `action('key')` API](https://webdriver.io/docs/api/browser/action#key-input-source)
    - [testing-library `type` API](https://testing-library.com/docs/user-event/utility/#type)

    &nbsp;
- name: 'Interactivity API: userEvent.selectOptions ​'
  id: guide/browser/interactivity-api#userevent-selectoptions
  summary: The userEvent.selectOptions allows selecting a value in a <select> element
  belongs_to: Interactivity API
  description: |-
    ## userEvent.selectOptions

    - **Type:** `(element: Element, values: HTMLElement | HTMLElement[] | string | string[], options?: UserEventSelectOptions) => Promise<void>`

    The `userEvent.selectOptions` allows selecting a value in a `<select>` element.

    **WARNING**

    If select element doesn't have [`multiple`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#attr-multiple) attribute, Vitest will select only the first element in the array.

    Unlike `@testing-library`, Vitest doesn't support [listbox](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role) at the moment, but we plan to add support for it in the future.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('clears input', async () => {
      const select = screen.getByRole('select')

      await userEvent.selectOptions(select, 'Option 1')
      expect(select).toHaveValue('option-1')

      await userEvent.selectOptions(select, 'option-1')
      expect(select).toHaveValue('option-1')

      await userEvent.selectOptions(select, [
        screen.getByRole('option', { name: 'Option 1' }),
        screen.getByRole('option', { name: 'Option 2' }),
      ])
      expect(select).toHaveValue(['option-1', 'option-2'])
    })
    ```

    **WARNING**

    `webdriverio` provider doesn't support selecting multiple elements because it doesn't provide API to do so.

    References:

    - [Playwright `locator.selectOption` API](https://playwright.dev/docs/api/class-locator#locator-select-option)
    - [WebdriverIO `element.selectByIndex` API](https://webdriver.io/docs/api/element/selectByIndex)
    - [testing-library `selectOptions` API](https://testing-library.com/docs/user-event/utility/#-selectoptions-deselectoptions)

    &nbsp;
- name: 'Interactivity API: userEvent.tab ​'
  id: guide/browser/interactivity-api#userevent-tab
  summary: Sends a Tab key event
  belongs_to: Interactivity API
  description: |-
    ## userEvent.tab

    - **Type:** `(options?: UserEventTabOptions) => Promise<void>`

    Sends a `Tab` key event. This is a shorthand for `userEvent.keyboard('{tab}')`.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('tab works', async () => {
      const [input1, input2] = screen.getAllByRole('input')

      expect(input1).toHaveFocus()

      await userEvent.tab()

      expect(input2).toHaveFocus()

      await userEvent.tab({ shift: true })

      expect(input1).toHaveFocus()
    })
    ```

    References:

    - [Playwright `locator.press` API](https://playwright.dev/docs/api/class-locator#locator-press)
    - [WebdriverIO `action('key')` API](https://webdriver.io/docs/api/browser/action#key-input-source)
    - [testing-library `tab` API](https://testing-library.com/docs/user-event/convenience/#tab)

    &nbsp;
- name: 'Interactivity API: userEvent.tripleClick ​'
  id: guide/browser/interactivity-api#userevent-tripleclick
  summary: Triggers a triple click event on an element
  belongs_to: Interactivity API
  description: |-
    ## userEvent.tripleClick

    - **Type:** `(element: Element, options?: UserEventTripleClickOptions) => Promise<void>`

    Triggers a triple click event on an element. Since there is no `tripleclick` in browser api, this method will fire three click events in a row, and so you must check [click event detail](https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#usage_notes) to filter the event: `evt.detail === 3`.

    Please refer to your provider's documentation for detailed explanation about how this method works.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('triggers a triple click on an element', async () => {
      const logo = screen.getByRole('img', { name: /logo/ })
      let tripleClickFired = false
      logo.addEventListener('click', (evt) => {
        if (evt.detail === 3) {
          tripleClickFired = true
        }
      })

      await userEvent.tripleClick(logo)
      expect(tripleClickFired).toBe(true)
    })
    ```

    References:

    - [Playwright `locator.click` API](https://playwright.dev/docs/api/class-locator#locator-click): implemented via `click` with `clickCount: 3` .
    - [WebdriverIO `browser.action` API](https://webdriver.io/docs/api/browser/action/): implemented via actions api with `move` plus three `down + up + pause` events in a row
    - [testing-library `tripleClick` API](https://testing-library.com/docs/user-event/convenience/#tripleClick)

    &nbsp;
- name: 'Interactivity API: userEvent.type ​'
  id: guide/browser/interactivity-api#userevent-type
  summary: If you don't rely on special characters (e.g., {shift} or {selectall}), it is recommended to use userEvent.fill instead
  belongs_to: Interactivity API
  description: |-
    ## userEvent.type

    - **Type:** `(element: Element, text: string, options?: UserEventTypeOptions) => Promise<void>`

    **WARNING**

    If you don't rely on [special characters](https://testing-library.com/docs/user-event/keyboard) (e.g., `{shift}` or `{selectall}`), it is recommended to use [`userEvent.fill`](#userevent-fill) instead.

    The `type` method implements `@testing-library/user-event`'s [`type`](https://testing-library.com/docs/user-event/utility/#type) utility built on top of [`keyboard`](https://testing-library.com/docs/user-event/keyboard) API.

    This function allows you to type characters into an input/textarea/conteneditable element. It supports [user-event `keyboard` syntax](https://testing-library.com/docs/user-event/keyboard).

    If you just need to press characters without an input, use [`userEvent.keyboard`](#userevent-keyboard) API.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('update input', async () => {
      const input = screen.getByRole('input')

      await userEvent.type(input, 'foo') // input.value == foo
      await userEvent.type(input, '{{a[[') // input.value == foo{a[
      await userEvent.type(input, '{Shift}') // input.value == foo{a[
    })
    ```

    References:

    - [Playwright `locator.press` API](https://playwright.dev/docs/api/class-locator#locator-press)
    - [WebdriverIO `action('key')` API](https://webdriver.io/docs/api/browser/action#key-input-source)
    - [testing-library `type` API](https://testing-library.com/docs/user-event/utility/#type)

    &nbsp;
- name: 'Interactivity API: userEvent.unhover ​'
  id: guide/browser/interactivity-api#userevent-unhover
  summary: This works the same as userEvent.hover, but moves the cursor to the document.body element instead
  belongs_to: Interactivity API
  description: |-
    ## userEvent.unhover

    - **Type:** `(element: Element, options?: UserEventHoverOptions) => Promise<void>`

    This works the same as [`userEvent.hover`](#userevent-hover), but moves the cursor to the `document.body` element instead.

    **WARNING**

    By default, the cursor position is in the center (in `webdriverio` provider) or in "some" visible place (in `playwright` provider) of the body element, so if the currently hovered element is already in the same position, this method will have no effect.

    ts

    ``` javascript
    import { userEvent } from '@vitest/browser/context'
    import { screen } from '@testing-library/dom'

    test('unhover logo element', async () => {
      const logo = screen.getByRole('img', { name: /logo/ })

      await userEvent.unhover(logo)
    })
    ```

    References:

    - [Playwright `locator.hover` API](https://playwright.dev/docs/api/class-locator#locator-hover)
    - [WebdriverIO `element.moveTo` API](https://webdriver.io/docs/api/element/moveTo/)
    - [testing-library `hover` API](https://testing-library.com/docs/user-event/convenience/#hover)

    &nbsp;
- name: isAbove ​
  id: api/assert#isabove
  summary: Assert that valueToCheck is strictly greater than (>) valueToBeAbove
  belongs_to: assert
  description: |-
    ## isAbove

    - **Type:** `(valueToCheck: number, valueToBeAbove: number, message?: string) => void`

    Assert that `valueToCheck` is strictly greater than (\>) `valueToBeAbove`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isAbove', () => {
      assert.isAbove(5, 2, '5 is strictly greater than 2')
    })
    ```
- name: isArray ​
  id: api/assert#isarray
  summary: Asserts that value is an array
  belongs_to: assert
  description: |-
    ## isArray

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is an array.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const color = ['red', 'green', 'yellow']

    test('assert.isArray', () => {
      assert.isArray(color, 'color is array')
    })
    ```
- name: isAtLeast ​
  id: api/assert#isatleast
  summary: Assert that valueToCheck is greater than or equal to (>=) valueToBeAtLeast
  belongs_to: assert
  description: |-
    ## isAtLeast

    - **Type:** `(valueToCheck: number, valueToBeAtLeast: number, message?: string) => void`

    Assert that `valueToCheck` is greater than or equal to (\>=) `valueToBeAtLeast`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isAtLeast', () => {
      assert.isAtLeast(5, 2, '5 is greater or equal to 2')
      assert.isAtLeast(3, 3, '3 is greater or equal to 3')
    })
    ```
- name: isAtMost ​
  id: api/assert#isatmost
  summary: Asserts valueToCheck is less than or equal to (<=) valueToBeAtMost
  belongs_to: assert
  description: |-
    ## isAtMost

    - **Type:** `(valueToCheck: number, valueToBeAtMost: number, message?: string) => void`

    Asserts `valueToCheck` is less than or equal to (\<=) `valueToBeAtMost`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isAtMost', () => {
      assert.isAtMost(3, 6, '3 is less than or equal to 6')
      assert.isAtMost(4, 4, '4 is less than or equal to 4')
    })
    ```
- name: isBelow ​
  id: api/assert#isbelow
  summary: Asserts valueToCheck is strictly less than (<) valueToBeBelow
  belongs_to: assert
  description: |-
    ## isBelow

    - **Type:** `(valueToCheck: number, valueToBeBelow: number, message?: string) => void`

    Asserts `valueToCheck` is strictly less than (\<) `valueToBeBelow`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isBelow', () => {
      assert.isBelow(3, 6, '3 is strictly less than 6')
    })
    ```
- name: isBoolean ​
  id: api/assert#isboolean
  summary: Asserts that value is a boolean
  belongs_to: assert
  description: |-
    ## isBoolean

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is a boolean.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const isReady = true

    test('assert.isBoolean', () => {
      assert.isBoolean(isReady, 'isReady is a boolean')
    })
    ```
- name: isDefined ​
  id: api/assert#isdefined
  summary: Asserts that value is not undefined
  belongs_to: assert
  description: |-
    ## isDefined

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not undefined.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const name = 'foo'

    test('assert.isDefined', () => {
      assert.isDefined(name, 'name is not undefined')
    })
    ```
- name: isEmpty ​
  id: api/assert#isempty
  summary: Asserts that the target does not contain any values
  belongs_to: assert
  description: |-
    ## isEmpty

    - **Type:** `<T>(target: T, message?: string) => void`
    - **Alias:** `empty`

    Asserts that the `target` does not contain any values. For arrays and strings, it checks the length property. For Map and Set instances, it checks the size property. For non-function objects, it gets the count of its own enumerable string keys.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isEmpty', () => {
      assert.isEmpty([])
      assert.isEmpty('')
      assert.isEmpty(new Map())
      assert.isEmpty({})
    })
    ```
- name: isExtensible ​
  id: api/assert#isextensible
  summary: Asserts that object is extensible (can have new properties added to it)
  belongs_to: assert
  description: |-
    ## isExtensible

    - **Type:** `<T>(object: T, message?: string) => void`
    - **Alias:** `extensible`

    Asserts that `object` is extensible (can have new properties added to it).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isExtensible', () => {
      assert.isExtensible({})
    })
    ```
- name: isFalse ​
  id: api/assert#isfalse
  summary: Asserts that value is false
  belongs_to: assert
  description: |-
    ## isFalse

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is false.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const testPassed = false

    test('assert.isFalse', () => {
      assert.isFalse(testPassed)
    })
    ```
- name: isFinite ​
  id: api/assert#isfinite
  summary: Asserts that value is a finite number (not NaN, Infinity)
  belongs_to: assert
  description: |-
    ## isFinite

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is a finite number (not NaN, Infinity).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const colors = 3

    test('assert.isFinite', () => {
      assert.isFinite(colors, 'colors is number not NaN or Infinity')
    })
    ```
- name: isFrozen ​
  id: api/assert#isfrozen
  summary: Asserts that object is frozen (cannot have new properties added to it and its existing properties cannot be modified)
  belongs_to: assert
  description: |-
    ## isFrozen

    - **Type:** `<T>(object: T, message?: string) => void`
    - **Alias:** `frozen`

    Asserts that object is frozen (cannot have new properties added to it and its existing properties cannot be modified).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isFrozen', () => {
      const frozenObject = Object.freeze({})
      assert.frozen(frozenObject)
    })
    ```
- name: isFunction ​
  id: api/assert#isfunction
  summary: null
  belongs_to: assert
  description: |-
    ## isFunction

    - **Type:** `<T>(value: T, message?: string) => void`
    - **Alias:**`isCallable` Asserts that `value` is a function.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    function name() { return 'foo' };

    test('assert.isFunction', () => {
      assert.isFunction(name, 'name is function')
    })
    ```
- name: isNaN ​
  id: api/assert#isnan
  summary: Asserts that value is NaN
  belongs_to: assert
  description: |-
    ## isNaN

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is NaN.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const calculation = 1 * 'viitest'

    test('assert.isNaN', () => {
      assert.isNaN(calculation, '1 * "vitest" is NaN')
    })
    ```
- name: isNotArray ​
  id: api/assert#isnotarray
  summary: Asserts that value is not an array
  belongs_to: assert
  description: |-
    ## isNotArray

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not an array.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const color = 'red'

    test('assert.isNotArray', () => {
      assert.isNotArray(color, 'color is not array but string')
    })
    ```
- name: isNotBoolean ​
  id: api/assert#isnotboolean
  summary: Asserts that value is not a boolean
  belongs_to: assert
  description: |-
    ## isNotBoolean

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not a boolean.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const isReady = 'sure'

    test('assert.isBoolean', () => {
      assert.isBoolean(isReady, 'isReady is not a boolean but string')
    })
    ```
- name: isNotEmpty ​
  id: api/assert#isnotempty
  summary: Asserts that the target contains values
  belongs_to: assert
  description: "## isNotEmpty\n\n- **Type:** `<T>(object: T, message?: string) => void`\n- **Alias:** `notEmpty`\n\nAsserts that the `target` contains values. For arrays and strings, it checks the length property. For Map and Set instances, it checks the size property. For non-function objects, it gets the count of its own enumerable string keys.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('assert.isNotEmpty', () => {\n  assert.isNotEmpty([1, 2])\n  assert.isNotEmpty('34')\n  assert.isNotEmpty(new Set([5, 6]))\n  assert.isNotEmpty({ key: 7 })\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/assert](https://vitest.dev/api/assert)"
- name: isNotExtensible ​
  id: api/assert#isnotextensible
  summary: Asserts that object is not extensible (can not have new properties added to it)
  belongs_to: assert
  description: |-
    ## isNotExtensible

    - **Type:** `<T>(object: T, message?: string) => void`
    - **Alias:** `notExtensible`

    Asserts that `object` is not extensible (can not have new properties added to it).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isNotExtensible', () => {
      const nonExtensibleObject = Object.preventExtensions({})
      const sealedObject = Object.seal({})
      const frozenObject = Object.freeze({})

      assert.isNotExtensible(nonExtensibleObject)
      assert.isNotExtensible(sealedObject)
      assert.isNotExtensible(frozenObject)
    })
    ```
- name: isNotFalse ​
  id: api/assert#isnotfalse
  summary: Asserts that value is not false
  belongs_to: assert
  description: |-
    ## isNotFalse

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not false.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const testPassed = 'no'

    test('assert.isNotFalse', () => {
      assert.isNotFalse(testPassed)
    })
    ```
- name: isNotFrozen ​
  id: api/assert#isnotfrozen
  summary: Asserts that object is not frozen (can have new properties added to it and its existing properties can be modified)
  belongs_to: assert
  description: |-
    ## isNotFrozen

    - **Type:** `<T>(object: T, message?: string) => void`
    - **Alias:** `notFrozen`

    Asserts that `object` is not frozen (can have new properties added to it and its existing properties can be modified).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isNotFrozen', () => {
      assert.isNotFrozen({})
    })
    ```
- name: isNotFunction ​
  id: api/assert#isnotfunction
  summary: Asserts that value is not a function
  belongs_to: assert
  description: |-
    ## isNotFunction

    - **Type:** `<T>(value: T, message?: string) => void`
    - **Alias:** `isNotCallable`

    Asserts that `value` is not a function.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const name = 'foo'

    test('assert.isNotFunction', () => {
      assert.isNotFunction(name, 'name is not function but string')
    })
    ```
- name: isNotNaN ​
  id: api/assert#isnotnan
  summary: Asserts that value is not NaN
  belongs_to: assert
  description: |-
    ## isNotNaN

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not NaN.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const calculation = 1 * 2

    test('assert.isNotNaN', () => {
      assert.isNotNaN(calculation, '1 * 2 is Not NaN but 2')
    })
    ```
- name: isNotNull ​
  id: api/assert#isnotnull
  summary: Asserts that value is not null
  belongs_to: assert
  description: |-
    ## isNotNull

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not null.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const error = { message: 'error was occured' }

    test('assert.isNotNull', () => {
      assert.isNotNull(error, 'error is not null but object')
    })
    ```
- name: isNotNumber ​
  id: api/assert#isnotnumber
  summary: Asserts that value is not a number
  belongs_to: assert
  description: |-
    ## isNotNumber

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not a number.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const colors = '3 colors'

    test('assert.isNotNumber', () => {
      assert.isNotNumber(colors, 'colors is not number but strings')
    })
    ```
- name: isNotObject ​
  id: api/assert#isnotobject
  summary: Asserts that value is not an object of type Object (as revealed by Object.prototype.toString)
  belongs_to: assert
  description: |-
    ## isNotObject

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not an object of type Object (as revealed by Object.prototype.toString). The assertion does not match subclassed objects.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const someThing = 'redCircle'

    test('assert.isNotObject', () => {
      assert.isNotObject(someThing, 'someThing is not object but string')
    })
    ```
- name: isNotOk ​
  id: api/assert#isnotok
  summary: Assert that the given value is falsy
  belongs_to: assert
  description: |-
    ## isNotOk

    - **Type:** `<T>(value: T, message?: string) => void`
    - **Alias** `notOk`

    Assert that the given `value` is falsy.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isNotOk', () => {
      assert.isNotOk('foo', 'this will fail, every truthy is not ok')
      assert.isNotOk(false, 'this will pass since false is falsy')
    })
    ```
- name: isNotSealed ​
  id: api/assert#isnotsealed
  summary: Asserts that object is not sealed (can have new properties added to it and its existing properties can be removed)
  belongs_to: assert
  description: |-
    ## isNotSealed

    - **Type:** `<T>(object: T, message?: string) => void`
    - **Alias:** `notSealed`

    Asserts that `object` is not sealed (can have new properties added to it and its existing properties can be removed).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isNotSealed', () => {
      assert.isNotSealed({})
    })
    ```
- name: isNotString ​
  id: api/assert#isnotstring
  summary: Asserts that value is not a string
  belongs_to: assert
  description: |-
    ## isNotString

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not a string.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const color = ['red', 'green', 'yellow']

    test('assert.isNotString', () => {
      assert.isNotString(color, 'color is not string but array')
    })
    ```
- name: isNotTrue ​
  id: api/assert#isnottrue
  summary: Asserts that value is not true
  belongs_to: assert
  description: |-
    ## isNotTrue

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is not true.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const testPassed = 'ok'

    test('assert.isNotTrue', () => {
      assert.isNotTrue(testPassed)
    })
    ```
- name: isNull ​
  id: api/assert#isnull
  summary: Asserts that value is null
  belongs_to: assert
  description: |-
    ## isNull

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is null.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const error = null

    test('assert.isNull', () => {
      assert.isNull(error, 'error is null')
    })
    ```
- name: isNumber ​
  id: api/assert#isnumber
  summary: Asserts that value is a number
  belongs_to: assert
  description: |-
    ## isNumber

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is a number.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const colors = 3

    test('assert.isNumber', () => {
      assert.isNumber(colors, 'colors is number')
    })
    ```
- name: isObject ​
  id: api/assert#isobject
  summary: Asserts that value is an object of type Object (as revealed by Object.prototype.toString)
  belongs_to: assert
  description: |-
    ## isObject

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is an object of type Object (as revealed by Object.prototype.toString). The assertion does not match subclassed objects.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const someThing = { color: 'red', shape: 'circle' }

    test('assert.isObject', () => {
      assert.isObject(someThing, 'someThing is object')
    })
    ```
- name: isOk ​
  id: api/assert#isok
  summary: Assert that the given value is truthy
  belongs_to: assert
  description: |-
    ## isOk

    - **Type:** `<T>(value: T, message?: string) => void`
    - **Alias** `ok`

    Assert that the given `value` is truthy.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isOk', () => {
      assert.isOk('foo', 'every truthy is ok')
      assert.isOk(false, 'this will fail since false is not truthy')
    })
    ```
- name: isolate ​
  id: config/index#isolate
  summary: Run tests in an isolated environment
  belongs_to: Configuring Vitest
  description: |-
    ### isolate

    - **Type:** `boolean`
    - **Default:** `true`
    - **CLI:**`--no-isolate`, `--isolate=false`

    Run tests in an isolated environment. This option has no effect on `vmThreads` and `vmForks` pools.

    Disabling this option might [improve performance](../guide/improving-performance) if your code doesn't rely on side effects (which is usually true for projects with `node` environment).

    **TIP**

    You can disable isolation for specific pools by using [`poolOptions`](#pooloptions) property.
- name: isSealed ​
  id: api/assert#issealed
  summary: Asserts that object is sealed (cannot have new properties added to it and its existing properties cannot be removed)
  belongs_to: assert
  description: |-
    ## isSealed

    - **Type:** `<T>(object: T, message?: string) => void`
    - **Alias:** `sealed`

    Asserts that `object` is sealed (cannot have new properties added to it and its existing properties cannot be removed).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.isSealed', () => {
      const sealedObject = Object.seal({})
      const frozenObject = Object.seal({})

      assert.isSealed(sealedObject)
      assert.isSealed(frozenObject)
    })
    ```
- name: isString ​
  id: api/assert#isstring
  summary: Asserts that value is a string
  belongs_to: assert
  description: |-
    ## isString

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is a string.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const color = 'red'

    test('assert.isString', () => {
      assert.isString(color, 'color is string')
    })
    ```
- name: isTrue ​
  id: api/assert#istrue
  summary: Asserts that value is true
  belongs_to: assert
  description: |-
    ## isTrue

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is true.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const testPassed = true

    test('assert.isTrue', () => {
      assert.isTrue(testPassed)
    })
    ```
- name: isUndefined ​
  id: api/assert#isundefined
  summary: Asserts that value is undefined
  belongs_to: assert
  description: |-
    ## isUndefined

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is undefined.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const name = undefined

    test('assert.isUndefined', () => {
      assert.isUndefined(name, 'name is undefined')
    })
    ```
- name: items ​
  id: api/expect-typeof#items
  summary: You can get array item type with .items to perform further assertions
  belongs_to: expectTypeOf
  description: |-
    ## items

    - **Type:** `ExpectTypeOf<T>`

    You can get array item type with `.items` to perform further assertions.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf([1, 2, 3]).items.toEqualTypeOf<number>()
    expectTypeOf([1, 2, 3]).items.not.toEqualTypeOf<string>()
    ```
- name: lengthOf ​
  id: api/assert#lengthof
  summary: Asserts that object has a length or size with the expected value
  belongs_to: assert
  description: |-
    ## lengthOf

    - **Type:** `<T extends { readonly length?: number | undefined } | { readonly size?: number | undefined }>(object: T, length: number, message?: string) => void`

    Asserts that `object` has a `length` or `size` with the expected value.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.lengthOf', () => {
      assert.lengthOf([1, 2, 3], 3, 'array has length of 3')
      assert.lengthOf('foobar', 6, 'string has length of 6')
      assert.lengthOf(new Set([1, 2, 3]), 3, 'set has size of 3')
      assert.lengthOf(new Map([['a', 1], ['b', 2], ['c', 3]]), 3, 'map has size of 3')
    })
    ```
- name: logHeapUsage ​
  id: config/index#logheapusage
  summary: Show heap usage after each test
  belongs_to: Configuring Vitest
  description: |-
    ### logHeapUsage

    - **Type**: `boolean`
    - **Default**: `false`
    - **CLI:**`--logHeapUsage`, `--logHeapUsage=false`

    Show heap usage after each test. Useful for debugging memory leaks.
- name: Managing Vitest config file
  id: config/file
  summary: If you are using Vite and have a vite.config file, Vitest will read it to match with the plugins and setup as your Vite app
  description: "# Managing Vitest config file\n\nIf you are using Vite and have a `vite.config` file, Vitest will read it to match with the plugins and setup as your Vite app. If you want to have a different configuration for testing or your main app doesn't rely on Vite specifically, you could either:\n\n- Create `vitest.config.ts`, which will have the higher priority and will **override** the configuration from `vite.config.ts` (Vitest supports all conventional JS and TS extensions, but doesn't support `json`) - it means all options in your `vite.config` will be **ignored**\n- Pass `--config` option to CLI, e.g. `vitest --config ./path/to/vitest.config.ts`\n- Use `process.env.VITEST` or `mode` property on `defineConfig` (will be set to `test`/`benchmark` if not overridden with `--mode`) to conditionally apply different configuration in `vite.config.ts`\n\nTo configure `vitest` itself, add `test` property in your Vite config. You'll also need to add a reference to Vitest types using a [triple slash command](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html#-reference-types-) at the top of your config file, if you are importing `defineConfig` from `vite` itself.\n\nUsing `defineConfig` from `vite` you should follow this:\n\nts\n\n``` javascript\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n```\n\nUsing `defineConfig` from `vitest/config` you should follow this:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n```\n\nYou can retrieve Vitest's default options to expand them if needed:\n\nts\n\n``` javascript\nimport { configDefaults, defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    exclude: [...configDefaults.exclude, 'packages/template/*'],\n  },\n})\n```\n\nWhen using a separate `vitest.config.js`, you can also extend Vite's options from another config file if needed:\n\nts\n\n``` javascript\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default mergeConfig(viteConfig, defineConfig({\n  test: {\n    exclude: ['packages/template/*'],\n  },\n}))\n```\n\nIf your Vite config is defined as a function, you can define the config like this:\n\nts\n\n``` javascript\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default defineConfig(configEnv => mergeConfig(\n  viteConfig(configEnv),\n  defineConfig({\n    test: {\n      exclude: ['packages/template/*'],\n    },\n  })\n))\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/config/file](https://vitest.dev/config/file)"
- name: match ​
  id: api/assert#match
  summary: Asserts that value matches the regular expression regexp
  belongs_to: assert
  description: |-
    ## match

    - **Type:** `(value: string, regexp: RegExp, message?: string) => void`

    Asserts that `value` matches the regular expression `regexp`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.match', () => {
      assert.match('foobar', /^foo/, 'regexp matches')
    })
    ```
- name: maxConcurrency ​
  id: config/index#maxconcurrency
  summary: A number of tests that are allowed to run at the same time marked with test.concurrent
  belongs_to: Configuring Vitest
  description: |-
    ### maxConcurrency

    - **Type**: `number`
    - **Default**: `5`
    - **CLI**: `--max-concurrency=10`, `--maxConcurrency=10`

    A number of tests that are allowed to run at the same time marked with `test.concurrent`.

    Test above this limit will be queued to run when available slot appears.
- name: maxWorkers *  ​
  id: config/index#maxworkers
  summary: Maximum number or percentage of workers to run tests in
  belongs_to: Configuring Vitest
  description: "### maxWorkers \\* \n\n- **Type:** `number | string`\n\nMaximum number or percentage of workers to run tests in. `poolOptions.{threads,vmThreads}.maxThreads`/`poolOptions.forks.maxForks` has higher priority."
- name: Migration Guide
  id: guide/migration
  summary: Vitest 2.0 changes the default configuration for pool to 'forks' for better stability
  description: "# Migration Guide\n\n## Migrating to Vitest 2.0\n\n### Default Pool is `forks`\n\nVitest 2.0 changes the default configuration for `pool` to `'forks'` for better stability. You can read the full motivation in [PR](https://github.com/vitest-dev/vitest/pull/5047).\n\nIf you've used `poolOptions` without specifying a `pool`, you might need to update the configuration:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: { \n        singleThread: true, \n      }, \n      forks: { \n        singleFork: true, \n      }, \n    }\n  }\n})\n```\n\n### Hooks are Running in a Stack\n\nBefore Vitest 2.0, all hooks ran in parallel. In 2.0, all hooks run serially. Additionally, `afterAll`/`afterEach` hooks run in reverse order.\n\nTo revert to the parallel execution of hooks, change [`sequence.hooks`](../config/index#sequence-hooks) to `'parallel'`:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    sequence: { \n      hooks: 'parallel', \n    }, \n  },\n})\n```\n\n### `suite.concurrent` Runs All Tests Concurrently\n\nPreviously, specifying `concurrent` on a suite would group concurrent tests by suites, running them sequentially. Now, following Jest's behavior, all tests run concurrently (subject to [`maxConcurrency`](../config/index#maxconcurrency) limits).\n\n### V8 Coverage's `coverage.ignoreEmptyLines` is Enabled by Default\n\nThe default value of `coverage.ignoreEmptyLines` is now true. This significant change may affect code coverage reports, requiring adjustments to coverage thresholds for some projects. This adjustment only affects the default setting when `coverage.provider` is `'v8'`.\n\n### Removal of the `watchExclude` Option\n\nVitest uses Vite's watcher. Exclude files or directories by adding them to `server.watch.ignored`:\n\nts\n\n``` javascript\nexport default defineConfig({\n  server: { \n    watch: { \n      ignored: ['!node_modules/examplejs'] \n    } \n  } \n})\n```\n\n### `--segfault-retry` Removed\n\nWith the changes to default pool, this option is no longer needed. If you experience segfault errors, try switching to `'forks'` pool. If the problem persists, please open a new issue with a reproduction.\n\n### Empty Task In Suite Tasks Removed\n\nThis is the change to the advanced [task API](../advanced/runner#your-task-function). Previously, traversing `.suite` would eventually lead to the empty internal suite that was used instead of a file task.\n\nThis makes `.suite` optional; if the task is defined at the top level, it will not have a suite. You can fallback to the `.file` property that is now present on all tasks (including the file task itself, so be careful not to fall into the endless recursion).\n\nThis change also removes the file from `expect.getState().currentTestName` and makes `expect.getState().testPath` required.\n\n### `task.meta` is Added to the JSON Reporter\n\nJSON reporter now prints `task.meta` for every assertion result.\n\n### Simplified Generic Types of Mock Functions (e.g. `vi.fn<T>`, `Mock<T>`)\n\nPreviously `vi.fn<TArgs, TReturn>` accepted two generic types separately for arguments and return value. This is changed to directly accept a function type `vi.fn<T>` to simplify the usage.\n\nts\n\n``` javascript\nimport { type Mock, vi } from 'vitest'\n\nconst add = (x: number, y: number): number => x + y\n\n// using vi.fn<T>\nconst mockAdd = vi.fn<Parameters<typeof add>, ReturnType<typeof add>>() \nconst mockAdd = vi.fn<typeof add>() \n\n// using Mock<T>\nconst mockAdd: Mock<Parameters<typeof add>, ReturnType<typeof add>> = vi.fn() \nconst mockAdd: Mock<typeof add> = vi.fn()\n```\n\n### Accessing Resolved `mock.results`\n\nPreviously Vitest resolved `mock.results` values if the function returned a Promise. Now there is a separate [`mock.settledResults`](../api/mock#mock-settledresults) property that populates only when the returned Promise is resolved or rejected.\n\nts\n\n``` javascript\nconst fn = vi.fn().mockResolvedValueOnce('result')\nawait fn()\n\nconst result = fn.mock.results[0] // 'result'\nconst result = fn.mock.results[0] // 'Promise<result>'\n\nconst settledResult = fn.mock.settledResults[0] // 'result'\n```\n\nWith this change, we also introduce new [`toHaveResolved*`](../api/expect#tohaveresolved) matchers similar to `toHaveReturned` to make migration easier if you used `toHaveReturned` before:\n\nts\n\n``` javascript\nconst fn = vi.fn().mockResolvedValueOnce('result')\nawait fn()\n\nexpect(fn).toHaveReturned('result') \nexpect(fn).toHaveResolved('result')\n```\n\n### Browser Mode\n\nVitest Browser Mode had a lot of changes during the beta cycle. You can read about our philosophy on the Browser Mode in the [GitHub discussion page](https://github.com/vitest-dev/vitest/discussions/5828).\n\nMost of the changes were additive, but there were some small breaking changes:\n\n- `none` provider was renamed to `preview` [\\#5842](https://github.com/vitest-dev/vitest/pull/5826)\n- `preview` provider is now a default [\\#5842](https://github.com/vitest-dev/vitest/pull/5826)\n- `indexScripts` is renamed to `orchestratorScripts` [\\#5842](https://github.com/vitest-dev/vitest/pull/5842)\n\n### Deprecated Options Removed\n\nSome deprecated options were removed:\n\n- `vitest typecheck` command - use `vitest --typecheck` instead\n- `VITEST_JUNIT_CLASSNAME` and `VITEST_JUNIT_SUITE_NAME` env variables (use reporter options instead)\n- check for `c8` coverage (use coverage-v8 instead)\n- export of `SnapshotEnvironment` from `vitest` - import it from `vitest/snapshot` instead\n- `SpyInstance` is removed in favor of `MockInstance`\n\n## Migrating to Vitest 1.0\n\n### Minimum Requirements\n\nVitest 1.0 requires Vite 5.0 and Node.js 18 or higher.\n\nAll `@vitest/*` sub packages require Vitest version 1.0.\n\n### Snapshots Update [\\#3961](https://github.com/vitest-dev/vitest/pull/3961)\n\nQuotes in snapshots are no longer escaped, and all snapshots use backtick quotes (\\`) even if the string is just a single line.\n\n1.  Quotes are no longer escaped:\n\ndiff\n\n``` javascript\nexpect({ foo: 'bar' }).toMatchInlineSnapshot(`\n  Object {\n-    \\\\\"foo\\\\\": \\\\\"bar\\\\\",\n+    \"foo\": \"bar\",\n  }\n`)\n```\n\n2.  One-line snapshots now use \"\\`\" quotes instead of ':\n\ndiff\n\n``` javascript\n- expect('some string').toMatchInlineSnapshot('\"some string\"')\n+ expect('some string').toMatchInlineSnapshot(`\"some string\"`)\n```\n\nThere were also [changes](https://github.com/vitest-dev/vitest/pull/4076) to `@vitest/snapshot` package. If you are not using it directly, you don't need to change anything.\n\n- You no longer need to extend `SnapshotClient` just to override `equalityCheck` method: just pass it down as `isEqual` when initiating an instance\n- `client.setTest` was renamed to `client.startCurrentRun`\n- `client.resetCurrent` was renamed to `client.finishCurrentRun`\n\n### Pools are Standardized [\\#4172](https://github.com/vitest-dev/vitest/pull/4172)\n\nWe removed a lot of configuration options to make it easier to configure the runner to your needs. Please, have a look at migration examples if you rely on `--threads` or other related flags.\n\n- `--threads` is now `--pool=threads`\n- `--no-threads` is now `--pool=forks`\n- `--single-thread` is now `--poolOptions.threads.singleThread`\n- `--experimental-vm-threads` is now `--pool=vmThreads`\n- `--experimental-vm-worker-memory-limit` is now `--poolOptions.vmThreads.memoryLimit`\n- `--isolate` is now `--poolOptions.<pool-name>.isolate` and `browser.isolate`\n- `test.maxThreads` is now `test.poolOptions.<pool-name>.maxThreads`\n- `test.minThreads` is now `test.poolOptions.<pool-name>.minThreads`\n- `test.useAtomics` is now `test.poolOptions.<pool-name>.useAtomics`\n- `test.poolMatchGlobs.child_process` is now `test.poolMatchGlobs.forks`\n- `test.poolMatchGlobs.experimentalVmThreads` is now `test.poolMatchGlobs.vmThreads`\n\ndiff\n\n``` javascript\n{\n  scripts: {\n-    \"test\": \"vitest --no-threads\"\n     // For identical behaviour:\n+    \"test\": \"vitest --pool forks --poolOptions.forks.singleFork\"\n     // Or multi parallel forks:\n+    \"test\": \"vitest --pool forks\"\n\n  }\n}\n```\n\ndiff\n\n``` javascript\n{\n  scripts: {\n-    \"test\": \"vitest --experimental-vm-threads\"\n+    \"test\": \"vitest --pool vmThreads\"\n  }\n}\n```\n\ndiff\n\n``` javascript\n{\n  scripts: {\n-    \"test\": \"vitest --isolate false\"\n+    \"test\": \"vitest --poolOptions.threads.isolate false\"\n  }\n}\n```\n\ndiff\n\n``` javascript\n{\n  scripts: {\n-    \"test\": \"vitest --no-threads --isolate false\"\n+    \"test\": \"vitest --pool forks --poolOptions.forks.isolate false\"\n  }\n}\n```\n\n### Changes to Coverage [\\#4265](https://github.com/vitest-dev/vitest/pull/4265), [\\#4442](https://github.com/vitest-dev/vitest/pull/4442)\n\nOption `coverage.all` is now enabled by default. This means that all project files matching `coverage.include` pattern will be processed even if they are not executed.\n\nCoverage thresholds API's shape was changed, and it now supports specifying thresholds for specific files using glob patterns:\n\ndiff\n\n``` javascript\nexport default defineConfig({\n  test: {\n    coverage: {\n-      perFile: true,\n-      thresholdAutoUpdate: true,\n-      100: true,\n-      lines: 100,\n-      functions: 100,\n-      branches: 100,\n-      statements: 100,\n+      thresholds: {\n+        perFile: true,\n+        autoUpdate: true,\n+        100: true,\n+        lines: 100,\n+        functions: 100,\n+        branches: 100,\n+        statements: 100,\n+      }\n    }\n  }\n})\n```\n\n### Mock Types [\\#4400](https://github.com/vitest-dev/vitest/pull/4400)\n\nA few types were removed in favor of Jest-style \"Mock\" naming.\n\ndiff\n\n``` javascript\n- import { EnhancedSpy, SpyInstance } from 'vitest'\n+ import { MockInstance } from 'vitest'\n```\n\n**WARNING**\n\n`SpyInstance` is deprecated in favor of `MockInstance` and will be removed in the next major release.\n\n### Timer mocks [\\#3925](https://github.com/vitest-dev/vitest/pull/3925)\n\n`vi.useFakeTimers()` no longer automatically mocks [`process.nextTick`](https://nodejs.org/api/process.html#processnexttickcallback-args). It is still possible to mock `process.nextTick` by explicitly specifying it by using `vi.useFakeTimers({ toFake: ['nextTick'] })`.\n\nHowever, mocking `process.nextTick` is not possible when using `--pool=forks`. Use a different `--pool` option if you need `process.nextTick` mocking.\n\n## Migrating from Jest\n\nVitest has been designed with a Jest compatible API, in order to make the migration from Jest as simple as possible. Despite those efforts, you may still run into the following differences:\n\n### Globals as a Default\n\nJest has their [globals API](https://jestjs.io/docs/api) enabled by default. Vitest does not. You can either enable globals via [the `globals` configuration setting](../config/index#globals) or update your code to use imports from the `vitest` module instead.\n\nIf you decide to keep globals disabled, be aware that common libraries like [`testing-library`](https://testing-library.com/) will not run auto DOM [cleanup](https://testing-library.com/docs/svelte-testing-library/api/#cleanup).\n\n### Module Mocks\n\nWhen mocking a module in Jest, the factory argument's return value is the default export. In Vitest, the factory argument has to return an object with each export explicitly defined. For example, the following `jest.mock` would have to be updated as follows:\n\nts\n\n``` javascript\njest.mock('./some-path', () => 'hello') \nvi.mock('./some-path', () => ({ \n  default: 'hello', \n}))\n```\n\nFor more details please refer to the [`vi.mock` api section](../api/vi#vi-mock).\n\n### Auto-Mocking Behaviour\n\nUnlike Jest, mocked modules in `<root>/__mocks__` are not loaded unless `vi.mock()` is called. If you need them to be mocked in every test, like in Jest, you can mock them inside [`setupFiles`](../config/index#setupfiles).\n\n### Importing the Original of a Mocked Package\n\nIf you are only partially mocking a package, you might have previously used Jest's function `requireActual`. In Vitest, you should replace these calls with `vi.importActual`.\n\nts\n\n``` javascript\nconst { cloneDeep } = jest.requireActual('lodash/cloneDeep') \nconst { cloneDeep } = await vi.importActual('lodash/cloneDeep')\n```\n\n### Extends mocking to external libraries\n\nWhere Jest does it by default, when mocking a module and wanting this mocking to be extended to other external libraries that use the same module, you should explicitly tell which 3rd-party library you want to be mocked, so the external library would be part of your source code, by using [server.deps.inline](../config/index#server-deps-inline).\n\n``` javascript\nserver.deps.inline: [\"lib-name\"]\n```\n\n### Envs\n\nJust like Jest, Vitest sets `NODE_ENV` to `test`, if it wasn't set before. Vitest also has a counterpart for `JEST_WORKER_ID` called `VITEST_POOL_ID` (always less than or equal to `maxThreads`), so if you rely on it, don't forget to rename it. Vitest also exposes `VITEST_WORKER_ID` which is a unique ID of a running worker - this number is not affected by `maxThreads`, and will increase with each created worker.\n\n### Replace property\n\nIf you want to modify the object, you will use [replaceProperty API](https://jestjs.io/docs/jest-object#jestreplacepropertyobject-propertykey-value) in Jest, you can use [`vi.stubEnv`](../api/index#vi-stubenv) or [`vi.spyOn`](../api/vi#vi-spyon) to do the same also in Vitest.\n\n### Done Callback\n\nFrom Vitest v0.10.0, the callback style of declaring tests is deprecated. You can rewrite them to use `async`/`await` functions, or use Promise to mimic the callback style.\n\n``` javascript\nit('should work', (done) => {\nit('should work', () => new Promise(done => {\n  // ...\n  done()\n})\n}))\n```\n\n### Hooks\n\n`beforeAll`/`beforeEach` hooks may return [teardown function](../api/index#setup-and-teardown) in Vitest. Because of that you may need to rewrite your hooks declarations, if they return something other than `undefined` or `null`:\n\nts\n\n``` javascript\nbeforeEach(() => setActivePinia(createTestingPinia())) \nbeforeEach(() => { setActivePinia(createTestingPinia()) })\n```\n\nIn Jest hooks are called sequentially (one after another). By default, Vitest runs hooks in parallel. To use Jest's behavior, update [`sequence.hooks`](../config/index#sequence-hooks) option:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    sequence: { \n      hooks: 'list', \n    } \n  }\n})\n```\n\n### Types\n\nVitest doesn't have an equivalent to `jest` namespace, so you will need to import types directly from `vitest`:\n\nts\n\n``` javascript\nlet fn: jest.Mock<(name: string) => number> \nimport type { Mock } from 'vitest'\nlet fn: Mock<(name: string) => number>\n```\n\n### Timers\n\nVitest doesn't support Jest's legacy timers.\n\n### Timeout\n\nIf you used `jest.setTimeout`, you would need to migrate to `vi.setConfig`:\n\nts\n\n``` javascript\njest.setTimeout(5_000) \nvi.setConfig({ testTimeout: 5_000 })\n```\n\n### Vue Snapshots\n\nThis is not a Jest-specific feature, but if you previously were using Jest with vue-cli preset, you will need to install [`jest-serializer-vue`](https://github.com/eddyerburgh/jest-serializer-vue) package, and use it inside [setupFiles](../config/index#setupfiles):\n\n`vite.config.js`\n\njs\n\n``` javascript\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['./tests/unit/setup.js']\n  }\n})\n```\n\n`tests/unit/setup.js`\n\njs\n\n``` javascript\nimport vueSnapshotSerializer from 'jest-serializer-vue'\n\nexpect.addSnapshotSerializer(vueSnapshotSerializer)\n```\n\nOtherwise your snapshots will have a lot of escaped `\"` characters.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/migration](https://vitest.dev/guide/migration)"
- name: 'Migration Guide: --segfault-retry Removed ​'
  id: guide/migration#segfault-retry-removed
  summary: With the changes to default pool, this option is no longer needed
  belongs_to: Migration Guide
  description: |-
    ### `--segfault-retry` Removed

    With the changes to default pool, this option is no longer needed. If you experience segfault errors, try switching to `'forks'` pool. If the problem persists, please open a new issue with a reproduction.
- name: 'Migration Guide: Accessing Resolved mock.results ​'
  id: guide/migration#accessing-resolved-mock-results
  summary: Previously Vitest resolved mock.results values if the function returned a Promise
  belongs_to: Migration Guide
  description: "### Accessing Resolved `mock.results`\n\nPreviously Vitest resolved `mock.results` values if the function returned a Promise. Now there is a separate [`mock.settledResults`](../api/mock#mock-settledresults) property that populates only when the returned Promise is resolved or rejected.\n\nts\n\n``` javascript\nconst fn = vi.fn().mockResolvedValueOnce('result')\nawait fn()\n\nconst result = fn.mock.results[0] // 'result'\nconst result = fn.mock.results[0] // 'Promise<result>'\n\nconst settledResult = fn.mock.settledResults[0] // 'result'\n```\n\nWith this change, we also introduce new [`toHaveResolved*`](../api/expect#tohaveresolved) matchers similar to `toHaveReturned` to make migration easier if you used `toHaveReturned` before:\n\nts\n\n``` javascript\nconst fn = vi.fn().mockResolvedValueOnce('result')\nawait fn()\n\nexpect(fn).toHaveReturned('result') \nexpect(fn).toHaveResolved('result')\n```"
- name: 'Migration Guide: Auto-Mocking Behaviour ​'
  id: guide/migration#auto-mocking-behaviour
  summary: Unlike Jest, mocked modules in <root>/__mocks__ are not loaded unless vi.mock() is called
  belongs_to: Migration Guide
  description: |-
    ### Auto-Mocking Behaviour

    Unlike Jest, mocked modules in `<root>/__mocks__` are not loaded unless `vi.mock()` is called. If you need them to be mocked in every test, like in Jest, you can mock them inside [`setupFiles`](../config/index#setupfiles).
- name: 'Migration Guide: Browser Mode ​'
  id: guide/migration#browser-mode
  summary: Vitest Browser Mode had a lot of changes during the beta cycle
  belongs_to: Migration Guide
  description: |-
    ### Browser Mode

    Vitest Browser Mode had a lot of changes during the beta cycle. You can read about our philosophy on the Browser Mode in the [GitHub discussion page](https://github.com/vitest-dev/vitest/discussions/5828).

    Most of the changes were additive, but there were some small breaking changes:

    - `none` provider was renamed to `preview` [\#5842](https://github.com/vitest-dev/vitest/pull/5826)
    - `preview` provider is now a default [\#5842](https://github.com/vitest-dev/vitest/pull/5826)
    - `indexScripts` is renamed to `orchestratorScripts` [\#5842](https://github.com/vitest-dev/vitest/pull/5842)
- name: 'Migration Guide: Changes to Coverage4265, #4442 ​'
  id: guide/migration#changes-to-coverage-4265-4442
  summary: Option coverage.all is now enabled by default
  belongs_to: Migration Guide
  description: |-
    ### Changes to Coverage [\#4265](https://github.com/vitest-dev/vitest/pull/4265), [\#4442](https://github.com/vitest-dev/vitest/pull/4442)

    Option `coverage.all` is now enabled by default. This means that all project files matching `coverage.include` pattern will be processed even if they are not executed.

    Coverage thresholds API's shape was changed, and it now supports specifying thresholds for specific files using glob patterns:

    diff

    ``` javascript
    export default defineConfig({
      test: {
        coverage: {
    -      perFile: true,
    -      thresholdAutoUpdate: true,
    -      100: true,
    -      lines: 100,
    -      functions: 100,
    -      branches: 100,
    -      statements: 100,
    +      thresholds: {
    +        perFile: true,
    +        autoUpdate: true,
    +        100: true,
    +        lines: 100,
    +        functions: 100,
    +        branches: 100,
    +        statements: 100,
    +      }
        }
      }
    })
    ```
- name: 'Migration Guide: Default Pool is forks ​'
  id: guide/migration#default-pool-is-forks
  summary: Vitest 2.0 changes the default configuration for pool to 'forks' for better stability
  belongs_to: Migration Guide
  description: "### Default Pool is `forks`\n\nVitest 2.0 changes the default configuration for `pool` to `'forks'` for better stability. You can read the full motivation in [PR](https://github.com/vitest-dev/vitest/pull/5047).\n\nIf you've used `poolOptions` without specifying a `pool`, you might need to update the configuration:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: { \n        singleThread: true, \n      }, \n      forks: { \n        singleFork: true, \n      }, \n    }\n  }\n})\n```"
- name: 'Migration Guide: Deprecated Options Removed ​'
  id: guide/migration#deprecated-options-removed
  summary: null
  belongs_to: Migration Guide
  description: |-
    ### Deprecated Options Removed

    Some deprecated options were removed:

    - `vitest typecheck` command - use `vitest --typecheck` instead
    - `VITEST_JUNIT_CLASSNAME` and `VITEST_JUNIT_SUITE_NAME` env variables (use reporter options instead)
    - check for `c8` coverage (use coverage-v8 instead)
    - export of `SnapshotEnvironment` from `vitest` - import it from `vitest/snapshot` instead
    - `SpyInstance` is removed in favor of `MockInstance`

    &nbsp;
- name: 'Migration Guide: Done Callback ​'
  id: guide/migration#done-callback
  summary: From Vitest v0.10.0, the callback style of declaring tests is deprecated
  belongs_to: Migration Guide
  description: |-
    ### Done Callback

    From Vitest v0.10.0, the callback style of declaring tests is deprecated. You can rewrite them to use `async`/`await` functions, or use Promise to mimic the callback style.

    ``` javascript
    it('should work', (done) => {
    it('should work', () => new Promise(done => {
      // ...
      done()
    })
    }))
    ```
- name: 'Migration Guide: Empty Task In Suite Tasks Removed ​'
  id: guide/migration#empty-task-in-suite-tasks-removed
  summary: This is the change to the advanced task API
  belongs_to: Migration Guide
  description: |-
    ### Empty Task In Suite Tasks Removed

    This is the change to the advanced [task API](../advanced/runner#your-task-function). Previously, traversing `.suite` would eventually lead to the empty internal suite that was used instead of a file task.

    This makes `.suite` optional; if the task is defined at the top level, it will not have a suite. You can fallback to the `.file` property that is now present on all tasks (including the file task itself, so be careful not to fall into the endless recursion).

    This change also removes the file from `expect.getState().currentTestName` and makes `expect.getState().testPath` required.
- name: 'Migration Guide: Envs ​'
  id: guide/migration#envs
  summary: Just like Jest, Vitest sets NODE_ENV to test, if it wasn't set before
  belongs_to: Migration Guide
  description: |-
    ### Envs

    Just like Jest, Vitest sets `NODE_ENV` to `test`, if it wasn't set before. Vitest also has a counterpart for `JEST_WORKER_ID` called `VITEST_POOL_ID` (always less than or equal to `maxThreads`), so if you rely on it, don't forget to rename it. Vitest also exposes `VITEST_WORKER_ID` which is a unique ID of a running worker - this number is not affected by `maxThreads`, and will increase with each created worker.
- name: 'Migration Guide: Extends mocking to external libraries ​'
  id: guide/migration#extends-mocking-to-external-libraries
  summary: Where Jest does it by default, when mocking a module and wanting this mocking to be extended to other external libraries that use the same module, you should explicitly tell which 3rd-party library you want to be mocked, so the external library would be part of your source code, by using server.deps.inline
  belongs_to: Migration Guide
  description: |-
    ### Extends mocking to external libraries

    Where Jest does it by default, when mocking a module and wanting this mocking to be extended to other external libraries that use the same module, you should explicitly tell which 3rd-party library you want to be mocked, so the external library would be part of your source code, by using [server.deps.inline](../config/index#server-deps-inline).

    ``` javascript
    server.deps.inline: ["lib-name"]
    ```
- name: 'Migration Guide: Globals as a Default ​'
  id: guide/migration#globals-as-a-default
  summary: Jest has their globals API enabled by default
  belongs_to: Migration Guide
  description: |-
    ### Globals as a Default

    Jest has their [globals API](https://jestjs.io/docs/api) enabled by default. Vitest does not. You can either enable globals via [the `globals` configuration setting](../config/index#globals) or update your code to use imports from the `vitest` module instead.

    If you decide to keep globals disabled, be aware that common libraries like [`testing-library`](https://testing-library.com/) will not run auto DOM [cleanup](https://testing-library.com/docs/svelte-testing-library/api/#cleanup).
- name: 'Migration Guide: Hooks are Running in a Stack ​'
  id: guide/migration#hooks-are-running-in-a-stack
  summary: Before Vitest 2.0, all hooks ran in parallel
  belongs_to: Migration Guide
  description: "### Hooks are Running in a Stack\n\nBefore Vitest 2.0, all hooks ran in parallel. In 2.0, all hooks run serially. Additionally, `afterAll`/`afterEach` hooks run in reverse order.\n\nTo revert to the parallel execution of hooks, change [`sequence.hooks`](../config/index#sequence-hooks) to `'parallel'`:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    sequence: { \n      hooks: 'parallel', \n    }, \n  },\n})\n```"
- name: 'Migration Guide: Hooks ​'
  id: guide/migration#hooks
  summary: beforeAll/beforeEach hooks may return teardown function in Vitest
  belongs_to: Migration Guide
  description: "### Hooks\n\n`beforeAll`/`beforeEach` hooks may return [teardown function](../api/index#setup-and-teardown) in Vitest. Because of that you may need to rewrite your hooks declarations, if they return something other than `undefined` or `null`:\n\nts\n\n``` javascript\nbeforeEach(() => setActivePinia(createTestingPinia())) \nbeforeEach(() => { setActivePinia(createTestingPinia()) })\n```\n\nIn Jest hooks are called sequentially (one after another). By default, Vitest runs hooks in parallel. To use Jest's behavior, update [`sequence.hooks`](../config/index#sequence-hooks) option:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    sequence: { \n      hooks: 'list', \n    } \n  }\n})\n```"
- name: 'Migration Guide: Importing the Original of a Mocked Package ​'
  id: guide/migration#importing-the-original-of-a-mocked-package
  summary: If you are only partially mocking a package, you might have previously used Jest's function requireActual
  belongs_to: Migration Guide
  description: "### Importing the Original of a Mocked Package\n\nIf you are only partially mocking a package, you might have previously used Jest's function `requireActual`. In Vitest, you should replace these calls with `vi.importActual`.\n\nts\n\n``` javascript\nconst { cloneDeep } = jest.requireActual('lodash/cloneDeep') \nconst { cloneDeep } = await vi.importActual('lodash/cloneDeep')\n```"
- name: 'Migration Guide: Migrating from Jest ​'
  id: guide/migration#migrating-from-jest
  summary: Vitest has been designed with a Jest compatible API, in order to make the migration from Jest as simple as possible
  belongs_to: Migration Guide
  description: |-
    ## Migrating from Jest

    Vitest has been designed with a Jest compatible API, in order to make the migration from Jest as simple as possible. Despite those efforts, you may still run into the following differences:
- name: 'Migration Guide: Migrating to Vitest 1.0 ​'
  id: guide/migration#migrating-to-vitest-1-0
  summary: null
  belongs_to: Migration Guide
  description: '## Migrating to Vitest 1.0'
- name: 'Migration Guide: Migrating to Vitest 2.0 ​'
  id: guide/migration#migrating-to-vitest-2-0
  summary: null
  belongs_to: Migration Guide
  description: '## Migrating to Vitest 2.0'
- name: 'Migration Guide: Minimum Requirements ​'
  id: guide/migration#minimum-requirements
  summary: Vitest 1.0 requires Vite 5.0 and Node.js 18 or higher
  belongs_to: Migration Guide
  description: |-
    ### Minimum Requirements

    Vitest 1.0 requires Vite 5.0 and Node.js 18 or higher.

    All `@vitest/*` sub packages require Vitest version 1.0.
- name: 'Migration Guide: Mock Types4400 ​'
  id: guide/migration#mock-types-4400
  summary: A few types were removed in favor of Jest-style "Mock" naming
  belongs_to: Migration Guide
  description: |-
    ### Mock Types [\#4400](https://github.com/vitest-dev/vitest/pull/4400)

    A few types were removed in favor of Jest-style "Mock" naming.

    diff

    ``` javascript
    - import { EnhancedSpy, SpyInstance } from 'vitest'
    + import { MockInstance } from 'vitest'
    ```

    **WARNING**

    `SpyInstance` is deprecated in favor of `MockInstance` and will be removed in the next major release.
- name: 'Migration Guide: Module Mocks ​'
  id: guide/migration#module-mocks
  summary: When mocking a module in Jest, the factory argument's return value is the default export
  belongs_to: Migration Guide
  description: "### Module Mocks\n\nWhen mocking a module in Jest, the factory argument's return value is the default export. In Vitest, the factory argument has to return an object with each export explicitly defined. For example, the following `jest.mock` would have to be updated as follows:\n\nts\n\n``` javascript\njest.mock('./some-path', () => 'hello') \nvi.mock('./some-path', () => ({ \n  default: 'hello', \n}))\n```\n\nFor more details please refer to the [`vi.mock` api section](../api/vi#vi-mock)."
- name: 'Migration Guide: Pools are Standardized4172 ​'
  id: guide/migration#pools-are-standardized-4172
  summary: We removed a lot of configuration options to make it easier to configure the runner to your needs
  belongs_to: Migration Guide
  description: |-
    ### Pools are Standardized [\#4172](https://github.com/vitest-dev/vitest/pull/4172)

    We removed a lot of configuration options to make it easier to configure the runner to your needs. Please, have a look at migration examples if you rely on `--threads` or other related flags.

    - `--threads` is now `--pool=threads`
    - `--no-threads` is now `--pool=forks`
    - `--single-thread` is now `--poolOptions.threads.singleThread`
    - `--experimental-vm-threads` is now `--pool=vmThreads`
    - `--experimental-vm-worker-memory-limit` is now `--poolOptions.vmThreads.memoryLimit`
    - `--isolate` is now `--poolOptions.<pool-name>.isolate` and `browser.isolate`
    - `test.maxThreads` is now `test.poolOptions.<pool-name>.maxThreads`
    - `test.minThreads` is now `test.poolOptions.<pool-name>.minThreads`
    - `test.useAtomics` is now `test.poolOptions.<pool-name>.useAtomics`
    - `test.poolMatchGlobs.child_process` is now `test.poolMatchGlobs.forks`
    - `test.poolMatchGlobs.experimentalVmThreads` is now `test.poolMatchGlobs.vmThreads`

    diff

    ``` javascript
    {
      scripts: {
    -    "test": "vitest --no-threads"
         // For identical behaviour:
    +    "test": "vitest --pool forks --poolOptions.forks.singleFork"
         // Or multi parallel forks:
    +    "test": "vitest --pool forks"

      }
    }
    ```

    diff

    ``` javascript
    {
      scripts: {
    -    "test": "vitest --experimental-vm-threads"
    +    "test": "vitest --pool vmThreads"
      }
    }
    ```

    diff

    ``` javascript
    {
      scripts: {
    -    "test": "vitest --isolate false"
    +    "test": "vitest --poolOptions.threads.isolate false"
      }
    }
    ```

    diff

    ``` javascript
    {
      scripts: {
    -    "test": "vitest --no-threads --isolate false"
    +    "test": "vitest --pool forks --poolOptions.forks.isolate false"
      }
    }
    ```
- name: 'Migration Guide: Removal of the watchExclude Option ​'
  id: guide/migration#removal-of-the-watchexclude-option
  summary: Vitest uses Vite's watcher
  belongs_to: Migration Guide
  description: "### Removal of the `watchExclude` Option\n\nVitest uses Vite's watcher. Exclude files or directories by adding them to `server.watch.ignored`:\n\nts\n\n``` javascript\nexport default defineConfig({\n  server: { \n    watch: { \n      ignored: ['!node_modules/examplejs'] \n    } \n  } \n})\n```"
- name: 'Migration Guide: Replace property ​'
  id: guide/migration#replace-property
  summary: If you want to modify the object, you will use replaceProperty API in Jest, you can use vi.stubEnv or vi.spyOn to do the same also in Vitest
  belongs_to: Migration Guide
  description: |-
    ### Replace property

    If you want to modify the object, you will use [replaceProperty API](https://jestjs.io/docs/jest-object#jestreplacepropertyobject-propertykey-value) in Jest, you can use [`vi.stubEnv`](../api/index#vi-stubenv) or [`vi.spyOn`](../api/vi#vi-spyon) to do the same also in Vitest.
- name: 'Migration Guide: Simplified Generic Types of Mock Functions (e.g. vi.fn<T>, Mock<T>) ​'
  id: guide/migration#simplified-generic-types-of-mock-functions-e-g-vi-fn-t-mock-t
  summary: Previously vi.fn<TArgs, TReturn> accepted two generic types separately for arguments and return value
  belongs_to: Migration Guide
  description: "### Simplified Generic Types of Mock Functions (e.g. `vi.fn<T>`, `Mock<T>`)\n\nPreviously `vi.fn<TArgs, TReturn>` accepted two generic types separately for arguments and return value. This is changed to directly accept a function type `vi.fn<T>` to simplify the usage.\n\nts\n\n``` javascript\nimport { type Mock, vi } from 'vitest'\n\nconst add = (x: number, y: number): number => x + y\n\n// using vi.fn<T>\nconst mockAdd = vi.fn<Parameters<typeof add>, ReturnType<typeof add>>() \nconst mockAdd = vi.fn<typeof add>() \n\n// using Mock<T>\nconst mockAdd: Mock<Parameters<typeof add>, ReturnType<typeof add>> = vi.fn() \nconst mockAdd: Mock<typeof add> = vi.fn()\n```"
- name: 'Migration Guide: Snapshots Update3961 ​'
  id: guide/migration#snapshots-update-3961
  summary: Quotes in snapshots are no longer escaped, and all snapshots use backtick quotes (`) even if the string is just a single line
  belongs_to: Migration Guide
  description: |-
    ### Snapshots Update [\#3961](https://github.com/vitest-dev/vitest/pull/3961)

    Quotes in snapshots are no longer escaped, and all snapshots use backtick quotes (\`) even if the string is just a single line.

    1.  Quotes are no longer escaped:

    diff

    ``` javascript
    expect({ foo: 'bar' }).toMatchInlineSnapshot(`
      Object {
    -    \\"foo\\": \\"bar\\",
    +    "foo": "bar",
      }
    `)
    ```

    2.  One-line snapshots now use "\`" quotes instead of ':

    diff

    ``` javascript
    - expect('some string').toMatchInlineSnapshot('"some string"')
    + expect('some string').toMatchInlineSnapshot(`"some string"`)
    ```

    There were also [changes](https://github.com/vitest-dev/vitest/pull/4076) to `@vitest/snapshot` package. If you are not using it directly, you don't need to change anything.

    - You no longer need to extend `SnapshotClient` just to override `equalityCheck` method: just pass it down as `isEqual` when initiating an instance
    - `client.setTest` was renamed to `client.startCurrentRun`
    - `client.resetCurrent` was renamed to `client.finishCurrentRun`

    &nbsp;
- name: 'Migration Guide: suite.concurrent Runs All Tests Concurrently ​'
  id: guide/migration#suite-concurrent-runs-all-tests-concurrently
  summary: Previously, specifying concurrent on a suite would group concurrent tests by suites, running them sequentially
  belongs_to: Migration Guide
  description: |-
    ### `suite.concurrent` Runs All Tests Concurrently

    Previously, specifying `concurrent` on a suite would group concurrent tests by suites, running them sequentially. Now, following Jest's behavior, all tests run concurrently (subject to [`maxConcurrency`](../config/index#maxconcurrency) limits).
- name: 'Migration Guide: task.meta is Added to the JSON Reporter ​'
  id: guide/migration#task-meta-is-added-to-the-json-reporter
  summary: JSON reporter now prints task.meta for every assertion result
  belongs_to: Migration Guide
  description: |-
    ### `task.meta` is Added to the JSON Reporter

    JSON reporter now prints `task.meta` for every assertion result.
- name: 'Migration Guide: Timeout ​'
  id: guide/migration#timeout
  summary: null
  belongs_to: Migration Guide
  description: "### Timeout\n\nIf you used `jest.setTimeout`, you would need to migrate to `vi.setConfig`:\n\nts\n\n``` javascript\njest.setTimeout(5_000) \nvi.setConfig({ testTimeout: 5_000 })\n```"
- name: 'Migration Guide: Timer mocks3925 ​'
  id: guide/migration#timer-mocks-3925
  summary: vi.useFakeTimers() no longer automatically mocks process.nextTick
  belongs_to: Migration Guide
  description: |-
    ### Timer mocks [\#3925](https://github.com/vitest-dev/vitest/pull/3925)

    `vi.useFakeTimers()` no longer automatically mocks [`process.nextTick`](https://nodejs.org/api/process.html#processnexttickcallback-args). It is still possible to mock `process.nextTick` by explicitly specifying it by using `vi.useFakeTimers({ toFake: ['nextTick'] })`.

    However, mocking `process.nextTick` is not possible when using `--pool=forks`. Use a different `--pool` option if you need `process.nextTick` mocking.
- name: 'Migration Guide: Timers ​'
  id: guide/migration#timers
  summary: Vitest doesn't support Jest's legacy timers
  belongs_to: Migration Guide
  description: |-
    ### Timers

    Vitest doesn't support Jest's legacy timers.
- name: 'Migration Guide: Types ​'
  id: guide/migration#types
  summary: null
  belongs_to: Migration Guide
  description: "### Types\n\nVitest doesn't have an equivalent to `jest` namespace, so you will need to import types directly from `vitest`:\n\nts\n\n``` javascript\nlet fn: jest.Mock<(name: string) => number> \nimport type { Mock } from 'vitest'\nlet fn: Mock<(name: string) => number>\n```"
- name: 'Migration Guide: V8 Coverage''s coverage.ignoreEmptyLines is Enabled by Default ​'
  id: guide/migration#v8-coverage-s-coverage-ignoreemptylines-is-enabled-by-default
  summary: The default value of coverage.ignoreEmptyLines is now true
  belongs_to: Migration Guide
  description: |-
    ### V8 Coverage's `coverage.ignoreEmptyLines` is Enabled by Default

    The default value of `coverage.ignoreEmptyLines` is now true. This significant change may affect code coverage reports, requiring adjustments to coverage thresholds for some projects. This adjustment only affects the default setting when `coverage.provider` is `'v8'`.
- name: 'Migration Guide: Vue Snapshots ​'
  id: guide/migration#vue-snapshots
  summary: Otherwise your snapshots will have a lot of escaped " characters
  belongs_to: Migration Guide
  description: "### Vue Snapshots\n\nThis is not a Jest-specific feature, but if you previously were using Jest with vue-cli preset, you will need to install [`jest-serializer-vue`](https://github.com/eddyerburgh/jest-serializer-vue) package, and use it inside [setupFiles](../config/index#setupfiles):\n\n`vite.config.js`\n\njs\n\n``` javascript\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['./tests/unit/setup.js']\n  }\n})\n```\n\n`tests/unit/setup.js`\n\njs\n\n``` javascript\nimport vueSnapshotSerializer from 'jest-serializer-vue'\n\nexpect.addSnapshotSerializer(vueSnapshotSerializer)\n```\n\nOtherwise your snapshots will have a lot of escaped `\"` characters.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/migration](https://vitest.dev/guide/migration)"
- name: minWorkers *  ​
  id: config/index#minworkers
  summary: Minimum number or percentage of workers to run tests in
  belongs_to: Configuring Vitest
  description: "### minWorkers \\* \n\n- **Type:** `number | string`\n\nMinimum number or percentage of workers to run tests in. `poolOptions.{threads,vmThreads}.minThreads`/`poolOptions.forks.minForks` has higher priority."
- name: Miscellaneous ​
  id: api/vi#miscellaneous
  summary: A set of useful helper functions that Vitest provides
  belongs_to: Vi
  description: |-
    ## Miscellaneous

    A set of useful helper functions that Vitest provides.
- name: Mock Functions
  id: api/mock
  summary: You can create a mock function to track its execution with vi.fn method
  description: "# Mock Functions\n\nYou can create a mock function to track its execution with `vi.fn` method. If you want to track a method on an already created object, you can use `vi.spyOn` method:\n\njs\n\n``` javascript\nimport { vi } from 'vitest'\n\nconst fn = vi.fn()\nfn('hello world')\nfn.mock.calls[0] === ['hello world']\n\nconst market = {\n  getApples: () => 100\n}\n\nconst getApplesSpy = vi.spyOn(market, 'getApples')\nmarket.getApples()\ngetApplesSpy.mock.calls.length === 1\n```\n\nYou should use mock assertions (e.g., [`toHaveBeenCalled`](expect#tohavebeencalled)) on [`expect`](expect) to assert mock result. This API reference describes available properties and methods to manipulate mock behavior.\n\n## getMockImplementation\n\n- **Type:** `(...args: any) => any`\n\nReturns current mock implementation if there is one.\n\nIf mock was created with [`vi.fn`](vi#vi-fn), it will consider passed down method as a mock implementation.\n\nIf mock was created with [`vi.spyOn`](vi#vi-spyon), it will return `undefined` unless a custom implementation was provided.\n\n## getMockName\n\n- **Type:** `() => string`\n\nUse it to return the name given to mock with method `.mockName(name)`.\n\n## mockClear\n\n- **Type:** `() => MockInstance`\n\nClears all information about every call. After calling it, all properties on `.mock` will return empty state. This method does not reset implementations. It is useful if you need to clean up mock between different assertions.\n\nIf you want this method to be called before each test automatically, you can enable [`clearMocks`](../config/index#clearmocks) setting in config.\n\n## mockName\n\n- **Type:** `(name: string) => MockInstance`\n\nSets internal mock name. Useful to see the name of the mock if assertion fails.\n\n## mockImplementation\n\n- **Type:** `(fn: Function) => MockInstance`\n\nAccepts a function that will be used as an implementation of the mock.\n\nts\n\n``` javascript\nconst mockFn = vi.fn().mockImplementation(apples => apples + 1)\n// or: vi.fn(apples => apples + 1);\n\nconst NelliesBucket = mockFn(0)\nconst BobsBucket = mockFn(1)\n\nNelliesBucket === 1 // true\nBobsBucket === 2 // true\n\nmockFn.mock.calls[0][0] === 0 // true\nmockFn.mock.calls[1][0] === 1 // true\n```\n\n## mockImplementationOnce\n\n- **Type:** `(fn: Function) => MockInstance`\n\nAccepts a function that will be used as mock's implementation during the next call. Can be chained so that multiple function calls produce different results.\n\nts\n\n``` javascript\nconst myMockFn = vi\n  .fn()\n  .mockImplementationOnce(() => true)\n  .mockImplementationOnce(() => false)\n\nmyMockFn() // true\nmyMockFn() // false\n```\n\nWhen the mocked function runs out of implementations, it will invoke the default implementation that was set with `vi.fn(() => defaultValue)` or `.mockImplementation(() => defaultValue)` if they were called:\n\nts\n\n``` javascript\nconst myMockFn = vi\n  .fn(() => 'default')\n  .mockImplementationOnce(() => 'first call')\n  .mockImplementationOnce(() => 'second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\n```\n\n## withImplementation\n\n- **Type:** `(fn: Function, callback: () => void) => MockInstance`\n- **Type:** `(fn: Function, callback: () => Promise<unknown>) => Promise<MockInstance>`\n\nOverrides the original mock implementation temporarily while the callback is being executed.\n\njs\n\n``` javascript\nconst myMockFn = vi.fn(() => 'original')\n\nmyMockFn.withImplementation(() => 'temp', () => {\n  myMockFn() // 'temp'\n})\n\nmyMockFn() // 'original'\n```\n\nCan be used with an asynchronous callback. The method has to be awaited to use the original implementation afterward.\n\nts\n\n``` javascript\ntest('async callback', () => {\n  const myMockFn = vi.fn(() => 'original')\n\n  // We await this call since the callback is async\n  await myMockFn.withImplementation(\n    () => 'temp',\n    async () => {\n      myMockFn() // 'temp'\n    },\n  )\n\n  myMockFn() // 'original'\n})\n```\n\nNote that this method takes precedence over the [`mockImplementationOnce`](#mockimplementationonce).\n\n## mockRejectedValue\n\n- **Type:** `(value: any) => MockInstance`\n\nAccepts an error that will be rejected when async function is called.\n\nts\n\n``` javascript\nconst asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))\n\nawait asyncMock() // throws \"Async error\"\n```\n\n## mockRejectedValueOnce\n\n- **Type:** `(value: any) => MockInstance`\n\nAccepts a value that will be rejected during the next function call. If chained, every consecutive call will reject specified value.\n\nts\n\n``` javascript\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValueOnce('first call')\n  .mockRejectedValueOnce(new Error('Async error'))\n\nawait asyncMock() // first call\nawait asyncMock() // throws \"Async error\"\n```\n\n## mockReset\n\n- **Type:** `() => MockInstance`\n\nDoes what `mockClear` does and makes inner implementation an empty function (returning `undefined` when invoked). This also resets all \"once\" implementations. This is useful when you want to completely reset a mock to the default state.\n\nIf you want this method to be called before each test automatically, you can enable [`mockReset`](../config/index#mockreset) setting in config.\n\n## mockRestore\n\n- **Type:** `() => MockInstance`\n\nDoes what `mockReset` does and restores inner implementation to the original function.\n\nNote that restoring mock from `vi.fn()` will set implementation to an empty function that returns `undefined`. Restoring a `vi.fn(impl)` will restore implementation to `impl`.\n\nIf you want this method to be called before each test automatically, you can enable [`restoreMocks`](../config/index#restoremocks) setting in config.\n\n## mockResolvedValue\n\n- **Type:** `(value: any) => MockInstance`\n\nAccepts a value that will be resolved when async function is called.\n\nts\n\n``` javascript\nconst asyncMock = vi.fn().mockResolvedValue(42)\n\nawait asyncMock() // 42\n```\n\n## mockResolvedValueOnce\n\n- **Type:** `(value: any) => MockInstance`\n\nAccepts a value that will be resolved during the next function call. If chained, every consecutive call will resolve specified value.\n\nts\n\n``` javascript\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValue('default')\n  .mockResolvedValueOnce('first call')\n  .mockResolvedValueOnce('second call')\n\nawait asyncMock() // first call\nawait asyncMock() // second call\nawait asyncMock() // default\nawait asyncMock() // default\n```\n\n## mockReturnThis\n\n- **Type:** `() => MockInstance`\n\nUse this if you need to return `this` context from the method without invoking actual implementation. This is a shorthand for:\n\nts\n\n``` javascript\nspy.mockImplementation(function () {\n  return this\n})\n```\n\n## mockReturnValue\n\n- **Type:** `(value: any) => MockInstance`\n\nAccepts a value that will be returned whenever the mock function is called.\n\nts\n\n``` javascript\nconst mock = vi.fn()\nmock.mockReturnValue(42)\nmock() // 42\nmock.mockReturnValue(43)\nmock() // 43\n```\n\n## mockReturnValueOnce\n\n- **Type:** `(value: any) => MockInstance`\n\nAccepts a value that will be returned during the next function call. If chained, every consecutive call will return the specified value.\n\nWhen there are no more `mockReturnValueOnce` values to use, mock will fallback to previously defined implementation if there is one.\n\nts\n\n``` javascript\nconst myMockFn = vi\n  .fn()\n  .mockReturnValue('default')\n  .mockReturnValueOnce('first call')\n  .mockReturnValueOnce('second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\n```\n\n## mock.calls\n\nThis is an array containing all arguments for each call. One item of the array is the arguments of that call.\n\njs\n\n``` javascript\nconst fn = vi.fn()\n\nfn('arg1', 'arg2')\nfn('arg3')\n\nfn.mock.calls === [\n  ['arg1', 'arg2'], // first call\n  ['arg3'], // second call\n]\n```\n\n## mock.lastCall\n\nThis contains the arguments of the last call. If mock wasn't called, will return `undefined`.\n\n## mock.results\n\nThis is an array containing all values that were `returned` from the function. One item of the array is an object with properties `type` and `value`. Available types are:\n\n- `'return'` - function returned without throwing.\n- `'throw'` - function threw a value.\n\nThe `value` property contains the returned value or thrown error. If the function returned a `Promise`, then `result` will always be `'return'` even if the promise was rejected.\n\njs\n\n``` javascript\nconst fn = vi.fn()\n  .mockReturnValueOnce('result')\n  .mockImplementationOnce(() => { throw new Error('thrown error') })\n\nconst result = fn() // returned 'result'\n\ntry {\n  fn() // threw Error\n}\ncatch {}\n\nfn.mock.results === [\n  // first result\n  {\n    type: 'return',\n    value: 'result',\n  },\n  // last result\n  {\n    type: 'throw',\n    value: Error,\n  },\n]\n```\n\n## mock.settledResults\n\nAn array containing all values that were `resolved` or `rejected` from the function.\n\nThis array will be empty if the function was never resolved or rejected.\n\njs\n\n``` javascript\nconst fn = vi.fn().mockResolvedValueOnce('result')\n\nconst result = fn()\n\nfn.mock.settledResults === []\n\nawait result\n\nfn.mock.settledResults === [\n  {\n    type: 'fulfilled',\n    value: 'result',\n  },\n]\n```\n\n## mock.invocationCallOrder\n\nThis property returns the order of the mock function's execution. It is an array of numbers that are shared between all defined mocks.\n\njs\n\n``` javascript\nconst fn1 = vi.fn()\nconst fn2 = vi.fn()\n\nfn1()\nfn2()\nfn1()\n\nfn1.mock.invocationCallOrder === [1, 3]\nfn2.mock.invocationCallOrder === [2]\n```\n\n## mock.contexts\n\nThis property is an array of `this` values used during each call to the mock function.\n\njs\n\n``` javascript\nconst fn = vi.fn()\nconst context = {}\n\nfn.apply(context)\nfn.call(context)\n\nfn.mock.contexts[0] === context\nfn.mock.contexts[1] === context\n```\n\n## mock.instances\n\nThis property is an array containing all instances that were created when the mock was called with the `new` keyword. Note that this is an actual context (`this`) of the function, not a return value.\n\n**WARNING**\n\nIf mock was instantiated with `new MyClass()`, then `mock.instances` will be an array with one value:\n\njs\n\n``` javascript\nconst MyClass = vi.fn()\nconst a = new MyClass()\n\nMyClass.mock.instances[0] === a\n```\n\nIf you return a value from constructor, it will not be in `instances` array, but instead inside `results`:\n\njs\n\n``` javascript\nconst Spy = vi.fn(() => ({ method: vi.fn() }))\nconst a = new Spy()\n\nSpy.mock.instances[0] !== a\nSpy.mock.results[0] === a\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/mock](https://vitest.dev/api/mock)"
- name: Mock Modules ​
  id: api/vi#mock-modules
  summary: This section describes the API that you can use when mocking a module
  belongs_to: Vi
  description: |-
    ## Mock Modules

    This section describes the API that you can use when [mocking a module](../guide/mocking#modules). Beware that Vitest doesn't support mocking modules imported using `require()`.
- name: mock.calls ​
  id: api/mock#mock-calls
  summary: This is an array containing all arguments for each call
  belongs_to: Mock Functions
  description: |-
    ## mock.calls

    This is an array containing all arguments for each call. One item of the array is the arguments of that call.

    js

    ``` javascript
    const fn = vi.fn()

    fn('arg1', 'arg2')
    fn('arg3')

    fn.mock.calls === [
      ['arg1', 'arg2'], // first call
      ['arg3'], // second call
    ]
    ```
- name: mock.contexts ​
  id: api/mock#mock-contexts
  summary: This property is an array of this values used during each call to the mock function
  belongs_to: Mock Functions
  description: |-
    ## mock.contexts

    This property is an array of `this` values used during each call to the mock function.

    js

    ``` javascript
    const fn = vi.fn()
    const context = {}

    fn.apply(context)
    fn.call(context)

    fn.mock.contexts[0] === context
    fn.mock.contexts[1] === context
    ```
- name: mock.instances ​
  id: api/mock#mock-instances
  summary: This property is an array containing all instances that were created when the mock was called with the new keyword
  belongs_to: Mock Functions
  description: "## mock.instances\n\nThis property is an array containing all instances that were created when the mock was called with the `new` keyword. Note that this is an actual context (`this`) of the function, not a return value.\n\n**WARNING**\n\nIf mock was instantiated with `new MyClass()`, then `mock.instances` will be an array with one value:\n\njs\n\n``` javascript\nconst MyClass = vi.fn()\nconst a = new MyClass()\n\nMyClass.mock.instances[0] === a\n```\n\nIf you return a value from constructor, it will not be in `instances` array, but instead inside `results`:\n\njs\n\n``` javascript\nconst Spy = vi.fn(() => ({ method: vi.fn() }))\nconst a = new Spy()\n\nSpy.mock.instances[0] !== a\nSpy.mock.results[0] === a\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/mock](https://vitest.dev/api/mock)"
- name: mock.invocationCallOrder ​
  id: api/mock#mock-invocationcallorder
  summary: This property returns the order of the mock function's execution
  belongs_to: Mock Functions
  description: |-
    ## mock.invocationCallOrder

    This property returns the order of the mock function's execution. It is an array of numbers that are shared between all defined mocks.

    js

    ``` javascript
    const fn1 = vi.fn()
    const fn2 = vi.fn()

    fn1()
    fn2()
    fn1()

    fn1.mock.invocationCallOrder === [1, 3]
    fn2.mock.invocationCallOrder === [2]
    ```
- name: mock.lastCall ​
  id: api/mock#mock-lastcall
  summary: This contains the arguments of the last call
  belongs_to: Mock Functions
  description: |-
    ## mock.lastCall

    This contains the arguments of the last call. If mock wasn't called, will return `undefined`.
- name: mock.results ​
  id: api/mock#mock-results
  summary: This is an array containing all values that were returned from the function
  belongs_to: Mock Functions
  description: |-
    ## mock.results

    This is an array containing all values that were `returned` from the function. One item of the array is an object with properties `type` and `value`. Available types are:

    - `'return'` - function returned without throwing.
    - `'throw'` - function threw a value.

    The `value` property contains the returned value or thrown error. If the function returned a `Promise`, then `result` will always be `'return'` even if the promise was rejected.

    js

    ``` javascript
    const fn = vi.fn()
      .mockReturnValueOnce('result')
      .mockImplementationOnce(() => { throw new Error('thrown error') })

    const result = fn() // returned 'result'

    try {
      fn() // threw Error
    }
    catch {}

    fn.mock.results === [
      // first result
      {
        type: 'return',
        value: 'result',
      },
      // last result
      {
        type: 'throw',
        value: Error,
      },
    ]
    ```
- name: mock.settledResults ​
  id: api/mock#mock-settledresults
  summary: An array containing all values that were resolved or rejected from the function
  belongs_to: Mock Functions
  description: |-
    ## mock.settledResults

    An array containing all values that were `resolved` or `rejected` from the function.

    This array will be empty if the function was never resolved or rejected.

    js

    ``` javascript
    const fn = vi.fn().mockResolvedValueOnce('result')

    const result = fn()

    fn.mock.settledResults === []

    await result

    fn.mock.settledResults === [
      {
        type: 'fulfilled',
        value: 'result',
      },
    ]
    ```
- name: mockClear ​
  id: api/mock#mockclear
  summary: Clears all information about every call
  belongs_to: Mock Functions
  description: |-
    ## mockClear

    - **Type:** `() => MockInstance`

    Clears all information about every call. After calling it, all properties on `.mock` will return empty state. This method does not reset implementations. It is useful if you need to clean up mock between different assertions.

    If you want this method to be called before each test automatically, you can enable [`clearMocks`](../config/index#clearmocks) setting in config.
- name: mockImplementation ​
  id: api/mock#mockimplementation
  summary: Accepts a function that will be used as an implementation of the mock
  belongs_to: Mock Functions
  description: |-
    ## mockImplementation

    - **Type:** `(fn: Function) => MockInstance`

    Accepts a function that will be used as an implementation of the mock.

    ts

    ``` javascript
    const mockFn = vi.fn().mockImplementation(apples => apples + 1)
    // or: vi.fn(apples => apples + 1);

    const NelliesBucket = mockFn(0)
    const BobsBucket = mockFn(1)

    NelliesBucket === 1 // true
    BobsBucket === 2 // true

    mockFn.mock.calls[0][0] === 0 // true
    mockFn.mock.calls[1][0] === 1 // true
    ```
- name: mockImplementationOnce ​
  id: api/mock#mockimplementationonce
  summary: Accepts a function that will be used as mock's implementation during the next call
  belongs_to: Mock Functions
  description: |-
    ## mockImplementationOnce

    - **Type:** `(fn: Function) => MockInstance`

    Accepts a function that will be used as mock's implementation during the next call. Can be chained so that multiple function calls produce different results.

    ts

    ``` javascript
    const myMockFn = vi
      .fn()
      .mockImplementationOnce(() => true)
      .mockImplementationOnce(() => false)

    myMockFn() // true
    myMockFn() // false
    ```

    When the mocked function runs out of implementations, it will invoke the default implementation that was set with `vi.fn(() => defaultValue)` or `.mockImplementation(() => defaultValue)` if they were called:

    ts

    ``` javascript
    const myMockFn = vi
      .fn(() => 'default')
      .mockImplementationOnce(() => 'first call')
      .mockImplementationOnce(() => 'second call')

    // 'first call', 'second call', 'default', 'default'
    console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())
    ```
- name: Mocking
  id: guide/mocking
  summary: When writing tests it's only a matter of time before you need to create a "fake" version of an internal — or external — service
  description: "# Mocking\n\nWhen writing tests it's only a matter of time before you need to create a \"fake\" version of an internal — or external — service. This is commonly referred to as **mocking**. Vitest provides utility functions to help you out through its **vi** helper. You can `import { vi } from 'vitest'` or access it **globally** (when [global configuration](../config/index#globals) is **enabled**).\n\n**WARNING**\n\nAlways remember to clear or restore mocks before or after each test run to undo mock state changes between runs! See [`mockReset`](../api/mock#mockreset) docs for more info.\n\nIf you wanna dive in head first, check out the [API section](../api/vi) otherwise keep reading to take a deeper dive into the world of mocking.\n\n## Dates\n\nSometimes you need to be in control of the date to ensure consistency when testing. Vitest uses [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers) package for manipulating timers, as well as system date. You can find more about the specific API in detail [here](../api/vi#vi-setsystemtime).\n\n### Example\n\njs\n\n``` javascript\nimport { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'\n\nconst businessHours = [9, 17]\n\nfunction purchase() {\n  const currentHour = new Date().getHours()\n  const [open, close] = businessHours\n\n  if (currentHour > open && currentHour < close) {\n    return { message: 'Success' }\n  }\n\n  return { message: 'Error' }\n}\n\ndescribe('purchasing flow', () => {\n  beforeEach(() => {\n    // tell vitest we use mocked time\n    vi.useFakeTimers()\n  })\n\n  afterEach(() => {\n    // restoring date after each test run\n    vi.useRealTimers()\n  })\n\n  it('allows purchases within business hours', () => {\n    // set hour within business hours\n    const date = new Date(2000, 1, 1, 13)\n    vi.setSystemTime(date)\n\n    // access Date.now() will result in the date set above\n    expect(purchase()).toEqual({ message: 'Success' })\n  })\n\n  it('disallows purchases outside of business hours', () => {\n    // set hour outside business hours\n    const date = new Date(2000, 1, 1, 19)\n    vi.setSystemTime(date)\n\n    // access Date.now() will result in the date set above\n    expect(purchase()).toEqual({ message: 'Error' })\n  })\n})\n```\n\n## Functions\n\nMocking functions can be split up into two different categories; *spying & mocking*.\n\nSometimes all you need is to validate whether or not a specific function has been called (and possibly which arguments were passed). In these cases a spy would be all we need which you can use directly with `vi.spyOn()` ([read more here](../api/vi#vi-spyon)).\n\nHowever spies can only help you **spy** on functions, they are not able to alter the implementation of those functions. In the case where we do need to create a fake (or mocked) version of a function we can use `vi.fn()` ([read more here](../api/vi#vi-fn)).\n\nWe use [Tinyspy](https://github.com/tinylibs/tinyspy) as a base for mocking functions, but we have our own wrapper to make it `jest` compatible. Both `vi.fn()` and `vi.spyOn()` share the same methods, however only the return result of `vi.fn()` is callable.\n\n### Example\n\njs\n\n``` javascript\nimport { afterEach, describe, expect, it, vi } from 'vitest'\n\nconst messages = {\n  items: [\n    { message: 'Simple test message', from: 'Testman' },\n    // ...\n  ],\n  getLatest, // can also be a `getter or setter if supported`\n}\n\nfunction getLatest(index = messages.items.length - 1) {\n  return messages.items[index]\n}\n\ndescribe('reading messages', () => {\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  it('should get the latest message with a spy', () => {\n    const spy = vi.spyOn(messages, 'getLatest')\n    expect(spy.getMockName()).toEqual('getLatest')\n\n    expect(messages.getLatest()).toEqual(\n      messages.items[messages.items.length - 1],\n    )\n\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    spy.mockImplementationOnce(() => 'access-restricted')\n    expect(messages.getLatest()).toEqual('access-restricted')\n\n    expect(spy).toHaveBeenCalledTimes(2)\n  })\n\n  it('should get with a mock', () => {\n    const mock = vi.fn().mockImplementation(getLatest)\n\n    expect(mock()).toEqual(messages.items[messages.items.length - 1])\n    expect(mock).toHaveBeenCalledTimes(1)\n\n    mock.mockImplementationOnce(() => 'access-restricted')\n    expect(mock()).toEqual('access-restricted')\n\n    expect(mock).toHaveBeenCalledTimes(2)\n\n    expect(mock()).toEqual(messages.items[messages.items.length - 1])\n    expect(mock).toHaveBeenCalledTimes(3)\n  })\n})\n```\n\n### More\n\n- [Jest's Mock Functions](https://jestjs.io/docs/mock-function-api)\n\n## Globals\n\nYou can mock global variables that are not present with `jsdom` or `node` by using [`vi.stubGlobal`](../api/vi#vi-stubglobal) helper. It will put the value of the global variable into a `globalThis` object.\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\n\nconst IntersectionObserverMock = vi.fn(() => ({\n  disconnect: vi.fn(),\n  observe: vi.fn(),\n  takeRecords: vi.fn(),\n  unobserve: vi.fn(),\n}))\n\nvi.stubGlobal('IntersectionObserver', IntersectionObserverMock)\n\n// now you can access it as `IntersectionObserver` or `window.IntersectionObserver`\n```\n\n## Modules\n\nMock modules observe third-party-libraries, that are invoked in some other code, allowing you to test arguments, output or even redeclare its implementation.\n\nSee the [`vi.mock()` API section](../api/vi#vi-mock) for a more in-depth detailed API description.\n\n### Automocking Algorithm\n\nIf your code is importing a mocked module, without any associated `__mocks__` file or `factory` for this module, Vitest will mock the module itself by invoking it and mocking every export.\n\nThe following principles apply\n\n- All arrays will be emptied\n- All primitives and collections will stay the same\n- All objects will be deeply cloned\n- All instances of classes and their prototypes will be deeply cloned\n\n### Virtual Modules\n\nVitest supports mocking Vite [virtual modules](https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention). It works differently from how virtual modules are treated in Jest. Instead of passing down `virtual: true` to a `vi.mock` function, you need to tell Vite that module exists otherwise it will fail during parsing. You can do that in several ways:\n\n1.  Provide an alias\n\nts\n\n``` javascript\n// vitest.config.js\nexport default {\n  test: {\n    alias: {\n      '$app/forms': resolve('./mocks/forms.js')\n    }\n  }\n}\n```\n\n2.  Provide a plugin that resolves a virtual module\n\nts\n\n``` javascript\n// vitest.config.js\nexport default {\n  plugins: [\n    {\n      name: 'virtual-modules',\n      resolveId(id) {\n        if (id === '$app/forms') {\n          return 'virtual:$app/forms'\n        }\n      }\n    }\n  ]\n}\n```\n\nThe benefit of the second approach is that you can dynamically create different virtual entrypoints. If you redirect several virtual modules into a single file, then all of them will be affected by `vi.mock`, so make sure to use unique identifiers.\n\n### Mocking Pitfalls\n\nBeware that it is not possible to mock calls to methods that are called inside other methods of the same file. For example, in this code:\n\nts\n\n``` javascript\nexport function foo() {\n  return 'foo'\n}\n\nexport function foobar() {\n  return `${foo()}bar`\n}\n```\n\nIt is not possible to mock the `foo` method from the outside because it is referenced directly. So this code will have no effect on the `foo` call inside `foobar` (but it will affect the `foo` call in other modules):\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\nimport * as mod from './foobar.js'\n\n// this will only affect \"foo\" outside of the original module\nvi.spyOn(mod, 'foo')\nvi.mock('./foobar.js', async (importOriginal) => {\n  return {\n    ...await importOriginal<typeof import('./foobar.js')>(),\n    // this will only affect \"foo\" outside of the original module\n    foo: () => 'mocked'\n  }\n})\n```\n\nYou can confirm this behaviour by providing the implementation to the `foobar` method directly:\n\nts\n\n``` javascript\n// foobar.test.js\nimport * as mod from './foobar.js'\n\nvi.spyOn(mod, 'foo')\n\n// exported foo references mocked method\nmod.foobar(mod.foo)\n```\n\nts\n\n``` javascript\n// foobar.js\nexport function foo() {\n  return 'foo'\n}\n\nexport function foobar(injectedFoo) {\n  return injectedFoo !== foo // false\n}\n```\n\nThis is the intended behaviour. It is usually a sign of bad code when mocking is involved in such a manner. Consider refactoring your code into multiple files or improving your application architecture by using techniques such as [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection).\n\n### Example\n\njs\n\n``` javascript\nimport { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'\nimport { Client } from 'pg'\nimport { failure, success } from './handlers.js'\n\n// get todos\nexport async function getTodos(event, context) {\n  const client = new Client({\n    // ...clientOptions\n  })\n\n  await client.connect()\n\n  try {\n    const result = await client.query('SELECT * FROM todos;')\n\n    client.end()\n\n    return success({\n      message: `${result.rowCount} item(s) returned`,\n      data: result.rows,\n      status: true,\n    })\n  }\n  catch (e) {\n    console.error(e.stack)\n\n    client.end()\n\n    return failure({ message: e, status: false })\n  }\n}\n\nvi.mock('pg', () => {\n  const Client = vi.fn()\n  Client.prototype.connect = vi.fn()\n  Client.prototype.query = vi.fn()\n  Client.prototype.end = vi.fn()\n\n  return { Client }\n})\n\nvi.mock('./handlers.js', () => {\n  return {\n    success: vi.fn(),\n    failure: vi.fn(),\n  }\n})\n\ndescribe('get a list of todo items', () => {\n  let client\n\n  beforeEach(() => {\n    client = new Client()\n  })\n\n  afterEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it('should return items successfully', async () => {\n    client.query.mockResolvedValueOnce({ rows: [], rowCount: 0 })\n\n    await getTodos()\n\n    expect(client.connect).toBeCalledTimes(1)\n    expect(client.query).toBeCalledWith('SELECT * FROM todos;')\n    expect(client.end).toBeCalledTimes(1)\n\n    expect(success).toBeCalledWith({\n      message: '0 item(s) returned',\n      data: [],\n      status: true,\n    })\n  })\n\n  it('should throw an error', async () => {\n    const mError = new Error('Unable to retrieve rows')\n    client.query.mockRejectedValueOnce(mError)\n\n    await getTodos()\n\n    expect(client.connect).toBeCalledTimes(1)\n    expect(client.query).toBeCalledWith('SELECT * FROM todos;')\n    expect(client.end).toBeCalledTimes(1)\n    expect(failure).toBeCalledWith({ message: mError, status: false })\n  })\n})\n```\n\n## File System\n\nMocking the file system ensures that the tests do not depend on the actual file system, making the tests more reliable and predictable. This isolation helps in avoiding side effects from previous tests. It allows for testing error conditions and edge cases that might be difficult or impossible to replicate with an actual file system, such as permission issues, disk full scenarios, or read/write errors.\n\nVitest doesn't provide any file system mocking API out of the box. You can use `vi.mock` to mock the `fs` module manually, but it's hard to maintain. Instead, we recommend using [`memfs`](https://www.npmjs.com/package/memfs) to do that for you. `memfs` creates an in-memory file system, which simulates file system operations without touching the actual disk. This approach is fast and safe, avoiding any potential side effects on the real file system.\n\n### Example\n\nTo automatially redirect every `fs` call to `memfs`, you can create `__mocks__/fs.cjs` and `__mocks__/fs/promises.cjs` files at the root of your project:\n\n\\_\\_mocks\\_\\_/fs.cjs\\_\\_mocks\\_\\_/fs/promises.cjs\n\nts\n\n``` javascript\n// we can also use `import`, but then\n// every export should be explicitly defined\n\nconst { fs } = require('memfs')\nmodule.exports = fs\n```\n\nts\n\n``` javascript\n// we can also use `import`, but then\n// every export should be explicitly defined\n\nconst { fs } = require('memfs')\nmodule.exports = fs.promises\n```\n\nts\n\n``` javascript\n// hello-world.js\nimport { readFileSync } from 'node:fs'\n\nexport function readHelloWorld(path) {\n  return readFileSync('./hello-world.txt')\n}\n```\n\nts\n\n``` javascript\n// hello-world.test.js\nimport { beforeEach, expect, it, vi } from 'vitest'\nimport { fs, vol } from 'memfs'\nimport { readHelloWorld } from './hello-world.js'\n\n// tell vitest to use fs mock from __mocks__ folder\n// this can be done in a setup file if fs should always be mocked\nvi.mock('node:fs')\nvi.mock('node:fs/promises')\n\nbeforeEach(() => {\n  // reset the state of in-memory fs\n  vol.reset()\n})\n\nit('should return correct text', () => {\n  const path = './hello-world.txt'\n  fs.writeFileSync(path, 'hello world')\n\n  const text = readHelloWorld(path)\n  expect(text).toBe('hello world')\n})\n\nit('can return a value multiple times', () => {\n  // you can use vol.fromJSON to define several files\n  vol.fromJSON(\n    {\n      './dir1/hw.txt': 'hello dir1',\n      './dir2/hw.txt': 'hello dir2',\n    },\n    // default cwd\n    '/tmp'\n  )\n\n  expect(readHelloWorld('/tmp/dir1/hw.txt')).toBe('hello dir1')\n  expect(readHelloWorld('/tmp/dir2/hw.txt')).toBe('hello dir2')\n})\n```\n\n## Requests\n\nBecause Vitest runs in Node, mocking network requests is tricky; web APIs are not available, so we need something that will mimic network behavior for us. We recommend [Mock Service Worker](https://mswjs.io/) to accomplish this. It will let you mock both `REST` and `GraphQL` network requests, and is framework agnostic.\n\nMock Service Worker (MSW) works by intercepting the requests your tests make, allowing you to use it without changing any of your application code. In-browser, this uses the [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API). In Node.js, and for Vitest, it uses the [`@mswjs/interceptors`](https://github.com/mswjs/interceptors) library. To learn more about MSW, read their [introduction](https://mswjs.io/docs/)\n\n### Configuration\n\nYou can use it like below in your [setup file](../config/index#setupfiles)\n\njs\n\n``` javascript\nimport { afterAll, afterEach, beforeAll } from 'vitest'\nimport { setupServer } from 'msw/node'\nimport { HttpResponse, graphql, http } from 'msw'\n\nconst posts = [\n  {\n    userId: 1,\n    id: 1,\n    title: 'first post title',\n    body: 'first post body',\n  },\n  // ...\n]\n\nexport const restHandlers = [\n  http.get('https://rest-endpoint.example/path/to/posts', () => {\n    return HttpResponse.json(posts)\n  }),\n]\n\nconst graphqlHandlers = [\n  graphql.query('ListPosts', () => {\n    return HttpResponse.json(\n      {\n        data: { posts },\n      },\n    )\n  }),\n]\n\nconst server = setupServer(...restHandlers, ...graphqlHandlers)\n\n// Start server before all tests\nbeforeAll(() => server.listen({ onUnhandledRequest: 'error' }))\n\n//  Close server after all tests\nafterAll(() => server.close())\n\n// Reset handlers after each test `important for test isolation`\nafterEach(() => server.resetHandlers())\n```\n\n> Configuring the server with `onUnhandleRequest: 'error'` ensures that an error is thrown whenever there is a request that does not have a corresponding request handler.\n\n### More\n\nThere is much more to MSW. You can access cookies and query parameters, define mock error responses, and much more! To see all you can do with MSW, read [their documentation](https://mswjs.io/docs).\n\n## Timers\n\nWhen we test code that involves timeouts or intervals, instead of having our tests wait it out or timeout, we can speed up our tests by using \"fake\" timers that mock calls to `setTimeout` and `setInterval`.\n\nSee the [`vi.useFakeTimers` API section](../api/vi#vi-usefaketimers) for a more in depth detailed API description.\n\n### Example\n\njs\n\n``` javascript\nimport { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'\n\nfunction executeAfterTwoHours(func) {\n  setTimeout(func, 1000 * 60 * 60 * 2) // 2 hours\n}\n\nfunction executeEveryMinute(func) {\n  setInterval(func, 1000 * 60) // 1 minute\n}\n\nconst mock = vi.fn(() => console.log('executed'))\n\ndescribe('delayed execution', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n  it('should execute the function', () => {\n    executeAfterTwoHours(mock)\n    vi.runAllTimers()\n    expect(mock).toHaveBeenCalledTimes(1)\n  })\n  it('should not execute the function', () => {\n    executeAfterTwoHours(mock)\n    // advancing by 2ms won't trigger the func\n    vi.advanceTimersByTime(2)\n    expect(mock).not.toHaveBeenCalled()\n  })\n  it('should execute every minute', () => {\n    executeEveryMinute(mock)\n    vi.advanceTimersToNextTimer()\n    expect(mock).toHaveBeenCalledTimes(1)\n    vi.advanceTimersToNextTimer()\n    expect(mock).toHaveBeenCalledTimes(2)\n  })\n})\n```\n\n## Cheat Sheet\n\n**INFO**\n\n`vi` in the examples below is imported directly from `vitest`. You can also use it globally, if you set `globals` to `true` in your [config](../config/index).\n\nI want to…\n\n### Spy on a `method`\n\nts\n\n``` javascript\nconst instance = new SomeClass()\nvi.spyOn(instance, 'method')\n```\n\n### Mock exported variables\n\njs\n\n``` javascript\n// some-path.js\nexport const getter = 'variable'\n```\n\nts\n\n``` javascript\n// some-path.test.ts\nimport * as exports from './some-path.js'\n\nvi.spyOn(exports, 'getter', 'get').mockReturnValue('mocked')\n```\n\n### Mock an exported function\n\n1.  Example with `vi.mock`:\n\n**WARNING**\n\nDon't forget that a `vi.mock` call is hoisted to top of the file. It will always be executed before all imports.\n\nts\n\n``` javascript\n// ./some-path.js\nexport function method() {}\n```\n\nts\n\n``` javascript\nimport { method } from './some-path.js'\n\nvi.mock('./some-path.js', () => ({\n  method: vi.fn()\n}))\n```\n\n2.  Example with `vi.spyOn`:\n\nts\n\n``` javascript\nimport * as exports from './some-path.js'\n\nvi.spyOn(exports, 'method').mockImplementation(() => {})\n```\n\n### Mock an exported class implementation\n\n1.  Example with `vi.mock` and `.prototype`:\n\nts\n\n``` javascript\n// some-path.ts\nexport class SomeClass {}\n```\n\nts\n\n``` javascript\nimport { SomeClass } from './some-path.js'\n\nvi.mock('./some-path.js', () => {\n  const SomeClass = vi.fn()\n  SomeClass.prototype.someMethod = vi.fn()\n  return { SomeClass }\n})\n// SomeClass.mock.instances will have SomeClass\n```\n\n2.  Example with `vi.mock` and a return value:\n\nts\n\n``` javascript\nimport { SomeClass } from './some-path.js'\n\nvi.mock('./some-path.js', () => {\n  const SomeClass = vi.fn(() => ({\n    someMethod: vi.fn()\n  }))\n  return { SomeClass }\n})\n// SomeClass.mock.returns will have returned object\n```\n\n3.  Example with `vi.spyOn`:\n\nts\n\n``` javascript\nimport * as exports from './some-path.js'\n\nvi.spyOn(exports, 'SomeClass').mockImplementation(() => {\n  // whatever suites you from first two examples\n})\n```\n\n### Spy on an object returned from a function\n\n1.  Example using cache:\n\nts\n\n``` javascript\n// some-path.ts\nexport function useObject() {\n  return { method: () => true }\n}\n```\n\nts\n\n``` javascript\n// useObject.js\nimport { useObject } from './some-path.js'\n\nconst obj = useObject()\nobj.method()\n```\n\nts\n\n``` javascript\n// useObject.test.js\nimport { useObject } from './some-path.js'\n\nvi.mock('./some-path.js', () => {\n  let _cache\n  const useObject = () => {\n    if (!_cache) {\n      _cache = {\n        method: vi.fn(),\n      }\n    }\n    // now every time that useObject() is called it will\n    // return the same object reference\n    return _cache\n  }\n  return { useObject }\n})\n\nconst obj = useObject()\n// obj.method was called inside some-path\nexpect(obj.method).toHaveBeenCalled()\n```\n\n### Mock part of a module\n\nts\n\n``` javascript\nimport { mocked, original } from './some-path.js'\n\nvi.mock('./some-path.js', async (importOriginal) => {\n  const mod = await importOriginal<typeof import('./some-path.js')>()\n  return {\n    ...mod,\n    mocked: vi.fn()\n  }\n})\noriginal() // has original behaviour\nmocked() // is a spy function\n```\n\n### Mock the current date\n\nTo mock `Date`'s time, you can use `vi.setSystemTime` helper function. This value will **not** automatically reset between different tests.\n\nBeware that using `vi.useFakeTimers` also changes the `Date`'s time.\n\nts\n\n``` javascript\nconst mockDate = new Date(2022, 0, 1)\nvi.setSystemTime(mockDate)\nconst now = new Date()\nexpect(now.valueOf()).toBe(mockDate.valueOf())\n// reset mocked time\nvi.useRealTimers()\n```\n\n### Mock a global variable\n\nYou can set global variable by assigning a value to `globalThis` or using [`vi.stubGlobal`](../api/vi#vi-stubglobal) helper. When using `vi.stubGlobal`, it will **not** automatically reset between different tests, unless you enable [`unstubGlobals`](../config/index#unstubglobals) config option or call [`vi.unstubAllGlobals`](../api/vi#vi-unstuballglobals).\n\nts\n\n``` javascript\nvi.stubGlobal('__VERSION__', '1.0.0')\nexpect(__VERSION__).toBe('1.0.0')\n```\n\n### Mock `import.meta.env`\n\n1.  To change environmental variable, you can just assign a new value to it.\n\n**WARNING**\n\nThe environmental variable value will ***not*** automatically reset between different tests.\n\nts\n\n``` javascript\nimport { beforeEach, expect, it } from 'vitest'\n\n// you can reset it in beforeEach hook manually\nconst originalViteEnv = import.meta.env.VITE_ENV\n\nbeforeEach(() => {\n  import.meta.env.VITE_ENV = originalViteEnv\n})\n\nit('changes value', () => {\n  import.meta.env.VITE_ENV = 'staging'\n  expect(import.meta.env.VITE_ENV).toBe('staging')\n})\n```\n\n2.  If you want to automatically reset the value(s), you can use the `vi.stubEnv` helper with the [`unstubEnvs`](../config/index#unstubenvs) config option enabled (or call [`vi.unstubAllEnvs`](../api/vi#vi-unstuballenvs) manually in a `beforeEach` hook):\n\nts\n\n``` javascript\nimport { expect, it, vi } from 'vitest'\n\n// before running tests \"VITE_ENV\" is \"test\"\nimport.meta.env.VITE_ENV === 'test'\n\nit('changes value', () => {\n  vi.stubEnv('VITE_ENV', 'staging')\n  expect(import.meta.env.VITE_ENV).toBe('staging')\n})\n\nit('the value is restored before running an other test', () => {\n  expect(import.meta.env.VITE_ENV).toBe('test')\n})\n```\n\nts\n\n``` javascript\n// vitest.config.ts\nexport default {\n  test: {\n    unstubAllEnvs: true,\n  }\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/mocking](https://vitest.dev/guide/mocking)"
- name: Mocking Functions and Objects ​
  id: api/vi#mocking-functions-and-objects
  summary: This section describes how to work with method mocks and replace environmental and global variables
  belongs_to: Vi
  description: |-
    ## Mocking Functions and Objects

    This section describes how to work with [method mocks](mock) and replace environmental and global variables.
- name: 'Mocking: Automocking Algorithm ​'
  id: guide/mocking#automocking-algorithm
  summary: If your code is importing a mocked module, without any associated __mocks__ file or factory for this module, Vitest will mock the module itself by invoking it and mocking every export
  belongs_to: Mocking
  description: |-
    ### Automocking Algorithm

    If your code is importing a mocked module, without any associated `__mocks__` file or `factory` for this module, Vitest will mock the module itself by invoking it and mocking every export.

    The following principles apply

    - All arrays will be emptied
    - All primitives and collections will stay the same
    - All objects will be deeply cloned
    - All instances of classes and their prototypes will be deeply cloned

    &nbsp;
- name: 'Mocking: Cheat Sheet ​'
  id: guide/mocking#cheat-sheet
  summary: vi in the examples below is imported directly from vitest
  belongs_to: Mocking
  description: |-
    ## Cheat Sheet

    **INFO**

    `vi` in the examples below is imported directly from `vitest`. You can also use it globally, if you set `globals` to `true` in your [config](../config/index).

    I want to…
- name: 'Mocking: Configuration ​'
  id: guide/mocking#configuration
  summary: 'Configuring the server with onUnhandleRequest: ''error'' ensures that an error is thrown whenever there is a request that does not have a corresponding request handler'
  belongs_to: Mocking
  description: |-
    ### Configuration

    You can use it like below in your [setup file](../config/index#setupfiles)

    js

    ``` javascript
    import { afterAll, afterEach, beforeAll } from 'vitest'
    import { setupServer } from 'msw/node'
    import { HttpResponse, graphql, http } from 'msw'

    const posts = [
      {
        userId: 1,
        id: 1,
        title: 'first post title',
        body: 'first post body',
      },
      // ...
    ]

    export const restHandlers = [
      http.get('https://rest-endpoint.example/path/to/posts', () => {
        return HttpResponse.json(posts)
      }),
    ]

    const graphqlHandlers = [
      graphql.query('ListPosts', () => {
        return HttpResponse.json(
          {
            data: { posts },
          },
        )
      }),
    ]

    const server = setupServer(...restHandlers, ...graphqlHandlers)

    // Start server before all tests
    beforeAll(() => server.listen({ onUnhandledRequest: 'error' }))

    //  Close server after all tests
    afterAll(() => server.close())

    // Reset handlers after each test `important for test isolation`
    afterEach(() => server.resetHandlers())
    ```

    > Configuring the server with `onUnhandleRequest: 'error'` ensures that an error is thrown whenever there is a request that does not have a corresponding request handler.
- name: 'Mocking: Dates ​'
  id: guide/mocking#dates
  summary: Sometimes you need to be in control of the date to ensure consistency when testing
  belongs_to: Mocking
  description: |-
    ## Dates

    Sometimes you need to be in control of the date to ensure consistency when testing. Vitest uses [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers) package for manipulating timers, as well as system date. You can find more about the specific API in detail [here](../api/vi#vi-setsystemtime).
- name: 'Mocking: Example ​'
  id: guide/mocking#example
  summary: null
  belongs_to: Mocking
  description: |-
    ### Example

    js

    ``` javascript
    import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

    const businessHours = [9, 17]

    function purchase() {
      const currentHour = new Date().getHours()
      const [open, close] = businessHours

      if (currentHour > open && currentHour < close) {
        return { message: 'Success' }
      }

      return { message: 'Error' }
    }

    describe('purchasing flow', () => {
      beforeEach(() => {
        // tell vitest we use mocked time
        vi.useFakeTimers()
      })

      afterEach(() => {
        // restoring date after each test run
        vi.useRealTimers()
      })

      it('allows purchases within business hours', () => {
        // set hour within business hours
        const date = new Date(2000, 1, 1, 13)
        vi.setSystemTime(date)

        // access Date.now() will result in the date set above
        expect(purchase()).toEqual({ message: 'Success' })
      })

      it('disallows purchases outside of business hours', () => {
        // set hour outside business hours
        const date = new Date(2000, 1, 1, 19)
        vi.setSystemTime(date)

        // access Date.now() will result in the date set above
        expect(purchase()).toEqual({ message: 'Error' })
      })
    })
    ```
- name: 'Mocking: Example ​'
  id: guide/mocking#example-3
  summary: null
  belongs_to: Mocking
  description: |-
    ### Example

    To automatially redirect every `fs` call to `memfs`, you can create `__mocks__/fs.cjs` and `__mocks__/fs/promises.cjs` files at the root of your project:

    \_\_mocks\_\_/fs.cjs \_\_mocks\_\_/fs/promises.cjs

    ts

    ``` javascript
    // we can also use `import`, but then
    // every export should be explicitly defined

    const { fs } = require('memfs')
    module.exports = fs
    ```

    ts

    ``` javascript
    // we can also use `import`, but then
    // every export should be explicitly defined

    const { fs } = require('memfs')
    module.exports = fs.promises
    ```

    ts

    ``` javascript
    // hello-world.js
    import { readFileSync } from 'node:fs'

    export function readHelloWorld(path) {
      return readFileSync('./hello-world.txt')
    }
    ```

    ts

    ``` javascript
    // hello-world.test.js
    import { beforeEach, expect, it, vi } from 'vitest'
    import { fs, vol } from 'memfs'
    import { readHelloWorld } from './hello-world.js'

    // tell vitest to use fs mock from __mocks__ folder
    // this can be done in a setup file if fs should always be mocked
    vi.mock('node:fs')
    vi.mock('node:fs/promises')

    beforeEach(() => {
      // reset the state of in-memory fs
      vol.reset()
    })

    it('should return correct text', () => {
      const path = './hello-world.txt'
      fs.writeFileSync(path, 'hello world')

      const text = readHelloWorld(path)
      expect(text).toBe('hello world')
    })

    it('can return a value multiple times', () => {
      // you can use vol.fromJSON to define several files
      vol.fromJSON(
        {
          './dir1/hw.txt': 'hello dir1',
          './dir2/hw.txt': 'hello dir2',
        },
        // default cwd
        '/tmp'
      )

      expect(readHelloWorld('/tmp/dir1/hw.txt')).toBe('hello dir1')
      expect(readHelloWorld('/tmp/dir2/hw.txt')).toBe('hello dir2')
    })
    ```
- name: 'Mocking: Example ​'
  id: guide/mocking#example-2
  summary: null
  belongs_to: Mocking
  description: |-
    ### Example

    js

    ``` javascript
    import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'
    import { Client } from 'pg'
    import { failure, success } from './handlers.js'

    // get todos
    export async function getTodos(event, context) {
      const client = new Client({
        // ...clientOptions
      })

      await client.connect()

      try {
        const result = await client.query('SELECT * FROM todos;')

        client.end()

        return success({
          message: `${result.rowCount} item(s) returned`,
          data: result.rows,
          status: true,
        })
      }
      catch (e) {
        console.error(e.stack)

        client.end()

        return failure({ message: e, status: false })
      }
    }

    vi.mock('pg', () => {
      const Client = vi.fn()
      Client.prototype.connect = vi.fn()
      Client.prototype.query = vi.fn()
      Client.prototype.end = vi.fn()

      return { Client }
    })

    vi.mock('./handlers.js', () => {
      return {
        success: vi.fn(),
        failure: vi.fn(),
      }
    })

    describe('get a list of todo items', () => {
      let client

      beforeEach(() => {
        client = new Client()
      })

      afterEach(() => {
        vi.clearAllMocks()
      })

      it('should return items successfully', async () => {
        client.query.mockResolvedValueOnce({ rows: [], rowCount: 0 })

        await getTodos()

        expect(client.connect).toBeCalledTimes(1)
        expect(client.query).toBeCalledWith('SELECT * FROM todos;')
        expect(client.end).toBeCalledTimes(1)

        expect(success).toBeCalledWith({
          message: '0 item(s) returned',
          data: [],
          status: true,
        })
      })

      it('should throw an error', async () => {
        const mError = new Error('Unable to retrieve rows')
        client.query.mockRejectedValueOnce(mError)

        await getTodos()

        expect(client.connect).toBeCalledTimes(1)
        expect(client.query).toBeCalledWith('SELECT * FROM todos;')
        expect(client.end).toBeCalledTimes(1)
        expect(failure).toBeCalledWith({ message: mError, status: false })
      })
    })
    ```
- name: 'Mocking: Example ​'
  id: guide/mocking#example-4
  summary: null
  belongs_to: Mocking
  description: |-
    ### Example

    js

    ``` javascript
    import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'

    function executeAfterTwoHours(func) {
      setTimeout(func, 1000 * 60 * 60 * 2) // 2 hours
    }

    function executeEveryMinute(func) {
      setInterval(func, 1000 * 60) // 1 minute
    }

    const mock = vi.fn(() => console.log('executed'))

    describe('delayed execution', () => {
      beforeEach(() => {
        vi.useFakeTimers()
      })
      afterEach(() => {
        vi.restoreAllMocks()
      })
      it('should execute the function', () => {
        executeAfterTwoHours(mock)
        vi.runAllTimers()
        expect(mock).toHaveBeenCalledTimes(1)
      })
      it('should not execute the function', () => {
        executeAfterTwoHours(mock)
        // advancing by 2ms won't trigger the func
        vi.advanceTimersByTime(2)
        expect(mock).not.toHaveBeenCalled()
      })
      it('should execute every minute', () => {
        executeEveryMinute(mock)
        vi.advanceTimersToNextTimer()
        expect(mock).toHaveBeenCalledTimes(1)
        vi.advanceTimersToNextTimer()
        expect(mock).toHaveBeenCalledTimes(2)
      })
    })
    ```
- name: 'Mocking: Example ​'
  id: guide/mocking#example-1
  summary: null
  belongs_to: Mocking
  description: |-
    ### Example

    js

    ``` javascript
    import { afterEach, describe, expect, it, vi } from 'vitest'

    const messages = {
      items: [
        { message: 'Simple test message', from: 'Testman' },
        // ...
      ],
      getLatest, // can also be a `getter or setter if supported`
    }

    function getLatest(index = messages.items.length - 1) {
      return messages.items[index]
    }

    describe('reading messages', () => {
      afterEach(() => {
        vi.restoreAllMocks()
      })

      it('should get the latest message with a spy', () => {
        const spy = vi.spyOn(messages, 'getLatest')
        expect(spy.getMockName()).toEqual('getLatest')

        expect(messages.getLatest()).toEqual(
          messages.items[messages.items.length - 1],
        )

        expect(spy).toHaveBeenCalledTimes(1)

        spy.mockImplementationOnce(() => 'access-restricted')
        expect(messages.getLatest()).toEqual('access-restricted')

        expect(spy).toHaveBeenCalledTimes(2)
      })

      it('should get with a mock', () => {
        const mock = vi.fn().mockImplementation(getLatest)

        expect(mock()).toEqual(messages.items[messages.items.length - 1])
        expect(mock).toHaveBeenCalledTimes(1)

        mock.mockImplementationOnce(() => 'access-restricted')
        expect(mock()).toEqual('access-restricted')

        expect(mock).toHaveBeenCalledTimes(2)

        expect(mock()).toEqual(messages.items[messages.items.length - 1])
        expect(mock).toHaveBeenCalledTimes(3)
      })
    })
    ```
- name: 'Mocking: File System ​'
  id: guide/mocking#file-system
  summary: Mocking the file system ensures that the tests do not depend on the actual file system, making the tests more reliable and predictable
  belongs_to: Mocking
  description: |-
    ## File System

    Mocking the file system ensures that the tests do not depend on the actual file system, making the tests more reliable and predictable. This isolation helps in avoiding side effects from previous tests. It allows for testing error conditions and edge cases that might be difficult or impossible to replicate with an actual file system, such as permission issues, disk full scenarios, or read/write errors.

    Vitest doesn't provide any file system mocking API out of the box. You can use `vi.mock` to mock the `fs` module manually, but it's hard to maintain. Instead, we recommend using [`memfs`](https://www.npmjs.com/package/memfs) to do that for you. `memfs` creates an in-memory file system, which simulates file system operations without touching the actual disk. This approach is fast and safe, avoiding any potential side effects on the real file system.
- name: 'Mocking: Functions ​'
  id: guide/mocking#functions
  summary: Mocking functions can be split up into two different categories; spying & mocking
  belongs_to: Mocking
  description: |-
    ## Functions

    Mocking functions can be split up into two different categories; *spying & mocking*.

    Sometimes all you need is to validate whether or not a specific function has been called (and possibly which arguments were passed). In these cases a spy would be all we need which you can use directly with `vi.spyOn()` ([read more here](../api/vi#vi-spyon)).

    However spies can only help you **spy** on functions, they are not able to alter the implementation of those functions. In the case where we do need to create a fake (or mocked) version of a function we can use `vi.fn()` ([read more here](../api/vi#vi-fn)).

    We use [Tinyspy](https://github.com/tinylibs/tinyspy) as a base for mocking functions, but we have our own wrapper to make it `jest` compatible. Both `vi.fn()` and `vi.spyOn()` share the same methods, however only the return result of `vi.fn()` is callable.
- name: 'Mocking: Globals ​'
  id: guide/mocking#globals
  summary: You can mock global variables that are not present with jsdom or node by using vi.stubGlobal helper
  belongs_to: Mocking
  description: |-
    ## Globals

    You can mock global variables that are not present with `jsdom` or `node` by using [`vi.stubGlobal`](../api/vi#vi-stubglobal) helper. It will put the value of the global variable into a `globalThis` object.

    ts

    ``` javascript
    import { vi } from 'vitest'

    const IntersectionObserverMock = vi.fn(() => ({
      disconnect: vi.fn(),
      observe: vi.fn(),
      takeRecords: vi.fn(),
      unobserve: vi.fn(),
    }))

    vi.stubGlobal('IntersectionObserver', IntersectionObserverMock)

    // now you can access it as `IntersectionObserver` or `window.IntersectionObserver`
    ```
- name: 'Mocking: Mock a global variable ​'
  id: guide/mocking#mock-a-global-variable
  summary: You can set global variable by assigning a value to globalThis or using vi.stubGlobal helper
  belongs_to: Mocking
  description: |-
    ### Mock a global variable

    You can set global variable by assigning a value to `globalThis` or using [`vi.stubGlobal`](../api/vi#vi-stubglobal) helper. When using `vi.stubGlobal`, it will **not** automatically reset between different tests, unless you enable [`unstubGlobals`](../config/index#unstubglobals) config option or call [`vi.unstubAllGlobals`](../api/vi#vi-unstuballglobals).

    ts

    ``` javascript
    vi.stubGlobal('__VERSION__', '1.0.0')
    expect(__VERSION__).toBe('1.0.0')
    ```
- name: 'Mocking: Mock an exported class implementation ​'
  id: guide/mocking#mock-an-exported-class-implementation
  summary: null
  belongs_to: Mocking
  description: |-
    ### Mock an exported class implementation

    1.  Example with `vi.mock` and `.prototype`:

    ts

    ``` javascript
    // some-path.ts
    export class SomeClass {}
    ```

    ts

    ``` javascript
    import { SomeClass } from './some-path.js'

    vi.mock('./some-path.js', () => {
      const SomeClass = vi.fn()
      SomeClass.prototype.someMethod = vi.fn()
      return { SomeClass }
    })
    // SomeClass.mock.instances will have SomeClass
    ```

    2.  Example with `vi.mock` and a return value:

    ts

    ``` javascript
    import { SomeClass } from './some-path.js'

    vi.mock('./some-path.js', () => {
      const SomeClass = vi.fn(() => ({
        someMethod: vi.fn()
      }))
      return { SomeClass }
    })
    // SomeClass.mock.returns will have returned object
    ```

    3.  Example with `vi.spyOn`:

    ts

    ``` javascript
    import * as exports from './some-path.js'

    vi.spyOn(exports, 'SomeClass').mockImplementation(() => {
      // whatever suites you from first two examples
    })
    ```
- name: 'Mocking: Mock an exported function ​'
  id: guide/mocking#mock-an-exported-function
  summary: Don't forget that a vi.mock call is hoisted to top of the file
  belongs_to: Mocking
  description: |-
    ### Mock an exported function

    1.  Example with `vi.mock`:

    **WARNING**

    Don't forget that a `vi.mock` call is hoisted to top of the file. It will always be executed before all imports.

    ts

    ``` javascript
    // ./some-path.js
    export function method() {}
    ```

    ts

    ``` javascript
    import { method } from './some-path.js'

    vi.mock('./some-path.js', () => ({
      method: vi.fn()
    }))
    ```

    2.  Example with `vi.spyOn`:

    ts

    ``` javascript
    import * as exports from './some-path.js'

    vi.spyOn(exports, 'method').mockImplementation(() => {})
    ```
- name: 'Mocking: Mock exported variables ​'
  id: guide/mocking#mock-exported-variables
  summary: null
  belongs_to: Mocking
  description: |-
    ### Mock exported variables

    js

    ``` javascript
    // some-path.js
    export const getter = 'variable'
    ```

    ts

    ``` javascript
    // some-path.test.ts
    import * as exports from './some-path.js'

    vi.spyOn(exports, 'getter', 'get').mockReturnValue('mocked')
    ```
- name: 'Mocking: Mock import.meta.env ​'
  id: guide/mocking#mock-import-meta-env
  summary: The environmental variable value will not automatically reset between different tests
  belongs_to: Mocking
  description: "### Mock `import.meta.env`\n\n1.  To change environmental variable, you can just assign a new value to it.\n\n**WARNING**\n\nThe environmental variable value will ***not*** automatically reset between different tests.\n\nts\n\n``` javascript\nimport { beforeEach, expect, it } from 'vitest'\n\n// you can reset it in beforeEach hook manually\nconst originalViteEnv = import.meta.env.VITE_ENV\n\nbeforeEach(() => {\n  import.meta.env.VITE_ENV = originalViteEnv\n})\n\nit('changes value', () => {\n  import.meta.env.VITE_ENV = 'staging'\n  expect(import.meta.env.VITE_ENV).toBe('staging')\n})\n```\n\n2.  If you want to automatically reset the value(s), you can use the `vi.stubEnv` helper with the [`unstubEnvs`](../config/index#unstubenvs) config option enabled (or call [`vi.unstubAllEnvs`](../api/vi#vi-unstuballenvs) manually in a `beforeEach` hook):\n\nts\n\n``` javascript\nimport { expect, it, vi } from 'vitest'\n\n// before running tests \"VITE_ENV\" is \"test\"\nimport.meta.env.VITE_ENV === 'test'\n\nit('changes value', () => {\n  vi.stubEnv('VITE_ENV', 'staging')\n  expect(import.meta.env.VITE_ENV).toBe('staging')\n})\n\nit('the value is restored before running an other test', () => {\n  expect(import.meta.env.VITE_ENV).toBe('test')\n})\n```\n\nts\n\n``` javascript\n// vitest.config.ts\nexport default {\n  test: {\n    unstubAllEnvs: true,\n  }\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/mocking](https://vitest.dev/guide/mocking)"
- name: 'Mocking: Mock part of a module ​'
  id: guide/mocking#mock-part-of-a-module
  summary: null
  belongs_to: Mocking
  description: |-
    ### Mock part of a module

    ts

    ``` javascript
    import { mocked, original } from './some-path.js'

    vi.mock('./some-path.js', async (importOriginal) => {
      const mod = await importOriginal<typeof import('./some-path.js')>()
      return {
        ...mod,
        mocked: vi.fn()
      }
    })
    original() // has original behaviour
    mocked() // is a spy function
    ```
- name: 'Mocking: Mock the current date ​'
  id: guide/mocking#mock-the-current-date
  summary: To mock Date's time, you can use vi.setSystemTime helper function
  belongs_to: Mocking
  description: |-
    ### Mock the current date

    To mock `Date`'s time, you can use `vi.setSystemTime` helper function. This value will **not** automatically reset between different tests.

    Beware that using `vi.useFakeTimers` also changes the `Date`'s time.

    ts

    ``` javascript
    const mockDate = new Date(2022, 0, 1)
    vi.setSystemTime(mockDate)
    const now = new Date()
    expect(now.valueOf()).toBe(mockDate.valueOf())
    // reset mocked time
    vi.useRealTimers()
    ```
- name: 'Mocking: Mocking Pitfalls ​'
  id: guide/mocking#mocking-pitfalls
  summary: Beware that it is not possible to mock calls to methods that are called inside other methods of the same file
  belongs_to: Mocking
  description: |-
    ### Mocking Pitfalls

    Beware that it is not possible to mock calls to methods that are called inside other methods of the same file. For example, in this code:

    ts

    ``` javascript
    export function foo() {
      return 'foo'
    }

    export function foobar() {
      return `${foo()}bar`
    }
    ```

    It is not possible to mock the `foo` method from the outside because it is referenced directly. So this code will have no effect on the `foo` call inside `foobar` (but it will affect the `foo` call in other modules):

    ts

    ``` javascript
    import { vi } from 'vitest'
    import * as mod from './foobar.js'

    // this will only affect "foo" outside of the original module
    vi.spyOn(mod, 'foo')
    vi.mock('./foobar.js', async (importOriginal) => {
      return {
        ...await importOriginal<typeof import('./foobar.js')>(),
        // this will only affect "foo" outside of the original module
        foo: () => 'mocked'
      }
    })
    ```

    You can confirm this behaviour by providing the implementation to the `foobar` method directly:

    ts

    ``` javascript
    // foobar.test.js
    import * as mod from './foobar.js'

    vi.spyOn(mod, 'foo')

    // exported foo references mocked method
    mod.foobar(mod.foo)
    ```

    ts

    ``` javascript
    // foobar.js
    export function foo() {
      return 'foo'
    }

    export function foobar(injectedFoo) {
      return injectedFoo !== foo // false
    }
    ```

    This is the intended behaviour. It is usually a sign of bad code when mocking is involved in such a manner. Consider refactoring your code into multiple files or improving your application architecture by using techniques such as [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection).
- name: 'Mocking: Modules ​'
  id: guide/mocking#modules
  summary: Mock modules observe third-party-libraries, that are invoked in some other code, allowing you to test arguments, output or even redeclare its implementation
  belongs_to: Mocking
  description: |-
    ## Modules

    Mock modules observe third-party-libraries, that are invoked in some other code, allowing you to test arguments, output or even redeclare its implementation.

    See the [`vi.mock()` API section](../api/vi#vi-mock) for a more in-depth detailed API description.
- name: 'Mocking: More ​'
  id: guide/mocking#more-1
  summary: There is much more to MSW
  belongs_to: Mocking
  description: |-
    ### More

    There is much more to MSW. You can access cookies and query parameters, define mock error responses, and much more! To see all you can do with MSW, read [their documentation](https://mswjs.io/docs).
- name: 'Mocking: More ​'
  id: guide/mocking#more
  summary: null
  belongs_to: Mocking
  description: |-
    ### More

    - [Jest's Mock Functions](https://jestjs.io/docs/mock-function-api)
- name: 'Mocking: Requests ​'
  id: guide/mocking#requests
  summary: Because Vitest runs in Node, mocking network requests is tricky; web APIs are not available, so we need something that will mimic network behavior for us
  belongs_to: Mocking
  description: |-
    ## Requests

    Because Vitest runs in Node, mocking network requests is tricky; web APIs are not available, so we need something that will mimic network behavior for us. We recommend [Mock Service Worker](https://mswjs.io/) to accomplish this. It will let you mock both `REST` and `GraphQL` network requests, and is framework agnostic.

    Mock Service Worker (MSW) works by intercepting the requests your tests make, allowing you to use it without changing any of your application code. In-browser, this uses the [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API). In Node.js, and for Vitest, it uses the [`@mswjs/interceptors`](https://github.com/mswjs/interceptors) library. To learn more about MSW, read their [introduction](https://mswjs.io/docs/)
- name: 'Mocking: Spy on a method ​'
  id: guide/mocking#spy-on-a-method
  summary: null
  belongs_to: Mocking
  description: |-
    ### Spy on a `method`

    ts

    ``` javascript
    const instance = new SomeClass()
    vi.spyOn(instance, 'method')
    ```
- name: 'Mocking: Spy on an object returned from a function ​'
  id: guide/mocking#spy-on-an-object-returned-from-a-function
  summary: null
  belongs_to: Mocking
  description: |-
    ### Spy on an object returned from a function

    1.  Example using cache:

    ts

    ``` javascript
    // some-path.ts
    export function useObject() {
      return { method: () => true }
    }
    ```

    ts

    ``` javascript
    // useObject.js
    import { useObject } from './some-path.js'

    const obj = useObject()
    obj.method()
    ```

    ts

    ``` javascript
    // useObject.test.js
    import { useObject } from './some-path.js'

    vi.mock('./some-path.js', () => {
      let _cache
      const useObject = () => {
        if (!_cache) {
          _cache = {
            method: vi.fn(),
          }
        }
        // now every time that useObject() is called it will
        // return the same object reference
        return _cache
      }
      return { useObject }
    })

    const obj = useObject()
    // obj.method was called inside some-path
    expect(obj.method).toHaveBeenCalled()
    ```
- name: 'Mocking: Timers ​'
  id: guide/mocking#timers
  summary: When we test code that involves timeouts or intervals, instead of having our tests wait it out or timeout, we can speed up our tests by using "fake" timers that mock calls to setTimeout and setInterval
  belongs_to: Mocking
  description: |-
    ## Timers

    When we test code that involves timeouts or intervals, instead of having our tests wait it out or timeout, we can speed up our tests by using "fake" timers that mock calls to `setTimeout` and `setInterval`.

    See the [`vi.useFakeTimers` API section](../api/vi#vi-usefaketimers) for a more in depth detailed API description.
- name: 'Mocking: Virtual Modules ​'
  id: guide/mocking#virtual-modules
  summary: Vitest supports mocking Vite virtual modules
  belongs_to: Mocking
  description: |-
    ### Virtual Modules

    Vitest supports mocking Vite [virtual modules](https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention). It works differently from how virtual modules are treated in Jest. Instead of passing down `virtual: true` to a `vi.mock` function, you need to tell Vite that module exists otherwise it will fail during parsing. You can do that in several ways:

    1.  Provide an alias

    ts

    ``` javascript
    // vitest.config.js
    export default {
      test: {
        alias: {
          '$app/forms': resolve('./mocks/forms.js')
        }
      }
    }
    ```

    2.  Provide a plugin that resolves a virtual module

    ts

    ``` javascript
    // vitest.config.js
    export default {
      plugins: [
        {
          name: 'virtual-modules',
          resolveId(id) {
            if (id === '$app/forms') {
              return 'virtual:$app/forms'
            }
          }
        }
      ]
    }
    ```

    The benefit of the second approach is that you can dynamically create different virtual entrypoints. If you redirect several virtual modules into a single file, then all of them will be affected by `vi.mock`, so make sure to use unique identifiers.
- name: mockName ​
  id: api/mock#mockname
  summary: Sets internal mock name
  belongs_to: Mock Functions
  description: |-
    ## mockName

    - **Type:** `(name: string) => MockInstance`

    Sets internal mock name. Useful to see the name of the mock if assertion fails.
- name: mockRejectedValue ​
  id: api/mock#mockrejectedvalue
  summary: Accepts an error that will be rejected when async function is called
  belongs_to: Mock Functions
  description: |-
    ## mockRejectedValue

    - **Type:** `(value: any) => MockInstance`

    Accepts an error that will be rejected when async function is called.

    ts

    ``` javascript
    const asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))

    await asyncMock() // throws "Async error"
    ```
- name: mockRejectedValueOnce ​
  id: api/mock#mockrejectedvalueonce
  summary: Accepts a value that will be rejected during the next function call
  belongs_to: Mock Functions
  description: |-
    ## mockRejectedValueOnce

    - **Type:** `(value: any) => MockInstance`

    Accepts a value that will be rejected during the next function call. If chained, every consecutive call will reject specified value.

    ts

    ``` javascript
    const asyncMock = vi
      .fn()
      .mockResolvedValueOnce('first call')
      .mockRejectedValueOnce(new Error('Async error'))

    await asyncMock() // first call
    await asyncMock() // throws "Async error"
    ```
- name: mockReset ​
  id: config/index#mockreset
  summary: Will call .mockReset() on all spies before each test
  belongs_to: Configuring Vitest
  description: |-
    ### mockReset

    - **Type:** `boolean`
    - **Default:** `false`

    Will call [`.mockReset()`](../api/mock#mockreset) on all spies before each test. This will clear mock history and reset its implementation to an empty function (will return `undefined`).
- name: mockReset ​
  id: api/mock#mockreset
  summary: Does what mockClear does and makes inner implementation an empty function (returning undefined when invoked)
  belongs_to: Mock Functions
  description: |-
    ## mockReset

    - **Type:** `() => MockInstance`

    Does what `mockClear` does and makes inner implementation an empty function (returning `undefined` when invoked). This also resets all "once" implementations. This is useful when you want to completely reset a mock to the default state.

    If you want this method to be called before each test automatically, you can enable [`mockReset`](../config/index#mockreset) setting in config.
- name: mockResolvedValue ​
  id: api/mock#mockresolvedvalue
  summary: Accepts a value that will be resolved when async function is called
  belongs_to: Mock Functions
  description: |-
    ## mockResolvedValue

    - **Type:** `(value: any) => MockInstance`

    Accepts a value that will be resolved when async function is called.

    ts

    ``` javascript
    const asyncMock = vi.fn().mockResolvedValue(42)

    await asyncMock() // 42
    ```
- name: mockResolvedValueOnce ​
  id: api/mock#mockresolvedvalueonce
  summary: Accepts a value that will be resolved during the next function call
  belongs_to: Mock Functions
  description: |-
    ## mockResolvedValueOnce

    - **Type:** `(value: any) => MockInstance`

    Accepts a value that will be resolved during the next function call. If chained, every consecutive call will resolve specified value.

    ts

    ``` javascript
    const asyncMock = vi
      .fn()
      .mockResolvedValue('default')
      .mockResolvedValueOnce('first call')
      .mockResolvedValueOnce('second call')

    await asyncMock() // first call
    await asyncMock() // second call
    await asyncMock() // default
    await asyncMock() // default
    ```
- name: mockRestore ​
  id: api/mock#mockrestore
  summary: Does what mockReset does and restores inner implementation to the original function
  belongs_to: Mock Functions
  description: |-
    ## mockRestore

    - **Type:** `() => MockInstance`

    Does what `mockReset` does and restores inner implementation to the original function.

    Note that restoring mock from `vi.fn()` will set implementation to an empty function that returns `undefined`. Restoring a `vi.fn(impl)` will restore implementation to `impl`.

    If you want this method to be called before each test automatically, you can enable [`restoreMocks`](../config/index#restoremocks) setting in config.
- name: mockReturnThis ​
  id: api/mock#mockreturnthis
  summary: Use this if you need to return this context from the method without invoking actual implementation
  belongs_to: Mock Functions
  description: |-
    ## mockReturnThis

    - **Type:** `() => MockInstance`

    Use this if you need to return `this` context from the method without invoking actual implementation. This is a shorthand for:

    ts

    ``` javascript
    spy.mockImplementation(function () {
      return this
    })
    ```
- name: mockReturnValue ​
  id: api/mock#mockreturnvalue
  summary: Accepts a value that will be returned whenever the mock function is called
  belongs_to: Mock Functions
  description: |-
    ## mockReturnValue

    - **Type:** `(value: any) => MockInstance`

    Accepts a value that will be returned whenever the mock function is called.

    ts

    ``` javascript
    const mock = vi.fn()
    mock.mockReturnValue(42)
    mock() // 42
    mock.mockReturnValue(43)
    mock() // 43
    ```
- name: mockReturnValueOnce ​
  id: api/mock#mockreturnvalueonce
  summary: Accepts a value that will be returned during the next function call
  belongs_to: Mock Functions
  description: |-
    ## mockReturnValueOnce

    - **Type:** `(value: any) => MockInstance`

    Accepts a value that will be returned during the next function call. If chained, every consecutive call will return the specified value.

    When there are no more `mockReturnValueOnce` values to use, mock will fallback to previously defined implementation if there is one.

    ts

    ``` javascript
    const myMockFn = vi
      .fn()
      .mockReturnValue('default')
      .mockReturnValueOnce('first call')
      .mockReturnValueOnce('second call')

    // 'first call', 'second call', 'default', 'default'
    console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())
    ```
- name: nestedInclude ​
  id: api/assert#nestedinclude
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## nestedInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.nestedInclude', () => {
      assert.nestedInclude({ '.a': { b: 'x' } }, { '\\.a.[b]': 'x' })
      assert.nestedInclude({ a: { '[b]': 'x' } }, { 'a.\\[b\\]': 'x' })
    })
    ```
- name: nestedProperty ​
  id: api/assert#nestedproperty
  summary: Asserts that object has a direct or inherited property named by property, which can be a string using dot- and bracket-notation for nested reference
  belongs_to: assert
  description: |-
    ## nestedProperty

    - **Type:** `<T>(object: T, property: string, message?: string) => void`

    Asserts that `object` has a direct or inherited property named by `property`, which can be a string using dot- and bracket-notation for nested reference.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepPropertyVal', () => {
      assert.nestedProperty({ tea: { green: 'matcha' } }, 'tea.green')
    })
    ```
- name: nestedPropertyVal ​
  id: api/assert#nestedpropertyval
  summary: Asserts that object has a property named by property with value given by value
  belongs_to: assert
  description: |-
    ## nestedPropertyVal

    - **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`

    Asserts that `object` has a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.nestedPropertyVal', () => {
      assert.nestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'matcha')
    })
    ```
- name: Node API
  id: advanced/api
  summary: Vitest exposes experimental private API
  description: "# Node API\n\n**WARNING**\n\nVitest exposes experimental private API. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\n## startVitest\n\nYou can start running Vitest tests using its Node API:\n\njs\n\n``` javascript\nimport { startVitest } from 'vitest/node'\n\nconst vitest = await startVitest('test')\n\nawait vitest?.close()\n```\n\n`startVitest` function returns `Vitest` instance if tests can be started. It returns `undefined`, if one of the following occurs:\n\n- Vitest didn't find the `vite` package (usually installed with Vitest)\n- If coverage is enabled and run mode is \"test\", but the coverage package is not installed (`@vitest/coverage-v8` or `@vitest/coverage-istanbul`)\n- If the environment package is not installed (`jsdom`/`happy-dom`/`@edge-runtime/vm`)\n\nIf `undefined` is returned or tests failed during the run, Vitest sets `process.exitCode` to `1`.\n\nIf watch mode is not enabled, Vitest will call `close` method.\n\nIf watch mode is enabled and the terminal supports TTY, Vitest will register console shortcuts.\n\nYou can pass down a list of filters as a second argument. Vitest will run only tests that contain at least one of the passed-down strings in their file path.\n\nAdditionally, you can use the third argument to pass in CLI arguments, which will override any test config options.\n\nAlternatively, you can pass in the complete Vite config as the fourth argument, which will take precedence over any other user-defined options.\n\n## createVitest\n\nYou can create Vitest instance yourself using `createVitest` function. It returns the same `Vitest` instance as `startVitest`, but it doesn't start tests and doesn't validate installed packages.\n\njs\n\n``` javascript\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test', {\n  watch: false,\n})\n```\n\n## parseCLI\n\nYou can use this method to parse CLI arguments. It accepts a string (where arguments are split by a single space) or a strings array of CLI arguments in the same format that Vitest CLI uses. It returns a filter and `options` that you can later pass down to `createVitest` or `startVitest` methods.\n\nts\n\n``` javascript\nimport { parseCLI } from 'vitest/node'\n\nparseCLI('vitest ./files.ts --coverage --browser=chrome')\n```\n\n## Vitest\n\nVitest instance requires the current test mode. It can be either:\n\n- `test` when running runtime tests\n- `benchmark` when running benchmarks\n\n### mode\n\n#### test\n\nTest mode will only call functions inside `test` or `it`, and throws an error when `bench` is encountered. This mode uses `include` and `exclude` options in the config to find test files.\n\n#### benchmark\n\nBenchmark mode calls `bench` functions and throws an error, when it encounters `test` or `it`. This mode uses `benchmark.include` and `benchmark.exclude` options in the config to find benchmark files.\n\n### start\n\nYou can start running tests or benchmarks with `start` method. You can pass an array of strings to filter test files.\n\n### `provide`\n\nVitest exposes `provide` method which is a shorthand for `vitest.getCoreWorkspaceProject().provide`. With this method you can pass down values from the main thread to tests. All values are checked with `structuredClone` before they are stored, but the values themselves are not cloned.\n\nTo recieve the values in the test, you need to import `inject` method from `vitest` entrypont:\n\nts\n\n``` javascript\nimport { inject } from 'vitest'\nconst port = inject('wsPort') // 3000\n```\n\nFor better type safety, we encourage you to augment the type of `ProvidedContext`:\n\nts\n\n``` javascript\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test', {\n  watch: false,\n})\nvitest.provide('wsPort', 3000)\n\ndeclare module 'vitest' {\n  export interface ProvidedContext {\n    wsPort: number\n  }\n}\n```\n\n**WARNING**\n\nTechnically, `provide` is a method of `WorkspaceProject`, so it is limited to the specific project. However, all projects inherit the values from the core project which makes `vitest.provide` universal way of passing down values to tests.\n\n**TIP**\n\nThis method is also available to [global setup files](../config/index#globalsetup) for cases where you don't want to use the public API:\n\njs\n\n``` javascript\nexport default function setup({ provide }) {\n  provide('wsPort', 3000)\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/api](https://vitest.dev/advanced/api)"
- name: 'Node API: createVitest ​'
  id: advanced/api#createvitest
  summary: You can create Vitest instance yourself using createVitest function
  belongs_to: Node API
  description: |-
    ## createVitest

    You can create Vitest instance yourself using `createVitest` function. It returns the same `Vitest` instance as `startVitest`, but it doesn't start tests and doesn't validate installed packages.

    js

    ``` javascript
    import { createVitest } from 'vitest/node'

    const vitest = await createVitest('test', {
      watch: false,
    })
    ```
- name: 'Node API: mode ​'
  id: advanced/api#mode
  summary: Test mode will only call functions inside test or it, and throws an error when bench is encountered
  belongs_to: Node API
  description: |-
    ### mode

    #### test

    Test mode will only call functions inside `test` or `it`, and throws an error when `bench` is encountered. This mode uses `include` and `exclude` options in the config to find test files.

    #### benchmark

    Benchmark mode calls `bench` functions and throws an error, when it encounters `test` or `it`. This mode uses `benchmark.include` and `benchmark.exclude` options in the config to find benchmark files.
- name: 'Node API: parseCLI ​'
  id: advanced/api#parsecli
  summary: You can use this method to parse CLI arguments
  belongs_to: Node API
  description: |-
    ## parseCLI

    You can use this method to parse CLI arguments. It accepts a string (where arguments are split by a single space) or a strings array of CLI arguments in the same format that Vitest CLI uses. It returns a filter and `options` that you can later pass down to `createVitest` or `startVitest` methods.

    ts

    ``` javascript
    import { parseCLI } from 'vitest/node'

    parseCLI('vitest ./files.ts --coverage --browser=chrome')
    ```
- name: 'Node API: provide ​'
  id: advanced/api#provide
  summary: Vitest exposes provide method which is a shorthand for vitest.getCoreWorkspaceProject().provide
  belongs_to: Node API
  description: "### `provide`\n\nVitest exposes `provide` method which is a shorthand for `vitest.getCoreWorkspaceProject().provide`. With this method you can pass down values from the main thread to tests. All values are checked with `structuredClone` before they are stored, but the values themselves are not cloned.\n\nTo recieve the values in the test, you need to import `inject` method from `vitest` entrypont:\n\nts\n\n``` javascript\nimport { inject } from 'vitest'\nconst port = inject('wsPort') // 3000\n```\n\nFor better type safety, we encourage you to augment the type of `ProvidedContext`:\n\nts\n\n``` javascript\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test', {\n  watch: false,\n})\nvitest.provide('wsPort', 3000)\n\ndeclare module 'vitest' {\n  export interface ProvidedContext {\n    wsPort: number\n  }\n}\n```\n\n**WARNING**\n\nTechnically, `provide` is a method of `WorkspaceProject`, so it is limited to the specific project. However, all projects inherit the values from the core project which makes `vitest.provide` universal way of passing down values to tests.\n\n**TIP**\n\nThis method is also available to [global setup files](../config/index#globalsetup) for cases where you don't want to use the public API:\n\njs\n\n``` javascript\nexport default function setup({ provide }) {\n  provide('wsPort', 3000)\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/api](https://vitest.dev/advanced/api)"
- name: 'Node API: start ​'
  id: advanced/api#start
  summary: You can start running tests or benchmarks with start method
  belongs_to: Node API
  description: |-
    ### start

    You can start running tests or benchmarks with `start` method. You can pass an array of strings to filter test files.
- name: 'Node API: startVitest ​'
  id: advanced/api#startvitest
  summary: startVitest function returns Vitest instance if tests can be started
  belongs_to: Node API
  description: |-
    ## startVitest

    You can start running Vitest tests using its Node API:

    js

    ``` javascript
    import { startVitest } from 'vitest/node'

    const vitest = await startVitest('test')

    await vitest?.close()
    ```

    `startVitest` function returns `Vitest` instance if tests can be started. It returns `undefined`, if one of the following occurs:

    - Vitest didn't find the `vite` package (usually installed with Vitest)
    - If coverage is enabled and run mode is "test", but the coverage package is not installed (`@vitest/coverage-v8` or `@vitest/coverage-istanbul`)
    - If the environment package is not installed (`jsdom`/`happy-dom`/`@edge-runtime/vm`)

    If `undefined` is returned or tests failed during the run, Vitest sets `process.exitCode` to `1`.

    If watch mode is not enabled, Vitest will call `close` method.

    If watch mode is enabled and the terminal supports TTY, Vitest will register console shortcuts.

    You can pass down a list of filters as a second argument. Vitest will run only tests that contain at least one of the passed-down strings in their file path.

    Additionally, you can use the third argument to pass in CLI arguments, which will override any test config options.

    Alternatively, you can pass in the complete Vite config as the fourth argument, which will take precedence over any other user-defined options.
- name: 'Node API: Vitest ​'
  id: advanced/api#vitest
  summary: Vitest instance requires the current test mode
  belongs_to: Node API
  description: |-
    ## Vitest

    Vitest instance requires the current test mode. It can be either:

    - `test` when running runtime tests
    - `benchmark` when running benchmarks
- name: not ​
  id: api/expect#not
  summary: Using not will negate the assertion
  belongs_to: expect
  description: |-
    ## not

    Using `not` will negate the assertion. For example, this code asserts that an `input` value is not equal to `2`. If it's equal, the assertion will throw an error, and the test will fail.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const input = Math.sqrt(16)

    expect(input).not.to.equal(2) // chai API
    expect(input).not.toBe(2) // jest API
    ```
- name: not ​
  id: api/expect-typeof#not
  summary: You can negate all assertions, using .not property
  belongs_to: expectTypeOf
  description: |-
    ## not

    - **Type:** `ExpectTypeOf`

    You can negate all assertions, using `.not` property.
- name: notDeepEqual ​
  id: api/assert#notdeepequal
  summary: Assert that actual is not deeply equal to expected
  belongs_to: assert
  description: |-
    ## notDeepEqual

    - **Type:** `<T>(actual: T, expected: T, message?: string) => void`

    Assert that `actual` is not deeply equal to `expected`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notDeepEqual', () => {
      assert.notDeepEqual({ color: 'green' }, { color: 'red' })
    })
    ```
- name: notDeepInclude ​
  id: api/assert#notdeepinclude
  summary: Asserts that haystack does not include needle
  belongs_to: assert
  description: |-
    ## notDeepInclude

    - **Type:**
      - `(haystack: string, needle: string, message?: string) => void`
      - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`
      - `<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string) => void`

    Asserts that `haystack` does not include `needle`. It can be used to assert the absence of a value in an array or a subset of properties in an object. Deep equality is used.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const obj1 = { a: 1 }
    const obj2 = { b: 2 }

    test('assert.notDeepInclude', () => {
      assert.notDeepInclude([obj1, obj2], { a: 10 })
      assert.notDeepInclude({ foo: obj1, bar: obj2 }, { foo: { a: 10 } })
    })
    ```
- name: notDeepNestedInclude ​
  id: api/assert#notdeepnestedinclude
  summary: Asserts that haystack not includes needle
  belongs_to: assert
  description: |-
    ## notDeepNestedInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` not includes `needle`. Can be used to assert the absence of a subset of properties in an object while checking for deep equality. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notDeepNestedInclude', () => {
      assert.notDeepNestedInclude({ a: { b: [{ x: 1 }] } }, { 'a.b[0]': { y: 1 } })
      assert.notDeepNestedInclude({ '.a': { '[b]': { x: 1 } } }, { '\\.a.\\[b\\]': { y: 2 } })
    })
    ```
- name: notDeepNestedPropertyVal ​
  id: api/assert#notdeepnestedpropertyval
  summary: Asserts that object does not have a property named by property with value given by value
  belongs_to: assert
  description: |-
    ## notDeepNestedPropertyVal

    - **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`

    Asserts that `object` does not have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notDeepNestedPropertyVal', () => {
      assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' })
      assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' })
      assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' })
    })
    ```
- name: notDeepOwnInclude ​
  id: api/assert#notdeepowninclude
  summary: Asserts that haystack not includes needle
  belongs_to: assert
  description: |-
    ## notDeepOwnInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` not includes `needle`. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notDeepOwnInclude', () => {
      assert.notDeepOwnInclude({ a: { b: 2 } }, { a: { c: 3 } })
    })
    ```
- name: notDeepPropertyVal ​
  id: api/assert#notdeeppropertyval
  summary: Asserts that object does not have a direct or inherited property named by property with a value given by value
  belongs_to: assert
  description: |-
    ## notDeepPropertyVal

    - **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`

    Asserts that `object` does not have a direct or inherited property named by `property` with a value given by `value`. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepPropertyVal', () => {
      assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' })
      assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' })
      assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' })
    })
    ```
- name: notEqual ​
  id: api/assert#notequal
  summary: Asserts non-strict inequality (!=) of actual and expected
  belongs_to: assert
  description: |-
    ## notEqual

    - **Type:** `<T>(actual: T, expected: T, message?: string) => void`

    Asserts non-strict inequality (!=) of `actual` and `expected`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.equal', () => {
      assert.notEqual(Math.sqrt(4), 3)
    })
    ```
- name: notExists ​
  id: api/assert#notexists
  summary: Asserts that value is either null nor undefined
  belongs_to: assert
  description: |-
    ## notExists

    - **Type:** `<T>(value: T, message?: string) => void`

    Asserts that `value` is either null nor undefined.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const foo = null
    const bar = undefined

    test('assert.notExists', () => {
      assert.notExists(foo, 'foo is null so not exist')
      assert.notExists(bar, 'bar is undefined so not exist')
    })
    ```
- name: notInclude ​
  id: api/assert#notinclude
  summary: Asserts that haystack does not include needle
  belongs_to: assert
  description: |-
    ## notInclude

    - **Type:**
      - `(haystack: string, needle: string, message?: string) => void`
      - `<T>(haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>, needle: T, message?: string) => void`
      - `<T extends object>(haystack: WeakSet<T>, needle: T, message?: string) => void`
      - `<T>(haystack: T, needle: Partial<T>, message?: string) => void`

    Asserts that `haystack` does not include `needle`. It can be used to assert the absence of a value in an array, a substring in a string, or a subset of properties in an object.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notInclude', () => {
      assert.notInclude([1, 2, 3], 4, 'array doesn\'t contain 4')
      assert.notInclude('foobar', 'baz', 'foobar doesn\'t contain baz')
      assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn\'t contain property')
    })
    ```
- name: notIncludeDeepMembers ​
  id: api/assert#notincludedeepmembers
  summary: Asserts that subset isn’t included in superset in any order
  belongs_to: assert
  description: |-
    ## notIncludeDeepMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` isn’t included in `superset` in any order. Uses a deep equality check. Duplicates are ignored.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notIncludeDeepMembers', () => {
      assert.notIncludeDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { f: 5 }], 'not include deep members')
    })
    ```
- name: notIncludeDeepOrderedMembers ​
  id: api/assert#notincludedeeporderedmembers
  summary: Asserts that subset isn’t included in superset in the same order beginning with the first element in superset
  belongs_to: assert
  description: |-
    ## notIncludeDeepOrderedMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` isn’t included in `superset` in the same order beginning with the first element in superset. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.includeDeepOrderedMembers', () => {
      assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { f: 5 }], 'not include deep ordered members')
      assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }], 'not include deep ordered members')
      assert.notIncludeDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { c: 3 }], 'not include deep ordered members')
    })
    ```
- name: notIncludeMembers ​
  id: api/assert#notincludemembers
  summary: Asserts that subset isn't included in superset in any order
  belongs_to: assert
  description: |-
    ## notIncludeMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` isn't included in `superset` in any order. Uses a strict equality check (===). Duplicates are ignored.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notIncludeMembers', () => {
      assert.notIncludeMembers([1, 2, 3], [5, 1], 'not include members')
    })
    ```
- name: notIncludeOrderedMembers ​
  id: api/assert#notincludeorderedmembers
  summary: Asserts that subset isn't included in superset in the same order beginning with the first element in superset
  belongs_to: assert
  description: |-
    ## notIncludeOrderedMembers

    - **Type:** `<T>(superset: T[], subset: T[], message?: string) => void`

    Asserts that `subset` isn't included in `superset` in the same order beginning with the first element in `superset`. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notIncludeOrderedMembers', () => {
      assert.notIncludeOrderedMembers([1, 2, 3], [2, 1], 'not include ordered members')
      assert.notIncludeOrderedMembers([1, 2, 3], [2, 3], 'not include ordered members')
    })
    ```
- name: notInstanceOf ​
  id: api/assert#notinstanceof
  summary: Asserts that value is not an instance of constructor
  belongs_to: assert
  description: |-
    ## notInstanceOf

    - **Type:** `<T>(value: T, constructor: Function, message?: string) => void`

    Asserts that `value` is not an instance of `constructor`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    function Person(name) { this.name = name }
    const foo = new Person('foo')

    class Tea {
      constructor(name) {
        this.name = name
      }
    }
    const coffee = new Tea('coffee')

    test('assert.instanceOf', () => {
      assert.instanceOf(foo, Tea, 'foo is not an instance of Tea')
    })
    ```
- name: notMatch ​
  id: api/assert#notmatch
  summary: Asserts that value does not matches the regular expression regexp
  belongs_to: assert
  description: |-
    ## notMatch

    - **Type:** `(value: string, regexp: RegExp, message?: string) => void`

    Asserts that `value` does not matches the regular expression `regexp`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notMatch', () => {
      assert.notMatch('foobar', /^foo/, 'regexp does not match')
    })
    ```
- name: notNestedInclude ​
  id: api/assert#notnestedinclude
  summary: Asserts that haystack does not include needle
  belongs_to: assert
  description: |-
    ## notNestedInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` does not include `needle`. Can be used to assert the inclusion of a subset of properties in an object. Enables the use of dot- and bracket-notation for referencing nested properties. ‘\[\]’ and ‘.’ in property names can be escaped using double backslashes.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.nestedInclude', () => {
      assert.notNestedInclude({ '.a': { b: 'x' } }, { '\\.a.b': 'y' })
      assert.notNestedInclude({ a: { '[b]': 'x' } }, { 'a.\\[b\\]': 'y' })
    })
    ```
- name: notNestedProperty ​
  id: api/assert#notnestedproperty
  summary: Asserts that object does not have a direct or inherited property named by property, which can be a string using dot- and bracket-notation for nested reference
  belongs_to: assert
  description: |-
    ## notNestedProperty

    - **Type:** `<T>(object: T, property: string, message?: string) => void`

    Asserts that `object` does not have a direct or inherited property named by `property`, which can be a string using dot- and bracket-notation for nested reference.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.deepPropertyVal', () => {
      assert.notNestedProperty({ tea: { green: 'matcha' } }, 'tea.oolong')
    })
    ```
- name: notNestedPropertyVal ​
  id: api/assert#notnestedpropertyval
  summary: Asserts that object does not have a property named by property with value given by value
  belongs_to: assert
  description: |-
    ## notNestedPropertyVal

    - **Type:** `<T>(object: T, property: string, value: any, message?: string) => void`

    Asserts that `object` does not have a property named by `property` with value given by `value`. `property` can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notNestedPropertyVal', () => {
      assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'tea.green', 'konacha')
      assert.notNestedPropertyVal({ tea: { green: 'matcha' } }, 'coffee.green', 'matcha')
    })
    ```
- name: notOwnInclude ​
  id: api/assert#notowninclude
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## notOwnInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const obj1 = {
      b: 2
    }

    const obj2 = object.create(obj1)
    obj2.a = 1

    test('assert.notOwnInclude', () => {
      assert.notOwnInclude(obj2, { b: 2 })
    })
    ```
- name: notProperty ​
  id: api/assert#notproperty
  summary: null
  belongs_to: assert
  description: |-
    ## notProperty

    - **Type:** `<T>(object: T, property: string, message?: string) => void`

    Asserts that `object` does not have a direct or inherited property named by `property`

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notProperty', () => {
      assert.notProperty({ tea: { green: 'matcha' } }, 'coffee')
    })
    ```
- name: notPropertyVal ​
  id: api/assert#notpropertyval
  summary: Asserts that object does not have a direct or inherited property named by property with a value given by value
  belongs_to: assert
  description: |-
    ## notPropertyVal

    - **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`

    Asserts that `object` does not have a direct or inherited property named by `property` with a value given by `value`. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notPropertyVal', () => {
      assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad')
      assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good')
    })
    ```
- name: notSameDeepMembers ​
  id: api/assert#notsamedeepmembers
  summary: Asserts that set1 and set2 don’t have the same members in any order
  belongs_to: assert
  description: |-
    ## notSameDeepMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` don’t have the same members in any order. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.sameDeepMembers', () => {
      assert.sameDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members')
    })
    ```
- name: notSameDeepOrderedMembers ​
  id: api/assert#notsamedeeporderedmembers
  summary: Asserts that set1 and set2 don’t have the same members in the same order
  belongs_to: assert
  description: |-
    ## notSameDeepOrderedMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` don’t have the same members in the same order. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notSameDeepOrderedMembers', () => {
      assert.notSameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }, { z: 5 }], 'not same deep ordered members')
      assert.notSameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'not same deep ordered members')
    })
    ```
- name: notSameMembers ​
  id: api/assert#notsamemembers
  summary: Asserts that set1 and set2 don't have the same members in any order
  belongs_to: assert
  description: |-
    ## notSameMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` don't have the same members in any order. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.sameMembers', () => {
      assert.notSameMembers([1, 2, 3], [5, 1, 3], 'not same members')
    })
    ```
- name: notSameOrderedMembers ​
  id: api/assert#notsameorderedmembers
  summary: Asserts that set1 and set2 have the same members in the same order
  belongs_to: assert
  description: |-
    ## notSameOrderedMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` have the same members in the same order. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notSameOrderedMembers', () => {
      assert.notSameOrderedMembers([1, 2, 3], [2, 1, 3], 'not same ordered members')
    })
    ```
- name: notTypeOf ​
  id: api/assert#nottypeof
  summary: Asserts that value’s type is not name, as determined by Object.prototype.toString
  belongs_to: assert
  description: |-
    ## notTypeOf

    - **Type:** `<T>(value: T, name: string, message?: string) => void`

    Asserts that `value`’s type is not `name`, as determined by Object.prototype.toString.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notTypeOf', () => {
      assert.notTypeOf('red', 'number', '"red" is not a number')
    })
    ```
- name: onConsoleLog *  ​
  id: config/index#onconsolelog
  summary: Custom handler for console.log in tests
  belongs_to: Configuring Vitest
  description: "### onConsoleLog \\* \n\n- **Type**: `(log: string, type: 'stdout' | 'stderr') => boolean | void`\n\nCustom handler for `console.log` in tests. If you return `false`, Vitest will not print the log to the console.\n\nCan be useful for filtering out logs from third-party libraries.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onConsoleLog(log: string, type: 'stdout' | 'stderr'): boolean | void {\n      return !(log === 'message from third party library' && type === 'stdout')\n    },\n  },\n})\n```"
- name: oneOf ​
  id: api/assert#oneof
  summary: Asserts that non-object, non-array value inList appears in the flat array list
  belongs_to: assert
  description: |-
    ## oneOf

    - **Type:** `<T>(inList: T, list: T[], message?: string) => void`

    Asserts that non-object, non-array value `inList` appears in the flat array `list`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.oneOf', () => {
      assert.oneOf(1, [2, 1], 'Not found in list')
    })
    ```
- name: onStackTrace *  ​
  id: config/index#onstacktrace
  summary: Apply a filtering function to each frame of each stack trace when handling errors
  belongs_to: Configuring Vitest
  description: "### onStackTrace \\* \n\n- **Type**: `(error: Error, frame: ParsedStack) => boolean | void`\n\nApply a filtering function to each frame of each stack trace when handling errors. The first argument, `error`, is an object with the same properties as a standard `Error`, but it is not an actual instance.\n\nCan be useful for filtering out stack trace frames from third-party libraries.\n\nts\n\n``` javascript\nimport type { ParsedStack } from 'vitest'\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onStackTrace(error: Error, { file }: ParsedStack): boolean | void {\n      // If we've encountered a ReferenceError, show the whole stack.\n      if (error.name === 'ReferenceError') {\n        return\n      }\n\n      // Reject all frames from third party libraries.\n      if (file.includes('node_modules')) {\n        return false\n      }\n    },\n  },\n})\n```"
- name: onTestFailed ​
  id: api/index#ontestfailed
  summary: This hook is called only after the test has failed
  belongs_to: Test API Reference
  description: "### onTestFailed\n\nThis hook is called only after the test has failed. It is called after `afterEach` hooks since they can influence the test result. It receives a `TaskResult` object with the current test result. This hook is useful for debugging.\n\nts\n\n``` javascript\nimport { onTestFailed, test } from 'vitest'\n\ntest('performs a query', () => {\n  const db = connectDb()\n  onTestFailed((e) => {\n    console.log(e.result.errors)\n  })\n  db.query('SELECT * FROM users')\n})\n```\n\n**WARNING**\n\nIf you are running tests concurrently, you should always use `onTestFailed` hook from the test context since Vitest doesn't track concurrent tests in global hooks:\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest.concurrent('performs a query', ({ onTestFailed }) => {\n  const db = connectDb()\n  onTestFailed((result) => {\n    console.log(result.errors)\n  })\n  db.query('SELECT * FROM users')\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/](https://vitest.dev/api/)"
- name: onTestFinished ​
  id: api/index#ontestfinished
  summary: This hook is always called after the test has finished running
  belongs_to: Test API Reference
  description: |-
    ### onTestFinished

    This hook is always called after the test has finished running. It is called after `afterEach` hooks since they can influence the test result. It receives a `TaskResult` object with the current test result.

    ts

    ``` javascript
    import { onTestFinished, test } from 'vitest'

    test('performs a query', () => {
      const db = connectDb()
      onTestFinished(() => db.close())
      db.query('SELECT * FROM users')
    })
    ```

    **WARNING**

    If you are running tests concurrently, you should always use `onTestFinished` hook from the test context since Vitest doesn't track concurrent tests in global hooks:

    ts

    ``` javascript
    import { test } from 'vitest'

    test.concurrent('performs a query', ({ onTestFinished }) => {
      const db = connectDb()
      onTestFinished(() => db.close())
      db.query('SELECT * FROM users')
    })
    ```

    This hook is particularly useful when creating reusable logic:

    ts

    ``` javascript
    // this can be in a separate file
    function getTestDb() {
      const db = connectMockedDb()
      onTestFinished(() => db.close())
      return db
    }

    test('performs a user query', async () => {
      const db = getTestDb()
      expect(
        await db.query('SELECT * from users').perform()
      ).toEqual([])
    })

    test('performs an organization query', async () => {
      const db = getTestDb()
      expect(
        await db.query('SELECT * from organizations').perform()
      ).toEqual([])
    })
    ```

    **TIP**

    This hook is always called in reverse order and is not affected by [`sequence.hooks`](../config/index#sequence-hooks) option.
- name: open *  ​
  id: config/index#open
  summary: null
  belongs_to: Configuring Vitest
  description: "### open \\* \n\n- **Type:** `boolean`\n- **Default:** `!process.env.CI`\n- **CLI:**`--open`, `--open=false`\n\nOpen Vitest UI (WIP)"
- name: operator ​
  id: api/assert#operator
  summary: Compare val1 and val2 using operator
  belongs_to: assert
  description: |-
    ## operator

    - **Type:** `(val1: OperatorComparable, operator: Operator, val2: OperatorComparable, message?: string) => void`

    Compare `val1` and `val2` using `operator`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.operator', () => {
      assert.operator(1, '<', 2, 'everything is ok')
    })
    ```
- name: outputFile *  ​
  id: config/index#outputfile
  summary: Write test results to a file when the --reporter=json, --reporter=html or --reporter=junit option is also specified
  belongs_to: Configuring Vitest
  description: "### outputFile \\* \n\n- **Type:** `string | Record<string, string>`\n- **CLI:**`--outputFile=<path>`, `--outputFile.json=./path`\n\nWrite test results to a file when the `--reporter=json`, `--reporter=html` or `--reporter=junit` option is also specified. By providing an object instead of a string you can define individual outputs when using multiple reporters."
- name: ownInclude ​
  id: api/assert#owninclude
  summary: Asserts that haystack includes needle
  belongs_to: assert
  description: |-
    ## ownInclude

    - **Type:** `(haystack: any, needle: any, message?: string) => void`

    Asserts that `haystack` includes `needle`. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.ownInclude', () => {
      assert.ownInclude({ a: 1 }, { a: 1 })
    })
    ```
- name: parameter ​
  id: api/expect-typeof#parameter
  summary: You can extract a certain function argument with .parameter(number) call to perform other assertions on it
  belongs_to: expectTypeOf
  description: |-
    ## parameter

    - **Type:** `(nth: number) => ExpectTypeOf`

    You can extract a certain function argument with `.parameter(number)` call to perform other assertions on it.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    function foo(a: number, b: string) {
      return [a, b]
    }

    expectTypeOf(foo).parameter(0).toBeNumber()
    expectTypeOf(foo).parameter(1).toBeString()
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.
- name: parameters ​
  id: api/expect-typeof#parameters
  summary: You can extract function arguments with .parameters to perform assertions on its value
  belongs_to: expectTypeOf
  description: |-
    ## parameters

    - **Type:** `ExpectTypeOf<Parameters>`

    You can extract function arguments with `.parameters` to perform assertions on its value. Parameters are returned as an array.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    type NoParam = () => void
    type HasParam = (s: string) => void

    expectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()
    expectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.

    **TIP**

    You can also use [`.toBeCallableWith`](#tobecallablewith) matcher as a more expressive assertion.
- name: passWithNoTests *  ​
  id: config/index#passwithnotests
  summary: Vitest will not fail, if no tests will be found
  belongs_to: Configuring Vitest
  description: "### passWithNoTests \\* \n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI:**`--passWithNoTests`, `--passWithNoTests=false`\n\nVitest will not fail, if no tests will be found."
- name: poll ​
  id: api/expect#poll
  summary: expect.poll reruns the assertion until it is succeeded
  belongs_to: expect
  description: |-
    ## poll

    - **Type:** `ExpectStatic & (actual: () => any, options: { interval, timeout, message }) => Assertions`

    `expect.poll` reruns the *assertion* until it is succeeded. You can configure how many times Vitest should rerun the `expect.poll` callback by setting `interval` and `timeout` options.

    If an error is thrown inside the `expect.poll` callback, Vitest will retry again until the timeout runs out.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('element exists', async () => {
      asyncInjectElement()

      await expect.poll(() => document.querySelector('.element')).toBeTruthy()
    })
    ```

    **WARNING**

    `expect.poll` makes every assertion asynchronous, so do not forget to await it otherwise you might get unhandled promise rejections.

    `expect.poll` doesn't work with several matchers:

    - Snapshot matchers are not supported because they will always succeed. If your condition is flaky, consider using [`vi.waitFor`](vi#vi-waitfor) instead to resolve it first:

    ts

    ``` javascript
    import { expect, vi } from 'vitest'

    const flakyValue = await vi.waitFor(() => getFlakyValue())
    expect(flakyValue).toMatchSnapshot()
    ```

    - `.resolves` and `.rejects` are not supported. `expect.poll` already awaits the condition if it's asynchronous.
    - `toThrow` and its aliases are not supported because the `expect.poll` condition is always resolved before the matcher gets the value
- name: pool *  ​
  id: config/index#pool
  summary: Pool used to run tests in
  belongs_to: Configuring Vitest
  description: "### pool \\* \n\n- **Type:** `'threads' | 'forks' | 'vmThreads' | 'vmForks'`\n- **Default:** `'forks'`\n- **CLI:** `--pool=threads`\n\nPool used to run tests in.\n\n#### threads \\* \n\nEnable multi-threading using [tinypool](https://github.com/tinylibs/tinypool) (a lightweight fork of [Piscina](https://github.com/piscinajs/piscina)). When using threads you are unable to use process related APIs such as `process.chdir()`. Some libraries written in native languages, such as Prisma, `bcrypt` and `canvas`, have problems when running in multiple threads and run into segfaults. In these cases it is advised to use `forks` pool instead.\n\n#### forks \\* \n\nSimilar as `threads` pool but uses `child_process` instead of `worker_threads` via [tinypool](https://github.com/tinylibs/tinypool). Communication between tests and main process is not as fast as with `threads` pool. Process related APIs such as `process.chdir()` are available in `forks` pool.\n\n#### vmThreads \\* \n\nRun tests using [VM context](https://nodejs.org/api/vm.html) (inside a sandboxed environment) in a `threads` pool.\n\nThis makes tests run faster, but the VM module is unstable when running [ESM code](https://github.com/nodejs/node/issues/37648). Your tests will [leak memory](https://github.com/nodejs/node/issues/33439) - to battle that, consider manually editing [`poolOptions.vmThreads.memoryLimit`](#pooloptions-vmthreads-memorylimit) value.\n\n**WARNING**\n\nRunning code in a sandbox has some advantages (faster tests), but also comes with a number of disadvantages.\n\n- The globals within native modules, such as (`fs`, `path`, etc), differ from the globals present in your test environment. As a result, any error thrown by these native modules will reference a different Error constructor compared to the one used in your code:\n\nts\n\n``` javascript\ntry {\n  fs.writeFileSync('/doesnt exist')\n}\ncatch (err) {\n  console.log(err instanceof Error) // false\n}\n```\n\n- Importing ES modules caches them indefinitely which introduces memory leaks if you have a lot of contexts (test files). There is no API in Node.js that clears that cache.\n- Accessing globals [takes longer](https://github.com/nodejs/node/issues/31658) in a sandbox environment.\n\nPlease, be aware of these issues when using this option. Vitest team cannot fix any of the issues on our side.\n\n#### vmForks \\* \n\nSimilar as `vmThreads` pool but uses `child_process` instead of `worker_threads` via [tinypool](https://github.com/tinylibs/tinypool). Communication between tests and the main process is not as fast as with `vmThreads` pool. Process related APIs such as `process.chdir()` are available in `vmForks` pool. Please be aware that this pool has the same pitfalls listed in `vmThreads`."
- name: poolMatchGlobs ​
  id: config/index#poolmatchglobs
  summary: Automatically assign pool in which tests will run based on globs
  belongs_to: Configuring Vitest
  description: |-
    ### poolMatchGlobs

    - **Type:** `[string, 'threads' | 'forks' | 'vmThreads' | 'vmForks' | 'typescript'][]`
    - **Default:** `[]`

    Automatically assign pool in which tests will run based on globs. The first match will be used.

    For example:

    ts

    ``` javascript
    import { defineConfig } from 'vitest/config'

    export default defineConfig({
      test: {
        poolMatchGlobs: [
          // all tests in "worker-specific" directory will run inside a worker as if you enabled `--pool=threads` for them,
          ['**/tests/worker-specific/**', 'threads'],
          // run all tests in "browser" directory in an actual browser
          ['**/tests/browser/**', 'browser'],
          // all other tests will run based on "browser.enabled" and "threads" options, if you didn't specify other globs
          // ...
        ]
      }
    })
    ```
- name: poolOptions *  ​
  id: config/index#pooloptions
  summary: Options for threads pool
  belongs_to: Configuring Vitest
  description: "### poolOptions \\* \n\n- **Type:** `Record<'threads' | 'forks' | 'vmThreads' | 'vmForks', {}>`\n- **Default:** `{}`\n\n#### poolOptions.threads\n\nOptions for `threads` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: {\n        // Threads related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.threads.maxThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of threads. You can also use `VITEST_MAX_THREADS` environment variable.\n\n##### poolOptions.threads.minThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of threads. You can also use `VITEST_MIN_THREADS` environment variable.\n\n##### poolOptions.threads.singleThread\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nRun all tests with the same environment inside a single worker thread. This will disable built-in module isolation (your source code or [inlined](#server-deps-inline) code will still be reevaluated for each test), but can improve test performance.\n\n**WARNING**\n\nEven though this option will force tests to run one after another, this option is different from Jest's `--runInBand`. Vitest uses workers not only for running tests in parallel, but also to provide isolation. By disabling this option, your tests will run sequentially, but in the same global context, so you must provide isolation yourself.\n\nThis might cause all sorts of issues, if you are relying on global state (frontend frameworks usually do) or your code relies on environment to be defined separately for each test. But can be a speed boost for your tests (up to 3 times faster), that don't necessarily rely on global state or can easily bypass that.\n\n##### poolOptions.threads.useAtomics \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n\nUse Atomics to synchronize threads.\n\nThis can improve performance in some cases, but might cause segfault in older Node versions.\n\n##### poolOptions.threads.isolate\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nIsolate environment for each test file.\n\n##### poolOptions.threads.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` in the threads. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n#### poolOptions.forks\n\nOptions for `forks` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      forks: {\n        // Forks related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.forks.maxForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of forks.\n\n##### poolOptions.forks.minForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of forks.\n\n##### poolOptions.forks.isolate\n\n- **Type:** `boolean`\n- **Default:** `true`\n\nIsolate environment for each test file.\n\n##### poolOptions.forks.singleFork\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nRun all tests with the same environment inside a single child process. This will disable built-in module isolation (your source code or [inlined](#server-deps-inline) code will still be reevaluated for each test), but can improve test performance.\n\n**WARNING**\n\nEven though this option will force tests to run one after another, this option is different from Jest's `--runInBand`. Vitest uses child processes not only for running tests in parallel, but also to provide isolation. By disabling this option, your tests will run sequentially, but in the same global context, so you must provide isolation yourself.\n\nThis might cause all sorts of issues, if you are relying on global state (frontend frameworks usually do) or your code relies on environment to be defined separately for each test. But can be a speed boost for your tests (up to 3 times faster), that don't necessarily rely on global state or can easily bypass that.\n\n##### poolOptions.forks.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` process in the child processes. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n#### poolOptions.vmThreads\n\nOptions for `vmThreads` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmThreads: {\n        // VM threads related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.vmThreads.maxThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of threads. You can also use `VITEST_MAX_THREADS` environment variable.\n\n##### poolOptions.vmThreads.minThreads \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of threads. You can also use `VITEST_MIN_THREADS` environment variable.\n\n##### poolOptions.vmThreads.memoryLimit \\* \n\n- **Type:** `string | number`\n- **Default:** `1 / CPU Cores`\n\nSpecifies the memory limit for workers before they are recycled. This value heavily depends on your environment, so it's better to specify it manually instead of relying on the default.\n\n**TIP**\n\nThe implementation is based on Jest's [`workerIdleMemoryLimit`](https://jestjs.io/docs/configuration#workeridlememorylimit-numberstring).\n\nThe limit can be specified in a number of different ways and whatever the result is `Math.floor` is used to turn it into an integer value:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use 1.1.\n- With units\n  - `50%` - As above, a percentage of total system memory\n  - `100KB`, `65MB`, etc - With units to denote a fixed memory limit.\n    - `K` / `KB` - Kilobytes (x1000)\n    - `KiB` - Kibibytes (x1024)\n    - `M` / `MB` - Megabytes\n    - `MiB` - Mebibytes\n    - `G` / `GB` - Gigabytes\n    - `GiB` - Gibibytes\n\n**WARNING**\n\nPercentage based memory limit [does not work on Linux CircleCI](https://github.com/jestjs/jest/issues/11956#issuecomment-1212925677) workers due to incorrect system memory being reported.\n\n##### poolOptions.vmThreads.useAtomics \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n\nUse Atomics to synchronize threads.\n\nThis can improve performance in some cases, but might cause segfault in older Node versions.\n\n##### poolOptions.vmThreads.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` process in the VM context. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103).\n\n#### poolOptions.vmForks \\* \n\nOptions for `vmForks` pool.\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmForks: {\n        // VM forks related options here\n      }\n    }\n  }\n})\n```\n\n##### poolOptions.vmForks.maxForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMaximum number or percentage of threads. You can also use `VITEST_MAX_FORKS` environment variable.\n\n##### poolOptions.vmForks.minForks \\* \n\n- **Type:** `number | string`\n- **Default:** *available CPUs*\n\nMinimum number or percentage of threads. You can also use `VITEST_MIN_FORKS` environment variable.\n\n##### poolOptions.vmForks.memoryLimit \\* \n\n- **Type:** `string | number`\n- **Default:** `1 / CPU Cores`\n\nSpecifies the memory limit for workers before they are recycled. This value heavily depends on your environment, so it's better to specify it manually instead of relying on the default. How the value is calculated is described in [`poolOptions.vmThreads.memoryLimit`](#pooloptions-vmthreads-memorylimit)\n\n##### poolOptions.vmForks.execArgv \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nPass additional arguments to `node` process in the VM context. See [Command-line API \\| Node.js](https://nodejs.org/docs/latest/api/cli.html) for more information.\n\n**WARNING**\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See [https://github.com/nodejs/node/issues/41103](https://github.com/nodejs/node/issues/41103)."
- name: printConsoleTrace ​
  id: config/index#printconsoletrace
  summary: Always print console traces when calling any console method
  belongs_to: Configuring Vitest
  description: "### printConsoleTrace\n\n- **Type:** `boolean`\n- **Default:** `false`\n\nAlways print console traces when calling any `console` method. This is useful for debugging.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/config/](https://vitest.dev/config/)"
- name: property ​
  id: api/assert#property
  summary: null
  belongs_to: assert
  description: |-
    ## property

    - **Type:** `<T>(object: T, property: string, message?: string) => void`

    Asserts that `object` has a direct or inherited property named by `property`

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.property', () => {
      assert.property({ tea: { green: 'matcha' } }, 'tea')
      assert.property({ tea: { green: 'matcha' } }, 'toString')
    })
    ```
- name: propertyVal ​
  id: api/assert#propertyval
  summary: Asserts that object has a direct or inherited property named by property with a value given by value
  belongs_to: assert
  description: |-
    ## propertyVal

    - **Type:** `<T, V>(object: T, property: string, value: V, message?: string) => void`

    Asserts that `object` has a direct or inherited property named by `property` with a value given by `value`. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.notPropertyVal', () => {
      assert.propertyVal({ tea: 'is good' }, 'tea', 'is good')
    })
    ```
- name: rejects ​
  id: api/expect#rejects
  summary: rejects is intended to remove boilerplate when asserting asynchronous code
  belongs_to: expect
  description: |-
    ## rejects

    - **Type:** `Promisify<Assertions>`

    `rejects` is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap reason why the promise was rejected, and assert its value with usual assertions. If the promise successfully resolves, the assertion will fail.

    It returns the same `Assertions` object, but all matchers now return `Promise`, so you would need to `await` it. Also works with `chai` assertions.

    For example, if you have a function that fails when you call it, you may use this code to assert the reason:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    async function buyApples(id) {
      if (!id) {
        throw new Error('no id')
      }
    }

    test('buyApples throws an error when no id provided', async () => {
      // toThrow returns a promise now, so you HAVE to await it
      await expect(buyApples()).rejects.toThrow('no id')
    })
    ```

    **WARNING**

    If the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions were actually called, you can use [`expect.assertions(number)`](#expect-assertions).
- name: Reporters
  id: guide/reporters
  summary: Vitest provides several built-in reporters to display test output in different formats, as well as the ability to use custom reporters
  description: "# Reporters\n\nVitest provides several built-in reporters to display test output in different formats, as well as the ability to use custom reporters. You can select different reporters either by using the `--reporter` command line option, or by including a `reporters` property in your [configuration file](../config/index#reporters). If no reporter is specified, Vitest will use the `default` reporter as described below.\n\nUsing reporters via command line:\n\nbash\n\n``` javascript\nnpx vitest --reporter=verbose\n```\n\nUsing reporters via [`vitest.config.ts`](../config/index):\n\nts\n\n``` javascript\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    reporters: ['verbose']\n  },\n})\n```\n\nSome reporters can be customized by passing additional options to them. Reporter specific options are described in sections below.\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: [\n      'default',\n      ['junit', { suiteName: 'UI tests' }]\n    ],\n  },\n})\n```\n\n## Reporter Output\n\nBy default, Vitest's reporters will print their output to the terminal. When using the `json`, `html` or `junit` reporters, you can instead write your tests' output to a file by including an `outputFile` [configuration option](../config/index#outputfile) either in your Vite configuration file or via CLI.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=json --outputFile=./test-output.json\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['json'],\n    outputFile: './test-output.json'\n  },\n})\n```\n\n## Combining Reporters\n\nYou can use multiple reporters simultaneously to print your test results in different formats. For example:\n\nbash\n\n``` javascript\nnpx vitest --reporter=json --reporter=default\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['json', 'default'],\n    outputFile: './test-output.json'\n  },\n})\n```\n\nThe above example will both print the test results to the terminal in the default style and write them as JSON to the designated output file.\n\nWhen using multiple reporters, it's also possible to designate multiple output files, as follows:\n\nts\n\n``` javascript\nexport default defineConfig({\n  reporters: ['junit', 'json', 'verbose'],\n  outputFile: {\n    junit: './junit-report.xml',\n    json: './json-report.json',\n  },\n})\n```\n\nThis example will write separate JSON and XML reports as well as printing a verbose report to the terminal.\n\n## Built-in Reporters\n\n### Default Reporter\n\nBy default (i.e. if no reporter is specified), Vitest will display results for each test suite hierarchically as they run, and then collapse after a suite passes. When all tests have finished running, the final terminal output will display a summary of results and details of any failed tests.\n\nExample output for tests in progress:\n\nbash\n\n``` javascript\n✓ __tests__/file1.test.ts (2) 725ms\n✓ __tests__/file2.test.ts (5) 746ms\n  ✓ second test file (2) 746ms\n    ✓ 1 + 1 should equal 2\n    ✓ 2 - 1 should equal 1\n```\n\nFinal output after tests have finished:\n\nbash\n\n``` javascript\n✓ __tests__/file1.test.ts (2) 725ms\n✓ __tests__/file2.test.ts (2) 746ms\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\n```\n\n### Basic Reporter\n\nThe `basic` reporter displays the test files that have run and a summary of results after the entire suite has finished running. Individual tests are not included in the report unless they fail.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=basic\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['basic']\n  },\n})\n```\n\nExample output using basic reporter:\n\nbash\n\n``` javascript\n✓ __tests__/file1.test.ts (2) 725ms\n✓ __tests__/file2.test.ts (2) 746ms\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\n```\n\n### Verbose Reporter\n\nFollows the same hierarchical structure as the `default` reporter, but does not collapse sub-trees for passed test suites. The final terminal output displays all tests that have run, including those that have passed.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=verbose\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['verbose']\n  },\n})\n```\n\nExample of final terminal output for a passing test suite:\n\nbash\n\n``` javascript\n✓ __tests__/file1.test.ts (2) 725ms\n   ✓ first test file (2) 725ms\n     ✓ 2 + 2 should equal 4\n     ✓ 4 - 2 should equal 2\n✓ __tests__/file2.test.ts (2) 746ms\n  ✓ second test file (2) 746ms\n    ✓ 1 + 1 should equal 2\n    ✓ 2 - 1 should equal 1\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\n```\n\n### Dot Reporter\n\nPrints a single dot for each completed test to provide minimal output while still showing all tests that have run. Details are only provided for failed tests, along with the `basic` reporter summary for the suite.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=dot\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['dot']\n  },\n})\n```\n\nExample terminal output for a passing test suite:\n\nbash\n\n``` javascript\n....\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\n```\n\n### JUnit Reporter\n\nOutputs a report of the test results in JUnit XML format. Can either be printed to the terminal or written to an XML file using the [`outputFile`](../config/index#outputfile) configuration option.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=junit\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['junit']\n  },\n})\n```\n\nExample of a JUnit XML report:\n\nxml\n\n``` javascript\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<testsuites name=\"vitest tests\" tests=\"2\" failures=\"1\" errors=\"0\" time=\"0.503\">\n    <testsuite name=\"__tests__/test-file-1.test.ts\" timestamp=\"2023-10-19T17:41:58.580Z\" hostname=\"My-Computer.local\" tests=\"2\" failures=\"1\" errors=\"0\" skipped=\"0\" time=\"0.013\">\n        <testcase classname=\"__tests__/test-file-1.test.ts\" name=\"first test file &gt; 2 + 2 should equal 4\" time=\"0.01\">\n            <failure message=\"expected 5 to be 4 // Object.is equality\" type=\"AssertionError\">\nAssertionError: expected 5 to be 4 // Object.is equality\n ❯ __tests__/test-file-1.test.ts:20:28\n            </failure>\n        </testcase>\n        <testcase classname=\"__tests__/test-file-1.test.ts\" name=\"first test file &gt; 4 - 2 should equal 2\" time=\"0\">\n        </testcase>\n    </testsuite>\n</testsuites>\n```\n\nThe outputted XML contains nested `testsuites` and `testcase` tags. You can use the environment variables `VITEST_JUNIT_SUITE_NAME` and `VITEST_JUNIT_CLASSNAME` to configure their `name` and `classname` attributes, respectively. These can also be customized via reporter options:\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: [\n      ['junit', { suiteName: 'custom suite name', classname: 'custom-classname' }]\n    ]\n  },\n})\n```\n\n### JSON Reporter\n\nOutputs a report of the test results in JSON format. Can either be printed to the terminal or written to a file using the [`outputFile`](../config/index#outputfile) configuration option.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=json\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['json']\n  },\n})\n```\n\nExample of a JSON report:\n\njson\n\n``` javascript\n{\n  \"numTotalTestSuites\": 1,\n  \"numPassedTestSuites\": 0,\n  \"numFailedTestSuites\": 1,\n  \"numPendingTestSuites\": 0,\n  \"numTotalTests\": 1,\n  \"numPassedTests\": 0,\n  \"numFailedTests\": 1,\n  \"numPendingTests\": 0,\n  \"numTodoTests\": 0,\n  \"startTime\": 1697737019307,\n  \"success\": false,\n  \"testResults\": [\n    {\n      \"assertionResults\": [\n        {\n          \"ancestorTitles\": [\n            \"\",\n            \"first test file\"\n          ],\n          \"fullName\": \" first test file 2 + 2 should equal 4\",\n          \"status\": \"failed\",\n          \"title\": \"2 + 2 should equal 4\",\n          \"duration\": 9,\n          \"failureMessages\": [\n            \"expected 5 to be 4 // Object.is equality\"\n          ],\n          \"location\": {\n            \"line\": 20,\n            \"column\": 28\n          }\n        }\n      ],\n      \"startTime\": 1697737019787,\n      \"endTime\": 1697737019797,\n      \"status\": \"failed\",\n      \"message\": \"\",\n      \"name\": \"/root-directory/__tests__/test-file-1.test.ts\"\n    }\n  ]\n}\n```\n\n### HTML Reporter\n\nGenerates an HTML file to view test results through an interactive [GUI](ui). After the file has been generated, Vitest will keep a local development server running and provide a link to view the report in a browser.\n\nOutput file can be specified using the [`outputFile`](../config/index#outputfile) configuration option. If no `outputFile` option is provided, a new HTML file will be created.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=html\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['html']\n  },\n})\n```\n\n**TIP**\n\nThis reporter requires installed [`@vitest/ui`](ui) package.\n\n### TAP Reporter\n\nOutputs a report following [Test Anything Protocol](https://testanything.org/) (TAP).\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=tap\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['tap']\n  },\n})\n```\n\nExample of a TAP report:\n\nbash\n\n``` javascript\nTAP version 13\n1..1\nnot ok 1 - __tests__/test-file-1.test.ts # time=14.00ms {\n    1..1\n    not ok 1 - first test file # time=13.00ms {\n        1..2\n        not ok 1 - 2 + 2 should equal 4 # time=11.00ms\n            ---\n            error:\n                name: \"AssertionError\"\n                message: \"expected 5 to be 4 // Object.is equality\"\n            at: \"/root-directory/__tests__/test-file-1.test.ts:20:28\"\n            actual: \"5\"\n            expected: \"4\"\n            ...\n        ok 2 - 4 - 2 should equal 2 # time=1.00ms\n    }\n}\n```\n\n### TAP Flat Reporter\n\nOutputs a TAP flat report. Like the `tap` reporter, test results are formatted to follow TAP standards, but test suites are formatted as a flat list rather than a nested hierarchy.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=tap-flat\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['tap-flat']\n  },\n})\n```\n\nExample of a TAP flat report:\n\nbash\n\n``` javascript\nTAP version 13\n1..2\nnot ok 1 - __tests__/test-file-1.test.ts > first test file > 2 + 2 should equal 4 # time=11.00ms\n    ---\n    error:\n        name: \"AssertionError\"\n        message: \"expected 5 to be 4 // Object.is equality\"\n    at: \"/root-directory/__tests__/test-file-1.test.ts:20:28\"\n    actual: \"5\"\n    expected: \"4\"\n    ...\nok 2 - __tests__/test-file-1.test.ts > first test file > 4 - 2 should equal 2 # time=0.00ms\n```\n\n### Hanging Process Reporter\n\nDisplays a list of hanging processes, if any are preventing Vitest from exiting safely. The `hanging-process` reporter does not itself display test results, but can be used in conjunction with another reporter to monitor processes while tests run. Using this reporter can be resource-intensive, so should generally be reserved for debugging purposes in situations where Vitest consistently cannot exit the process.\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=hanging-process\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['hanging-process']\n  },\n})\n```\n\n### Github Actions Reporter\n\nOutput [workflow commands](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-error-message) to provide annotations for test failures. This reporter is automatically enabled with a [`default`](#default-reporter) reporter when `process.env.GITHUB_ACTIONS === 'true'`.\n\nIf you configure non-default reporters, you need to explicitly add `github-actions`.\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: process.env.GITHUB_ACTIONS ? ['dot', 'github-actions'] : ['dot'],\n  },\n})\n```\n\n### Blob Reporter\n\nStores test results on the machine so they can be later merged using [`--merge-reports`](cli#merge-reports) command. By default, stores all results in `.vitest-reports` folder, but can be overriden with `--outputFile` or `--outputFile.blob` flags.\n\nbash\n\n``` javascript\nnpx vitest --reporter=blob --outputFile=reports/blob-1.json\n```\n\nWe recommend using this reporter if you are running Vitest on different machines with the [`--shard`](cli#shard) flag. All blob reports can be merged into any report by using `--merge-reports` command at the end of your CI pipeline:\n\nbash\n\n``` javascript\nnpx vitest --merge-reports=reports --reporter=json --reporter=default\n```\n\n**TIP**\n\nBoth `--reporter=blob` and `--merge-reports` do not work in watch mode.\n\n## Custom Reporters\n\nYou can use third-party custom reporters installed from NPM by specifying their package name in the reporters' option:\n\nCLIvitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=some-published-vitest-reporter\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['some-published-vitest-reporter']\n  },\n})\n```\n\nAdditionally, you can define your own [custom reporters](../advanced/reporters) and use them by specifying their file path:\n\nbash\n\n``` javascript\nnpx vitest --reporter=./path/to/reporter.ts\n```\n\nCustom reporters should implement the [Reporter interface](https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/types/reporter.ts).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/reporters](https://vitest.dev/guide/reporters)"
- name: reporters *  ​
  id: config/index#reporters
  summary: Custom reporters for output
  belongs_to: Configuring Vitest
  description: "### reporters \\* \n\n- **Type:** `Reporter | Reporter[]`\n- **Default:** `'default'`\n- **CLI:**`--reporter=<name>`, `--reporter=<name1> --reporter=<name2>`\n\nCustom [reporters](../guide/reporters) for output. Reporters can be [a Reporter instance](https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/types/reporter.ts), a string to select built-in reporters, or a path to a custom implementation (e.g. `'./path/to/reporter.ts'`, `'@scope/reporter'`)."
- name: 'Reporters: Basic Reporter ​'
  id: guide/reporters#basic-reporter
  summary: The basic reporter displays the test files that have run and a summary of results after the entire suite has finished running
  belongs_to: Reporters
  description: |-
    ### Basic Reporter

    The `basic` reporter displays the test files that have run and a summary of results after the entire suite has finished running. Individual tests are not included in the report unless they fail.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=basic
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['basic']
      },
    })
    ```

    Example output using basic reporter:

    bash

    ``` javascript
    ✓ __tests__/file1.test.ts (2) 725ms
    ✓ __tests__/file2.test.ts (2) 746ms

     Test Files  2 passed (2)
          Tests  4 passed (4)
       Start at  12:34:32
       Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)
    ```
- name: 'Reporters: Blob Reporter ​'
  id: guide/reporters#blob-reporter
  summary: Stores test results on the machine so they can be later merged using --merge-reports command
  belongs_to: Reporters
  description: |-
    ### Blob Reporter

    Stores test results on the machine so they can be later merged using [`--merge-reports`](cli#merge-reports) command. By default, stores all results in `.vitest-reports` folder, but can be overriden with `--outputFile` or `--outputFile.blob` flags.

    bash

    ``` javascript
    npx vitest --reporter=blob --outputFile=reports/blob-1.json
    ```

    We recommend using this reporter if you are running Vitest on different machines with the [`--shard`](cli#shard) flag. All blob reports can be merged into any report by using `--merge-reports` command at the end of your CI pipeline:

    bash

    ``` javascript
    npx vitest --merge-reports=reports --reporter=json --reporter=default
    ```

    **TIP**

    Both `--reporter=blob` and `--merge-reports` do not work in watch mode.
- name: 'Reporters: Built-in Reporters ​'
  id: guide/reporters#built-in-reporters
  summary: null
  belongs_to: Reporters
  description: '## Built-in Reporters'
- name: 'Reporters: Combining Reporters ​'
  id: guide/reporters#combining-reporters
  summary: You can use multiple reporters simultaneously to print your test results in different formats
  belongs_to: Reporters
  description: |-
    ## Combining Reporters

    You can use multiple reporters simultaneously to print your test results in different formats. For example:

    bash

    ``` javascript
    npx vitest --reporter=json --reporter=default
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['json', 'default'],
        outputFile: './test-output.json'
      },
    })
    ```

    The above example will both print the test results to the terminal in the default style and write them as JSON to the designated output file.

    When using multiple reporters, it's also possible to designate multiple output files, as follows:

    ts

    ``` javascript
    export default defineConfig({
      reporters: ['junit', 'json', 'verbose'],
      outputFile: {
        junit: './junit-report.xml',
        json: './json-report.json',
      },
    })
    ```

    This example will write separate JSON and XML reports as well as printing a verbose report to the terminal.
- name: 'Reporters: Custom Reporters ​'
  id: guide/reporters#custom-reporters
  summary: Custom reporters should implement the Reporter interface
  belongs_to: Reporters
  description: "## Custom Reporters\n\nYou can use third-party custom reporters installed from NPM by specifying their package name in the reporters' option:\n\nCLI vitest.config.ts\n\nbash\n\n``` javascript\nnpx vitest --reporter=some-published-vitest-reporter\n```\n\nts\n\n``` javascript\nexport default defineConfig({\n  test: {\n    reporters: ['some-published-vitest-reporter']\n  },\n})\n```\n\nAdditionally, you can define your own [custom reporters](../advanced/reporters) and use them by specifying their file path:\n\nbash\n\n``` javascript\nnpx vitest --reporter=./path/to/reporter.ts\n```\n\nCustom reporters should implement the [Reporter interface](https://github.com/vitest-dev/vitest/blob/main/packages/vitest/src/types/reporter.ts).\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/reporters](https://vitest.dev/guide/reporters)"
- name: 'Reporters: Default Reporter ​'
  id: guide/reporters#default-reporter
  summary: By default (i.e
  belongs_to: Reporters
  description: |-
    ### Default Reporter

    By default (i.e. if no reporter is specified), Vitest will display results for each test suite hierarchically as they run, and then collapse after a suite passes. When all tests have finished running, the final terminal output will display a summary of results and details of any failed tests.

    Example output for tests in progress:

    bash

    ``` javascript
    ✓ __tests__/file1.test.ts (2) 725ms
    ✓ __tests__/file2.test.ts (5) 746ms
      ✓ second test file (2) 746ms
        ✓ 1 + 1 should equal 2
        ✓ 2 - 1 should equal 1
    ```

    Final output after tests have finished:

    bash

    ``` javascript
    ✓ __tests__/file1.test.ts (2) 725ms
    ✓ __tests__/file2.test.ts (2) 746ms

     Test Files  2 passed (2)
          Tests  4 passed (4)
       Start at  12:34:32
       Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)
    ```
- name: 'Reporters: Dot Reporter ​'
  id: guide/reporters#dot-reporter
  summary: Prints a single dot for each completed test to provide minimal output while still showing all tests that have run
  belongs_to: Reporters
  description: |-
    ### Dot Reporter

    Prints a single dot for each completed test to provide minimal output while still showing all tests that have run. Details are only provided for failed tests, along with the `basic` reporter summary for the suite.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=dot
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['dot']
      },
    })
    ```

    Example terminal output for a passing test suite:

    bash

    ``` javascript
    ....

     Test Files  2 passed (2)
          Tests  4 passed (4)
       Start at  12:34:32
       Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)
    ```
- name: 'Reporters: Github Actions Reporter ​'
  id: guide/reporters#github-actions-reporter
  summary: Output workflow commands to provide annotations for test failures
  belongs_to: Reporters
  description: |-
    ### Github Actions Reporter

    Output [workflow commands](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-error-message) to provide annotations for test failures. This reporter is automatically enabled with a [`default`](#default-reporter) reporter when `process.env.GITHUB_ACTIONS === 'true'`.

    If you configure non-default reporters, you need to explicitly add `github-actions`.

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: process.env.GITHUB_ACTIONS ? ['dot', 'github-actions'] : ['dot'],
      },
    })
    ```
- name: 'Reporters: Hanging Process Reporter ​'
  id: guide/reporters#hanging-process-reporter
  summary: Displays a list of hanging processes, if any are preventing Vitest from exiting safely
  belongs_to: Reporters
  description: |-
    ### Hanging Process Reporter

    Displays a list of hanging processes, if any are preventing Vitest from exiting safely. The `hanging-process` reporter does not itself display test results, but can be used in conjunction with another reporter to monitor processes while tests run. Using this reporter can be resource-intensive, so should generally be reserved for debugging purposes in situations where Vitest consistently cannot exit the process.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=hanging-process
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['hanging-process']
      },
    })
    ```
- name: 'Reporters: HTML Reporter ​'
  id: guide/reporters#html-reporter
  summary: Generates an HTML file to view test results through an interactive GUI
  belongs_to: Reporters
  description: |-
    ### HTML Reporter

    Generates an HTML file to view test results through an interactive [GUI](ui). After the file has been generated, Vitest will keep a local development server running and provide a link to view the report in a browser.

    Output file can be specified using the [`outputFile`](../config/index#outputfile) configuration option. If no `outputFile` option is provided, a new HTML file will be created.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=html
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['html']
      },
    })
    ```

    **TIP**

    This reporter requires installed [`@vitest/ui`](ui) package.
- name: 'Reporters: JSON Reporter ​'
  id: guide/reporters#json-reporter
  summary: Outputs a report of the test results in JSON format
  belongs_to: Reporters
  description: |-
    ### JSON Reporter

    Outputs a report of the test results in JSON format. Can either be printed to the terminal or written to a file using the [`outputFile`](../config/index#outputfile) configuration option.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=json
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['json']
      },
    })
    ```

    Example of a JSON report:

    json

    ``` javascript
    {
      "numTotalTestSuites": 1,
      "numPassedTestSuites": 0,
      "numFailedTestSuites": 1,
      "numPendingTestSuites": 0,
      "numTotalTests": 1,
      "numPassedTests": 0,
      "numFailedTests": 1,
      "numPendingTests": 0,
      "numTodoTests": 0,
      "startTime": 1697737019307,
      "success": false,
      "testResults": [
        {
          "assertionResults": [
            {
              "ancestorTitles": [
                "",
                "first test file"
              ],
              "fullName": " first test file 2 + 2 should equal 4",
              "status": "failed",
              "title": "2 + 2 should equal 4",
              "duration": 9,
              "failureMessages": [
                "expected 5 to be 4 // Object.is equality"
              ],
              "location": {
                "line": 20,
                "column": 28
              }
            }
          ],
          "startTime": 1697737019787,
          "endTime": 1697737019797,
          "status": "failed",
          "message": "",
          "name": "/root-directory/__tests__/test-file-1.test.ts"
        }
      ]
    }
    ```
- name: 'Reporters: JUnit Reporter ​'
  id: guide/reporters#junit-reporter
  summary: Outputs a report of the test results in JUnit XML format
  belongs_to: Reporters
  description: |-
    ### JUnit Reporter

    Outputs a report of the test results in JUnit XML format. Can either be printed to the terminal or written to an XML file using the [`outputFile`](../config/index#outputfile) configuration option.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=junit
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['junit']
      },
    })
    ```

    Example of a JUnit XML report:

    xml

    ``` javascript
    <?xml version="1.0" encoding="UTF-8" ?>
    <testsuites name="vitest tests" tests="2" failures="1" errors="0" time="0.503">
        <testsuite name="__tests__/test-file-1.test.ts" timestamp="2023-10-19T17:41:58.580Z" hostname="My-Computer.local" tests="2" failures="1" errors="0" skipped="0" time="0.013">
            <testcase classname="__tests__/test-file-1.test.ts" name="first test file &gt; 2 + 2 should equal 4" time="0.01">
                <failure message="expected 5 to be 4 // Object.is equality" type="AssertionError">
    AssertionError: expected 5 to be 4 // Object.is equality
     ❯ __tests__/test-file-1.test.ts:20:28
                </failure>
            </testcase>
            <testcase classname="__tests__/test-file-1.test.ts" name="first test file &gt; 4 - 2 should equal 2" time="0">
            </testcase>
        </testsuite>
    </testsuites>
    ```

    The outputted XML contains nested `testsuites` and `testcase` tags. You can use the environment variables `VITEST_JUNIT_SUITE_NAME` and `VITEST_JUNIT_CLASSNAME` to configure their `name` and `classname` attributes, respectively. These can also be customized via reporter options:

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: [
          ['junit', { suiteName: 'custom suite name', classname: 'custom-classname' }]
        ]
      },
    })
    ```
- name: 'Reporters: Reporter Output ​'
  id: guide/reporters#reporter-output
  summary: By default, Vitest's reporters will print their output to the terminal
  belongs_to: Reporters
  description: |-
    ## Reporter Output

    By default, Vitest's reporters will print their output to the terminal. When using the `json`, `html` or `junit` reporters, you can instead write your tests' output to a file by including an `outputFile` [configuration option](../config/index#outputfile) either in your Vite configuration file or via CLI.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=json --outputFile=./test-output.json
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['json'],
        outputFile: './test-output.json'
      },
    })
    ```
- name: 'Reporters: TAP Flat Reporter ​'
  id: guide/reporters#tap-flat-reporter
  summary: Outputs a TAP flat report
  belongs_to: Reporters
  description: |-
    ### TAP Flat Reporter

    Outputs a TAP flat report. Like the `tap` reporter, test results are formatted to follow TAP standards, but test suites are formatted as a flat list rather than a nested hierarchy.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=tap-flat
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['tap-flat']
      },
    })
    ```

    Example of a TAP flat report:

    bash

    ``` javascript
    TAP version 13
    1..2
    not ok 1 - __tests__/test-file-1.test.ts > first test file > 2 + 2 should equal 4 # time=11.00ms
        ---
        error:
            name: "AssertionError"
            message: "expected 5 to be 4 // Object.is equality"
        at: "/root-directory/__tests__/test-file-1.test.ts:20:28"
        actual: "5"
        expected: "4"
        ...
    ok 2 - __tests__/test-file-1.test.ts > first test file > 4 - 2 should equal 2 # time=0.00ms
    ```
- name: 'Reporters: TAP Reporter ​'
  id: guide/reporters#tap-reporter
  summary: Outputs a report following Test Anything Protocol (TAP)
  belongs_to: Reporters
  description: |-
    ### TAP Reporter

    Outputs a report following [Test Anything Protocol](https://testanything.org/) (TAP).

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=tap
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['tap']
      },
    })
    ```

    Example of a TAP report:

    bash

    ``` javascript
    TAP version 13
    1..1
    not ok 1 - __tests__/test-file-1.test.ts # time=14.00ms {
        1..1
        not ok 1 - first test file # time=13.00ms {
            1..2
            not ok 1 - 2 + 2 should equal 4 # time=11.00ms
                ---
                error:
                    name: "AssertionError"
                    message: "expected 5 to be 4 // Object.is equality"
                at: "/root-directory/__tests__/test-file-1.test.ts:20:28"
                actual: "5"
                expected: "4"
                ...
            ok 2 - 4 - 2 should equal 2 # time=1.00ms
        }
    }
    ```
- name: 'Reporters: Verbose Reporter ​'
  id: guide/reporters#verbose-reporter
  summary: Follows the same hierarchical structure as the default reporter, but does not collapse sub-trees for passed test suites
  belongs_to: Reporters
  description: |-
    ### Verbose Reporter

    Follows the same hierarchical structure as the `default` reporter, but does not collapse sub-trees for passed test suites. The final terminal output displays all tests that have run, including those that have passed.

    CLI vitest.config.ts

    bash

    ``` javascript
    npx vitest --reporter=verbose
    ```

    ts

    ``` javascript
    export default defineConfig({
      test: {
        reporters: ['verbose']
      },
    })
    ```

    Example of final terminal output for a passing test suite:

    bash

    ``` javascript
    ✓ __tests__/file1.test.ts (2) 725ms
       ✓ first test file (2) 725ms
         ✓ 2 + 2 should equal 4
         ✓ 4 - 2 should equal 2
    ✓ __tests__/file2.test.ts (2) 746ms
      ✓ second test file (2) 746ms
        ✓ 1 + 1 should equal 2
        ✓ 2 - 1 should equal 1

     Test Files  2 passed (2)
          Tests  4 passed (4)
       Start at  12:34:32
       Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)
    ```
- name: resolves ​
  id: api/expect#resolves
  summary: resolves is intended to remove boilerplate when asserting asynchronous code
  belongs_to: expect
  description: |-
    ## resolves

    - **Type:** `Promisify<Assertions>`

    `resolves` is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail.

    It returns the same `Assertions` object, but all matchers now return `Promise`, so you would need to `await` it. Also works with `chai` assertions.

    For example, if you have a function, that makes an API call and returns some data, you may use this code to assert its return value:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    async function buyApples() {
      return fetch('/buy/apples').then(r => r.json())
    }

    test('buyApples returns new stock id', async () => {
      // toEqual returns a promise now, so you HAVE to await it
      await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API
      await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API
    })
    ```

    **WARNING**

    If the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually called, you may use [`expect.assertions(number)`](#expect-assertions).
- name: resolves ​
  id: api/expect-typeof#resolves
  summary: This matcher extracts resolved value of a Promise, so you can perform other assertions on it
  belongs_to: expectTypeOf
  description: |-
    ## resolves

    - **Type:** `ExpectTypeOf<ResolvedPromise>`

    This matcher extracts resolved value of a `Promise`, so you can perform other assertions on it.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    async function asyncFunc() {
      return 123
    }

    expectTypeOf(asyncFunc).returns.resolves.toBeNumber()
    expectTypeOf(Promise.resolve('string')).resolves.toBeString()
    ```

    **WARNING**

    If used on a non-promise type, it will return `never`, so you won't be able to chain it with other matchers.
- name: resolveSnapshotPath *  ​
  id: config/index#resolvesnapshotpath
  summary: Overrides default snapshot path
  belongs_to: Configuring Vitest
  description: "### resolveSnapshotPath \\* \n\n- **Type**: `(testPath: string, snapExtension: string) => string`\n- **Default**: stores snapshot files in `__snapshots__` directory\n\nOverrides default snapshot path. For example, to store snapshots next to test files:\n\nts\n\n``` javascript\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    resolveSnapshotPath: (testPath, snapExtension) => testPath + snapExtension,\n  },\n})\n```"
- name: restoreMocks ​
  id: config/index#restoremocks
  summary: Will call .mockRestore() on all spies before each test
  belongs_to: Configuring Vitest
  description: |-
    ### restoreMocks

    - **Type:** `boolean`
    - **Default:** `false`

    Will call [`.mockRestore()`](../api/mock#mockrestore) on all spies before each test. This will clear mock history and reset its implementation to the original one.
- name: retry ​
  id: config/index#retry
  summary: Retry the test specific number of times if it fails
  belongs_to: Configuring Vitest
  description: |-
    ### retry

    - **Type:** `number`
    - **Default:** `0`
    - **CLI:** `--retry=<value>`

    Retry the test specific number of times if it fails.
- name: Retry-ability
  id: guide/browser/retry-ability
  summary: Tests in the browser might fail inconsistently due to their asynchronous nature
  description: "# Retry-ability\n\nTests in the browser might fail inconsistently due to their asynchronous nature. Because of this, it is important to have a way to guarantee that assertions succeed even if the condition is delayed (by a timeout, network request, or animation, for example). For this purpose, Vitest provides retriable assertions out of the box via the [`expect.poll`](../../api/expect#poll) and `expect.element` APIs:\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\nimport { screen } from '@testing-library/dom'\n\ntest('error banner is rendered', async () => {\n  triggerError()\n\n  // @testing-library provides queries with built-in retry-ability\n  // It will try to find the banner until it's rendered\n  const banner = await screen.findByRole('alert', {\n    name: /error/i,\n  })\n\n  // Vitest provides `expect.element` with built-in retry-ability\n  // It will check `element.textContent` until it's equal to \"Error!\"\n  await expect.element(banner).toHaveTextContent('Error!')\n})\n```\n\n**TIP**\n\n`expect.element` is a shorthand for `expect.poll(() => element)` and works in exactly the same way.\n\n`toHaveTextContent` and all other [`@testing-library/jest-dom`](https://github.com/testing-library/jest-dom) assertions are still available on a regular `expect` without a built-in retry-ability mechanism:\n\nts\n\n``` javascript\n// will fail immediately if .textContent is not `'Error!'`\nexpect(banner).toHaveTextContent('Error!')\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/browser/retry-ability](https://vitest.dev/guide/browser/retry-ability)"
- name: returns ​
  id: api/expect-typeof#returns
  summary: You can use .returns to extract return value of a function type
  belongs_to: expectTypeOf
  description: |-
    ## returns

    - **Type:** `ExpectTypeOf<ReturnValue>`

    You can use `.returns` to extract return value of a function type.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(() => {}).returns.toBeVoid()
    expectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.
- name: root ​
  id: config/index#root
  summary: null
  belongs_to: Configuring Vitest
  description: |-
    ### root

    - **Type:** `string`
    - **CLI:**`-r <path>`, `--root=<path>`

    Project root
- name: runner ​
  id: config/index#runner
  summary: Path to a custom test runner
  belongs_to: Configuring Vitest
  description: |-
    ### runner

    - **Type**: `VitestRunnerConstructor`
    - **Default**: `node`, when running tests, or `benchmark`, when running benchmarks

    Path to a custom test runner. This is an advanced feature and should be used with custom library runners. You can read more about it in [the documentation](../advanced/runner).
- name: sameDeepMembers ​
  id: api/assert#samedeepmembers
  summary: Asserts that set1 and set2 have the same members in any order
  belongs_to: assert
  description: |-
    ## sameDeepMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` have the same members in any order. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.sameDeepMembers', () => {
      assert.sameDeepMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members')
    })
    ```
- name: sameDeepOrderedMembers ​
  id: api/assert#samedeeporderedmembers
  summary: Asserts that set1 and set2 have the same members in the same order
  belongs_to: assert
  description: |-
    ## sameDeepOrderedMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` have the same members in the same order. Uses a deep equality check.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.sameDeepOrderedMembers', () => {
      assert.sameDeepOrderedMembers([{ a: 1 }, { b: 2 }, { c: 3 }], [{ a: 1 }, { b: 2 }, { c: 3 }], 'same deep ordered members')
    })
    ```
- name: sameMembers ​
  id: api/assert#samemembers
  summary: Asserts that set1 and set2 have the same members in any order
  belongs_to: assert
  description: |-
    ## sameMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` have the same members in any order. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.sameMembers', () => {
      assert.sameMembers([1, 2, 3], [2, 1, 3], 'same members')
    })
    ```
- name: sameOrderedMembers ​
  id: api/assert#sameorderedmembers
  summary: Asserts that set1 and set2 have the same members in the same order
  belongs_to: assert
  description: |-
    ## sameOrderedMembers

    - **Type:** `<T>(set1: T[], set2: T[], message?: string) => void`

    Asserts that `set1` and `set2` have the same members in the same order. Uses a strict equality check (===).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.sameOrderedMembers', () => {
      assert.sameOrderedMembers([1, 2, 3], [1, 2, 3], 'same ordered members')
    })
    ```
- name: sequence ​
  id: config/index#sequence
  summary: Options for how tests should be sorted
  belongs_to: Configuring Vitest
  description: "### sequence\n\n- **Type**: `{ sequencer?, shuffle?, seed?, hooks?, setupFiles? }`\n\nOptions for how tests should be sorted.\n\nYou can provide sequence options to CLI with dot notation:\n\nsh\n\n``` javascript\nnpx vitest --sequence.shuffle --sequence.seed=1000\n```\n\n#### sequence.sequencer \\* \n\n- **Type**: `TestSequencerConstructor`\n- **Default**: `BaseSequencer`\n\nA custom class that defines methods for sharding and sorting. You can extend `BaseSequencer` from `vitest/node`, if you only need to redefine one of the `sort` and `shard` methods, but both should exist.\n\nSharding is happening before sorting, and only if `--shard` option is provided.\n\n#### sequence.shuffle\n\n- **Type**: `boolean | { files?, tests? }`\n- **Default**: `false`\n- **CLI**: `--sequence.shuffle`, `--sequence.shuffle=false`\n\nIf you want files and tests to run randomly, you can enable it with this option, or CLI argument [`--sequence.shuffle`](../guide/cli).\n\nVitest usually uses cache to sort tests, so long running tests start earlier - this makes tests run faster. If your files and tests will run in random order you will lose this performance improvement, but it may be useful to track tests that accidentally depend on another run previously.\n\n#### sequence.shuffle.files\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--sequence.shuffle.files`, `--sequence.shuffle.files=false`\n\nWhether to randomize files, be aware that long running tests will not start earlier if you enable this option.\n\n#### sequence.shuffle.tests\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--sequence.shuffle.tests`, `--sequence.shuffle.tests=false`\n\nWhether to randomize tests.\n\n#### sequence.concurrent\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **CLI**: `--sequence.concurrent`, `--sequence.concurrent=false`\n\nIf you want tests to run in parallel, you can enable it with this option, or CLI argument [`--sequence.concurrent`](../guide/cli).\n\n#### sequence.seed \\* \n\n- **Type**: `number`\n- **Default**: `Date.now()`\n- **CLI**: `--sequence.seed=1000`\n\nSets the randomization seed, if tests are running in random order.\n\n#### sequence.hooks\n\n- **Type**: `'stack' | 'list' | 'parallel'`\n- **Default**: `'parallel'`\n- **CLI**: `--sequence.hooks=<value>`\n\nChanges the order in which hooks are executed.\n\n- `stack` will order \"after\" hooks in reverse order, \"before\" hooks will run in the order they were defined\n- `list` will order all hooks in the order they are defined\n- `parallel` will run hooks in a single group in parallel (hooks in parent suites will still run before the current suite's hooks)\n\n**TIP**\n\nThis option doesn't affect [`onTestFinished`](../api/index#ontestfinished). It is always called in reverse order.\n\n#### sequence.setupFiles\n\n- **Type**: `'list' | 'parallel'`\n- **Default**: `'parallel'`\n- **CLI**: `--sequence.setupFiles=<value>`\n\nChanges the order in which setup files are executed.\n\n- `list` will run setup files in the order they are defined\n- `parallel` will run setup files in parallel"
- name: server ​
  id: config/index#server
  summary: Vite-Node server options
  belongs_to: Configuring Vitest
  description: |-
    ### server

    - **Type:** `{ sourcemap?, deps?, ... }`

    Vite-Node server options.

    #### server.sourcemap

    - **Type:** `'inline' | boolean`
    - **Default:** `'inline'`

    Inject inline source map to modules.

    #### server.debug

    - **Type:** `{ dumpModules?, loadDumppedModules? }`

    Vite-Node debugger options.

    #### server.debug.dumpModules

    - **Type:** `boolean | string`

    Dump the transformed module to filesystem. Passing a string will dump to the specified path.

    #### server.debug.loadDumppedModules

    - **Type:** `boolean`

    Read dumped module from filesystem whenever exists. Useful for debugging by modifying the dump result from the filesystem.

    #### server.deps

    - **Type:** `{ external?, inline?, ... }`

    Handling for dependencies resolution.

    #### server.deps.external

    - **Type:** `(string | RegExp)[]`
    - **Default:** `[/\/node_modules\//]`

    Externalize means that Vite will bypass the package to the native Node. Externalized dependencies will not be applied to Vite's transformers and resolvers, so they do not support HMR on reload. By default, all packages inside `node_modules` are externalized.

    These options support package names as they are written in `node_modules` or specified inside [`deps.moduleDirectories`](#deps-moduledirectories). For example, package `@company/some-name` located inside `packages/some-name` should be specified as `some-name`, and `packages` should be included in `deps.moduleDirectories`. Basically, Vitest always checks the file path, not the actual package name.

    If regexp is used, Vitest calls it on the *file path*, not the package name.

    #### server.deps.inline

    - **Type:** `(string | RegExp)[] | true`
    - **Default:** `[]`

    Vite will process inlined modules. This could be helpful to handle packages that ship `.js` in ESM format (that Node can't handle).

    If `true`, every dependency will be inlined. All dependencies, specified in [`ssr.noExternal`](https://vitejs.dev/guide/ssr.html#ssr-externals) will be inlined by default.

    #### server.deps.fallbackCJS

    - **Type** `boolean`
    - **Default:** `false`

    When a dependency is a valid ESM package, try to guess the cjs version based on the path. This might be helpful, if a dependency has the wrong ESM file.

    This might potentially cause some misalignment if a package has different logic in ESM and CJS mode.

    #### server.deps.cacheDir

    - **Type** `string`
    - **Default**: `'node_modules/.vite'`

    Directory to save cache files.
- name: Setup and Teardown ​
  id: api/index#setup-and-teardown
  summary: These functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code
  belongs_to: Test API Reference
  description: |-
    ## Setup and Teardown

    These functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code. They apply to the current context: the file if they are used at the top-level or the current suite if they are inside a `describe` block. These hooks are not called, when you are running Vitest as a type checker.
- name: setupFiles ​
  id: config/index#setupfiles
  summary: Path to setup files
  belongs_to: Configuring Vitest
  description: |-
    ### setupFiles

    - **Type:** `string | string[]`

    Path to setup files. They will be run before each test file.

    **INFO**

    Changing setup files will trigger rerun of all tests.

    You can use `process.env.VITEST_POOL_ID` (integer-like string) inside to distinguish between threads.

    **TIP**

    Note, that if you are running [`--isolate=false`](#isolate), this setup file will be run in the same global scope multiple times. Meaning, that you are accessing the same global object before each test, so make sure you are not doing the same thing more than you need.

    For example, you may rely on a global variable:

    ts

    ``` javascript
    import { config } from '@some-testing-lib'

    if (!globalThis.defined) {
      config.plugins = [myCoolPlugin]
      computeHeavyThing()
      globalThis.defined = true
    }

    // hooks are reset before each suite
    afterEach(() => {
      cleanup()
    })

    globalThis.resetBeforeEachTest = true
    ```
- name: silent *  ​
  id: config/index#silent
  summary: null
  belongs_to: Configuring Vitest
  description: "### silent \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n- **CLI:**`--silent`, `--silent=false`\n\nSilent console output from tests"
- name: slowTestThreshold *  ​
  id: config/index#slowtestthreshold
  summary: The number of milliseconds after which a test is considered slow and reported as such in the results
  belongs_to: Configuring Vitest
  description: "### slowTestThreshold \\* \n\n- **Type**: `number`\n- **Default**: `300`\n- **CLI**: `--slow-test-threshold=<number>`, `--slowTestThreshold=<number>`\n\nThe number of milliseconds after which a test is considered slow and reported as such in the results."
- name: Snapshot
  id: guide/snapshot
  summary: Snapshot tests are a very useful tool whenever you want to make sure the output of your functions does not change unexpectedly
  description: "# Snapshot\n\n[Learn Snapshot by video from Vue School](https://vueschool.io/lessons/snapshots-in-vitest?friend=vueuse)\n\nSnapshot tests are a very useful tool whenever you want to make sure the output of your functions does not change unexpectedly.\n\nWhen using snapshot, Vitest will take a snapshot of the given value, then compare it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the result.\n\n## Use Snapshots\n\nTo snapshot a value, you can use the [`toMatchSnapshot()`](../api/expect#tomatchsnapshot) from `expect()` API:\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchSnapshot()\n})\n```\n\nThe first time this test is run, Vitest creates a snapshot file that looks like this:\n\njs\n\n``` javascript\n// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n\nexports['toUpperCase 1'] = '\"FOOBAR\"'\n```\n\nThe snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. On subsequent test runs, Vitest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code that should be fixed, or the implementation has changed and the snapshot needs to be updated.\n\n**WARNING**\n\nWhen using Snapshots with async concurrent tests, `expect` from the local [Test Context](test-context) must be used to ensure the right test is detected.\n\n## Inline Snapshots\n\nSimilarly, you can use the [`toMatchInlineSnapshot()`](../api/expect#tomatchinlinesnapshot) to store the snapshot inline within the test file.\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchInlineSnapshot()\n})\n```\n\nInstead of creating a snapshot file, Vitest will modify the test file directly to update the snapshot as a string:\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchInlineSnapshot('\"FOOBAR\"')\n})\n```\n\nThis allows you to see the expected output directly without jumping across different files.\n\n**WARNING**\n\nWhen using Snapshots with async concurrent tests, `expect` from the local [Test Context](test-context) must be used to ensure the right test is detected.\n\n## Updating Snapshots\n\nWhen the received value doesn't match the snapshot, the test fails and shows you the difference between them. When the snapshot change is expected, you may want to update the snapshot from the current state.\n\nIn watch mode, you can press the `u` key in the terminal to update the failed snapshot directly.\n\nOr you can use the `--update` or `-u` flag in the CLI to make Vitest update snapshots.\n\nbash\n\n``` javascript\nvitest -u\n```\n\n## File Snapshots\n\nWhen calling `toMatchSnapshot()`, we store all snapshots in a formatted snap file. That means we need to escape some characters (namely the double-quote `\"` and backtick `` ` ``) in the snapshot string. Meanwhile, you might lose the syntax highlighting for the snapshot content (if they are in some language).\n\nTo improve this case, we introduce [`toMatchFileSnapshot()`](../api/expect#tomatchfilesnapshot) to explicitly snapshot in a file. This allows you to assign any file extension to the snapshot file, and making them more readable.\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n```\n\nIt will compare with the content of `./test/basic.output.html`. And can be written back with the `--update` flag.\n\n## Image Snapshots\n\nIt's also possible to snapshot images using [`jest-image-snapshot`](https://github.com/americanexpress/jest-image-snapshot).\n\nbash\n\n``` javascript\nnpm i -D jest-image-snapshot\n```\n\nts\n\n``` javascript\ntest('image snapshot', () => {\n  expect(readFileSync('./test/stubs/input-image.png'))\n    .toMatchImageSnapshot()\n})\n```\n\n## Custom Serializer\n\nYou can add your own logic to alter how your snapshots are serialized. Like Jest, Vitest has default serializers for built-in JavaScript types, HTML elements, ImmutableJS and for React elements.\n\nYou can explicitly add custom serializer by using [`expect.addSnapshotSerializer`](../api/expect#expect-addsnapshotserializer) API.\n\nts\n\n``` javascript\nexpect.addSnapshotSerializer({\n  serialize(val, config, indentation, depth, refs, printer) {\n    // `printer` is a function that serializes a value using existing plugins.\n    return `Pretty foo: ${printer(\n      val.foo,\n      config,\n      indentation,\n      depth,\n      refs,\n    )}`\n  },\n  test(val) {\n    return val && Object.prototype.hasOwnProperty.call(val, 'foo')\n  },\n})\n```\n\nWe also support [snapshotSerializers](../config/index#snapshotserializers) option to implicitly add custom serializers.\n\nts\n\n``` javascript\nimport { SnapshotSerializer } from 'vitest'\n\nexport default {\n  serialize(val, config, indentation, depth, refs, printer) {\n    // `printer` is a function that serializes a value using existing plugins.\n    return `Pretty foo: ${printer(\n      val.foo,\n      config,\n      indentation,\n      depth,\n      refs,\n    )}`\n  },\n  test(val) {\n    return val && Object.prototype.hasOwnProperty.call(val, 'foo')\n  },\n} satisfies SnapshotSerializer\n```\n\nts\n\n``` javascript\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    snapshotSerializers: ['path/to/custom-serializer.ts']\n  },\n})\n```\n\nAfter adding a test like this:\n\nts\n\n``` javascript\ntest('foo snapshot test', () => {\n  const bar = {\n    foo: {\n      x: 1,\n      y: 2,\n    },\n  }\n\n  expect(bar).toMatchSnapshot()\n})\n```\n\nYou will get the following snapshot:\n\n``` javascript\nPretty foo: Object {\n  \"x\": 1,\n  \"y\": 2,\n}\n```\n\nWe are using Jest's `pretty-format` for serializing snapshots. You can read more about it here: [pretty-format](https://github.com/facebook/jest/blob/main/packages/pretty-format/README.md#serialize).\n\n## Difference from Jest\n\nVitest provides an almost compatible Snapshot feature with [Jest's](https://jestjs.io/docs/snapshot-testing) with a few exceptions:\n\n#### 1. Comment header in the snapshot file is different\n\ndiff\n\n``` javascript\n- // Jest Snapshot v1, https://goo.gl/fbAQLP\n+ // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n```\n\nThis does not really affect the functionality but might affect your commit diff when migrating from Jest.\n\n#### 2. `printBasicPrototype` is default to `false`\n\nBoth Jest and Vitest's snapshots are powered by [`pretty-format`](https://github.com/facebook/jest/blob/main/packages/pretty-format). In Vitest we set `printBasicPrototype` default to `false` to provide a cleaner snapshot output, while in Jest \\<29.0.0 it's `true` by default.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('snapshot', () => {\n  const bar = [\n    {\n      foo: 'bar',\n    },\n  ]\n\n  // in Jest\n  expect(bar).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        \"foo\": \"bar\",\n      },\n    ]\n  `)\n\n  // in Vitest\n  expect(bar).toMatchInlineSnapshot(`\n    [\n      {\n        \"foo\": \"bar\",\n      },\n    ]\n  `)\n})\n```\n\nWe believe this is a more reasonable default for readability and overall DX. If you still prefer Jest's behavior, you can change your config:\n\nts\n\n``` javascript\n// vitest.config.js\nexport default defineConfig({\n  test: {\n    snapshotFormat: {\n      printBasicPrototype: true\n    }\n  }\n})\n```\n\n#### 3. Chevron `>` is used as a separator instead of colon `:` for custom messages\n\nVitest uses chevron `>` as a separator instead of colon `:` for readability, when a custom message is passed during creation of a snapshot file.\n\nFor the following example test code:\n\njs\n\n``` javascript\ntest('toThrowErrorMatchingSnapshot', () => {\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingSnapshot('hint')\n})\n```\n\nIn Jest, the snapshot will be:\n\nconsole\n\n``` javascript\nexports[`toThrowErrorMatchingSnapshot: hint 1`] = `\"error\"`;\n```\n\nIn Vitest, the equivalent snapshot will be:\n\nconsole\n\n``` javascript\nexports[`toThrowErrorMatchingSnapshot > hint 1`] = `[Error: error]`;\n```\n\n#### 4. default `Error` snapshot is different for `toThrowErrorMatchingSnapshot` and `toThrowErrorMatchingInlineSnapshot`\n\njs\n\n``` javascript\ntest('snapshot', () => {\n  //\n  // in Jest\n  //\n\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  // Jest snapshots `Error.message` for `Error` instance\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`\"error\"`)\n\n  //\n  // in Vitest\n  //\n\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`[Error: error]`)\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/snapshot](https://vitest.dev/guide/snapshot)"
- name: 'Snapshot: Custom Serializer ​'
  id: guide/snapshot#custom-serializer
  summary: You can add your own logic to alter how your snapshots are serialized
  belongs_to: Snapshot
  description: |-
    ## Custom Serializer

    You can add your own logic to alter how your snapshots are serialized. Like Jest, Vitest has default serializers for built-in JavaScript types, HTML elements, ImmutableJS and for React elements.

    You can explicitly add custom serializer by using [`expect.addSnapshotSerializer`](../api/expect#expect-addsnapshotserializer) API.

    ts

    ``` javascript
    expect.addSnapshotSerializer({
      serialize(val, config, indentation, depth, refs, printer) {
        // `printer` is a function that serializes a value using existing plugins.
        return `Pretty foo: ${printer(
          val.foo,
          config,
          indentation,
          depth,
          refs,
        )}`
      },
      test(val) {
        return val && Object.prototype.hasOwnProperty.call(val, 'foo')
      },
    })
    ```

    We also support [snapshotSerializers](../config/index#snapshotserializers) option to implicitly add custom serializers.

    ts

    ``` javascript
    import { SnapshotSerializer } from 'vitest'

    export default {
      serialize(val, config, indentation, depth, refs, printer) {
        // `printer` is a function that serializes a value using existing plugins.
        return `Pretty foo: ${printer(
          val.foo,
          config,
          indentation,
          depth,
          refs,
        )}`
      },
      test(val) {
        return val && Object.prototype.hasOwnProperty.call(val, 'foo')
      },
    } satisfies SnapshotSerializer
    ```

    ts

    ``` javascript
    import { defineConfig } from 'vite'

    export default defineConfig({
      test: {
        snapshotSerializers: ['path/to/custom-serializer.ts']
      },
    })
    ```

    After adding a test like this:

    ts

    ``` javascript
    test('foo snapshot test', () => {
      const bar = {
        foo: {
          x: 1,
          y: 2,
        },
      }

      expect(bar).toMatchSnapshot()
    })
    ```

    You will get the following snapshot:

    ``` javascript
    Pretty foo: Object {
      "x": 1,
      "y": 2,
    }
    ```

    We are using Jest's `pretty-format` for serializing snapshots. You can read more about it here: [pretty-format](https://github.com/facebook/jest/blob/main/packages/pretty-format/README.md#serialize).
- name: 'Snapshot: Difference from Jest ​'
  id: guide/snapshot#difference-from-jest
  summary: This does not really affect the functionality but might affect your commit diff when migrating from Jest
  belongs_to: Snapshot
  description: "## Difference from Jest\n\nVitest provides an almost compatible Snapshot feature with [Jest's](https://jestjs.io/docs/snapshot-testing) with a few exceptions:\n\n#### 1. Comment header in the snapshot file is different\n\ndiff\n\n``` javascript\n- // Jest Snapshot v1, https://goo.gl/fbAQLP\n+ // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n```\n\nThis does not really affect the functionality but might affect your commit diff when migrating from Jest.\n\n#### 2. `printBasicPrototype` is default to `false`\n\nBoth Jest and Vitest's snapshots are powered by [`pretty-format`](https://github.com/facebook/jest/blob/main/packages/pretty-format). In Vitest we set `printBasicPrototype` default to `false` to provide a cleaner snapshot output, while in Jest \\<29.0.0 it's `true` by default.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('snapshot', () => {\n  const bar = [\n    {\n      foo: 'bar',\n    },\n  ]\n\n  // in Jest\n  expect(bar).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        \"foo\": \"bar\",\n      },\n    ]\n  `)\n\n  // in Vitest\n  expect(bar).toMatchInlineSnapshot(`\n    [\n      {\n        \"foo\": \"bar\",\n      },\n    ]\n  `)\n})\n```\n\nWe believe this is a more reasonable default for readability and overall DX. If you still prefer Jest's behavior, you can change your config:\n\nts\n\n``` javascript\n// vitest.config.js\nexport default defineConfig({\n  test: {\n    snapshotFormat: {\n      printBasicPrototype: true\n    }\n  }\n})\n```\n\n#### 3. Chevron `>` is used as a separator instead of colon `:` for custom messages\n\nVitest uses chevron `>` as a separator instead of colon `:` for readability, when a custom message is passed during creation of a snapshot file.\n\nFor the following example test code:\n\njs\n\n``` javascript\ntest('toThrowErrorMatchingSnapshot', () => {\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingSnapshot('hint')\n})\n```\n\nIn Jest, the snapshot will be:\n\nconsole\n\n``` javascript\nexports[`toThrowErrorMatchingSnapshot: hint 1`] = `\"error\"`;\n```\n\nIn Vitest, the equivalent snapshot will be:\n\nconsole\n\n``` javascript\nexports[`toThrowErrorMatchingSnapshot > hint 1`] = `[Error: error]`;\n```\n\n#### 4. default `Error` snapshot is different for `toThrowErrorMatchingSnapshot` and `toThrowErrorMatchingInlineSnapshot`\n\njs\n\n``` javascript\ntest('snapshot', () => {\n  //\n  // in Jest\n  //\n\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  // Jest snapshots `Error.message` for `Error` instance\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`\"error\"`)\n\n  //\n  // in Vitest\n  //\n\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`[Error: error]`)\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/snapshot](https://vitest.dev/guide/snapshot)"
- name: 'Snapshot: File Snapshots ​'
  id: guide/snapshot#file-snapshots
  summary: When calling toMatchSnapshot(), we store all snapshots in a formatted snap file
  belongs_to: Snapshot
  description: |-
    ## File Snapshots

    When calling `toMatchSnapshot()`, we store all snapshots in a formatted snap file. That means we need to escape some characters (namely the double-quote `"` and backtick `` ` ``) in the snapshot string. Meanwhile, you might lose the syntax highlighting for the snapshot content (if they are in some language).

    To improve this case, we introduce [`toMatchFileSnapshot()`](../api/expect#tomatchfilesnapshot) to explicitly snapshot in a file. This allows you to assign any file extension to the snapshot file, and making them more readable.

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('render basic', async () => {
      const result = renderHTML(h('div', { class: 'foo' }))
      await expect(result).toMatchFileSnapshot('./test/basic.output.html')
    })
    ```

    It will compare with the content of `./test/basic.output.html`. And can be written back with the `--update` flag.
- name: 'Snapshot: Image Snapshots ​'
  id: guide/snapshot#image-snapshots
  summary: It's also possible to snapshot images using jest-image-snapshot
  belongs_to: Snapshot
  description: |-
    ## Image Snapshots

    It's also possible to snapshot images using [`jest-image-snapshot`](https://github.com/americanexpress/jest-image-snapshot).

    bash

    ``` javascript
    npm i -D jest-image-snapshot
    ```

    ts

    ``` javascript
    test('image snapshot', () => {
      expect(readFileSync('./test/stubs/input-image.png'))
        .toMatchImageSnapshot()
    })
    ```
- name: 'Snapshot: Inline Snapshots ​'
  id: guide/snapshot#inline-snapshots
  summary: Similarly, you can use the toMatchInlineSnapshot() to store the snapshot inline within the test file
  belongs_to: Snapshot
  description: |-
    ## Inline Snapshots

    Similarly, you can use the [`toMatchInlineSnapshot()`](../api/expect#tomatchinlinesnapshot) to store the snapshot inline within the test file.

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('toUpperCase', () => {
      const result = toUpperCase('foobar')
      expect(result).toMatchInlineSnapshot()
    })
    ```

    Instead of creating a snapshot file, Vitest will modify the test file directly to update the snapshot as a string:

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('toUpperCase', () => {
      const result = toUpperCase('foobar')
      expect(result).toMatchInlineSnapshot('"FOOBAR"')
    })
    ```

    This allows you to see the expected output directly without jumping across different files.

    **WARNING**

    When using Snapshots with async concurrent tests, `expect` from the local [Test Context](test-context) must be used to ensure the right test is detected.
- name: 'Snapshot: Updating Snapshots ​'
  id: guide/snapshot#updating-snapshots
  summary: When the received value doesn't match the snapshot, the test fails and shows you the difference between them
  belongs_to: Snapshot
  description: |-
    ## Updating Snapshots

    When the received value doesn't match the snapshot, the test fails and shows you the difference between them. When the snapshot change is expected, you may want to update the snapshot from the current state.

    In watch mode, you can press the `u` key in the terminal to update the failed snapshot directly.

    Or you can use the `--update` or `-u` flag in the CLI to make Vitest update snapshots.

    bash

    ``` javascript
    vitest -u
    ```
- name: 'Snapshot: Use Snapshots ​'
  id: guide/snapshot#use-snapshots
  summary: The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process
  belongs_to: Snapshot
  description: |-
    ## Use Snapshots

    To snapshot a value, you can use the [`toMatchSnapshot()`](../api/expect#tomatchsnapshot) from `expect()` API:

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('toUpperCase', () => {
      const result = toUpperCase('foobar')
      expect(result).toMatchSnapshot()
    })
    ```

    The first time this test is run, Vitest creates a snapshot file that looks like this:

    js

    ``` javascript
    // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

    exports['toUpperCase 1'] = '"FOOBAR"'
    ```

    The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. On subsequent test runs, Vitest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code that should be fixed, or the implementation has changed and the snapshot needs to be updated.

    **WARNING**

    When using Snapshots with async concurrent tests, `expect` from the local [Test Context](test-context) must be used to ensure the right test is detected.
- name: snapshotEnvironment ​
  id: config/index#snapshotEnvironment
  summary: Path to a custom snapshot environment implementation
  belongs_to: Configuring Vitest
  description: |-
    ### snapshotEnvironment

    - **Type:** `string`

    Path to a custom snapshot environment implementation. This is useful if you are running your tests in an environment that doesn't support Node.js APIs. This option doesn't have any effect on a browser runner.

    This object should have the shape of `SnapshotEnvironment` and is used to resolve and read/write snapshot files:

    ts

    ``` javascript
    export interface SnapshotEnvironment {
      getVersion: () => string
      getHeader: () => string
      resolvePath: (filepath: string) => Promise<string>
      resolveRawPath: (testPath: string, rawPath: string) => Promise<string>
      saveSnapshotFile: (filepath: string, snapshot: string) => Promise<void>
      readSnapshotFile: (filepath: string) => Promise<string | null>
      removeSnapshotFile: (filepath: string) => Promise<void>
    }
    ```

    You can extend default `VitestSnapshotEnvironment` from `vitest/snapshot` entry point if you need to overwrite only a part of the API.

    **WARNING**

    This is a low-level option and should be used only for advanced cases where you don't have access to default Node.js APIs.

    If you just need to configure snapshots feature, use [`snapshotFormat`](#snapshotformat) or [`resolveSnapshotPath`](#resolvesnapshotpath) options.
- name: snapshotFormat *  ​
  id: config/index#snapshotformat
  summary: Format options for snapshot testing
  belongs_to: Configuring Vitest
  description: "### snapshotFormat \\* \n\n- **Type:** `PrettyFormatOptions`\n\nFormat options for snapshot testing. These options are passed down to [`pretty-format`](https://www.npmjs.com/package/pretty-format).\n\n**TIP**\n\nBeware that `plugins` field on this object will be ignored.\n\nIf you need to extend snapshot serializer via pretty-format plugins, please, use [`expect.addSnapshotSerializer`](../api/expect#expect-addsnapshotserializer) API or [snapshotSerializers](#snapshotserializers) option."
- name: snapshotSerializers *  ​
  id: config/index#snapshotserializers
  summary: A list of paths to snapshot serializer modules for snapshot testing, useful if you want add custom snapshot serializers
  belongs_to: Configuring Vitest
  description: "### snapshotSerializers \\* \n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nA list of paths to snapshot serializer modules for snapshot testing, useful if you want add custom snapshot serializers. See [Custom Serializer](../guide/snapshot#custom-serializer) for more information."
- name: soft ​
  id: api/expect#soft
  summary: expect.soft functions similarly to expect, but instead of terminating the test execution upon a failed assertion, it continues running and marks the failure as a test failure
  belongs_to: expect
  description: |-
    ## soft

    - **Type:** `ExpectStatic & (actual: any) => Assertions`

    `expect.soft` functions similarly to `expect`, but instead of terminating the test execution upon a failed assertion, it continues running and marks the failure as a test failure. All errors encountered during the test will be displayed until the test is completed.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('expect.soft test', () => {
      expect.soft(1 + 1).toBe(3) // mark the test as fail and continue
      expect.soft(1 + 2).toBe(4) // mark the test as fail and continue
    })
    // At the end of the test, the above errors will be output.
    ```

    It can also be used with `expect`. if `expect` assertion fails, the test will be terminated and all errors will be displayed.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('expect.soft test', () => {
      expect.soft(1 + 1).toBe(3) // mark the test as fail and continue
      expect(1 + 2).toBe(4) // failed and terminate the test, all previous errors will be output
      expect.soft(1 + 3).toBe(5) // do not run
    })
    ```

    **WARNING**

    `expect.soft` can only be used inside the [`test`](index#test) function.
- name: strictEqual ​
  id: api/assert#strictequal
  summary: Asserts strict equality (===) of actual and expected
  belongs_to: assert
  description: |-
    ## strictEqual

    - **Type:** `<T>(actual: T, expected: T, message?: string) => void`

    Asserts strict equality (===) of `actual` and `expected`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.strictEqual', () => {
      assert.strictEqual(Math.sqrt(4), 2)
    })
    ```
- name: Task Metadata
  id: advanced/metadata
  summary: Vitest exposes experimental private API
  description: "# Task Metadata\n\n**WARNING**\n\nVitest exposes experimental private API. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\nIf you are developing a custom reporter or using Vitest Node.js API, you might find it useful to pass data from tests that are being executed in various contexts to your reporter or custom Vitest handler.\n\nTo accomplish this, relying on the [test context](../guide/test-context) is not feasible since it cannot be serialized. However, with Vitest, you can utilize the `meta` property available on every task (suite or test) to share data between your tests and the Node.js process. It's important to note that this communication is one-way only, as the `meta` property can only be modified from within the test context. Any changes made within the Node.js context will not be visible in your tests.\n\nYou can populate `meta` property on test context or inside `beforeAll`/`afterAll` hooks for suite tasks.\n\nts\n\n``` javascript\nafterAll((suite) => {\n  suite.meta.done = true\n})\n\ntest('custom', ({ task }) => {\n  task.meta.custom = 'some-custom-handler'\n})\n```\n\nOnce a test is completed, Vitest will send a task including the result and `meta` to the Node.js process using RPC. To intercept and process this task, you can utilize the `onTaskUpdate` method available in your reporter implementation:\n\nts\n\n``` javascript\n// custom-reporter.js\nexport default {\n  // you can intercept packs if needed\n  onTaskUpdate(packs) {\n    const [id, result, meta] = packs[0]\n  },\n  // meta is located on every task inside \"onFinished\"\n  onFinished(files) {\n    files[0].meta.done === true\n    files[0].tasks[0].meta.custom === 'some-custom-handler'\n  }\n}\n```\n\n**WARNING**\n\nVitest can send several tasks at the same time if several tests are completed in a short period of time.\n\n**BEWARE**\n\nVitest uses different methods to communicate with the Node.js process.\n\n- If Vitest runs tests inside worker threads, it will send data via [message port](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort)\n- If Vitest uses child process, the data will be send as a serialized Buffer via [`process.send`](https://nodejs.org/api/process.html#processsendmessage-sendhandle-options-callback) API\n- If Vitest runs tests in the browser, the data will be stringified using [flatted](https://www.npmjs.com/package/flatted) package\n\nThis property is also present on every test in the `json` reporter, so make sure that data can be serialized into JSON.\n\nAlso, make sure you serialize [Error properties](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#error_types) before you set them.\n\nYou can also get this information from Vitest state when tests finished running:\n\nts\n\n``` javascript\nconst vitest = await createVitest('test')\nawait vitest.start()\nvitest.state.getFiles()[0].meta.done === true\nvitest.state.getFiles()[0].tasks[0].meta.custom === 'some-custom-handler'\n```\n\nIt's also possible to extend type definitions when using TypeScript:\n\nts\n\n``` javascript\ndeclare module 'vitest' {\n  interface TaskMeta {\n    done?: boolean\n    custom?: string\n  }\n}\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/metadata](https://vitest.dev/advanced/metadata)"
- name: teardownTimeout *  ​
  id: config/index#teardowntimeout
  summary: null
  belongs_to: Configuring Vitest
  description: "### teardownTimeout \\* \n\n- **Type:** `number`\n- **Default:** `10000`\n- **CLI:**`--teardown-timeout=5000`, `--teardownTimeout=5000`\n\nDefault timeout to wait for close when Vitest shuts down, in milliseconds"
- name: Test API Reference
  id: api/index
  summary: Vitest 1.3.0 deprecates the use of options as the last parameter
  description: "# Test API Reference\n\nThe following types are used in the type signatures below\n\nts\n\n``` javascript\ntype Awaitable<T> = T | PromiseLike<T>\ntype TestFunction = () => Awaitable<void>\n\ninterface TestOptions {\n  /**\n   * Will fail the test if it takes too long to execute\n   */\n  timeout?: number\n  /**\n   * Will retry the test specific number of times if it fails\n   *\n   * @default 0\n   */\n  retry?: number\n  /**\n   * Will repeat the same test several times even if it fails each time\n   * If you have \"retry\" option and it fails, it will use every retry in each cycle\n   * Useful for debugging random failings\n   *\n   * @default 0\n   */\n  repeats?: number\n}\n```\n\nVitest 1.3.0 deprecates the use of options as the last parameter. You will see a deprecation message until 2.0.0 when this syntax will be removed. If you need to pass down options, use `test` function's second argument:\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest('flaky test', () => {}, { retry: 3 }) \ntest('flaky test', { retry: 3 }, () => {})\n```\n\nWhen a test function returns a promise, the runner will wait until it is resolved to collect async expectations. If the promise is rejected, the test will fail.\n\n**TIP**\n\nIn Jest, `TestFunction` can also be of type `(done: DoneCallback) => void`. If this form is used, the test will not be concluded until `done` is called. You can achieve the same using an `async` function, see the [Migration guide Done Callback section](../guide/migration#done-callback).\n\nMost options support both dot-syntax and object-syntax allowing you to use whatever style you prefer.\n\ndot-syntaxobject-syntax\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest.skip('skipped test', () => {\n  // some logic that fails right now\n})\n```\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest('skipped test', { skip: true }, () => {\n  // some logic that fails right now\n})\n```\n\n## test\n\n- **Alias:** `it`\n\n`test` defines a set of related expectations. It receives the test name and a function that holds the expectations to test.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with [testTimeout](../config/index#testtimeout)\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\ntest('should work as expected', () => {\n  expect(Math.sqrt(4)).toBe(2)\n})\n```\n\n### test.extend\n\n- **Alias:** `it.extend`\n\nUse `test.extend` to extend the test context with custom fixtures. This will return a new `test` and it's also extendable, so you can compose more fixtures or override existing ones by extending it as you need. See [Extend Test Context](../guide/test-context#test-extend) for more information.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nconst todos = []\nconst archive = []\n\nconst myTest = test.extend({\n  todos: async ({ task }, use) => {\n    todos.push(1, 2, 3)\n    await use(todos)\n    todos.length = 0\n  },\n  archive\n})\n\nmyTest('add item', ({ todos }) => {\n  expect(todos.length).toBe(3)\n\n  todos.push(4)\n  expect(todos.length).toBe(4)\n})\n```\n\n### test.skip\n\n- **Alias:** `it.skip`\n\nIf you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use `test.skip` to avoid running them.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest.skip('skipped test', () => {\n  // Test skipped, no error\n  assert.equal(Math.sqrt(4), 3)\n})\n```\n\nYou can also skip test by calling `skip` on its [context](../guide/test-context) dynamically:\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest('skipped test', (context) => {\n  context.skip()\n  // Test skipped, no error\n  assert.equal(Math.sqrt(4), 3)\n})\n```\n\n### test.skipIf\n\n- **Alias:** `it.skipIf`\n\nIn some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific. Instead of wrapping the test code with `if`, you can use `test.skipIf` to skip the test whenever the condition is truthy.\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ntest.skipIf(isDev)('prod only test', () => {\n  // this test only runs in production\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### test.runIf\n\n- **Alias:** `it.runIf`\n\nOpposite of [test.skipIf](#test-skipif).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ntest.runIf(isDev)('dev only test', () => {\n  // this test only runs in development\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### test.only\n\n- **Alias:** `it.only`\n\nUse `test.only` to only run certain tests in a given suite. This is useful when debugging.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with [testTimeout](../config/index#testtimeout).\n\nts\n\n``` javascript\nimport { assert, test } from 'vitest'\n\ntest.only('test', () => {\n  // Only this test (and others marked with only) are run\n  assert.equal(Math.sqrt(4), 2)\n})\n```\n\nSometimes it is very useful to run `only` tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.\n\nIn order to do that run `vitest` with specific file containing the tests in question.\n\n``` javascript\n# vitest interesting.test.ts\n```\n\n### test.concurrent\n\n- **Alias:** `it.concurrent`\n\n`test.concurrent` marks consecutive tests to be run in parallel. It receives the test name, an async function with the tests to collect, and an optional timeout (in milliseconds).\n\nts\n\n``` javascript\nimport { describe, test } from 'vitest'\n\n// The two tests marked with concurrent will be run in parallel\ndescribe('suite', () => {\n  test('serial test', async () => { /* ... */ })\n  test.concurrent('concurrent test 1', async () => { /* ... */ })\n  test.concurrent('concurrent test 2', async () => { /* ... */ })\n})\n```\n\n`test.skip`, `test.only`, and `test.todo` works with concurrent tests. All the following combinations are valid:\n\nts\n\n``` javascript\ntest.concurrent(/* ... */)\ntest.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)\ntest.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)\ntest.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)\n```\n\nWhen running concurrent tests, Snapshots and Assertions must use `expect` from the local [Test Context](../guide/test-context) to ensure the right test is detected.\n\nts\n\n``` javascript\ntest.concurrent('test 1', async ({ expect }) => {\n  expect(foo).toMatchSnapshot()\n})\ntest.concurrent('test 2', async ({ expect }) => {\n  expect(foo).toMatchSnapshot()\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### test.sequential\n\n- **Alias:** `it.sequential`\n\n`test.sequential` marks a test as sequential. This is useful if you want to run tests in sequence within `describe.concurrent` or with the `--sequence.concurrent` command option.\n\nts\n\n``` javascript\n// with config option { sequence: { concurrent: true } }\ntest('concurrent test 1', async () => { /* ... */ })\ntest('concurrent test 2', async () => { /* ... */ })\n\ntest.sequential('sequential test 1', async () => { /* ... */ })\ntest.sequential('sequential test 2', async () => { /* ... */ })\n\n// within concurrent suite\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n\n  test.sequential('sequential test 1', async () => { /* ... */ })\n  test.sequential('sequential test 2', async () => { /* ... */ })\n})\n```\n\n### test.todo\n\n- **Alias:** `it.todo`\n\nUse `test.todo` to stub tests to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.\n\nts\n\n``` javascript\n// An entry will be shown in the report for this test\ntest.todo('unimplemented test')\n```\n\n### test.fails\n\n- **Alias:** `it.fails`\n\nUse `test.fails` to indicate that an assertion will fail explicitly.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\nfunction myAsyncFunc() {\n  return new Promise(resolve => resolve(1))\n}\ntest.fails('fail test', async () => {\n  await expect(myAsyncFunc()).rejects.toBe(1)\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### test.each\n\n- **Alias:** `it.each`\n\n**TIP**\n\nWhile `test.each` is provided for Jest compatibility, Vitest also has [`test.for`](#test-for) with an additional feature to integrate [`TestContext`](../guide/test-context).\n\nUse `test.each` when you need to run the same test with different variables. You can inject parameters with [printf formatting](https://nodejs.org/api/util.html#util_util_format_format_args) in the test name in the order of the test function parameters.\n\n- `%s`: string\n- `%d`: number\n- `%i`: integer\n- `%f`: floating point value\n- `%j`: json\n- `%o`: object\n- `%#`: index of the test case\n- `%%`: single percent sign ('%')\n\nts\n\n``` javascript\ntest.each([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', (a, b, expected) => {\n  expect(a + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, 1) -> 2\n// ✓ add(1, 2) -> 3\n// ✓ add(2, 1) -> 3\n```\n\nYou can also access object properties with `$` prefix, if you are using objects as arguments:\n\nts\n\n``` javascript\ntest.each([\n  { a: 1, b: 1, expected: 2 },\n  { a: 1, b: 2, expected: 3 },\n  { a: 2, b: 1, expected: 3 },\n])('add($a, $b) -> $expected', ({ a, b, expected }) => {\n  expect(a + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, 1) -> 2\n// ✓ add(1, 2) -> 3\n// ✓ add(2, 1) -> 3\n```\n\nYou can also access Object attributes with `.`, if you are using objects as arguments:\n\nts\n\n``` javascript\ntest.each`\na               | b      | expected\n${{ val: 1 }}   | ${'b'} | ${'1b'}\n${{ val: 2 }}   | ${'b'} | ${'2b'}\n${{ val: 3 }}   | ${'b'} | ${'3b'}\n`('add($a.val, $b) -> $expected', ({ a, b, expected }) => {\n  expect(a.val + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, b) -> 1b\n// ✓ add(2, b) -> 2b\n// ✓ add(3, b) -> 3b\n```\n\nStarting from Vitest 0.25.3, you can also use template string table.\n\n- First row should be column names, separated by `|`;\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\nts\n\n``` javascript\ntest.each`\n  a               | b      | expected\n  ${1}            | ${1}   | ${2}\n  ${'a'}          | ${'b'} | ${'ab'}\n  ${[]}           | ${'b'} | ${'b'}\n  ${{}}           | ${'b'} | ${'[object Object]b'}\n  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}\n`('returns $expected when $a is added $b', ({ a, b, expected }) => {\n  expect(a + b).toBe(expected)\n})\n```\n\n**TIP**\n\nVitest processes `$values` with Chai `format` method. If the value is too truncated, you can increase [chaiConfig.truncateThreshold](../config/index#chaiconfig-truncatethreshold) in your config file.\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### test.for\n\n- **Alias:** `it.for`\n\nAlternative of `test.each` to provide [`TestContext`](../guide/test-context).\n\nThe difference from `test.each` is how array case is provided in the arguments. Other non array case (including template string usage) works exactly same.\n\nts\n\n``` javascript\n// `each` spreads array case\ntest.each([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', (a, b, expected) => { \n  expect(a + b).toBe(expected)\n})\n\n// `for` doesn't spread array case\ntest.for([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', ([a, b, expected]) => { \n  expect(a + b).toBe(expected)\n})\n```\n\n2nd argument is [`TestContext`](../guide/test-context) and it can be used for concurrent snapshot, for example,\n\nts\n\n``` javascript\ntest.concurrent.for([\n  [1, 1],\n  [1, 2],\n  [2, 1],\n])('add(%i, %i)', ([a, b], { expect }) => {\n  expect(a + b).matchSnapshot()\n})\n```\n\n## bench\n\n- **Type:** `(name: string | Function, fn: BenchFunction, options?: BenchOptions) => void`\n\n`bench` defines a benchmark. In Vitest terms benchmark is a function that defines a series of operations. Vitest runs this function multiple times to display different performance results.\n\nVitest uses [`tinybench`](https://github.com/tinylibs/tinybench) library under the hood, inheriting all its options that can be used as a third argument.\n\nts\n\n``` javascript\nimport { bench } from 'vitest'\n\nbench('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n}, { time: 1000 })\n```\n\nts\n\n``` javascript\nexport interface Options {\n  /**\n   * time needed for running a benchmark task (milliseconds)\n   * @default 500\n   */\n  time?: number\n\n  /**\n   * number of times that a task should run if even the time option is finished\n   * @default 10\n   */\n  iterations?: number\n\n  /**\n   * function to get the current timestamp in milliseconds\n   */\n  now?: () => number\n\n  /**\n   * An AbortSignal for aborting the benchmark\n   */\n  signal?: AbortSignal\n\n  /**\n   * warmup time (milliseconds)\n   * @default 100ms\n   */\n  warmupTime?: number\n\n  /**\n   * warmup iterations\n   * @default 5\n   */\n  warmupIterations?: number\n\n  /**\n   * setup function to run before each benchmark task (cycle)\n   */\n  setup?: Hook\n\n  /**\n   * teardown function to run after each benchmark task (cycle)\n   */\n  teardown?: Hook\n}\n```\n\n### bench.skip\n\n- **Type:** `(name: string | Function, fn: BenchFunction, options?: BenchOptions) => void`\n\nYou can use `bench.skip` syntax to skip running certain benchmarks.\n\nts\n\n``` javascript\nimport { bench } from 'vitest'\n\nbench.skip('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n})\n```\n\n### bench.only\n\n- **Type:** `(name: string | Function, fn: BenchFunction, options?: BenchOptions) => void`\n\nUse `bench.only` to only run certain benchmarks in a given suite. This is useful when debugging.\n\nts\n\n``` javascript\nimport { bench } from 'vitest'\n\nbench.only('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n})\n```\n\n### bench.todo\n\n- **Type:** `(name: string | Function) => void`\n\nUse `bench.todo` to stub benchmarks to be implemented later.\n\nts\n\n``` javascript\nimport { bench } from 'vitest'\n\nbench.todo('unimplemented test')\n```\n\n## describe\n\nWhen you use `test` or `bench` in the top level of file, they are collected as part of the implicit suite for it. Using `describe` you can define a new suite in the current context, as a set of related tests or benchmarks and other nested suites. A suite lets you organize your tests and benchmarks so reports are more clear.\n\nts\n\n``` javascript\n// basic.spec.ts\n// organizing tests\n\nimport { describe, expect, test } from 'vitest'\n\nconst person = {\n  isActive: true,\n  age: 32,\n}\n\ndescribe('person', () => {\n  test('person is defined', () => {\n    expect(person).toBeDefined()\n  })\n\n  test('is active', () => {\n    expect(person.isActive).toBeTruthy()\n  })\n\n  test('age limit', () => {\n    expect(person.age).toBeLessThanOrEqual(32)\n  })\n})\n```\n\nts\n\n``` javascript\n// basic.bench.ts\n// organizing benchmarks\n\nimport { bench, describe } from 'vitest'\n\ndescribe('sort', () => {\n  bench('normal', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.sort((a, b) => {\n      return a - b\n    })\n  })\n\n  bench('reverse', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.reverse().sort((a, b) => {\n      return a - b\n    })\n  })\n})\n```\n\nYou can also nest describe blocks if you have a hierarchy of tests or benchmarks:\n\nts\n\n``` javascript\nimport { describe, expect, test } from 'vitest'\n\nfunction numberToCurrency(value: number | string) {\n  if (typeof value !== 'number') {\n    throw new TypeError('Value must be a number')\n  }\n\n  return value.toFixed(2).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n}\n\ndescribe('numberToCurrency', () => {\n  describe('given an invalid number', () => {\n    test('composed of non-numbers to throw error', () => {\n      expect(() => numberToCurrency('abc')).toThrowError()\n    })\n  })\n\n  describe('given a valid number', () => {\n    test('returns the correct currency format', () => {\n      expect(numberToCurrency(10000)).toBe('10,000.00')\n    })\n  })\n})\n```\n\n### describe.skip\n\n- **Alias:** `suite.skip`\n\nUse `describe.skip` in a suite to avoid running a particular describe block.\n\nts\n\n``` javascript\nimport { assert, describe, test } from 'vitest'\n\ndescribe.skip('skipped suite', () => {\n  test('sqrt', () => {\n    // Suite skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n```\n\n### describe.skipIf\n\n- **Alias:** `suite.skipIf`\n\nIn some cases, you might run suites multiple times with different environments, and some of the suites might be environment-specific. Instead of wrapping the suite with `if`, you can use `describe.skipIf` to skip the suite whenever the condition is truthy.\n\nts\n\n``` javascript\nimport { describe, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ndescribe.skipIf(isDev)('prod only test suite', () => {\n  // this test suite only runs in production\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax when using Vitest as [type checker](../guide/testing-types).\n\n### describe.runIf\n\n- **Alias:** `suite.runIf`\n\nOpposite of [describe.skipIf](#describe-skipif).\n\nts\n\n``` javascript\nimport { assert, describe, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ndescribe.runIf(isDev)('dev only test suite', () => {\n  // this test suite only runs in development\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### describe.only\n\n- **Type:** `(name: string | Function, fn: TestFunction, options?: number | TestOptions) => void`\n\nUse `describe.only` to only run certain suites\n\nts\n\n``` javascript\n// Only this suite (and others marked with only) are run\ndescribe.only('suite', () => {\n  test('sqrt', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('other suite', () => {\n  // ... will be skipped\n})\n```\n\nSometimes it is very useful to run `only` tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.\n\nIn order to do that run `vitest` with specific file containing the tests in question.\n\n``` javascript\n# vitest interesting.test.ts\n```\n\n### describe.concurrent\n\n- **Alias:** `suite.concurrent`\n\n`describe.concurrent` runs all inner suites and tests in parallel\n\nts\n\n``` javascript\n// All suites and tests within this suite will be run in parallel\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  describe('concurrent suite 2', async () => {\n    test('concurrent test inner 1', async () => { /* ... */ })\n    test('concurrent test inner 2', async () => { /* ... */ })\n  })\n  test.concurrent('concurrent test 3', async () => { /* ... */ })\n})\n```\n\n`.skip`, `.only`, and `.todo` works with concurrent suites. All the following combinations are valid:\n\nts\n\n``` javascript\ndescribe.concurrent(/* ... */)\ndescribe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)\ndescribe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)\ndescribe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)\n```\n\nWhen running concurrent tests, Snapshots and Assertions must use `expect` from the local [Test Context](../guide/test-context) to ensure the right test is detected.\n\nts\n\n``` javascript\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async ({ expect }) => {\n    expect(foo).toMatchSnapshot()\n  })\n  test('concurrent test 2', async ({ expect }) => {\n    expect(foo).toMatchSnapshot()\n  })\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### describe.sequential\n\n- **Alias:** `suite.sequential`\n\n`describe.sequential` in a suite marks every test as sequential. This is useful if you want to run tests in sequence within `describe.concurrent` or with the `--sequence.concurrent` command option.\n\nts\n\n``` javascript\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n\n  describe.sequential('', () => {\n    test('sequential test 1', async () => { /* ... */ })\n    test('sequential test 2', async () => { /* ... */ })\n  })\n})\n```\n\n### describe.shuffle\n\n- **Alias:** `suite.shuffle`\n\nVitest provides a way to run all tests in random order via CLI flag [`--sequence.shuffle`](../guide/cli) or config option [`sequence.shuffle`](../config/index#sequence-shuffle), but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag.\n\nts\n\n``` javascript\ndescribe.shuffle('suite', () => {\n  test('random test 1', async () => { /* ... */ })\n  test('random test 2', async () => { /* ... */ })\n  test('random test 3', async () => { /* ... */ })\n})\n// order depends on sequence.seed option in config (Date.now() by default)\n```\n\n`.skip`, `.only`, and `.todo` works with random suites.\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n### describe.todo\n\n- **Alias:** `suite.todo`\n\nUse `describe.todo` to stub suites to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.\n\nts\n\n``` javascript\n// An entry will be shown in the report for this suite\ndescribe.todo('unimplemented suite')\n```\n\n### describe.each\n\n- **Alias:** `suite.each`\n\nUse `describe.each` if you have more than one test that depends on the same data.\n\nts\n\n``` javascript\ndescribe.each([\n  { a: 1, b: 1, expected: 2 },\n  { a: 1, b: 2, expected: 3 },\n  { a: 2, b: 1, expected: 3 },\n])('describe object add($a, $b)', ({ a, b, expected }) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected)\n  })\n\n  test(`returned value not be greater than ${expected}`, () => {\n    expect(a + b).not.toBeGreaterThan(expected)\n  })\n\n  test(`returned value not be less than ${expected}`, () => {\n    expect(a + b).not.toBeLessThan(expected)\n  })\n})\n```\n\nStarting from Vitest 0.25.3, you can also use template string table.\n\n- First row should be column names, separated by `|`;\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\nts\n\n``` javascript\ndescribe.each`\n  a               | b      | expected\n  ${1}            | ${1}   | ${2}\n  ${'a'}          | ${'b'} | ${'ab'}\n  ${[]}           | ${'b'} | ${'b'}\n  ${{}}           | ${'b'} | ${'[object Object]b'}\n  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}\n`('describe template string add($a, $b)', ({ a, b, expected }) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected)\n  })\n})\n```\n\n**WARNING**\n\nYou cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).\n\n## Setup and Teardown\n\nThese functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code. They apply to the current context: the file if they are used at the top-level or the current suite if they are inside a `describe` block. These hooks are not called, when you are running Vitest as a type checker.\n\n### beforeEach\n\n- **Type:** `beforeEach(fn: () => Awaitable<void>, timeout?: number)`\n\nRegister a callback to be called before each of the tests in the current context runs. If the function returns a promise, Vitest waits until the promise resolve before running the test.\n\nOptionally, you can pass a timeout (in milliseconds) defining how long to wait before terminating. The default is 5 seconds.\n\nts\n\n``` javascript\nimport { beforeEach } from 'vitest'\n\nbeforeEach(async () => {\n  // Clear mocks and add some testing data after before each test run\n  await stopMocking()\n  await addUser({ name: 'John' })\n})\n```\n\nHere, the `beforeEach` ensures that user is added for each test.\n\n`beforeEach` also accepts an optional cleanup function (equivalent to `afterEach`).\n\nts\n\n``` javascript\nimport { beforeEach } from 'vitest'\n\nbeforeEach(async () => {\n  // called once before each test run\n  await prepareSomething()\n\n  // clean up function, called once after each test run\n  return async () => {\n    await resetSomething()\n  }\n})\n```\n\n### afterEach\n\n- **Type:** `afterEach(fn: () => Awaitable<void>, timeout?: number)`\n\nRegister a callback to be called after each one of the tests in the current context completes. If the function returns a promise, Vitest waits until the promise resolve before continuing.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\n\n``` javascript\nimport { afterEach } from 'vitest'\n\nafterEach(async () => {\n  await clearTestingData() // clear testing data after each test run\n})\n```\n\nHere, the `afterEach` ensures that testing data is cleared after each test runs.\n\n**TIP**\n\nVitest 1.3.0 added [`onTestFinished`](#ontestfinished) hook. You can call it during the test execution to cleanup any state after the test has finished running.\n\n### beforeAll\n\n- **Type:** `beforeAll(fn: () => Awaitable<void>, timeout?: number)`\n\nRegister a callback to be called once before starting to run all tests in the current context. If the function returns a promise, Vitest waits until the promise resolve before running tests.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\n\n``` javascript\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => {\n  await startMocking() // called once before all tests run\n})\n```\n\nHere the `beforeAll` ensures that the mock data is set up before tests run.\n\n`beforeAll` also accepts an optional cleanup function (equivalent to `afterAll`).\n\nts\n\n``` javascript\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => {\n  // called once before all tests run\n  await startMocking()\n\n  // clean up function, called once after all tests run\n  return async () => {\n    await stopMocking()\n  }\n})\n```\n\n### afterAll\n\n- **Type:** `afterAll(fn: () => Awaitable<void>, timeout?: number)`\n\nRegister a callback to be called once after all tests have run in the current context. If the function returns a promise, Vitest waits until the promise resolve before continuing.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\n\n``` javascript\nimport { afterAll } from 'vitest'\n\nafterAll(async () => {\n  await stopMocking() // this method is called after all tests run\n})\n```\n\nHere the `afterAll` ensures that `stopMocking` method is called after all tests run.\n\n## Test Hooks\n\nVitest provides a few hooks that you can call *during* the test execution to cleanup the state when the test has finished runnning.\n\n**WARNING**\n\nThese hooks will throw an error if they are called outside of the test body.\n\n### onTestFinished\n\nThis hook is always called after the test has finished running. It is called after `afterEach` hooks since they can influence the test result. It receives a `TaskResult` object with the current test result.\n\nts\n\n``` javascript\nimport { onTestFinished, test } from 'vitest'\n\ntest('performs a query', () => {\n  const db = connectDb()\n  onTestFinished(() => db.close())\n  db.query('SELECT * FROM users')\n})\n```\n\n**WARNING**\n\nIf you are running tests concurrently, you should always use `onTestFinished` hook from the test context since Vitest doesn't track concurrent tests in global hooks:\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest.concurrent('performs a query', ({ onTestFinished }) => {\n  const db = connectDb()\n  onTestFinished(() => db.close())\n  db.query('SELECT * FROM users')\n})\n```\n\nThis hook is particularly useful when creating reusable logic:\n\nts\n\n``` javascript\n// this can be in a separate file\nfunction getTestDb() {\n  const db = connectMockedDb()\n  onTestFinished(() => db.close())\n  return db\n}\n\ntest('performs a user query', async () => {\n  const db = getTestDb()\n  expect(\n    await db.query('SELECT * from users').perform()\n  ).toEqual([])\n})\n\ntest('performs an organization query', async () => {\n  const db = getTestDb()\n  expect(\n    await db.query('SELECT * from organizations').perform()\n  ).toEqual([])\n})\n```\n\n**TIP**\n\nThis hook is always called in reverse order and is not affected by [`sequence.hooks`](../config/index#sequence-hooks) option.\n\n### onTestFailed\n\nThis hook is called only after the test has failed. It is called after `afterEach` hooks since they can influence the test result. It receives a `TaskResult` object with the current test result. This hook is useful for debugging.\n\nts\n\n``` javascript\nimport { onTestFailed, test } from 'vitest'\n\ntest('performs a query', () => {\n  const db = connectDb()\n  onTestFailed((e) => {\n    console.log(e.result.errors)\n  })\n  db.query('SELECT * FROM users')\n})\n```\n\n**WARNING**\n\nIf you are running tests concurrently, you should always use `onTestFailed` hook from the test context since Vitest doesn't track concurrent tests in global hooks:\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest.concurrent('performs a query', ({ onTestFailed }) => {\n  const db = connectDb()\n  onTestFailed((result) => {\n    console.log(result.errors)\n  })\n  db.query('SELECT * FROM users')\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/](https://vitest.dev/api/)"
- name: Test Context
  id: guide/test-context
  summary: Inspired by Playwright Fixtures, Vitest's test context allows you to define utils, states, and fixtures that can be used in your tests
  description: "# Test Context\n\nInspired by [Playwright Fixtures](https://playwright.dev/docs/test-fixtures), Vitest's test context allows you to define utils, states, and fixtures that can be used in your tests.\n\n## Usage\n\nThe first argument for each test callback is a test context.\n\nts\n\n``` javascript\nimport { it } from 'vitest'\n\nit('should work', (ctx) => {\n  // prints name of the test\n  console.log(ctx.task.name)\n})\n```\n\n## Built-in Test Context\n\n#### `context.task`\n\nA readonly object containing metadata about the test.\n\n#### `context.expect`\n\nThe `expect` API bound to the current test:\n\nts\n\n``` javascript\nimport { it } from 'vitest'\n\nit('math is easy', ({ expect }) => {\n  expect(2 + 2).toBe(4)\n})\n```\n\nThis API is useful for running snapshot tests concurrently because global expect cannot track them:\n\nts\n\n``` javascript\nimport { it } from 'vitest'\n\nit.concurrent('math is easy', ({ expect }) => {\n  expect(2 + 2).toMatchInlineSnapshot()\n})\n\nit.concurrent('math is hard', ({ expect }) => {\n  expect(2 * 2).toMatchInlineSnapshot()\n})\n```\n\n#### `context.skip`\n\nSkips subsequent test execution and marks test as skipped:\n\nts\n\n``` javascript\nimport { expect, it } from 'vitest'\n\nit('math is hard', ({ skip }) => {\n  skip()\n  expect(2 + 2).toBe(5)\n})\n```\n\n## Extend Test Context\n\nVitest provides two different ways to help you extend the test context.\n\n### `test.extend`\n\nLike [Playwright](https://playwright.dev/docs/api/class-test#test-extend), you can use this method to define your own `test` API with custom fixtures and reuse it anywhere.\n\nFor example, we first create `myTest` with two fixtures, `todos` and `archive`.\n\nts\n\n``` javascript\n// my-test.ts\nimport { test } from 'vitest'\n\nconst todos = []\nconst archive = []\n\nexport const myTest = test.extend({\n  todos: async ({}, use) => {\n    // setup the fixture before each test function\n    todos.push(1, 2, 3)\n\n    // use the fixture value\n    await use(todos)\n\n    // cleanup the fixture after each test function\n    todos.length = 0\n  },\n  archive\n})\n```\n\nThen we can import and use it.\n\nts\n\n``` javascript\nimport { expect } from 'vitest'\nimport { myTest } from './my-test.js'\n\nmyTest('add items to todos', ({ todos }) => {\n  expect(todos.length).toBe(3)\n\n  todos.push(4)\n  expect(todos.length).toBe(4)\n})\n\nmyTest('move items from todos to archive', ({ todos, archive }) => {\n  expect(todos.length).toBe(3)\n  expect(archive.length).toBe(0)\n\n  archive.push(todos.pop())\n  expect(todos.length).toBe(2)\n  expect(archive.length).toBe(1)\n})\n```\n\nWe can also add more fixtures or override existing fixtures by extending `myTest`.\n\nts\n\n``` javascript\nexport const myTest2 = myTest.extend({\n  settings: {\n    // ...\n  }\n})\n```\n\n#### Fixture initialization\n\nVitest runner will smartly initialize your fixtures and inject them into the test context based on usage.\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\nasync function todosFn({ task }, use) {\n  await use([1, 2, 3])\n}\n\nconst myTest = test.extend({\n  todos: todosFn,\n  archive: []\n})\n\n// todosFn will not run\nmyTest('', () => {})\nmyTest('', ({ archive }) => {})\n\n// todosFn will run\nmyTest('', ({ todos }) => {})\n```\n\n**WARNING**\n\nWhen using `test.extend()` with fixtures, you should always use the object destructuring pattern `{ todos }` to access context both in fixture function and test function.\n\n#### Automatic fixture\n\nVitest also supports the tuple syntax for fixtures, allowing you to pass options for each fixture. For example, you can use it to explicitly initialize a fixture, even if it's not being used in tests.\n\nts\n\n``` javascript\nimport { test as base } from 'vitest'\n\nconst test = base.extend({\n  fixture: [\n    async ({}, use) => {\n      // this function will run\n      setup()\n      await use()\n      teardown()\n    },\n    { auto: true } // Mark as an automatic fixture\n  ],\n})\n\ntest('', () => {})\n```\n\n#### TypeScript\n\nTo provide fixture types for all your custom contexts, you can pass the fixtures type as a generic.\n\nts\n\n``` javascript\ninterface MyFixtures {\n  todos: number[]\n  archive: number[]\n}\n\nconst myTest = test.extend<MyFixtures>({\n  todos: [],\n  archive: []\n})\n\nmyTest('', (context) => {\n  expectTypeOf(context.todos).toEqualTypeOf<number[]>()\n  expectTypeOf(context.archive).toEqualTypeOf<number[]>()\n})\n```\n\n### `beforeEach` and `afterEach`\n\nThe contexts are different for each test. You can access and extend them within the `beforeEach` and `afterEach` hooks.\n\nts\n\n``` javascript\nimport { beforeEach, it } from 'vitest'\n\nbeforeEach(async (context) => {\n  // extend context\n  context.foo = 'bar'\n})\n\nit('should work', ({ foo }) => {\n  console.log(foo) // 'bar'\n})\n```\n\n#### TypeScript\n\nTo provide property types for all your custom contexts, you can aggregate the `TestContext` type by adding\n\nts\n\n``` javascript\ndeclare module 'vitest' {\n  export interface TestContext {\n    foo?: string\n  }\n}\n```\n\nIf you want to provide property types only for specific `beforeEach`, `afterEach`, `it` and `test` hooks, you can pass the type as a generic.\n\nts\n\n``` javascript\ninterface LocalTestContext {\n  foo: string\n}\n\nbeforeEach<LocalTestContext>(async (context) => {\n  // typeof context is 'TestContext & LocalTestContext'\n  context.foo = 'bar'\n})\n\nit<LocalTestContext>('should work', ({ foo }) => {\n  // typeof foo is 'string'\n  console.log(foo) // 'bar'\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/test-context](https://vitest.dev/guide/test-context)"
- name: 'Test Context: beforeEach and afterEach ​'
  id: guide/test-context#beforeeach-and-aftereach
  summary: The contexts are different for each test
  belongs_to: Test Context
  description: "### `beforeEach` and `afterEach`\n\nThe contexts are different for each test. You can access and extend them within the `beforeEach` and `afterEach` hooks.\n\nts\n\n``` javascript\nimport { beforeEach, it } from 'vitest'\n\nbeforeEach(async (context) => {\n  // extend context\n  context.foo = 'bar'\n})\n\nit('should work', ({ foo }) => {\n  console.log(foo) // 'bar'\n})\n```\n\n#### TypeScript\n\nTo provide property types for all your custom contexts, you can aggregate the `TestContext` type by adding\n\nts\n\n``` javascript\ndeclare module 'vitest' {\n  export interface TestContext {\n    foo?: string\n  }\n}\n```\n\nIf you want to provide property types only for specific `beforeEach`, `afterEach`, `it` and `test` hooks, you can pass the type as a generic.\n\nts\n\n``` javascript\ninterface LocalTestContext {\n  foo: string\n}\n\nbeforeEach<LocalTestContext>(async (context) => {\n  // typeof context is 'TestContext & LocalTestContext'\n  context.foo = 'bar'\n})\n\nit<LocalTestContext>('should work', ({ foo }) => {\n  // typeof foo is 'string'\n  console.log(foo) // 'bar'\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/test-context](https://vitest.dev/guide/test-context)"
- name: 'Test Context: Built-in Test Context ​'
  id: guide/test-context#built-in-test-context
  summary: A readonly object containing metadata about the test
  belongs_to: Test Context
  description: |-
    ## Built-in Test Context

    #### `context.task`

    A readonly object containing metadata about the test.

    #### `context.expect`

    The `expect` API bound to the current test:

    ts

    ``` javascript
    import { it } from 'vitest'

    it('math is easy', ({ expect }) => {
      expect(2 + 2).toBe(4)
    })
    ```

    This API is useful for running snapshot tests concurrently because global expect cannot track them:

    ts

    ``` javascript
    import { it } from 'vitest'

    it.concurrent('math is easy', ({ expect }) => {
      expect(2 + 2).toMatchInlineSnapshot()
    })

    it.concurrent('math is hard', ({ expect }) => {
      expect(2 * 2).toMatchInlineSnapshot()
    })
    ```

    #### `context.skip`

    Skips subsequent test execution and marks test as skipped:

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('math is hard', ({ skip }) => {
      skip()
      expect(2 + 2).toBe(5)
    })
    ```
- name: 'Test Context: Extend Test Context ​'
  id: guide/test-context#extend-test-context
  summary: Vitest provides two different ways to help you extend the test context
  belongs_to: Test Context
  description: |-
    ## Extend Test Context

    Vitest provides two different ways to help you extend the test context.
- name: 'Test Context: test.extend ​'
  id: guide/test-context#test-extend
  summary: Like Playwright, you can use this method to define your own test API with custom fixtures and reuse it anywhere
  belongs_to: Test Context
  description: |-
    ### `test.extend`

    Like [Playwright](https://playwright.dev/docs/api/class-test#test-extend), you can use this method to define your own `test` API with custom fixtures and reuse it anywhere.

    For example, we first create `myTest` with two fixtures, `todos` and `archive`.

    ts

    ``` javascript
    // my-test.ts
    import { test } from 'vitest'

    const todos = []
    const archive = []

    export const myTest = test.extend({
      todos: async ({}, use) => {
        // setup the fixture before each test function
        todos.push(1, 2, 3)

        // use the fixture value
        await use(todos)

        // cleanup the fixture after each test function
        todos.length = 0
      },
      archive
    })
    ```

    Then we can import and use it.

    ts

    ``` javascript
    import { expect } from 'vitest'
    import { myTest } from './my-test.js'

    myTest('add items to todos', ({ todos }) => {
      expect(todos.length).toBe(3)

      todos.push(4)
      expect(todos.length).toBe(4)
    })

    myTest('move items from todos to archive', ({ todos, archive }) => {
      expect(todos.length).toBe(3)
      expect(archive.length).toBe(0)

      archive.push(todos.pop())
      expect(todos.length).toBe(2)
      expect(archive.length).toBe(1)
    })
    ```

    We can also add more fixtures or override existing fixtures by extending `myTest`.

    ts

    ``` javascript
    export const myTest2 = myTest.extend({
      settings: {
        // ...
      }
    })
    ```

    #### Fixture initialization

    Vitest runner will smartly initialize your fixtures and inject them into the test context based on usage.

    ts

    ``` javascript
    import { test } from 'vitest'

    async function todosFn({ task }, use) {
      await use([1, 2, 3])
    }

    const myTest = test.extend({
      todos: todosFn,
      archive: []
    })

    // todosFn will not run
    myTest('', () => {})
    myTest('', ({ archive }) => {})

    // todosFn will run
    myTest('', ({ todos }) => {})
    ```

    **WARNING**

    When using `test.extend()` with fixtures, you should always use the object destructuring pattern `{ todos }` to access context both in fixture function and test function.

    #### Automatic fixture

    Vitest also supports the tuple syntax for fixtures, allowing you to pass options for each fixture. For example, you can use it to explicitly initialize a fixture, even if it's not being used in tests.

    ts

    ``` javascript
    import { test as base } from 'vitest'

    const test = base.extend({
      fixture: [
        async ({}, use) => {
          // this function will run
          setup()
          await use()
          teardown()
        },
        { auto: true } // Mark as an automatic fixture
      ],
    })

    test('', () => {})
    ```

    #### TypeScript

    To provide fixture types for all your custom contexts, you can pass the fixtures type as a generic.

    ts

    ``` javascript
    interface MyFixtures {
      todos: number[]
      archive: number[]
    }

    const myTest = test.extend<MyFixtures>({
      todos: [],
      archive: []
    })

    myTest('', (context) => {
      expectTypeOf(context.todos).toEqualTypeOf<number[]>()
      expectTypeOf(context.archive).toEqualTypeOf<number[]>()
    })
    ```
- name: 'Test Context: Usage ​'
  id: guide/test-context#usage
  summary: The first argument for each test callback is a test context
  belongs_to: Test Context
  description: |-
    ## Usage

    The first argument for each test callback is a test context.

    ts

    ``` javascript
    import { it } from 'vitest'

    it('should work', (ctx) => {
      // prints name of the test
      console.log(ctx.task.name)
    })
    ```
- name: Test Environment
  id: guide/environment
  summary: Vitest provides environment option to run code inside a specific environment
  description: "# Test Environment\n\nVitest provides [`environment`](../config/index#environment) option to run code inside a specific environment. You can modify how environment behaves with [`environmentOptions`](../config/index#environmentoptions) option.\n\nBy default, you can use these environments:\n\n- `node` is default environment\n- `jsdom` emulates browser environment by providing Browser API, uses [`jsdom`](https://github.com/jsdom/jsdom) package\n- `happy-dom` emulates browser environment by providing Browser API, and considered to be faster than jsdom, but lacks some API, uses [`happy-dom`](https://github.com/capricorn86/happy-dom) package\n- `edge-runtime` emulates Vercel's [edge-runtime](https://edge-runtime.vercel.app/), uses [`@edge-runtime/vm`](https://www.npmjs.com/package/@edge-runtime/vm) package\n\n## Environments for Specific Files\n\nWhen setting `environment` option in your config, it will apply to all the test files in your project. To have more fine-grained control, you can use control comments to specify environment for specific files. Control comments are comments that start with `@vitest-environment` and are followed by the environment name:\n\nts\n\n``` javascript\n// @vitest-environment jsdom\n\nimport { expect, test } from 'vitest'\n\ntest('test', () => {\n  expect(typeof window).not.toBe('undefined')\n})\n```\n\nOr you can also set [`environmentMatchGlobs`](../config/index#environmentmatchglobs) option specifying the environment based on the glob patterns.\n\n## Custom Environment\n\nYou can create your own package to extend Vitest environment. To do so, create package with the name `vitest-environment-${name}` or specify a path to a valid JS/TS file. That package should export an object with the shape of `Environment`:\n\nts\n\n``` javascript\nimport type { Environment } from 'vitest'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  // optional - only if you support \"experimental-vm\" pool\n  async setupVM() {\n    const vm = await import('node:vm')\n    const context = vm.createContext()\n    return {\n      getVmContext() {\n        return context\n      },\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  },\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n```\n\n**WARNING**\n\nVitest requires `transformMode` option on environment object. It should be equal to `ssr` or `web`. This value determines how plugins will transform source code. If it's set to `ssr`, plugin hooks will receive `ssr: true` when transforming or resolving files. Otherwise, `ssr` is set to `false`.\n\nYou also have access to default Vitest environments through `vitest/environments` entry:\n\nts\n\n``` javascript\nimport { builtinEnvironments, populateGlobal } from 'vitest/environments'\n\nconsole.log(builtinEnvironments) // { jsdom, happy-dom, node, edge-runtime }\n```\n\nVitest also provides `populateGlobal` utility function, which can be used to move properties from object into the global namespace:\n\nts\n\n``` javascript\ninterface PopulateOptions {\n  // should non-class functions be bind to the global namespace\n  bindFunctions?: boolean\n}\n\ninterface PopulateResult {\n  // a list of all keys that were copied, even if value doesn't exist on original object\n  keys: Set<string>\n  // a map of original object that might have been overridden with keys\n  // you can return these values inside `teardown` function\n  originals: Map<string | symbol, any>\n}\n\nexport function populateGlobal(global: any, original: any, options: PopulateOptions): PopulateResult\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/environment](https://vitest.dev/guide/environment)"
- name: 'Test Environment: Custom Environment ​'
  id: guide/environment#custom-environment
  summary: You can create your own package to extend Vitest environment
  belongs_to: Test Environment
  description: "## Custom Environment\n\nYou can create your own package to extend Vitest environment. To do so, create package with the name `vitest-environment-${name}` or specify a path to a valid JS/TS file. That package should export an object with the shape of `Environment`:\n\nts\n\n``` javascript\nimport type { Environment } from 'vitest'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  // optional - only if you support \"experimental-vm\" pool\n  async setupVM() {\n    const vm = await import('node:vm')\n    const context = vm.createContext()\n    return {\n      getVmContext() {\n        return context\n      },\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  },\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n```\n\n**WARNING**\n\nVitest requires `transformMode` option on environment object. It should be equal to `ssr` or `web`. This value determines how plugins will transform source code. If it's set to `ssr`, plugin hooks will receive `ssr: true` when transforming or resolving files. Otherwise, `ssr` is set to `false`.\n\nYou also have access to default Vitest environments through `vitest/environments` entry:\n\nts\n\n``` javascript\nimport { builtinEnvironments, populateGlobal } from 'vitest/environments'\n\nconsole.log(builtinEnvironments) // { jsdom, happy-dom, node, edge-runtime }\n```\n\nVitest also provides `populateGlobal` utility function, which can be used to move properties from object into the global namespace:\n\nts\n\n``` javascript\ninterface PopulateOptions {\n  // should non-class functions be bind to the global namespace\n  bindFunctions?: boolean\n}\n\ninterface PopulateResult {\n  // a list of all keys that were copied, even if value doesn't exist on original object\n  keys: Set<string>\n  // a map of original object that might have been overridden with keys\n  // you can return these values inside `teardown` function\n  originals: Map<string | symbol, any>\n}\n\nexport function populateGlobal(global: any, original: any, options: PopulateOptions): PopulateResult\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/environment](https://vitest.dev/guide/environment)"
- name: 'Test Environment: Environments for Specific Files ​'
  id: guide/environment#environments-for-specific-files
  summary: When setting environment option in your config, it will apply to all the test files in your project
  belongs_to: Test Environment
  description: |-
    ## Environments for Specific Files

    When setting `environment` option in your config, it will apply to all the test files in your project. To have more fine-grained control, you can use control comments to specify environment for specific files. Control comments are comments that start with `@vitest-environment` and are followed by the environment name:

    ts

    ``` javascript
    // @vitest-environment jsdom

    import { expect, test } from 'vitest'

    test('test', () => {
      expect(typeof window).not.toBe('undefined')
    })
    ```

    Or you can also set [`environmentMatchGlobs`](../config/index#environmentmatchglobs) option specifying the environment based on the glob patterns.
- name: Test Filtering
  id: guide/filtering
  summary: Will only execute test files that contain basic, e.g
  description: "# Test Filtering\n\nFiltering, timeouts, concurrent for suite and tests\n\n## CLI\n\nYou can use CLI to filter test files by name:\n\nbash\n\n``` javascript\n$ vitest basic\n```\n\nWill only execute test files that contain `basic`, e.g.\n\n``` javascript\nbasic.test.ts\nbasic-foo.test.ts\nbasic/foo.test.ts\n```\n\nYou can also use the `-t, --testNamePattern <pattern>` option to filter tests by full name. This can be helpful when you want to filter by the name defined within a file rather than the filename itself.\n\n## Specifying a Timeout\n\nYou can optionally pass a timeout in milliseconds as third argument to tests. The default is 5 seconds.\n\nts\n\n``` javascript\nimport { test } from 'vitest'\n\ntest('name', async () => { /* ... */ }, 1000)\n```\n\nHooks also can receive a timeout, with the same 5 seconds default.\n\nts\n\n``` javascript\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => { /* ... */ }, 1000)\n```\n\n## Skipping Suites and Tests\n\nUse `.skip` to avoid running certain suites or tests\n\nts\n\n``` javascript\nimport { assert, describe, it } from 'vitest'\n\ndescribe.skip('skipped suite', () => {\n  it('test', () => {\n    // Suite skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('suite', () => {\n  it.skip('skipped test', () => {\n    // Test skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n```\n\n## Selecting Suites and Tests to Run\n\nUse `.only` to only run certain suites or tests\n\nts\n\n``` javascript\nimport { assert, describe, it } from 'vitest'\n\n// Only this suite (and others marked with only) are run\ndescribe.only('suite', () => {\n  it('test', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('another suite', () => {\n  it('skipped test', () => {\n    // Test skipped, as tests are running in Only mode\n    assert.equal(Math.sqrt(4), 3)\n  })\n\n  it.only('test', () => {\n    // Only this test (and others marked with only) are run\n    assert.equal(Math.sqrt(4), 2)\n  })\n})\n```\n\n## Unimplemented Suites and Tests\n\nUse `.todo` to stub suites and tests that should be implemented\n\nts\n\n``` javascript\nimport { describe, it } from 'vitest'\n\n// An entry will be shown in the report for this suite\ndescribe.todo('unimplemented suite')\n\n// An entry will be shown in the report for this test\ndescribe('suite', () => {\n  it.todo('unimplemented test')\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/filtering](https://vitest.dev/guide/filtering)"
- name: 'Test Filtering: CLI ​'
  id: guide/filtering#cli
  summary: Will only execute test files that contain basic, e.g
  belongs_to: Test Filtering
  description: |-
    ## CLI

    You can use CLI to filter test files by name:

    bash

    ``` javascript
    $ vitest basic
    ```

    Will only execute test files that contain `basic`, e.g.

    ``` javascript
    basic.test.ts
    basic-foo.test.ts
    basic/foo.test.ts
    ```

    You can also use the `-t, --testNamePattern <pattern>` option to filter tests by full name. This can be helpful when you want to filter by the name defined within a file rather than the filename itself.
- name: 'Test Filtering: Selecting Suites and Tests to Run ​'
  id: guide/filtering#selecting-suites-and-tests-to-run
  summary: null
  belongs_to: Test Filtering
  description: |-
    ## Selecting Suites and Tests to Run

    Use `.only` to only run certain suites or tests

    ts

    ``` javascript
    import { assert, describe, it } from 'vitest'

    // Only this suite (and others marked with only) are run
    describe.only('suite', () => {
      it('test', () => {
        assert.equal(Math.sqrt(4), 3)
      })
    })

    describe('another suite', () => {
      it('skipped test', () => {
        // Test skipped, as tests are running in Only mode
        assert.equal(Math.sqrt(4), 3)
      })

      it.only('test', () => {
        // Only this test (and others marked with only) are run
        assert.equal(Math.sqrt(4), 2)
      })
    })
    ```
- name: 'Test Filtering: Skipping Suites and Tests ​'
  id: guide/filtering#skipping-suites-and-tests
  summary: null
  belongs_to: Test Filtering
  description: |-
    ## Skipping Suites and Tests

    Use `.skip` to avoid running certain suites or tests

    ts

    ``` javascript
    import { assert, describe, it } from 'vitest'

    describe.skip('skipped suite', () => {
      it('test', () => {
        // Suite skipped, no error
        assert.equal(Math.sqrt(4), 3)
      })
    })

    describe('suite', () => {
      it.skip('skipped test', () => {
        // Test skipped, no error
        assert.equal(Math.sqrt(4), 3)
      })
    })
    ```
- name: 'Test Filtering: Specifying a Timeout ​'
  id: guide/filtering#specifying-a-timeout
  summary: You can optionally pass a timeout in milliseconds as third argument to tests
  belongs_to: Test Filtering
  description: |-
    ## Specifying a Timeout

    You can optionally pass a timeout in milliseconds as third argument to tests. The default is 5 seconds.

    ts

    ``` javascript
    import { test } from 'vitest'

    test('name', async () => { /* ... */ }, 1000)
    ```

    Hooks also can receive a timeout, with the same 5 seconds default.

    ts

    ``` javascript
    import { beforeAll } from 'vitest'

    beforeAll(async () => { /* ... */ }, 1000)
    ```
- name: 'Test Filtering: Unimplemented Suites and Tests ​'
  id: guide/filtering#unimplemented-suites-and-tests
  summary: © 2021-Present Anthony Fu © 2021-Present Matias Capeletto Licensed under the MIT License
  belongs_to: Test Filtering
  description: "## Unimplemented Suites and Tests\n\nUse `.todo` to stub suites and tests that should be implemented\n\nts\n\n``` javascript\nimport { describe, it } from 'vitest'\n\n// An entry will be shown in the report for this suite\ndescribe.todo('unimplemented suite')\n\n// An entry will be shown in the report for this test\ndescribe('suite', () => {\n  it.todo('unimplemented test')\n})\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/filtering](https://vitest.dev/guide/filtering)"
- name: Test Hooks ​
  id: api/index#test-hooks
  summary: Vitest provides a few hooks that you can call during the test execution to cleanup the state when the test has finished runnning
  belongs_to: Test API Reference
  description: |-
    ## Test Hooks

    Vitest provides a few hooks that you can call *during* the test execution to cleanup the state when the test has finished runnning.

    **WARNING**

    These hooks will throw an error if they are called outside of the test body.
- name: Test Runner
  id: advanced/runner
  summary: This is advanced API
  description: "# Test Runner\n\n**WARNING**\n\nThis is advanced API. If you are just running tests, you probably don't need this. It is primarily used by library authors.\n\nYou can specify a path to your test runner with the `runner` option in your configuration file. This file should have a default export with a class implementing these methods:\n\nts\n\n``` javascript\nexport interface VitestRunner {\n  /**\n   * First thing that's getting called before actually collecting and running tests.\n   */\n  onBeforeCollect?: (paths: string[]) => unknown\n  /**\n   * Called after collecting tests and before \"onBeforeRun\".\n   */\n  onCollected?: (files: File[]) => unknown\n\n  /**\n   * Called when test runner should cancel next test runs.\n   * Runner should listen for this method and mark tests and suites as skipped in\n   * \"onBeforeRunSuite\" and \"onBeforeRunTask\" when called.\n   */\n  onCancel?: (reason: CancelReason) => unknown\n\n  /**\n   * Called before running a single test. Doesn't have \"result\" yet.\n   */\n  onBeforeRunTask?: (test: TaskPopulated) => unknown\n  /**\n   * Called before actually running the test function. Already has \"result\" with \"state\" and \"startTime\".\n   */\n  onBeforeTryTask?: (test: TaskPopulated, options: { retry: number; repeats: number }) => unknown\n  /**\n   * Called after result and state are set.\n   */\n  onAfterRunTask?: (test: TaskPopulated) => unknown\n  /**\n   * Called right after running the test function. Doesn't have new state yet. Will not be called, if the test function throws.\n   */\n  onAfterTryTask?: (test: TaskPopulated, options: { retry: number; repeats: number }) => unknown\n\n  /**\n   * Called before running a single suite. Doesn't have \"result\" yet.\n   */\n  onBeforeRunSuite?: (suite: Suite) => unknown\n  /**\n   * Called after running a single suite. Has state and result.\n   */\n  onAfterRunSuite?: (suite: Suite) => unknown\n\n  /**\n   * If defined, will be called instead of usual Vitest suite partition and handling.\n   * \"before\" and \"after\" hooks will not be ignored.\n   */\n  runSuite?: (suite: Suite) => Promise<void>\n  /**\n   * If defined, will be called instead of usual Vitest handling. Useful, if you have your custom test function.\n   * \"before\" and \"after\" hooks will not be ignored.\n   */\n  runTask?: (test: TaskPopulated) => Promise<void>\n\n  /**\n   * Called, when a task is updated. The same as \"onTaskUpdate\" in a reporter, but this is running in the same thread as tests.\n   */\n  onTaskUpdate?: (task: [string, TaskResult | undefined][]) => Promise<void>\n\n  /**\n   * Called before running all tests in collected paths.\n   */\n  onBeforeRunFiles?: (files: File[]) => unknown\n  /**\n   * Called right after running all tests in collected paths.\n   */\n  onAfterRunFiles?: (files: File[]) => unknown\n  /**\n   * Called when new context for a test is defined. Useful, if you want to add custom properties to the context.\n   * If you only want to define custom context with a runner, consider using \"beforeAll\" in \"setupFiles\" instead.\n   *\n   * This method is called for both \"test\" and \"custom\" handlers.\n   *\n   * @see https://vitest.dev/advanced/runner.html#your-task-function\n   */\n  extendTaskContext?: <T extends Test | Custom>(context: TaskContext<T>) => TaskContext<T>\n  /**\n   * Called, when certain files are imported. Can be called in two situations: when collecting tests and when importing setup files.\n   */\n  importFile: (filepath: string, source: VitestRunnerImportSource) => unknown\n  /**\n   * Publicly available configuration.\n   */\n  config: VitestRunnerConfig\n}\n```\n\nWhen initiating this class, Vitest passes down Vitest config, - you should expose it as a `config` property.\n\n**WARNING**\n\nVitest also injects an instance of `ViteNodeRunner` as `__vitest_executor` property. You can use it to process files in `importFile` method (this is default behavior of `TestRunner` and `BenchmarkRunner`).\n\n`ViteNodeRunner` exposes `executeId` method, which is used to import test files in a Vite-friendly environment. Meaning, it will resolve imports and transform file content at runtime so that Node can understand it.\n\n**TIP**\n\nSnapshot support and some other features depend on the runner. If you don't want to lose it, you can extend your runner from `VitestTestRunner` imported from `vitest/runners`. It also exposes `BenchmarkNodeRunner`, if you want to extend benchmark functionality.\n\n## Your Task Function\n\nYou can extend Vitest task system with your tasks. A task is an object that is part of a suite. It is automatically added to the current suite with a `suite.task` method:\n\njs\n\n``` javascript\n// ./utils/custom.js\nimport { createTaskCollector, getCurrentSuite, setFn } from 'vitest/suite'\n\nexport { describe, beforeAll, afterAll } from 'vitest'\n\n// this function will be called during collection phase:\n// don't call function handler here, add it to suite tasks\n// with \"getCurrentSuite().task()\" method\n// note: createTaskCollector provides support for \"todo\"/\"each\"/...\nexport const myCustomTask = createTaskCollector(\n  function (name, fn, timeout) {\n    getCurrentSuite().task(name, {\n      ...this, // so \"todo\"/\"skip\"/... is tracked correctly\n      meta: {\n        customPropertyToDifferentiateTask: true\n      },\n      handler: fn,\n      timeout,\n    })\n  }\n)\n```\n\njs\n\n``` javascript\n// ./garden/tasks.test.js\nimport { afterAll, beforeAll, describe, myCustomTask } from '../custom.js'\nimport { gardener } from './gardener.js'\n\ndescribe('take care of the garden', () => {\n  beforeAll(() => {\n    gardener.putWorkingClothes()\n  })\n\n  myCustomTask('weed the grass', () => {\n    gardener.weedTheGrass()\n  })\n  myCustomTask.todo('mow the lawn', () => {\n    gardener.mowerTheLawn()\n  })\n  myCustomTask('water flowers', () => {\n    gardener.waterFlowers()\n  })\n\n  afterAll(() => {\n    gardener.goHome()\n  })\n})\n```\n\nbash\n\n``` javascript\nvitest ./garden/tasks.test.js\n```\n\n**WARNING**\n\nIf you don't have a custom runner or didn't define `runTest` method, Vitest will try to retrieve a task automatically. If you didn't add a function with `setFn`, it will fail.\n\n**TIP**\n\nCustom task system supports hooks and contexts. If you want to support property chaining (like, `only`, `skip`, and your custom ones), you can import `createChainable` from `vitest/suite` and wrap your function with it. You will need to call `custom` as `custom.call(this)`, if you decide to do this.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/runner](https://vitest.dev/advanced/runner)"
- name: 'Test Runner: Your Task Function ​'
  id: advanced/runner#your-task-function
  summary: You can extend Vitest task system with your tasks
  belongs_to: Test Runner
  description: "## Your Task Function\n\nYou can extend Vitest task system with your tasks. A task is an object that is part of a suite. It is automatically added to the current suite with a `suite.task` method:\n\njs\n\n``` javascript\n// ./utils/custom.js\nimport { createTaskCollector, getCurrentSuite, setFn } from 'vitest/suite'\n\nexport { describe, beforeAll, afterAll } from 'vitest'\n\n// this function will be called during collection phase:\n// don't call function handler here, add it to suite tasks\n// with \"getCurrentSuite().task()\" method\n// note: createTaskCollector provides support for \"todo\"/\"each\"/...\nexport const myCustomTask = createTaskCollector(\n  function (name, fn, timeout) {\n    getCurrentSuite().task(name, {\n      ...this, // so \"todo\"/\"skip\"/... is tracked correctly\n      meta: {\n        customPropertyToDifferentiateTask: true\n      },\n      handler: fn,\n      timeout,\n    })\n  }\n)\n```\n\njs\n\n``` javascript\n// ./garden/tasks.test.js\nimport { afterAll, beforeAll, describe, myCustomTask } from '../custom.js'\nimport { gardener } from './gardener.js'\n\ndescribe('take care of the garden', () => {\n  beforeAll(() => {\n    gardener.putWorkingClothes()\n  })\n\n  myCustomTask('weed the grass', () => {\n    gardener.weedTheGrass()\n  })\n  myCustomTask.todo('mow the lawn', () => {\n    gardener.mowerTheLawn()\n  })\n  myCustomTask('water flowers', () => {\n    gardener.waterFlowers()\n  })\n\n  afterAll(() => {\n    gardener.goHome()\n  })\n})\n```\n\nbash\n\n``` javascript\nvitest ./garden/tasks.test.js\n```\n\n**WARNING**\n\nIf you don't have a custom runner or didn't define `runTest` method, Vitest will try to retrieve a task automatically. If you didn't add a function with `setFn`, it will fail.\n\n**TIP**\n\nCustom task system supports hooks and contexts. If you want to support property chaining (like, `only`, `skip`, and your custom ones), you can import `createChainable` from `vitest/suite` and wrap your function with it. You will need to call `custom` as `custom.call(this)`, if you decide to do this.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/advanced/runner](https://vitest.dev/advanced/runner)"
- name: test ​
  id: api/index#test
  summary: test defines a set of related expectations
  belongs_to: Test API Reference
  description: |-
    ## test

    - **Alias:** `it`

    `test` defines a set of related expectations. It receives the test name and a function that holds the expectations to test.

    Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with [testTimeout](../config/index#testtimeout)

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('should work as expected', () => {
      expect(Math.sqrt(4)).toBe(2)
    })
    ```
- name: test.concurrent ​
  id: api/index#test-concurrent
  summary: test.concurrent marks consecutive tests to be run in parallel
  belongs_to: Test API Reference
  description: |-
    ### test.concurrent

    - **Alias:** `it.concurrent`

    `test.concurrent` marks consecutive tests to be run in parallel. It receives the test name, an async function with the tests to collect, and an optional timeout (in milliseconds).

    ts

    ``` javascript
    import { describe, test } from 'vitest'

    // The two tests marked with concurrent will be run in parallel
    describe('suite', () => {
      test('serial test', async () => { /* ... */ })
      test.concurrent('concurrent test 1', async () => { /* ... */ })
      test.concurrent('concurrent test 2', async () => { /* ... */ })
    })
    ```

    `test.skip`, `test.only`, and `test.todo` works with concurrent tests. All the following combinations are valid:

    ts

    ``` javascript
    test.concurrent(/* ... */)
    test.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)
    test.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)
    test.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)
    ```

    When running concurrent tests, Snapshots and Assertions must use `expect` from the local [Test Context](../guide/test-context) to ensure the right test is detected.

    ts

    ``` javascript
    test.concurrent('test 1', async ({ expect }) => {
      expect(foo).toMatchSnapshot()
    })
    test.concurrent('test 2', async ({ expect }) => {
      expect(foo).toMatchSnapshot()
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: test.each ​
  id: api/index#test-each
  summary: While test.each is provided for Jest compatibility, Vitest also has test.for with an additional feature to integrate TestContext
  belongs_to: Test API Reference
  description: |-
    ### test.each

    - **Alias:** `it.each`

    **TIP**

    While `test.each` is provided for Jest compatibility, Vitest also has [`test.for`](#test-for) with an additional feature to integrate [`TestContext`](../guide/test-context).

    Use `test.each` when you need to run the same test with different variables. You can inject parameters with [printf formatting](https://nodejs.org/api/util.html#util_util_format_format_args) in the test name in the order of the test function parameters.

    - `%s`: string
    - `%d`: number
    - `%i`: integer
    - `%f`: floating point value
    - `%j`: json
    - `%o`: object
    - `%#`: index of the test case
    - `%%`: single percent sign ('%')

    ts

    ``` javascript
    test.each([
      [1, 1, 2],
      [1, 2, 3],
      [2, 1, 3],
    ])('add(%i, %i) -> %i', (a, b, expected) => {
      expect(a + b).toBe(expected)
    })

    // this will return
    // ✓ add(1, 1) -> 2
    // ✓ add(1, 2) -> 3
    // ✓ add(2, 1) -> 3
    ```

    You can also access object properties with `$` prefix, if you are using objects as arguments:

    ts

    ``` javascript
    test.each([
      { a: 1, b: 1, expected: 2 },
      { a: 1, b: 2, expected: 3 },
      { a: 2, b: 1, expected: 3 },
    ])('add($a, $b) -> $expected', ({ a, b, expected }) => {
      expect(a + b).toBe(expected)
    })

    // this will return
    // ✓ add(1, 1) -> 2
    // ✓ add(1, 2) -> 3
    // ✓ add(2, 1) -> 3
    ```

    You can also access Object attributes with `.`, if you are using objects as arguments:

    ts

    ``` javascript
    test.each`
    a               | b      | expected
    ${{ val: 1 }}   | ${'b'} | ${'1b'}
    ${{ val: 2 }}   | ${'b'} | ${'2b'}
    ${{ val: 3 }}   | ${'b'} | ${'3b'}
    `('add($a.val, $b) -> $expected', ({ a, b, expected }) => {
      expect(a.val + b).toBe(expected)
    })

    // this will return
    // ✓ add(1, b) -> 1b
    // ✓ add(2, b) -> 2b
    // ✓ add(3, b) -> 3b
    ```

    Starting from Vitest 0.25.3, you can also use template string table.

    - First row should be column names, separated by `|`;
    - One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.

    ts

    ``` javascript
    test.each`
      a               | b      | expected
      ${1}            | ${1}   | ${2}
      ${'a'}          | ${'b'} | ${'ab'}
      ${[]}           | ${'b'} | ${'b'}
      ${{}}           | ${'b'} | ${'[object Object]b'}
      ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}
    `('returns $expected when $a is added $b', ({ a, b, expected }) => {
      expect(a + b).toBe(expected)
    })
    ```

    **TIP**

    Vitest processes `$values` with Chai `format` method. If the value is too truncated, you can increase [chaiConfig.truncateThreshold](../config/index#chaiconfig-truncatethreshold) in your config file.

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: test.extend ​
  id: api/index#test-extended
  summary: Use test.extend to extend the test context with custom fixtures
  belongs_to: Test API Reference
  description: |-
    ### test.extend

    - **Alias:** `it.extend`

    Use `test.extend` to extend the test context with custom fixtures. This will return a new `test` and it's also extendable, so you can compose more fixtures or override existing ones by extending it as you need. See [Extend Test Context](../guide/test-context#test-extend) for more information.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const todos = []
    const archive = []

    const myTest = test.extend({
      todos: async ({ task }, use) => {
        todos.push(1, 2, 3)
        await use(todos)
        todos.length = 0
      },
      archive
    })

    myTest('add item', ({ todos }) => {
      expect(todos.length).toBe(3)

      todos.push(4)
      expect(todos.length).toBe(4)
    })
    ```
- name: test.fails ​
  id: api/index#test-fails
  summary: Use test.fails to indicate that an assertion will fail explicitly
  belongs_to: Test API Reference
  description: |-
    ### test.fails

    - **Alias:** `it.fails`

    Use `test.fails` to indicate that an assertion will fail explicitly.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    function myAsyncFunc() {
      return new Promise(resolve => resolve(1))
    }
    test.fails('fail test', async () => {
      await expect(myAsyncFunc()).rejects.toBe(1)
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: test.for ​
  id: api/index#test-for
  summary: Alternative of test.each to provide TestContext
  belongs_to: Test API Reference
  description: "### test.for\n\n- **Alias:** `it.for`\n\nAlternative of `test.each` to provide [`TestContext`](../guide/test-context).\n\nThe difference from `test.each` is how array case is provided in the arguments. Other non array case (including template string usage) works exactly same.\n\nts\n\n``` javascript\n// `each` spreads array case\ntest.each([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', (a, b, expected) => { \n  expect(a + b).toBe(expected)\n})\n\n// `for` doesn't spread array case\ntest.for([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', ([a, b, expected]) => { \n  expect(a + b).toBe(expected)\n})\n```\n\n2nd argument is [`TestContext`](../guide/test-context) and it can be used for concurrent snapshot, for example,\n\nts\n\n``` javascript\ntest.concurrent.for([\n  [1, 1],\n  [1, 2],\n  [2, 1],\n])('add(%i, %i)', ([a, b], { expect }) => {\n  expect(a + b).matchSnapshot()\n})\n```"
- name: test.only ​
  id: api/index#test-only
  summary: Use test.only to only run certain tests in a given suite
  belongs_to: Test API Reference
  description: |-
    ### test.only

    - **Alias:** `it.only`

    Use `test.only` to only run certain tests in a given suite. This is useful when debugging.

    Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with [testTimeout](../config/index#testtimeout).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test.only('test', () => {
      // Only this test (and others marked with only) are run
      assert.equal(Math.sqrt(4), 2)
    })
    ```

    Sometimes it is very useful to run `only` tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.

    In order to do that run `vitest` with specific file containing the tests in question.

    ``` javascript
    # vitest interesting.test.ts
    ```
- name: test.runIf ​
  id: api/index#test-runif
  summary: Opposite of test.skipIf
  belongs_to: Test API Reference
  description: |-
    ### test.runIf

    - **Alias:** `it.runIf`

    Opposite of [test.skipIf](#test-skipif).

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const isDev = process.env.NODE_ENV === 'development'

    test.runIf(isDev)('dev only test', () => {
      // this test only runs in development
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: test.sequential ​
  id: api/index#test-sequential
  summary: test.sequential marks a test as sequential
  belongs_to: Test API Reference
  description: |-
    ### test.sequential

    - **Alias:** `it.sequential`

    `test.sequential` marks a test as sequential. This is useful if you want to run tests in sequence within `describe.concurrent` or with the `--sequence.concurrent` command option.

    ts

    ``` javascript
    // with config option { sequence: { concurrent: true } }
    test('concurrent test 1', async () => { /* ... */ })
    test('concurrent test 2', async () => { /* ... */ })

    test.sequential('sequential test 1', async () => { /* ... */ })
    test.sequential('sequential test 2', async () => { /* ... */ })

    // within concurrent suite
    describe.concurrent('suite', () => {
      test('concurrent test 1', async () => { /* ... */ })
      test('concurrent test 2', async () => { /* ... */ })

      test.sequential('sequential test 1', async () => { /* ... */ })
      test.sequential('sequential test 2', async () => { /* ... */ })
    })
    ```
- name: test.skip ​
  id: api/index#test-skip
  summary: If you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use test.skip to avoid running them
  belongs_to: Test API Reference
  description: |-
    ### test.skip

    - **Alias:** `it.skip`

    If you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use `test.skip` to avoid running them.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test.skip('skipped test', () => {
      // Test skipped, no error
      assert.equal(Math.sqrt(4), 3)
    })
    ```

    You can also skip test by calling `skip` on its [context](../guide/test-context) dynamically:

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('skipped test', (context) => {
      context.skip()
      // Test skipped, no error
      assert.equal(Math.sqrt(4), 3)
    })
    ```
- name: test.skipIf ​
  id: api/index#test-skipif
  summary: In some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific
  belongs_to: Test API Reference
  description: |-
    ### test.skipIf

    - **Alias:** `it.skipIf`

    In some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific. Instead of wrapping the test code with `if`, you can use `test.skipIf` to skip the test whenever the condition is truthy.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    const isDev = process.env.NODE_ENV === 'development'

    test.skipIf(isDev)('prod only test', () => {
      // this test only runs in production
    })
    ```

    **WARNING**

    You cannot use this syntax, when using Vitest as [type checker](../guide/testing-types).
- name: test.todo ​
  id: api/index#test-todo
  summary: Use test.todo to stub tests to be implemented later
  belongs_to: Test API Reference
  description: |-
    ### test.todo

    - **Alias:** `it.todo`

    Use `test.todo` to stub tests to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.

    ts

    ``` javascript
    // An entry will be shown in the report for this test
    test.todo('unimplemented test')
    ```
- name: Testing Types
  id: guide/testing-types
  summary: Vitest allows you to write tests for your types, using expectTypeOf or assertType syntaxes
  description: "# Testing Types\n\n**Sample Project**\n\n[GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/typecheck) - [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/typecheck?initialPath=__vitest__/)\n\nVitest allows you to write tests for your types, using `expectTypeOf` or `assertType` syntaxes. By default all tests inside `*.test-d.ts` files are considered type tests, but you can change it with [`typecheck.include`](../config/index#typecheck-include) config option.\n\nUnder the hood Vitest calls `tsc` or `vue-tsc`, depending on your config, and parses results. Vitest will also print out type errors in your source code, if it finds any. You can disable it with [`typecheck.ignoreSourceErrors`](../config/index#typecheck-ignoresourceerrors) config option.\n\nKeep in mind that Vitest doesn't run or compile these files, they are only statically analyzed by the compiler, and because of that you cannot use any dynamic statements. Meaning, you cannot use dynamic test names, and `test.each`, `test.runIf`, `test.skipIf`, `test.concurrent` APIs. But you can use other APIs, like `test`, `describe`, `.only`, `.skip` and `.todo`.\n\nUsing CLI flags, like `--allowOnly` and `-t` are also supported for type checking.\n\nts\n\n``` javascript\nimport { assertType, expectTypeOf } from 'vitest'\nimport { mount } from './mount.js'\n\ntest('my types work properly', () => {\n  expectTypeOf(mount).toBeFunction()\n  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()\n\n  // @ts-expect-error name is a string\n  assertType(mount({ name: 42 }))\n})\n```\n\nAny type error triggered inside a test file will be treated as a test error, so you can use any type trick you want to test types of your project.\n\nYou can see a list of possible matchers in [API section](../api/expect-typeof).\n\n## Reading Errors\n\nIf you are using `expectTypeOf` API, refer to the [expect-type documentation on its error messages](https://github.com/mmkal/expect-type#error-messages).\n\nWhen types don't match, `.toEqualTypeOf` and `.toMatchTypeOf` use a special helper type to produce error messages that are as actionable as possible. But there's a bit of an nuance to understanding them. Since the assertions are written \"fluently\", the failure should be on the \"expected\" type, not the \"actual\" type (`expect<Actual>().toEqualTypeOf<Expected>()`). This means that type errors can be a little confusing - so this library produces a `MismatchInfo` type to try to make explicit what the expectation is. For example:\n\nts\n\n``` javascript\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()\n```\n\nIs an assertion that will fail, since `{a: 1}` has type `{a: number}` and not `{a: string}`. The error message in this case will read something like this:\n\n``` javascript\ntest/test.ts:999:999 - error TS2344: Type '{ a: string; }' does not satisfy the constraint '{ a: \\\\\"Expected: string, Actual: number\\\\\"; }'.\n  Types of property 'a' are incompatible.\n    Type 'string' is not assignable to type '\\\\\"Expected: string, Actual: number\\\\\"'.\n\n999 expectTypeOf({a: 1}).toEqualTypeOf<{a: string}>()\n```\n\nNote that the type constraint reported is a human-readable messaging specifying both the \"expected\" and \"actual\" types. Rather than taking the sentence `Types of property 'a' are incompatible // Type 'string' is not assignable to type \"Expected: string, Actual: number\"` literally - just look at the property name (`'a'`) and the message: `Expected: string, Actual: number`. This will tell you what's wrong, in most cases. Extremely complex types will of course be more effort to debug, and may require some experimentation. Please [raise an issue](https://github.com/mmkal/expect-type) if the error messages are actually misleading.\n\nThe `toBe...` methods (like `toBeString`, `toBeNumber`, `toBeVoid` etc.) fail by resolving to a non-callable type when the `Actual` type under test doesn't match up. For example, the failure for an assertion like `expectTypeOf(1).toBeString()` will look something like this:\n\n``` javascript\ntest/test.ts:999:999 - error TS2349: This expression is not callable.\n  Type 'ExpectString<number>' has no call signatures.\n\n999 expectTypeOf(1).toBeString()\n                    ~~~~~~~~~~\n```\n\nThe `This expression is not callable` part isn't all that helpful - the meaningful error is the next line, `Type 'ExpectString<number> has no call signatures`. This essentially means you passed a number but asserted it should be a string.\n\nIf TypeScript added support for [\"throw\" types](https://github.com/microsoft/TypeScript/pull/40468) these error messages could be improved significantly. Until then they will take a certain amount of squinting.\n\n#### Concrete \"expected\" objects vs typeargs\n\nError messages for an assertion like this:\n\nts\n\n``` javascript\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: '' })\n```\n\nWill be less helpful than for an assertion like this:\n\nts\n\n``` javascript\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()\n```\n\nThis is because the TypeScript compiler needs to infer the typearg for the `.toEqualTypeOf({a: ''})` style, and this library can only mark it as a failure by comparing it against a generic `Mismatch` type. So, where possible, use a typearg rather than a concrete type for `.toEqualTypeOf` and `toMatchTypeOf`. If it's much more convenient to compare two concrete types, you can use `typeof`:\n\nts\n\n``` javascript\nconst one = valueFromFunctionOne({ some: { complex: inputs } })\nconst two = valueFromFunctionTwo({ some: { other: inputs } })\n\nexpectTypeOf(one).toEqualTypeof<typeof two>()\n```\n\nIf you find it hard working with `expectTypeOf` API and figuring out errors, you can always use more simple `assertType` API:\n\nts\n\n``` javascript\nconst answer = 42\n\nassertType<number>(answer)\n// @ts-expect-error answer is not a string\nassertType<string>(answer)\n```\n\n**TIP**\n\nWhen using `@ts-expect-error` syntax, you might want to make sure that you didn't make a typo. You can do that by including your type files in [`test.include`](../config/index#include) config option, so Vitest will also actually *run* these tests and fail with `ReferenceError`.\n\nThis will pass, because it expects an error, but the word “answer” has a typo, so it's a false positive error:\n\nts\n\n``` javascript\n// @ts-expect-error answer is not a string\nassertType<string>(answr) //\n```\n\n## Run Typechecking\n\nTo enable typechecking, just add [`--typecheck`](../config/index#typecheck) flag to your Vitest command in `package.json`:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest --typecheck\"\n  }\n}\n```\n\nNow you can run typecheck:\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpm run test\n```\n\nbash\n\n``` javascript\nyarn test\n```\n\nbash\n\n``` javascript\npnpm run test\n```\n\nbash\n\n``` javascript\nbun test\n```\n\nVitest uses `tsc --noEmit` or `vue-tsc --noEmit`, depending on your configuration, so you can remove these scripts from your pipeline.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/testing-types](https://vitest.dev/guide/testing-types)"
- name: 'Testing Types: Reading Errors ​'
  id: guide/testing-types#reading-errors
  summary: If you are using expectTypeOf API, refer to the expect-type documentation on its error messages
  belongs_to: Testing Types
  description: |-
    ## Reading Errors

    If you are using `expectTypeOf` API, refer to the [expect-type documentation on its error messages](https://github.com/mmkal/expect-type#error-messages).

    When types don't match, `.toEqualTypeOf` and `.toMatchTypeOf` use a special helper type to produce error messages that are as actionable as possible. But there's a bit of an nuance to understanding them. Since the assertions are written "fluently", the failure should be on the "expected" type, not the "actual" type (`expect<Actual>().toEqualTypeOf<Expected>()`). This means that type errors can be a little confusing - so this library produces a `MismatchInfo` type to try to make explicit what the expectation is. For example:

    ts

    ``` javascript
    expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()
    ```

    Is an assertion that will fail, since `{a: 1}` has type `{a: number}` and not `{a: string}`. The error message in this case will read something like this:

    ``` javascript
    test/test.ts:999:999 - error TS2344: Type '{ a: string; }' does not satisfy the constraint '{ a: \\"Expected: string, Actual: number\\"; }'.
      Types of property 'a' are incompatible.
        Type 'string' is not assignable to type '\\"Expected: string, Actual: number\\"'.

    999 expectTypeOf({a: 1}).toEqualTypeOf<{a: string}>()
    ```

    Note that the type constraint reported is a human-readable messaging specifying both the "expected" and "actual" types. Rather than taking the sentence `Types of property 'a' are incompatible // Type 'string' is not assignable to type "Expected: string, Actual: number"` literally - just look at the property name (`'a'`) and the message: `Expected: string, Actual: number`. This will tell you what's wrong, in most cases. Extremely complex types will of course be more effort to debug, and may require some experimentation. Please [raise an issue](https://github.com/mmkal/expect-type) if the error messages are actually misleading.

    The `toBe...` methods (like `toBeString`, `toBeNumber`, `toBeVoid` etc.) fail by resolving to a non-callable type when the `Actual` type under test doesn't match up. For example, the failure for an assertion like `expectTypeOf(1).toBeString()` will look something like this:

    ``` javascript
    test/test.ts:999:999 - error TS2349: This expression is not callable.
      Type 'ExpectString<number>' has no call signatures.

    999 expectTypeOf(1).toBeString()
                        ~~~~~~~~~~
    ```

    The `This expression is not callable` part isn't all that helpful - the meaningful error is the next line, `Type 'ExpectString<number> has no call signatures`. This essentially means you passed a number but asserted it should be a string.

    If TypeScript added support for ["throw" types](https://github.com/microsoft/TypeScript/pull/40468) these error messages could be improved significantly. Until then they will take a certain amount of squinting.

    #### Concrete "expected" objects vs typeargs

    Error messages for an assertion like this:

    ts

    ``` javascript
    expectTypeOf({ a: 1 }).toEqualTypeOf({ a: '' })
    ```

    Will be less helpful than for an assertion like this:

    ts

    ``` javascript
    expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()
    ```

    This is because the TypeScript compiler needs to infer the typearg for the `.toEqualTypeOf({a: ''})` style, and this library can only mark it as a failure by comparing it against a generic `Mismatch` type. So, where possible, use a typearg rather than a concrete type for `.toEqualTypeOf` and `toMatchTypeOf`. If it's much more convenient to compare two concrete types, you can use `typeof`:

    ts

    ``` javascript
    const one = valueFromFunctionOne({ some: { complex: inputs } })
    const two = valueFromFunctionTwo({ some: { other: inputs } })

    expectTypeOf(one).toEqualTypeof<typeof two>()
    ```

    If you find it hard working with `expectTypeOf` API and figuring out errors, you can always use more simple `assertType` API:

    ts

    ``` javascript
    const answer = 42

    assertType<number>(answer)
    // @ts-expect-error answer is not a string
    assertType<string>(answer)
    ```

    **TIP**

    When using `@ts-expect-error` syntax, you might want to make sure that you didn't make a typo. You can do that by including your type files in [`test.include`](../config/index#include) config option, so Vitest will also actually *run* these tests and fail with `ReferenceError`.

    This will pass, because it expects an error, but the word “answer” has a typo, so it's a false positive error:

    ts

    ``` javascript
    // @ts-expect-error answer is not a string
    assertType<string>(answr) //
    ```
- name: 'Testing Types: Run Typechecking ​'
  id: guide/testing-types#run-typechecking
  summary: Vitest uses tsc --noEmit or vue-tsc --noEmit, depending on your configuration, so you can remove these scripts from your pipeline
  belongs_to: Testing Types
  description: "## Run Typechecking\n\nTo enable typechecking, just add [`--typecheck`](../config/index#typecheck) flag to your Vitest command in `package.json`:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest --typecheck\"\n  }\n}\n```\n\nNow you can run typecheck:\n\nnpm yarn pnpm bun\n\nbash\n\n``` javascript\nnpm run test\n```\n\nbash\n\n``` javascript\nyarn test\n```\n\nbash\n\n``` javascript\npnpm run test\n```\n\nbash\n\n``` javascript\nbun test\n```\n\nVitest uses `tsc --noEmit` or `vue-tsc --noEmit`, depending on your configuration, so you can remove these scripts from your pipeline.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/testing-types](https://vitest.dev/guide/testing-types)"
- name: testNamePattern *  ​
  id: config/index#testnamepattern
  summary: Run tests with full names matching the pattern
  belongs_to: Configuring Vitest
  description: "### testNamePattern \\* \n\n- **Type** `string | RegExp`\n- **CLI:**`-t <pattern>`, `--testNamePattern=<pattern>`, `--test-name-pattern=<pattern>`\n\nRun tests with full names matching the pattern. If you add `OnlyRunThis` to this property, tests not containing the word `OnlyRunThis` in the test name will be skipped.\n\njs\n\n``` javascript\nimport { expect, test } from 'vitest'\n\n// run\ntest('OnlyRunThis', () => {\n  expect(true).toBe(true)\n})\n\n// skipped\ntest('doNotRun', () => {\n  expect(true).toBe(true)\n})\n```"
- name: testTimeout ​
  id: config/index#testtimeout
  summary: null
  belongs_to: Configuring Vitest
  description: |-
    ### testTimeout

    - **Type:** `number`
    - **Default:**`5_000` in Node.js, `15_000` if `browser.enabled` is `true`
    - **CLI:**`--test-timeout=5000`, `--testTimeout=5000`

    Default timeout of a test in milliseconds
- name: testTransformMode ​
  id: config/index#testtransformmode
  summary: Determine the transform method for all modules imported inside a test that matches the glob pattern
  belongs_to: Configuring Vitest
  description: "### testTransformMode\n\n- **Type:** `{ web?, ssr? }`\n\nDetermine the transform method for all modules imported inside a test that matches the glob pattern. By default, relies on the environment. For example, tests with JSDOM environment will process all files with `ssr: false` flag and tests with Node environment process all modules with `ssr: true`.\n\n#### testTransformMode.ssr\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nUse SSR transform pipeline for all modules inside specified tests.  \nVite plugins will receive `ssr: true` flag when processing those files.\n\n#### testTransformMode.web\n\n- **Type:** `string[]`\n- **Default:** `[]`\n\nFirst do a normal transform pipeline (targeting browser), then do a SSR rewrite to run the code in Node.  \nVite plugins will receive `ssr: false` flag when processing those files."
- name: throws ​
  id: api/assert#throws
  summary: If errorLike is an Error constructor, asserts that fn will throw an error that is an instance of errorLike
  belongs_to: assert
  description: |-
    ## throws

    - **Type:**
      - `(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string) => void`
      - `(fn: () => void, errorLike?: ErrorConstructor | Error | null, errMsgMatcher?: RegExp | string | null, message?: string) => void`
    - **Alias:**
      - `throw`
      - `Throw`

    If `errorLike` is an Error constructor, asserts that `fn` will throw an error that is an instance of `errorLike`. If errorLike is an Error instance, asserts that the error thrown is the same instance as `errorLike`. If `errMsgMatcher` is provided, it also asserts that the error thrown will have a message matching `errMsgMatcher`.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.throws', () => {
      assert.throws(fn, 'Error thrown must have this msg')
      assert.throws(fn, /Error thrown must have a msg that matches this/)
      assert.throws(fn, ReferenceError)
      assert.throws(fn, errorInstance)
      assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg')
      assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg')
      assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/)
      assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/)
    })
    ```
- name: toBe ​
  id: api/expect#tobe
  summary: toBe can be used to assert if primitives are equal or that objects share the same reference
  belongs_to: expect
  description: |-
    ## toBe

    - **Type:** `(value: any) => Awaitable<void>`

    `toBe` can be used to assert if primitives are equal or that objects share the same reference. It is equivalent of calling `expect(Object.is(3, 3)).toBe(true)`. If the objects are not the same, but you want to check if their structures are identical, you can use [`toEqual`](#toequal).

    For example, the code below checks if the trader has 13 apples.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const stock = {
      type: 'apples',
      count: 13,
    }

    test('stock has 13 apples', () => {
      expect(stock.type).toBe('apples')
      expect(stock.count).toBe(13)
    })

    test('stocks are the same', () => {
      const refStock = stock // same reference

      expect(stock).toBe(refStock)
    })
    ```

    Try not to use `toBe` with floating-point numbers. Since JavaScript rounds them, `0.1 + 0.2` is not strictly `0.3`. To reliably assert floating-point numbers, use [`toBeCloseTo`](#tobecloseto) assertion.
- name: toBeAny ​
  id: api/expect-typeof#tobeany
  summary: With this matcher you can check, if provided type is any type
  belongs_to: expectTypeOf
  description: |-
    ## toBeAny

    - **Type:** `() => void`

    With this matcher you can check, if provided type is `any` type. If the type is too specific, the test will fail.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf<any>().toBeAny()
    expectTypeOf({} as any).toBeAny()
    expectTypeOf('string').not.toBeAny()
    ```
- name: toBeArray ​
  id: api/expect-typeof#tobearray
  summary: null
  belongs_to: expectTypeOf
  description: |-
    ## toBeArray

    - **Type:** `() => void`

    This matcher checks, if provided type is `Array<T>`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(42).not.toBeArray()
    expectTypeOf([]).toBeArray()
    expectTypeOf([1, 2]).toBeArray()
    expectTypeOf([{}, 42]).toBeArray()
    ```
- name: toBeBoolean ​
  id: api/expect-typeof#tobeboolean
  summary: This matcher checks, if provided type is boolean
  belongs_to: expectTypeOf
  description: |-
    ## toBeBoolean

    - **Type:** `() => void`

    This matcher checks, if provided type is `boolean`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(42).not.toBeBoolean()
    expectTypeOf(true).toBeBoolean()
    expectTypeOf<boolean>().toBeBoolean()
    ```
- name: toBeCallableWith ​
  id: api/expect-typeof#tobecallablewith
  summary: This matcher ensures you can call provided function with a set of parameters
  belongs_to: expectTypeOf
  description: |-
    ## toBeCallableWith

    - **Type:** `() => void`

    This matcher ensures you can call provided function with a set of parameters.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    type NoParam = () => void
    type HasParam = (s: string) => void

    expectTypeOf<NoParam>().toBeCallableWith()
    expectTypeOf<HasParam>().toBeCallableWith('some string')
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.
- name: toBeCloseTo ​
  id: api/expect#tobecloseto
  summary: Use toBeCloseTo to compare floating-point numbers
  belongs_to: expect
  description: |-
    ## toBeCloseTo

    - **Type:** `(value: number, numDigits?: number) => Awaitable<void>`

    Use `toBeCloseTo` to compare floating-point numbers. The optional `numDigits` argument limits the number of digits to check *after* the decimal point. For example:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test.fails('decimals are not equal in javascript', () => {
      expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004
    })

    test('decimals are rounded to 5 after the point', () => {
      // 0.2 + 0.1 is 0.30000 | "000000000004" removed
      expect(0.2 + 0.1).toBeCloseTo(0.3, 5)
      // nothing from 0.30000000000000004 is removed
      expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)
    })
    ```
- name: toBeConstructibleWith ​
  id: api/expect-typeof#tobeconstructiblewith
  summary: This matcher ensures you can create a new instance with a set of constructor parameters
  belongs_to: expectTypeOf
  description: |-
    ## toBeConstructibleWith

    - **Type:** `() => void`

    This matcher ensures you can create a new instance with a set of constructor parameters.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(Date).toBeConstructibleWith(new Date())
    expectTypeOf(Date).toBeConstructibleWith('01-01-2000')
    ```

    **WARNING**

    If used on a non-function type, it will return `never`, so you won't be able to chain it with other matchers.
- name: toBeDefined ​
  id: api/expect#tobedefined
  summary: toBeDefined asserts that the value is not equal to undefined
  belongs_to: expect
  description: |-
    ## toBeDefined

    - **Type:** `() => Awaitable<void>`

    `toBeDefined` asserts that the value is not equal to `undefined`. Useful use case would be to check if function *returned* anything.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    function getApples() {
      return 3
    }

    test('function returned something', () => {
      expect(getApples()).toBeDefined()
    })
    ```
- name: toBeFalsy ​
  id: api/expect#tobefalsy
  summary: toBeFalsy asserts that the value is false when converted to boolean
  belongs_to: expect
  description: |-
    ## toBeFalsy

    - **Type:** `() => Awaitable<void>`

    `toBeFalsy` asserts that the value is false when converted to boolean. Useful if you don't care for the value, but just want to know if it can be converted to `false`.

    For example, having this code you don't care for the return value of `stocks.stockFailed` - it may return any falsy value, but the code will still work.

    ts

    ``` javascript
    import { Stocks } from './stocks.js'

    const stocks = new Stocks()
    stocks.sync('Bill')
    if (!stocks.stockFailed('Bill')) {
      stocks.sell('apples', 'Bill')
    }
    ```

    So if you want to test that `stocks.stockFailed` will be falsy, you could write:

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { Stocks } from './stocks.js'

    const stocks = new Stocks()

    test('if Bill stock hasn\'t failed, sell apples to him', () => {
      stocks.syncStocks('Bill')
      expect(stocks.stockFailed('Bill')).toBeFalsy()
    })
    ```

    Everything in JavaScript is truthy, except `false`, `null`, `undefined`, `NaN`, `0`, `-0`, `0n`, `""` and `document.all`.
- name: toBeFunction ​
  id: api/expect-typeof#tobefunction
  summary: This matcher checks, if provided type is a function
  belongs_to: expectTypeOf
  description: |-
    ## toBeFunction

    - **Type:** `() => void`

    This matcher checks, if provided type is a `function`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(42).not.toBeFunction()
    expectTypeOf((): never => {}).toBeFunction()
    ```
- name: toBeGreaterThan ​
  id: api/expect#tobegreaterthan
  summary: toBeGreaterThan asserts if actual value is greater than received one
  belongs_to: expect
  description: |-
    ## toBeGreaterThan

    - **Type:** `(n: number | bigint) => Awaitable<void>`

    `toBeGreaterThan` asserts if actual value is greater than received one. Equal values will fail the test.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { getApples } from './stocks.js'

    test('have more then 10 apples', () => {
      expect(getApples()).toBeGreaterThan(10)
    })
    ```
- name: toBeGreaterThanOrEqual ​
  id: api/expect#tobegreaterthanorequal
  summary: toBeGreaterThanOrEqual asserts if actual value is greater than received one or equal to it
  belongs_to: expect
  description: |-
    ## toBeGreaterThanOrEqual

    - **Type:** `(n: number | bigint) => Awaitable<void>`

    `toBeGreaterThanOrEqual` asserts if actual value is greater than received one or equal to it.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { getApples } from './stocks.js'

    test('have 11 apples or more', () => {
      expect(getApples()).toBeGreaterThanOrEqual(11)
    })
    ```
- name: toBeInstanceOf ​
  id: api/expect#tobeinstanceof
  summary: toBeInstanceOf asserts if an actual value is instance of received class
  belongs_to: expect
  description: |-
    ## toBeInstanceOf

    - **Type:** `(c: any) => Awaitable<void>`

    `toBeInstanceOf` asserts if an actual value is instance of received class.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { Stocks } from './stocks.js'

    const stocks = new Stocks()

    test('stocks are instance of Stocks', () => {
      expect(stocks).toBeInstanceOf(Stocks)
    })
    ```
- name: toBeLessThan ​
  id: api/expect#tobelessthan
  summary: toBeLessThan asserts if actual value is less than received one
  belongs_to: expect
  description: |-
    ## toBeLessThan

    - **Type:** `(n: number | bigint) => Awaitable<void>`

    `toBeLessThan` asserts if actual value is less than received one. Equal values will fail the test.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { getApples } from './stocks.js'

    test('have less then 20 apples', () => {
      expect(getApples()).toBeLessThan(20)
    })
    ```
- name: toBeLessThanOrEqual ​
  id: api/expect#tobelessthanorequal
  summary: toBeLessThanOrEqual asserts if actual value is less than received one or equal to it
  belongs_to: expect
  description: |-
    ## toBeLessThanOrEqual

    - **Type:** `(n: number | bigint) => Awaitable<void>`

    `toBeLessThanOrEqual` asserts if actual value is less than received one or equal to it.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { getApples } from './stocks.js'

    test('have 11 apples or less', () => {
      expect(getApples()).toBeLessThanOrEqual(11)
    })
    ```
- name: toBeNaN ​
  id: api/expect#tobenan
  summary: toBeNaN simply asserts if something is NaN
  belongs_to: expect
  description: |-
    ## toBeNaN

    - **Type:** `() => Awaitable<void>`

    `toBeNaN` simply asserts if something is `NaN`. Alias for `.toBe(NaN)`.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    let i = 0

    function getApplesCount() {
      i++
      return i > 1 ? Number.NaN : i
    }

    test('getApplesCount has some unusual side effects...', () => {
      expect(getApplesCount()).not.toBeNaN()
      expect(getApplesCount()).toBeNaN()
    })
    ```
- name: toBeNever ​
  id: api/expect-typeof#tobenever
  summary: This matcher checks, if provided type is a never type
  belongs_to: expectTypeOf
  description: |-
    ## toBeNever

    - **Type:** `() => void`

    This matcher checks, if provided type is a `never` type.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf<never>().toBeNever()
    expectTypeOf((): never => {}).returns.toBeNever()
    ```
- name: toBeNull ​
  id: api/expect#tobenull
  summary: toBeNull simply asserts if something is null
  belongs_to: expect
  description: |-
    ## toBeNull

    - **Type:** `() => Awaitable<void>`

    `toBeNull` simply asserts if something is `null`. Alias for `.toBe(null)`.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    function apples() {
      return null
    }

    test('we don\'t have apples', () => {
      expect(apples()).toBeNull()
    })
    ```
- name: toBeNull ​
  id: api/expect-typeof#tobenull
  summary: This matcher checks, if provided type is null
  belongs_to: expectTypeOf
  description: |-
    ## toBeNull

    - **Type:** `() => void`

    This matcher checks, if provided type is `null`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(null).toBeNull()
    expectTypeOf<null>().toBeNull()
    expectTypeOf(undefined).not.toBeNull()
    ```
- name: toBeNullable ​
  id: api/expect-typeof#tobenullable
  summary: This matcher checks, if you can use null or undefined with provided type
  belongs_to: expectTypeOf
  description: |-
    ## toBeNullable

    - **Type:** `() => void`

    This matcher checks, if you can use `null` or `undefined` with provided type.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf<1 | undefined>().toBeNullable()
    expectTypeOf<1 | null>().toBeNullable()
    expectTypeOf<1 | undefined | null>().toBeNullable()
    ```
- name: toBeObject ​
  id: api/expect-typeof#tobeobject
  summary: This matcher checks, if provided type is an object
  belongs_to: expectTypeOf
  description: |-
    ## toBeObject

    - **Type:** `() => void`

    This matcher checks, if provided type is an `object`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(42).not.toBeObject()
    expectTypeOf({}).toBeObject()
    ```
- name: toBeString ​
  id: api/expect-typeof#tobestring
  summary: This matcher checks, if provided type is a string
  belongs_to: expectTypeOf
  description: |-
    ## toBeString

    - **Type:** `() => void`

    This matcher checks, if provided type is a `string`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(42).not.toBeString()
    expectTypeOf('').toBeString()
    expectTypeOf('a').toBeString()
    ```
- name: toBeSymbol ​
  id: api/expect-typeof#tobesymbol
  summary: This matcher checks, if provided type is a symbol
  belongs_to: expectTypeOf
  description: |-
    ## toBeSymbol

    - **Type:** `() => void`

    This matcher checks, if provided type is a `symbol`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(Symbol(1)).toBeSymbol()
    expectTypeOf<symbol>().toBeSymbol()
    ```
- name: toBeTruthy ​
  id: api/expect#tobetruthy
  summary: toBeTruthy asserts that the value is true when converted to boolean
  belongs_to: expect
  description: |-
    ## toBeTruthy

    - **Type:** `() => Awaitable<void>`

    `toBeTruthy` asserts that the value is true when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to `true`.

    For example, having this code you don't care for the return value of `stocks.getInfo` - it maybe a complex object, a string, or anything else. The code will still work.

    ts

    ``` javascript
    import { Stocks } from './stocks.js'

    const stocks = new Stocks()
    stocks.sync('Bill')
    if (stocks.getInfo('Bill')) {
      stocks.sell('apples', 'Bill')
    }
    ```

    So if you want to test that `stocks.getInfo` will be truthy, you could write:

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { Stocks } from './stocks.js'

    const stocks = new Stocks()

    test('if we know Bill stock, sell apples to him', () => {
      stocks.sync('Bill')
      expect(stocks.getInfo('Bill')).toBeTruthy()
    })
    ```

    Everything in JavaScript is truthy, except `false`, `null`, `undefined`, `NaN`, `0`, `-0`, `0n`, `""` and `document.all`.
- name: toBeTypeOf ​
  id: api/expect#tobetypeof
  summary: toBeTypeOf asserts if an actual value is of type of received type
  belongs_to: expect
  description: |-
    ## toBeTypeOf

    - **Type:** `(c: 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') => Awaitable<void>`

    `toBeTypeOf` asserts if an actual value is of type of received type.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const actual = 'stock'

    test('stock is type of string', () => {
      expect(actual).toBeTypeOf('string')
    })
    ```
- name: toBeUndefined ​
  id: api/expect#tobeundefined
  summary: Opposite of toBeDefined, toBeUndefined asserts that the value is equal to undefined
  belongs_to: expect
  description: |-
    ## toBeUndefined

    - **Type:** `() => Awaitable<void>`

    Opposite of `toBeDefined`, `toBeUndefined` asserts that the value *is* equal to `undefined`. Useful use case would be to check if function hasn't *returned* anything.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    function getApplesFromStock(stock: string) {
      if (stock === 'Bill') {
        return 13
      }
    }

    test('mary doesn\'t have a stock', () => {
      expect(getApplesFromStock('Mary')).toBeUndefined()
    })
    ```
- name: toBeUndefined ​
  id: api/expect-typeof#tobeundefined
  summary: This matcher checks, if provided type is undefined
  belongs_to: expectTypeOf
  description: |-
    ## toBeUndefined

    - **Type:** `() => void`

    This matcher checks, if provided type is `undefined`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(undefined).toBeUndefined()
    expectTypeOf<undefined>().toBeUndefined()
    expectTypeOf(null).not.toBeUndefined()
    ```
- name: toBeUnknown ​
  id: api/expect-typeof#tobeunknown
  summary: This matcher checks, if provided type is unknown type
  belongs_to: expectTypeOf
  description: |-
    ## toBeUnknown

    - **Type:** `() => void`

    This matcher checks, if provided type is `unknown` type.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf().toBeUnknown()
    expectTypeOf({} as unknown).toBeUnknown()
    expectTypeOf('string').not.toBeUnknown()
    ```
- name: toBeVoid ​
  id: api/expect-typeof#tobevoid
  summary: This matcher checks, if provided type is void
  belongs_to: expectTypeOf
  description: |-
    ## toBeVoid

    - **Type:** `() => void`

    This matcher checks, if provided type is `void`.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf(() => {}).returns.toBeVoid()
    expectTypeOf<void>().toBeVoid()
    ```
- name: toContain ​
  id: api/expect#tocontain
  summary: toContain asserts if the actual value is in an array
  belongs_to: expect
  description: |-
    ## toContain

    - **Type:** `(received: string) => Awaitable<void>`

    `toContain` asserts if the actual value is in an array. `toContain` can also check whether a string is a substring of another string. Since Vitest 1.0, if you are running tests in a browser-like environment, this assertion can also check if class is contained in a `classList`, or an element is inside another one.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { getAllFruits } from './stocks.js'

    test('the fruit list contains orange', () => {
      expect(getAllFruits()).toContain('orange')

      const element = document.querySelector('#el')
      // element has a class
      expect(element.classList).toContain('flex')
      // element is inside another one
      expect(document.querySelector('#wrapper')).toContain(element)
    })
    ```
- name: toContainEqual ​
  id: api/expect#tocontainequal
  summary: toContainEqual asserts if an item with a specific structure and values is contained in an array
  belongs_to: expect
  description: |-
    ## toContainEqual

    - **Type:** `(received: any) => Awaitable<void>`

    `toContainEqual` asserts if an item with a specific structure and values is contained in an array. It works like [`toEqual`](#toequal) inside for each element.

    ts

    ``` javascript
    import { expect, test } from 'vitest'
    import { getFruitStock } from './stocks.js'

    test('apple available', () => {
      expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })
    })
    ```
- name: toEqual ​
  id: api/expect#toequal
  summary: toEqual asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively)
  belongs_to: expect
  description: |-
    ## toEqual

    - **Type:** `(received: any) => Awaitable<void>`

    `toEqual` asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively). You can see the difference between `toEqual` and [`toBe`](#tobe) in this example:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const stockBill = {
      type: 'apples',
      count: 13,
    }

    const stockMary = {
      type: 'apples',
      count: 13,
    }

    test('stocks have the same properties', () => {
      expect(stockBill).toEqual(stockMary)
    })

    test('stocks are not the same', () => {
      expect(stockBill).not.toBe(stockMary)
    })
    ```

    **WARNING**

    A *deep equality* will not be performed for `Error` objects. Only the `message` property of an Error is considered for equality. To customize equality to check properties other than `message`, use [`expect.addEqualityTesters`](#expect-addequalitytesters). To test if something was thrown, use [`toThrowError`](#tothrowerror) assertion.
- name: toEqualTypeOf ​
  id: api/expect-typeof#toequaltypeof
  summary: This matcher will check if the types are fully equal to each other
  belongs_to: expectTypeOf
  description: |-
    ## toEqualTypeOf

    - **Type:** `<T>(expected: T) => void`

    This matcher will check if the types are fully equal to each other. This matcher will not fail if two objects have different values, but the same type. It will fail however if an object is missing a property.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()
    expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })
    expectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })
    expectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()
    ```
- name: toHaveBeenCalled ​
  id: api/expect#tohavebeencalled
  summary: This assertion is useful for testing that a function has been called
  belongs_to: expect
  description: |-
    ## toHaveBeenCalled

    - **Type:** `() => Awaitable<void>`

    This assertion is useful for testing that a function has been called. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    const market = {
      buy(subject: string, amount: number) {
        // ...
      },
    }

    test('spy function', () => {
      const buySpy = vi.spyOn(market, 'buy')

      expect(buySpy).not.toHaveBeenCalled()

      market.buy('apples', 10)

      expect(buySpy).toHaveBeenCalled()
    })
    ```
- name: toHaveBeenCalledTimes ​
  id: api/expect#tohavebeencalledtimes
  summary: This assertion checks if a function was called a certain amount of times
  belongs_to: expect
  description: |-
    ## toHaveBeenCalledTimes

    - **Type**: `(amount: number) => Awaitable<void>`

    This assertion checks if a function was called a certain amount of times. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    const market = {
      buy(subject: string, amount: number) {
        // ...
      },
    }

    test('spy function called two times', () => {
      const buySpy = vi.spyOn(market, 'buy')

      market.buy('apples', 10)
      market.buy('apples', 20)

      expect(buySpy).toHaveBeenCalledTimes(2)
    })
    ```
- name: toHaveBeenCalledWith ​
  id: api/expect#tohavebeencalledwith
  summary: This assertion checks if a function was called at least once with certain parameters
  belongs_to: expect
  description: |-
    ## toHaveBeenCalledWith

    - **Type**: `(...args: any[]) => Awaitable<void>`

    This assertion checks if a function was called at least once with certain parameters. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    const market = {
      buy(subject: string, amount: number) {
        // ...
      },
    }

    test('spy function', () => {
      const buySpy = vi.spyOn(market, 'buy')

      market.buy('apples', 10)
      market.buy('apples', 20)

      expect(buySpy).toHaveBeenCalledWith('apples', 10)
      expect(buySpy).toHaveBeenCalledWith('apples', 20)
    })
    ```
- name: toHaveBeenLastCalledWith ​
  id: api/expect#tohavebeenlastcalledwith
  summary: This assertion checks if a function was called with certain parameters at its last invocation
  belongs_to: expect
  description: |-
    ## toHaveBeenLastCalledWith

    - **Type**: `(...args: any[]) => Awaitable<void>`

    This assertion checks if a function was called with certain parameters at its last invocation. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    const market = {
      buy(subject: string, amount: number) {
        // ...
      },
    }

    test('spy function', () => {
      const buySpy = vi.spyOn(market, 'buy')

      market.buy('apples', 10)
      market.buy('apples', 20)

      expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)
      expect(buySpy).toHaveBeenLastCalledWith('apples', 20)
    })
    ```
- name: toHaveBeenNthCalledWith ​
  id: api/expect#tohavebeennthcalledwith
  summary: This assertion checks if a function was called with certain parameters at the certain time
  belongs_to: expect
  description: |-
    ## toHaveBeenNthCalledWith

    - **Type**: `(time: number, ...args: any[]) => Awaitable<void>`

    This assertion checks if a function was called with certain parameters at the certain time. The count starts at 1. So, to check the second entry, you would write `.toHaveBeenNthCalledWith(2, ...)`.

    Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    const market = {
      buy(subject: string, amount: number) {
        // ...
      },
    }

    test('first call of spy function called with right params', () => {
      const buySpy = vi.spyOn(market, 'buy')

      market.buy('apples', 10)
      market.buy('apples', 20)

      expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)
    })
    ```
- name: toHaveLastResolvedWith ​
  id: api/expect#tohavelastresolvedwith
  summary: You can call this assertion to check if a function has successfully resolved a certain value when it was last invoked
  belongs_to: expect
  description: |-
    ## toHaveLastResolvedWith

    - **Type**: `(returnValue: any) => Awaitable<void>`

    You can call this assertion to check if a function has successfully resolved a certain value when it was last invoked. Requires a spy function to be passed to `expect`.

    If the function returned a promise, but it was not resolved yet, this will fail.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function resolves bananas on a last call', async () => {
      const sell = vi.fn((product: string) => Promise.resolve({ product }))

      await sell('apples')
      await sell('bananas')

      expect(sell).toHaveLastResolvedWith({ product: 'bananas' })
    })
    ```
- name: toHaveLastReturnedWith ​
  id: api/expect#tohavelastreturnedwith
  summary: You can call this assertion to check if a function has successfully returned a certain value when it was last invoked
  belongs_to: expect
  description: |-
    ## toHaveLastReturnedWith

    - **Type**: `(returnValue: any) => Awaitable<void>`

    You can call this assertion to check if a function has successfully returned a certain value when it was last invoked. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function returns bananas on a last call', () => {
      const sell = vi.fn((product: string) => ({ product }))

      sell('apples')
      sell('bananas')

      expect(sell).toHaveLastReturnedWith({ product: 'bananas' })
    })
    ```
- name: toHaveLength ​
  id: api/expect#tohavelength
  summary: toHaveLength asserts if an object has a .length property and it is set to a certain numeric value
  belongs_to: expect
  description: |-
    ## toHaveLength

    - **Type:** `(received: number) => Awaitable<void>`

    `toHaveLength` asserts if an object has a `.length` property and it is set to a certain numeric value.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('toHaveLength', () => {
      expect('abc').toHaveLength(3)
      expect([1, 2, 3]).toHaveLength(3)

      expect('').not.toHaveLength(3) // doesn't have .length of 3
      expect({ length: 3 }).toHaveLength(3)
    })
    ```
- name: toHaveNthResolvedWith ​
  id: api/expect#tohaventhresolvedwith
  summary: You can call this assertion to check if a function has successfully resolved a certain value on a specific invokation
  belongs_to: expect
  description: |-
    ## toHaveNthResolvedWith

    - **Type**: `(time: number, returnValue: any) => Awaitable<void>`

    You can call this assertion to check if a function has successfully resolved a certain value on a specific invokation. Requires a spy function to be passed to `expect`.

    If the function returned a promise, but it was not resolved yet, this will fail.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function returns bananas on second call', async () => {
      const sell = vi.fn((product: string) => Promise.resolve({ product }))

      await sell('apples')
      await sell('bananas')

      expect(sell).toHaveNthResolvedWith(2, { product: 'bananas' })
    })
    ```
- name: toHaveNthReturnedWith ​
  id: api/expect#tohaventhreturnedwith
  summary: You can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call
  belongs_to: expect
  description: |-
    ## toHaveNthReturnedWith

    - **Type**: `(time: number, returnValue: any) => Awaitable<void>`

    You can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function returns bananas on second call', () => {
      const sell = vi.fn((product: string) => ({ product }))

      sell('apples')
      sell('bananas')

      expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })
    })
    ```
- name: toHaveProperty ​
  id: api/expect#tohaveproperty
  summary: toHaveProperty asserts if a property at provided reference key exists for an object
  belongs_to: expect
  description: |-
    ## toHaveProperty

    - **Type:** `(key: any, received?: any) => Awaitable<void>`

    `toHaveProperty` asserts if a property at provided reference `key` exists for an object.

    You can provide an optional value argument also known as deep equality, like the `toEqual` matcher to compare the received property value.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const invoice = {
      'isActive': true,
      'P.O': '12345',
      'customer': {
        first_name: 'John',
        last_name: 'Doe',
        location: 'China',
      },
      'total_amount': 5000,
      'items': [
        {
          type: 'apples',
          quantity: 10,
        },
        {
          type: 'oranges',
          quantity: 5,
        },
      ],
    }

    test('John Doe Invoice', () => {
      expect(invoice).toHaveProperty('isActive') // assert that the key exists
      expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal

      expect(invoice).not.toHaveProperty('account') // assert that this key does not exist

      // Deep referencing using dot notation
      expect(invoice).toHaveProperty('customer.first_name')
      expect(invoice).toHaveProperty('customer.last_name', 'Doe')
      expect(invoice).not.toHaveProperty('customer.location', 'India')

      // Deep referencing using an array containing the key
      expect(invoice).toHaveProperty('items[0].type', 'apples')
      expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works

      // Deep referencing using an array containing the keyPath
      expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')
      expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works

      // Wrap your key in an array to avoid the key from being parsed as a deep reference
      expect(invoice).toHaveProperty(['P.O'], '12345')
    })
    ```
- name: toHaveProperty ​
  id: api/expect-typeof#tohaveproperty
  summary: This matcher checks if a property exists on the provided object
  belongs_to: expectTypeOf
  description: "## toHaveProperty\n\n- **Type:** `<K extends keyof T>(property: K) => ExpectTypeOf<T[K>`\n\nThis matcher checks if a property exists on the provided object. If it exists, it also returns the same set of matchers for the type of this property, so you can chain assertions one after another.\n\nts\n\n``` javascript\nimport { expectTypeOf } from 'vitest'\n\nconst obj = { a: 1, b: '' }\n\nexpectTypeOf(obj).toHaveProperty('a')\nexpectTypeOf(obj).not.toHaveProperty('c')\n\nexpectTypeOf(obj).toHaveProperty('a').toBeNumber()\nexpectTypeOf(obj).toHaveProperty('b').toBeString()\nexpectTypeOf(obj).toHaveProperty('a').not.toBeString()\n```\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/expect-typeof](https://vitest.dev/api/expect-typeof)"
- name: toHaveResolved ​
  id: api/expect#tohaveresolved
  summary: This assertion checks if a function has successfully resolved a value at least once (i.e., did not reject)
  belongs_to: expect
  description: |-
    ## toHaveResolved

    - **Type**: `() => Awaitable<void>`

    This assertion checks if a function has successfully resolved a value at least once (i.e., did not reject). Requires a spy function to be passed to `expect`.

    If the function returned a promise, but it was not resolved yet, this will fail.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'
    import db from './db/apples.js'

    async function getApplesPrice(amount: number) {
      return amount * await db.get('price')
    }

    test('spy function resolved a value', async () => {
      const getPriceSpy = vi.fn(getApplesPrice)

      const price = await getPriceSpy(10)

      expect(price).toBe(100)
      expect(getPriceSpy).toHaveResolved()
    })
    ```
- name: toHaveResolvedTimes ​
  id: api/expect#tohaveresolvedtimes
  summary: This assertion checks if a function has successfully resolved a value an exact amount of times (i.e., did not reject)
  belongs_to: expect
  description: |-
    ## toHaveResolvedTimes

    - **Type**: `(amount: number) => Awaitable<void>`

    This assertion checks if a function has successfully resolved a value an exact amount of times (i.e., did not reject). Requires a spy function to be passed to `expect`.

    This will only count resolved promises. If the function returned a promise, but it was not resolved yet, it will not be counted.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function resolved a value two times', async () => {
      const sell = vi.fn((product: string) => Promise.resolve({ product }))

      await sell('apples')
      await sell('bananas')

      expect(sell).toHaveResolvedTimes(2)
    })
    ```
- name: toHaveResolvedWith ​
  id: api/expect#tohaveresolvedwith
  summary: You can call this assertion to check if a function has successfully resolved a certain value at least once
  belongs_to: expect
  description: |-
    ## toHaveResolvedWith

    - **Type**: `(returnValue: any) => Awaitable<void>`

    You can call this assertion to check if a function has successfully resolved a certain value at least once. Requires a spy function to be passed to `expect`.

    If the function returned a promise, but it was not resolved yet, this will fail.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function resolved a product', async () => {
      const sell = vi.fn((product: string) => Promise.resolve({ product }))

      await sell('apples')

      expect(sell).toHaveResolvedWith({ product: 'apples' })
    })
    ```
- name: toHaveReturned ​
  id: api/expect#tohavereturned
  summary: This assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error)
  belongs_to: expect
  description: |-
    ## toHaveReturned

    - **Type**: `() => Awaitable<void>`

    This assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error). Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    function getApplesPrice(amount: number) {
      const PRICE = 10
      return amount * PRICE
    }

    test('spy function returned a value', () => {
      const getPriceSpy = vi.fn(getApplesPrice)

      const price = getPriceSpy(10)

      expect(price).toBe(100)
      expect(getPriceSpy).toHaveReturned()
    })
    ```
- name: toHaveReturnedTimes ​
  id: api/expect#tohavereturnedtimes
  summary: This assertion checks if a function has successfully returned a value an exact amount of times (i.e., did not throw an error)
  belongs_to: expect
  description: |-
    ## toHaveReturnedTimes

    - **Type**: `(amount: number) => Awaitable<void>`

    This assertion checks if a function has successfully returned a value an exact amount of times (i.e., did not throw an error). Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function returns a value two times', () => {
      const sell = vi.fn((product: string) => ({ product }))

      sell('apples')
      sell('bananas')

      expect(sell).toHaveReturnedTimes(2)
    })
    ```
- name: toHaveReturnedWith ​
  id: api/expect#tohavereturnedwith
  summary: You can call this assertion to check if a function has successfully returned a value with certain parameters at least once
  belongs_to: expect
  description: |-
    ## toHaveReturnedWith

    - **Type**: `(returnValue: any) => Awaitable<void>`

    You can call this assertion to check if a function has successfully returned a value with certain parameters at least once. Requires a spy function to be passed to `expect`.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('spy function returns a product', () => {
      const sell = vi.fn((product: string) => ({ product }))

      sell('apples')

      expect(sell).toHaveReturnedWith({ product: 'apples' })
    })
    ```
- name: toMatch ​
  id: api/expect#tomatch
  summary: toMatch asserts if a string matches a regular expression or a string
  belongs_to: expect
  description: |-
    ## toMatch

    - **Type:** `(received: string | regexp) => Awaitable<void>`

    `toMatch` asserts if a string matches a regular expression or a string.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('top fruits', () => {
      expect('top fruits include apple, orange and grape').toMatch(/apple/)
      expect('applefruits').toMatch('fruit') // toMatch also accepts a string
    })
    ```
- name: toMatchFileSnapshot ​
  id: api/expect#tomatchfilesnapshot
  summary: Compare or update the snapshot with the content of a file explicitly specified (instead of the .snap file)
  belongs_to: expect
  description: |-
    ## toMatchFileSnapshot

    - **Type:** `<T>(filepath: string, message?: string) => Promise<void>`

    Compare or update the snapshot with the content of a file explicitly specified (instead of the `.snap` file).

    ts

    ``` javascript
    import { expect, it } from 'vitest'

    it('render basic', async () => {
      const result = renderHTML(h('div', { class: 'foo' }))
      await expect(result).toMatchFileSnapshot('./test/basic.output.html')
    })
    ```

    Note that since file system operation is async, you need to use `await` with `toMatchFileSnapshot()`.
- name: toMatchInlineSnapshot ​
  id: api/expect#tomatchinlinesnapshot
  summary: This ensures that a value matches the most recent snapshot
  belongs_to: expect
  description: |-
    ## toMatchInlineSnapshot

    - **Type:** `<T>(shape?: Partial<T> | string, snapshot?: string, message?: string) => void`

    This ensures that a value matches the most recent snapshot.

    Vitest adds and updates the inlineSnapshot string argument to the matcher in the test file (instead of an external `.snap` file).

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('matches inline snapshot', () => {
      const data = { foo: new Set(['bar', 'snapshot']) }
      // Vitest will update following content when updating the snapshot
      expect(data).toMatchInlineSnapshot(`
        {
          "foo": Set {
            "bar",
            "snapshot",
          },
        }
      `)
    })
    ```

    You can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('matches snapshot', () => {
      const data = { foo: new Set(['bar', 'snapshot']) }
      expect(data).toMatchInlineSnapshot(
        { foo: expect.any(Set) },
        `
        {
          "foo": Any<Set>,
        }
      `
      )
    })
    ```
- name: toMatchObject ​
  id: api/expect#tomatchobject
  summary: toMatchObject asserts if an object matches a subset of the properties of an object
  belongs_to: expect
  description: |-
    ## toMatchObject

    - **Type:** `(received: object | array) => Awaitable<void>`

    `toMatchObject` asserts if an object matches a subset of the properties of an object.

    You can also pass an array of objects. This is useful if you want to check that two arrays match in their number of elements, as opposed to `arrayContaining`, which allows for extra elements in the received array.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    const johnInvoice = {
      isActive: true,
      customer: {
        first_name: 'John',
        last_name: 'Doe',
        location: 'China',
      },
      total_amount: 5000,
      items: [
        {
          type: 'apples',
          quantity: 10,
        },
        {
          type: 'oranges',
          quantity: 5,
        },
      ],
    }

    const johnDetails = {
      customer: {
        first_name: 'John',
        last_name: 'Doe',
        location: 'China',
      },
    }

    test('invoice has john personal details', () => {
      expect(johnInvoice).toMatchObject(johnDetails)
    })

    test('the number of elements must match exactly', () => {
      // Assert that an array of object matches
      expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([
        { foo: 'bar' },
        { baz: 1 },
      ])
    })
    ```
- name: toMatchSnapshot ​
  id: api/expect#tomatchsnapshot
  summary: This ensures that a value matches the most recent snapshot
  belongs_to: expect
  description: |-
    ## toMatchSnapshot

    - **Type:** `<T>(shape?: Partial<T> | string, message?: string) => void`

    This ensures that a value matches the most recent snapshot.

    You can provide an optional `hint` string argument that is appended to the test name. Although Vitest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate multiple snapshots in a single it or test block. Vitest sorts snapshots by name in the corresponding `.snap` file.

    **TIP**

    When snapshot mismatch and causing the test failing, if the mismatch is expected, you can press `u` key to update the snapshot for once. Or you can pass `-u` or `--update` CLI options to make Vitest always update the tests.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('matches snapshot', () => {
      const data = { foo: new Set(['bar', 'snapshot']) }
      expect(data).toMatchSnapshot()
    })
    ```

    You can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    test('matches snapshot', () => {
      const data = { foo: new Set(['bar', 'snapshot']) }
      expect(data).toMatchSnapshot({ foo: expect.any(Set) })
    })
    ```
- name: toMatchTypeOf ​
  id: api/expect-typeof#tomatchtypeof
  summary: This matcher checks if expect type extends provided type
  belongs_to: expectTypeOf
  description: |-
    ## toMatchTypeOf

    - **Type:** `<T>(expected: T) => void`

    This matcher checks if expect type extends provided type. It is different from `toEqual` and is more similar to [expect's](expect) `toMatchObject()`. With this matcher, you can check if an object “matches” a type.

    ts

    ``` javascript
    import { expectTypeOf } from 'vitest'

    expectTypeOf({ a: 1, b: 1 }).toMatchTypeOf({ a: 1 })
    expectTypeOf<number>().toMatchTypeOf<string | number>()
    expectTypeOf<string | number>().not.toMatchTypeOf<number>()
    ```
- name: toSatisfy ​
  id: api/expect#tosatisfy
  summary: This assertion checks if a value satisfies a certain predicate
  belongs_to: expect
  description: |-
    ## toSatisfy

    - **Type:** `(predicate: (value: any) => boolean) => Awaitable<void>`

    This assertion checks if a value satisfies a certain predicate.

    ts

    ``` javascript
    import { describe, expect, it } from 'vitest'
    describe('toSatisfy()', () => {
      const isOdd = (value: number) => value % 2 !== 0

      it('pass with 0', () => {
        expect(1).toSatisfy(isOdd)
      })

      it('pass with negation', () => {
        expect(2).not.toSatisfy(isOdd)
      })
    })
    ```
- name: toStrictEqual ​
  id: api/expect#tostrictequal
  summary: toStrictEqual asserts if the actual value is equal to the received one or has the same structure if it is an object (compares them recursively), and of the same type
  belongs_to: expect
  description: |-
    ## toStrictEqual

    - **Type:** `(received: any) => Awaitable<void>`

    `toStrictEqual` asserts if the actual value is equal to the received one or has the same structure if it is an object (compares them recursively), and of the same type.

    Differences from [`.toEqual`](#toequal):

    - Keys with `undefined` properties are checked. e.g. `{a: undefined, b: 2}` does not match `{b: 2}` when using `.toStrictEqual`.
    - Array sparseness is checked. e.g. `[, 1]` does not match `[undefined, 1]` when using `.toStrictEqual`.
    - Object types are checked to be equal. e.g. A class instance with fields `a` and` b` will not equal a literal object with fields `a` and `b`.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    class Stock {
      constructor(type) {
        this.type = type
      }
    }

    test('structurally the same, but semantically different', () => {
      expect(new Stock('apples')).toEqual({ type: 'apples' })
      expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })
    })
    ```
- name: toThrowError ​
  id: api/expect#tothrowerror
  summary: toThrowError asserts if a function throws an error when it is called
  belongs_to: expect
  description: |-
    ## toThrowError

    - **Type:** `(received: any) => Awaitable<void>`

    - **Alias:** `toThrow`

    `toThrowError` asserts if a function throws an error when it is called.

    You can provide an optional argument to test that a specific error is thrown:

    - regular expression: error message matches the pattern
    - string: error message includes the substring

    **TIP**

    You must wrap the code in a function, otherwise the error will not be caught, and test will fail.

    For example, if we want to test that `getFruitStock('pineapples')` throws, we could write:

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    function getFruitStock(type: string) {
      if (type === 'pineapples') {
        throw new Error('Pineapples are not in stock')
      }

      // Do some other stuff
    }

    test('throws on pineapples', () => {
      // Test that the error message says "stock" somewhere: these are equivalent
      expect(() => getFruitStock('pineapples')).toThrowError(/stock/)
      expect(() => getFruitStock('pineapples')).toThrowError('stock')

      // Test the exact error message
      expect(() => getFruitStock('pineapples')).toThrowError(
        /^Pineapples are not in stock$/,
      )
    })
    ```

    **TIP**

    To test async functions, use in combination with [rejects](#rejects).

    js

    ``` javascript
    function getAsyncFruitStock() {
      return Promise.reject(new Error('empty'))
    }

    test('throws on pineapples', async () => {
      await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')
    })
    ```
- name: toThrowErrorMatchingInlineSnapshot ​
  id: api/expect#tothrowerrormatchinginlinesnapshot
  summary: The same as toMatchInlineSnapshot, but expects the same value as toThrowError
  belongs_to: expect
  description: |-
    ## toThrowErrorMatchingInlineSnapshot

    - **Type:** `(snapshot?: string, message?: string) => void`

    The same as [`toMatchInlineSnapshot`](#tomatchinlinesnapshot), but expects the same value as [`toThrowError`](#tothrowerror).
- name: toThrowErrorMatchingSnapshot ​
  id: api/expect#tothrowerrormatchingsnapshot
  summary: The same as toMatchSnapshot, but expects the same value as toThrowError
  belongs_to: expect
  description: |-
    ## toThrowErrorMatchingSnapshot

    - **Type:** `(message?: string) => void`

    The same as [`toMatchSnapshot`](#tomatchsnapshot), but expects the same value as [`toThrowError`](#tothrowerror).
- name: typecheck ​
  id: config/index#typecheck
  summary: Options for configuring typechecking test environment
  belongs_to: Configuring Vitest
  description: |-
    ### typecheck

    Options for configuring [typechecking](../guide/testing-types) test environment.

    #### typecheck.enabled

    - **Type**: `boolean`
    - **Default**: `false`
    - **CLI**: `--typecheck`, `--typecheck.enabled`

    Enable typechecking alongside your regular tests.

    #### typecheck.only

    - **Type**: `boolean`
    - **Default**: `false`
    - **CLI**: `--typecheck.only`

    Run only typecheck tests, when typechecking is enabled. When using CLI, this option will automatically enable typechecking.

    #### typecheck.checker

    - **Type**: `'tsc' | 'vue-tsc' | string`
    - **Default**: `tsc`

    What tools to use for type checking. Vitest will spawn a process with certain parameters for easier parsing, depending on the type. Checker should implement the same output format as `tsc`.

    You need to have a package installed to use typechecker:

    - `tsc` requires `typescript` package
    - `vue-tsc` requires `vue-tsc` package

    You can also pass down a path to custom binary or command name that produces the same output as `tsc --noEmit --pretty false`.

    #### typecheck.include

    - **Type**: `string[]`
    - **Default**: `['**/*.{test,spec}-d.?(c|m)[jt]s?(x)']`

    Glob pattern for files that should be treated as test files

    #### typecheck.exclude

    - **Type**: `string[]`
    - **Default**: `['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**']`

    Glob pattern for files that should not be treated as test files

    #### typecheck.allowJs

    - **Type**: `boolean`
    - **Default**: `false`

    Check JS files that have `@ts-check` comment. If you have it enabled in tsconfig, this will not overwrite it.

    #### typecheck.ignoreSourceErrors

    - **Type**: `boolean`
    - **Default**: `false`

    Do not fail, if Vitest found errors outside the test files. This will not show you non-test errors at all.

    By default, if Vitest finds source error, it will fail test suite.

    #### typecheck.tsconfig

    - **Type**: `string`
    - **Default**: *tries to find closest tsconfig.json*

    Path to custom tsconfig, relative to the project root.
- name: typeOf ​
  id: api/assert#typeof
  summary: Asserts that value’s type is name, as determined by Object.prototype.toString
  belongs_to: assert
  description: |-
    ## typeOf

    - **Type:** `<T>(value: T, name: string, message?: string) => void`

    Asserts that `value`’s type is `name`, as determined by Object.prototype.toString.

    ts

    ``` javascript
    import { assert, test } from 'vitest'

    test('assert.typeOf', () => {
      assert.typeOf({ color: 'red' }, 'object', 'we have an object')
      assert.typeOf(['red', 'green'], 'array', 'we have an array')
      assert.typeOf('red', 'string', 'we have a string')
      assert.typeOf(/red/, 'regexp', 'we have a regular expression')
      assert.typeOf(null, 'null', 'we have a null')
      assert.typeOf(undefined, 'undefined', 'we have an undefined')
    })
    ```
- name: unstubEnvs ​
  id: config/index#unstubenvs
  summary: Will call vi.unstubAllEnvs before each test
  belongs_to: Configuring Vitest
  description: |-
    ### unstubEnvs

    - **Type:** `boolean`
    - **Default:** `false`

    Will call [`vi.unstubAllEnvs`](../api/vi#vi-unstuballenvs) before each test.
- name: unstubGlobals ​
  id: config/index#unstubglobals
  summary: Will call vi.unstubAllGlobals before each test
  belongs_to: Configuring Vitest
  description: |-
    ### unstubGlobals

    - **Type:** `boolean`
    - **Default:** `false`

    Will call [`vi.unstubAllGlobals`](../api/vi#vi-unstuballglobals) before each test.
- name: update *  ​
  id: config/index#update
  summary: Update snapshot files
  belongs_to: Configuring Vitest
  description: "### update \\* \n\n- **Type:** `boolean`\n- **Default:** `false`\n- **CLI:**`-u`, `--update`, `--update=false`\n\nUpdate snapshot files. This will update all changed snapshots and delete obsolete ones."
- name: Vi
  id: api/vi
  summary: Vitest provides utility functions to help you out through its vi helper
  description: "# Vi\n\nVitest provides utility functions to help you out through its `vi` helper. You can access it globally (when [globals configuration](../config/index#globals) is enabled), or import it from `vitest` directly:\n\njs\n\n``` javascript\nimport { vi } from 'vitest'\n```\n\n## Mock Modules\n\nThis section describes the API that you can use when [mocking a module](../guide/mocking#modules). Beware that Vitest doesn't support mocking modules imported using `require()`.\n\n### vi.mock\n\n- **Type**: `(path: string, factory?: (importOriginal: () => unknown) => unknown) => void`\n- **Type**: `<T>(path: Promise<T>, factory?: (importOriginal: () => T) => unknown) => void`\n\nSubstitutes all imported modules from provided `path` with another module. You can use configured Vite aliases inside a path. The call to `vi.mock` is hoisted, so it doesn't matter where you call it. It will always be executed before all imports. If you need to reference some variables outside of its scope, you can define them inside [`vi.hoisted`](#vi-hoisted) and reference them inside `vi.mock`.\n\n**WARNING**\n\n`vi.mock` works only for modules that were imported with the `import` keyword. It doesn't work with `require`.\n\nIn order to hoist `vi.mock`, Vitest statically analyzes your files. It indicates that `vi` that was not directly imported from the `vitest` package (for example, from some utility file) cannot be used. Use `vi.mock` with `vi` imported from `vitest`, or enable [`globals`](../config/index#globals) config option.\n\nVitest will not mock modules that were imported inside a [setup file](../config/index#setupfiles) because they are cached by the time a test file is running. You can call [`vi.resetModules()`](#vi-resetmodules) inside [`vi.hoisted`](#vi-hoisted) to clear all module caches before running a test file.\n\nIf `factory` is defined, all imports will return its result. Vitest calls factory only once and caches results for all subsequent imports until [`vi.unmock`](#vi-unmock) or [`vi.doUnmock`](#vi-dounmock) is called.\n\nUnlike in `jest`, the factory can be asynchronous. You can use [`vi.importActual`](#vi-importactual) or a helper with the factory passed in as the first argument, and get the original module inside.\n\njs\n\n``` javascript\n// when using JavaScript\n\nvi.mock('./path/to/module.js', async (importOriginal) => {\n  const mod = await importOriginal()\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\n```\n\nts\n\n``` javascript\n// when using TypeScript\n\nvi.mock('./path/to/module.js', async (importOriginal) => {\n  const mod = await importOriginal<typeof import('./path/to/module.js')>()\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\n```\n\nVitest supports a module promise instead of a string in `vi.mock` method for better IDE support (when file is moved, path will be updated, `importOriginal` also inherits the type automatically).\n\nts\n\n``` javascript\nvi.mock(import('./path/to/module.js'), async (importOriginal) => {\n  const mod = await importOriginal() // type is inferred\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\n```\n\nUnder the hood, Vitest still operates on a string and not a module object.\n\n**WARNING**\n\n`vi.mock` is hoisted (in other words, *moved*) to **top of the file**. It means that whenever you write it (be it inside `beforeEach` or `test`), it will actually be called before that.\n\nThis also means that you cannot use any variables inside the factory that are defined outside the factory.\n\nIf you need to use variables inside the factory, try [`vi.doMock`](#vi-domock). It works the same way but isn't hoisted. Beware that it only mocks subsequent imports.\n\nYou can also reference variables defined by `vi.hoisted` method if it was declared before `vi.mock`:\n\nts\n\n``` javascript\nimport { namedExport } from './path/to/module.js'\n\nconst mocks = vi.hoisted(() => {\n  return {\n    namedExport: vi.fn(),\n  }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return {\n    namedExport: mocks.namedExport,\n  }\n})\n\nvi.mocked(namedExport).mockReturnValue(100)\n\nexpect(namedExport()).toBe(100)\nexpect(namedExport).toBe(mocks.namedExport)\n```\n\n**WARNING**\n\nIf you are mocking a module with default export, you will need to provide a `default` key within the returned factory function object. This is an ES module-specific caveat; therefore, `jest` documentation may differ as `jest` uses CommonJS modules. For example,\n\nts\n\n``` javascript\nvi.mock('./path/to/module.js', () => {\n  return {\n    default: { myDefaultKey: vi.fn() },\n    namedExport: vi.fn(),\n    // etc...\n  }\n})\n```\n\nIf there is a `__mocks__` folder alongside a file that you are mocking, and the factory is not provided, Vitest will try to find a file with the same name in the `__mocks__` subfolder and use it as an actual module. If you are mocking a dependency, Vitest will try to find a `__mocks__` folder in the [root](../config/index#root) of the project (default is `process.cwd()`). You can tell Vitest where the dependencies are located through the [deps.moduleDirectories](../config/index#deps-moduledirectories) config option.\n\nFor example, you have this file structure:\n\n``` javascript\n- __mocks__\n  - axios.js\n- src\n  __mocks__\n    - increment.js\n  - increment.js\n- tests\n  - increment.test.js\n```\n\nIf you call `vi.mock` in a test file without a factory provided, it will find a file in the `__mocks__` folder to use as a module:\n\nts\n\n``` javascript\n// increment.test.js\nimport { vi } from 'vitest'\n\n// axios is a default export from `__mocks__/axios.js`\nimport axios from 'axios'\n\n// increment is a named export from `src/__mocks__/increment.js`\nimport { increment } from '../increment.js'\n\nvi.mock('axios')\nvi.mock('../increment.js')\n\naxios.get(`/apples/${increment(1)}`)\n```\n\n**WARNING**\n\nBeware that if you don't call `vi.mock`, modules **are not** mocked automatically. To replicate Jest's automocking behaviour, you can call `vi.mock` for each required module inside [`setupFiles`](../config/index#setupfiles).\n\nIf there is no `__mocks__` folder or a factory provided, Vitest will import the original module and auto-mock all its exports. For the rules applied, see [algorithm](../guide/mocking#automocking-algorithm).\n\n### vi.doMock\n\n- **Type**: `(path: string, factory?: (importOriginal: () => unknown) => unknown) => void`\n\nThe same as [`vi.mock`](#vi-mock), but it's not hoisted to the top of the file, so you can reference variables in the global file scope. The next [dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) of the module will be mocked.\n\n**WARNING**\n\nThis will not mock modules that were imported before this was called. Don't forget that all static imports in ESM are always [hoisted](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#hoisting), so putting this before static import will not force it to be called before the import:\n\nts\n\n``` javascript\nvi.doMock('./increment.js') // this will be called _after_ the import statement\n\nimport { increment } from './increment.js'\n```\n\nts\n\n``` javascript\n// ./increment.js\nexport function increment(number) {\n  return number + 1\n}\n```\n\nts\n\n``` javascript\nimport { beforeEach, test } from 'vitest'\nimport { increment } from './increment.js'\n\n// the module is not mocked, because vi.doMock is not called yet\nincrement(1) === 2\n\nlet mockedIncrement = 100\n\nbeforeEach(() => {\n  // you can access variables inside a factory\n  vi.doMock('./increment.js', () => ({ increment: () => ++mockedIncrement }))\n})\n\ntest('importing the next module imports mocked one', async () => {\n  // original import WAS NOT MOCKED, because vi.doMock is evaluated AFTER imports\n  expect(increment(1)).toBe(2)\n  const { increment: mockedIncrement } = await import('./increment.js')\n  // new dynamic import returns mocked module\n  expect(mockedIncrement(1)).toBe(101)\n  expect(mockedIncrement(1)).toBe(102)\n  expect(mockedIncrement(1)).toBe(103)\n})\n```\n\n### vi.mocked\n\n- **Type**: `<T>(obj: T, deep?: boolean) => MaybeMockedDeep<T>`\n- **Type**: `<T>(obj: T, options?: { partial?: boolean; deep?: boolean }) => MaybePartiallyMockedDeep<T>`\n\nType helper for TypeScript. Just returns the object that was passed.\n\nWhen `partial` is `true` it will expect a `Partial<T>` as a return value. By default, this will only make TypeScript believe that the first level values are mocked. You can pass down `{ deep: true }` as a second argument to tell TypeScript that the whole object is mocked, if it actually is.\n\nts\n\n``` javascript\nimport example from './example.js'\n\nvi.mock('./example.js')\n\ntest('1 + 1 equals 10', async () => {\n  vi.mocked(example.calc).mockReturnValue(10)\n  expect(example.calc(1, '+', 1)).toBe(10)\n})\n```\n\n### vi.importActual\n\n- **Type**: `<T>(path: string) => Promise<T>`\n\nImports module, bypassing all checks if it should be mocked. Can be useful if you want to mock module partially.\n\nts\n\n``` javascript\nvi.mock('./example.js', async () => {\n  const axios = await vi.importActual('./example.js')\n\n  return { ...axios, get: vi.fn() }\n})\n```\n\n### vi.importMock\n\n- **Type**: `<T>(path: string) => Promise<MaybeMockedDeep<T>>`\n\nImports a module with all of its properties (including nested properties) mocked. Follows the same rules that [`vi.mock`](#vi-mock) does. For the rules applied, see [algorithm](../guide/mocking#automocking-algorithm).\n\n### vi.unmock\n\n- **Type**: `(path: string) => void`\n\nRemoves module from the mocked registry. All calls to import will return the original module even if it was mocked before. This call is hoisted to the top of the file, so it will only unmock modules that were defined in `setupFiles`, for example.\n\n### vi.doUnmock\n\n- **Type**: `(path: string) => void`\n\nThe same as [`vi.unmock`](#vi-unmock), but is not hoisted to the top of the file. The next import of the module will import the original module instead of the mock. This will not unmock previously imported modules.\n\nts\n\n``` javascript\n// ./increment.js\nexport function increment(number) {\n  return number + 1\n}\n```\n\nts\n\n``` javascript\nimport { increment } from './increment.js'\n\n// increment is already mocked, because vi.mock is hoisted\nincrement(1) === 100\n\n// this is hoisted, and factory is called before the import on line 1\nvi.mock('./increment.js', () => ({ increment: () => 100 }))\n\n// all calls are mocked, and `increment` always returns 100\nincrement(1) === 100\nincrement(30) === 100\n\n// this is not hoisted, so other import will return unmocked module\nvi.doUnmock('./increment.js')\n\n// this STILL returns 100, because `vi.doUnmock` doesn't reevaluate a module\nincrement(1) === 100\nincrement(30) === 100\n\n// the next import is unmocked, now `increment` is the original function that returns count + 1\nconst { increment: unmockedIncrement } = await import('./increment.js')\n\nunmockedIncrement(1) === 2\nunmockedIncrement(30) === 31\n```\n\n### vi.resetModules\n\n- **Type**: `() => Vitest`\n\nResets modules registry by clearing the cache of all modules. This allows modules to be reevaluated when reimported. Top-level imports cannot be re-evaluated. Might be useful to isolate modules where local state conflicts between tests.\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\n\nimport { data } from './data.js' // Will not get reevaluated beforeEach test\n\nbeforeEach(() => {\n  vi.resetModules()\n})\n\ntest('change state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  mod.changeLocalState('new value')\n  expect(mod.getLocalState()).toBe('new value')\n})\n\ntest('module has old state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  expect(mod.getLocalState()).toBe('old value')\n})\n```\n\n**WARNING**\n\nDoes not reset mocks registry. To clear mocks registry, use [`vi.unmock`](#vi-unmock) or [`vi.doUnmock`](#vi-dounmock).\n\n### vi.dynamicImportSettled\n\nWait for all imports to load. Useful, if you have a synchronous call that starts importing a module that you cannot wait otherwise.\n\nts\n\n``` javascript\nimport { expect, test } from 'vitest'\n\n// cannot track import because Promise is not returned\nfunction renderComponent() {\n  import('./component.js').then(({ render }) => {\n    render()\n  })\n}\n\ntest('operations are resolved', async () => {\n  renderComponent()\n  await vi.dynamicImportSettled()\n  expect(document.querySelector('.component')).not.toBeNull()\n})\n```\n\n**TIP**\n\nIf during a dynamic import another dynamic import is initiated, this method will wait until all of them are resolved.\n\nThis method will also wait for the next `setTimeout` tick after the import is resolved so all synchronous operations should be completed by the time it's resolved.\n\n## Mocking Functions and Objects\n\nThis section describes how to work with [method mocks](mock) and replace environmental and global variables.\n\n### vi.fn\n\n- **Type:** `(fn?: Function) => Mock`\n\nCreates a spy on a function, though can be initiated without one. Every time a function is invoked, it stores its call arguments, returns, and instances. Also, you can manipulate its behavior with [methods](mock). If no function is given, mock will return `undefined`, when invoked.\n\nts\n\n``` javascript\nconst getApples = vi.fn(() => 0)\n\ngetApples()\n\nexpect(getApples).toHaveBeenCalled()\nexpect(getApples).toHaveReturnedWith(0)\n\ngetApples.mockReturnValueOnce(5)\n\nconst res = getApples()\nexpect(res).toBe(5)\nexpect(getApples).toHaveNthReturnedWith(2, 5)\n```\n\n### vi.isMockFunction\n\n- **Type:** `(fn: Function) => boolean`\n\nChecks that a given parameter is a mock function. If you are using TypeScript, it will also narrow down its type.\n\n### vi.clearAllMocks\n\nWill call [`.mockClear()`](mock#mockclear) on all spies. This will clear mock history, but not reset its implementation to the default one.\n\n### vi.resetAllMocks\n\nWill call [`.mockReset()`](mock#mockreset) on all spies. This will clear mock history and reset its implementation to an empty function (will return `undefined`).\n\n### vi.restoreAllMocks\n\nWill call [`.mockRestore()`](mock#mockrestore) on all spies. This will clear mock history and reset its implementation to the original one.\n\n### vi.spyOn\n\n- **Type:** `<T, K extends keyof T>(object: T, method: K, accessType?: 'get' | 'set') => MockInstance`\n\nCreates a spy on a method or getter/setter of an object similar to [`vi.fn()`](#vi-fn). It returns a [mock function](mock).\n\nts\n\n``` javascript\nlet apples = 0\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockImplementation(() => apples)\napples = 1\n\nexpect(cart.getApples()).toBe(1)\n\nexpect(spy).toHaveBeenCalled()\nexpect(spy).toHaveReturnedWith(1)\n```\n\n**TIP**\n\nYou can call [`vi.restoreAllMocks`](#vi-restoreallmocks) inside [`afterEach`](index#aftereach) (or enable [`test.restoreMocks`](../config/index#restoreMocks)) to restore all methods to their original implementations. This will restore the original [object descriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), so you won't be able to change method's implementation:\n\nts\n\n``` javascript\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockReturnValue(10)\n\nconsole.log(cart.getApples()) // 10\nvi.restoreAllMocks()\nconsole.log(cart.getApples()) // 42\nspy.mockReturnValue(10)\nconsole.log(cart.getApples()) // still 42!\n```\n\n### vi.stubEnv\n\n- **Type:** `(name: string, value: string) => Vitest`\n\nChanges the value of environmental variable on `process.env` and `import.meta.env`. You can restore its value by calling `vi.unstubAllEnvs`.\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling \"vi.stubEnv\"\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n// doesn't change other envs\nimport.meta.env.MODE === 'development'\n```\n\n**TIP**\n\nYou can also change the value by simply assigning it, but you won't be able to use `vi.unstubAllEnvs` to restore previous value:\n\nts\n\n``` javascript\nimport.meta.env.MODE = 'test'\n```\n\n### vi.unstubAllEnvs\n\n- **Type:** `() => Vitest`\n\nRestores all `import.meta.env` and `process.env` values that were changed with `vi.stubEnv`. When it's called for the first time, Vitest remembers the original value and will store it, until `unstubAllEnvs` is called again.\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling stubEnv\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n\nvi.stubEnv('NODE_ENV', 'staging')\n\nprocess.env.NODE_ENV === 'staging'\nimport.meta.env.NODE_ENV === 'staging'\n\nvi.unstubAllEnvs()\n\n// restores to the value that were stored before the first \"stubEnv\" call\nprocess.env.NODE_ENV === 'development'\nimport.meta.env.NODE_ENV === 'development'\n```\n\n### vi.stubGlobal\n\n- **Type:** `(name: string | number | symbol, value: unknown) => Vitest`\n\nChanges the value of global variable. You can restore its original value by calling `vi.unstubAllGlobals`.\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\n\n// `innerWidth` is \"0\" before calling stubGlobal\n\nvi.stubGlobal('innerWidth', 100)\n\ninnerWidth === 100\nglobalThis.innerWidth === 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth === 100\n```\n\n**TIP**\n\nYou can also change the value by simply assigning it to `globalThis` or `window` (if you are using `jsdom` or `happy-dom` environment), but you won't be able to use `vi.unstubAllGlobals` to restore original value:\n\nts\n\n``` javascript\nglobalThis.innerWidth = 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth = 100\n```\n\n### vi.unstubAllGlobals\n\n- **Type:** `() => Vitest`\n\nRestores all global values on `globalThis`/`global` (and `window`/`top`/`self`/`parent`, if you are using `jsdom` or `happy-dom` environment) that were changed with `vi.stubGlobal`. When it's called for the first time, Vitest remembers the original value and will store it, until `unstubAllGlobals` is called again.\n\nts\n\n``` javascript\nimport { vi } from 'vitest'\n\nconst Mock = vi.fn()\n\n// IntersectionObserver is \"undefined\" before calling \"stubGlobal\"\n\nvi.stubGlobal('IntersectionObserver', Mock)\n\nIntersectionObserver === Mock\nglobal.IntersectionObserver === Mock\nglobalThis.IntersectionObserver === Mock\n// if you are using jsdom or happy-dom\nwindow.IntersectionObserver === Mock\n\nvi.unstubAllGlobals()\n\nglobalThis.IntersectionObserver === undefined\n'IntersectionObserver' in globalThis === false\n// throws ReferenceError, because it's not defined\nIntersectionObserver === undefined\n```\n\n## Fake Timers\n\nThis sections descibes how to work with [fake timers](../guide/mocking#timers).\n\n### vi.advanceTimersByTime\n\n- **Type:** `(ms: number) => Vitest`\n\nThis method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first.\n\nts\n\n``` javascript\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersByTime(150)\n\n// log: 1\n// log: 2\n// log: 3\n```\n\n### vi.advanceTimersByTimeAsync\n\n- **Type:** `(ms: number) => Promise<Vitest>`\n\nThis method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first. This will include asynchronously set timers.\n\nts\n\n``` javascript\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersByTimeAsync(150)\n\n// log: 1\n// log: 2\n// log: 3\n```\n\n### vi.advanceTimersToNextTimer\n\n- **Type:** `() => Vitest`\n\nWill call next available timer. Useful to make assertions between each timer call. You can chain call it to manage timers by yourself.\n\nts\n\n``` javascript\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersToNextTimer() // log: 1\n  .advanceTimersToNextTimer() // log: 2\n  .advanceTimersToNextTimer() // log: 3\n```\n\n### vi.advanceTimersToNextTimerAsync\n\n- **Type:** `() => Promise<Vitest>`\n\nWill call next available timer and wait until it's resolved if it was set asynchronously. Useful to make assertions between each timer call.\n\nts\n\n``` javascript\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 1\nexpect(console.log).toHaveBeenCalledWith(1)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 2\nawait vi.advanceTimersToNextTimerAsync() // log: 3\n```\n\n### vi.getTimerCount\n\n- **Type:** `() => number`\n\nGet the number of waiting timers.\n\n### vi.clearAllTimers\n\nRemoves all timers that are scheduled to run. These timers will never run in the future.\n\n### vi.getMockedSystemTime\n\n- **Type**: `() => Date | null`\n\nReturns mocked current date that was set using `setSystemTime`. If date is not mocked the method will return `null`.\n\n### vi.getRealSystemTime\n\n- **Type**: `() => number`\n\nWhen using `vi.useFakeTimers`, `Date.now` calls are mocked. If you need to get real time in milliseconds, you can call this function.\n\n### vi.runAllTicks\n\n- **Type:** `() => Vitest`\n\nCalls every microtask that was queued by `process.nextTick`. This will also run all microtasks scheduled by themselves.\n\n### vi.runAllTimers\n\n- **Type:** `() => Vitest`\n\nThis method will invoke every initiated timer until the timer queue is empty. It means that every timer called during `runAllTimers` will be fired. If you have an infinite interval, it will throw after 10 000 tries (can be configured with [`fakeTimers.loopLimit`](../config/index#faketimers-looplimit)).\n\nts\n\n``` javascript\nlet i = 0\nsetTimeout(() => console.log(++i))\nconst interval = setInterval(() => {\n  console.log(++i)\n  if (i === 3) {\n    clearInterval(interval)\n  }\n}, 50)\n\nvi.runAllTimers()\n\n// log: 1\n// log: 2\n// log: 3\n```\n\n### vi.runAllTimersAsync\n\n- **Type:** `() => Promise<Vitest>`\n\nThis method will asynchronously invoke every initiated timer until the timer queue is empty. It means that every timer called during `runAllTimersAsync` will be fired even asynchronous timers. If you have an infinite interval, it will throw after 10 000 tries (can be configured with [`fakeTimers.loopLimit`](../config/index#faketimers-looplimit)).\n\nts\n\n``` javascript\nsetTimeout(async () => {\n  console.log(await Promise.resolve('result'))\n}, 100)\n\nawait vi.runAllTimersAsync()\n\n// log: result\n```\n\n### vi.runOnlyPendingTimers\n\n- **Type:** `() => Vitest`\n\nThis method will call every timer that was initiated after [`vi.useFakeTimers`](#vi-usefaketimers) call. It will not fire any timer that was initiated during its call.\n\nts\n\n``` javascript\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.runOnlyPendingTimers()\n\n// log: 1\n```\n\n### vi.runOnlyPendingTimersAsync\n\n- **Type:** `() => Promise<Vitest>`\n\nThis method will asynchronously call every timer that was initiated after [`vi.useFakeTimers`](#vi-usefaketimers) call, even asynchronous ones. It will not fire any timer that was initiated during its call.\n\nts\n\n``` javascript\nsetTimeout(() => {\n  console.log(1)\n}, 100)\nsetTimeout(() => {\n  Promise.resolve().then(() => {\n    console.log(2)\n    setInterval(() => {\n      console.log(3)\n    }, 40)\n  })\n}, 10)\n\nawait vi.runOnlyPendingTimersAsync()\n\n// log: 2\n// log: 3\n// log: 3\n// log: 1\n```\n\n### vi.setSystemTime\n\n- **Type**: `(date: string | number | Date) => void`\n\nIf fake timers are enabled, this method simulates a user changing the system clock (will affect date related API like `hrtime`, `performance.now` or `new Date()`) - however, it will not fire any timers. If fake timers are not enabled, this method will only mock `Date.*` calls.\n\nUseful if you need to test anything that depends on the current date - for example [Luxon](https://github.com/moment/luxon/) calls inside your code.\n\nts\n\n``` javascript\nconst date = new Date(1998, 11, 19)\n\nvi.useFakeTimers()\nvi.setSystemTime(date)\n\nexpect(Date.now()).toBe(date.valueOf())\n\nvi.useRealTimers()\n```\n\n### vi.useFakeTimers\n\n- **Type:** `(config?: FakeTimerInstallOpts) => Vitest`\n\nTo enable mocking timers, you need to call this method. It will wrap all further calls to timers (such as `setTimeout`, `setInterval`, `clearTimeout`, `clearInterval`, `setImmediate`, `clearImmediate`, and `Date`) until [`vi.useRealTimers()`](#vi-userealtimers) is called.\n\nMocking `nextTick` is not supported when running Vitest inside `node:child_process` by using `--pool=forks`. NodeJS uses `process.nextTick` internally in `node:child_process` and hangs when it is mocked. Mocking `nextTick` is supported when running Vitest with `--pool=threads`.\n\nThe implementation is based internally on [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n\n**TIP**\n\n`vi.useFakeTimers()` does not automatically mock `process.nextTick`. But you can enable it by specifying the option in `toFake` argument: `vi.useFakeTimers({ toFake: ['nextTick'] })`.\n\n### vi.isFakeTimers\n\n- **Type:** `() => boolean`\n\nReturns `true` if fake timers are enabled.\n\n### vi.useRealTimers\n\n- **Type:** `() => Vitest`\n\nWhen timers are run out, you may call this method to return mocked timers to its original implementations. All timers that were scheduled before will be discarded.\n\n## Miscellaneous\n\nA set of useful helper functions that Vitest provides.\n\n### vi.waitFor\n\n- **Type:** `<T>(callback: WaitForCallback<T>, options?: number | WaitForOptions) => Promise<T>`\n\nWait for the callback to execute successfully. If the callback throws an error or returns a rejected promise it will continue to wait until it succeeds or times out.\n\nThis is very useful when you need to wait for some asynchronous action to complete, for example, when you start a server and need to wait for it to start.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\nimport { createServer } from './server.js'\n\ntest('Server started successfully', async () => {\n  const server = createServer()\n\n  await vi.waitFor(\n    () => {\n      if (!server.isReady) {\n        throw new Error('Server not started')\n      }\n\n      console.log('Server started')\n    },\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n  expect(server.isReady).toBe(true)\n})\n```\n\nIt also works for asynchronous callbacks\n\nts\n\n``` javascript\n// @vitest-environment jsdom\n\nimport { expect, test, vi } from 'vitest'\nimport { getDOMElementAsync, populateDOMAsync } from './dom.js'\n\ntest('Element exists in a DOM', async () => {\n  // start populating DOM\n  populateDOMAsync()\n\n  const element = await vi.waitFor(async () => {\n    // try to get the element until it exists\n    const element = await getDOMElementAsync() as HTMLElement | null\n    expect(element).toBeTruthy()\n    expect(element.dataset.initialized).toBeTruthy()\n    return element\n  }, {\n    timeout: 500, // default is 1000\n    interval: 20, // default is 50\n  })\n  expect(element).toBeInstanceOf(HTMLElement)\n})\n```\n\nIf `vi.useFakeTimers` is used, `vi.waitFor` automatically calls `vi.advanceTimersByTime(interval)` in every check callback.\n\n### vi.waitUntil\n\n- **Type:** `<T>(callback: WaitUntilCallback<T>, options?: number | WaitUntilOptions) => Promise<T>`\n\nThis is similar to `vi.waitFor`, but if the callback throws any errors, execution is immediately interrupted and an error message is received. If the callback returns falsy value, the next check will continue until truthy value is returned. This is useful when you need to wait for something to exist before taking the next step.\n\nLook at the example below. We can use `vi.waitUntil` to wait for the element to appear on the page, and then we can do something with the element.\n\nts\n\n``` javascript\nimport { expect, test, vi } from 'vitest'\n\ntest('Element render correctly', async () => {\n  const element = await vi.waitUntil(\n    () => document.querySelector('.element'),\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n\n  // do something with the element\n  expect(element.querySelector('.element-child')).toBeTruthy()\n})\n```\n\n### vi.hoisted\n\n- **Type**: `<T>(factory: () => T) => T`\n\nAll static `import` statements in ES modules are hoisted to the top of the file, so any code that is defined before the imports will actually be executed after imports are evaluated.\n\nHowever, it can be useful to invoke some side effects like mocking dates before importing a module.\n\nTo bypass this limitation, you can rewrite static imports into dynamic ones like this:\n\ndiff\n\n``` javascript\ncallFunctionWithSideEffect()\n- import { value } from './some/module.js'\n+ const { value } = await import('./some/module.js')\n```\n\nWhen running `vitest`, you can do this automatically by using `vi.hoisted` method.\n\ndiff\n\n``` javascript\n- callFunctionWithSideEffect()\nimport { value } from './some/module.js'\n+ vi.hoisted(() => callFunctionWithSideEffect())\n```\n\nThis method returns the value that was returned from the factory. You can use that value in your `vi.mock` factories if you need easy access to locally defined variables:\n\nts\n\n``` javascript\nimport { expect, vi } from 'vitest'\nimport { originalMethod } from './path/to/module.js'\n\nconst { mockedMethod } = vi.hoisted(() => {\n  return { mockedMethod: vi.fn() }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return { originalMethod: mockedMethod }\n})\n\nmockedMethod.mockReturnValue(100)\nexpect(originalMethod()).toBe(100)\n```\n\nNote that this method can also be called asynchronously even if your environment doesn't support top-level await:\n\nts\n\n``` javascript\nconst promised = await vi.hoisted(async () => {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts')\n  return response.json()\n})\n```\n\n### vi.setConfig\n\n- **Type**: `RuntimeConfig`\n\nUpdates config for the current test file. This method supports only config options that will affect the current test file:\n\nts\n\n``` javascript\nvi.setConfig({\n  allowOnly: true,\n  testTimeout: 10_000,\n  hookTimeout: 10_000,\n  clearMocks: true,\n  restoreMocks: true,\n  fakeTimers: {\n    now: new Date(2021, 11, 19),\n    // supports the whole object\n  },\n  maxConcurrency: 10,\n  sequence: {\n    hooks: 'stack'\n    // supports only \"sequence.hooks\"\n  }\n})\n```\n\n### vi.resetConfig\n\n- **Type**: `RuntimeConfig`\n\nIf [`vi.setConfig`](#vi-setconfig) was called before, this will reset config to the original state.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/vi](https://vitest.dev/api/vi)"
- name: vi.advanceTimersByTime ​
  id: api/vi#vi-advancetimersbytime
  summary: This method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first
  belongs_to: Vi
  description: |-
    ### vi.advanceTimersByTime

    - **Type:** `(ms: number) => Vitest`

    This method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first.

    ts

    ``` javascript
    let i = 0
    setInterval(() => console.log(++i), 50)

    vi.advanceTimersByTime(150)

    // log: 1
    // log: 2
    // log: 3
    ```
- name: vi.advanceTimersByTimeAsync ​
  id: api/vi#vi-advancetimersbytimeasync
  summary: This method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first
  belongs_to: Vi
  description: |-
    ### vi.advanceTimersByTimeAsync

    - **Type:** `(ms: number) => Promise<Vitest>`

    This method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first. This will include asynchronously set timers.

    ts

    ``` javascript
    let i = 0
    setInterval(() => Promise.resolve().then(() => console.log(++i)), 50)

    await vi.advanceTimersByTimeAsync(150)

    // log: 1
    // log: 2
    // log: 3
    ```
- name: vi.advanceTimersToNextTimer ​
  id: api/vi#vi-advancetimerstonexttimer
  summary: Will call next available timer
  belongs_to: Vi
  description: |-
    ### vi.advanceTimersToNextTimer

    - **Type:** `() => Vitest`

    Will call next available timer. Useful to make assertions between each timer call. You can chain call it to manage timers by yourself.

    ts

    ``` javascript
    let i = 0
    setInterval(() => console.log(++i), 50)

    vi.advanceTimersToNextTimer() // log: 1
      .advanceTimersToNextTimer() // log: 2
      .advanceTimersToNextTimer() // log: 3
    ```
- name: vi.advanceTimersToNextTimerAsync ​
  id: api/vi#vi-advancetimerstonexttimerasync
  summary: Will call next available timer and wait until it's resolved if it was set asynchronously
  belongs_to: Vi
  description: |-
    ### vi.advanceTimersToNextTimerAsync

    - **Type:** `() => Promise<Vitest>`

    Will call next available timer and wait until it's resolved if it was set asynchronously. Useful to make assertions between each timer call.

    ts

    ``` javascript
    let i = 0
    setInterval(() => Promise.resolve().then(() => console.log(++i)), 50)

    await vi.advanceTimersToNextTimerAsync() // log: 1
    expect(console.log).toHaveBeenCalledWith(1)

    await vi.advanceTimersToNextTimerAsync() // log: 2
    await vi.advanceTimersToNextTimerAsync() // log: 3
    ```
- name: vi.clearAllMocks ​
  id: api/vi#vi-clearallmocks
  summary: Will call .mockClear() on all spies
  belongs_to: Vi
  description: |-
    ### vi.clearAllMocks

    Will call [`.mockClear()`](mock#mockclear) on all spies. This will clear mock history, but not reset its implementation to the default one.
- name: vi.clearAllTimers ​
  id: api/vi#vi-clearalltimers
  summary: Removes all timers that are scheduled to run
  belongs_to: Vi
  description: |-
    ### vi.clearAllTimers

    Removes all timers that are scheduled to run. These timers will never run in the future.
- name: vi.doMock ​
  id: api/vi#vi-domock
  summary: The same as vi.mock, but it's not hoisted to the top of the file, so you can reference variables in the global file scope
  belongs_to: Vi
  description: |-
    ### vi.doMock

    - **Type**: `(path: string, factory?: (importOriginal: () => unknown) => unknown) => void`

    The same as [`vi.mock`](#vi-mock), but it's not hoisted to the top of the file, so you can reference variables in the global file scope. The next [dynamic import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) of the module will be mocked.

    **WARNING**

    This will not mock modules that were imported before this was called. Don't forget that all static imports in ESM are always [hoisted](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#hoisting), so putting this before static import will not force it to be called before the import:

    ts

    ``` javascript
    vi.doMock('./increment.js') // this will be called _after_ the import statement

    import { increment } from './increment.js'
    ```

    ts

    ``` javascript
    // ./increment.js
    export function increment(number) {
      return number + 1
    }
    ```

    ts

    ``` javascript
    import { beforeEach, test } from 'vitest'
    import { increment } from './increment.js'

    // the module is not mocked, because vi.doMock is not called yet
    increment(1) === 2

    let mockedIncrement = 100

    beforeEach(() => {
      // you can access variables inside a factory
      vi.doMock('./increment.js', () => ({ increment: () => ++mockedIncrement }))
    })

    test('importing the next module imports mocked one', async () => {
      // original import WAS NOT MOCKED, because vi.doMock is evaluated AFTER imports
      expect(increment(1)).toBe(2)
      const { increment: mockedIncrement } = await import('./increment.js')
      // new dynamic import returns mocked module
      expect(mockedIncrement(1)).toBe(101)
      expect(mockedIncrement(1)).toBe(102)
      expect(mockedIncrement(1)).toBe(103)
    })
    ```
- name: vi.doUnmock ​
  id: api/vi#vi-dounmock
  summary: The same as vi.unmock, but is not hoisted to the top of the file
  belongs_to: Vi
  description: |-
    ### vi.doUnmock

    - **Type**: `(path: string) => void`

    The same as [`vi.unmock`](#vi-unmock), but is not hoisted to the top of the file. The next import of the module will import the original module instead of the mock. This will not unmock previously imported modules.

    ts

    ``` javascript
    // ./increment.js
    export function increment(number) {
      return number + 1
    }
    ```

    ts

    ``` javascript
    import { increment } from './increment.js'

    // increment is already mocked, because vi.mock is hoisted
    increment(1) === 100

    // this is hoisted, and factory is called before the import on line 1
    vi.mock('./increment.js', () => ({ increment: () => 100 }))

    // all calls are mocked, and `increment` always returns 100
    increment(1) === 100
    increment(30) === 100

    // this is not hoisted, so other import will return unmocked module
    vi.doUnmock('./increment.js')

    // this STILL returns 100, because `vi.doUnmock` doesn't reevaluate a module
    increment(1) === 100
    increment(30) === 100

    // the next import is unmocked, now `increment` is the original function that returns count + 1
    const { increment: unmockedIncrement } = await import('./increment.js')

    unmockedIncrement(1) === 2
    unmockedIncrement(30) === 31
    ```
- name: vi.dynamicImportSettled ​
  id: api/vi#vi-dynamicimportsettled
  summary: Wait for all imports to load
  belongs_to: Vi
  description: |-
    ### vi.dynamicImportSettled

    Wait for all imports to load. Useful, if you have a synchronous call that starts importing a module that you cannot wait otherwise.

    ts

    ``` javascript
    import { expect, test } from 'vitest'

    // cannot track import because Promise is not returned
    function renderComponent() {
      import('./component.js').then(({ render }) => {
        render()
      })
    }

    test('operations are resolved', async () => {
      renderComponent()
      await vi.dynamicImportSettled()
      expect(document.querySelector('.component')).not.toBeNull()
    })
    ```

    **TIP**

    If during a dynamic import another dynamic import is initiated, this method will wait until all of them are resolved.

    This method will also wait for the next `setTimeout` tick after the import is resolved so all synchronous operations should be completed by the time it's resolved.
- name: vi.fn ​
  id: api/vi#vi-fn
  summary: Creates a spy on a function, though can be initiated without one
  belongs_to: Vi
  description: |-
    ### vi.fn

    - **Type:** `(fn?: Function) => Mock`

    Creates a spy on a function, though can be initiated without one. Every time a function is invoked, it stores its call arguments, returns, and instances. Also, you can manipulate its behavior with [methods](mock). If no function is given, mock will return `undefined`, when invoked.

    ts

    ``` javascript
    const getApples = vi.fn(() => 0)

    getApples()

    expect(getApples).toHaveBeenCalled()
    expect(getApples).toHaveReturnedWith(0)

    getApples.mockReturnValueOnce(5)

    const res = getApples()
    expect(res).toBe(5)
    expect(getApples).toHaveNthReturnedWith(2, 5)
    ```
- name: vi.getMockedSystemTime ​
  id: api/vi#vi-getmockedsystemtime
  summary: Returns mocked current date that was set using setSystemTime
  belongs_to: Vi
  description: |-
    ### vi.getMockedSystemTime

    - **Type**: `() => Date | null`

    Returns mocked current date that was set using `setSystemTime`. If date is not mocked the method will return `null`.
- name: vi.getRealSystemTime ​
  id: api/vi#vi-getrealsystemtime
  summary: When using vi.useFakeTimers, Date.now calls are mocked
  belongs_to: Vi
  description: |-
    ### vi.getRealSystemTime

    - **Type**: `() => number`

    When using `vi.useFakeTimers`, `Date.now` calls are mocked. If you need to get real time in milliseconds, you can call this function.
- name: vi.getTimerCount ​
  id: api/vi#vi-gettimercount
  summary: Get the number of waiting timers
  belongs_to: Vi
  description: |-
    ### vi.getTimerCount

    - **Type:** `() => number`

    Get the number of waiting timers.
- name: vi.hoisted ​
  id: api/vi#vi-hoisted
  summary: All static import statements in ES modules are hoisted to the top of the file, so any code that is defined before the imports will actually be executed after imports are evaluated
  belongs_to: Vi
  description: |-
    ### vi.hoisted

    - **Type**: `<T>(factory: () => T) => T`

    All static `import` statements in ES modules are hoisted to the top of the file, so any code that is defined before the imports will actually be executed after imports are evaluated.

    However, it can be useful to invoke some side effects like mocking dates before importing a module.

    To bypass this limitation, you can rewrite static imports into dynamic ones like this:

    diff

    ``` javascript
    callFunctionWithSideEffect()
    - import { value } from './some/module.js'
    + const { value } = await import('./some/module.js')
    ```

    When running `vitest`, you can do this automatically by using `vi.hoisted` method.

    diff

    ``` javascript
    - callFunctionWithSideEffect()
    import { value } from './some/module.js'
    + vi.hoisted(() => callFunctionWithSideEffect())
    ```

    This method returns the value that was returned from the factory. You can use that value in your `vi.mock` factories if you need easy access to locally defined variables:

    ts

    ``` javascript
    import { expect, vi } from 'vitest'
    import { originalMethod } from './path/to/module.js'

    const { mockedMethod } = vi.hoisted(() => {
      return { mockedMethod: vi.fn() }
    })

    vi.mock('./path/to/module.js', () => {
      return { originalMethod: mockedMethod }
    })

    mockedMethod.mockReturnValue(100)
    expect(originalMethod()).toBe(100)
    ```

    Note that this method can also be called asynchronously even if your environment doesn't support top-level await:

    ts

    ``` javascript
    const promised = await vi.hoisted(async () => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts')
      return response.json()
    })
    ```
- name: vi.importActual ​
  id: api/vi#vi-importactual
  summary: Imports module, bypassing all checks if it should be mocked
  belongs_to: Vi
  description: |-
    ### vi.importActual

    - **Type**: `<T>(path: string) => Promise<T>`

    Imports module, bypassing all checks if it should be mocked. Can be useful if you want to mock module partially.

    ts

    ``` javascript
    vi.mock('./example.js', async () => {
      const axios = await vi.importActual('./example.js')

      return { ...axios, get: vi.fn() }
    })
    ```
- name: vi.importMock ​
  id: api/vi#vi-importmock
  summary: Imports a module with all of its properties (including nested properties) mocked
  belongs_to: Vi
  description: |-
    ### vi.importMock

    - **Type**: `<T>(path: string) => Promise<MaybeMockedDeep<T>>`

    Imports a module with all of its properties (including nested properties) mocked. Follows the same rules that [`vi.mock`](#vi-mock) does. For the rules applied, see [algorithm](../guide/mocking#automocking-algorithm).
- name: vi.isFakeTimers ​
  id: api/vi#vi-isfaketimers
  summary: Returns true if fake timers are enabled
  belongs_to: Vi
  description: |-
    ### vi.isFakeTimers

    - **Type:** `() => boolean`

    Returns `true` if fake timers are enabled.
- name: vi.isMockFunction ​
  id: api/vi#vi-ismockfunction
  summary: Checks that a given parameter is a mock function
  belongs_to: Vi
  description: |-
    ### vi.isMockFunction

    - **Type:** `(fn: Function) => boolean`

    Checks that a given parameter is a mock function. If you are using TypeScript, it will also narrow down its type.
- name: vi.mock ​
  id: api/vi#vi-mock
  summary: Substitutes all imported modules from provided path with another module
  belongs_to: Vi
  description: |-
    ### vi.mock

    - **Type**: `(path: string, factory?: (importOriginal: () => unknown) => unknown) => void`
    - **Type**: `<T>(path: Promise<T>, factory?: (importOriginal: () => T) => unknown) => void`

    Substitutes all imported modules from provided `path` with another module. You can use configured Vite aliases inside a path. The call to `vi.mock` is hoisted, so it doesn't matter where you call it. It will always be executed before all imports. If you need to reference some variables outside of its scope, you can define them inside [`vi.hoisted`](#vi-hoisted) and reference them inside `vi.mock`.

    **WARNING**

    `vi.mock` works only for modules that were imported with the `import` keyword. It doesn't work with `require`.

    In order to hoist `vi.mock`, Vitest statically analyzes your files. It indicates that `vi` that was not directly imported from the `vitest` package (for example, from some utility file) cannot be used. Use `vi.mock` with `vi` imported from `vitest`, or enable [`globals`](../config/index#globals) config option.

    Vitest will not mock modules that were imported inside a [setup file](../config/index#setupfiles) because they are cached by the time a test file is running. You can call [`vi.resetModules()`](#vi-resetmodules) inside [`vi.hoisted`](#vi-hoisted) to clear all module caches before running a test file.

    If `factory` is defined, all imports will return its result. Vitest calls factory only once and caches results for all subsequent imports until [`vi.unmock`](#vi-unmock) or [`vi.doUnmock`](#vi-dounmock) is called.

    Unlike in `jest`, the factory can be asynchronous. You can use [`vi.importActual`](#vi-importactual) or a helper with the factory passed in as the first argument, and get the original module inside.

    js

    ``` javascript
    // when using JavaScript

    vi.mock('./path/to/module.js', async (importOriginal) => {
      const mod = await importOriginal()
      return {
        ...mod,
        // replace some exports
        namedExport: vi.fn(),
      }
    })
    ```

    ts

    ``` javascript
    // when using TypeScript

    vi.mock('./path/to/module.js', async (importOriginal) => {
      const mod = await importOriginal<typeof import('./path/to/module.js')>()
      return {
        ...mod,
        // replace some exports
        namedExport: vi.fn(),
      }
    })
    ```

    Vitest supports a module promise instead of a string in `vi.mock` method for better IDE support (when file is moved, path will be updated, `importOriginal` also inherits the type automatically).

    ts

    ``` javascript
    vi.mock(import('./path/to/module.js'), async (importOriginal) => {
      const mod = await importOriginal() // type is inferred
      return {
        ...mod,
        // replace some exports
        namedExport: vi.fn(),
      }
    })
    ```

    Under the hood, Vitest still operates on a string and not a module object.

    **WARNING**

    `vi.mock` is hoisted (in other words, *moved*) to **top of the file**. It means that whenever you write it (be it inside `beforeEach` or `test`), it will actually be called before that.

    This also means that you cannot use any variables inside the factory that are defined outside the factory.

    If you need to use variables inside the factory, try [`vi.doMock`](#vi-domock). It works the same way but isn't hoisted. Beware that it only mocks subsequent imports.

    You can also reference variables defined by `vi.hoisted` method if it was declared before `vi.mock`:

    ts

    ``` javascript
    import { namedExport } from './path/to/module.js'

    const mocks = vi.hoisted(() => {
      return {
        namedExport: vi.fn(),
      }
    })

    vi.mock('./path/to/module.js', () => {
      return {
        namedExport: mocks.namedExport,
      }
    })

    vi.mocked(namedExport).mockReturnValue(100)

    expect(namedExport()).toBe(100)
    expect(namedExport).toBe(mocks.namedExport)
    ```

    **WARNING**

    If you are mocking a module with default export, you will need to provide a `default` key within the returned factory function object. This is an ES module-specific caveat; therefore, `jest` documentation may differ as `jest` uses CommonJS modules. For example,

    ts

    ``` javascript
    vi.mock('./path/to/module.js', () => {
      return {
        default: { myDefaultKey: vi.fn() },
        namedExport: vi.fn(),
        // etc...
      }
    })
    ```

    If there is a `__mocks__` folder alongside a file that you are mocking, and the factory is not provided, Vitest will try to find a file with the same name in the `__mocks__` subfolder and use it as an actual module. If you are mocking a dependency, Vitest will try to find a `__mocks__` folder in the [root](../config/index#root) of the project (default is `process.cwd()`). You can tell Vitest where the dependencies are located through the [deps.moduleDirectories](../config/index#deps-moduledirectories) config option.

    For example, you have this file structure:

    ``` javascript
    - __mocks__
      - axios.js
    - src
      __mocks__
        - increment.js
      - increment.js
    - tests
      - increment.test.js
    ```

    If you call `vi.mock` in a test file without a factory provided, it will find a file in the `__mocks__` folder to use as a module:

    ts

    ``` javascript
    // increment.test.js
    import { vi } from 'vitest'

    // axios is a default export from `__mocks__/axios.js`
    import axios from 'axios'

    // increment is a named export from `src/__mocks__/increment.js`
    import { increment } from '../increment.js'

    vi.mock('axios')
    vi.mock('../increment.js')

    axios.get(`/apples/${increment(1)}`)
    ```

    **WARNING**

    Beware that if you don't call `vi.mock`, modules **are not** mocked automatically. To replicate Jest's automocking behaviour, you can call `vi.mock` for each required module inside [`setupFiles`](../config/index#setupfiles).

    If there is no `__mocks__` folder or a factory provided, Vitest will import the original module and auto-mock all its exports. For the rules applied, see [algorithm](../guide/mocking#automocking-algorithm).
- name: vi.mocked ​
  id: api/vi#vi-mocked
  summary: Type helper for TypeScript
  belongs_to: Vi
  description: |-
    ### vi.mocked

    - **Type**: `<T>(obj: T, deep?: boolean) => MaybeMockedDeep<T>`
    - **Type**: `<T>(obj: T, options?: { partial?: boolean; deep?: boolean }) => MaybePartiallyMockedDeep<T>`

    Type helper for TypeScript. Just returns the object that was passed.

    When `partial` is `true` it will expect a `Partial<T>` as a return value. By default, this will only make TypeScript believe that the first level values are mocked. You can pass down `{ deep: true }` as a second argument to tell TypeScript that the whole object is mocked, if it actually is.

    ts

    ``` javascript
    import example from './example.js'

    vi.mock('./example.js')

    test('1 + 1 equals 10', async () => {
      vi.mocked(example.calc).mockReturnValue(10)
      expect(example.calc(1, '+', 1)).toBe(10)
    })
    ```
- name: vi.resetAllMocks ​
  id: api/vi#vi-resetallmocks
  summary: Will call .mockReset() on all spies
  belongs_to: Vi
  description: |-
    ### vi.resetAllMocks

    Will call [`.mockReset()`](mock#mockreset) on all spies. This will clear mock history and reset its implementation to an empty function (will return `undefined`).
- name: vi.resetConfig ​
  id: api/vi#vi-resetconfig
  summary: If vi.setConfig was called before, this will reset config to the original state
  belongs_to: Vi
  description: "### vi.resetConfig\n\n- **Type**: `RuntimeConfig`\n\nIf [`vi.setConfig`](#vi-setconfig) was called before, this will reset config to the original state.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/api/vi](https://vitest.dev/api/vi)"
- name: vi.resetModules ​
  id: api/vi#vi-resetmodules
  summary: Resets modules registry by clearing the cache of all modules
  belongs_to: Vi
  description: |-
    ### vi.resetModules

    - **Type**: `() => Vitest`

    Resets modules registry by clearing the cache of all modules. This allows modules to be reevaluated when reimported. Top-level imports cannot be re-evaluated. Might be useful to isolate modules where local state conflicts between tests.

    ts

    ``` javascript
    import { vi } from 'vitest'

    import { data } from './data.js' // Will not get reevaluated beforeEach test

    beforeEach(() => {
      vi.resetModules()
    })

    test('change state', async () => {
      const mod = await import('./some/path.js') // Will get reevaluated
      mod.changeLocalState('new value')
      expect(mod.getLocalState()).toBe('new value')
    })

    test('module has old state', async () => {
      const mod = await import('./some/path.js') // Will get reevaluated
      expect(mod.getLocalState()).toBe('old value')
    })
    ```

    **WARNING**

    Does not reset mocks registry. To clear mocks registry, use [`vi.unmock`](#vi-unmock) or [`vi.doUnmock`](#vi-dounmock).
- name: vi.restoreAllMocks ​
  id: api/vi#vi-restoreallmocks
  summary: Will call .mockRestore() on all spies
  belongs_to: Vi
  description: |-
    ### vi.restoreAllMocks

    Will call [`.mockRestore()`](mock#mockrestore) on all spies. This will clear mock history and reset its implementation to the original one.
- name: vi.runAllTicks ​
  id: api/vi#vi-runallticks
  summary: Calls every microtask that was queued by process.nextTick
  belongs_to: Vi
  description: |-
    ### vi.runAllTicks

    - **Type:** `() => Vitest`

    Calls every microtask that was queued by `process.nextTick`. This will also run all microtasks scheduled by themselves.
- name: vi.runAllTimers ​
  id: api/vi#vi-runalltimers
  summary: This method will invoke every initiated timer until the timer queue is empty
  belongs_to: Vi
  description: |-
    ### vi.runAllTimers

    - **Type:** `() => Vitest`

    This method will invoke every initiated timer until the timer queue is empty. It means that every timer called during `runAllTimers` will be fired. If you have an infinite interval, it will throw after 10 000 tries (can be configured with [`fakeTimers.loopLimit`](../config/index#faketimers-looplimit)).

    ts

    ``` javascript
    let i = 0
    setTimeout(() => console.log(++i))
    const interval = setInterval(() => {
      console.log(++i)
      if (i === 3) {
        clearInterval(interval)
      }
    }, 50)

    vi.runAllTimers()

    // log: 1
    // log: 2
    // log: 3
    ```
- name: vi.runAllTimersAsync ​
  id: api/vi#vi-runalltimersasync
  summary: This method will asynchronously invoke every initiated timer until the timer queue is empty
  belongs_to: Vi
  description: |-
    ### vi.runAllTimersAsync

    - **Type:** `() => Promise<Vitest>`

    This method will asynchronously invoke every initiated timer until the timer queue is empty. It means that every timer called during `runAllTimersAsync` will be fired even asynchronous timers. If you have an infinite interval, it will throw after 10 000 tries (can be configured with [`fakeTimers.loopLimit`](../config/index#faketimers-looplimit)).

    ts

    ``` javascript
    setTimeout(async () => {
      console.log(await Promise.resolve('result'))
    }, 100)

    await vi.runAllTimersAsync()

    // log: result
    ```
- name: vi.runOnlyPendingTimers ​
  id: api/vi#vi-runonlypendingtimers
  summary: This method will call every timer that was initiated after vi.useFakeTimers call
  belongs_to: Vi
  description: |-
    ### vi.runOnlyPendingTimers

    - **Type:** `() => Vitest`

    This method will call every timer that was initiated after [`vi.useFakeTimers`](#vi-usefaketimers) call. It will not fire any timer that was initiated during its call.

    ts

    ``` javascript
    let i = 0
    setInterval(() => console.log(++i), 50)

    vi.runOnlyPendingTimers()

    // log: 1
    ```
- name: vi.runOnlyPendingTimersAsync ​
  id: api/vi#vi-runonlypendingtimersasync
  summary: This method will asynchronously call every timer that was initiated after vi.useFakeTimers call, even asynchronous ones
  belongs_to: Vi
  description: |-
    ### vi.runOnlyPendingTimersAsync

    - **Type:** `() => Promise<Vitest>`

    This method will asynchronously call every timer that was initiated after [`vi.useFakeTimers`](#vi-usefaketimers) call, even asynchronous ones. It will not fire any timer that was initiated during its call.

    ts

    ``` javascript
    setTimeout(() => {
      console.log(1)
    }, 100)
    setTimeout(() => {
      Promise.resolve().then(() => {
        console.log(2)
        setInterval(() => {
          console.log(3)
        }, 40)
      })
    }, 10)

    await vi.runOnlyPendingTimersAsync()

    // log: 2
    // log: 3
    // log: 3
    // log: 1
    ```
- name: vi.setConfig ​
  id: api/vi#vi-setconfig
  summary: Updates config for the current test file
  belongs_to: Vi
  description: |-
    ### vi.setConfig

    - **Type**: `RuntimeConfig`

    Updates config for the current test file. This method supports only config options that will affect the current test file:

    ts

    ``` javascript
    vi.setConfig({
      allowOnly: true,
      testTimeout: 10_000,
      hookTimeout: 10_000,
      clearMocks: true,
      restoreMocks: true,
      fakeTimers: {
        now: new Date(2021, 11, 19),
        // supports the whole object
      },
      maxConcurrency: 10,
      sequence: {
        hooks: 'stack'
        // supports only "sequence.hooks"
      }
    })
    ```
- name: vi.setSystemTime ​
  id: api/vi#vi-setsystemtime
  summary: If fake timers are enabled, this method simulates a user changing the system clock (will affect date related API like hrtime, performance.now or new Date()) - however, it will not fire any timers
  belongs_to: Vi
  description: |-
    ### vi.setSystemTime

    - **Type**: `(date: string | number | Date) => void`

    If fake timers are enabled, this method simulates a user changing the system clock (will affect date related API like `hrtime`, `performance.now` or `new Date()`) - however, it will not fire any timers. If fake timers are not enabled, this method will only mock `Date.*` calls.

    Useful if you need to test anything that depends on the current date - for example [Luxon](https://github.com/moment/luxon/) calls inside your code.

    ts

    ``` javascript
    const date = new Date(1998, 11, 19)

    vi.useFakeTimers()
    vi.setSystemTime(date)

    expect(Date.now()).toBe(date.valueOf())

    vi.useRealTimers()
    ```
- name: vi.spyOn ​
  id: api/vi#vi-spyon
  summary: Creates a spy on a method or getter/setter of an object similar to vi.fn()
  belongs_to: Vi
  description: |-
    ### vi.spyOn

    - **Type:** `<T, K extends keyof T>(object: T, method: K, accessType?: 'get' | 'set') => MockInstance`

    Creates a spy on a method or getter/setter of an object similar to [`vi.fn()`](#vi-fn). It returns a [mock function](mock).

    ts

    ``` javascript
    let apples = 0
    const cart = {
      getApples: () => 42,
    }

    const spy = vi.spyOn(cart, 'getApples').mockImplementation(() => apples)
    apples = 1

    expect(cart.getApples()).toBe(1)

    expect(spy).toHaveBeenCalled()
    expect(spy).toHaveReturnedWith(1)
    ```

    **TIP**

    You can call [`vi.restoreAllMocks`](#vi-restoreallmocks) inside [`afterEach`](index#aftereach) (or enable [`test.restoreMocks`](../config/index#restoreMocks)) to restore all methods to their original implementations. This will restore the original [object descriptor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty), so you won't be able to change method's implementation:

    ts

    ``` javascript
    const cart = {
      getApples: () => 42,
    }

    const spy = vi.spyOn(cart, 'getApples').mockReturnValue(10)

    console.log(cart.getApples()) // 10
    vi.restoreAllMocks()
    console.log(cart.getApples()) // 42
    spy.mockReturnValue(10)
    console.log(cart.getApples()) // still 42!
    ```
- name: vi.stubEnv ​
  id: api/vi#vi-stubenv
  summary: Changes the value of environmental variable on process.env and import.meta.env
  belongs_to: Vi
  description: |-
    ### vi.stubEnv

    - **Type:** `(name: string, value: string) => Vitest`

    Changes the value of environmental variable on `process.env` and `import.meta.env`. You can restore its value by calling `vi.unstubAllEnvs`.

    ts

    ``` javascript
    import { vi } from 'vitest'

    // `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`
    // are "development" before calling "vi.stubEnv"

    vi.stubEnv('NODE_ENV', 'production')

    process.env.NODE_ENV === 'production'
    import.meta.env.NODE_ENV === 'production'
    // doesn't change other envs
    import.meta.env.MODE === 'development'
    ```

    **TIP**

    You can also change the value by simply assigning it, but you won't be able to use `vi.unstubAllEnvs` to restore previous value:

    ts

    ``` javascript
    import.meta.env.MODE = 'test'
    ```
- name: vi.stubGlobal ​
  id: api/vi#vi-stubglobal
  summary: Changes the value of global variable
  belongs_to: Vi
  description: |-
    ### vi.stubGlobal

    - **Type:** `(name: string | number | symbol, value: unknown) => Vitest`

    Changes the value of global variable. You can restore its original value by calling `vi.unstubAllGlobals`.

    ts

    ``` javascript
    import { vi } from 'vitest'

    // `innerWidth` is "0" before calling stubGlobal

    vi.stubGlobal('innerWidth', 100)

    innerWidth === 100
    globalThis.innerWidth === 100
    // if you are using jsdom or happy-dom
    window.innerWidth === 100
    ```

    **TIP**

    You can also change the value by simply assigning it to `globalThis` or `window` (if you are using `jsdom` or `happy-dom` environment), but you won't be able to use `vi.unstubAllGlobals` to restore original value:

    ts

    ``` javascript
    globalThis.innerWidth = 100
    // if you are using jsdom or happy-dom
    window.innerWidth = 100
    ```
- name: vi.unmock ​
  id: api/vi#vi-unmock
  summary: Removes module from the mocked registry
  belongs_to: Vi
  description: |-
    ### vi.unmock

    - **Type**: `(path: string) => void`

    Removes module from the mocked registry. All calls to import will return the original module even if it was mocked before. This call is hoisted to the top of the file, so it will only unmock modules that were defined in `setupFiles`, for example.
- name: vi.unstubAllEnvs ​
  id: api/vi#vi-unstuballenvs
  summary: Restores all import.meta.env and process.env values that were changed with vi.stubEnv
  belongs_to: Vi
  description: |-
    ### vi.unstubAllEnvs

    - **Type:** `() => Vitest`

    Restores all `import.meta.env` and `process.env` values that were changed with `vi.stubEnv`. When it's called for the first time, Vitest remembers the original value and will store it, until `unstubAllEnvs` is called again.

    ts

    ``` javascript
    import { vi } from 'vitest'

    // `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`
    // are "development" before calling stubEnv

    vi.stubEnv('NODE_ENV', 'production')

    process.env.NODE_ENV === 'production'
    import.meta.env.NODE_ENV === 'production'

    vi.stubEnv('NODE_ENV', 'staging')

    process.env.NODE_ENV === 'staging'
    import.meta.env.NODE_ENV === 'staging'

    vi.unstubAllEnvs()

    // restores to the value that were stored before the first "stubEnv" call
    process.env.NODE_ENV === 'development'
    import.meta.env.NODE_ENV === 'development'
    ```
- name: vi.unstubAllGlobals ​
  id: api/vi#vi-unstuballglobals
  summary: Restores all global values on globalThis/global (and window/top/self/parent, if you are using jsdom or happy-dom environment) that were changed with vi.stubGlobal
  belongs_to: Vi
  description: |-
    ### vi.unstubAllGlobals

    - **Type:** `() => Vitest`

    Restores all global values on `globalThis`/`global` (and `window`/`top`/`self`/`parent`, if you are using `jsdom` or `happy-dom` environment) that were changed with `vi.stubGlobal`. When it's called for the first time, Vitest remembers the original value and will store it, until `unstubAllGlobals` is called again.

    ts

    ``` javascript
    import { vi } from 'vitest'

    const Mock = vi.fn()

    // IntersectionObserver is "undefined" before calling "stubGlobal"

    vi.stubGlobal('IntersectionObserver', Mock)

    IntersectionObserver === Mock
    global.IntersectionObserver === Mock
    globalThis.IntersectionObserver === Mock
    // if you are using jsdom or happy-dom
    window.IntersectionObserver === Mock

    vi.unstubAllGlobals()

    globalThis.IntersectionObserver === undefined
    'IntersectionObserver' in globalThis === false
    // throws ReferenceError, because it's not defined
    IntersectionObserver === undefined
    ```
- name: vi.useFakeTimers ​
  id: api/vi#vi-usefaketimers
  summary: To enable mocking timers, you need to call this method
  belongs_to: Vi
  description: |-
    ### vi.useFakeTimers

    - **Type:** `(config?: FakeTimerInstallOpts) => Vitest`

    To enable mocking timers, you need to call this method. It will wrap all further calls to timers (such as `setTimeout`, `setInterval`, `clearTimeout`, `clearInterval`, `setImmediate`, `clearImmediate`, and `Date`) until [`vi.useRealTimers()`](#vi-userealtimers) is called.

    Mocking `nextTick` is not supported when running Vitest inside `node:child_process` by using `--pool=forks`. NodeJS uses `process.nextTick` internally in `node:child_process` and hangs when it is mocked. Mocking `nextTick` is supported when running Vitest with `--pool=threads`.

    The implementation is based internally on [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).

    **TIP**

    `vi.useFakeTimers()` does not automatically mock `process.nextTick`. But you can enable it by specifying the option in `toFake` argument: `vi.useFakeTimers({ toFake: ['nextTick'] })`.
- name: vi.useRealTimers ​
  id: api/vi#vi-userealtimers
  summary: When timers are run out, you may call this method to return mocked timers to its original implementations
  belongs_to: Vi
  description: |-
    ### vi.useRealTimers

    - **Type:** `() => Vitest`

    When timers are run out, you may call this method to return mocked timers to its original implementations. All timers that were scheduled before will be discarded.
- name: vi.waitFor ​
  id: api/vi#vi-waitfor
  summary: Wait for the callback to execute successfully
  belongs_to: Vi
  description: |-
    ### vi.waitFor

    - **Type:** `<T>(callback: WaitForCallback<T>, options?: number | WaitForOptions) => Promise<T>`

    Wait for the callback to execute successfully. If the callback throws an error or returns a rejected promise it will continue to wait until it succeeds or times out.

    This is very useful when you need to wait for some asynchronous action to complete, for example, when you start a server and need to wait for it to start.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'
    import { createServer } from './server.js'

    test('Server started successfully', async () => {
      const server = createServer()

      await vi.waitFor(
        () => {
          if (!server.isReady) {
            throw new Error('Server not started')
          }

          console.log('Server started')
        },
        {
          timeout: 500, // default is 1000
          interval: 20, // default is 50
        }
      )
      expect(server.isReady).toBe(true)
    })
    ```

    It also works for asynchronous callbacks

    ts

    ``` javascript
    // @vitest-environment jsdom

    import { expect, test, vi } from 'vitest'
    import { getDOMElementAsync, populateDOMAsync } from './dom.js'

    test('Element exists in a DOM', async () => {
      // start populating DOM
      populateDOMAsync()

      const element = await vi.waitFor(async () => {
        // try to get the element until it exists
        const element = await getDOMElementAsync() as HTMLElement | null
        expect(element).toBeTruthy()
        expect(element.dataset.initialized).toBeTruthy()
        return element
      }, {
        timeout: 500, // default is 1000
        interval: 20, // default is 50
      })
      expect(element).toBeInstanceOf(HTMLElement)
    })
    ```

    If `vi.useFakeTimers` is used, `vi.waitFor` automatically calls `vi.advanceTimersByTime(interval)` in every check callback.
- name: vi.waitUntil ​
  id: api/vi#vi-waituntil
  summary: This is similar to vi.waitFor, but if the callback throws any errors, execution is immediately interrupted and an error message is received
  belongs_to: Vi
  description: |-
    ### vi.waitUntil

    - **Type:** `<T>(callback: WaitUntilCallback<T>, options?: number | WaitUntilOptions) => Promise<T>`

    This is similar to `vi.waitFor`, but if the callback throws any errors, execution is immediately interrupted and an error message is received. If the callback returns falsy value, the next check will continue until truthy value is returned. This is useful when you need to wait for something to exist before taking the next step.

    Look at the example below. We can use `vi.waitUntil` to wait for the element to appear on the page, and then we can do something with the element.

    ts

    ``` javascript
    import { expect, test, vi } from 'vitest'

    test('Element render correctly', async () => {
      const element = await vi.waitUntil(
        () => document.querySelector('.element'),
        {
          timeout: 500, // default is 1000
          interval: 20, // default is 50
        }
      )

      // do something with the element
      expect(element.querySelector('.element-child')).toBeTruthy()
    })
    ```
- name: Vitest UI
  id: guide/ui
  summary: Powered by Vite, Vitest also has a dev server under the hood when running the tests
  description: "# Vitest UI\n\nPowered by Vite, Vitest also has a dev server under the hood when running the tests. This allows Vitest to provide a beautiful UI to view and interact with your tests. The Vitest UI is optional, so you'll need to install it with:\n\nbash\n\n``` javascript\nnpm i -D @vitest/ui\n```\n\nThen you can start the tests with UI by passing the `--ui` flag:\n\nbash\n\n``` javascript\nvitest --ui\n```\n\nThen you can visit the Vitest UI at [`http://localhost:51204/__vitest__/`](http://localhost:51204/__vitest__/)\n\nUI can also be used as a reporter. Use `'html'` reporter in your Vitest configuration to generate HTML output and preview the results of your tests:\n\nts\n\n``` javascript\n// vitest.config.ts\n\nexport default {\n  test: {\n    reporters: ['html']\n  }\n}\n```\n\nYou can check your coverage report in Vitest UI: see [Vitest UI Coverage](coverage#vitest-ui) for more details.\n\n**WARNING**\n\nIf you still want to see how your tests are running in real time in the terminal, don't forget to add `default` reporter to `reporters` option: `['default', 'html']`.\n\n**TIP**\n\nTo preview your HTML report, you can use the [vite preview](https://vitejs.dev/guide/cli#vite-preview) command:\n\nsh\n\n``` javascript\nnpx vite preview --outDir ./html\n```\n\nYou can configure output with [`outputFile`](../config/index#outputfile) config option. You need to specify `.html` path there. For example, `./html/index.html` is the default value.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/ui](https://vitest.dev/guide/ui)"
- name: watch *  ​
  id: config/index#watch
  summary: null
  belongs_to: Configuring Vitest
  description: "### watch \\* \n\n- **Type:** `boolean`\n- **Default:** `!process.env.CI`\n- **CLI:**`-w`, `--watch`, `--watch=false`\n\nEnable watch mode"
- name: Why Vitest
  id: guide/why
  summary: This guide assumes that you are familiar with Vite
  description: "# Why Vitest\n\n**NOTE**\n\nThis guide assumes that you are familiar with Vite. A good way to start learning more is to read the [Why Vite Guide](https://vitejs.dev/guide/why), and [Next generation frontend tooling with ViteJS](https://www.youtube.com/watch?v=UJypSr8IhKY), a stream where [Evan You](https://twitter.com/youyuxi) did a demo explaining the main concepts.\n\n## The Need for a Vite Native Test Runner\n\nVite's out-of-the-box support for common web patterns, features like glob imports and SSR primitives, and its many plugins and integrations are fostering a vibrant ecosystem. Its dev and build story are key to its success. For docs, there are several SSG-based alternatives powered by Vite. Vite's Unit Testing story hasn't been clear though. Existing options like [Jest](https://jestjs.io/) were created in a different context. There is a lot of duplication between Jest and Vite, forcing users to configure two different pipelines.\n\nUsing Vite dev server to transform your files during testing, enables the creation of a simple runner that doesn't need to deal with the complexity of transforming source files and can solely focus on providing the best DX during testing. A test runner that uses the same configuration of your App (through `vite.config.js`), sharing a common transformation pipeline during dev, build, and test time. That is extensible with the same plugin API that lets you and the maintainers of your tools provide first-class integration with Vite. A tool that is built with Vite in mind from the start, taking advantage of its improvements in DX, like its instant Hot Module Reload (HMR). This is Vitest, a next generation testing framework powered by Vite.\n\nGiven Jest's massive adoption, Vitest provides a compatible API that allows you to use it as a drop-in replacement in most projects. It also includes the most common features required when setting up your unit tests (mocking, snapshots, coverage). Vitest cares a lot about performance and uses Worker threads to run as much as possible in parallel. Some ports have seen test running an order of magnitude faster. Watch mode is enabled by default, aligning itself with the way Vite pushes for a dev first experience. Even with all these improvements in DX, Vitest stays lightweight by carefully choosing its dependencies (or directly inlining needed pieces).\n\n**Vitest aims to position itself as the Test Runner of choice for Vite projects, and as a solid alternative even for projects not using Vite.**\n\nContinue reading in the [Getting Started Guide](index)\n\n## How is Vitest Different from X?\n\nYou can check out the [Comparisons](comparisons) section for more details on how Vitest differs from other similar tools.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/why](https://vitest.dev/guide/why)"
- name: 'Why Vitest: How is Vitest Different from X? ​'
  id: guide/why#how-is-vitest-different-from-x
  summary: You can check out the Comparisons section for more details on how Vitest differs from other similar tools
  belongs_to: Why Vitest
  description: "## How is Vitest Different from X?\n\nYou can check out the [Comparisons](comparisons) section for more details on how Vitest differs from other similar tools.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/why](https://vitest.dev/guide/why)"
- name: 'Why Vitest: The Need for a Vite Native Test Runner ​'
  id: guide/why#the-need-for-a-vite-native-test-runner
  summary: Vite's out-of-the-box support for common web patterns, features like glob imports and SSR primitives, and its many plugins and integrations are fostering a vibrant ecosystem
  belongs_to: Why Vitest
  description: |-
    ## The Need for a Vite Native Test Runner

    Vite's out-of-the-box support for common web patterns, features like glob imports and SSR primitives, and its many plugins and integrations are fostering a vibrant ecosystem. Its dev and build story are key to its success. For docs, there are several SSG-based alternatives powered by Vite. Vite's Unit Testing story hasn't been clear though. Existing options like [Jest](https://jestjs.io/) were created in a different context. There is a lot of duplication between Jest and Vite, forcing users to configure two different pipelines.

    Using Vite dev server to transform your files during testing, enables the creation of a simple runner that doesn't need to deal with the complexity of transforming source files and can solely focus on providing the best DX during testing. A test runner that uses the same configuration of your App (through `vite.config.js`), sharing a common transformation pipeline during dev, build, and test time. That is extensible with the same plugin API that lets you and the maintainers of your tools provide first-class integration with Vite. A tool that is built with Vite in mind from the start, taking advantage of its improvements in DX, like its instant Hot Module Reload (HMR). This is Vitest, a next generation testing framework powered by Vite.

    Given Jest's massive adoption, Vitest provides a compatible API that allows you to use it as a drop-in replacement in most projects. It also includes the most common features required when setting up your unit tests (mocking, snapshots, coverage). Vitest cares a lot about performance and uses Worker threads to run as much as possible in parallel. Some ports have seen test running an order of magnitude faster. Watch mode is enabled by default, aligning itself with the way Vite pushes for a dev first experience. Even with all these improvements in DX, Vitest stays lightweight by carefully choosing its dependencies (or directly inlining needed pieces).

    **Vitest aims to position itself as the Test Runner of choice for Vite projects, and as a solid alternative even for projects not using Vite.**

    Continue reading in the [Getting Started Guide](index)
- name: withImplementation ​
  id: api/mock#withimplementation
  summary: Overrides the original mock implementation temporarily while the callback is being executed
  belongs_to: Mock Functions
  description: |-
    ## withImplementation

    - **Type:** `(fn: Function, callback: () => void) => MockInstance`
    - **Type:** `(fn: Function, callback: () => Promise<unknown>) => Promise<MockInstance>`

    Overrides the original mock implementation temporarily while the callback is being executed.

    js

    ``` javascript
    const myMockFn = vi.fn(() => 'original')

    myMockFn.withImplementation(() => 'temp', () => {
      myMockFn() // 'temp'
    })

    myMockFn() // 'original'
    ```

    Can be used with an asynchronous callback. The method has to be awaited to use the original implementation afterward.

    ts

    ``` javascript
    test('async callback', () => {
      const myMockFn = vi.fn(() => 'original')

      // We await this call since the callback is async
      await myMockFn.withImplementation(
        () => 'temp',
        async () => {
          myMockFn() // 'temp'
        },
      )

      myMockFn() // 'original'
    })
    ```

    Note that this method takes precedence over the [`mockImplementationOnce`](#mockimplementationonce).
- name: Workspace
  id: guide/workspace
  summary: Vitest provides built-in support for monorepos through a workspace configuration file
  description: "# Workspace\n\n**Sample Project**\n\n[GitHub](https://github.com/vitest-dev/vitest/tree/main/examples/workspace) - [Play Online](https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/workspace?initialPath=__vitest__/)\n\nVitest provides built-in support for monorepos through a workspace configuration file. You can create a workspace to define your project's setups.\n\n## Defining a Workspace\n\nA workspace should have a `vitest.workspace` or `vitest.projects` file in its root (in the same folder as your config file if you have one). Vitest supports `ts`/`js`/`json` extensions for this file.\n\nWorkspace configuration file should have a default export with a list of files or glob patterns referencing your projects. For example, if you have a folder named `packages` that contains your projects, you can define a workspace with this config file:\n\nvitest.workspace.ts\n\nts\n\n``` javascript\nexport default [\n  'packages/*'\n]\n```\n\nVitest will consider every folder in `packages` as a separate project even if it doesn't have a config file inside.\n\n**WARNING**\n\nVitest will not consider the root config as a workspace project (so it will not run tests specified in `include`) unless it is specified in this config.\n\nYou can also reference projects with their config files:\n\nvitest.workspace.ts\n\nts\n\n``` javascript\nexport default [\n  'packages/*/vitest.config.{e2e,unit}.ts'\n]\n```\n\nThis pattern will only include projects with `vitest.config` file that includes `e2e` and `unit` before the extension.\n\n**WARNING**\n\nIf you are referencing filenames with glob pattern, make sure your config file starts with `vite.config` or `vitest.config`. Otherwise Vitest will skip it.\n\nYou can also define projects with inline config. Workspace file supports using both syntaxes at the same time.\n\nvitest.workspace.ts\n\nts\n\n``` javascript\nimport { defineWorkspace } from 'vitest/config'\n\n// defineWorkspace provides a nice type hinting DX\nexport default defineWorkspace([\n  'packages/*',\n  {\n    // add \"extends\" to merge two configs together\n    extends: './vite.config.js',\n    test: {\n      include: ['tests/**/*.{browser}.test.{ts,js}'],\n      // it is recommended to define a name when using inline configs\n      name: 'happy-dom',\n      environment: 'happy-dom',\n    }\n  },\n  {\n    test: {\n      include: ['tests/**/*.{node}.test.{ts,js}'],\n      name: 'node',\n      environment: 'node',\n    }\n  }\n])\n```\n\n**WARNING**\n\nAll projects should have unique names. Otherwise, Vitest will throw an error. If you do not provide a name inside the inline config, Vitest will assign a number. If you don't provide a name inside a project config defined with glob syntax, Vitest will use the directory name by default.\n\nIf you don't rely on inline configs, you can just create a small json file in your root directory:\n\nvitest.workspace.json\n\njson\n\n``` javascript\n[\n  \"packages/*\"\n]\n```\n\nWorkspace projects don't support all configuration properties. For better type safety, use `defineProject` instead of `defineConfig` method inside project configuration files:\n\npackages/a/vitest.config.ts\n\nts\n\n``` javascript\nimport { defineProject } from 'vitest/config'\n\nexport default defineProject({\n  test: {\n    environment: 'jsdom',\n    // \"reporters\" is not supported in a project config,\n    // so it will show an error\n    reporters: ['json']\n  }\n})\n```\n\n## Running tests\n\nTo run tests inside the workspace, define a script in your root `package.json`:\n\njson\n\n``` javascript\n{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n```\n\nNow tests can be run using your package manager:\n\nnpmyarnpnpmbun\n\nbash\n\n``` javascript\nnpm run test\n```\n\nbash\n\n``` javascript\nyarn test\n```\n\nbash\n\n``` javascript\npnpm run test\n```\n\nbash\n\n``` javascript\nbun test\n```\n\nIf you need to run tests only inside a single project, use the `--project` CLI option:\n\nbash\n\n``` javascript\nnpm run test --project e2e\n```\n\n**TIP**\n\nCLI option `--project` can be used multiple times to filter out several projects:\n\nbash\n\n``` javascript\nnpm run test --project e2e --project unit\n```\n\n## Configuration\n\nNone of the configuration options are inherited from the root-level config file. You can create a shared config file and merge it with the project config yourself:\n\npackages/a/vitest.config.ts\n\nts\n\n``` javascript\nimport { defineProject, mergeConfig } from 'vitest/config'\nimport configShared from '../vitest.shared.js'\n\nexport default mergeConfig(\n  configShared,\n  defineProject({\n    test: {\n      environment: 'jsdom',\n    }\n  })\n)\n```\n\nAlso, some of the configuration options are not allowed in a project config. Most notably:\n\n- `coverage`: coverage is done for the whole workspace\n- `reporters`: only root-level reporters can be supported\n- `resolveSnapshotPath`: only root-level resolver is respected\n- all other options that don't affect test runners\n\n**TIP**\n\nAll configuration options that are not supported inside a project config have \\* sign next them in [\"Config\"](../config/index) page.\n\n## Coverage\n\nCoverage for workspace projects works out of the box. But if you have [`all`](../config/index#coverage-all) option enabled and use non-conventional extensions in some of your projects, you will need to have a plugin that handles this extension in your root configuration file.\n\nFor example, if you have a package that uses Vue files and it has its own config file, but some of the files are not imported in your tests, coverage will fail trying to analyze the usage of unused files, because it relies on the root configuration rather than project configuration.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/workspace](https://vitest.dev/guide/workspace)"
- name: workspace *  ​
  id: config/index#workspace
  summary: Path to a workspace config file relative to root
  belongs_to: Configuring Vitest
  description: "### workspace \\* \n\n- **Type:** `string`\n- **CLI:** `--workspace=./file.js`\n- **Default:**`vitest.{workspace,projects}.{js,ts,json}` close to the config file or root\n\nPath to a [workspace](../guide/workspace) config file relative to [root](#root)."
- name: 'Workspace: Configuration ​'
  id: guide/workspace#configuration
  summary: None of the configuration options are inherited from the root-level config file
  belongs_to: Workspace
  description: |-
    ## Configuration

    None of the configuration options are inherited from the root-level config file. You can create a shared config file and merge it with the project config yourself:

    packages/a/vitest.config.ts

    ts

    ``` javascript
    import { defineProject, mergeConfig } from 'vitest/config'
    import configShared from '../vitest.shared.js'

    export default mergeConfig(
      configShared,
      defineProject({
        test: {
          environment: 'jsdom',
        }
      })
    )
    ```

    Also, some of the configuration options are not allowed in a project config. Most notably:

    - `coverage`: coverage is done for the whole workspace
    - `reporters`: only root-level reporters can be supported
    - `resolveSnapshotPath`: only root-level resolver is respected
    - all other options that don't affect test runners

    **TIP**

    All configuration options that are not supported inside a project config have \* sign next them in ["Config"](../config/index) page.
- name: 'Workspace: Coverage ​'
  id: guide/workspace#coverage
  summary: Coverage for workspace projects works out of the box
  belongs_to: Workspace
  description: "## Coverage\n\nCoverage for workspace projects works out of the box. But if you have [`all`](../config/index#coverage-all) option enabled and use non-conventional extensions in some of your projects, you will need to have a plugin that handles this extension in your root configuration file.\n\nFor example, if you have a package that uses Vue files and it has its own config file, but some of the files are not imported in your tests, coverage will fail trying to analyze the usage of unused files, because it relies on the root configuration rather than project configuration.\n\n© 2021-Present Anthony Fu  \n© 2021-Present Matias Capeletto  \nLicensed under the MIT License.  \n[https://vitest.dev/guide/workspace](https://vitest.dev/guide/workspace)"
- name: 'Workspace: Defining a Workspace ​'
  id: guide/workspace#defining-a-workspace
  summary: A workspace should have a vitest.workspace or vitest.projects file in its root (in the same folder as your config file if you have one)
  belongs_to: Workspace
  description: |-
    ## Defining a Workspace

    A workspace should have a `vitest.workspace` or `vitest.projects` file in its root (in the same folder as your config file if you have one). Vitest supports `ts`/`js`/`json` extensions for this file.

    Workspace configuration file should have a default export with a list of files or glob patterns referencing your projects. For example, if you have a folder named `packages` that contains your projects, you can define a workspace with this config file:

    vitest.workspace.ts

    ts

    ``` javascript
    export default [
      'packages/*'
    ]
    ```

    Vitest will consider every folder in `packages` as a separate project even if it doesn't have a config file inside.

    **WARNING**

    Vitest will not consider the root config as a workspace project (so it will not run tests specified in `include`) unless it is specified in this config.

    You can also reference projects with their config files:

    vitest.workspace.ts

    ts

    ``` javascript
    export default [
      'packages/*/vitest.config.{e2e,unit}.ts'
    ]
    ```

    This pattern will only include projects with `vitest.config` file that includes `e2e` and `unit` before the extension.

    **WARNING**

    If you are referencing filenames with glob pattern, make sure your config file starts with `vite.config` or `vitest.config`. Otherwise Vitest will skip it.

    You can also define projects with inline config. Workspace file supports using both syntaxes at the same time.

    vitest.workspace.ts

    ts

    ``` javascript
    import { defineWorkspace } from 'vitest/config'

    // defineWorkspace provides a nice type hinting DX
    export default defineWorkspace([
      'packages/*',
      {
        // add "extends" to merge two configs together
        extends: './vite.config.js',
        test: {
          include: ['tests/**/*.{browser}.test.{ts,js}'],
          // it is recommended to define a name when using inline configs
          name: 'happy-dom',
          environment: 'happy-dom',
        }
      },
      {
        test: {
          include: ['tests/**/*.{node}.test.{ts,js}'],
          name: 'node',
          environment: 'node',
        }
      }
    ])
    ```

    **WARNING**

    All projects should have unique names. Otherwise, Vitest will throw an error. If you do not provide a name inside the inline config, Vitest will assign a number. If you don't provide a name inside a project config defined with glob syntax, Vitest will use the directory name by default.

    If you don't rely on inline configs, you can just create a small json file in your root directory:

    vitest.workspace.json

    json

    ``` javascript
    [
      "packages/*"
    ]
    ```

    Workspace projects don't support all configuration properties. For better type safety, use `defineProject` instead of `defineConfig` method inside project configuration files:

    packages/a/vitest.config.ts

    ts

    ``` javascript
    import { defineProject } from 'vitest/config'

    export default defineProject({
      test: {
        environment: 'jsdom',
        // "reporters" is not supported in a project config,
        // so it will show an error
        reporters: ['json']
      }
    })
    ```
- name: 'Workspace: Running tests ​'
  id: guide/workspace#running-tests
  summary: null
  belongs_to: Workspace
  description: |-
    ## Running tests

    To run tests inside the workspace, define a script in your root `package.json`:

    json

    ``` javascript
    {
      "scripts": {
        "test": "vitest"
      }
    }
    ```

    Now tests can be run using your package manager:

    npm yarn pnpm bun

    bash

    ``` javascript
    npm run test
    ```

    bash

    ``` javascript
    yarn test
    ```

    bash

    ``` javascript
    pnpm run test
    ```

    bash

    ``` javascript
    bun test
    ```

    If you need to run tests only inside a single project, use the `--project` CLI option:

    bash

    ``` javascript
    npm run test --project e2e
    ```

    **TIP**

    CLI option `--project` can be used multiple times to filter out several projects:

    bash

    ``` javascript
    npm run test --project e2e --project unit
    ```
