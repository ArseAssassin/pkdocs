---
name: Yarn
slug: yarn~berry
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: Berry
copyright: |-
  © 2016–present Yarn Contributors
  Licensed under the BSD License.
  https://yarnpkg.com/
homepage: https://yarnpkg.com/

---
- name: 1. Introduction
  id: getting-started
  summary: Yarn is a package manager for your code
  description: "# 1. Introduction\n\nYarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don't ever have to worry.\n\nYarn allows you to use other developers' solutions to different problems, making it easier for you to develop your software. If you have problems, you can report issues or contribute back on [GitHub](https://github.com/yarnpkg/berry), and when the problem is fixed, you can use Yarn to keep it all up to date.\n\nCode is shared through something called a **package**. A package contains all the code being shared as well as a `package.json` file (called a **manifest**) which describes the package.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started](https://yarnpkg.com/getting-started)"
- name: 2. Installation
  id: getting-started/install
  summary: The preferred way to manage Yarn is through Corepack, a new binary shipped with all Node.js releases starting from 16.10
  description: "# 2. Installation\n\n## Install Corepack\n\nThe preferred way to manage Yarn is through [Corepack](https://nodejs.org/dist/latest/docs/api/corepack.html), a new binary shipped with all Node.js releases starting from 16.10. It acts as an intermediary between you and Yarn, and lets you use different package manager versions across multiple projects without having to check-in the Yarn binary anymore.\n\n### Node.js \\>=16.10\n\nCorepack is included by default with all Node.js installs, but is currently opt-in. To enable it, run the following command:\n\n``` language-bash\ncorepack enable\n```\n\n### Node.js \\<16.10\n\nCorepack isn't included with Node.js in versions before the 16.10; to address that, run:\n\n``` language-bash\nnpm i -g corepack\n```\n\n## Initializing your project\n\nJust run the following command. It will generate some files inside your current directory; add them all to your next commit, and you'll be done!\n\n``` language-bash\nyarn init -2\n```\n\n> **Note:** By default, `yarn init -2` will setup your project to be compatible with [Zero-Installs](../features/zero-installs), which requires checking-in your cache in your repository; check your [`.gitignore`](qa#which-files-should-be-gitignored) if you wish to disable this.\n\n> **Note:** In case you're migrating from Yarn 1.x and hit a blocker, you might want to take a look at our [Migration Guide](migration). It isn't always needed, but a fairly comprehensive resource of how to solve issues that may arise in the transition.\n\n## Updating to the latest versions\n\nAny time you'll want to update Yarn to the latest version, just run:\n\n``` language-bash\nyarn set version stable\n```\n\nYarn will then configure your project to use the most recent stable binary. Don't forget to run a new install to update your artifacts before committing the results!\n\n## Installing the latest build fresh from master\n\nFrom time to time even the most recent releases aren't enough, and you then will want to try out the very latest master branch to check if a bug has been fixed. This has become very simple! Just run the following command:\n\n``` language-bash\nyarn set version from sources\n```\n\nSimilarly, specific PRs can be installed using the `--branch` flag:\n\n``` language-bash\nyarn set version from sources --branch 1211\n```\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started/install](https://yarnpkg.com/getting-started/install)"
- name: 3. Usage
  id: getting-started/usage
  summary: Now that you have Yarn installed, you can start using it! Here are some of the most common commands you'll need
  description: "# 3. Usage\n\nNow that you have Yarn [installed](install), you can start using it! Here are some of the most common commands you'll need.\n\n> **Migrating from Yarn 1**\n>\n> We've been compiling helpful advice when porting over from Yarn 1 on the following [Migration Guide](migration). Give it a look and contribute to it if you see things that aren't covered yet! Make sure to consult the [PnP Compatibility Table](../features/pnp#compatibility-table) and [enable the node-modules plugin](migration#if-required-enable-the-node-modules-plugin) if required!\n\n- [Accessing the list of commands](#accessing-the-list-of-commands)\n- [Starting a new project](#starting-a-new-project)\n- [Installing all the dependencies](#installing-all-the-dependencies)\n- [Adding a dependency](#adding-a-dependency)\n- [Adding a dependency to different categories of dependencies](#adding-a-dependency-to-different-categories-of-dependencies)\n- [Upgrading a dependency](#upgrading-a-dependency)\n- [Removing a dependency](#removing-a-dependency)\n- [Upgrading Yarn itself](#upgrading-yarn-itself)\n\n### Accessing the list of commands\n\n``` language-bash\nyarn help\n```\n\n### Starting a new project\n\n``` language-bash\nyarn init\n```\n\n### Installing all the dependencies\n\n``` language-bash\nyarn\nyarn install\n```\n\n### Adding a dependency\n\n``` language-bash\nyarn add [package]\nyarn add [package]@[version]\nyarn add [package]@[tag]\n```\n\n### Adding a dependency to different categories of dependencies\n\n``` language-bash\nyarn add [package] --dev  # dev dependencies\nyarn add [package] --peer # peer dependencies\n```\n\n### Upgrading a dependency\n\n``` language-bash\nyarn up [package]\nyarn up [package]@[version]\nyarn up [package]@[tag]\n```\n\n### Removing a dependency\n\n``` language-bash\nyarn remove [package]\n```\n\n### Upgrading Yarn itself\n\n``` language-bash\nyarn set version latest\nyarn set version from sources\n```\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started/usage](https://yarnpkg.com/getting-started/usage)"
- name: 4. Editor SDKs
  id: getting-started/editor-sdks
  summary: Smart IDEs (such as VSCode or IntelliJ) require special configuration for TypeScript to work when using Plug'n'Play installs
  description: "# 4. Editor SDKs\n\nSmart IDEs (such as VSCode or IntelliJ) require special configuration for TypeScript to work when using [Plug'n'Play installs](../features/pnp). This page intends to be a collection of settings for each editor we've worked with - please contribute to this list!\n\nThe editor SDKs and settings can be generated using `yarn dlx @yarnpkg/sdks` (or `yarn sdks` if you added `@yarnpkg/sdks` to your dependencies). Its detailed documentation can be found on the [dedicated page](../sdks/cli/default). Generally speaking:\n\n- Use `yarn sdks vscode vim` to generate both the base SDKs and the settings for the specified supported editors.\n- Use `yarn sdks base` to generate the base SDKs and then manually tweak the configuration of unsupported editors.\n- Use `yarn sdks` to update all installed SDKs and editor settings.\n\n------------------------------------------------------------------------\n\n- [Tools currently supported](#tools-currently-supported)\n\n- [Editor setup](#editor-setup)\n\n  - [VSCode](#vscode)\n\n  - [VIM](#vim)\n\n    - [coc.nvim](#cocnvim)\n\n    - [Neovim Native LSP](#neovim-native-lsp)\n\n      - [Supporting go-to-definition et al.](#supporting-go-to-definition-et-al)\n\n  - [Emacs](#emacs)\n\n- [Caveat](#caveat)\n\n## Tools currently supported\n\n> **Note:** Be aware that only the SDKs for the tools present in your *root* package.json will be installed (the tool won't look at the dependencies from your other workspaces). So don't forget to run the command again should you change the set of tools used by your project!\n\n| Extension                                                                                          | Required `package.json` dependency                   |\n|----------------------------------------------------------------------------------------------------|------------------------------------------------------|\n| Builtin VSCode TypeScript Server                                                                   | [typescript](https://yarnpkg.com/package/typescript) |\n| [vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)        | [eslint](https://yarnpkg.com/package/eslint)         |\n| [prettier-vscode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)      | [prettier](https://yarnpkg.com/package/prettier)     |\n| [vscode-stylelint](https://marketplace.visualstudio.com/items?itemName=stylelint.vscode-stylelint) | [stylelint](https://stylelint.io/)                   |\n| [flow-for-vscode\\*](https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode)  | [flow-bin](https://flow.org/)                        |\n\n> \\* Flow is currently [incompatible with PnP](../features/pnp#incompatible).\n\nIf you'd like to contribute more, [take a look here!](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-sdks/sources/generateSdk.ts)\n\n## Editor setup\n\n### VSCode\n\nTo support features like go-to-definition a plugin like [ZipFS](https://marketplace.visualstudio.com/items?itemName=arcanis.vscode-zipfs) is needed.\n\n1.  Run the following command, which will generate a new directory called `.yarn/sdks`:\n\n``` language-bash\nyarn dlx @yarnpkg/sdks vscode\n```\n\n2.  For safety reason VSCode requires you to explicitly activate the custom TS settings:\n\n3.  Press ctrl+shift+p in a TypeScript file\n\n4.  Choose \"Select TypeScript Version\"\n\n5.  Pick \"Use Workspace Version\"\n\nYour VSCode project is now configured to use the exact same version of TypeScript as the one you usually use, except that it will now be able to properly resolve the type definitions!\n\nNote that VSCode might ask you to do Step 3 again from time to time, but apart from that your experience should be mostly the same as usual. Happy development!\n\n### VIM\n\nTo support features like go-to-definition a plugin like [vim-rzip](https://github.com/lbrayner/vim-rzip) is needed.\n\n#### coc.nvim\n\nRun the following command, which will generate a new directory called `.yarn/sdks` and create a `.vim/coc-settings.json` file:\n\n``` language-bash\nyarn dlx @yarnpkg/sdks vim\n```\n\n#### Neovim Native LSP\n\nRun the following command, which will generate a new directory called `.yarn/sdks`:\n\n``` language-bash\nyarn dlx @yarnpkg/sdks base\n```\n\nWith the `.yarn/sdks` in place TypeScript support should work out of the box with [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig) and [theia-ide/typescript-language-server](https://github.com/theia-ide/typescript-language-server).\n\n##### Supporting go-to-definition et al.\n\n> **Note:** Due to a bug in [Neovim's URI handling](https://github.com/neovim/neovim/pull/14959) go-to-definition is only supported in neovim-nightly.\n\nAs well as the [vim-rzip](https://github.com/lbrayner/vim-rzip) plugin you'll also need the following snippet to handle Yarn PnP's URIs emitted from [theia-ide/typescript-language-server](https://github.com/theia-ide/typescript-language-server). See [lbrayner/vim-rzip#15](https://github.com/lbrayner/vim-rzip/issues/15) for further details.\n\n``` language-vim\n\" Decode URI encoded characters\nfunction! DecodeURI(uri)\n    return substitute(a:uri, '%\\([a-fA-F0-9][a-fA-F0-9]\\)', '\\=nr2char(\"0x\" . submatch(1))', \"g\")\nendfunction\n\n\" Attempt to clear non-focused buffers with matching name\nfunction! ClearDuplicateBuffers(uri)\n    \" if our filename has URI encoded characters\n    if DecodeURI(a:uri) !=# a:uri\n        \" wipeout buffer with URI decoded name - can print error if buffer in focus\n        sil! exe \"bwipeout \" . fnameescape(DecodeURI(a:uri))\n        \" change the name of the current buffer to the URI decoded name\n        exe \"keepalt file \" . fnameescape(DecodeURI(a:uri))\n        \" ensure we don't have any open buffer matching non-URI decoded name\n        sil! exe \"bwipeout \" . fnameescape(a:uri)\n    endif\nendfunction\n\nfunction! RzipOverride()\n    \" Disable vim-rzip's autocommands\n    autocmd! zip BufReadCmd   zipfile:*,zipfile:*/*\n    exe \"au! zip BufReadCmd \".g:zipPlugin_ext\n\n    \" order is important here, setup name of new buffer correctly then fallback to vim-rzip's handling\n    autocmd zip BufReadCmd   zipfile:*  call ClearDuplicateBuffers(expand(\"<amatch>\"))\n    autocmd zip BufReadCmd   zipfile:*  call rzip#Read(DecodeURI(expand(\"<amatch>\")), 1)\n\n    if has(\"unix\")\n        autocmd zip BufReadCmd   zipfile:*/*  call ClearDuplicateBuffers(expand(\"<amatch>\"))\n        autocmd zip BufReadCmd   zipfile:*/*  call rzip#Read(DecodeURI(expand(\"<amatch>\")), 1)\n    endif\n\n    exe \"au zip BufReadCmd \".g:zipPlugin_ext.\"  call rzip#Browse(DecodeURI(expand('<amatch>')))\"\nendfunction\n\nautocmd VimEnter * call RzipOverride()\n```\n\n### Emacs\n\nThe SDK comes with a typescript-language-server wrapper which enables you to use the ts-ls LSP client.\n\n1.  Run the following command, which will generate a new directory called `.yarn/sdks`:\n\n``` language-bash\nyarn dlx @yarnpkg/sdks base\n```\n\n2.  Create a `.dir-locals.el` with the following content to enable Flycheck and LSP support and make sure LSP is loaded after local variables are applied to trigger the `eval-after-load`:\n\n``` language-lisp\n((typescript-mode\n  . ((eval . (let ((project-directory (car (dir-locals-find-file default-directory))))\n                (setq lsp-clients-typescript-server-args `(\"--tsserver-path\" ,(concat project-directory \".yarn/sdks/typescript/bin/tsserver\") \"--stdio\")))))))\n```\n\n3.  Do note, that you can rename `:local` as you'd like in case you have SDKs stored elsewhere (other than `.yarn/sdks/...`) in other projects.\n\n## Caveat\n\n- Since the Yarn packages are kept within their archives, editors need to understand how to work with such paths should you want to open the files (for example when command-clicking on an import path originating from an external package). This can only be implemented by those editors, and we can't do much more than opening issues to ask for this feature to be implemented (for example, here's the VSCode issue: [\\#75559](https://github.com/microsoft/vscode/issues/75559)).\n\n  As a workaround, you can run `yarn unplug pkg-name` to instruct yarn to unzip the package, which will re-enable `Go to definition` functionality for the specific package.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started/editor-sdks](https://yarnpkg.com/getting-started/editor-sdks)"
- name: 5. Migration
  id: getting-started/migration
  summary: Any major release has its breaking changes, and Yarn 2 isn't the exception
  description: "# 5. Migration\n\nAny major release has its breaking changes, and Yarn 2 isn't the exception. A few old behaviors were cleaned, fixed, modified, or removed. While one of our goals is to make the transition as easy as we can, there are a few things to be aware of when migrating a codebase. To make this process more efficient we've listed below the recommended migration steps, along with solutions for the most common problems you might face.\n\n- [Why should you migrate?](#why-should-you-migrate)\n\n- [Step by step](#step-by-step)\n\n- [Switching to Plug'n'Play](#switching-to-plugnplay)\n\n  - [Before we start](#before-we-start)\n  - [Enabling it](#enabling-it)\n  - [Editor support](#editor-support)\n  - [Final notes](#final-notes)\n\n- [General Advices](#general-advices)\n\n  - [Upgrade to Node.js 12.x or newer](#upgrade-to-nodejs-12x-or-newer)\n  - [Fix dependencies with `packageExtensions`](#fix-dependencies-with-packageextensions)\n  - [Use `yarn dlx` instead of `yarn global`](#use-yarn-dlx-instead-of-yarn-global)\n  - [Enable the PnP plugin when using Webpack 4](#enable-the-pnp-plugin-when-using-webpack-4)\n  - [Upgrade `resolve` to 1.9+](#upgrade-resolve-to-19)\n  - [Call binaries using `yarn run` rather than `node_modules/.bin`](#call-binaries-using-yarn-run-rather-than-node_modulesbin)\n  - [Call your scripts through `yarn node` rather than `node`](#call-your-scripts-through-yarn-node-rather-than-node)\n  - [Explicitly call the `pre` and `post` scripts](#explicitly-call-the-pre-and-post-scripts)\n  - [Setup your IDE for PnP support](#setup-your-ide-for-pnp-support)\n  - [Update your configuration to the new settings](#update-your-configuration-to-the-new-settings)\n  - [Don't use `.npmrc` files](#dont-use-npmrc-files)\n  - [Take a look at our end-to-end tests](#take-a-look-at-our-end-to-end-tests)\n  - [Don't use `bundleDependencies`](#dont-use-bundledependencies)\n  - [If required: enable the `node-modules` plugin](#if-required-enable-the-node-modules-plugin)\n  - [Replace `nohoist` by `nmHoistingLimits`](#replace-nohoist-by-nmhoistinglimits)\n\n- [CLI Commands](#cli-commands)\n\n  - [Renamed](#renamed)\n  - [Removed from core](#removed-from-core)\n  - [Not implemented yet](#not-implemented-yet)\n\n- [Troubleshooting](#troubleshooting)\n\n  - [`Cannot find module [...]`](#cannot-find-module-)\n  - [`A package is trying to access another package [...]`](#a-package-is-trying-to-access-another-package-)\n\n## Why should you migrate?\n\nWe answer this question in details [here](qa#why-should-you-upgrade-to-yarn-modern).\n\nIn a few words, upgrading to the latest versions is critical to a fast and stable Yarn experience. Numerous bugs were fixed since the first major version, and we no longer expect to build new features on the old trunk. **Even if you don't plan to use the new default installation strategy called Plug'n'Play** your projects will still get benefits from the upgrade:\n\n- The good old `node_modules` installer improved as well as various edge cases got fixed\n- A renewed focus on performances and good practices (we now formally track perfs via a [dashboard](../benchmarks))\n- Improved user experience for various CLI commands and settings ([`yarn add -i`](../cli/add), [`yarn up`](../cli/up), [`logFilters`](../configuration/yarnrc#logFilters), ...)\n- New commands and capabilities (such as the [TypeScript plugin](https://github.com/yarnpkg/berry/tree/master/packages/plugin-typescript#yarnpkgplugin-typescript), or the [release workflow](../features/release-workflow))\n\nAnd of course a very active development cycle.\n\n## Step by step\n\n**Note:** Don't worry if your project isn't quite ready for [Plug'n'Play](../features/pnp) just yet! This guide will let you migrate **without losing your `node_modules` folder**. Only in a later optional section we will cover how to enable PnP support, and this part will only be recommended, not mandatory. Baby steps! 😉\n\nNote that those commands only need to be run once for the whole project and will automatically take effect for all your contributors as soon as they pull the migration commit, thanks to the power of [`yarnPath`](../configuration/yarnrc#yarnPath):\n\n1.  Run `npm install -g yarn` to update the global yarn version to latest v1\n2.  Go into your project directory\n3.  Run `yarn set version berry` to enable v2 (cf [Install](install) for more details)\n4.  If you used `.npmrc` or `.yarnrc`, you'll need to turn them into the [new format](../configuration/yarnrc) (see also [1](migration#update-your-configuration-to-the-new-settings), [2](migration#dont-use-npmrc-files))\n5.  Add [`nodeLinker: node-modules`](../configuration/yarnrc#nodeLinker) in your `.yarnrc.yml` file\n6.  Commit the changes so far (`yarn-X.Y.Z.js`, `.yarnrc.yml`, ...)\n7.  Run `yarn install` to migrate the lockfile\n8.  Take a look at [this article](qa#which-files-should-be-gitignored) to see what should be gitignored\n9.  Commit everything remaining\n\nSome optional features are available via external plugins:\n\n10. Run [`yarn plugin import interactive-tools`](../cli/plugin/import) if you want [`upgrade-interactive`](../cli/upgrade-interactive)\n11. Run [`yarn plugin list`](../cli/plugin/list) to see what other official plugins exist and might be useful\n12. Commit the yarn plugins\n\nGood, you should now have a working Yarn install! Some things might still require a bit of work (for instance we deprecated [arbitrary `pre/post`-scripts](../advanced/lifecycle-scripts), and renamed `--frozen-lockfile` into `--immutable`), but those special cases will be documented on a case-by-case basis in the rest of this document (for example [here](migration#explicitly-call-the-pre-and-post-scripts)).\n\n## Switching to Plug'n'Play\n\nThis step is completely optional - while we recommend to use Plug'n'Play for most new projects, it may sometimes require an average time investment to enable it on existing projects. For this reason, we prefer to list it here as a separate step that you can look into if you're curious or simply want the absolute best of what Yarn has to offer.\n\n### Before we start\n\nPlug'n'Play enforces strict dependency rules. In particular, you'll hit problems if you (or your dependencies) rely on unlisted dependencies (the reasons for that are detailed in our [Rulebook](../advanced/rulebook)), but the gist is that it was the cause of many \"project doesn't work on my computer\" issues, both in Yarn and other package managers.\n\nTo quickly detect which places may rely on unsafe patterns run `yarn dlx @yarnpkg/doctor` in your project - it'll statically analyze your sources to try to locate the most common issues that could result in a subpar experience. For example here's what `webpack-dev-server` would reveal:\n\n``` language-text\n➤ YN0000: Found 1 package(s) to process\n➤ YN0000: For a grand total of 236 file(s) to validate\n\n➤ YN0000: ┌ /webpack-dev-server/package.json\n➤ YN0000: │ /webpack-dev-server/test/testSequencer.js:5:19: Undeclared dependency on @jest/test-sequencer\n➤ YN0000: │ /webpack-dev-server/client-src/default/webpack.config.js:12:14: Webpack configs from non-private packages should avoid referencing loaders without require.resolve\n➤ YN0000: │ /webpack-dev-server/test/server/contentBase-option.test.js:68:8: Strings should avoid referencing the node_modules directory (prefer require.resolve)\n➤ YN0000: └ Completed in 5.12s\n\n➤ YN0000: Failed with errors in 5.12s\n```\n\nIn this case, the doctor noticed that:\n\n- `testSequencer.js` depends on a package without listing it as a proper dependency - which would be reported as an error at runtime under Plug'n'Play.\n\n- `webpack.config.js` references a loader without passing its name to `require.resolve` - which is unsafe, as it means the loader won't be loaded from `webpack-dev-server`'s dependencies.\n\n- `contentBase-option.test.js` checks the content of the `node_modules` folder - which wouldn't exist anymore under Plug'n'Play.\n\n### Enabling it\n\n1.  Look into your `.yarnrc.yml` file for the [`nodeLinker`](../configuration/yarnrc#nodeLinker) setting\n2.  If you don't find it, or if it's set to `pnp`, then it's all good: you're already using Plug'n'Play!\n3.  Otherwise, remove it from your configuration file\n4.  Run `yarn install`\n5.  Various files may have appeared; check [this article](qa#which-files-should-be-gitignored) to see what to put in your gitignore\n6.  Commit the changes\n\n### Editor support\n\nWe have a [dedicated documentation](editor-sdks), but if you're using VSCode (or some other IDE with Intellisense-like feature) the gist is:\n\n1.  Install the [ZipFS](https://marketplace.visualstudio.com/items?itemName=arcanis.vscode-zipfs) VSCode extension\n2.  Make sure that `typescript`, `eslint`, `prettier`, ... all dependencies typically used by your IDE extensions are listed at the *top level* of the project (rather than in a random workspace)\n3.  Run `yarn dlx @yarnpkg/sdks vscode`\n4.  Commit the changes - this way contributors won't have to follow the same procedure\n5.  For TypeScript, don't forget to select [Use Workspace Version](https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript) in VSCode\n\n### Final notes\n\nNow you should have a working Yarn Plug'n'Play setup, but your repository might still need some extra care. Some things to keep in mind:\n\n- There is no `node_modules` folder and no `.bin` folder. If you relied on these, [call `yarn run` instead](##call-binaries-using-yarn-run-rather-than-node_modulesbin).\n- Replace any calls to `node` that are not inside a Yarn script with `yarn node`\n- Custom pre-hooks (e.g. prestart) need to be called manually now\n\nAll of this and more is documented in the following sections. In general, we advise you at this point to try to run your application and see what breaks, then check here to find out tips on how to correct your install.\n\n## General Advices\n\n### Upgrade to Node.js 12.x or newer\n\nNode.js 10.x reached its official End of Life in April 2021 and won't receive any further update. Yarn consequently doesn't support it anymore.\n\n### Fix dependencies with `packageExtensions`\n\nPackages sometimes forget to list their dependencies. In the past it used to cause many subtle issues, so Yarn now defaults to prevent such unsound accesses. Still, we don't want it to prevent you from doing your work as long as you can do it in a safe and predictable way, so we came up with the [`packageExtensions`](../configuration/yarnrc#packageExtensions) setting.\n\nFor example, if `react` was to forget to list a dependency on `prop-types`, you'd fix it like this:\n\n``` language-yaml\npackageExtensions:\n  \"react@*\":\n    dependencies:\n      prop-types: \"*\"\n```\n\nAnd if a Babel plugin was missing its peer dependency on `@babel/core`, you'd fix it with:\n\n``` language-yaml\npackageExtensions:\n  \"@babel/plugin-something@*\":\n    peerDependencies:\n      \"@babel/core\": \"*\"\n```\n\n### Use `yarn dlx` instead of `yarn global`\n\n`yarn dlx` is designed to execute one off scripts that may have been installed as global packages with `yarn 1.x`. Managing system-wide packages is outside of the scope of `yarn`. To reflect this, `yarn global` has been removed. [Read more on GitHub](https://github.com/yarnpkg/berry/issues/821).\n\n### Enable the PnP plugin when using Webpack 4\n\nWebpack 5 supports PnP natively, but if you use Webpack 4 you'll need to add the [`pnp-webpack-plugin`](https://github.com/arcanis/pnp-webpack-plugin) plugin yourself.\n\n### Upgrade `resolve` to 1.9+\n\nThe `resolve` package is used by many tools in order to retrieve the dependencies for any given folder on the filesystem. It's compatible with Plug'n'Play, but only starting from 1.9+, so make sure you don't have an older release in your dependency tree (especially as transitive dependency).\n\n**Fix:** Open your lockfile, look for all the `resolve` entries that could match 1.9+ (for example `^1.0.0`), and remove them. Then run `yarn install` again. If you run `yarn why resolve`, you'll also get a good idea of which package is depending on outdated version of `resolve` - maybe you can upgrade them too?\n\n### Call binaries using `yarn run` rather than `node_modules/.bin`\n\nThe `node_modules/.bin` folder is an implementation detail, and the PnP installs don't generate it at all. Rather than relying on its existence, just use the `yarn run` command which can start both scripts and binaries:\n\n``` language-bash\nyarn run jest\n# or, using the shortcut:\nyarn jest\n```\n\n### Call your scripts through `yarn node` rather than `node`\n\nWe now need to inject some variables into the environment for Node to be able to locate your dependencies. In order to make this possible, we ask you to use `yarn node` which transparently does the heavy lifting.\n\n**Note:** this section only applies to the *shell CLI*. The commands defined in your `scripts` are unaffected, as we make sure that `node` always points to the right location, with the right variables already set.\n\n### Explicitly call the `pre` and `post` scripts\n\nRewrite:\n\n``` language-json\n{\n  \"scripts\": {\n    \"prestart\": \"do-something\",\n    \"start\": \"http-server\"\n  }\n}\n```\n\nInto:\n\n``` language-json\n{\n  \"scripts\": {\n    \"prestart\": \"do-something\",\n    \"start\": \"yarn prestart && http-server\"\n  }\n}\n```\n\n**Note:** This only applies to user scripts, such as `start` & friends. It's still fine to use any of `preinstall`, `install`, and `postinstall`. Consult the [script documentation](../advanced/lifecycle-scripts) for more information.\n\n### Setup your IDE for PnP support\n\nWe've written a [guide](editor-sdks) entirely designed to explain how to use Yarn with your IDE. Make sure to take a look at it, and maybe contribute to it if some instructions are unclear or missing!\n\n### Update your configuration to the new settings\n\nYarn 2 uses a different style of configuration files than Yarn 1. While mostly invisible for the lockfile (because we import them on the fly), it might cause some issues for your rc files.\n\n- The main change is the name of the file. Yarn 1 used `.yarnrc`, but Yarn 2 is moving to a different name: `.yarnrc.yml`. This should make it easier for third-party tools to detect whether a project uses Yarn 1 or Yarn 2, and will allow you to easily set different settings in your home folders when working with a mix of Yarn 1 and Yarn 2 projects.\n\n- As evidenced by the new file extension, the Yarnrc files are now to be written in [YAML](https://en.wikipedia.org/wiki/YAML). This has been requested for a long time, and we hope it'll allow easier integrations for the various third-party tools that need to interact with the Yarnrc files (think Dependabot, etc).\n\n- The configuration keys have changed. The comprehensive settings list is available in our [documentation](../configuration/yarnrc), but here are some particular changes you need to be aware of:\n\n  - Custom registries are now configured via [`npmRegistryServer`](../configuration/yarnrc#npmRegistryServer).\n\n  - Registry authentication tokens are now configured via [`npmAuthToken`](../configuration/yarnrc#npmAuthToken).\n\n  - The `yarn-offline-mirror` has been removed, since the offline mirror has been merged with the cache as part of the [Zero-Install effort](../features/zero-installs). Just commit the Yarn cache and you're ready to go.\n\n### Don't use `.npmrc` files\n\nOn top of their naming, the way we load the Yarnrc files has also been changed and simplified. In particular:\n\n- Yarn doesn't use the configuration from your `.npmrc` files anymore; we instead read all of our configuration from the `.yarnrc.yml` files whose available settings can be found in [our documentation](../configuration/yarnrc).\n\n- As mentioned in the previous section, the yarnrc files are now called `.yarnrc.yml`, with an extension. We've completely stopped reading the values from the regular `.yarnrc` files.\n\n- All environment variables prefixed with `YARN_` are automatically used to override the matching configuration settings. So for example, adding `YARN_NPM_REGISTRY_SERVER` into your environment will change the value of [`npmRegistryServer`](../configuration/yarnrc#npmRegistryServer).\n\n### Take a look at our end-to-end tests\n\nWe now run daily [end-to-end tests](https://github.com/yarnpkg/berry#current-status) against various popular JavaScript tools in order to make sure that we never regress - or to be notified when those tools do.\n\nConsulting the sources for those tests is a great way to check whether some special configuration values have to be set when using a particular toolchain.\n\n### Don't use `bundleDependencies`\n\nThe `bundleDependencies` (or `bundledDependencies`) is an artifact of the past that used to let you define a set of packages that would be stored as-is within the package archive, `node_modules` and all. This feature has many problems:\n\n- It uses `node_modules`, which doesn't easily allow different install strategies such as Plug'n'Play.\n- It encodes the hoisting inside the package, which is the exact opposite of what we aim for\n- It messes with the hoisting of other packages\n- Etc, etc, etc\n\nSo how to replace them? There are different ways:\n\n- If you need to patch a package, just fork it or reference it through `file:` (it's perfectly fine even for transitive dependencies to use this protocol). The `portal:` and `patch:` protocols are also options, although they'll only work for Yarn consumers.\n\n- If you need to ship a package to your customers as a standalone (no dependencies), bundle it yourself using Webpack, Rollup, or similar tools.\n\n### If required: enable the `node-modules` plugin\n\n**[PnP Compatibility Table](../features/pnp#compatibility-table)**\n\nDespite our best efforts some tools don't work at all under Plug'n'Play environments, and we don't have the resources to update them ourselves. There are only two notorious ones on our list: Flow, and React Native.\n\nIn such a radical case, you can enable the built-in [`node-modules` plugin](https://github.com/yarnpkg/berry/tree/master/packages/plugin-nm) by adding the following into your local [`.yarnrc.yml`](../configuration/yarnrc) file before running a fresh `yarn install`:\n\n``` language-yaml\nnodeLinker: node-modules\n```\n\nThis will cause Yarn to install the project just like Yarn 1 used to, by copying the packages into various `node_modules` folders.\n\n[More information about the `nodeLinker` option.](../configuration/yarnrc#nodeLinker)\n\n### Replace `nohoist` by `nmHoistingLimits`\n\nThe `nohoist` setting from Yarn 1 was made specifically for React Native (in order to help it support workspaces), but the way it worked (through glob patterns) was causing a lot of bugs and confusion, noone being really sure which patterns needed to be set. As a result, we've simplified this feature in order to only support three identified patterns.\n\nIf you were using `nohoist`, we recommend you remove it from your manifest configuration and instead set [`nmHoistingLimits`](../configuration/yarnrc#nmHoistingLimits) in your yarnrc file:\n\n``` language-yaml\nnmHoistingLimits: workspaces\n```\n\n## CLI Commands\n\n### Renamed\n\n[TABLE]\n\n### Removed from core\n\n[TABLE]\n\n### Not implemented yet\n\nThose features simply haven't been implemented yet. Help welcome!\n\n[TABLE]\n\n## Troubleshooting\n\n### `Cannot find module [...]`\n\nInterestingly, this error often **doesn't** come from Yarn. In fact, seeing this message should be extremely rare when working with Yarn 2 projects and typically highlights that something is wrong in your setup.\n\nThis error appears when Node is executed without the proper environment variables. In such a case, the underlying application won't be able to access the dependencies and Node will throw this message. To fix that, make sure that the script is called through `yarn node [...]` (instead of `node [...]`) if you run it from the command line.\n\n### `A package is trying to access another package [...]`\n\n> **Full message:** A package is trying to access another package without the second one being listed as a dependency of the first one.\n\nSome packages don't properly list their actual dependencies for a reason or another. Now that we've fully switched to Plug'n'Play and enforce boundaries between the various branches of the dependency tree, this kind of issue will start to become more apparent than it previously was.\n\nThe long term fix is to submit a pull request upstream to add the missing dependency to the package listing. Given that it sometimes might take some time before they get merged, we also have a more short-term fix available: create `.yarnrc.yml` in your project, then use the [`packageExtensions` setting](../configuration/yarnrc#packageExtensions) to add the missing dependency to the relevant packages. Once you're done, run `yarn install` to apply your changes and voilà!\n\n``` language-yaml\npackageExtensions:\n  \"debug@*\":\n    peerDependenciesMeta:\n      \"supports-color\":\n        optional: true\n```\n\nIf you also open a PR on the upstream repository you will also be able to contribute your package extension to our [compat plugin](https://github.com/yarnpkg/berry/blob/master/packages/plugin-compat/sources/extensions.ts), helping the whole ecosystem move forward.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started/migration](https://yarnpkg.com/getting-started/migration)"
- name: 6. Questions & Answers
  id: getting-started/qa
  summary: While the Yarn Classic line (1.x) remains a pillar of the JavaScript ecosystem, we recommend upgrading if possible
  description: "# 6. Questions & Answers\n\n- [Why should you upgrade to Yarn Modern?](#why-should-you-upgrade-to-yarn-modern)\n- [How easy should you expect the migration from Classic to Modern to be?](#how-easy-should-you-expect-the-migration-from-classic-to-modern-to-be)\n- [Which files should be gitignored?](#which-files-should-be-gitignored)\n- [Should lockfiles be committed to the repository?](#should-lockfiles-be-committed-to-the-repository)\n- [How to share scripts between workspaces?](#how-to-share-scripts-between-workspaces)\n- [Is Yarn operated by Facebook?](#is-yarn-operated-by-facebook)\n- [Why `registry.yarnpkg.com`? Does Facebook track us?](#why-registryyarnpkgcom-does-facebook-track-us)\n- [Queries to `registry.yarnpkg.com` return a 404/500/...; is it down?](#queries-to-registryyarnpkgcom-return-a-404500-is-it-down)\n- [Is Yarn faster than other package managers?](#is-yarn-faster-than-other-package-managers)\n- [Why is TypeScript patched even if I don't use Plug'n'Play?](#why-is-typescript-patched-even-if-i-dont-use-plugnplay)\n\n## Why should you upgrade to Yarn Modern?\n\nWhile the Yarn Classic line (1.x) remains a pillar of the JavaScript ecosystem, we recommend upgrading if possible. Why's that?\n\n1.  New features: On top of the classic features you're already used to, on top of the new ones you'll discover ([`yarn dlx`](../cli/dlx), [builtin `patch:` protocol](https://github.com/yarnpkg/berry/tree/master/packages/plugin-patch), ...), Modern offers plugins extending Yarn's featureset with [changesets](../features/release-workflow), [constraints](../features/constraints), [workspaces](../cli/workspaces/foreach), ...\n\n2.  Efficiency: Modern features new install strategies, leading projects to only be a fraction of their past self; as an example, under the default configuration the stock CRA artifacts now only take 45MB instead of 237MB. [Performances](https://p.datadoghq.eu/sb/d2wdprp9uki7gfks-c562c42f4dfd0ade4885690fa719c818) were improved as well, with most installs now only taking a few seconds even on extremely large projects. We even made it possible to reach [zero seconds](../features/zero-installs)!\n\n3.  Extensibility: Modern's architecture allows you to build your own features as you need it. No more of you being blocked waiting for us to implement this feature you dream of - you can now do it yourself, according to your own specs! Focused workspaces, custom installs, project validation, ...\n\n4.  Stability: Modern comes after years of experience with maintaining Classic; it allowed us to finally fix longstanding design issues with how some features were implemented. Workspaces are now core components, the resolution pipeline has been streamlined, data structures are more efficient... as a result, Modern is much less likely to suffer from incorrect assumptions and other design flaws.\n\n5.  Future proof: A big reason why we invested in Modern was that we noticed how building new features on Classic was becoming difficult - each change being too likely to have unforeseen consequences. The Modern architecture learned from our mistakes, and was designed to allow us to build features at a much higher pace - as evidenced by our new gained velocity.\n\n## How easy should you expect the migration from Classic to Modern to be?\n\nGenerally, a few main things will need to be taken care of:\n\n1.  The settings format changed. We don't read the `.npmrc` or `.yarnrc` files anymore, instead of consuming the settings from the [`.yarnrc.yml` file](../configuration/yarnrc).\n\n2.  Some third-party packages don't list their dependencies properly and will need to be helped through the [`packageExtensions`](../configuration/yarnrc#packageExtensions) settings.\n\n3.  Support for text editors is pretty good, but you'll need to run the one-time-setup listed in our [SDK documentation](editor-sdks).\n\n4.  Some tools (mostly React Native and Flow) will require downgrading to the `node_modules` install strategy by setting the [`nodeLinker`](../configuration/yarnrc#nodeLinker) setting to `node-modules`. TypeScript doesn't have this problem.\n\nMost projects will only face those four problems, which can all be fixed in a good afternoon of work. For more detailed instructions, please see the detailed [migration guide](migration).\n\n## Which files should be gitignored?\n\nIf you're using Zero-Installs:\n\n``` language-gitignore\n.yarn/*\n!.yarn/cache\n!.yarn/patches\n!.yarn/plugins\n!.yarn/releases\n!.yarn/sdks\n!.yarn/versions\n```\n\nIf you're not using Zero-Installs:\n\n``` language-gitignore\n.pnp.*\n.yarn/*\n!.yarn/patches\n!.yarn/plugins\n!.yarn/releases\n!.yarn/sdks\n!.yarn/versions\n```\n\nIf you're interested to know more about each of these files:\n\n- `.yarn/cache` and `.pnp.*` may be safely ignored, but you'll need to run `yarn install` to regenerate them between each branch switch - which would be optional otherwise, cf [Zero-Installs](../features/zero-installs).\n\n- `.yarn/install-state.gz` is an optimization file that you shouldn't ever have to commit. It simply stores the exact state of your project so that the next commands can boot without having to resolve your workspaces all over again.\n\n- `.yarn/patches` contain the patchfiles you've been generating with the [`yarn patch-commit`](../cli/patch-commit) command. You always want them in your repository, since they are necessary to install your dependencies.\n\n- `.yarn/plugins` and `.yarn/releases` contain the Yarn releases used in the current repository (as defined by [`yarn set version`](../cli/set/version)). You will want to keep them versioned (this prevents potential issues if, say, two engineers use different Yarn versions with different features).\n\n- `.yarn/sdks` contains the editor SDKs generated by `@yarnpkg/sdks`. Whether to keep it in your repository or not is up to you; if you don't, you'll need to follow the editor procedure again on new clones. See [Editor SDKs](editor-sdks) for more details.\n\n- `.yarn/unplugged` should likely always be ignored since they typically hold machine-specific build artifacts. Ignoring it might however prevent [Zero-Installs](../features/zero-installs) from working (to prevent this, set [`enableScripts`](../configuration/yarnrc#enableScripts) to `false`).\n\n- `.yarn/versions` is used by the [version plugin](../features/release-workflow) to store the package release definitions. You will want to keep it within your repository.\n\n- `yarn.lock` should always be stored within your repository ([even if you develop a library](#should-lockfiles-be-committed-to-the-repository)).\n\n- `.yarnrc.yml` (and its older counterpart, `.yarnrc`) are configuration files. They should always be stored in your project.\n\n> **Tip:** You can also add a `.gitattributes` file to identify the release and plugin bundles as binary content. This way Git won't bother showing massive diffs when each time you subsequently add or update them:\n>\n> ``` language-gitattributes\n> /.yarn/releases/** binary\n> /.yarn/plugins/** binary\n> ```\n\n## Should lockfiles be committed to the repository?\n\n**Yes.**\n\nLockfiles are meant to always be stored along with your project sources - and this regardless of whether you're writing a standalone application or a distributed library.\n\nOne persisting argument against checking-in the lockfile in the repository is about being made aware of potential problems against the latest versions of the library. People saying this argue that the lockfile being present prevents contributors from seeing such issues, as all dependencies are locked and appear fine until a consumer installs the library and uses more recent (and incompatible) dependencies.\n\nAlthough tempting, this reasoning has a fatal flaw: removing the lockfile from the repository doesn't prevent this problem from happening. In particular:\n\n- Active contributors won't get new versions unless they explicitly remove their install artifacts (`node_modules`), which may not happen often. Problematic dependency upgrades will thus be mainly discovered by new contributors, which doesn't make for a good first experience and may deter contributions.\n\n- Even assuming you run fresh installs every week, your upgrades won't be easily reversible - once you test the most recent packages, you won't test against the less recent ones. The compatibility issues will still exist, they just will be against packages that used to work but that you don't test anymore. in other words, by always testing the most recent semver release, you won't see if you accidentally start relying on a feature that wasn't available before.\n\nOf course these points are only part of the problem - the lack of lockfile also means that key state information are missing from the repository. When months later you or your contributors want to make a fix on one of your old projects you might not even be able to *build* it anymore, let alone improve it.\n\nLockfiles should **always** be kept within the repository. Continuous integration testing **is a good idea**, but should be left to continuous integration systems. For example, Yarn itself runs [daily tests](https://github.com/yarnpkg/berry#current-status) against the latest versions of major open-source frameworks and tools, which allows us to quickly spot any compatibility issue with the newest release, while still being guarateed that every contributor will have a consistent experience working with the project. [Dependabot](https://dependabot.com/#how-it-works) and [Renovate](https://www.whitesourcesoftware.com/free-developer-tools/renovate) are also good tools that track your dependencies updates for you.\n\n## How to share scripts between workspaces?\n\nLittle-known Yarn feature: any script with a colon in its name (`build:foo`) can be called from any workspace. Another little-known feature: `$INIT_CWD` will always point to the directory running the script. Put together, you can write scripts that can be reused this way:\n\n``` language-json\n{\n  \"dependencies\": {\n    \"typescript\": \"^3.8.0\"\n  },\n  \"scripts\": {\n    \"g:tsc\": \"cd $INIT_CWD && tsc\"\n  }\n}\n```\n\nThen, from any workspace that contains its own `tsconfig.json`, you'll be able to call TypeScript:\n\n``` language-json\n{\n  \"scripts\": {\n    \"build\": \"yarn g:tsc\"\n  }\n}\n```\n\nor if you only want to use `tsc` from the root workspace:\n\n``` language-json\n{\n  \"scripts\": {\n    \"build\": \"run -T tsc\"\n  }\n}\n```\n\nShould you want to run a script in the base of your project:\n\n``` language-json\n{\n  \"scripts\": {\n    \"build\": \"node ${PROJECT_CWD}/scripts/update-contributors.js\"\n  }\n}\n```\n\n## Is Yarn operated by Facebook?\n\n**No.**\n\nDespite the first version of Yarn having been implemented by [Sebastian McKenzie](https://twitter.com/sebmck) while working at Facebook, the initial design received feedbacks from various other companies (such as [Tilde](https://www.tilde.io) via [Yehuda Katz](https://yehudakatz.com/2016/10/11/im-excited-to-work-on-yarn-the-new-js-package-manager-2/)) and the project was put into its own [GitHub organization](https://github.com/yarnpkg). Facebook kept investing in it during the following years (mostly because it proved to be a critical part of the RN ecosystem) but major contributions came from the open-source too.\n\nNowadays, the active development team is composed exclusively of people employed by non-founders companies. Facebook employees are of course still welcome to offer contributions to the project, but they would go through the same review process as everyone else.\n\n## Why `registry.yarnpkg.com`? Does Facebook track us?\n\n**No.**\n\nWhen Yarn got created, the npm registry used to be served through Fastly. This was apparently affecting the install performances, so the initial team decided to partner with Cloudflare and setup a [reverse proxy](https://en.wikipedia.org/wiki/Reverse_proxy) that would simply better cache the requests before returning them. This setup didn't even have a backend on our side.\n\nAt some point npm switched to Cloudflare as well, and we turned off the proxy to replace it by a [CNAME](https://en.wikipedia.org/wiki/CNAME_record) ([proof](https://toolbox.googleapps.com/apps/dig/#CNAME/registry.yarnpkg.com)). We still keep the hostname for reliability reasons - while it stands to reason that the Yarn domain name will keep being maintained for as long as Yarn is being used, the same isn't necessarily true of the npm domain name. That gives us the ability to redirect to a read-only copy of the registry should the primary source become unavailable.\n\nWhile we do gather some basic [client-side telemetry](../advanced/telemetry), no http logs can ever even reach the Yarn project infrastructure - and even less Facebook, which has no control over the project (see also, [Is Yarn operated by Facebook?](qa#is-yarn-operated-by-facebook)).\n\n## Queries to `registry.yarnpkg.com` return a 404/500/...; is it down?\n\n**No.**\n\nAs mentioned in the [previous section](#why-registryyarnpkgcom-does-facebook-track-us), the Yarn registry is just a CNAME to the npm registry. Since we don't even have a backend, any server error can only come from the npm registry and thus should be reported to them and monitored on their [status page](https://status.npmjs.org/).\n\n## Is Yarn faster than other package managers?\n\n**Shrug 🤷‍♀️**\n\nAt the time Yarn got released Yarn was effectively much faster than some of its competitors. Unfortunately, we failed to highlight that performance wasn't the main reason why we kept working on Yarn. Performances come and go, so while we were super fast it wasn't so much because we were doing something incredibly well, but rather that the competing implementations had a serious bug. When that bug got fixed, our miscommunication became more apparent as some people thought that Yarn was all about performances.\n\nPut simply, our differences lie in our priorities. Different projects make different tradeoffs, and it's exactly what happens here. We prioritized workspaces because we felt like monorepos were providing significant value. We've spent significant resources pushing for Plug'n'Play (including through [dozens of contributions to third-party projects](https://github.com/pulls?utf8=%E2%9C%93&q=is%3Apr+author%3Aarcanis+archived%3Afalse+is%3Aclosed+pnp+-user%3Ayarnpkg+)) because we felt like this was important for the ecosystem. This is the main difference: we make our own informed decisions regarding the project roadmap.\n\nSpeed is relative and a temporary state. Processes, roadmaps and core values are what stick.\n\n## Why is TypeScript patched even if I don't use Plug'n'Play?\n\nGiven that PnP is a resolver standard different from Node, tools that reimplement the `require.resolve` API need to add some logic to account for the PnP resolution. While various projects did so (for example Webpack 5 now supports PnP out of the box), a few are still on the fence about it. In the case of TypeScript we started and keep maintaining a [pull request](https://github.com/microsoft/TypeScript/pull/35206), but the TypeScript team still has to accept it. In order to unblock our users, we made the decision to automatically apply this exact pull request to the downloaded TypeScript versions, using our new [`patch:` protocol](../features/protocols#patch).\n\nWhich now begs the question: why do we still apply this patch even when Plug'n'Play is disabled? The main reason is that Yarn intends to provide consistent behaviour. Some setups involve using the `node_modules` linker during development (to avoid having to setup editor [SDKS](editor-sdks)) and PnP in production (for install speed). If we were to only apply the patches when PnP is enabled, then the package cache would turn different, which would for example break immutable installs.\n\nWe *could* potentially make it configurable through a switch, but in the end we decided it wasn't worth the extra configuration:\n\n- The TypeScript patch is a noop if PnP isn't enabled, so this shouldn't affect your work (if it does, please open an issue)\n- We hope to eventually land this PR in TypeScript one day, so the more eyes we can get on it the higher our confidence will be\n- Since Yarn 3+, failing builtin patches are simply ignored and fallback to the original sources\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started/qa](https://yarnpkg.com/getting-started/qa)"
- name: 7. Recipes
  id: getting-started/recipes
  summary: You may sometimes need to use node_modules on just part of your workspace (for example, if you use Angular or React-Native)
  description: "# 7. Recipes\n\n## TypeScript + PnP quick start:\n\n- Initialize the repo using Yarn 2:\n\n``` language-sh\nyarn init -2\n```\n\n- Add typescript and enable [VSCode integration](editor-sdks):\n\n``` language-sh\nyarn add --dev typescript\nyarn dlx @yarnpkg/sdks vscode\n```\n\n- You can optionally enable [Yarn's TypeScript plugin](https://github.com/yarnpkg/berry/tree/master/packages/plugin-typescript), which helps manage `@types/*` dependencies automatically.\n\n``` language-sh\nyarn plugin import typescript\n```\n\n## Running a Yarn CLI command in the specified directory:\n\n- Starting a new library inside a monorepo directly, without manually creating directories for it.\n\n``` language-sh\nyarn packages/my-new-lib init\n```\n\n- Running an arbitrary command inside a specific workspace:\n\n``` language-sh\nyarn packages/app tsc --noEmit\n```\n\n## Hybrid PnP + node_modules mono-repo:\n\nYou may sometimes need to use `node_modules` on just part of your workspace (for example, if you use Angular or React-Native).\n\n- Create a separate directory for the `node_modules` project.\n\n``` language-sh\nmkdir nm-packages/myproj\n```\n\n- Create an empty lockfile in the new project. Yarn uses lockfiles to locate the root of projects.\n\n``` language-sh\ntouch nm-packages/myproj/yarn.lock\n```\n\n- Add a `.yarnrc.yml` file inside the new directory that enables `node_modules` just for it (`nm-packages/myproj/.yarnrc.yml`):\n\n``` language-yml\nnodeLinker: node-modules\n```\n\n- Add a PnP ignore pattern for this path in your main `.yarnrc.yml` at the root of your monorepo:\n\n``` language-yml\npnpIgnorePatterns:\n  - ./nm-packages/**\n```\n\n- Run `yarn` to apply `pnpIgnorePatterns` in the repo root.\n- Run `cd nm-packages/myproj && yarn` to install the now isolated project.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/getting-started/recipes](https://yarnpkg.com/getting-started/recipes)"
- name: Architecture
  id: advanced/architecture
  summary: Yarn works through a core package (published as @yarnpkg/core) that exposes the various base components that make up a project
  description: "# Architecture\n\n- [General architecture](#general-architecture)\n- [Install architecture](#install-architecture)\n\n## General architecture\n\nYarn works through a core package (published as `@yarnpkg/core`) that exposes the various base components that make up a project. Some of the components are classes that you might recognize from the API: `Configuration`, `Project`, `Workspace`, `Cache`, `Manifest`, and others. All those are provided by the core package.\n\nThe core itself doesn't do much - it merely contains the logic required to manage a project. In order to use this logic from the command-line Yarn provides an indirection called `@yarnpkg/cli` which, interestingly, doesn't do much either. It however has two very important responsibilities: it hydrates a project instance based on the current directory (`cwd`), and inject the prebuilt Yarn plugins into the environment.\n\nSee, Yarn is built in modular way that allow most of the business logic related to third-party interactions to be externalized inside their own package - for example the [npm resolver](https://github.com/yarnpkg/berry/tree/master/packages/plugin-npm) is but one plugin amongst many others. This design gives us a much simpler codebase to work with (hence an increased development speed and stabler product), and offers plugin authors the ability to write their own external logic without having to modify the Yarn codebase itself.\n\n## Install architecture\n\nWhat happens when running `yarn install` can be summarized in a few different steps:\n\n1.  First we enter the \"resolution step\":\n\n    - First we load the entries stored within the lockfile, then based on those data and the current state of the project (that it figures out by reading the manifest files, aka `package.json`) the core runs an internal algorithm to find out which entries are missing.\n\n    - For each of those missing entries, it queries the plugins using the [`Resolver`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts) interface, and asks them whether they would know about a package that would match the given descriptor ([`supportsDescriptor`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L54)) and its exact identity ([`getCandidates`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L114)) and transitive dependency list ([`resolve`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L123)).\n\n    - Once it has obtained a new list of package metadata, the core starts a new resolution pass on the transitive dependencies of the newly added packages. This will be repeated until it figures out that all packages from the dependency tree now have their metadata stored within the lockfile.\n\n    - Finally, once every package range from the dependency tree has been resolved into metadata, the core builds the tree in memory one last time in order to generate what we call \"virtual packages\". In short, those virtual packages are split instances of the same base package - we use them to disambiguate all packages that list peer dependencies, whose dependency set would change depending on their location in the dependency tree (consult [this lexicon entry](lexicon#virtualpackages) for more information).\n\n2.  Once the resolution is done, we enter the \"fetch step\":\n\n    - Now that we have the exact set of packages that make up our dependency tree, we iterate over it and for each of them we start a new request to the cache to know whether the package is anywhere to be found. If it isn't we do just like we did in the previous step and we ask our plugins (through the [`Fetcher`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts) interface) whether they know about the package ([`supports`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts#L43)) and if so to retrieve it from whatever its remote location is ([`fetch`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts#L67)).\n\n    - Interesting tidbit regarding the fetchers: they communicate with the core through an abstraction layer over `fs`. We do this so that our packages can come from many different sources - it can be from a zip archive for packages downloaded from a registry, or from an actual directory on the disk for [`portal:`](architecture) dependencies.\n\n3.  And finally, once all the packages are ready for consumption, comes the \"link step\":\n\n    - In order to work properly, the packages you use must be installed on the disk in some way. For example, in the case of a native Node application, your packages would have to be installed into a set of `node_modules` directories so that they could be located by the interpreter. That's what the linker is about. Through the [`Linker`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Linker.ts) and [`Installer`](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Installer.ts) interfaces the Yarn core will communicate with the registered plugins to let them know about the packages listed in the dependency tree, and describe their relationships (for example it would tell them that `tapable` is a dependency of `webpack`). The plugins can then decide what to do of this information in whatever way they see fit.\n\n    - Doing this means that new linkers can be created for other programming languages pretty easily - you just need to write your own logic regarding what should happen from the packages provided by Yarn. Want to generate an `__autoload.php`? Do it! Want to setup a Python virtual env? No problemo!\n\n    - Something else that's pretty cool is that the packages from within the dependency tree don't have to all be of the same type. Our plugin design allows instantiating multiple linkers simultaneously. Even better - the packages can depend on one another across linkers! You could have a JavaScript package depending on a Python package (which is technically the case of `node-gyp`, for example).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/architecture](https://yarnpkg.com/advanced/architecture)"
- name: Constraints
  id: features/constraints
  summary: This feature is still incubating, and its exact API might change from a release to the next
  description: "# Constraints\n\n> **Experimental**\n>\n> This feature is still incubating, and its exact API might change from a release to the next. It means it's the perfect time for you to get involved and let us hear your feedback!\n\n> **Plugin**\n>\n> To access this feature, first install the `constraints` plugin: `yarn plugin import constraints`\n\nConstraints are a solution to a very basic need: I have a lot of [workspaces](workspaces), and I need to make sure they use the same version of their dependencies. Or that they don't depend on a specific package. Or that they use a specific type of dependency. Anyway, you see the point: whatever is the exact logic, my goal is the same; I want to automatically enforce some kind of rule across all my workspaces. That's exactly what constraints allow you to do.\n\n- [Creating a constraint](#creating-a-constraint)\n\n  - [Query predicate](#query-predicate)\n\n    - [`dependency_type/1`](#dependency_type1)\n    - [`workspace/1`](#workspace1)\n    - [`workspace_ident/2`](#workspace_ident2)\n    - [`workspace_version/2`](#workspace_version2)\n    - [`workspace_has_dependency/4`](#workspace_has_dependency4)\n    - [`workspace_field/3`](#workspace_field3)\n\n  - [`workspace_field_test/3`](#workspace_field_test3)\n\n  - [Constraint predicates](#constraint-predicates)\n\n    - [`gen_enforced_dependency/4`](#gen_enforced_dependency4)\n    - [`gen_enforced_field/3`](#gen_enforced_field3)\n\n- [Constraint recipes](#constraint-recipes)\n\n  - [Prevent all workspaces from depending on a specific package](#prevent-all-workspaces-from-depending-on-a-specific-package)\n  - [Prevent two workspaces from depending on conflicting versions of a same dependency](#prevent-two-workspaces-from-depending-on-conflicting-versions-of-a-same-dependency)\n  - [Force all workspace dependencies to be made explicit](#force-all-workspace-dependencies-to-be-made-explicit)\n\n## Creating a constraint\n\nConstraints are created by adding a `constraints.pro` file at the root of your project (repository). The `.pro` extension might leave you perplexed: this is because constraints aren't written in JavaScript (!) but rather in Prolog, a fact-based rule engine. The goal of this section isn't to teach you Prolog (good tutorials already exist, such as [Learn Prolog in Y Minutes](https://learnxinyminutes.com/docs/prolog/)), but rather to show you why we chose it and the value it brings.\n\nAs we mentioned, Prolog is a fact-based engine. It starts with a list of *facts* that are always true, and a list of *predicates* that basically read as \"predicate `f(X)` is true if `u(X)` and `v(X)` are both true\". By computing for which values of `X` are `u(X)` and `v(X)` true, Prolog is able to automatically compute the list of values for which `f(X)` would be true. This is particularly useful for constraints, because it allows you to write very simple but powerful rules that have the ability to affect all your workspaces in very few lines.\n\nGoing back to the constraint engine, the *facts* are the definitions created by the package manager (such as \"fact: the root workspace depends on Lodash version 4.4.2 in devDependencies\"), and the *predicates* are the set of rules that you want to enforce across your project (check below for some recipes).\n\n### Query predicate\n\nThe following predicates provide information about the current state of your project and are meant to be used in the dependencies of your own rules (check the recipes for examples how to use them in practice). Note that the `/<number>` syntax listed at the end simply is the predicate arity (number of arguments it takes).\n\nThe notation on this page uses `-`, `+` and `?` as prefix for the predicate parameters. These values are used commonly in prolog documentation and mean\n\n- `+`: this value is considered input and must be instantiated\n- `-`: this value is considered output and will be instantiated by the predicate, though you can provide a value to verify that the value matches the predicate\n- `?`: this value can be instantiated or not, both will work\n\n#### `dependency_type/1`\n\n``` language-prolog\ndependency_type(\n  -DependencyType\n).\n```\n\nTrue for only three values: `dependencies`, `devDependencies` and `peerDependencies`.\n\n#### `workspace/1`\n\n``` language-prolog\nworkspace(\n  -WorkspaceCwd\n).\n```\n\nTrue if the workspace described by the specified `WorkspaceCwd` exists.\n\n#### `workspace_ident/2`\n\n``` language-prolog\nworkspace_ident(\n  ?WorkspaceCwd,\n  ?WorkspaceIdent\n).\n```\n\nTrue if the workspace described by the specified `WorkspaceCwd` exists and if it has the specified `WorkspaceIdent`.\n\n#### `workspace_version/2`\n\n``` language-prolog\nworkspace_version(\n  ?WorkspaceCwd,\n  ?WorkspaceVersion\n).\n```\n\nTrue if the workspace described by the specified `WorkspacedCwd` exists and if it has the specified `WorkspaceVersion`.\n\n#### `workspace_has_dependency/4`\n\n``` language-prolog\nworkspace_has_dependency(\n  ?WorkspaceCwd,\n  ?DependencyIdent,\n  ?DependencyRange,\n  ?DependencyType\n).\n```\n\nTrue if the workspace described by the specified `WorkspaceCwd` depends on the dependency described by the specified `DependencyIdent` and `DependencyRange` combination in the dependencies block of the given `DependencyType`.\n\n#### `workspace_field/3`\n\n``` language-prolog\nworkspace_field(\n  +WorkspaceCwd,\n  +FieldPath,\n  -FieldValue\n).\n```\n\nTrue if the workspace described by the `WorkspaceCwd` has the given `FieldValue` in the manifest at `FieldPath`.\n\nThe `FieldPath` can target properties of properties via `.` notation, e.g. a `FieldPath` of `'publishConfig.registry'` will set `FieldValue` to the value of the `registry` inside `publishConfig`.\n\n### `workspace_field_test/3`\n\n``` language-prolog\nworkspace_field(\n  +WorkspaceCwd,\n  +FieldPath,\n  +CheckCode\n).\n```\n\nTrue if the workspace described by the `WorkspaceCwd` has a value in the manifest at `FieldPath`, and if this value passes the check of `CheckCode`.\n\nThe `CheckCode` script is meant to be written in JavaScript, with the special variable `$$` representing the value obtained from the manifest. This makes `workspace_field_test` an escape hatch for some operations that would be too inconvenient to implement in Prolog (for example checking that a value is present within a JS array, etc).\n\nThe `Arguments` parameter is expected to be an optional Prolog list of atoms that will be passed to `CheckCode` through `$0`, `$1`, etc.\n\n### Constraint predicates\n\nThe following predicates will affect the behavior of the `yarn constraints` and `yarn constraints --fix` commands.\n\nThe parameters to the predicates are prefixed with `+` and `-`. These have the same meaning as in the query predicates. In this context they mean\n\n- `-` These are the output, they will not have a value when the predicate is invoked and the predicate must ensure a value is set\n- `+` These are the input, they will already have a value when the predicate is invoked\n\n#### `gen_enforced_dependency/4`\n\n``` language-prolog\ngen_enforced_dependency(\n  +WorkspaceCwd,\n  -DependencyIdent,\n  -DependencyRange,\n  +DependencyType\n).\n```\n\nThe `gen_enforced_dependency` rule offers a neat way to inform the package manager that a specific workspace MUST either depend on a specific range of a specific dependency (if `DependencyRange` is non-null) or not depend at all on the dependency (if `DependencyRange` is null; takes precedence over any conflicting range) in the `DependencyType` dependencies block.\n\nRunning `yarn constraints --fix` will instruct Yarn to fix the detected errors the best it can, but in some cases ambiguities will arise. Those will have to be solved manually, although Yarn will help you in the process.\n\n#### `gen_enforced_field/3`\n\n``` language-prolog\ngen_enforced_field(\n  +WorkspaceCwd,\n  -FieldPath,\n  +FieldValue\n).\n```\n\nThe `gen_enforced_field` predicate tells the package manager that a specific workspace must have the given `FieldValue` in the manifest via the `FieldPath`. A `FieldValue` of `null` means the field has to be absent:\n\n``` language-text\n? gen_enforced_field(WorkspaceCwd, FieldPath, null).\n```\n\nNote that the value will be interpreted in JSON if possible, or as a regular string otherwise. So if you need to put a `null` value into a field, use the JSON syntax:\n\n``` language-text\n? gen_enforced_field(WorkspaceCwd, FieldPath, 'null').\n```\n\nFinally, if you need to put a string containing `null` into a field, use the JSON string syntax:\n\n``` language-text\n? gen_enforced_field(WorkspaceCwd, FieldPath, '\"null\"').\n```\n\nRunning `yarn constraints --fix` will instruct Yarn to fix the detected errors the best it can, but in some cases ambiguities will arise. Those will have to be solved manually, although Yarn will help you in the process.\n\n## Constraint recipes\n\nThe following constraints are a good starting point to figure out how to write your own rules. If you build one that you think would be a good fit for this section, open a PR and we'll add them here!\n\n> **Quick note about the Prolog syntax**\n>\n> Be aware that in prolog `X :- Y` basically means \"X is true for each Y that's true\". Similarly, know that UpperCamelCase names are variables that get \"replaced\" by every compatible value possible. Finally, the special variable name `_` simply discards the parameter value.\n\n### Prevent all workspaces from depending on a specific package\n\n``` language-prolog\ngen_enforced_dependency(WorkspaceCwd, 'tslib', null, DependencyType) :-\n  workspace_has_dependency(WorkspaceCwd, 'tslib', _, DependencyType).\n```\n\nWe define a rule that says that for each dependency of each workspace in our project, if this dependency name is `tslib`, then it exists a similar rule of the `gen_enforced_dependency` type that forbids the workspace from depending on `tslib`. This will cause the package manager to see that the rule isn't met, and autofix it when requested by removing the dependency from the workspace.\n\n### Prevent two workspaces from depending on conflicting versions of a same dependency\n\n``` language-prolog\ngen_enforced_dependency(WorkspaceCwd, DependencyIdent, DependencyRange2, DependencyType) :-\n  workspace_has_dependency(WorkspaceCwd, DependencyIdent, DependencyRange, DependencyType),\n  workspace_has_dependency(OtherWorkspaceCwd, DependencyIdent, DependencyRange2, DependencyType2),\n  DependencyRange \\= DependencyRange2.\n```\n\nWe define a `gen_enforced_dependency` rule that requires each dependency of each package (first `workspace_has_dependency`) if it also exists another dependency of another package (second `workspace_has_dependency`) that has the same name but a different range (`\\=` operator).\n\n### Force all workspace dependencies to be made explicit\n\n``` language-prolog\ngen_enforced_dependency(WorkspaceCwd, DependencyIdent, 'workspace:*', DependencyType) :-\n  workspace_ident(_, DependencyIdent),\n  workspace_has_dependency(WorkspaceCwd, DependencyIdent, _, DependencyType).\n```\n\nWe define a `gen_enforced_dependency` rule that requires the dependency range `workspace:*` to be used if the dependency name is also the name of a valid workspace. The final `workspace_has_dependency` check is there to ensure that this rule is only applied on workspace that currently depend on the specified workspace in the first place (if it wasn't there, the rule would instead force all workspaces to depend on one another).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/constraints](https://yarnpkg.com/features/constraints)"
- name: Contributing
  id: advanced/contributing
  summary: Thanks for being here! Yarn gives a lot of importance to being a community project, and we rely on your help as much as you rely on ours
  description: "# Contributing\n\nThanks for being here! Yarn gives a lot of importance to being a community project, and we rely on your help as much as you rely on ours. In order to help you help us, we've invested in an infra and documentation that should make contributing to Yarn very easy. If you have any feedback on what we could improve, please open an issue to discuss it!\n\n- [Opening an issue](#opening-an-issue)\n- [How can you help?](#how-can-you-help)\n- [Finding work to do](#finding-work-to-do)\n- [Writing your feature](#writing-your-feature)\n- [Testing your code](#testing-your-code)\n- [Formatting your code](#formatting-your-code)\n- [Checking Constraints](#checking-constraints)\n- [Preparing your PR to be released](#preparing-your-pr-to-be-released)\n- [Writing documentation](#writing-documentation)\n\n## Opening an issue\n\nWe have some rules regarding our issues. Please check [the following page](sherlock) for more details.\n\n## How can you help?\n\n- Review our documentation! We often aren't native english speakers, and our grammar might be a bit off. Any help we can get that makes our documentation more digestible is appreciated!\n\n- Talk about Yarn in your local meetups! Even our users aren't always aware of some of our features. Learn, then share your knowledge with your own circles!\n\n- Help with our infra! There are always small improvements to do: run tests faster, uniformize the test names, improve the way our version numbers are setup, ...\n\n- Write code! We have so many features we want to implement, and so little time to actually do it... Any help you can afford will be appreciated, and you will have the satisfaction to know that your work helped literally millions of developers!\n\n## Finding work to do\n\nIt might be difficult to know where to start on a fresh codebase. To help a bit with this, we try to mark various issues with tags meant to highlight issues that we think don't require as much context as others:\n\n- [Good First Issue](https://github.com/yarnpkg/berry/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22) are typically self-contained features of a limited scope that are a good way to get some insight as to how Yarn works under the hood.\n\n- [Help Wanted](https://github.com/yarnpkg/berry/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) are issues that don't require a lot of context but also have less impact than the ones who do, so no core maintainer has the bandwidth to work on them.\n\nFinally, feel free to pop on our [Discord channel](https://discordapp.com/invite/yarnpkg) to ask for help and guidance. We're always happy to see new blood, and will help you our best to make your first open-source contribution a success!\n\n## Writing your feature\n\nOur repository is setup in such a way that calling `yarn` inside it will always use the TypeScript sources themselves - you don't have to rebuild anything for your changes to be applied there (we use `@babel/register` to automatically transpile the files as we require them). The downside is that it's slower than the regular Yarn, but the improved developer experience is well worth it.\n\n``` language-bash\nyarn install # Will automatically pick up any changes you made to sources\n```\n\n## Testing your code\n\nWe currently have two testsuites, built for different purposes. The first one is unit tests and can be triggered by running the following command from anywhere within the repository:\n\n``` language-bash\nyarn test:unit\n```\n\nWhile various subcomponents that have a strict JS interface contract are tested via unit tests (for example the portable shell library, or the various util libraries we ship), Yarn as a whole relies on integration tests. Being much closer to what our users experience, they give us a higher confidence when refactoring the application that everything will work according to plan. Those tests can be triggered by running the following command (again, from anywhere within the repository):\n\n``` language-bash\nyarn build:cli\nyarn test:integration\n```\n\nNote that because we want to avoid adding the `@babel/register` overhead to each Yarn call the CLI will need to be prebuilt for the integration tests to run - that's what the `yarn build:cli` command is for. This unfortunately means that you will need to rebuild the CLI after each modification if you want the integration tests to pick up your changes.\n\nBoth unit tests and integration tests use Jest, which means that you can filter the tests you want to run by using the `-t` flag (or simply the file path):\n\n``` language-bash\nyarn test:unit yarnpkg-shell\nyarn test:integration -t 'it should correctly install a single dependency that contains no sub-dependencies'\n```\n\nShould you need to write a test (and you certainly will if you add a feature or fix a bug 😉), they are located in the following directories:\n\n- **Unit tests:** [`packages/*/tests`](https://github.com/search?utf8=%E2%9C%93&q=repo%3Ayarnpkg%2Fberry+filename%3Atest.ts+language%3ATypeScript+language%3ATypeScript&type=Code&ref=advsearch&l=TypeScript&l=TypeScript)\n- **Integration tests:** [`packages/acceptance-tests/pkg-test-specs/sources`](https://github.com/yarnpkg/berry/tree/master/packages/acceptance-tests/pkg-tests-specs/sources)\n\nThe `makeTemporaryEnv` utility generates a very basic temporary environment just for the context of your test. The first parameter will be used to generate a `package.json` file, the second to generate a `.yarnrc.yml` file, and the third is the callback that will be run once the temporary environment has been created.\n\n## Formatting your code\n\nBefore submitting your code for review, please make sure your code is properly formatted by using the following command from anywhere within the repository:\n\n``` language-bash\nyarn test:lint\n```\n\nWe use ESLint to check this, so using the `--fix` flag will cause ESLint to attempt to automatically correct most errors that might be left in your code:\n\n``` language-bash\nyarn test:lint --fix\n```\n\n## Checking Constraints\n\nWe use [constraints](../features/constraints) to enforce various rules across the repository. They are declared inside the [`constraints.pro` file](https://github.com/yarnpkg/berry/blob/master/constraints.pro) and their purposes are documented with comments.\n\nConstraints can be checked with `yarn constraints`, and fixed with `yarn constraints --fix`. Generally speaking:\n\n- Workspaces must not depend on conflicting ranges of dependencies. Use the `-i,--interactive` flag and select \"Reuse\" when installing dependencies and you shouldn't ever have to deal with this rule.\n\n- Workspaces must not depend on non-workspace ranges of available workspaces. Use the `-i,--interactive` flag and select \"Reuse\" or \"Attach\" when installing dependencies and you shouldn't ever have to deal with this rule.\n\n- Workspaces that are part of the standard bundle or plugins must have specific build scripts. The ones that aren't, must be declared inside the `constraints.pro` file with `inline_compile`.\n\n- Workspaces must point our repository through the `repository` field.\n\n## Preparing your PR to be released\n\nIn order to track which packages need to be released, we use the workflow described in the [following document](../features/release-workflow). To summarize, you must run `yarn version check --interactive` on each PR you make, and select which packages should be released again for your changes to be effective (and to which version), if any.\n\nYou can check if you've set everything correctly with `yarn version check`.\n\nIf you expect a package to have to be released again but Yarn doesn't offer you this choice, first check whether the name of your local branch is `master`. If that's the case, Yarn might not be able to detect your changes (since it will do it against `master`, which is yourself). Run the following commands:\n\n``` language-bash\ngit checkout -b my-feature\ngit checkout -\ngit reset --hard upstream/master\ngit checkout -\nyarn version check --interactive\n```\n\nIf it fails and you have no idea why, feel free to ping a maintainer and we'll do our best to help you.\n\n**Note:** If you modify one of the [default plugins](https://github.com/yarnpkg/berry#default-plugins), you will also need to bump `@yarnpkg/cli`.\n\n## Writing documentation\n\nOur website is stored within the [`packages/gatsby`](https://github.com/yarnpkg/berry/tree/master/packages/gatsby) directory. *Do not manually edit the html files in the `docs` folder!* Instead, just make your changes in the Gatsby directory (for example you'd edit this very page [here](https://github.com/yarnpkg/berry/blob/master/packages/gatsby/content/advanced/contributing.md)), then run the following command to spawn a local server and see your changes:\n\n``` language-bash\nyarn develop\n```\n\nOnce you're happy with what the documentation looks like, just commit your local changes and open a PR. Netlify will pick up your changes and spawn a fresh preview for everyone to see:\n\nOnce everything is green and a maintainer has reviewed your changes, we'll merge them and a bot will automatically trigger a rebuild of the website and update the `docs` folder 🙂\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/contributing](https://yarnpkg.com/advanced/contributing)"
- name: Error Codes
  id: advanced/error-codes
  summary: Keeping this convention will help our users to figure out which error codes can be found on this documentation and which ones should instead be checked against the individual documentation of the plugins they use
  description: "# Error Codes\n\n> *Are you a plugin author and want to declare your own error codes that don't match the semantic of the ones provided here? Please relinquish one character and use the `YNX` prefix (ex `YNX001`) instead of `YN0`!*\n>\n> *Keeping this convention will help our users to figure out which error codes can be found on this documentation and which ones should instead be checked against the individual documentation of the plugins they use.*\n\n- [YN0000 - `UNNAMED`](#yn0000---unnamed)\n- [YN0001 - `EXCEPTION`](#yn0001---exception)\n- [YN0002 - `MISSING_PEER_DEPENDENCY`](#yn0002---missing_peer_dependency)\n- [YN0003 - `CYCLIC_DEPENDENCIES`](#yn0003---cyclic_dependencies)\n- [YN0004 - `DISABLED_BUILD_SCRIPTS`](#yn0004---disabled_build_scripts)\n- [YN0005 - `BUILD_DISABLED`](#yn0005---build_disabled)\n- [YN0006 - `SOFT_LINK_BUILD`](#yn0006---soft_link_build)\n- [YN0007 - `MUST_BUILD`](#yn0007---must_build)\n- [YN0008 - `MUST_REBUILD`](#yn0008---must_rebuild)\n- [YN0009 - `BUILD_FAILED`](#yn0009---build_failed)\n- [YN0010 - `RESOLVER_NOT_FOUND`](#yn0010---resolver_not_found)\n- [YN0011 - `FETCHER_NOT_FOUND`](#yn0011---fetcher_not_found)\n- [YN0012 - `LINKER_NOT_FOUND`](#yn0012---linker_not_found)\n- [YN0013 - `FETCH_NOT_CACHED`](#yn0013---fetch_not_cached)\n- [YN0014 - `YARN_IMPORT_FAILED`](#yn0014---yarn_import_failed)\n- [YN0015 - `REMOTE_INVALID`](#yn0015---remote_invalid)\n- [YN0016 - `REMOTE_NOT_FOUND`](#yn0016---remote_not_found)\n- [YN0017 - `RESOLUTION_PACK`](#yn0017---resolution_pack)\n- [YN0018 - `CACHE_CHECKSUM_MISMATCH`](#yn0018---cache_checksum_mismatch)\n- [YN0019 - `UNUSED_CACHE_ENTRY`](#yn0019---unused_cache_entry)\n- [YN0020 - `MISSING_LOCKFILE_ENTRY`](#yn0020---missing_lockfile_entry)\n- [YN0021 - `WORKSPACE_NOT_FOUND`](#yn0021---workspace_not_found)\n- [YN0022 - `TOO_MANY_MATCHING_WORKSPACES`](#yn0022---too_many_matching_workspaces)\n- [YN0023 - `CONSTRAINTS_MISSING_DEPENDENCY`](#yn0023---constraints_missing_dependency)\n- [YN0024 - `CONSTRAINTS_INCOMPATIBLE_DEPENDENCY`](#yn0024---constraints_incompatible_dependency)\n- [YN0025 - `CONSTRAINTS_EXTRANEOUS_DEPENDENCY`](#yn0025---constraints_extraneous_dependency)\n- [YN0026 - `CONSTRAINTS_INVALID_DEPENDENCY`](#yn0026---constraints_invalid_dependency)\n- [YN0027 - `CANT_SUGGEST_RESOLUTIONS`](#yn0027---cant_suggest_resolutions)\n- [YN0028 - `FROZEN_LOCKFILE_EXCEPTION`](#yn0028---frozen_lockfile_exception)\n- [YN0029 - `CROSS_DRIVE_VIRTUAL_LOCAL`](#yn0029---cross_drive_virtual_local)\n- [YN0030 - `FETCH_FAILED`](#yn0030---fetch_failed)\n- [YN0031 - `DANGEROUS_NODE_MODULES`](#yn0031---dangerous_node_modules)\n- [YN0032 - `NODE_GYP_INJECTED`](#yn0032---node_gyp_injected)\n- [YN0046 - `AUTOMERGE_FAILED_TO_PARSE`](#yn0046---automerge_failed_to_parse)\n- [YN0047 - `AUTOMERGE_IMMUTABLE`](#yn0047---automerge_immutable)\n- [YN0048 - `AUTOMERGE_SUCCESS`](#yn0048---automerge_success)\n- [YN0049 - `AUTOMERGE_REQUIRED`](#yn0049---automerge_required)\n- [YN0050 - `DEPRECATED_CLI_SETTINGS`](#yn0050---deprecated_cli_settings)\n- [YN0059 - `INVALID_RANGE_PEER_DEPENDENCY`](#yn0059---invalid_range_peer_dependency)\n- [YN0060 - `INCOMPATIBLE_PEER_DEPENDENCY`](#yn0060---incompatible_peer_dependency)\n- [YN0061 - `DEPRECATED_PACKAGE`](#yn0061---deprecated_package)\n- [YN0062 - `INCOMPATIBLE_OS`](#yn0062---incompatible_os)\n- [YN0063 - `INCOMPATIBLE_CPU`](#yn0063---incompatible_cpu)\n- [YN0068 - `UNUSED_PACKAGE_EXTENSION`](#yn0068---unused_package_extension)\n- [YN0069 - `REDUNDANT_PACKAGE_EXTENSION`](#yn0069---redundant_package_extension)\n- [YN0071 - `NM_CANT_INSTALL_EXTERNAL_SOFT_LINK`](#yn0071---nm_cant_install_external_soft_link)\n- [YN0072 - `NM_PRESERVE_SYMLINKS_REQUIRED`](#yn0072---nm_preserve_symlinks_required)\n- [YN0074 - `NM_HARDLINKS_MODE_DOWNGRADED`](#yn0074---nm_hardlinks_mode_downgraded)\n- [YN0075 - `PROLOG_INSTANTIATION_ERROR`](#yn0075---prolog_instantiation_error)\n- [YN0076 - `INCOMPATIBLE_ARCHITECTURE`](#yn0076---incompatible_architecture)\n- [YN0077 - `GHOST_ARCHITECTURE`](#yn0077---ghost_architecture)\n\n## YN0000 - `UNNAMED`\n\nThis code is used to log regular messages, mostly to align all the lines in the Yarn output. No worry!\n\n## YN0001 - `EXCEPTION`\n\nAn exception had be thrown by the program.\n\nThis error typically should never happen (it should instead point to a different error message from this page so that it can be properly documented), so it should be considered a bug in Yarn. Feel free to open an issue or, even better, a pull request aiming to fix it.\n\n## YN0002 - `MISSING_PEER_DEPENDENCY`\n\nA package requests a peer dependency, but one or more of its parents in the dependency tree doesn't provide it.\n\nNote that Yarn enforces peer dependencies at every level of the dependency tree. That is, if `─D>` is a dependency and `─P>` is a peer dependency,\n\n``` language-sh\n# bad\nproject\n├─D> packagePeer\n└─D> packageA\n     └─P> packageB\n          └─P> packagePeer\n\n# good\nproject\n├─D> packagePeer\n└─D> packageA\n     ├─P> packagePeer\n     └─D> packageB\n          └─P> packagePeer\n```\n\nDepending on your situation, multiple options are possible:\n\n- The author of `packageA` can fix this problem by adding a peer dependency on `packagePeer`. If relevant, they can use [optional peer dependencies](../configuration/manifest#peerDependenciesMeta.optional) to this effect.\n\n- The author of `packageB` can fix this problem by marking the `packagePeer` peer dependency as optional - but only if the peer dependency is actually optional, of course!\n\n- The author of `project` can fix this problem by manually overriding the `packageA` and/or `packageB` definitions via the [`packageExtensions` config option](../configuration/yarnrc#packageExtensions).\n\nTo understand more about this issue, check out [this blog post](https://dev.to/arcanis/implicit-transitive-peer-dependencies-ed0).\n\n## YN0003 - `CYCLIC_DEPENDENCIES`\n\nTwo packages with build scripts have cyclic dependencies.\n\nCyclic dependencies are a can of worms. They happen when a package `A` depends on a package `B` and vice-versa Sometime can arise through a chain of multiple packages - for example when `A` depends on `B`, which depends on `C`, which depends on `A`.\n\nWhile cyclic dependencies may work fine in the general Javascript case (and in fact Yarn won't warn you about it in most cases), they can cause issues as soon as build scripts are involved. Indeed, in order to build a package, we first must make sure that its own dependencies have been properly built. How can we do that when two packages reference each other? Since the first one to build cannot be deduced, such patterns will cause the build scripts of every affected package to simply be ignored (and a warning emitted).\n\nThere's already good documentation online explaining how to get rid of cyclic dependencies, the simplest one being to extract the shared part of your program into a third package without dependencies. So the first case we described would become `A` depends on `C`, `B` depends on `C`, `C` doesn't depend on anything.\n\n## YN0004 - `DISABLED_BUILD_SCRIPTS`\n\nA package has build scripts, but they've been disabled across the project.\n\nBuild scripts can be disabled on a global basis through the use of the `enableScripts` settings. When it happens, a warning is still emitted to let you know that the installation might not be complete.\n\nThe safest way to downgrade the warning into a notification is to explicitly disable build scripts for the affected packages through the use of the `dependenciesMeta[].built` key.\n\n## YN0005 - `BUILD_DISABLED`\n\nA package has build scripts, but they've been disabled through its configuration.\n\nBuild scripts can be disabled on a per-project basis through the use of the `dependenciesMeta` settings from the `package.json` file. When it happens, a notification is still emitted to let you know that the installation might not be complete.\n\n## YN0006 - `SOFT_LINK_BUILD`\n\nA package has build scripts, but is linked through a soft link.\n\nFor Yarn, a hard link is when a package is owned by the package manager. In these instances Yarn will typically copy packages having build scripts into a project-local cache so that multiple projects with multiple dependency trees don't use the same build artifacts. So what's the problem with so-called \"soft links\"?\n\nSoft links are when the package manager doesn't own the package source. An example is a workspace, or a dependency referenced through the `portal:` specifier. In these instances Yarn cannot safely assume that executing build scripts there is the intended behavior, because it would likely involve mutating your project or, even worse, an external location on your disk that might be shared by multiple projects. Since Yarn avoids doing anything unsafe, it cannot run build scripts on soft links.\n\nThere are a few workarounds:\n\n- Using `file:` instead of `portal:` will cause a hard link to be used instead of a soft link. The other side of the coin will be that the packages will be copied into the cache as well, meaning that changing the package source will require you to run `YARN_UPDATE_FILE_CACHE=1 yarn install` for your changes to be taken into account.\n\n- You can manually run `yarn run postinstall` (or whatever is named your build script) from the directory of the affected packages. This requires you to know in which order they'll have to be called, but is generally the safest option.\n\n- You can simply abstain from using build scripts with soft links. While this suggestion might seem like a bad case of \"fix a problem by not encountering the problem\", consider that build scripts in development might not be of the best effect from a developer experience perspective - they usually mean that you'll need to run a script before being able to see your changes, which is often not what you seek.\n\n## YN0007 - `MUST_BUILD`\n\nA package must be built.\n\nThis informational message occurs when Yarn wishes to let you know that a package will need to be built for the installation to complete. This usually occurs in only two cases: either the package never has been built before, or its previous build failed (returned a non-zero exit code).\n\n## YN0008 - `MUST_REBUILD`\n\nA package must be rebuilt.\n\nThis information message occurs when Yarn wishes to let you know that a package will need to be rebuilt in order for the installation to complete. This usually occurs in a single case: when the package's dependency tree has changed. Note that this also includes its transitive dependencies, which sometimes may cause surprising rebuilds (for example, if `A` depends on `B` that depends on `C@1`, and if Yarn decides for some reason that `C` should be bumped to `C@2`, then `A` will need to be rebuilt).\n\n## YN0009 - `BUILD_FAILED`\n\nA package build failed.\n\nThis problem typically doesn't come from Yarn itself, and simply means that a package described as having build directives couldn't get built successfully.\n\nTo see the actual error message, read the file linked in the report. It will contain the full output of the failing script.\n\n## YN0010 - `RESOLVER_NOT_FOUND`\n\nA resolver cannot be found for the given package.\n\nResolvers are the components tasked from converting ranges (`^1.0.0`) into references (`1.2.3`). They each contain their own logic to do so - the semver resolver is the most famous one but far from being the only one. The GitHub resolver transforms GitHub repositories into tarball urls, the Git resolver normalizes the paths sent to git, ... each resolver takes care of a different resolution strategy. A missing resolver means that one of those strategies is missing.\n\nThis error is usually caused by a Yarn plugin being missing.\n\n## YN0011 - `FETCHER_NOT_FOUND`\n\nA fetcher cannot be found for the given package.\n\nFetchers are the components that take references and fetch the source code from the remote location. A semver fetcher would likely fetch the packages from some registry, while a workspace fetcher would simply redirect to the location on the disk where the sources can be found.\n\nThis error is usually caused by a Yarn plugin being missing.\n\n## YN0012 - `LINKER_NOT_FOUND`\n\nA linker cannot be found for the given package.\n\nLinkers are the components tasked from extracting the sources from the artifacts returned by the fetchers and putting them on the disk in a manner that can be understood by the target environment. The Node linker would use the Plug'n'Play strategy, while a PHP linker would use an autoload strategy instead.\n\nThis error is usually caused by a Yarn plugin being missing.\n\n## YN0013 - `FETCH_NOT_CACHED`\n\nA package cannot be found in the cache for the given package and will be fetched from its remote location.\n\nWhen a package is downloaded from whatever its remote location is, Yarn stores it in a specific folder called then cache. Then, the next time this package was to be downloaded, Yarn simply check this directory and use the stored package if available. This message simply means that the package couldn't be found there. It's not a huge issue, but you probably should try to limit it as much as possible - for example by using [Zero-Installs](../features/zero-installs).\n\n## YN0014 - `YARN_IMPORT_FAILED`\n\nA lockfile couldn't be properly imported from a v1 lockfile.\n\nThe v2 release contains major changes in the way Yarn is designed, and the lockfile format is one of them. In some rare cases, the data contained in the v1 lockfile aren't compatible with the ones we stored within the v2 files. When it happens, Yarn will emit this warning and resolve the package descriptor again. Only this package will be affected; all others will continue to be imported as expected.\n\n## YN0015 - `REMOTE_INVALID`\n\nThe remote source returned invalid data.\n\nThis error is thrown by the resolvers and fetchers when the remote sources they communicate with return values that aren't consistent with what we would expect (for example because they are missing fields).\n\n## YN0016 - `REMOTE_NOT_FOUND`\n\nThe remote source returned valid data, but told us the package couldn't be found.\n\nThis error is thrown by the resolvers and fetchers when the remote sources they communicate with inform them that the package against which have been made the request doesn't exist. This might happen if the package has been unpublished, and there's usually nothing Yarn can do.\n\n## YN0017 - `RESOLUTION_PACK`\n\nThis error code isn't used at the moment (it used to print the number of packages that took part in each pass of the resolution algorithm, but was deemed too verbose compared to its usefulness).\n\n## YN0018 - `CACHE_CHECKSUM_MISMATCH`\n\nThe checksum of a package from the cache doesn't match what the lockfile expects.\n\nThis situation usually happens after you've modified the zip archives from your cache by editing the files it contains for debug purposes. Use one of the two following commands in order to bypass it:\n\n- `YARN_CHECKSUM_BEHAVIOR=reset` will remove the files from the cache and download them again\n- `YARN_CHECKSUM_BEHAVIOR=update` will update the lockfile to contain the new checksum\n- `YARN_CHECKSUM_BEHAVIOR=ignore` will use the existing files but won't update the lockfile\n\n## YN0019 - `UNUSED_CACHE_ENTRY`\n\nA file from the cache has been detected unused while installing dependencies.\n\nRunning `yarn cache clean` will cause Yarn to remove everything inside `.yarn/cache`.\n\n## YN0020 - `MISSING_LOCKFILE_ENTRY`\n\nA package descriptor cannot be found in the lockfile.\n\nA lot of commands (for example `yarn run`) require the lockfile to be in a state consistent with the current project in order to behave properly. This error will be generated when Yarn detects that your project references a package that isn't listed within the lockfile (usually because you modified a `dependencies` field without running `yarn install`, or because you added a new workspace). Running `yarn install` will almost certainly fix this particular error.\n\n## YN0021 - `WORKSPACE_NOT_FOUND`\n\nA dependency uses a `workspace:` range that cannot be resolved to an existing workspace.\n\nThe `workspace:` protocol is a new feature that appeared in Yarn v2 that allows to target a specific workspace of the current project without risking to ever pull data from other sources in case the workspace doesn't exist. This error precisely means that the workspace doesn't exist for the reason described in the error message.\n\n## YN0022 - `TOO_MANY_MATCHING_WORKSPACES`\n\nThis error should be considered obsolete and not exist; open an issue if you have it.\n\n## YN0023 - `CONSTRAINTS_MISSING_DEPENDENCY`\n\nOne of your workspaces should depend on a dependency but doesn't.\n\nA [constraint](../features/constraints) has been put into effect that declares that the specified workspace must depend on the specified range of the specified dependency. Since it currently doesn't, Yarn emits this error when running `yarn constraints check`. In order to fix it simply run `yarn constraints fix` which will autofix all such errors.\n\n## YN0024 - `CONSTRAINTS_INCOMPATIBLE_DEPENDENCY`\n\nOne of your workspaces should depend on a specific version of a dependency but doesn't.\n\nA [constraint](../features/constraints) has been put into effect that declares that the specified workspace must depend on the specified range of the specified dependency. Since it currently doesn't, Yarn emits this error when running `yarn constraints check`. In order to fix it simply run `yarn constraints fix` which will autofix all such errors.\n\n## YN0025 - `CONSTRAINTS_EXTRANEOUS_DEPENDENCY`\n\nOne of your workspaces shouldn't depend on one of the dependencies it lists.\n\nA [constraint](../features/constraints) has been put into effect that declares that the specified workspace must depend on the specified range of the specified dependency. Since it currently doesn't, Yarn emits this error when running `yarn constraints check`. In order to fix it simply run `yarn constraints fix` which will autofix all such errors.\n\n## YN0026 - `CONSTRAINTS_INVALID_DEPENDENCY`\n\nOne of your workspaces lists an invalid dependency.\n\nA [constraint](../features/constraints) has been put into effect that declares that the specified workspace probably shouldn't depend on the specified dependency in its current state. Since it currently does, Yarn emits this error when running `yarn constraints check`. Fixing this error require manual intervention as the fix is ambiguous from Yarn's point of view.\n\n## YN0027 - `CANT_SUGGEST_RESOLUTIONS`\n\nYarn cannot figure out proper range suggestions for the packages you're adding to your project.\n\nWhen running `yarn add` without adding explicit ranges to the packages to add, Yarn will try to find versions that match your intent. Generally it means that it will prefer project workspaces and, if it cannot find any, will instead try to query the npm registry for the list of published releases and use whatever is the highest one. This error means that this process failed and Yarn cannot successfully figure out which version of the package should be added to your project.\n\n## YN0028 - `FROZEN_LOCKFILE_EXCEPTION`\n\nYour lockfile would be modified if Yarn was to finish the install.\n\nWhen passing the `--immutable` option to `yarn install`, Yarn will ensure that the lockfile isn't modified in the process and will instead throw an exception if this situation was to happen (for example if a newly added package was missing from the lockfile, or if the current Yarn release required some kind of migration before being able to work with the lockfile).\n\nThis option is typically meant to be used on your CI and production servers, and fixing this error should simply be a matter of running `yarn install` on your local development environment and submitting a PR containing the updated lockfile.\n\n## YN0029 - `CROSS_DRIVE_VIRTUAL_LOCAL`\n\nThis error code is deprecated.\n\n## YN0030 - `FETCH_FAILED`\n\nThis error code isn't used at the moment; we ideally want to explain **why** did the fetch fail rather than .\n\n## YN0031 - `DANGEROUS_NODE_MODULES`\n\nYarn is installing packages using [Plug'n'Play](../features/pnp), but a `node_modules` folder has been found.\n\nThis warning is emitted when your project is detected as containing `node_modules` folders that actually seem to contain packages. This is not advised as they're likely relicts of whatever package manager you used before, and might confuse your tools and lead you into \"works on my machine\" situations.\n\n## YN0032 - `NODE_GYP_INJECTED`\n\nIn some situation Yarn might detect that `node-gyp` is required by a package without this package explicitly listing the dependency. This behavior is there for legacy reason and should not be relied upon for the following reasons:\n\n- The main way to detect whether `node-gyp` is implicitly required is to check whether the package contains a `bindings.gyp` file. However, doing this check implies that the package listing is known at the time Yarn resolves the dependency tree. This would require to fetch all npm archives as part of the resolution step (rather than wait until the dedicated fetch step), and all that just for the sake of this problematic feature.\n\n- Implicit dependencies on `node-gyp` don't provide any hint to the package manager as to which versions of `node-gyp` are compatible with the package being built. Yarn does its best by adding an implicit dependency on `npm:*`, but it might be wrong and we'll have no way to know it - your installs will just crash unexpectedly when compiled with incompatible versions.\n\nPackages omitting `node-gyp` usually do so in order to decrease the amount of packages in the final dependency tree when building the package isn't required (prebuilt binaries). While a reasonable wish, doing this goes against the package manager rules and we would prefer to solve this through a dedicated feature rather than through such hacks. In the meantime we strongly recommend to consider prebuilding native dependencies via WebAssembly if possible - then the `node-gyp` problem completely disappears.\n\n## YN0046 - `AUTOMERGE_FAILED_TO_PARSE`\n\nThis error is triggered when Git conflict tokens are found within the `yarn.lock` file and one or both of the individual candidate lockfiles cannot be parsed. This typically happens because of one of those two situations:\n\n- If you're working on a branch with Yarn v2 and are trying to merge a branch using Yarn v1, this error will be triggered (the v1 lockfiles aren't Yaml, which prevents them from being parsed. Even if we could, they don't contain enough information compared to the v2 lockfiles).\n\n  - The easiest way to fix it is to use `git checkout --theirs yarn.lock`, and follow up with `yarn install` again (which can be followup by `yarn cache clean` to remove any file that wouldn't be needed anymore). This will cause the v1 lockfile to be re-imported. The v2 resolutions will be lost, but Yarn will detect it and resolve them all over again.\n\n- If you have multiple levels of conflicts. Yarn doesn't support such conflicts, and you'll have to figure out a way to only have two levels. This is typically done by first resolving the conflicts between two branches, and then resolving them again on the merge result of the previous step and the third branch.\n\n## YN0047 - `AUTOMERGE_IMMUTABLE`\n\nThis error is triggered when Git conflict tokens are found within the `yarn.lock` file while Yarn is executing under the immutable mode (`yarn install --immutable`).\n\nWhen under this mode, Yarn isn't allowed to edit any file, not even for automatically resolving conflicts. This mode is typically used on CI to ensure that your projects are always in a correct state before being merged into the trunk.\n\nIn order to solve this problem, try running `yarn install` again on your computer without the `--immutable` flag, then commit the changes if the command succeeded.\n\n## YN0048 - `AUTOMERGE_SUCCESS`\n\nThis informational message is emitted when Git conflict tokens were found within the `yarn.lock` file but were automatically fixed by Yarn. There's nothing else to do, everything should work out of the box!\n\n## YN0049 - `AUTOMERGE_REQUIRED`\n\nThis informational message is emitted when Git conflict tokens are found within the `yarn.lock` file. Yarn will then try to automatically resolve the conflict by following its internal heuristic.\n\nThe automerge logic is pretty simple: it will take the lockfile from the pulled branch, modify it by adding the information from the local branch, and run `yarn install` again to fix anything that might have been lost in the process.\n\n## YN0050 - `DEPRECATED_CLI_SETTINGS`\n\nThis error is triggered when passing options to a CLI command through its arguments (for example `--cache-folder`).\n\nStarting from the v2, this isn't supported anymore. The reason for this is that we've consolidated all of our configuration inside a single store that can be defined from a yarnrc file. This guarantees that all your commands run inside the same environments (which previously wasn't the case depending on whether you were using `--cache-folder` on all your commands or just the install). CLI options will now only be used to control the *one-time-behaviors* of a particular command (like `--verbose`).\n\n**Special note for Netlify users:** Netlify currently [automatically passes](https://github.com/netlify/build-image/blob/f9c7f9a87c10314e4d65b121d45d68dc976817a2/run-build-functions.sh#L109) the `--cache-folder` option to Yarn, and you cannot disable it. For this reason we decided to make it a warning rather than an error when we detect that Yarn is running on Netlify (we still ignore the flag). We suggest upvoting [the relevant issue](https://github.com/netlify/build-image/issues/319) on their repository, as we're likely to remove this special case in a future major release.\n\n## YN0059 - `INVALID_RANGE_PEER_DEPENDENCY`\n\nA package requests a peer dependency, but the range provided is not a valid semver range. It is not possible to ensure the provided package meets the peer dependency request. The range must be fixed in order for the warning to go away. This will not prevent resolution, but may leave the system in an incorrect state.\n\n## YN0060 - `INCOMPATIBLE_PEER_DEPENDENCY`\n\nA package requests a peer dependency, but its parent in the dependency tree provides a version that does not satisfy the peer dependency's range. The parent should be altered to provide a valid version or the peer dependency range updated. This will not prevent resolution, but may leave the system in an incorrect state.\n\n## YN0061 - `DEPRECATED_PACKAGE`\n\nA package is marked as deprecated by the publisher. Avoid using it, use the alternative provided in the deprecation message instead.\n\n## YN0062 - `INCOMPATIBLE_OS`\n\nA package is incompatible with the operating system, as reported by [`process.platform`](https://nodejs.org/api/process.html#process_process_platform). Its installation will be skipped.\n\n## YN0063 - `INCOMPATIBLE_CPU`\n\nA package is incompatible with the CPU architecture, as reported by [`process.arch`](https://nodejs.org/api/process.html#process_process_arch). Its installation will be skipped.\n\n## YN0068 - `UNUSED_PACKAGE_EXTENSION`\n\nA packageExtension is detected by Yarn as being unused, which means that the selector doesn't match any of the installed packages.\n\n## YN0069 - `REDUNDANT_PACKAGE_EXTENSION`\n\nA packageExtension is detected by Yarn as being unneeded, which means that the selected packages have the same behavior with and without the extension.\n\n## YN0071 - `NM_CANT_INSTALL_EXTERNAL_SOFT_LINK`\n\nAn external soft link (portal) cannot be installed, because incompatible version of a dependency exists in the parent package. This prevents portal representation for node_modules installs without a need to write files into portal's target directory, which is forbidden for security reasons.\n\n**Workarounds** If the ranges for conflicting dependencies overlap between portal target and portal parent, the workaround is to use `yarn dedupe foo` (where `foo` is the conflicting dependency name) to upgrade the conflicting dependencies to the highest available versions, if `yarn dedupe` is used without arguments, all the dependencies across the project will be upgraded to the highest versions within their ranges in `package.json`. Another alternative is to use `link:` protocol instead of `portal:` and install dependencies inside the target directory explicitly.\n\n## YN0072 - `NM_PRESERVE_SYMLINKS_REQUIRED`\n\nA portal dependency with subdependencies is used in the project. `--preserve-symlinks` Node option must be used to start the application in order for portal dependency to find its subdependencies and peer dependencies.\n\n## YN0074 - `NM_HARDLINKS_MODE_DOWNGRADED`\n\n`nmMode` has been downgraded to `hardlinks-local` due to global cache and install folder being on different devices. Consider changing `globalFolder` setting and place the global cache on the same device as your project, if you want `hardlinks-global` to take effect.\n\n## YN0075 - `PROLOG_INSTANTIATION_ERROR`\n\nThis error appears when a Prolog predicate is called with an invalid signature. Specifically, it means that some of the predicate parameters are non-instantiated (ie have no defined value), when the predicate would expect some. This doesn't mean that you need to hardcode a value, just that you need to assign one before calling the predicate. In the case of the `WorkspaceCwd` parameter from most of the Yarn predicates, it means that instead of calling:\n\n``` language-text\nworkspace_field(WorkspaceCwd, 'name', _).\n```\n\nYou would also use the `workspace/1` predicate to let Prolog \"fill\" the `WorkspaceCwd` parameter prior to using it in `workspace_field/3`:\n\n``` language-text\nworkspace(WorkspaceCwd), workspace_field(WorkspaceCwd, 'name', _).\n```\n\nFor more information about the parameters that must be instantiated when calling the predicate reported by the error message, consult the [dedicated page](../features/constraints#query-predicate) from our documentation.\n\n## YN0076 - `INCOMPATIBLE_ARCHITECTURE`\n\nA package is specified in its manifest (through the [`os`](../configuration/manifest#os) / [`cpu`](../configuration/manifest#cpu) fields) as being incompatible with the system architecture. Its postinstall scripts will not run on this system.\n\n## YN0077 - `GHOST_ARCHITECTURE`\n\nSome native packages may be excluded from the install if they signal they don't support the systems the project is intended for. This detection is typically based on your current system parameters, but it can be configured using the [`supportedArchitectures` config option](../configuration/yarnrc#supportedArchitectures). If your os or cpu are missing from this list, Yarn will skip the packages and raise a warning.\n\nNote that all fields from `supportedArchitectures` default to `current`, which is a dynamic value depending on your local parameters. For instance, if you wish to support \"my current os, whatever it is, plus linux\", you can set `supportedArchitectures.os` to `[\"current\", \"linux\"]`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/error-codes](https://yarnpkg.com/advanced/error-codes)"
- name: Lexicon
  id: advanced/lexicon
  summary: Refers to tasks executed right after the packages got installed; typically the postinstall scripts configured in the scripts field from the manifest
  description: "# Lexicon\n\n- [Build Scripts](#build-scripts)\n- [Dependency](#dependency)\n- [Descriptor](#descriptor)\n- [Development Dependency](#development-dependency)\n- [Fetcher](#fetcher)\n- [Hoisting](#hoisting)\n- [Linker](#linker)\n- [Locator](#locator)\n- [Manifest](#manifest)\n- [Monorepository](#monorepository)\n- [Package](#package)\n- [Peer dependency](#peer-dependency)\n- [Peer-dependent Package](#peer-dependent-package)\n- [Plugin](#plugin)\n- [Plug'n'Play](#plugnplay)\n- [PnP](#pnp)\n- [Portal](#portal)\n- [Project](#project)\n- [Range](#range)\n- [Reference](#reference)\n- [Resolver](#resolver)\n- [Scope](#scope)\n- [Singleton Package](#singleton-package)\n- [Transitive Dependency](#transitive-dependency)\n- [Unplugged Package](#unplugged-package)\n- [Virtual Package](#virtual-package)\n- [Workspace](#workspace)\n- [Worktree](#worktree)\n- [Yarn](#yarn)\n- [Zero-Install](#zero-install)\n\n### Build Scripts\n\nRefers to tasks executed right after the packages got installed; typically the `postinstall` scripts configured in the [`scripts` field](../configuration/manifest#scripts) from the manifest.\n\nBuild scripts should be left to native dependencies, there is virtually no reason for pure JavaScript packages to use them. They have [significant side effects](lifecycle-scripts#a-note-about-postinstall) on your user's projects, so weight carefully whether you really need them.\n\nSee also: [Lifecycle Scripts](lifecycle-scripts)\n\n### Dependency\n\nA dependency (listed in the [`dependencies` field](../configuration/manifest#dependencies) of the manifest) describes a relationship between two packages.\n\nWhen a package A has a dependency B, Yarn guarantees that A will be able to access B if the install is successful. Note that this is the only promise we make regarding regular dependencies: in particular, there is no guarantee that package B will be the same version than the one used in other parts of the application.\n\nSee also: [Development Dependency](#development-dependency)\n\nSee also: [Peer Dependency](#peer-dependency)\n\n### Descriptor\n\nA descriptor is a combination of a package name (for example `lodash`) and a package range (for example `^1.0.0`). Descriptors are used to identify a set of packages rather than one unique package.\n\n### Development Dependency\n\nA dependency (listed in the [`devDependencies` field](../configuration/manifest#devDependencies) of the manifest) describes a relationship between two packages.\n\nDevelopment dependencies are very much like regular dependencies except that they only matter for local packages. Packages fetched from remote registries such as npm will not be able to access their development dependencies, but packages installed from local sources (such as [workspaces](#workspaces) or the [`portal:` protocol](#portals)) will.\n\nSee also: [Dependency](#dependency)\n\nSee also: [Peer Dependency](#peer-dependency)\n\n### Fetcher\n\nFetchers are the components tasked with extracting the full package data from a reference. For example, the npm fetcher would download the package tarballs from the npm registry.\n\nSee also: [Architecture](architecture)\n\nSee also: the [`Fetcher` interface](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts#L34)\n\n### Hoisting\n\nHoisting is the act of transforming the dependency tree to optimize it by removing as many nodes as possible. There isn't a single way to decide how to transform the tree, and different package managers make different tradeoffs (some optimize for package popularity, package size, highest versions, ...). For this reason, no guarantee can be made regarding the final hoisting layout - except that packages will always be able to access the dependencies they listed in their [manifests](#Manifest).\n\nBecause the hoisting is heavily connected to the filesystem and the Node resolution, its very design makes it easy to make an error and accidentally access packages without them being properly defined as dependencies - and thus without being accounted for during the hoisting process, making their very existence unpredictable. For this reason and others, hoisting got sidelined starting from Yarn 2 in favour of the [Plug'n'Play resolution](#plugnplay).\n\n### Linker\n\nLinkers are the components that consume both a dependency tree and a store of package data, and generate in return disk artifacts specific to the environment they target. For example, the Plug'n'Play linker generates a single `.pnp.cjs` file.\n\nSee also: [Architecture](architecture)\n\nSee also: the [`Linker` interface](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Linker.ts#L28)\n\nSee also: the [`Installer` interface](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Installer.ts#L18)\n\n### Locator\n\nA locator is a combination of a package name (for example `lodash`) and a package reference (for example `1.2.3`). Locators are used to identify a single unique package (interestingly, all valid locators also are valid descriptors).\n\n### Manifest\n\nA manifest is a `package.json` file.\n\n### Monorepository\n\nA monorepository is a repository that contains multiple packages. For example, [Babel](https://github.com/babel/babel/tree/master/packages) and [Jest](https://github.com/facebook/jest/tree/master/packages) are examples of such repositories - they each contain dozen of small packages that each rely on one another.\n\nSee also: [Workspaces](../features/workspaces)\n\n### Package\n\nPackages are nodes of the dependency tree. Simply put, a package is a bundle of source code usually characterized by a `package.json` at its root. Packages can define dependencies, which are other packages that need to be made available for it to work properly.\n\n### Peer dependency\n\nA dependency (listed in the [`peerDependencies` field](../configuration/manifest#peerDependencies) of the manifest) describes a relationship between two packages.\n\nContrary to regular dependencies, a package A with a peer dependency on B doesn't guarantee that A will be able to access B - it's up to the package that depends on A to manually provide a version of B compatible with request from A. This drawback has a good side too: the package instance of B that A will access is guaranteed to be the exact same one as the one used by the ancestor of A. This matters a lot when B uses `instanceof` checks or singletons.\n\nSee also: [Development Dependencies](#development-dependencies) See also: [Peer Dependency](#peer-dependency) See also: [Singleton Package](#singleton-package)\n\n### Peer-dependent Package\n\nA peer-dependent package is a package that lists peer dependencies.\n\nSee also: [Virtual Packages](#virtual-package)\n\n### Plugin\n\nPlugins are a new concept introduced in Yarn 2+. Through the use of plugins, Yarn can be extended and made even more powerful - whether it's through the addition of new resolvers, fetchers, or linkers.\n\nSee also: [Plugins](../features/plugins) See also: the [`Plugin` interface](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Plugin.ts#L67)\n\n### Plug'n'Play\n\nPlug'n'Play is an alternative installation strategy that, instead of generating the typical `node_modules` directories, generate one single file that is then injected into Node to let it know where to find the installed packages. Starting from the v2, Plug'n'Play becomes the default installation strategy for Javascript projects.\n\nSee also: [Plug'n'Play](../features/pnp)\n\n### PnP\n\nSee [Plug'n'Play](#plugnplay)\n\n### Portal\n\nA portal is a dependency that uses the `portal:` protocol, pointing to a package located on the disk.\n\nContrary to the `link:` protocol (which can point to any location but cannot have dependencies), Yarn will setup its dependency map in such a way that not only will the dependent package be able to access the file referenced through the portal, but the portal itself will also be able to access its own dependencies. Even peer dependencies!\n\n### Project\n\nThe term project is used to encompass all the worktrees that belong to the same dependency tree.\n\nSee also: [Workspaces](../features/workspaces)\n\n### Range\n\nA range is a string that, when combined with a package name, can be used to select multiple versions of a single package. Ranges typically follow semver, but can use any of the supported Yarn protocols.\n\nSee also: [Protocols](../features/protocols)\n\n### Reference\n\nA reference is a string that, when combined with a package name, can be used to select one single version of a single package. References typically follow semver, but can use any of the supported Yarn protocols.\n\nSee also: [Protocols](../features/protocols)\n\n### Resolver\n\nResolvers are the components tasked from converting descriptors into locators, and extracting the package manifests from the package locators. For example, the npm resolver would check what versions are available on the npm registry and return all the candidates that satisfy the semver requirements, then would query the npm registry to fetch the full metadata associated with the selected resolution.\n\nSee also: [Architecture](architecture) See also: the [`Resolver` interface](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L45)\n\n### Scope\n\nScopes are a term linked inherited from the npm registry; they are used to describe a set of packages that all belong to the same entity. For example, all the Yarn packages related to the v2 belong to the `berry` scope on the npm registry. Scopes are traditionally prefixed with the `@` symbol.\n\n### Singleton Package\n\nA singleton package is a package which is instantiated a single time across the dependency tree.\n\nWhile singleton packages aren't a first-class citizen, they can be easily created using [peer dependencies](#peer-dependency) by using one of their properties: since packages depended upon by peer dependencies are guaranteed to be the exact same instance as the one used by their direct ancestor, using peer dependencies across the entire dependency branch all the way up to the nearest workspace will ensure that a single instance of the package is ever created - making it a de-facto singleton package.\n\nSee also: [Peer Dependency](#peer-dependency)\n\n### Transitive Dependency\n\nA transitive dependency is a dependency of a package you depend on.\n\nImagine the case of `react`. Your application depends on it (you listed it yourself in your manifest), so it's a direct dependency. But `react` also depends on `prop-types`! That makes `prop-types` a transitive dependency, in that you don't directly declare it.\n\n### Unplugged Package\n\nWith Yarn PnP, most packages are kept within their zip archives rather than being unpacked on the disk. The archives are then mounted on the filesystem at runtime, and transparently accessed. The mounts are read-only so that the archives don't get corrupted if something tries to write into them.\n\nIn some cases, however, keeping the package read-only may be difficult (such as when a package lists postinstall scripts - the build steps will often need to generate build artifacts, making read-only folders impractical). For those situations, Yarn can unpack specific packages and keep them into their own individual folders. Such packages are referred to as \"unplugged\".\n\nPackages are unplugged in a few scenarios:\n\n- explicitly by setting the [`unplugged` field](../configuration/manifest#dependenciesMeta.unplugged) to `true`\n- explicitly when the package set its [`preferUnplugged` field](../configuration/manifest#preferUnplugged) to `true`\n- implicitly when the package lists postinstall scripts\n- implicitly when the package contains native files\n\n### Virtual Package\n\nBecause [peer-dependent packages](#peer-dependent-package) effectively define an *horizon* of possible dependency sets rather than a single static set of dependencies, a peer-dependent package may have multiple dependency sets. When this happens, the package will need to be instantiated at least once for each such set.\n\nSince in Node-land the JS modules are instantiated based on their path (a file is never instantiated twice for any given path), and since PnP makes it so that packages are installed only once in any given project, the only way to instantiate those packages multiple times is to give them multiple paths while still referencing to the same on-disk location. That's where virtual packages come handy.\n\nVirtual packages are specialized instances of the peer-dependent packages that encode the set of dependencies that this particular instance should use. Each virtual package is given a unique filesystem path that ensures that the scripts it references will be instantiated with their proper dependency set.\n\nIn the past virtual packages were implemented using symlinks, but this recently changed and they are now implemented through a virtual filesystem layer. This circumvents the need to create hundreds of confusing symlinks, improving compatibility with Windows and preventing issues that would arise with third-party tools calling `realpath`.\n\n### Workspace\n\nGenerally speaking workspaces are a Yarn features used to work on multiple projects stored within the same repository.\n\nIn the context of Yarn's vocabulary, workspaces are local packages that directly belong to a project.\n\nSee also: [Packages](../features/packages)\n\nSee also: [Workspaces](../features/workspaces)\n\n### Worktree\n\nA worktree is a private workspace that adds new child workspaces to the current project.\n\nSee also: [Workspaces](../features/workspaces)\n\n### Yarn\n\nYarn is a command line tool used to manage programming environments. Written in Javascript, it is mostly used along with other Javascript projects but has capabilities that make it suitable to be used in various situations.\n\n### Zero-Install\n\nSee also: [Zero-Install](../features/zero-installs)\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/lexicon](https://yarnpkg.com/advanced/lexicon)"
- name: Lifecycle Scripts
  id: advanced/lifecycle-scripts
  summary: Packages can define in the scripts field of their manifest various actions that should be executed when the package manager executes a particular workflow
  description: "# Lifecycle Scripts\n\nPackages can define in the `scripts` field of their manifest various actions that should be executed when the package manager executes a particular workflow. Here they are:\n\n> **Note about `yarn pack`:** Although rarely called directly, `yarn pack` is a crucial part of Yarn. Each time Yarn has to fetch a dependency from a \"raw\" source (such as a Git repository), it will automatically run `yarn install` and `yarn pack` on it to know which are the files to use.\n\n- **prepack** is the lifecycle script called before each call to `yarn pack`. This is typically the place where you'll want to put scripts that build a package - such as transpiling its source.\n\n- **postpack** is called right after `yarn pack`, whether the call succeeded or not. This is typically the place where you'll clean your working directory from the build artifacts (note that whether to actually clean them or not is purely optional).\n\n- **prepublish** is called before `yarn npm publish` and similar commands (even before the package has been packed). This is the place where you'll want to check that the project is in an ok state. Because it's only called on prepublish, **the prepublish hook shouldn't have side effects.** In particular don't transpile the package sources in prepublish, as people consuming directly your repository (such as through the [`git:` protocol](../features/protocols#git)) wouldn't be able to use your project.\n\n- **postinstall** is called after a package's dependency tree changes are written to the disk -- e.g. after a dependency or transitive dependency is added, removed, or changed. It is guaranteed to be called in topological order (in other words, your dependencies' postinstalls will always run before yours). For backwards compatibility, **preinstall** and **install** are called as part of **postinstall**.\n\nNote that we don't support every single lifecycle script originally present in npm. This is a deliberate decision based on the observation that too many lifecycle scripts make it difficult to know which one to use in which circumstances, leading to confusion and mistakes. We are open to add the missing ones on a case-by-case basis if compelling use cases are provided.\n\n> In particular, we intentionally don't support arbitrary `pre` and `post` hooks for user-defined scripts (such as `prestart`). This behavior, inherited from npm, caused scripts to be implicit rather than explicit, obfuscating the execution flow. It also led to surprising executions with `yarn serve` also running `yarn preserve`.\n\n## A note about `postinstall`\n\nPostinstall scripts have very real consequences for your users. In most cases Yarn will keep the installed packages in its cache under their archive form, and will instruct Node to load the files directly from there. This leads to much smaller installs, and eventually to [Zero-Installs](../features/zero-installs).\n\nUnfortunately postinstall scripts break this model because they signal Yarn that those packages may need to mutate their own directory, forcing them to be extracted into physical locations on the disk and leading to heavier, slower, and less stable installs.\n\nDepending on your use case, here's how you can avoid postinstall scripts:\n\n- Native packages can be built to [WebAssembly](https://webassembly.org), which is already supported in Node 12 and beyond. On top of being portable and fast, WebAssembly packages also have the benefit to make your libraries available not only to Node but also to your browser users. And since their compilation is made upfront, your users won't be impacted by slow compilation time problems.\n\n- Project sustainability is a big topic, but the gist is that we don't think postinstall scripts are a viable solution. We however are committed to providing a specific field in the package.json that would signal to the package managers that a project would like to communicate its existence with the user in an integrated and respectful way.\n\n## Environment variables\n\nWhen running scripts and binaries, some environment variables are usually made available:\n\n- `$INIT_CWD` represents the directory from which the script has been invoked. This isn't the same as the cwd, which for scripts is always equal to the closest package root.\n\n- `$PROJECT_CWD` is the root of the project on the filesystem.\n\n- `$npm_package_name` is the name of the package that lists the script being executed.\n\n- `$npm_package_version` is its version.\n\n- `$npm_execpath` is the path to the Yarn binary.\n\n- `$npm_node_execpath` is the path to the Node binary.\n\n- `$npm_config_user_agent` is a string defining the Yarn version currently in use.\n\n- `$npm_lifecycle_event` is the name of the script or lifecycle event, if relevant.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/lifecycle-scripts](https://yarnpkg.com/advanced/lifecycle-scripts)"
- name: Manifests (package.json)
  id: configuration/manifest
  summary: Manifest files (also called package.json because of their name) contain everything needed to describe the settings unique to one particular package
  description: "# Manifests (package.json)\n\nManifest files (also called `package.json` because of their name) contain everything needed to describe the settings unique to one particular package. Project will contain multiple such manifests if they use the workspace feature, as each workspace is described through its own manifest. Note that defaults for these fields can be set via the `initFields` settings.\n\n## name\n\nThe name of the package. Used to identify it across the application, especially amongst multiple workspaces. The first part of the name (here `@scope/`) is optional and is used as a namespace).\n\n\"name\": \"@scope/name\",\n\n## version\n\nThe version of the package. Usually doesn't have any impact on your project, except when it is a workspace - then its version must match the specified ranges for the workspace to be selected as resolution candidate.\n\n\"version\": \"1.2.3\",\n\n## type\n\nA Node.js v13.x [option](https://nodejs.org/api/esm.html#esm_package_json_type_field). Possible values are `commonjs` (the default) and `module`. Yarn 3+ will generate a `.pnp.cjs` file when using PnP regardless of this option.\n\n\"type\": \"commonjs\",\n\n## private\n\nIf true, the package is considered private and Yarn will refuse to publish it regardless of the circumstances. Setting this flag also unlocks some features that wouldn't make sense in published packages, such as workspaces.\n\n\"private\": true,\n\n## license\n\nAn SPDX identifier that indicates under which license is your package distributed.\n\n\"license\": \"MIT\",\n\n## os\n\nA value compared during install with `process.platform`. If the values don't match, the package won't see its postinstall scripts run (if listed in `dependencies`) or won't be installed at all (if listed in `optionalDependencies`).\n\n\"os\": \\[\n\n\"linux\",\n\n\"darwin\",\n\n\"win32\",\n\n\\]\n\n## cpu\n\nA value compared during install with `process.arch`. If the values don't match, the package won't see its postinstall scripts run (if listed in `dependencies`) or won't be installed at all (if listed in `optionalDependencies`).\n\n\"cpu\": \\[\n\n\"x64\",\n\n\"ia32\",\n\n\"arm64\",\n\n\\]\n\n## main\n\nThe path that will be used to resolve the qualified path to use when accessing the package by its name. This field can be modified at publish-time through the use of the `publishConfig.main` field.\n\n\"main\": \"./sources/index.js\",\n\n## module\n\nThe path that will be used when an ES6-compatible environment will try to access the package by its name. Doesn't have any direct effect on Yarn itself.\n\n\"module\": \"./sources/index.mjs\",\n\n## languageName\n\nAn enumeration used by the linker plugins to figure which linker should install a specific package. Only some values are allowed, consult the documentation to know more.\n\n\"languageName\": \"node\",\n\n## bin\n\nA field used to expose some executable Javascript files to the parent package. Any entry listed here will be made available through the `$PATH`. Note that it is very advised to only expose Javascript files for portability reasons (shellscripts and non-js binaries require the user to have a specific shell, and are incompatible with zip access).\n\n\"bin\": {\n\n\"my-bin\": \"./dist/my-bin.js\",\n\n}\n\n## scripts\n\nA field used to list small shell scripts that will be executed when running `yarn run`. Scripts are by default executed by a miniature shell, so some advanced features might not be available (if you have more complex needs, we recommend you to just execute a Javascript file). Note that scripts containing `:` (the colon character) are globals to your project and can be called regardless of your current workspace. Finally, be aware that scripts are always executed relative to the closest workspace (never the cwd).\n\n\"scripts\": {\n\n\"test\": \"jest\",\n\n\"build\": \"webpack-cli --config ./webpack.config.js\",\n\n\"count-words\": \"echo \\\\$@\\\\ \\| wc -w\",\n\n}\n\n## dependencies\n\nThe set of dependencies that must be made available to the current package in order for it to work properly. Consult the list of supported ranges for more information.\n\n\"dependencies\": {\n\n\"webpack\": \"^5.0.0\",\n\n}\n\n## optionalDependencies\n\nSimilar to the `dependencies` field, except that these entries will not be required to build properly should they have any build script. Note that such dependencies must always be resolvable (otherwise we couldn't store it in the lockfile, which could lead to non-reproducible installs), but those which list `cpu`/`os` fields will not be fetched unless they match the current system architecture.\n\n**This field is usually not what you're looking for**, unless you depend on the `fsevents` package. If you need a package to be required only when a specific feature is used then use an optional peer dependency. Your users will have to satisfy it should they use the feature, but it won't cause the build errors to be silently swallowed when the feature is needed.\n\n\"optionalDependencies\": {\n\n\"fsevents\": \"^5.0.0\",\n\n}\n\n## devDependencies\n\nSimilar to the `dependencies` field, except that these dependencies are only installed on local installs and will never be installed by the consumers of your package.\n\n\"devDependencies\": {\n\n\"webpack\": \"^5.0.0\",\n\n}\n\n## peerDependencies\n\nPeer dependencies are inherited dependencies - the consumer of your package will be tasked to provide them. This is typically what you want when writing plugins, for example. Note that peer dependencies can also be listed as regular dependencies; in this case, Yarn will use the package provided by the ancestors if possible, but will fallback to the regular dependencies otherwise.\n\n\"peerDependencies\": {\n\n\"react\": \"\\*\",\n\n\"react-dom\": \"\\*\",\n\n}\n\n## workspaces\n\nWorkspaces are an optional feature used by monorepos to split a large project into semi-independent subprojects, each one listing their own set of dependencies. The `workspaces` field is a list of glob patterns that match all directories that should become workspaces of your application.\n\n\"workspaces\": \\[\n\n\"packages/\\*\",\n\n\\]\n\n## dependenciesMeta\n\nThis field lists some extra information related to the dependencies listed in the `dependencies` and `devDependencies` fields. In the context of a workspaced project most of these settings will affect *all workspaces* and as such must be specified at the *root* of the project (except if noted otherwise, the `dependenciesMeta` field will be ignored if found within a workspace).\n\n\"dependenciesMeta\": {\n\n\"fsevents\": {\n\n### built\n\nIf false, the package will never be built (deny-list). This behavior is reversed when the `enableScripts` yarnrc setting is toggled off - when that happens, only packages with `built` explicitly set to `true` will be executed (allow-list), and those with `built` explicitly set to `false` will simply see their build script warnings downgraded into simple notices.\n\n\"built\": false,\n\n### optional\n\nIf true, the build isn't required to succeed for the install to be considered a success, and the dependency may be skipped if its `os` and `cpu` fields don't match the current system architecture. It's what the `optionalDependencies` field compiles down to.\n\n**This settings will be applied even when found within a nested manifest**, but the highest requirement in the dependency tree will prevail.\n\n\"optional\": false,\n\n### unplugged\n\nIf true, the specified package will be automatically unplugged at install time. This should only be needed for packages that contain scripts in other languages than Javascript (for example `nan` contains C++ headers).\n\n\"unplugged\": true,\n\n}\n\n}\n\n## peerDependenciesMeta\n\nThis field lists some extra information related to the dependencies listed in the `peerDependencies` field.\n\n\"peerDependenciesMeta\": {\n\n\"react-dom\": {\n\n### optional\n\nIf true, the selected peer dependency will be marked as optional by the package manager and the consumer omitting it won't be reported as an error.\n\n\"optional\": true,\n\n}\n\n}\n\n## resolutions\n\nThis field allows you to instruct Yarn to use a specific resolution instead of anything the resolver would normally pick. This is useful to enforce all your packages to use a single version of a dependency, or backport a fix. The syntax for the resolution key accepts one level of specificity, so all the following examples are correct. Note: When a path is relative, like it can be with the `file:` and `portal:` protocols, it is resolved relative to the path of the project.\n\nNote that the `resolution` field can only be set at the root of the project, and will generate a warning if used in any other workspace.\n\n\"resolutions\": {\n\n\"relay-compiler\": \"3.0.0\",\n\n\"webpack/memory-fs\": \"0.4.1\",\n\n\"@babel/core/json5\": \"2.1.0\",\n\n\"@babel/core/@babel/generator\": \"7.3.4\",\n\n\"@babel/core@npm:7.0.0/@babel/generator\": \"7.3.4\",\n\n}\n\n## preferUnplugged\n\nThis field instructs Yarn to either force-extract its content on the disk (useful when you need to ship executable binaries for a reason or another) or to force it to stay within its archive (useful when you want your package to contain *ALL* the sources, including shellscripts, but they aren't useful for runtime purposes).\n\n\"preferUnplugged\": false,\n\n## files\n\nThe optional `files` field is an array of file patterns that describes the entries to be included when your package is installed as a dependency. File patterns follow a similar syntax to `.gitignore`, but reversed: including a file, directory, or glob pattern (`*`, `**/*`, and such) will make it so that file is included in the tarball when it’s packed. Omitting the field will make it default to `[\"*\"]`, which means it will include all files.\n\nSome special files and directories are also [included](https://github.com/yarnpkg/berry/blob/ab2e84588b1eacb2ec60a751f12b168415224a19/packages/plugin-pack/sources/packUtils.ts#L11) or [excluded](https://github.com/yarnpkg/berry/blob/ab2e84588b1eacb2ec60a751f12b168415224a19/packages/plugin-pack/sources/packUtils.ts#L27) regardless of whether they exist in the `files` array.\n\nYou can also provide a `.npmignore` file in the root of your package or in subdirectories, which will keep files from being included. The `.npmignore` file works just like a `.gitignore`. If there is a `.gitignore` file, and `.npmignore` is missing, `.gitignore`’s contents will be used instead. The `files` field overrides `.npmignore` and `.gitignore`.\n\n\"files\": \\[\n\n\"dist/\\*\\*/\\*\",\n\n\"lib/\\*\\*/\\*\",\n\n\\]\n\n## publishConfig\n\nThis field contains various settings that are only taken into consideration when a package is generated from your local sources (either through `yarn pack` or one of the publish commands like `yarn npm publish`).\n\n\"publishConfig\": {\n\n### access\n\nDefines the package access level to use when publishing packages to the npm registry. Valid values are `public` and `restricted`, but `restricted` usually requires to register for a paid plan (this is up to the registry you use).\n\n\"access\": \"public\",\n\n### bin\n\nIf present, the top-level `bin` field from the manifest will be set to this new value before the package is packed to be shipped to remote registries. This won't modify the real manifest, just the one stored within the tarball.\n\n\"bin\": \"./build/bin.js\",\n\n### browser\n\nSame principle as the `publishConfig.bin` property; this value will be used instead of the top-level `browser` field when generating the workspace tarball.\n\n\"browser\": \"./build/browser.js\",\n\n### executableFiles\n\nBy default, for portability reasons, no files except those listed in the bin field will be marked as executable in the resulting package archive. The executableFiles field lets you declare additional fields that must have the executable flag (+x) set even if they aren't directly accessible through the bin field.\n\n\"executableFiles\": \\[\n\n\"./dist/shim.js\",\n\n\\]\n\n### main\n\nSame principle as the \\`publishConfig.bin\\` property; this value will be used instead of the top-level \\`main\\` field when generating the workspace tarball.\n\n\"main\": \"./build/index.js\",\n\n### module\n\nSame principle as the \\`publishConfig.bin\\` property; this value will be used instead of the top-level \\`module\\` field when generating the workspace tarball.\n\n\"module\": \"./build/index.mjs\",\n\n### registry\n\nIf present, will replace whatever registry is defined in the configuration when the package is about to be pushed to a remote location.\n\n\"registry\": \"https://npm.pkg.github.com\",\n\n}\n\n## installConfig\n\nThis field contains various settings that alter how the workspace is installed.\n\n\"installConfig\": {\n\n### hoistingLimits\n\nDefines the highest point where packages can be hoisted, overriding for the current workspace the value initially set for [`nmHoistingLimits`](yarnrc#nmHoistingLimits). Valid values are `workspaces`, `dependencies` and `none`\n\n\"hoistingLimits\": \"none\",\n\n### selfReferences\n\nDefines whether workspaces are allowed to require themselves - results in creation of self-referencing symlinks, overriding for the current workspace the value initially set for [`nmSelfReferences`](yarnrc#nmSelfReferences)\n\n\"selfReferences\": true,\n\n}\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/configuration/manifest](https://yarnpkg.com/configuration/manifest)"
- name: Offline Cache
  id: features/offline-cache
  summary: The offline cache is a feature that allows Yarn to work just fine even should the network go down for any reason - whether it's because your employer didn't pay the utility bill or because the place where your packages are hosted becomes unavailable
  description: "# Offline Cache\n\nThe offline cache is a feature that allows Yarn to work just fine even should the network go down for any reason - whether it's because your employer didn't pay the utility bill or because the place where your packages are hosted becomes unavailable. It's also a critical part of [Zero-Installs](zero-installs) and doesn't store more than a single file for each package - making it suitable for being stored within a repository, [as we actually do in the Yarn repository itself](https://github.com/yarnpkg/berry/tree/master/.yarn/cache).\n\nThe way it works is simple: each time a package is downloaded from a remote location (\"remote\" as a generic term in this context: dependencies listed through the `file:` protocol also have a remote, even if it will be the local filesystem in their case) a copy will be stored within the cache. The next time this same package will need to be installed, Yarn will leverage the version stored within cache instead of downloading its original source.\n\nThe location of the local cache, relative to the root of the project, can be configured with the [`cacheFolder`](../configuration/yarnrc#cacheFolder) configuration option. By default, it is `.yarn/cache`.\n\n- [Disabling the cache](#disabling-the-cache)\n- [Cleaning the cache](#cleaning-the-cache)\n- [Sharing the cache](#sharing-the-cache)\n- [Cache integrity](#cache-integrity)\n\n## Disabling the cache\n\nBecause the offline cache is leveraged to power PnP (files are read directly from within the zip archives), the cache cannot be disabled. That being said it's totally safe to remove the cache folder entirely if needed - it will simply be rebuilt the next time you run `yarn install`.\n\nThe local cache can be disabled by [sharing the cache](#sharing-the-cache), in which case the global cache will be used.\n\nThe global mirror can be disabled by using the [`enableMirror`](../configuration/yarnrc#enableMirror) configuration option. This is not recommended when using a local cache, as the global mirror is an abstraction between the local cache and the network, storing all downloaded packages for future use, to reduce install times.\n\n## Cleaning the cache\n\nYarn automatically purges your cache from unneeded packages when you remove or upgrade them. In case you need to manually clean the cache, you can use the [`yarn cache clean`](../cli/cache/clean) command.\n\nThe global mirror, however, has to be manually cleaned using the [`yarn cache clean --mirror`](../cli/cache/clean) command.\n\n## Sharing the cache\n\nStarting from Yarn v2, Yarn will by default configure the cache to be local to your project. This is done to make it easier for you to store it as part of your repository, which we believe is the best way to ensure that your projects can still be installed just fine regardless of the availability of your package registries.\n\nStill, this might not make sense in every case. For example, you might be working on a small library and not care enough to bother with checking-in your cache. If that's your case just add the following line into a `.yarnrc.yml` file local to your project. It will instruct Yarn to use a special path that will be shared by all projects that list the same configuration:\n\n``` language-yaml\nenableGlobalCache: true\n```\n\nThe location of the shared cache is always [`<globalFolder>`](../configuration/yarnrc#globalFolder)`/cache`, which corresponds to the location of the global mirror.\n\n## Cache integrity\n\nBecause the archive checksums are stored within the lockfile, any cache corruption will be detected at install-time and you'll be asked to resolve the problem - either by removing the corrupted file, or updating the checksum. The latter isn't meant to be done except for advanced users in extremely specific cases.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/offline-cache](https://yarnpkg.com/features/offline-cache)"
- name: Plug'n'Play
  id: features/pnp
  summary: Unveiled in September 2018, Plug'n'Play is an innovative installation strategy for Node
  description: "# Plug'n'Play\n\n> **PnP API**\n>\n> Are you a library author trying to make your library compatible with the Plug'n'Play installation strategy? Do you want to use the PnP API for something awesome? If the answer to any of these questions is yes, make sure to visit the [PnP API](../advanced/pnpapi) page after reading the introduction!\n\nUnveiled in September 2018, Plug'n'Play is an innovative installation strategy for [Node](https://nodejs.org/). Based on prior work in other languages (for example [autoload](https://getcomposer.org/doc/04-schema.md#autoload) for PHP), it presents interesting characteristics that build upon the regular [CommonJS](https://en.wikipedia.org/wiki/CommonJS) `require` workflow in an almost completely backward-compatible way.\n\n- [The node_modules problem](#the-node_modules-problem)\n\n- [Fixing node_modules](#fixing-node_modules)\n\n- [Initializing PnP](#initializing-pnp)\n\n- [PnP `loose` mode](#pnp-loose-mode)\n\n  - [Caveat](#caveat)\n\n- [Alternatives](#alternatives)\n\n  - [Compatibility Table](#compatibility-table)\n\n    - [Native support](#native-support)\n    - [Support via plugins](#support-via-plugins)\n    - [Incompatible](#incompatible)\n\n- [Frequently Asked Questions](#frequently-asked-questions)\n\n  - [Why not use import maps?](#why-not-use-import-maps)\n  - [Packages are stored inside Zip archives: How can I access their files?](#packages-are-stored-inside-zip-archives-how-can-i-access-their-files)\n  - [Fallback Mode](#fallback-mode)\n\n## The node_modules problem\n\nThe way installs used to work was simple: when running `yarn install` Yarn would generate a `node_modules` directory that Node was then able to consume thanks to its built-in [Node Resolution Algorithm](https://nodejs.org/api/modules.html#modules_all_together). In this context, Node didn't have to know the first thing about what a \"package\" was: it only reasoned in terms of files. \"Does this file exist here? No: Ok, let's look in the parent `node_modules` then. Does it exist here? Still no: Ok ...\", and it kept going until it found the right one. This process was vastly inefficient for several reasons:\n\n- The `node_modules` directories typically contained gargantuan amounts of files. Generating them could make up for more than 70% of the time needed to run `yarn install`. Even having preexisting installations wouldn't save you, as package managers still had to diff the contents of `node_modules` with what it *should* contain.\n\n- Because the `node_modules` generation was an I/O-heavy operation, package managers didn't have much leeway to optimize it beyond just doing a simple file copy - and even though it could have used hardlinks or copy-on-write when possible, it would still have needed to diff the current state of the filesystem before making a bunch of syscalls to manipulate the disk.\n\n- Because Node had no concept of packages, it also didn't know whether a file was *meant* to be accessed. It was entirely possible that the code you wrote worked one day in development but broke later in production because you forgot to list one of your dependencies in your `package.json`.\n\n- Even at runtime, the Node resolution had to make a bunch of `stat` and `readdir` calls to figure out where to load every single required file from. It was extremely wasteful and was part of why booting Node applications took so much time.\n\n- Finally, the very design of the `node_modules` folder was impractical in that it didn't allow package managers to properly de-duplicate packages. Even though some algorithms could be employed to optimize the tree layout ([hoisting](../advanced/lexicon#hoisting)), we still ended up unable to optimize some particular patterns - causing not only the disk usage to be higher than needed, but also some packages to be instantiated multiple times in memory.\n\n## Fixing node_modules\n\nYarn already knows everything there is to know about your dependency tree - it even installs it on the disk for you. So, why is it up to Node to find where your packages are? Instead, it should be the package manager's job to inform the interpreter about the location of the packages on the disk and manage any dependencies between packages and even versions of packages. This is why Plug'n'Play was created.\n\nIn this install mode (the default starting from Yarn 2.0), Yarn generates a single `.pnp.cjs` file instead of the usual `node_modules` folder containing copies of various packages. The `.pnp.cjs` file contains various maps: one linking package names and versions to their location on the disk and another one linking package names and versions to their list of dependencies. With these lookup tables, Yarn can instantly tell Node where to find any package it needs to access, as long as they are part of the dependency tree, and as long as this file is loaded within your environment (more on that in the next section).\n\nThis approach has various benefits:\n\n- Installs are now nearly instantaneous. Yarn only needs to generate a single text file (instead of potentially tens of thousands). The main bottleneck becomes the number of dependencies in a project rather than disk performance.\n\n- Installs are more stable and reliable due to reduced I/O operations. Especially on Windows (where writing and removing files in batches may trigger various unintended interactions with Windows Defender and similar tools), I/O heavy `node_modules` operations were more prone to failure.\n\n- Perfect optimization of the dependency tree (aka perfect hoisting) and predictable package instantiations.\n\n- The generated `.pnp.cjs` file can be committed to your repository as part of the [Zero-Installs](zero-installs) effort, removing the need to run `yarn install` in the first place.\n\n- Faster application startup! The Node resolution doesn't have to iterate over the filesystem hierarchy nearly as much as before (and soon won't have to do it at all!).\n\n## Initializing PnP\n\nYarn generates a single `.pnp.cjs` file that needs to be installed for Node to know where to find the relevant packages. This registration is generally transparent: any direct or indirect `node` command executed through one of your `scripts` entries will automatically register the `.pnp.cjs` file as a runtime dependency. For the vast majority of use cases, the following will work just as you would expect:\n\n``` language-json\n{\n  \"scripts\": {\n    \"start\": \"node ./server.js\",\n    \"test\": \"jest\"\n  }\n}\n```\n\nFor some remaining edge cases, a small setup may be required:\n\n- If you need to run an arbitrary Node script, use [`yarn node`](../cli/node) as the interpreter, instead of `node`. This will be enough to register the `.pnp.cjs` file as a runtime dependency.\n\n``` language-text\nyarn node ./server.js\n```\n\n- If you operate on a system that automatically executes a Node script (for instance on Google Cloud Platform (--reference needed here--)), simply require the PnP file at the top of your init script and call its `setup` function.\n\n``` language-text\nrequire('./.pnp.cjs').setup();\n```\n\nAs a quick tip, all `yarn node` typically does is set the `NODE_OPTIONS` environment variable to use the [`--require`](https://nodejs.org/api/cli.html#cli_r_require_module) option from Node, associated with the path of the `.pnp.cjs` file. You can easily apply this operation yourself if you prefer:\n\n``` language-text\nnode -r ./.pnp.cjs ./server.js\nNODE_OPTIONS=\"--require $(pwd)/.pnp.cjs\" node ./server.js\n```\n\n## PnP `loose` mode\n\nBecause the hoisting heuristics aren't standardized and predictable, PnP operating under strict mode will prevent packages from requiring dependencies that are not explicitly listed; even if other dependencies also depend on it. This may cause issues with some packages.\n\nTo address this problem, Yarn ships with a \"loose\" mode which will cause the PnP linker to work in tandem with the `node-modules` hoister - we will first generate the list of packages that would have been hoisted to the top level in a typical `node_modules` install, then remember this list as what we call the \"fallback pool\".\n\n> Note that because the loose mode directly calls the `node-modules` hoister, it follows the exact same implementation as the true algorithm used by the [`node-modules` linker](https://github.com/yarnpkg/berry/tree/master/packages/plugin-nm)!\n\nAt runtime, packages that require unlisted dependencies will still be allowed to access them if any version of the dependency ended up in the fallback pool (which packages exactly are allowed to rely on the fallback pool can be tweaked with [pnpFallbackMode](../configuration/yarnrc#pnpFallbackMode)).\n\nNote that the content of the fallback pool is undetermined. If a dependency tree contains multiple versions of the same package, there is no means to determine which one will be hoisted to the top-level. Therefore, a package accessing the fallback pool will still generate a warning (via the [process.emitWarning](https://nodejs.org/api/process.html#process_process_emitwarning_warning_type_code_ctor) API).\n\nThis mode provides a compromise between the `strict` PnP linker and the `node_modules` linker.\n\nIn order to enable `loose` mode, make sure that the [`nodeLinker`](../configuration/yarnrc#nodeLinker) option is set to `pnp` (the default) and add the following into your local [`.yarnrc.yml`](../configuration/yarnrc) file:\n\n``` language-yaml\npnpMode: loose\n```\n\n[More information about the `pnpMode` option.](../configuration/yarnrc#pnpMode)\n\n### Caveat\n\nBecause we *emit* warnings (instead of *throwing* errors) on resolution errors, applications can't *catch* them. This means that the common pattern of trying to `require` an optional peer dependency inside a try/catch block will print a warning at runtime if the dependency is missing, even though it shouldn't. The only runtime implication is that such a warning can cause confusion, but it can safely be ignored.\n\nFor this reason, PnP `loose` mode **won't be** the default starting with version 2.1 (as we originally planned). It will continue to be supported as an alternative, hopefully easing the transition to the default and recommended workflow: PnP `strict` mode.\n\n## Alternatives\n\nIn the years leading up to Plug'n'Play being ratified as the main install strategy, other projects came up with alternative implementations of the Node Resolution Algorithm - usually to circumvent shortcomings of the `require.resolve` API. Examples include Webpack (`enhanced-resolve`), Babel (`resolve`), Jest (`jest-resolve`), and Metro (`metro-resolver`). These alternatives should be considered as superseded by proper integration with Plug'n'Play.\n\n### Compatibility Table\n\nThe following compatibility table gives you an idea of the integration status with various tools from the community. Note that only CLI tools are listed there, as frontend libraries (such as `react`, `vue`, `lodash`, ...) don't reimplement the Node resolution and as such don't need any special logic to take advantage of Plug'n'Play:\n\n**[Suggest an addition to this table](https://github.com/yarnpkg/berry/edit/master/packages/gatsby/content/features/plugnplay.md)**\n\n#### Native support\n\nMany common frontend tools now support Plug'n'Play natively!\n\n[TABLE]\n\n#### Support via plugins\n\n[TABLE]\n\n#### Incompatible\n\nThe following tools cannot be used with pure Plug'n'Play install (even under loose mode).\n\n**Important:** Even if a tool is incompatible with Plug'n'Play, you can still enable the [`node-modules` plugin](https://github.com/yarnpkg/berry/tree/master/packages/plugin-nm). Just follow the [instructions](../getting-started/migration#if-required-enable-the-node-modules-plugin) and you'll be ready to go in a minute 🙂\n\n[TABLE]\n\nThis list is kept up-to-date based on the latest release we've published starting from v2. In case you notice something off in your own project please try to upgrade Yarn and the problematic package first, then feel free to file an issue. And maybe a PR? 😊\n\n## Frequently Asked Questions\n\n### Why not use import maps?\n\nYarn Plug'n'Play provides semantic errors (explaining you the exact reason why a package isn't reachable from another) and a [sensible JS API](../advanced/pnpapi) to solve various shortcomings with `require.resolve`. These are features that import maps wouldn't solve by themselves. This is answered in more detail in [this thread](https://github.com/nodejs/modules/issues/477#issuecomment-578091424).\n\nA main reason we're in this mess today is that the original `node_modules` design tried to abstract packages away in order to provide a generic system that would work without any notion of packages. This became a challenge that prompted many implementers to come up with their own interpretations. Import maps suffer from the same flaw.\n\n### Packages are stored inside Zip archives: How can I access their files?\n\nWhen using PnP, packages are stored and accessed directly inside the Zip archives from the cache. The PnP runtime (`.pnp.cjs`) automatically patches Node's `fs` module to add support for accessing files inside Zip archives. This way, you don't have to do anything special:\n\n``` language-js\nconst {readFileSync} = require(`fs`);\n\n// Looks similar to `/path/to/.yarn/cache/lodash-npm-4.17.11-1c592398b2-8b49646c65.zip/node_modules/lodash/ceil.js`\nconst lodashCeilPath = require.resolve(`lodash/ceil`);\n\nconsole.log(readFileSync(lodashCeilPath));\n```\n\n### Fallback Mode\n\nBack when PnP was first implemented, the compatibility wasn't as good as it is now. To help with the transition, we designed a fallback mechanism: if a package tries to access an unlisted dependency, it's still allowed to resolve it *if the top-level package lists it as a dependency*. We allow this because there's no resolution ambiguity, as there's a single top-level package in any project. Unfortunately, this may cause confusing behaviors depending on how your project is set up. When that happens, PnP is always right, and the only reason it works when not in a workspace is due to some extra lax.\n\nThis behavior was just a patch, and will eventually be removed to clear up any confusion. You can prepare for that now by setting [`pnpFallbackMode`](../configuration/yarnrc#pnpFallbackMode) to `none`, which will disable the fallback mechanism altogether.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/pnp](https://yarnpkg.com/features/pnp)"
- name: Plugin Tutorial
  id: advanced/plugin-tutorial
  summary: Starting from the Yarn 2, Yarn now supports plugins
  description: "# Plugin Tutorial\n\nStarting from the Yarn 2, Yarn now supports plugins. For more information about what they are and in which case you'd want to use them, consult the [dedicated page](../features/plugins). We'll talk here about the exact steps needed to write one. It's quite simple, really!\n\n- [What does a plugin look like?](#what-does-a-plugin-look-like)\n- [Writing our first plugin](#writing-our-first-plugin)\n- [All-in-one plugin builder](#all-in-one-plugin-builder)\n- [Adding commands](#adding-commands)\n- [Using hooks](#using-hooks)\n- [Using a the Yarn API](#using-a-the-yarn-api)\n- [Official hooks](#official-hooks)\n\n## What does a plugin look like?\n\nPlugins are scripts that get loaded at runtime by Yarn, and that can inject new behaviors into it. They also can require some packages provided by Yarn itself, such as `@yarnpkg/core`. This allows you to use the exact same core API as the Yarn binary currently in use, kinda like if it was a peer dependency!\n\n> **Important:** Since plugins are loaded before Yarn starts (and thus before you make your first install), it's strongly advised to write your plugins in such a way that they work without dependencies. If that becomes difficult, know that we provide a powerful tool ([`@yarnpkg/builder`](#all-in-one-plugin-builder) that can bundle your plugins into a single Javascript file, ready to be published.\n\n## Writing our first plugin\n\nOpen in a text editor a new file called `plugin-hello-world.js`, and type the following code:\n\n``` language-js\nmodule.exports = {\n  name: `plugin-hello-world`,\n  factory: require => ({\n    // What is this `require` function, you ask? It's a `require`\n    // implementation provided by Yarn core that allows you to\n    // access various packages (such as @yarnpkg/core) without\n    // having to list them in your own dependencies - hence\n    // lowering your plugin bundle size, and making sure that\n    // you'll use the exact same core modules as the rest of the\n    // application.\n    //\n    // Of course, the regular `require` implementation remains\n    // available, so feel free to use the `require` you need for\n    // your use case!\n  })\n};\n```\n\nWe have our plugin, but now we need to register it so that Yarn knows where to find it. To do this, we'll just add an entry within the `.yarnrc.yml` file at the root of the repository:\n\n``` language-yaml\nplugins:\n  - ./plugin-hello-world.js\n```\n\nThat's it! You have your first plugin, congratulations! Of course it doesn't do much (or anything at all, really), but we'll see how to extend it to make it more powerful.\n\n## All-in-one plugin builder\n\nAs we saw, plugins are meant to be standalone JavaScript source files. It's very possible to author them by hand, especially if you only need a small one, but once you start adding multiple commands it can become a bit more complicated. To make this process easier, we maintain a package called `@yarnpkg/builder`. This builder is to Yarn what Next.js is to web development - it's a tool designed to help creating, building, and managing complex plugins written in TypeScript.\n\nIts documentation can be found on the [dedicated page](https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-builder/README.md), but remember that you're not required to use it. Sometimes good old scripts are just fine!\n\n## Adding commands\n\nPlugins can also register their own commands. To do this, we just have to write them using the [`clipanion`](https://github.com/arcanis/clipanion) library - and we don't even have to add it to our dependencies! Let's see an example:\n\n``` language-js\nmodule.exports = {\n  name: `plugin-hello-world`,\n  factory: require => {\n    const {BaseCommand} = require(`@yarnpkg/cli`);\n\n    class HelloWorldCommand extends BaseCommand {\n      static paths = [[`hello`]];\n\n      async execute() {\n        this.context.stdout.write(`This is my very own plugin 😎\\n`);\n      }\n    }\n\n    return {\n      commands: [\n        HelloWorldCommand,\n      ],\n    };\n  }\n};\n```\n\nNow, try to run `yarn hello`. You'll see your message appear! Note that you can use the full set of features provided by clipanion, including short options, long options, variadic argument lists, ... You can even validate your options using the [`typanion`](https://github.com/arcanis/typanion) library, which we provide. Here's an example where we only accept numbers as parameter:\n\n``` language-js\nmodule.exports = {\n  name: `plugin-addition`,\n  factory: require => {\n    const {BaseCommand} = require(`@yarnpkg/cli`);\n    const {Option} = require(`clipanion`);\n    const t = require(`typanion`);\n\n    class AdditionCommand extends BaseCommand {\n      static paths = [[`addition`]];\n\n      // Show descriptive usage for a --help argument passed to this command\n      static usage = Command.Usage({\n        description: `hello world!`,\n        details: `\n          This command will print a nice message.\n        `,\n        examples: [[\n          `Add two numbers together`,\n          `yarn addition 42 10`,\n        ]],\n      });\n\n      a = Option.String({validator: t.isNumber()});\n      b = Option.String({validator: t.isNumber()});\n\n      async execute() {\n        this.context.stdout.write(`${this.a}+${this.b}=${this.a + this.b}\\n`);\n      }\n    }\n\n    return {\n      commands: [\n        AdditionCommand,\n      ],\n    };\n  },\n};\n```\n\n## Using hooks\n\nPlugins can register to various events in the Yarn lifetime, and provide them additional information to alter their behavior. To do this, you just need to declare a new `hooks` property in your plugin and add members for each hook you want to listen to:\n\n``` language-js\nmodule.exports = {\n  name: `plugin-hello-world`,\n  factory: require => ({\n    hooks: {\n      setupScriptEnvironment(project, scriptEnv) {\n        scriptEnv.HELLO_WORLD = `my first plugin!`;\n      },\n    },\n  })\n};\n```\n\nIn this example, we registered to the `setupScriptEnvironment` hook and used it to inject an argument into the environment. Now, each time you'll run a script, you'll see that your env will contain a new value called `HELLO_WORLD`!\n\nHooks are numerous, and we're still working on them. Some might be added, removed, or changed, based on your feedback. So if you'd like to do something hooks don't allow you to do yet, come tell us!\n\n> **Note:** We don't yet have a list of hooks. If you're interested to improve this documentation by generating the hook list from our source code, please contact us on our Discord server!\n\n## Using a the Yarn API\n\nMost Yarn's hooks are called with various arguments that tell you more about the context under which the hook is being called. The exact argument list is different for each hook, but in general they are of the types defined in the [`@yarnpkg/core` library](https://yarnpkg.com/api).\n\nIn this example, we will integrate with the `afterAllInstalled` hook in order to print some basic information about the dependency tree after each install. This hook gets invoked with an additional parameter that is the public [`Project`](https://yarnpkg.com/api/classes/yarnpkg_core.project.html) instance where lie most of the information Yarn has collected about the project: dependencies, package manifests, workspace information, and so on.\n\n``` language-js\nconst fs = require(`fs`);\nconst util = require(`util`);\n\nmodule.exports = {\n  name: `plugin-project-info`,\n  factory: require => {\n    const {structUtils} = require(`@yarnpkg/core`);\n\n    return {\n      default: {\n        hooks: {\n          afterAllInstalled(project) {\n            let descriptorCount = 0;\n            for (const descriptor of project.storedDescriptors.values())\n              if (!structUtils.isVirtualDescriptor(descriptor))\n                descriptorCount += 1;\n\n            let packageCount = 0;\n            for (const pkg of project.storedPackages.values())\n              if (!structUtils.isVirtualLocator(pkg))\n                packageCount += 1;\n\n            console.log(`This project contains ${descriptorCount} different descriptors that resolve to ${packageCount} packages`);\n          }\n        }\n      }\n    };\n  }\n};\n```\n\nThis is getting interesting. As you can see, we accessed the [`storedDescriptors`](https://yarnpkg.com/api/classes/yarnpkg_core.project.html#storeddescriptors) and [`storedPackages`](https://yarnpkg.com/api/classes/yarnpkg_core.project.html#storedpackages) fields from our project instance, and iterated over them to obtain the number of non-virtual items (virtual packages are described in more details [here](lexicon#virtual-package)). This is a very simple use case, but we could have done many more things: the project root is located in the [`cwd`](https://yarnpkg.com/api/classes/yarnpkg_core.project.html#cwd) property, the workspaces are exposed as [`workspaces`](https://yarnpkg.com/api/classes/yarnpkg_core.project.html#workspaces), the link between descriptors and packages can be made via [`storedResolutions`](https://yarnpkg.com/api/classes/yarnpkg_core.project.html#storedresolutions), ... etc.\n\nNote that we've only scratched the surface of the `Project` class instance! The Yarn core provides many other classes (and hooks) that allow you to work with the cache, download packages, trigger http requests, ... and much more, as listed in the [API documentation](https://yarnpkg.com/api/). Next time you want to write a plugin, give it a look, there's almost certainly an utility there that will allow you to avoid having to reimplement the wheel.\n\n## Official hooks\n\n### `afterAllInstalled`\n\nCalled after the `install` method from the `Project` class successfully completed.\n\n    afterAllInstalled?: (\n      project: Project,\n      options: InstallOptions\n    ) => void;\n\n### `afterWorkspaceDependencyAddition`\n\nCalled when a new dependency is added to a workspace. Note that this hook is only called by the CLI commands like `yarn add` - manually adding the dependencies into the manifest and running `yarn install` won't trigger it.\n\n    afterWorkspaceDependencyAddition?: (\n      workspace: Workspace,\n      target: suggestUtils.Target,\n      descriptor: Descriptor,\n      strategies: Array<suggestUtils.Strategy>\n    ) => Promise<void>;\n\n### `afterWorkspaceDependencyRemoval`\n\nCalled when a dependency range is removed from a workspace. Note that this hook is only called by the CLI commands like `yarn remove` - manually removing the dependencies from the manifest and running `yarn install` won't trigger it.\n\n    afterWorkspaceDependencyRemoval?: (\n      workspace: Workspace,\n      target: suggestUtils.Target,\n      descriptor: Descriptor,\n    ) => Promise<void>;\n\n### `afterWorkspaceDependencyReplacement`\n\nCalled when a dependency range is replaced inside a workspace. Note that this hook is only called by the CLI commands like `yarn add` - manually updating the dependencies from the manifest and running `yarn install` won't trigger it.\n\n    afterWorkspaceDependencyReplacement?: (\n      workspace: Workspace,\n      target: suggestUtils.Target,\n      fromDescriptor: Descriptor,\n      toDescriptor: Descriptor,\n    ) => Promise<void>;\n\n### `beforeWorkspacePacking`\n\nCalled before a workspace is packed. The `rawManifest` value passed in parameter is allowed to be mutated at will, with the changes being only applied to the packed manifest (the original one won't be mutated).\n\n    beforeWorkspacePacking?: (\n      workspace: Workspace,\n      rawManifest: object,\n    ) => Promise<void> | void;\n\n### `cleanGlobalArtifacts`\n\nCalled when the user requests to clean the global cache. Plugins should use this hook to remove their own global artifacts.\n\n    cleanGlobalArtifacts?: (\n      configuration: Configuration,\n    ) => Promise<void>;\n\n### `fetchHostedRepository`\n\nCalled when a Git repository is fetched. If the function returns `null` the repository will be cloned and packed; otherwise, it must returns a value compatible with what a fetcher would return.\n\nThe main use case for this hook is to let you implement smarter cloning strategies depending on the hosting platform. For instance, GitHub supports downloading repository tarballs, which are more efficient than cloning the repository (even without its history).\n\n    fetchHostedRepository?: (\n      current: FetchResult | null,\n      locator: Locator,\n      opts: FetchOptions,\n    ) => Promise<FetchResult | null>;\n\n### `fetchPackageInfo`\n\nCalled by `yarn info`. The `extra` field is the set of parameters passed to the `-X,--extra` flag. Calling `registerData` will add a new set of data that will be added to the package information.\n\nFor instance, an \"audit\" plugin could check in `extra` whether the user requested audit information (via `-X audit`), and call `registerData` with those information (retrieved dynamically) if they did.\n\n    fetchPackageInfo?: (\n      pkg: Package,\n      extra: Set<string>,\n      registerData: (namespace: string, data: Array<formatUtils.Tuple> | {[key: string]: formatUtils.Tuple | undefined}) => void,\n    ) => Promise<void>;\n\n### `getBuiltinPatch`\n\nRegisters a builtin patch that can be referenced using the dedicated syntax: `patch:builtin<name>`. This is for instance how the TypeScript patch is automatically registered.\n\n    getBuiltinPatch?: (\n      project: Project,\n      name: string,\n    ) => Promise<string | null | void>;\n\n### `globalHashGeneration`\n\nCalled before the build, to compute a global hash key that we will use to detect whether packages must be rebuilt (typically when the Node version changes).\n\n    globalHashGeneration?: (\n      project: Project,\n      contributeHash: (data: string | Buffer) => void,\n    ) => Promise<void>;\n\n### `populateYarnPaths`\n\nUsed to notify the core of all the potential artifacts of the available linkers.\n\n    populateYarnPaths?: (\n      project: Project,\n      definePath: (path: PortablePath | null) => void,\n    ) => Promise<void>;\n\n### `reduceDependency`\n\nCalled during the resolution, once for each resolved package and each of their dependencies. By returning a new dependency descriptor you can replace the original one by a different range.\n\nNote that when multiple plugins are registered on `reduceDependency` they will be executed in definition order. In that case, `dependency` will always refer to the dependency as it currently is, whereas `initialDependency` will be the descriptor before any plugin attempted to change it.\n\n    reduceDependency?: (\n      dependency: Descriptor,\n      project: Project,\n      locator: Locator,\n      initialDependency: Descriptor,\n      extra: {resolver: Resolver, resolveOptions: ResolveOptions},\n    ) => Promise<Descriptor>;\n\n### `registerPackageExtensions`\n\nCalled when the package extensions are setup. Can be used to inject new ones. That's for example what the compat plugin uses to automatically fix packages with known flaws.\n\n    registerPackageExtensions?: (\n      configuration: Configuration,\n      registerPackageExtension: (descriptor: Descriptor, extensionData: PackageExtensionData) => void,\n    ) => Promise<void>;\n\n### `setupScriptEnvironment`\n\nCalled before a script is executed. The hooks are allowed to modify the `env` object as they see fit, and any call to `makePathWrapper` will cause a binary of the given name to be injected somewhere within the PATH (we recommend you don't alter the PATH yourself unless required).\n\nThe keys you get in the env are guaranteed to be uppercase. We strongly suggest you adopt this convention for any new key added to the env (we might enforce it later on).\n\n    setupScriptEnvironment?: (\n      project: Project,\n      env: ProcessEnvironment,\n      makePathWrapper: (name: string, argv0: string, args: Array<string>) => Promise<void>,\n    ) => Promise<void>;\n\n### `validateProject`\n\nCalled during the `Validation step` of the `install` method from the `Project` class.\n\n    validateProject?: (\n      project: Project,\n      report: {\n        reportWarning: (name: MessageName, text: string) => void;\n        reportError: (name: MessageName, text: string) => void;\n      }\n    ) => void;\n\n### `validateWorkspace`\n\nCalled during the `Validation step` of the `install` method from the `Project` class by the `validateProject` hook.\n\n    validateWorkspace?: (\n      workspace: Workspace,\n      report: {\n        reportWarning: (name: MessageName, text: string) => void;\n        reportError: (name: MessageName, text: string) => void;\n      }\n    ) => void;\n\n### `wrapNetworkRequest`\n\nCalled when a network request is being made. The `executor` function parameter, when called, will trigger the network request. You can use this mechanism to wrap network requests, for example to run some validation or add some logging.\n\n    wrapNetworkRequest?: (\n      executor: () => Promise<any>,\n      extra: WrapNetworkRequestInfo\n    ) => Promise<() => Promise<any>>;\n\n### `wrapScriptExecution`\n\nCalled as a script is getting executed. The `executor` function parameter, when called, will execute the script. You can use this mechanism to wrap script executions, for example to run some validation or add some performance monitoring.\n\n    wrapScriptExecution?: (\n      executor: () => Promise<number>,\n      project: Project,\n      locator: Locator,\n      scriptName: string,\n      extra: {script: string, args: Array<string>, cwd: PortablePath, env: ProcessEnvironment, stdin: Readable | null, stdout: Writable, stderr: Writable},\n    ) => Promise<() => Promise<number>>;\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/plugin-tutorial](https://yarnpkg.com/advanced/plugin-tutorial)"
- name: Plugins
  id: features/plugins
  summary: Ever since Yarn was created, our very essence has been about experimenting, evolving, pushing the status quo - rinse and repeat, each time one step further, each time paving the way for our next move
  description: "# Plugins\n\nEver since Yarn was created, our very essence has been about experimenting, evolving, pushing the status quo - rinse and repeat, each time one step further, each time paving the way for our next move.\n\nAs you can guess, this philosophy (coupled with the high number of external contributions we receive) requires us to iterate fast in order to accommodate the various experiments that we brew. In a major step forward, Yarn got redesigned in the v2 in order to leverage a new modular API that can be extended through plugins. Nowadays, most of our features are implemented through those plugins - even `yarn add` and `yarn install` are preinstalled plugins!\n\n- [What can plugins do?](#what-can-plugins-do)\n- [How to write plugins?](#how-to-write-plugins)\n- [Official plugins](#official-plugins)\n- [Contrib plugins](#contrib-plugins)\n\n## What can plugins do?\n\n- **Plugins can add new resolvers.** Resolvers are the components tasked from converting dependency ranges (for example `^1.2.0`) into fully-qualified package references (for example `npm:1.2.0`). By implementing a resolver, you can tell Yarn which versions are valid candidates to a specific range.\n\n- **Plugins can add new fetchers.** Fetchers are the components that take the fully-qualified package references we mentioned in the previous step (for example `npm:1.2.0`) and know how to obtain the data of the package they belong to. Fetchers can work with remote packages (for example the npm registry), but can also find the packages directly from their location on the disk (or any other data source).\n\n- **Plugins can add new linkers.** Once all the packages have been located and are ready for installation, Yarn will call the linkers to generate the files needed for the install targets to work properly. As an example, the PnP linker would generate the `.pnp.cjs` manifest, and a Python linker would instead generate the virtualenv files needed.\n\n- **Plugins can add new commands.** Each plugin can ship as many commands as they see fit, which will be injected into our CLI (also making them available through `yarn --help`). Because the Yarn plugins are dynamically linked with the running Yarn process, they can be very small and guaranteed to share the exact same behavior as your package manager (which wouldn't be the case if you were to reimplement the workspace detection, for example).\n\n- **Plugins can register to some events.** Yarn has a concept known as \"hooks\", where events are periodically triggered during the lifecycle of the package manager. Plugins can register to those hooks in order to add their own logic depending on what the core allows. For example, the `afterAllInstalled` hook will be called each time the `Project#install` method ends - typically after each `yarn install`.\n\n- **Plugins can be integrated with each other.** Each plugin has the ability to trigger special actions called hooks, and to register themselves to any defined hook. So for example, you could make a plugin that would execute an action each time a package is added as dependency of one of your workspaces!\n\n## How to write plugins?\n\nWe have a tutorial for this! Head over to [Plugin Tutorial](../advanced/plugin-tutorial).\n\n## Official plugins\n\n``` language-text\nyarn plugin import <name>\n```\n\n- [**constraints**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-constraints) - Adds new commands to Yarn to enforce lint rules across workspaces. See the [dedicated page](constraints) for more information.\n\n- [**exec**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-exec) - Adds a new protocol to Yarn (`exec:`) that dynamically generates arbitrary packages rather than downloading them from a known location. See the [plugin page](https://github.com/yarnpkg/berry/tree/master/packages/plugin-exec) for more information.\n\n- [**interactive-tools**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-interactive-tools) - Adds various commands providing a more high-level control on your project using graphical terminal interfaces (for example [`yarn upgrade-interactive`](../cli/upgrade-interactive)).\n\n- [**stage**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-stage) - Adds a new command to Yarn (`yarn stage`) to automatically stage & commit all changes to Yarn-related files in a single line.\n\n- [**typescript**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-typescript) - Improves the TypeScript experience (for example by automatically adding `@types` packages as dependencies when needed). See the [plugin page](https://github.com/yarnpkg/berry/tree/master/packages/plugin-typescript) for more information.\n\n- [**version**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-version) - Adds a new workflow to Yarn (`yarn version`) to efficiently manage releases in a monorepository. See the [dedicated page](release-workflow) for more information.\n\n- [**workspace-tools**](https://github.com/yarnpkg/berry/tree/master/packages/plugin-workspace-tools) - Adds various commands that make working with workspaces a more pleasing experience (for example [`yarn workspaces foreach`](../cli/workspaces/foreach)).\n\n## Contrib plugins\n\n``` language-text\nyarn plugin import <bundle url>\n```\n\nThis is just a centralized list of third-party plugins to make discovery easier. No guarantees are made as to plugin quality, compatibility, or lack of malicious code. As with all third-party dependencies, you should review them yourself before including them in your project.\n\n- [**plugin-installs**](https://gitlab.com/Larry1123/yarn-contrib/-/blob/master/packages/plugin-production-install/README.md) by [**Larry1123**](https://gitlab.com/Larry1123) - create minimal yarn installs after removing development dependencies, unrelated workspaces, `@types` packages, etc\n\n- [**yarn.build**](https://yarn.build/) by [**Owen Kelly**](https://github.com/ojkelly/yarn.build) - run builds and tests in parallel according to your workspace dependencies if they have changed, and bundle them up into deployable apps for Docker, AWS Lambda, or any other server.\n\n- [**licenses**](https://github.com/tophat/yarn-plugin-licenses) by [**Noah Negin-Ulster**](https://noahnu.com/) - audit direct and indirect dependency licenses to ensure compliance\n\n- [**semver-up**](https://github.com/tophat/yarn-plugin-semver-up) by [**Noah Negin-Ulster**](https://noahnu.com/) - configurable `yarn up` command that preserves semantic version ranges and update groups\n\n- [**conditions**](https://github.com/nicolo-ribaudo/yarn-plugin-conditions) by [**Nicolò Ribaudo**](https://twitter.com/NicoloRibaudo) - allow choosing between different dependency versions via install-time (during development) and publish-time flags\n\n- [**az-cli-auth**](https://github.com/FishandRichardsonPC/yarn-plugin-az-cli-auth) by [**Fish & Richardson P.C**](https://fr.com) - Uses the az cli to generate auth tokens when using azure devops repos\n\n- [**outdated**](https://github.com/mskelton/yarn-plugin-outdated) by [**Mark Skelton**](https://github.com/mskelton) - lists outdated dependencies similar to the Yarn 1.x `outdated` command\n\n- [**engines**](https://github.com/devoto13/yarn-plugin-engines) by [**Yaroslav Admin**](https://github.com/devoto13) - enforces a Node version range specified in the `package.json`'s `engines.node` field\n\nIf you wrote a plugin yourself, feel free to [open a PR](https://github.com/yarnpkg/berry/edit/master/packages/gatsby/content/features/plugins.md) to add it at the end of this list!\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/plugins](https://yarnpkg.com/features/plugins)"
- name: PnP API
  id: advanced/pnpapi
  summary: On top of being a simple install strategy, Plug'n'Play also provides a API that allows you to introspect the dependency tree at runtime
  description: "# PnP API\n\n- [Overview](#overview)\n\n- [Data Structures](#data-structures)\n\n  - [`PackageLocator`](#packagelocator)\n  - [`PackageInformation`](#packageinformation)\n\n- [Runtime Constants](#runtime-constants)\n\n  - [`process.versions.pnp`](#processversionspnp)\n  - [`require('module')`](#requiremodule)\n  - [`require('pnpapi')`](#requirepnpapi)\n\n- [API Interface](#api-interface)\n\n  - [`VERSIONS`](#versions)\n  - [`topLevel`](#toplevel)\n  - [`getLocator(...)`](#getlocator)\n  - [`getDependencyTreeRoots(...)`](#getdependencytreeroots)\n  - [`getAllLocators(...)`](#getalllocators)\n  - [`getPackageInformation(...)`](#getpackageinformation)\n  - [`findPackageLocator(...)`](#findpackagelocator)\n  - [`resolveToUnqualified(...)`](#resolvetounqualified)\n  - [`resolveUnqualified(...)`](#resolveunqualified)\n  - [`resolveRequest(...)`](#resolverequest)\n  - [`resolveVirtual(...)`](#resolvevirtual)\n\n- [Qualified vs Unqualified Resolutions](#qualified-vs-unqualified-resolutions)\n\n- [Accessing the files](#accessing-the-files)\n\n- [Traversing the dependency tree](#traversing-the-dependency-tree)\n\n## Overview\n\nOn top of being a simple install strategy, Plug'n'Play also provides a API that allows you to introspect the dependency tree at runtime.\n\n## Data Structures\n\n### `PackageLocator`\n\n``` language-ts\nexport type PackageLocator = {\n  name: string,\n  reference: string,\n};\n```\n\nA package locator is an object describing one unique instance of a package in the dependency tree. The `name` field is guaranteed to be the name of the package itself, but the `reference` field should be considered an opaque string whose value may be whatever the PnP implementation decides to put there.\n\nNote that one package locator is different from the others: the top-level locator (available through `pnp.topLevel`, cf below) sets *both* `name` and `reference` to `null`. This special locator will always mirror the top-level package (which is generally the root of the repository, even when working with workspaces).\n\n### `PackageInformation`\n\n``` language-ts\nexport type PackageInformation = {\n  packageLocation: string,\n  packageDependencies: Map<string, null | string | [string, string]>,\n  packagePeers: Set<string>,\n  linkType: 'HARD' | 'SOFT',\n};\n```\n\nThe package information set describes the location where the package can be found on the disk, and the exact set of dependencies it is allowed to require. The `packageDependencies` values are meant to be interpreted as such:\n\n- If a string, the value is meant to be used as a reference in a locator whose name is the dependency name.\n\n- If a `[string, string]` tuple, the value is meant to be used as a locator whose name is the first element of the tuple and reference is the second one. This typically occurs with package aliases (such as `\"foo\": \"npm:bar@1.2.3\"`).\n\n- If `null`, the specified dependency isn't available at all. This typically occurs when a package's peer dependency didn't get provided by its direct parent in the dependency tree.\n\nThe `packagePeers` field, if present, indicates which dependencies have an enforced contract on using the exact same instance as the package that depends on them. This field is rarely useful in pure PnP context (because our instantiation guarantees are stricter and more predictable than this), but is required to properly generate a `node_modules` directory from a PnP map.\n\nThe `linkType` field is only useful in specific cases - it describes whether the producer of the PnP API was asked to make the package available through a hard linkage (in which case all the `packageLocation` field is reputed being owned by the linker) or a soft linkage (in which case the `packageLocation` field represents a location outside of the sphere of influence of the linker).\n\n## Runtime Constants\n\n### `process.versions.pnp`\n\nWhen operating under PnP environments, this value will be set to a number indicating the version of the PnP standard in use (which is strictly identical to `require('pnpapi').VERSIONS.std`).\n\nThis value is a convenient way to check whether you're operating under a Plug'n'Play environment (where you can `require('pnpapi')`) or not:\n\n``` language-js\nif (process.versions.pnp) {\n  // do something with the PnP API ...\n} else {\n  // fallback\n}\n```\n\n### `require('module')`\n\nThe `module` builtin module is extended when operating within the PnP API with one extra function:\n\n``` language-ts\nexport function findPnpApi(lookupSource: URL | string): PnpApi | null;\n```\n\nWhen called, this function will traverse the filesystem hierarchy starting from the given `lookupSource` in order to locate the closest `.pnp.cjs` file. It'll then load this file, register it inside the PnP loader internal store, and return the resulting API to you.\n\nNote that while you'll be able to resolve the dependencies by using the API returned to you, you'll need to make sure they are properly *loaded* on behalf of the project too, by using `createRequire`:\n\n``` language-ts\nconst {createRequire, findPnpApi} = require(`module`);\n\n// We'll be able to inspect the dependencies of the module passed as first argument\nconst targetModule = process.argv[2];\n\nconst targetPnp = findPnpApi(targetModule);\nconst targetRequire = createRequire(targetModule);\n\nconst resolved = targetPnp.resolveRequest(`eslint`, targetModule);\nconst instance = targetRequire(resolved); // <-- important! don't use `require`!\n```\n\nFinally, it can be noted that `findPnpApi` isn't actually needed in most cases and we can do the same with just `createRequire` thanks to its `resolve` function:\n\n``` language-ts\nconst {createRequire} = require(`module`);\n\n// We'll be able to inspect the dependencies of the module passed as first argument\nconst targetModule = process.argv[2];\n\nconst targetRequire = createRequire(targetModule);\n\nconst resolved = targetRequire.resolve(`eslint`);\nconst instance = targetRequire(resolved); // <-- still important\n```\n\n### `require('pnpapi')`\n\nWhen operating under a Plug'n'Play environment, a new builtin module will appear in your tree and will be made available to all your packages (regardless of whether they define it in their dependencies or not): `pnpapi`. It exposes the constants a function described in the rest of this document.\n\nNote that we've reserved the `pnpapi` package name on the npm registry, so there's no risk that anyone will be able to snatch the name for nefarious purposes. We might use it later to provide a polyfill for non-PnP environments (so that you'd be able to use the PnP API regardless of whether the project got installed via PnP or not), but as of now it's still an empty package.\n\nNote that the `pnpapi` builtin is *contextual*: while two packages from the same dependency tree are guaranteed to read the same one, two packages from different dependency trees will get different instances - each reflecting the dependency tree they belong to. This distinction doesn't often matter except sometimes for project generator (which typically run within their own dependency tree while also manipulating the project they're generating).\n\n## API Interface\n\n### `VERSIONS`\n\n``` language-ts\nexport const VERSIONS: {std: number, [key: string]: number};\n```\n\nThe `VERSIONS` object contains a set of numbers that detail which version of the API is currently exposed. The only version that is guaranteed to be there is `std`, which will refer to the version of this document. Other keys are meant to be used to describe extensions provided by third-party implementors. Versions will only be bumped when the signatures of the public API change.\n\n**Note:** The current version is 3. We bump it responsibly and strive to make each version backward-compatible with the previous ones, but as you can probably guess some features are only available with the latest versions.\n\n### `topLevel`\n\n``` language-ts\nexport const topLevel: {name: null, reference: null};\n```\n\nThe `topLevel` object is a simple package locator pointing to the top-level package of the dependency tree. Note that even when using workspaces you'll still only have one single top-level for the entire project.\n\nThis object is provided for convenience and doesn't necessarily needs to be used; you may create your own top-level locator by using your own locator literal with both fields set to `null`.\n\n**Note:** These special top-level locators are merely aliases to physical locators, which can be accessed by calling `findPackageLocator`.\n\n### `getLocator(...)`\n\n``` language-ts\nexport function getLocator(name: string, referencish: string | [string, string]): PackageLocator;\n```\n\nThis function is a small helper that makes it easier to work with \"referencish\" ranges. As you may have seen in the `PackageInformation` interface, the `packageDependencies` map values may be either a string or a tuple - and the way to compute the resolved locator changes depending on that. To avoid having to manually make a `Array.isArray` check, we provide the `getLocator` function that does it for you.\n\nJust like for `topLevel`, you're under no obligation to actually use it - you're free to roll your own version if for some reason our implementation wasn't what you're looking for.\n\n### `getDependencyTreeRoots(...)`\n\n``` language-ts\nexport function getDependencyTreeRoots(): PackageLocator[];\n```\n\nThe `getDependencyTreeRoots` function will return the set of locators that constitute the roots of individual dependency trees. In Yarn, there is exactly one such locator for each workspace in the project.\n\n**Note:** This function will always return the physical locators, so it'll never return the special top-level locator described in the `topLevel` section.\n\n### `getAllLocators(...)`\n\n``` language-ts\nexport function getAllLocators(): PackageLocator[];\n```\n\n**Important:** This function is not part of the Plug'n'Play specification and only available as a Yarn extension. In order to use it, you first must check that the [`VERSIONS`](pnpapi#versions) dictionary contains a valid `getAllLocators` property.\n\nThe `getAllLocators` function will return all locators from the dependency tree, in no particular order (although it'll always be a consistent order between calls for the same API). It can be used when you wish to know more about the packages themselves, but not about the exact tree layout.\n\n### `getPackageInformation(...)`\n\n``` language-ts\nexport function getPackageInformation(locator: PackageLocator): PackageInformation;\n```\n\nThe `getPackageInformation` function returns all the information stored inside the PnP API for a given package.\n\n### `findPackageLocator(...)`\n\n``` language-ts\nexport function findPackageLocator(location: string): PackageLocator | null;\n```\n\nGiven a location on the disk, the `findPackageLocator` function will return the package locator for the package that \"owns\" the path. For example, running this function on something conceptually similar to `/path/to/node_modules/foo/index.js` would return a package locator pointing to the `foo` package (and its exact version).\n\n**Note:** This function will always return the physical locators, so it'll never return the special top-level locator described in the `topLevel` section. You can leverage this property to extract the physical locator for the top-level package:\n\n``` language-ts\nconst virtualLocator = pnpApi.topLevel;\nconst physicalLocator = pnpApi.findPackageLocator(pnpApi.getPackageInformation(virtualLocator).packageLocation);\n```\n\n### `resolveToUnqualified(...)`\n\n``` language-ts\nexport function resolveToUnqualified(request: string, issuer: string | null, opts?: {considerBuiltins?: boolean}): string | null;\n```\n\nThe `resolveToUnqualified` function is maybe the most important function exposed by the PnP API. Given a request (which may be a bare specifier like `lodash`, or an relative/absolute path like `./foo.js`) and the path of the file that issued the request, the PnP API will return an unqualified resolution.\n\nFor example, the following:\n\n``` language-text\nlodash/uniq\n```\n\nMight very well be resolved into:\n\n``` language-text\n/my/cache/lodash/1.0.0/node_modules/lodash/uniq\n```\n\nAs you can see, the `.js` extension didn't get added. This is due to the difference between [qualified and unqualified resolutions](#qualified-vs-unqualified-resolutions). In case you must obtain a path ready to be used with the filesystem API, prefer using `resolveRequest` instead.\n\nNote that in some cases you may just have a folder to work with as `issuer` parameter. When this happens, just suffix the issuer with an extra slash (`/`) to indicate to the PnP API that the issuer is a folder.\n\nThis function will return `null` if the request is a builtin module, unless `considerBuiltins` is set to `false`.\n\n### `resolveUnqualified(...)`\n\n``` language-ts\nexport function resolveUnqualified(unqualified: string, opts?: {extensions?: string[]}): string;\n```\n\nThe `resolveUnqualified` function is mostly provided as an helper; it reimplements the Node resolution for file extensions and folder indexes, but not the regular `node_modules` traversal. It makes it slightly easier to integrate PnP into some projects, although it isn't required in any way if you already have something that fits the bill.\n\nTo give you an example `resolveUnqualified` isn't needed with `enhanced-resolved`, used by Webpack, because it already implements its own way the logic contained in `resolveUnqualified` (and more). Instead, we only have to leverage the lower-level `resolveToUnqualified` function and feed it to the regular resolver.\n\nFor example, the following:\n\n``` language-text\n/my/cache/lodash/1.0.0/node_modules/lodash/uniq\n```\n\nMight very well be resolved into:\n\n``` language-text\n/my/cache/lodash/1.0.0/node_modules/lodash/uniq/index.js\n```\n\n### `resolveRequest(...)`\n\n``` language-ts\nexport function resolveRequest(request: string, issuer: string | null, opts?: {considerBuiltins?: boolean, extensions?: string[]]}): string | null;\n```\n\nThe `resolveRequest` function is a wrapper around both `resolveToUnqualified` and `resolveUnqualified`. In essence, it's a bit like calling `resolveUnqualified(resolveToUnqualified(...))`, but shorter.\n\nJust like `resolveUnqualified`, `resolveRequest` is entirely optional and you might want to skip it to directly use the lower-level `resolveToUnqualified` if you already have a resolution pipeline that just needs to add support for Plug'n'Play.\n\nFor example, the following:\n\n``` language-text\nlodash\n```\n\nMight very well be resolved into:\n\n``` language-text\n/my/cache/lodash/1.0.0/node_modules/lodash/uniq/index.js\n```\n\nThis function will return `null` if the request is a builtin module, unless `considerBuiltins` is set to `false`.\n\n### `resolveVirtual(...)`\n\n``` language-ts\nexport function resolveVirtual(path: string): string | null;\n```\n\n**Important:** This function is not part of the Plug'n'Play specification and only available as a Yarn extension. In order to use it, you first must check that the [`VERSIONS`](pnp-api#versions) dictionary contains a valid `resolveVirtual` property.\n\nThe `resolveVirtual` function will accept any path as parameter and return the same path minus any [virtual component](lexicon#virtual-package). This makes it easier to store the location to the files in a portable way as long as you don't care about losing the dependency tree information in the process (requiring files through those paths will prevent them from accessing their peer dependencies).\n\n## Qualified vs Unqualified Resolutions\n\nThis document detailed two types of resolutions: qualified and unqualified. Although similar, they present different characteristics that make them suitable in different settings.\n\nThe difference between qualified and unqualified resolutions lies in the quirks of the Node resolution itself. Unqualified resolutions can be statically computed without ever accessing the filesystem, but only can only resolve relative paths and bare specifiers (like `lodash`); they won't ever resolve the file extensions or folder indexes. By contrast, qualified resolutions are ready to be used to access the filesystem.\n\nUnqualified resolutions are the core of the Plug'n'Play API; they represent data that cannot be obtained any other way. If you're looking to integrate Plug'n'Play inside your resolver, they're likely what you're looking for. On the other hand, fully qualified resolutions are handy if you're working with the PnP API as a one-off and just want to obtain some information on a given file or package.\n\nTwo great options for two different use cases 🙂\n\n## Accessing the files\n\nThe paths returned in the `PackageInformation` structures are in the native format (so Posix on Linux/OSX and Win32 on Windows), but they may reference files outside of the typical filesystem. This is particularly true for Yarn, which references packages directly from within their zip archives.\n\nTo access such files, you can use the `@yarnpkg/fslib` project which abstracts the filesystem under a multi-layer architecture. For example, the following code would make it possible to access any path, regardless of whether they're stored within a zip archive or not:\n\n``` language-ts\nconst {PosixFS, ZipOpenFS} = require(`@yarnpkg/fslib`);\nconst libzip = require(`@yarnpkg/libzip`).getLibzipSync();\n\n// This will transparently open zip archives\nconst zipOpenFs = new ZipOpenFS({libzip});\n\n// This will convert all paths into a Posix variant, required for cross-platform compatibility\nconst crossFs = new PosixFS(zipOpenFs);\n\nconsole.log(crossFs.readFileSync(`C:\\\\path\\\\to\\\\archive.zip\\\\package.json`));\n```\n\n## Traversing the dependency tree\n\nThe following function implements a tree traversal in order to print the list of locators from the tree.\n\n**Important note:** This implementation iterates over **all** the nodes in the tree, even if they are found multiple times (which is very often the case). As a result the execution time is way higher than it could be. Optimize as needed 🙂\n\n``` language-ts\nconst pnp = require(`pnpapi`);\nconst seen = new Set();\n\nconst getKey = locator =>\n  JSON.stringify(locator);\n\nconst isPeerDependency = (pkg, parentPkg, name) =>\n  getKey(pkg.packageDependencies.get(name)) === getKey(parentPkg.packageDependencies.get(name));\n\nconst traverseDependencyTree = (locator, parentPkg = null) => {\n  // Prevent infinite recursion when A depends on B which depends on A\n  const key = getKey(locator);\n  if (seen.has(key))\n    return;\n\n  const pkg = pnp.getPackageInformation(locator);\n  console.assert(pkg, `The package information should be available`);\n\n  seen.add(key);\n\n  console.group(locator.name);\n\n  for (const [name, referencish] of pkg.packageDependencies) {\n    // Unmet peer dependencies\n    if (referencish === null)\n      continue;\n\n    // Avoid iterating on peer dependencies - very expensive\n    if (parentPkg !== null && isPeerDependency(pkg, parentPkg, name))\n      continue;\n\n    const childLocator = pnp.getLocator(name, referencish);\n    traverseDependencyTree(childLocator, pkg);\n  }\n\n  console.groupEnd(locator.name);\n\n  // Important: This `delete` here causes the traversal to go over nodes even\n  // if they have already been traversed in another branch. If you don't need\n  // that, remove this line for a hefty speed increase.\n  seen.delete(key);\n};\n\n// Iterate on each workspace\nfor (const locator of pnp.getDependencyTreeRoots()) {\n  traverseDependencyTree(locator);\n}\n```\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/pnpapi](https://yarnpkg.com/advanced/pnpapi)"
- name: PnPify
  id: advanced/pnpify
  summary: Plug'n'Play is, by design, compatible with all projects that only make use of the require API - whether it's require, require.resolve, or createRequireFromPath
  description: "# PnPify\n\n- [Motivation](#motivation)\n- [PnPify](#pnpify)\n- [Usage](#usage)\n- [Caveat](#caveat)\n- [IDE Support](#ide-support)\n\n## Motivation\n\nPlug'n'Play is, by design, compatible with all projects that only make use of the `require` API - whether it's `require`, `require.resolve`, or `createRequireFromPath`. However, some rare projects prefer to reimplement the Node resolution themselves and as such aren't compatible by default with our environment (unless they integrate their resolvers with the [PnP API](pnpapi)).\n\n## PnPify\n\nPnPify is a tool designed to work around these compatibility issues. It's not perfect - it brings its own set of caveats and doesn't allow you to leverage all the features that PnP has to offer - but it's often good enough to unblock you until better solutions are implemented.\n\nHow it works is simple: when a non-PnP-compliant project tries to access the `node_modules` directories (for example through `readdir` or `readFile`), PnPify intercepts those calls and converts them into calls to the PnP API. Then, based on the result, it simulates the existence of a virtual `node_modules` folder that the underlying tool will then consume - still unaware that the files are extracted from a virtual filesystem.\n\n## Usage\n\n1.  Add PnPify to your dependencies:\n\n``` language-bash\nyarn add @yarnpkg/pnpify\n```\n\n2.  Use pnpify to run the incompatible tool:\n\n``` language-bash\nyarn pnpify tsc\n```\n\nMore details about the run command can be found on its [dedicated page](../pnpify/cli/run).\n\n## Caveat\n\n- Due to how PnPify emulates the `node_modules` directory, some problems are to be expected, especially with tools that watch directories inside `node_modules`.\n\n- PnPify isn't designed to be a long-term solution; its purpose is purely to help projects during their transition to the stricter Plug'n'Play module resolution scheme. Relying on PnPify doesn't allow you to take full advantage of everything Plug'n'Play has to offer, in particular perfect flattening and boundary checks.\n\n## IDE Support\n\nWhen using Plug'n'Play installs with your favorite text editors you will probably want to keep using your extensions, like ESLint or Prettier. To do so, you may need to use `yarn sdks`. For more information, consult the detailed documentation in the [Editor SDKs](../getting-started/editor-sdks) section.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/pnpify](https://yarnpkg.com/advanced/pnpify)"
- name: pnpify run
  id: pnpify/cli/run
  summary: Run a command with a virtual node_modules folder
  description: "# pnpify run\n\nRun a command with a virtual node_modules folder.\n\n## Usage\n\n``` language-text\n$> pnpify run <commandName> ...\n```\n\n## Examples\n\nRun Angular using PnPify :\n\n``` language-text\npnpify ng build\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nWhen a non-PnP-compliant project tries to access the `node_modules` directories (for example through `readdir` or `readFile`), PnPify intercepts those calls and converts them into calls to the PnP API. Then, based on the result, it simulates the existence of a virtual `node_modules` folder that the underlying tool will then consume - still unaware that the files are extracted from a virtual filesystem.\n\nThe `run` keyword can be omitted if the executed command doesn't conflict with built-in commands.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/pnpify/cli/run](https://yarnpkg.com/pnpify/cli/run)"
- name: Protocols
  id: features/protocols
  summary: The following protocols can be used by any dependency entry listed in the dependencies or devDependencies fields
  description: "# Protocols\n\n- [Table](#table)\n\n- [Details](#details)\n\n  - [Exec](#exec)\n  - [Git](#git)\n  - [Patch](#patch)\n  - [Workspace](#workspace)\n\n- [Frequently Asked Questions](#frequently-asked-questions)\n\n  - [Can I install a workspace of a project when using the `git:` protocol?](#can-i-install-a-workspace-of-a-project-when-using-the-git-protocol)\n  - [Why can't I add dependencies through the `patch:` protocol?](#why-cant-i-add-dependencies-through-the-patch-protocol)\n  - [Why is the `link:` protocol recommended over aliases for path mapping?](#why-is-the-link-protocol-recommended-over-aliases-for-path-mapping)\n  - [What's the difference between `link:` and `portal:`?](#whats-the-difference-between-link-and-portal)\n\n## Table\n\nThe following protocols can be used by any dependency entry listed in the `dependencies` or `devDependencies` fields. While they work regardless of the context we strongly recommend you to only use semver ranges on published packages as they are the one common protocol whose semantic is clearly defined across all package managers.\n\n| Name          | Example                                 | Description                                                                                                          |\n|---------------|-----------------------------------------|----------------------------------------------------------------------------------------------------------------------|\n| Semver        | `^1.2.3`                                | Resolves from the default registry                                                                                   |\n| Tag           | `latest`                                | Resolves from the default registry                                                                                   |\n| Npm alias     | `npm:name@...`                          | Resolves from the npm registry                                                                                       |\n| Git           | `git@github.com:foo/bar.git`            | Downloads a public package from a Git repository                                                                     |\n| GitHub        | `github:foo/bar`                        | Downloads a **public** package from GitHub                                                                           |\n| GitHub        | `foo/bar`                               | Alias for the `github:` protocol                                                                                     |\n| File          | `file:./my-package`                     | Copies the target location into the cache                                                                            |\n| Link          | `link:./my-folder`                      | Creates a link to the `./my-folder` folder (ignore dependencies)                                                     |\n| Patch         | `patch:left-pad@1.0.0#./my-patch.patch` | Creates a patched copy of the original package                                                                       |\n| Portal        | `portal:./my-folder`                    | Creates a link to the `./my-folder` folder (follow dependencies)                                                     |\n| Workspace     | `workspace:*`                           | Creates a link to a package in another workspace                                                                     |\n| [Exec](#exec) | `exec:./my-generator-package`           | ^(*Experimental & Plugin*) Instructs Yarn to execute the specified Node script and use its output as package content |\n\n## Details\n\n### Exec\n\nThis protocol is experimental, and only available after installing an optional plugin.\n\nIts documentation and usage can be found on GitHub: [yarnpkg/berry/blob/master/packages/plugin-exec/README.md](https://github.com/yarnpkg/berry/blob/master/packages/plugin-exec/README.md).\n\n### Git\n\nThe Git protocol, while fairly old, has been significantly improved starting from Yarn 2. In particular, some things to know:\n\n- The target repository won't be used as-is - it will first be packed using [`pack`](../cli/pack)\n\n- You can explicitly request a tag, commit, branch, or semver tag, by using one of those keywords (if you're missing the keyword, Yarn will look for the first thing that seems to match, as in prior versions):\n\n``` language-text\ngit@github.com:yarnpkg/berry.git#tag=@yarnpkg/cli/2.2.0\ngit@github.com:yarnpkg/berry.git#commit=a806c88\ngit@github.com:yarnpkg/berry.git#head=master\n```\n\n- Yarn will use either of Yarn, npm, or pnpm to pack the repository, based on the repository style (ie we'll use Yarn if there's a `yarn.lock`, npm if there's a `package-lock.json`, or pnpm if there's a `pnpm-lock.yaml`)\n\n- Workspaces can be cloned as long as the remote repository uses Yarn or npm (npm@\\>=7.x has to be installed on the system); we can't support pnpm because it doesn't have equivalent for the [`workspace` command](../cli/workspace). Just reference the workspace by name in your range (you can optionally enforce the tag as well):\n\n``` language-text\ngit@github.com:yarnpkg/berry.git#workspace=@yarnpkg/shell&tag=@yarnpkg/shell/2.1.0\n```\n\n### Patch\n\nThe `patch:` protocol is meant to be used with [`yarn patch`](../cli/patch) and [`yarn patch-commit`](../cli/patch-commit). It allows you to change the sources for a package without having to completely fork the dependency. The intended workflow is:\n\n1.  Find a package you want to patch (let's say `lodash@^1.0.0`)\n2.  Run `yarn patch lodash`\n3.  Edit the folder the command generated\n4.  Once you're done, run `yarn patch-commit -s <path>`\n5.  In your manifest, change the dependency from `^1.0.0` to:\n\n``` language-text\npatch:lodash@^1.0.0#path/to/generated/file.patch\n```\n\nNote that if you wish to update a transitive dependency (ie not directly yours), it's perfectly possible to use the [`resolutions` field](../configuration/manifest#resolutions).\n\n### Workspace\n\nThe `workspace:` protocol is meant to be used with [workspaces](workspaces#workspace-ranges-workspace). While Yarn automatically picks workspace resolutions when they match, there are times where you absolutely don't want to risk using a package from the remote registry even if the versions don't match (for example if your project isn't actually meant to be published and you just want to use the workspaces to better compartmentalize your code).\n\nOur current recommendation is to use `workspace:*`, which will almost always do what you expect. See [the documentation of workspaces](workspaces#workspace-ranges-workspace) for full details about this protocol.\n\n## Frequently Asked Questions\n\n### Can I install a workspace of a project when using the `git:` protocol?\n\nYes! Yarn supports workspaces even through git dependencies, using the following syntax:\n\n``` language-json\n{\n  \"dependencies\": {\n    \"my-pkg\": \"org/app#workspace=my-pkg\"\n  }\n}\n```\n\nYou can even combine it with the branch selectors:\n\n``` language-json\n{\n  \"dependencies\": {\n    \"my-pkg\": \"org/app#head=next&workspace=my-pkg\"\n  }\n}\n```\n\n> **Note:** For this workflow to work, make sure that each individual workspaces can be built just by running `yarn install && yarn pack` into each individual workspace. In particular, avoid third-party release scripts unless they use `yarn pack` under the hood.\n\n### Why can't I add dependencies through the `patch:` protocol?\n\nA Yarn install is split across multiple steps (described [here](../advanced/architecture#install-architecture)). Most importantly, we first fully resolve the dependency tree, and only then do we download the packages from their remote sources. Since patches occur during this second step, by the time we inject the new dependencies it's already too late as the dependency tree has already been frozen.\n\nIn order to add dependencies to a package, either fork it (and reference it through the Git protocol, for example), or use the [`packageExtensions`](../configuration/yarnrc#packageExtensions) mechanism which is specifically made to add new runtime dependencies to packages.\n\n### Why is the `link:` protocol recommended over aliases for path mapping?\n\nMany tools support a feature generally known as \"aliases\", which allows you to map a specific directory to a package name. This pattern allows you to use regular package imports (`my-app/Toolbar`) instead of potentially complex relative paths (`../../../Toolbar`). It sounds awesome! So why do we recommend against this practice?\n\nAs we said, many tools support this feature. But the trick is that their implementations and configurations are all subtly different. Depending on the tool, it will be called `moduleNameMapper`, `resolve.alias`, `paths`, or even `module.name_mapper`. Depending on the tool it'll be a regex, a domain-specific language, or just a package name. All those differences make it difficult to keep the configurations synchronized, and likely that a mistake will creep in. Even worse, it'll lock you out of tools that don't support aliases, since they won't know how to deal with these paths they know nothing about.\n\nEnter the `link:` protocol! Through it, you directly instruct the package manager to install a resolution from the given name to the given path. Since the package manager's knowledge base is used by every package in your project, adding a link dependency is enough to make all your tooling aware of this new connection. No need for further configuration 💫\n\n``` language-json\n{\n  \"dependencies\": {\n    \"src\": \"link:./src\"\n  }\n}\n```\n\n> **Tip:** Yarn 2 implements support for self-references, making the `link:` protocol unneeded in most cases. Any file that's part of a package will always be able to import any file from its own package using the package name - even the top-level project! Just add a `\"name\": \"app\"` field into your top-level package.json, and you'll be able to use `import 'app/Toolbar'` without further ado.\n\n> **Note:** You may be tempted to alias a scope without giving an explicit name (ie `\"@app\": \"link:./src\"`). Don't. This pattern is invalid and won't work. The reason for this is that package identifiers have a required package name, and an optional scope name. As a result, a scope without package name is a syntax error. Prefer doing `\"app\": \"link:./src\"`, which will still allow you to use subdirectories if needed (ie `import 'app/toolbar/Icon'`).\n\n> **Note:** By reading this FAQ entry, you might think that we recommend against using aliases altogether. This isn't entirely correct. While using aliases *for directory mapping* is a practice we advise against, they have their usefulness in other contexts. For example, using an alias to map the `fs` module into a local mock is perfectly fine.\n\n### What's the difference between `link:` and `portal:`?\n\nThe `link:` protocol is meant to link a package name to a folder on the disk - any folder. For example, one perfect use case for the `link:` protocol is to map your `src` folder to a clearer name that you can then use from your Node applications without having to use relative paths (for example you could link `my-app` to `link:./src` so that you can call `require('my-app')` from any file within your application).\n\nBecause such destination folders typically don't contain `package.json`, the `link:` protocol doesn't even try to read them. It can cause problems when you want to link an identifier to a different *package* on the disk (similar to what `yarn link` does) because then the transitive dependencies aren't resolved.\n\nIn order to solve this use case, the new `portal:` protocol available in the v2 opens a portal to any package located on your disk. Because portals are meant to only target packages they can leverage the information from the `package.json` files listed within their targets to properly resolve transitive dependencies.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/protocols](https://yarnpkg.com/features/protocols)"
- name: Release Workflow
  id: features/release-workflow
  summary: This feature is still incubating, and we'll likely be improving it based on your feedback
  description: "# Release Workflow\n\n> **Experimental**\n>\n> This feature is still incubating, and we'll likely be improving it based on your feedback.\n\n> **Plugin**\n>\n> To access this feature, first install the `version` plugin: `yarn plugin import version`\n\nWhen working with monorepos, a hard task often is to figure out which packages should receive a new version when starting a new release. Yarn offers a few tools that aim to make this workflow easier without the need for third-party tools (although it's possible you may prefer the workflow offered by different implementations, of course!).\n\n- [Auto-updated dependencies](#auto-updated-dependencies)\n\n- [Deferred versioning](#deferred-versioning)\n\n- [Checked-in deferred records](#checked-in-deferred-records)\n\n- [Ensuring that versions are bumped (CI)](#ensuring-that-versions-are-bumped-ci)\n\n  - [Caveat](#caveat)\n\n    - [Commit history](#commit-history)\n\n## Auto-updated dependencies\n\nWhen running the `yarn version` command to upgrade the version of a workspace, every other workspace that depend on the first one through a basic semver ranges (`^x.y.z`, `~x.y.z`, ...) will get auto-updated to reference the new version. For example, let's say we have the following workspaces:\n\n``` language-text\n/packages/common (1.0.0)\n/packages/server (depends on common@^1.0.0)\n/packages/client (depends on common@^1.0.0)\n```\n\nIn pre-2.0, upgrading `common` would have required you to run the command there, then go into each of `server` and `client` to manually upgrade their dependencies to reference the new version. But not anymore! If we run `yarn version 1.1.1` into `common`, the following changes will be applied:\n\n``` language-text\n/packages/common (1.1.1)\n/packages/server (depends on common@^1.1.1)\n/packages/client (depends on common@^1.1.1)\n```\n\nOf course it's not that important when the packages from the monorepo are always meant to be used as part of the monorepo, but it becomes much more interesting when you work with multiple packages meant to be published. Have you forgotten to update the range of either of your dependent packages, your users would have potentially downloaded an old version of `common` which wouldn't have been compatible with the newer one.\n\n## Deferred versioning\n\nStarting from the 2.0, the `yarn version` command now accepts a new flag: `--deferred`. When set, this flag will cause the command to not immediately change the `version` field of the local manifest, but to instead internally record an entry stating that the current package will need to receive an upgrade during the next release cycle. For example, the following:\n\n``` language-bash\nyarn version minor --deferred\n```\n\nWill not cause the `package.json` file to change! Instead, Yarn will create (or reuse, if you're inside a branch) a file within the `.yarn/versions` directory. This file will record the requested upgrade:\n\n``` language-yaml\nreleases:\n  my-package@1.0.0: minor\n```\n\nThen later on, once you're ready, just run `yarn version apply`. Yarn will then locate all the upgrade records it previously saved, and apply them all at once (including by taking care of upgrading inter-dependencies as we saw).\n\n## Checked-in deferred records\n\nWe've seen in the previous section that `yarn version patch` could store the future versions in an internal folder, `.yarn/versions`. But why is that? What good is it? To answer this question, consider a popular open-source project developed through a monorepo. This project receives many external pull requests, but they aren't released right away - they're often released as part of a batch. Every once in a while, the lead maintainer will take all the changes, convert them into new versions, and start the deployment.\n\nLet's focus on the part where changes have to be converted into versions. How does that work? This isn't easy. Taking Lerna, for example (the most popular version management tool for monorepos), you have two solutions:\n\n- With the fixed mode, all your packages have a single version. As such, they get upgraded all at once.\n\n- With the independent mode, you get to chose a version for each package whose sources changed.\n\nOne critical problem remains, though: even if you use the independent mode, how will you know which packages are meant to be upgraded? And, just as critical, should they be patch releases? Minor releases? Hard to know - large projects can receive dozens of PRs a week, and keeping track of which units need to be released and to which version is a pretty difficult task.\n\nWith Yarn's workflow, however, this all becomes very easy! Since the upgrades are kept in a file, and since this file is magically bound to a Git branch, it simply becomes a matter of committing the release folder - all expected releases will then become part of the project history until comes the time of `yarn version apply` - then Yarn will consume all the individual records, merge then (so that a PR requiring a minor will have higher precedence than the PR requiring a patch), and apply them simultaneously.\n\nAs an added bonus, you'll even be able to review the package upgrades as part of the typical PR review! This will have the effect of delegating more power to your community while being able to ensure that everyone follows rules.\n\n## Ensuring that versions are bumped (CI)\n\nOne problem with committing the deferred releases, however, is that it becomes important to make sure that the PRs you receive include the correct package release definitions. For example, you should be able to trust that the definition contains release strategies (patch, minor, major, ...) for each modified workspace.\n\nTo solve this problem in an automated way, the `yarn version check` command appeared. When run, this command will figure out which packages changed and whether they are listed in the release definition file. If they aren't, an error will be thrown and - assuming you integrate this into a CI system such as the GitHub Actions - the PR author will be asked to fill out the release definition file.\n\nWriting this file can be tedious; fortunately `yarn version check` implements a very handy flag named `--interactive`. When set (`yarn version check --interactive`), Yarn will print a terminal interface that will summarize all the changed files, all the changed workspaces, all relevant dependent workspaces, and checkboxes for each entry allowing you to pick the release strategies you want to set for each workspace.\n\nThe [`changesetIgnorePatterns`](../configuration/yarnrc#changesetIgnorePatterns) configuration option can be used to ignore files when checking which files have changed. It is useful for excluding files that don't affect the release process (e.g. test files).\n\n### Caveat\n\n#### Commit history\n\nThe `version` plugin requires access to the commit history in order to be able to correctly infer which packages require release specifications. In particular, when using GitHub Actions with `actions/checkout@v2` or greater the default behavior is for Git to fetch just the version being checked, which would cause problems. To correct this, you will need to override the `fetch-depth` configuration value to fetch the whole commit history:\n\n``` language-yaml\n- uses: actions/checkout@v2\n  with:\n    fetch-depth: 0\n```\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/release-workflow](https://yarnpkg.com/features/release-workflow)"
- name: Rulebook
  id: advanced/rulebook
  summary: Writing portable packages is incredibly important, as it ensures that your users will benefit from an optimal experience regardless of their package manager
  description: "# Rulebook\n\nWriting portable packages is incredibly important, as it ensures that your users will benefit from an optimal experience regardless of their package manager.\n\nTo help with that, this page details the up-to-date collection of good practices you should follow in order to make your package work seamlessly on all three main package managers (Yarn, pnpm, and npm), and explanations if you want to learn more.\n\n- [Packages should only ever require what they formally list in their dependencies](#packages-should-only-ever-require-what-they-formally-list-in-their-dependencies)\n- [Modules shouldn't hardcode `node_modules` paths to access other modules](#modules-shouldnt-hardcode-node_modules-paths-to-access-other-modules)\n- [User scripts shouldn't hardcode the `node_modules/.bin` folder](#user-scripts-shouldnt-hardcode-the-node_modulesbin-folder)\n- [Published packages should avoid using `npm run` in their scripts](#published-packages-should-avoid-using-npm-run-in-their-scripts)\n- [Packages should never write inside their own folder outside of postinstall](#packages-should-never-write-inside-their-own-folder-outside-of-postinstall)\n- [Packages should use the `prepack` script to generate dist files before publishing](#packages-should-use-the-prepack-script-to-generate-dist-files-before-publishing)\n\n## Packages should only ever require what they formally list in their dependencies\n\n**Why?** Because otherwise your package will be susceptible to unpredictable \\[hoisting\\](/advanced/lexicon#hoisting) that will lead some of your consumers to experience pseudo-random crashes, depending on the other packages they will happen to use. Click on this paragraph to expand it and read a detailed example of the issues typically triggered by incorrect hoisting.\n\nImagine that Alice uses Babel. Babel depends on an utility package which itself depends on an old version of Lodash. Since the utility package already depends on Lodash, Bob, the Babel maintainer, decided to use Lodash without formally declaring it in Babel itself.\n\nBecause of the hoisting, Lodash will be put at the top, the tree becoming something like this:\n\nSo far, everything is nice: the utility package can still require Lodash, but now Babel can too. Perfect! Now, imagine that Alice also adds Gatsby to the mix, which would change the dependency tree as such:\n\nNow the hoisting becomes more interesting - since Babel doesn't formally declare the dependency, two different hoisting layouts can happen. The first one is pretty much identical to what we already had before, and under this layout things will be working just fine:\n\nBut a second layout is just as likely! And that's when things become trickier:\n\nFirst, let's check that this layout is valid: Gatsby still gets its Lodash 4 dependency, the Babel utility package still gets Lodash 1, and Babel itself still gets the utility package, just like before. But hold on, something else changed! Babel will no longer access Lodash 1! It'll instead retrieve the Lodash 4 copy that Gatsby provided, likely incompatible with whatever Babel originally expected. In the best case the application will crash, in the worst case it'll silently pass and generate incorrect results.\n\nIf Babel had instead defined Lodash 1 as its own dependency, the package manager would have been able to encode this constraint and ensure that the requirement would have been met regardless of the hoisting.\n\n**Solution:** In most cases (when the missing dependency is a utility package), the fix is really just to add the missing entry to the [`dependencies` field](../configuration/manifest#dependencies). While often enough, a few more complex cases sometimes arise:\n\n- If your package is a plugin (for example `babel-plugin-transform-commonjs`) and the missing dependency is the core (for example `babel-core`), you would need to instead register the dependency inside the [`peerDependencies` field](../configuration/manifest#peerDependencies).\n\n- If your package is something that automatically loads plugins (for example `eslint`), peer dependencies obviously aren't an option as you can't reasonably list all plugins. Instead, you should use the [`createRequire` function](https://nodejs.org/api/module.html#module_module_createrequire_filename) (or its [polyfill](https://github.com/nuxt-contrib/create-require)) to load plugins *on behalf of* the configuration file that lists the plugins to load - be it the package.json or a custom one like the `.eslintrc.js` file.\n\n- If your package only requires the dependency in specific cases that the user control (for example `mikro-orm` which only depends on `sqlite3` if the consumer actually uses a SQLite3 database), use the [`peerDependenciesMeta` field](../configuration/manifest#peerDependenciesMeta.optional) to declare the peer dependency as optional and silence any warning when unmet.\n\n- If your package is a meta-package of utilities (for example Next.js, which itself depends on Webpack so that its consumers don't have to do it), the situation is a bit complicated and you have two different options:\n\n  - The preferred one is to list the dependency (in Next.js's case, `webpack`) as *both a regular dependency and a peer dependency*. Yarn will interpret this pattern as \"peer dependency with a default\", meaning that your users will be able to take ownership of the Webpack package if they need to, while still giving the package manager the ability to emit a warning if the provided version is incompatible with the one your package expects.\n\n  - An alternative is to instead re-export the dependency as part of your public API. For example, Next could expose a `next/webpack` file that would only contain `module.exports = require('webpack')`, and consumers would require that instead of the typical `webpack` module. This isn't the recommended approach, however, because it wouldn't play well with plugins that expect Webpack to be a peer dependency (they wouldn't know that they need to use this `next/webpack` module instead).\n\n## Modules shouldn't hardcode `node_modules` paths to access other modules\n\n**Why?** The hoisting makes it impossible to be sure that the layout of the `node_modules` folder will always be the same. In fact, depending on the exact install strategy, the `node_modules` folders may not even exist.\n\n**Solution:** If you need to access one of your dependencies' files through the `fs` API (for example to read a dependency's `package.json`), just use `require.resolve` to obtain the path without having to make assumptions about the dependency location:\n\n``` language-ts\nconst fs = require(`fs`);\nconst data = fs.readFileSync(require.resolve(`my-dep/package.json`));\n```\n\nIf you need to access one of your dependencies' dependency (we really don't recommend that, but in some fringe cases it may happen), instead of hardcoding the `node_modules` path, use the [`createRequire`](https://nodejs.org/api/module.html#module_module_createrequire_filename) function:\n\n``` language-ts\nconst {createRequire} = require(`module`);\nconst firstDepReq = createRequire(require.resolve(`my-dep/package.json`));\nconst secondDep = firstDepReq(`transitive-dep`);\n```\n\nNote that while `createRequire` is Node 12+, a polyfill exists under the name [`create-require`](https://github.com/nuxt-contrib/create-require).\n\n## User scripts shouldn't hardcode the `node_modules/.bin` folder\n\n**Why?** The `.bin` folder is an implementation detail, and may not exist at all depending on the install strategy.\n\n**Solution:** If you're writing a [script](../configuration/manifest#scripts), you can just refer to the binary by its name! So instead of `node_modules/.bin/jest -w`, prefer just writing `jest -w` which will work just fine. If for some reason `jest` isn't available, check that the current package properly [defines it as a dependency](#a-package-should-only-require-what-it-lists-in-its-dependencies).\n\nSometimes you may find yourself having slightly more complex needs, for example if you wish to spawn a script with specific Node flags. Depending on the context we recommend passing options via the [`NODE_OPTIONS` environment variable](https://nodejs.org/api/cli.html#cli_node_options_options) rather than the CLI, but if that's not an option you can use `yarn bin <name>` to get the specified binary path:\n\n``` language-text\nyarn node --inspect $(yarn bin jest)\n```\n\nNote that, in this particular case, `yarn run` also supports the `--inspect` flag so you could just write:\n\n``` language-text\nyarn run --inspect jest\n```\n\n## Published packages should avoid using `npm run` in their scripts\n\n**Why?** This is a tricky one ... basically, it boils down to: package managers are not interchangeable. Using one package manager on a project installed by another is a recipe for troubles, as they follow different configuration settings and rules. For example, Yarn offers a hook system that allows its users to track which scripts are executed and how much time they take. Because `npm run` wouldn't know how to call these hooks, they would get ignore, leading to frustrating experiences for your consumers.\n\n**Solution:** While not the most esthetically pleasing option, the most portable one at the moment is to simply replace `npm run <name>` (or `yarn run <name>`) in your postinstall scripts and derived by the following:\n\n``` language-text\n$npm_execpath run <name>\n```\n\nThe `$npm_execpath` environment variable will get replaced by the right binary depending on the package manager your consumers will use. Yarn also supports just calling `run <name>` without any mention of the package manager, but to this date no other package manager does.\n\n## Packages should never write inside their own folder outside of postinstall\n\n**Why?** Depending on the install strategy, packages may be kept in read-only data stores where write accesses will be rejected. This is particularly true when using \"system-global\" stores, where modifying the sources for one package would risk corrupting all the projects depending on it from the same machine.\n\n**Solution:** Just write in another directory rather than your own package. Anything would work, but a very common idiom is to use the `node_modules/.cache` folder in order to store cache data - that's for example what Babel, Webpack, and more do.\n\nIf you absolutely need to write into your package's source folder (but really, we never came across this use case before), you still have the option to use [`preferUnplugged`](../configuration/manifest#preferUnplugged) to instruct Yarn to disable optimizations on your package and store it inside its own project-local copy, where you'll be able to mutate it at will.\n\n## Packages should use the `prepack` script to generate dist files before publishing\n\n**Why?** The original npm supported [many different scripts](https://docs.npmjs.com/misc/scripts). So much, in fact, that it became very difficult to know which script one would want to use in which context. In particular, the very subtle differences between the `prepack`, `prepare`, `prepublish`, and `prepublish-only` scripts led many to use the wrong script in the wrong context. For this reason, Yarn 2 deprecated most of the scripts and consolidated them around a restricted set of portable scripts.\n\n**Solution:** Always use the `prepack` script if you wish to generate dist artifacts before publishing your package. It will get called before calling `yarn pack` (which itself is called before calling `yarn npm publish`), when cloning your git repository as a git dependency, and any time you will run `yarn prepack`. As for `prepublish`, never use it with side effects - its only use should be to run tests before the publish step.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/rulebook](https://yarnpkg.com/advanced/rulebook)"
- name: sdks
  id: sdks/cli/default
  summary: Generate editor SDKs and settings
  description: "# sdks\n\nGenerate editor SDKs and settings.\n\n## Usage\n\n``` language-text\n$> sdks ...\n```\n\n## Examples\n\nGenerate the base SDKs :\n\n``` language-text\nsdks base\n```\n\nGenerate the base SDKs and editor settings for supported editors :\n\n``` language-text\nsdks vscode vim\n```\n\nUpdate all generated SDKs and editor settings :\n\n``` language-text\nsdks\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command generates a new directory, `.yarn/sdks`, which includes the base SDKs.\n\nWhen used without arguments, it:\n\n- throws an error on non-pnpified projects\n\n- updates all existing SDKs and editor settings on already-pnpified projects\n\nThe optional integrations arguments are a set of supported integrations, or the keyword `base`.\n\n- When `base` is used, only the base SDKs will be generated. This is useful for when an editor is not yet supported and you plan to manage the settings yourself.\n\n- When a set of integrations is used (e.g. `vscode`, `vim`, ...), the base SDKs will be installed plus all the settings relevant to the corresponding environments (for example on VSCode it would set `typescript.tsdk`).\n\nThe supported integrations at this time are: `vim`, `vscode`.\n\n**Note:** This command always updates the already-installed SDKs and editor settings, no matter which arguments are passed.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/sdks/cli/default](https://yarnpkg.com/sdks/cli/default)"
- name: Sherlock
  id: advanced/sherlock
  summary: In order to simplify our work maintaining Yarn, we ask you to help us by providing reproductions for the bugs you encounter
  description: "# Sherlock\n\nIn order to simplify our work maintaining Yarn, we ask you to help us by providing reproductions for the bugs you encounter. We can't stress this enough: under normal circumstances, **no reproduction will mean no help** and your issue may be closed for this reason.\n\nTo help you help us, we use a tool called [Sherlock](https://github.com/arcanis/sherlock) which allows you to attach reproduction testcases to your issues. In a sense, it's a bit like if you were writing a Jest test directly in your issue. By using this system we can quickly check whether a problem can be reproduced, and whether our fix is the right one. It's a win-win for everyone!\n\n- [Adding a reproduction to your issue](#adding-a-reproduction-to-your-issue)\n\n- [Developing your reproduction](#developing-your-reproduction)\n\n  - [Features](#features)\n  - [Limitations](#limitations)\n\n- [Available functions](#available-functions)\n\n- [Examples](#examples)\n\n- [Q&A](#qa)\n\n  - [Can I develop my reproduction offline?](#can-i-develop-my-reproduction-offline)\n  - [The Sherlock bot doesn't label my message](#the-sherlock-bot-doesnt-label-my-message)\n  - [The Sherlock bot is labelling my issue with `broken-repro`](#the-sherlock-bot-is-labelling-my-issue-with-broken-repro)\n  - [How can I run the bot again?](#how-can-i-run-the-bot-again)\n  - [That's really cool, can I do the same on my own project?](#thats-really-cool-can-i-do-the-same-on-my-own-project)\n\n## Adding a reproduction to your issue\n\nAdding a reproduction is as simple as adding a markdown codefence to your issue:\n\n```` language-markdown\nThis is my reproduction case:\n\n```js repro\nconst foo = await ...;\n```\n````\n\n> **Important:** Note that the codefence is not only tagged `js`, but also `repro`. This is critical, as we don't want to execute every single snippet!\n\n## Developing your reproduction\n\nThe easiest and most convenient way to develop your reproduction is by using the [Playground](../playground) (powered by [CodeSandbox](https://codesandbox.io/)).\n\n> Note: We ***strongly*** encourage you to use the Playground. It saves both you and us important time. Also, in the future, we *might* autoclose issues without a reproduction after a period of time, unless a contributor manually labels them as `reproducible`, so be prepared!\n\n### Features\n\n- A [Monaco Editor](https://microsoft.github.io/monaco-editor/) (the editor that powers VSCode) where you can write your reproduction.\n- A Terminal-like output where you can see the assertion or the error / playground tips if you haven't run anything yet.\n- A Menu for selecting reproduction templates. Note: Your last input is saved inside `localStorage` for future use.\n- The status of the playground (more information on hover).\n- An `Export` button that can be used to share the link of the playground and even copy/open an issue in our repo with the issue template filled with your reproduction (status has to be `reproducible`). You can also open the reproduction in CodeSandbox.\n- Shareable Playground URLs - You can export them by using the `Export` button and the code will be automatically imported inside the Playground when you access it through them.\n\n### Limitations\n\n- Reproductions are run inside a CodeSandbox container, so they're always running inside a Linux environment, with the Node version that CodeSandbox uses. This limitation also exists when running the reproduction with Sherlock inside an issue, so if you need to use a specific OS / Node version, you **have to** [develop your reproduction offline](#can-i-develop-my-reproduction-offline).\n- Don't use very large packages unless you absolutely have to - the sandbox won't like it.\n- The sandbox may go to sleep after some time. If that happens, reload the page to reboot it.\n\n## Available functions\n\nYou can use all of Javascript inside the repro code, including `async/await`. In fact, you can even use top-level `await`! As far as the runtime goes you should have access to all of Node's APIs, plus some extras:\n\n- In order to simplify some tasks that would be very menial otherwise (like spawning the Yarn process, or running a Node script in the generated environment), we provide a set of builtin functions that abstract these semantics. You can find the full reference inside [our repository](https://github.com/yarnpkg/berry/tree/master/scripts/actions/sherlock-prepare.js), along with some documentation.\n\n  **Note:** All core plugins are enabled by default, you don't need to run yarn import on them again.\n\n- The [expect](https://jestjs.io/docs/en/expect) API is available globally and *must* be used to describe the assertions in your test (simply throwing will cause Sherlock to mark your reproduction case as broken).\n\n## Examples\n\nIn [\\#478](https://github.com/yarnpkg/berry/issues/478), Yarn used to print an incorrect help message.\n\n``` language-js\nconst output = await yarn(`add`, `--help`);\n\nexpect(output).not.toContain(`yarn yarn`);\n```\n\nIn [\\#448](https://github.com/yarnpkg/berry/issues/448), running `pnpify --sdk` used to fail when ESLint was missing.\n\n``` language-js\nawait packageJsonAndInstall({\n  devDependencies: {\n    [`@yarnpkg/pnpify`]: `^2.0.0-rc.3`,\n    [`typescript`]: `^3.6.3`\n  }\n});\n\nawait expect(yarn(`pnpify`, `--sdk`)).rejects.not.toThrow(`Command failed`);\n```\n\nIn [\\#361](https://github.com/yarnpkg/berry/issues/361), running `yarn add dep` when `dep` was already a devDependency used to duplicate it in both fields:\n\n``` language-js\nconst {promises: {readFile}} = require(`fs`);\n\nawait packageJsonAndInstall({\n  devDependencies: {lodash: `*`},\n});\n\nawait yarn(`add`, `lodash`);\n\nconst pkgJson = JSON.parse(await readFile(`package.json`, `utf8`));\nexpect(pkgJson.dependencies).not.toHaveProperty(`lodash`);\n```\n\nFor more examples, consult the list of issues that have been tagged as having valid reproductions:\n\n<https://github.com/yarnpkg/berry/issues?q=is%3Aissue+label%3Areproducible+is%3Aclosed>\n\n## Q&A\n\n### Can I develop my reproduction offline?\n\nIf you can't use the Playground, you can build a reproduction offline and only share it once it's ready:\n\n1.  Clone our [repository](https://github.com/yarnpkg/berry)\n2.  Go into it, and write your issue in a markdown file (as if you were on GitHub)\n3.  Once ready, run `yarn sherlock <my-file.md>` to make Sherlock run your reproduction locally\n\nNote that you must write the issue itself, not only the reproduction, so don't forget to add the codefence etc. Once you are done, copy-paste the result on GitHub and the bot will promptly review your code and approve it.\n\n### The Sherlock bot doesn't label my message\n\nIt likely means that it didn't see your issue as containing a reproduction case. Make sure you properly added the `repro` tag to your codefence:\n\n```` language-markdown\nThis is my reproduction case:\n\n```js repro\nconst foo = ...;\n```\n````\n\n### The Sherlock bot is labelling my issue with `broken-repro`\n\nThis means that your code is throwing an exception on our systems which doesn't seem to be part of the expected testsuite. Note that only exceptions thrown by the [expect](https://jestjs.io/docs/en/expect) API will lead to your reproduction being correctly labelled.\n\nIf you wish to test that something is failing (for example to test that `yarn install --immutable` doesn't work when the lockfile isn't up-to-date, or something like this) you can use the following pattern:\n\n``` language-js\nawait expect(async () => {\n  // ...\n}()).rejects.toThrow();\n```\n\n### How can I run the bot again?\n\nEditing the issue content will cause the bot to run again. If you're a maintainer, you can also remove the reproduction label from the issue and Sherlock will happilly execute it again.\n\n### That's really cool, can I do the same on my own project?\n\nSherlock is an open-source project that we develop on [this repository](https://github.com/arcanis/sherlock). Try and let us know how it worked out for you!\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/sherlock](https://yarnpkg.com/advanced/sherlock)"
- name: Telemetry
  id: advanced/telemetry
  summary: As maintainers, it's sometimes difficult to know what we should prioritize
  description: "# Telemetry\n\n## Why does Yarn need some telemetry?\n\nAs maintainers, it's sometimes difficult to know what we should prioritize. Are large monorepos the most common situation our users encounter? What packageExtensions are the most common? How many people opted-out to the nm linker? Etc.\n\nAdditionally, because of the lack of telemetry, some projects also had trouble taking us seriously. Various threads in the Node docker image repositories suggested to remove Yarn from the Docker image, citing Yarn as a fringe tool. Our team doesn't have time to spend collecting the various polls from the surface of the earth, nor should we have to.\n\n## Will my information go to Facebook?\n\nNo. [Yarn is not a Facebook project](../getting-started/qa#is-yarn-operated-by-facebook), and Facebook won't receive **any** amount of data collected this way, and neither will Google, or Microsoft.\n\nThe data we collect are stored on [Datadog](https://www.datadoghq.com/), a trusted large-scale monitoring company with a heavy focus on security.\n\n## Which information are we talking about?\n\nAs of today, we collect the following:\n\n- The Yarn version\n- Which command name is used (but not its arguments)\n- The active plugin names (only for our own plugins; yours are hidden)\n- The number of installs run during the week\n- The number of different projects having been installed\n- How many installs for the nm linker\n- The number of workspaces\n- The number of dependencies\n- The packageExtensions field (name of extended + name of the extra dependency)\n- The IP address (most providers unfortunately don't let us remove that)\n\nData are sent via batches, roughly every seven days. This prevents us from tracking your usage with a too high granularity, leaving us only the most useful information to do our job efficiently.\n\n## How can I disable it?\n\nNote that, regardless of the configuration, the telemetry won't ever run on CI.\n\n- To disable it on a project (including for anyone who would clone it), run `yarn config set enableTelemetry 0`. This will make our life ever so slightly more difficult, so please consider whether it's really what you want to do.\n\n- To disable it on your whole machine (but not for anyone else), run `yarn config set --home enableTelemetry 0`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/advanced/telemetry](https://yarnpkg.com/advanced/telemetry)"
- name: Workspaces
  id: features/workspaces
  summary: The Yarn workspaces aim to make working with monorepos easy, solving one of the main use cases for yarn link in a more declarative way
  description: "# Workspaces\n\nThe Yarn workspaces aim to make working with [monorepos](../advanced/lexicon#monorepository) easy, solving one of the main use cases for `yarn link` in a more declarative way. In short, they allow multiple of your projects to live together in the same repository AND to cross-reference each others - any modification to one's source code being instantly applied to the others.\n\nFirst, some vocabulary: in the context of the workspace feature, a *project* is the whole directory tree making up your workspaces (often the repository itself). A *workspace* is a local package made up from your own sources from that same project. Finally, a *worktree* is the name given to workspaces that list their own child workspaces. A project contains one or more worktrees, which may themselves contain any number of workspaces. Any project contains at least one workspace: the root one.\n\n- [How to declare a worktree?](#how-to-declare-a-worktree)\n- [What does it mean to be a workspace?](#what-does-it-mean-to-be-a-workspace)\n- [Workspace ranges (`workspace:`)](#workspace-ranges-workspace)\n- [Publishing workspaces](#publishing-workspaces)\n- [Yarn Workspaces vs Lerna](#yarn-workspaces-vs-lerna)\n\n## How to declare a worktree?\n\nWorktrees are defined through the traditional `package.json` files. What makes them special is that they have the following properties:\n\n- They must declare a `workspaces` field which is expected to be an array of glob patterns that should be used to locate the workspaces that make up the worktree. For example, if you want all folders within the `packages` folder to be workspaces, just add `packages/*` to this array.\n\n- They must be connected in some way to the project-level `package.json` file. This doesn't matter in the typical workspace setup because there's usually a single worktree defined in the project-level `package.json`, but if you try to setup nested workspaces then you must make sure that the nested worktree is defined as a valid workspace of its parent worktree (otherwise Yarn won't find its correct parent folder).\n\nNote that because worktrees are defined with an otherwise regular `package.json` file, they also are valid workspaces themselves. If they're named, other workspaces will be able to properly cross-reference them.\n\n> **Note**\n>\n> Worktrees used to be required to be private (ie list `\"private\": true` in their package.json). This requirement got removed with the 2.0 release in order to help standalone projects to progressively adopt workspaces (for example by listing their documentation website as a separate workspace).\n\n## What does it mean to be a workspace?\n\nWorkspaces have two important properties:\n\n- Only the dependencies depended upon by a workspace can be accessed. Said another way, we strictly enforce your workspaces dependencies. Doing this allows us to cleanly decouple projects from one another, since you don't have to merge all their dependencies in one huge unmaintainable list. We still provide tools to manage dependencies from multiple workspaces at once, but they need to be explicitly used and offer a better integration (for example `yarn add` can make suggestions for your new dependencies based on what other workspaces use, but you can override them).\n\n- If the package manager was to resolve a range that a workspace could satisfy, it will prefer the workspace resolution over the remote resolution if possible. This is the pillar of the monorepo approach: rather than using the remote packages from the registry, your project packages will be interconnected and will use the code stored within your repository.\n\n## Workspace ranges (`workspace:`)\n\nWhile Yarn automatically picks workspace resolutions when they match, there are times where you absolutely don't want to risk using a package from the remote registry even if the versions don't match (for example if your project isn't actually meant to be published and you just want to use the workspaces to better compartment your code).\n\nFor those use cases, Yarn now supports a new resolution protocol starting from the v2: `workspace:`. When this protocol is used Yarn will refuse to resolve to anything else than a local workspace. This range protocol has two flavors:\n\n- If a semver range, it will select the workspace matching the specified version.\n- If a project-relative path, it will select the workspace that match this path **(experimental)**.\n\nNote that the second flavor is experimental and we advise against using it for now, as some details might change in the future. Our current recommendation is to use `workspace:*`, which will almost always do what you expect.\n\n## Publishing workspaces\n\nWhen a workspace is packed into an archive (whether it's through `yarn pack` or one of the publish commands like `yarn npm publish`), we dynamically replace any `workspace:` dependency by:\n\n- The corresponding version in the target workspace (if you use `*`, `^`, `~`, or a project-relative path)\n- The associated semver range (for any other range type)\n\nSo for example, if we assume we have the following workspaces whose current version is `1.5.0`, the following:\n\n``` language-json\n{\n  \"dependencies\": {\n    \"star\": \"workspace:*\",\n    \"caret\": \"workspace:^\",\n    \"tilde\": \"workspace:~\",\n    \"range\": \"workspace:^1.2.3\",\n    \"path\": \"workspace:path/to/baz\"\n  }\n}\n```\n\nWill be transformed into:\n\n``` language-json\n{\n  \"dependencies\": {\n    \"star\": \"1.5.0\",\n    \"caret\": \"^1.5.0\",\n    \"tilde\": \"~1.5.0\",\n    \"range\": \"^1.2.3\",\n    \"path\": \"1.5.0\"\n  }\n}\n```\n\nThis feature allows you to not have to depend on something else than your local workspaces, while still being able to publish the resulting packages to the remote registry without having to run intermediary publish steps - your consumers will be able to use your published workspaces as any other package, still benefiting from the guarantees semver offers.\n\n## Yarn Workspaces vs Lerna\n\nDespite the appearances, the Yarn workspaces and Lerna don't compete. In fact, Lerna will use Yarn's workspaces if possible. In a sense, you can see Lerna as a high-level layer on top of the low-level Yarn implementation.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/workspaces](https://yarnpkg.com/features/workspaces)"
- name: yarn add
  id: cli/add
  summary: Add dependencies to the project
  description: "# yarn add\n\nAdd dependencies to the project.\n\n## Usage\n\n``` language-text\n$> yarn add ...\n```\n\n## Examples\n\nAdd a regular package to the current workspace :\n\n``` language-text\nyarn add lodash\n```\n\nAdd a specific version for a package to the current workspace :\n\n``` language-text\nyarn add lodash@1.2.3\n```\n\nAdd a package from a GitHub repository (the master branch) to the current workspace using a URL :\n\n``` language-text\nyarn add lodash@https://github.com/lodash/lodash\n```\n\nAdd a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol :\n\n``` language-text\nyarn add lodash@github:lodash/lodash\n```\n\nAdd a package from a GitHub repository (the master branch) to the current workspace using the GitHub protocol (shorthand) :\n\n``` language-text\nyarn add lodash@lodash/lodash\n```\n\nAdd a package from a specific branch of a GitHub repository to the current workspace using the GitHub protocol (shorthand) :\n\n``` language-text\nyarn add lodash-es@lodash/lodash#es\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command adds a package to the package.json for the nearest workspace.\n\n- If it didn't exist before, the package will by default be added to the regular `dependencies` field, but this behavior can be overriden thanks to the `-D,--dev` flag (which will cause the dependency to be added to the `devDependencies` field instead) and the `-P,--peer` flag (which will do the same but for `peerDependencies`).\n\n- If the package was already listed in your dependencies, it will by default be upgraded whether it's part of your `dependencies` or `devDependencies` (it won't ever update `peerDependencies`, though).\n\n- If set, the `--prefer-dev` flag will operate as a more flexible `-D,--dev` in that it will add the package to your `devDependencies` if it isn't already listed in either `dependencies` or `devDependencies`, but it will also happily upgrade your `dependencies` if that's what you already use (whereas `-D,--dev` would throw an exception).\n\n- If set, the `-O,--optional` flag will add the package to the `optionalDependencies` field and, in combination with the `-P,--peer` flag, it will add the package as an optional peer dependency. If the package was already listed in your `dependencies`, it will be upgraded to `optionalDependencies`. If the package was already listed in your `peerDependencies`, in combination with the `-P,--peer` flag, it will be upgraded to an optional peer dependency: `\"peerDependenciesMeta\": { \"<package>\": { \"optional\": true } }`\n\n- If the added package doesn't specify a range at all its `latest` tag will be resolved and the returned version will be used to generate a new semver range (using the `^` modifier by default unless otherwise configured via the `defaultSemverRangePrefix` configuration, or the `~` modifier if `-T,--tilde` is specified, or no modifier at all if `-E,--exact` is specified). Two exceptions to this rule: the first one is that if the package is a workspace then its local version will be used, and the second one is that if you use `-P,--peer` the default range will be `*` and won't be resolved at all.\n\n- If the added package specifies a range (such as `^1.0.0`, `latest`, or `rc`), Yarn will add this range as-is in the resulting package.json entry (in particular, tags such as `rc` will be encoded as-is rather than being converted into a semver range).\n\nIf the `--cached` option is used, Yarn will preferably reuse the highest version already used somewhere within the project, even if through a transitive dependency.\n\nIf the `-i,--interactive` option is used (or if the `preferInteractive` settings is toggled on) the command will first try to check whether other workspaces in the project use the specified package and, if so, will offer to reuse them.\n\nIf the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n- `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n- `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\nFor a compilation of all the supported protocols, please consult the dedicated page from our website: [https://yarnpkg.com/features/protocols](../features/protocols).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/add](https://yarnpkg.com/cli/add)"
- name: yarn bin
  id: cli/bin
  summary: Get the path to a binary script
  description: "# yarn bin\n\nGet the path to a binary script.\n\n## Usage\n\n``` language-text\n$> yarn bin [name]\n```\n\n## Examples\n\nList all the available binaries :\n\n``` language-text\nyarn bin\n```\n\nPrint the path to a specific binary :\n\n``` language-text\nyarn bin eslint\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nWhen used without arguments, this command will print the list of all the binaries available in the current workspace. Adding the `-v,--verbose` flag will cause the output to contain both the binary name and the locator of the package that provides the binary.\n\nWhen an argument is specified, this command will just print the path to the binary on the standard output and exit. Note that the reported path may be stored within a zip archive.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/bin](https://yarnpkg.com/cli/bin)"
- name: yarn cache clean
  id: cli/cache/clean
  summary: Remove the shared cache files
  description: "# yarn cache clean\n\nRemove the shared cache files.\n\n## Usage\n\n``` language-text\n$> yarn cache clean\n```\n\n## Examples\n\nRemove all the local archives :\n\n``` language-text\nyarn cache clean\n```\n\nRemove all the archives stored in the ~/.yarn directory :\n\n``` language-text\nyarn cache clean --mirror\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will remove all the files from the cache.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/cache/clean](https://yarnpkg.com/cli/cache/clean)"
- name: yarn config
  id: cli/config
  summary: Display the current configuration
  description: "# yarn config\n\nDisplay the current configuration.\n\n## Usage\n\n``` language-text\n$> yarn config\n```\n\n## Examples\n\nPrint the active configuration settings :\n\n``` language-text\nyarn config\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command prints the current active configuration settings.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/config](https://yarnpkg.com/cli/config)"
- name: yarn config get
  id: cli/config/get
  summary: Read a configuration settings
  description: "# yarn config get\n\nRead a configuration settings.\n\n## Usage\n\n``` language-text\n$> yarn config get <name>\n```\n\n## Examples\n\nPrint a simple configuration setting :\n\n``` language-text\nyarn config get yarnPath\n```\n\nPrint a complex configuration setting :\n\n``` language-text\nyarn config get packageExtensions\n```\n\nPrint a nested field from the configuration :\n\n``` language-text\nyarn config get 'npmScopes[\"my-company\"].npmRegistryServer'\n```\n\nPrint a token from the configuration :\n\n``` language-text\nyarn config get npmAuthToken --no-redacted\n```\n\nPrint a configuration setting as JSON :\n\n``` language-text\nyarn config get packageExtensions --json\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will print a configuration setting.\n\nSecrets (such as tokens) will be redacted from the output by default. If this behavior isn't desired, set the `--no-redacted` to get the untransformed value.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/config/get](https://yarnpkg.com/cli/config/get)"
- name: yarn config set
  id: cli/config/set
  summary: Change a configuration settings
  description: "# yarn config set\n\nChange a configuration settings.\n\n## Usage\n\n``` language-text\n$> yarn config set <name> <value>\n```\n\n## Examples\n\nSet a simple configuration setting (a string, a number, or a boolean) :\n\n``` language-text\nyarn config set initScope myScope\n```\n\nSet a simple configuration setting (a string, a number, or a boolean) using the `--json` flag :\n\n``` language-text\nyarn config set initScope --json \\\"myScope\\\"\n```\n\nSet a complex configuration setting (an Array) using the `--json` flag :\n\n``` language-text\nyarn config set unsafeHttpWhitelist --json '[\"*.example.com\", \"example.com\"]'\n```\n\nSet a complex configuration setting (an Object) using the `--json` flag :\n\n``` language-text\nyarn config set packageExtensions --json '{ \"@babel/parser@*\": { \"dependencies\": { \"@babel/types\": \"*\" } } }'\n```\n\nSet a nested configuration setting :\n\n``` language-text\nyarn config set npmScopes.company.npmRegistryServer \"https://npm.example.com\"\n```\n\nSet a nested configuration setting using indexed access for non-simple keys :\n\n``` language-text\nyarn config set 'npmRegistries[\"//npm.example.com\"].npmAuthToken' \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will set a configuration setting.\n\nWhen used without the `--json` flag, it can only set a simple configuration setting (a string, a number, or a boolean).\n\nWhen used with the `--json` flag, it can set both simple and complex configuration settings, including Arrays and Objects.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/config/set](https://yarnpkg.com/cli/config/set)"
- name: yarn config unset
  id: cli/config/unset
  summary: Unset a configuration setting
  description: "# yarn config unset\n\nUnset a configuration setting.\n\n## Usage\n\n``` language-text\n$> yarn config unset <name>\n```\n\n## Examples\n\nUnset a simple configuration setting :\n\n``` language-text\nyarn config unset initScope\n```\n\nUnset a complex configuration setting :\n\n``` language-text\nyarn config unset packageExtensions\n```\n\nUnset a nested configuration setting :\n\n``` language-text\nyarn config unset npmScopes.company.npmRegistryServer\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will unset a configuration setting.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/config/unset](https://yarnpkg.com/cli/config/unset)"
- name: yarn constraints
  id: cli/constraints
  summary: Check that the project constraints are met
  description: "# yarn constraints\n\n> **Plugin**\n>\n> To use this command, first install the `constraints` plugin: `yarn plugin import constraints`\n\nCheck that the project constraints are met.\n\n## Usage\n\n``` language-text\n$> yarn constraints\n```\n\n## Examples\n\nCheck that all constraints are satisfied :\n\n``` language-text\nyarn constraints\n```\n\nAutofix all unmet constraints :\n\n``` language-text\nyarn constraints --fix\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will run constraints on your project and emit errors for each one that is found but isn't met. If any error is emitted the process will exit with a non-zero exit code.\n\nIf the `--fix` flag is used, Yarn will attempt to automatically fix the issues the best it can, following a multi-pass process (with a maximum of 10 iterations). Some ambiguous patterns cannot be autofixed, in which case you'll have to manually specify the right resolution.\n\nFor more information as to how to write constraints, please consult our dedicated page on our website: [https://yarnpkg.com/features/constraints](../features/constraints).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/constraints](https://yarnpkg.com/cli/constraints)"
- name: yarn constraints query
  id: cli/constraints/query
  summary: Query the constraints fact database
  description: "# yarn constraints query\n\n> **Plugin**\n>\n> To use this command, first install the `constraints` plugin: `yarn plugin import constraints`\n\nQuery the constraints fact database.\n\n## Usage\n\n``` language-text\n$> yarn constraints query <query>\n```\n\n## Examples\n\nList all dependencies throughout the workspace :\n\n``` language-text\nyarn constraints query 'workspace_has_dependency(_, DependencyName, _, _).'\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will output all matches to the given prolog query.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/constraints/query](https://yarnpkg.com/cli/constraints/query)"
- name: yarn constraints source
  id: cli/constraints/source
  summary: Print the source code for the constraints
  description: "# yarn constraints source\n\n> **Plugin**\n>\n> To use this command, first install the `constraints` plugin: `yarn plugin import constraints`\n\nPrint the source code for the constraints.\n\n## Usage\n\n``` language-text\n$> yarn constraints source\n```\n\n## Examples\n\nPrints the source code :\n\n``` language-text\nyarn constraints source\n```\n\nPrint the source code and the fact database :\n\n``` language-text\nyarn constraints source -v\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will print the Prolog source code used by the constraints engine. Adding the `-v,--verbose` flag will print the *full* source code, including the fact database automatically compiled from the workspace manifests.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/constraints/source](https://yarnpkg.com/cli/constraints/source)"
- name: yarn dedupe
  id: cli/dedupe
  summary: Deduplicate dependencies with overlapping ranges
  description: "# yarn dedupe\n\nDeduplicate dependencies with overlapping ranges.\n\n## Usage\n\n``` language-text\n$> yarn dedupe ...\n```\n\n## Examples\n\nDedupe all packages :\n\n``` language-text\nyarn dedupe\n```\n\nDedupe all packages using a specific strategy :\n\n``` language-text\nyarn dedupe --strategy highest\n```\n\nDedupe a specific package :\n\n``` language-text\nyarn dedupe lodash\n```\n\nDedupe all packages with the `@babel/*` scope :\n\n``` language-text\nyarn dedupe '@babel/*'\n```\n\nCheck for duplicates (can be used as a CI step) :\n\n``` language-text\nyarn dedupe --check\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nDuplicates are defined as descriptors with overlapping ranges being resolved and locked to different locators. They are a natural consequence of Yarn's deterministic installs, but they can sometimes pile up and unnecessarily increase the size of your project.\n\nThis command dedupes dependencies in the current project using different strategies (only one is implemented at the moment):\n\n- `highest`: Reuses (where possible) the locators with the highest versions. This means that dependencies can only be upgraded, never downgraded. It's also guaranteed that it never takes more than a single pass to dedupe the entire dependency tree.\n\n**Note:** Even though it never produces a wrong dependency tree, this command should be used with caution, as it modifies the dependency tree, which can sometimes cause problems when packages don't strictly follow semver recommendations. Because of this, it is recommended to also review the changes manually.\n\nIf set, the `-c,--check` flag will only report the found duplicates, without persisting the modified dependency tree. If changes are found, the command will exit with a non-zero exit code, making it suitable for CI purposes.\n\nIf the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n- `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n- `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\nThis command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n### In-depth explanation:\n\nYarn doesn't deduplicate dependencies by default, otherwise installs wouldn't be deterministic and the lockfile would be useless. What it actually does is that it tries to not duplicate dependencies in the first place.\n\n**Example:** If `foo@^2.3.4` (a dependency of a dependency) has already been resolved to `foo@2.3.4`, running `yarn add foo@*`will cause Yarn to reuse `foo@2.3.4`, even if the latest `foo` is actually `foo@2.10.14`, thus preventing unnecessary duplication.\n\nDuplication happens when Yarn can't unlock dependencies that have already been locked inside the lockfile.\n\n**Example:** If `foo@^2.3.4` (a dependency of a dependency) has already been resolved to `foo@2.3.4`, running `yarn add foo@2.10.14` will cause Yarn to install `foo@2.10.14` because the existing resolution doesn't satisfy the range `2.10.14`. This behavior can lead to (sometimes) unwanted duplication, since now the lockfile contains 2 separate resolutions for the 2 `foo` descriptors, even though they have overlapping ranges, which means that the lockfile can be simplified so that both descriptors resolve to `foo@2.10.14`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/dedupe](https://yarnpkg.com/cli/dedupe)"
- name: yarn dlx
  id: cli/dlx
  summary: Run a package in a temporary environment
  description: "# yarn dlx\n\nRun a package in a temporary environment.\n\n## Usage\n\n``` language-text\n$> yarn dlx <command> ...\n```\n\n## Examples\n\nUse create-react-app to create a new React app :\n\n``` language-text\nyarn dlx create-react-app ./my-app\n```\n\nInstall multiple packages for a single command :\n\n``` language-text\nyarn dlx -p typescript -p ts-node ts-node --transpile-only -e \"console.log('hello!')\"\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will install a package within a temporary environment, and run its binary script if it contains any. The binary will run within the current cwd.\n\nBy default Yarn will download the package named `command`, but this can be changed through the use of the `-p,--package` flag which will instruct Yarn to still run the same command but from a different package.\n\nUsing `yarn dlx` as a replacement of `yarn add` isn't recommended, as it makes your project non-deterministic (Yarn doesn't keep track of the packages installed through `dlx` - neither their name, nor their version).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/dlx](https://yarnpkg.com/cli/dlx)"
- name: yarn exec
  id: cli/exec
  summary: Execute a shell script
  description: "# yarn exec\n\nExecute a shell script.\n\n## Usage\n\n``` language-text\n$> yarn exec <commandName> ...\n```\n\n## Examples\n\nExecute a single shell command :\n\n``` language-text\nyarn exec echo Hello World\n```\n\nExecute a shell script :\n\n``` language-text\nyarn exec \"tsc & babel src --out-dir lib\"\n```\n\n## Details\n\nThis command simply executes a shell script within the context of the root directory of the active workspace using the portable shell.\n\nIt also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/exec](https://yarnpkg.com/cli/exec)"
- name: yarn explain peer-requirements
  id: cli/explain/peer-requirements
  summary: Explain a set of peer requirements
  description: "# yarn explain peer-requirements\n\nExplain a set of peer requirements.\n\n## Usage\n\n``` language-text\n$> yarn explain peer-requirements [hash]\n```\n\n## Examples\n\nExplain the corresponding set of peer requirements for a hash :\n\n``` language-text\nyarn explain peer-requirements p1a4ed\n```\n\nList all sets of peer requirements :\n\n``` language-text\nyarn explain peer-requirements\n```\n\n## Details\n\nA set of peer requirements represents all peer requirements that a dependent must satisfy when providing a given peer request to a requester and its descendants.\n\nWhen the hash argument is specified, this command prints a detailed explanation of all requirements of the set corresponding to the hash and whether they're satisfied or not.\n\nWhen used without arguments, this command lists all sets of peer requirements and the corresponding hash that can be used to get detailed information about a given set.\n\n**Note:** A hash is a six-letter p-prefixed code that can be obtained from peer dependency warnings or from the list of all peer requirements (`yarn explain peer-requirements`).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/explain/peer-requirements](https://yarnpkg.com/cli/explain/peer-requirements)"
- name: yarn info
  id: cli/info
  summary: See information related to packages
  description: "# yarn info\n\nSee information related to packages.\n\n## Usage\n\n``` language-text\n$> yarn info ...\n```\n\n## Examples\n\nShow information about Lodash :\n\n``` language-text\nyarn info lodash\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command prints various information related to the specified packages, accepting glob patterns.\n\nBy default, if the locator reference is missing, Yarn will default to print the information about all the matching direct dependencies of the package for the active workspace. To instead print all versions of the package that are direct dependencies of any of your workspaces, use the `-A,--all` flag. Adding the `-R,--recursive` flag will also report transitive dependencies.\n\nSome fields will be hidden by default in order to keep the output readable, but can be selectively displayed by using additional options (`--dependents`, `--manifest`, `--virtuals`, ...) described in the option descriptions.\n\nNote that this command will only print the information directly related to the selected packages - if you wish to know why the package is there in the first place, use `yarn why` which will do just that (it also provides a `-R,--recursive` flag that may be of some help).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/info](https://yarnpkg.com/cli/info)"
- name: yarn init
  id: cli/init
  summary: Create a new package
  description: "# yarn init\n\nCreate a new package.\n\n## Usage\n\n``` language-text\n$> yarn init\n```\n\n## Examples\n\nCreate a new package in the local directory :\n\n``` language-text\nyarn init\n```\n\nCreate a new private package in the local directory :\n\n``` language-text\nyarn init -p\n```\n\nCreate a new package and store the Yarn release inside :\n\n``` language-text\nyarn init -i=latest\n```\n\nCreate a new private package and defines it as a workspace root :\n\n``` language-text\nyarn init -w\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will setup a new package in your local directory.\n\nIf the `-p,--private` or `-w,--workspace` options are set, the package will be private by default.\n\nIf the `-w,--workspace` option is set, the package will be configured to accept a set of workspaces in the `packages/` directory.\n\nIf the `-i,--install` option is given a value, Yarn will first download it using `yarn set version` and only then forward the init call to the newly downloaded bundle. Without arguments, the downloaded bundle will be `latest`.\n\nThe initial settings of the manifest can be changed by using the `initScope` and `initFields` configuration values. Additionally, Yarn will generate an EditorConfig file whose rules can be altered via `initEditorConfig`, and will initialize a Git repository in the current directory.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/init](https://yarnpkg.com/cli/init)"
- name: yarn install
  id: cli/install
  summary: Install the project dependencies
  description: "# yarn install\n\nInstall the project dependencies.\n\n## Usage\n\n``` language-text\n$> yarn install\n```\n\n## Examples\n\nInstall the project :\n\n``` language-text\nyarn install\n```\n\nValidate a project when using Zero-Installs :\n\n``` language-text\nyarn install --immutable --immutable-cache\n```\n\nValidate a project when using Zero-Installs (slightly safer if you accept external PRs) :\n\n``` language-text\nyarn install --immutable --immutable-cache --check-cache\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command sets up your project if needed. The installation is split into four different steps that each have their own characteristics:\n\n- **Resolution:** First the package manager will resolve your dependencies. The exact way a dependency version is privileged over another isn't standardized outside of the regular semver guarantees. If a package doesn't resolve to what you would expect, check that all dependencies are correctly declared (also check our website for more information: ).\n\n- **Fetch:** Then we download all the dependencies if needed, and make sure that they're all stored within our cache (check the value of `cacheFolder` in `yarn config` to see where the cache files are stored).\n\n- **Link:** Then we send the dependency tree information to internal plugins tasked with writing them on the disk in some form (for example by generating the .pnp.cjs file you might know).\n\n- **Build:** Once the dependency tree has been written on the disk, the package manager will now be free to run the build scripts for all packages that might need it, in a topological order compatible with the way they depend on one another. See [https://yarnpkg.com/advanced/lifecycle-scripts](../advanced/lifecycle-scripts) for detail.\n\nNote that running this command is not part of the recommended workflow. Yarn supports zero-installs, which means that as long as you store your cache and your .pnp.cjs file inside your repository, everything will work without requiring any install right after cloning your repository or switching branches.\n\nIf the `--immutable` option is set (defaults to true on CI), Yarn will abort with an error exit code if the lockfile was to be modified (other paths can be added using the `immutablePatterns` configuration setting). For backward compatibility we offer an alias under the name of `--frozen-lockfile`, but it will be removed in a later release.\n\nIf the `--immutable-cache` option is set, Yarn will abort with an error exit code if the cache folder was to be modified (either because files would be added, or because they'd be removed).\n\nIf the `--check-cache` option is set, Yarn will always refetch the packages and will ensure that their checksum matches what's 1/ described in the lockfile 2/ inside the existing cache files (if present). This is recommended as part of your CI workflow if you're both following the Zero-Installs model and accepting PRs from third-parties, as they'd otherwise have the ability to alter the checked-in packages before submitting them.\n\nIf the `--inline-builds` option is set, Yarn will verbosely print the output of the build steps of your dependencies (instead of writing them into individual files). This is likely useful mostly for debug purposes only when using Docker-like environments.\n\nIf the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n- `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n- `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/install](https://yarnpkg.com/cli/install)"
- name: yarn link
  id: cli/link
  summary: Connect the local project to another one
  description: "# yarn link\n\nConnect the local project to another one.\n\n## Usage\n\n``` language-text\n$> yarn link <destination>\n```\n\n## Examples\n\nRegister a remote workspace for use in the current project :\n\n``` language-text\nyarn link ~/ts-loader\n```\n\nRegister all workspaces from a remote project for use in the current project :\n\n``` language-text\nyarn link ~/jest --all\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will set a new `resolutions` field in the project-level manifest and point it to the workspace at the specified location (even if part of another project).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/link](https://yarnpkg.com/cli/link)"
- name: yarn node
  id: cli/node
  summary: Run node with the hook already setup
  description: "# yarn node\n\nRun node with the hook already setup.\n\n## Usage\n\n``` language-text\n$> yarn node ...\n```\n\n## Examples\n\nRun a Node script :\n\n``` language-text\nyarn node ./my-script.js\n```\n\n## Details\n\nThis command simply runs Node. It also makes sure to call it in a way that's compatible with the current project (for example, on PnP projects the environment will be setup in such a way that PnP will be correctly injected into the environment).\n\nThe Node process will use the exact same version of Node as the one used to run Yarn itself, which might be a good way to ensure that your commands always use a consistent Node version.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/node](https://yarnpkg.com/cli/node)"
- name: yarn npm audit
  id: cli/npm/audit
  summary: Perform a vulnerability audit against the installed packages
  description: "# yarn npm audit\n\nPerform a vulnerability audit against the installed packages.\n\n## Usage\n\n``` language-text\n$> yarn npm audit\n```\n\n## Examples\n\nChecks for known security issues with the installed packages. The output is a list of known issues. :\n\n``` language-text\nyarn npm audit\n```\n\nAudit dependencies in all workspaces :\n\n``` language-text\nyarn npm audit --all\n```\n\nLimit auditing to `dependencies` (excludes `devDependencies`) :\n\n``` language-text\nyarn npm audit --environment production\n```\n\nShow audit report as valid JSON :\n\n``` language-text\nyarn npm audit --json\n```\n\nAudit all direct and transitive dependencies :\n\n``` language-text\nyarn npm audit --recursive\n```\n\nOutput moderate (or more severe) vulnerabilities :\n\n``` language-text\nyarn npm audit --severity moderate\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command checks for known security reports on the packages you use. The reports are by default extracted from the npm registry, and may or may not be relevant to your actual program (not all vulnerabilities affect all code paths).\n\nFor consistency with our other commands the default is to only check the direct dependencies for the active workspace. To extend this search to all workspaces, use `-A,--all`. To extend this search to both direct and transitive dependencies, use `-R,--recursive`.\n\nApplying the `--severity` flag will limit the audit table to vulnerabilities of the corresponding severity and above. Valid values are `info`, `low`, `moderate`, `high`, `critical`.\n\nIf the `--json` flag is set, Yarn will print the output exactly as received from the registry. Regardless of this flag, the process will exit with a non-zero exit code if a report is found for the selected packages.\n\nTo understand the dependency tree requiring vulnerable packages, check the raw report with the `--json` flag or use `yarn why <package>` to get more information as to who depends on them.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/audit](https://yarnpkg.com/cli/npm/audit)"
- name: yarn npm info
  id: cli/npm/info
  summary: Show information about a package
  description: "# yarn npm info\n\nShow information about a package.\n\n## Usage\n\n``` language-text\n$> yarn npm info ...\n```\n\n## Examples\n\nShow all available information about react (except the `dist`, `readme`, and `users` fields) :\n\n``` language-text\nyarn npm info react\n```\n\nShow all available information about react as valid JSON (including the `dist`, `readme`, and `users` fields) :\n\n``` language-text\nyarn npm info react --json\n```\n\nShow all available information about react 16.12.0 :\n\n``` language-text\nyarn npm info react@16.12.0\n```\n\nShow the description of react :\n\n``` language-text\nyarn npm info react --fields description\n```\n\nShow all available versions of react :\n\n``` language-text\nyarn npm info react --fields versions\n```\n\nShow the readme of react :\n\n``` language-text\nyarn npm info react --fields readme\n```\n\nShow a few fields of react :\n\n``` language-text\nyarn npm info react --fields homepage,repository\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will fetch information about a package from the npm registry, and prints it in a tree format.\n\nThe package does not have to be installed locally, but needs to have been published (in particular, local changes will be ignored even for workspaces).\n\nAppend `@<range>` to the package argument to provide information specific to the latest version that satisfies the range. If the range is invalid or if there is no version satisfying the range, the command will print a warning and fall back to the latest version.\n\nIf the `-f,--fields` option is set, it's a comma-separated list of fields which will be used to only display part of the package informations.\n\nBy default, this command won't return the `dist`, `readme`, and `users` fields, since they are often very long. To explicitly request those fields, explicitly list them with the `--fields` flag or request the output in JSON mode.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/info](https://yarnpkg.com/cli/npm/info)"
- name: yarn npm login
  id: cli/npm/login
  summary: Store new login info to access the npm registry
  description: "# yarn npm login\n\nStore new login info to access the npm registry.\n\n## Usage\n\n``` language-text\n$> yarn npm login\n```\n\n## Examples\n\nLogin to the default registry :\n\n``` language-text\nyarn npm login\n```\n\nLogin to the registry linked to the @my-scope registry :\n\n``` language-text\nyarn npm login --scope my-scope\n```\n\nLogin to the publish registry for the current package :\n\n``` language-text\nyarn npm login --publish\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will ask you for your username, password, and 2FA One-Time-Password (when it applies). It will then modify your local configuration (in your home folder, never in the project itself) to reference the new tokens thus generated.\n\nAdding the `-s,--scope` flag will cause the authentication to be done against whatever registry is configured for the associated scope (see also `npmScopes`).\n\nAdding the `--publish` flag will cause the authentication to be done against the registry used when publishing the package (see also `publishConfig.registry` and `npmPublishRegistry`).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/login](https://yarnpkg.com/cli/npm/login)"
- name: yarn npm logout
  id: cli/npm/logout
  summary: Logout of the npm registry
  description: "# yarn npm logout\n\nLogout of the npm registry.\n\n## Usage\n\n``` language-text\n$> yarn npm logout\n```\n\n## Examples\n\nLogout of the default registry :\n\n``` language-text\nyarn npm logout\n```\n\nLogout of the @my-scope scope :\n\n``` language-text\nyarn npm logout --scope my-scope\n```\n\nLogout of the publish registry for the current package :\n\n``` language-text\nyarn npm logout --publish\n```\n\nLogout of all registries :\n\n``` language-text\nyarn npm logout --all\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will log you out by modifying your local configuration (in your home folder, never in the project itself) to delete all credentials linked to a registry.\n\nAdding the `-s,--scope` flag will cause the deletion to be done against whatever registry is configured for the associated scope (see also `npmScopes`).\n\nAdding the `--publish` flag will cause the deletion to be done against the registry used when publishing the package (see also `publishConfig.registry` and `npmPublishRegistry`).\n\nAdding the `-A,--all` flag will cause the deletion to be done against all registries and scopes.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/logout](https://yarnpkg.com/cli/npm/logout)"
- name: yarn npm publish
  id: cli/npm/publish
  summary: Publish the active workspace to the npm registry
  description: "# yarn npm publish\n\nPublish the active workspace to the npm registry.\n\n## Usage\n\n``` language-text\n$> yarn npm publish\n```\n\n## Examples\n\nPublish the active workspace :\n\n``` language-text\nyarn npm publish\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will pack the active workspace into a fresh archive and upload it to the npm registry.\n\nThe package will by default be attached to the `latest` tag on the registry, but this behavior can be overriden by using the `--tag` option.\n\nNote that for legacy reasons scoped packages are by default published with an access set to `restricted` (aka \"private packages\"). This requires you to register for a paid npm plan. In case you simply wish to publish a public scoped package to the registry (for free), just add the `--access public` flag. This behavior can be enabled by default through the `npmPublishAccess` settings.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/publish](https://yarnpkg.com/cli/npm/publish)"
- name: yarn npm tag add
  id: cli/npm/tag/add
  summary: Add a tag for a specific version of a package
  description: "# yarn npm tag add\n\nAdd a tag for a specific version of a package.\n\n## Usage\n\n``` language-text\n$> yarn npm tag add <package> <tag>\n```\n\n## Examples\n\nAdd a `beta` tag for version `2.3.4-beta.4` of package `my-pkg` :\n\n``` language-text\nyarn npm tag add my-pkg@2.3.4-beta.4 beta\n```\n\n## Details\n\nThis command will add a tag to the npm registry for a specific version of a package. If the tag already exists, it will be overwritten.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/tag/add](https://yarnpkg.com/cli/npm/tag/add)"
- name: yarn npm tag list
  id: cli/npm/tag/list
  summary: List all dist-tags of a package
  description: "# yarn npm tag list\n\nList all dist-tags of a package.\n\n## Usage\n\n``` language-text\n$> yarn npm tag list [package]\n```\n\n## Examples\n\nList all tags of package `my-pkg` :\n\n``` language-text\nyarn npm tag list my-pkg\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will list all tags of a package from the npm registry.\n\nIf the package is not specified, Yarn will default to the current workspace.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/tag/list](https://yarnpkg.com/cli/npm/tag/list)"
- name: yarn npm tag remove
  id: cli/npm/tag/remove
  summary: Remove a tag from a package
  description: "# yarn npm tag remove\n\nRemove a tag from a package.\n\n## Usage\n\n``` language-text\n$> yarn npm tag remove <package> <tag>\n```\n\n## Examples\n\nRemove the `beta` tag from package `my-pkg` :\n\n``` language-text\nyarn npm tag remove my-pkg beta\n```\n\n## Details\n\nThis command will remove a tag from a package from the npm registry.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/tag/remove](https://yarnpkg.com/cli/npm/tag/remove)"
- name: yarn npm whoami
  id: cli/npm/whoami
  summary: Display the name of the authenticated user
  description: "# yarn npm whoami\n\nDisplay the name of the authenticated user.\n\n## Usage\n\n``` language-text\n$> yarn npm whoami\n```\n\n## Examples\n\nPrint username for the default registry :\n\n``` language-text\nyarn npm whoami\n```\n\nPrint username for the registry on a given scope :\n\n``` language-text\nyarn npm whoami --scope company\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nPrint the username associated with the current authentication settings to the standard output.\n\nWhen using `-s,--scope`, the username printed will be the one that matches the authentication settings of the registry associated with the given scope (those settings can be overriden using the `npmRegistries` map, and the registry associated with the scope is configured via the `npmScopes` map).\n\nWhen using `--publish`, the registry we'll select will by default be the one used when publishing packages (`publishConfig.registry` or `npmPublishRegistry` if available, otherwise we'll fallback to the regular `npmRegistryServer`).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/npm/whoami](https://yarnpkg.com/cli/npm/whoami)"
- name: yarn pack
  id: cli/pack
  summary: Generate a tarball from the active workspace
  description: "# yarn pack\n\nGenerate a tarball from the active workspace.\n\n## Usage\n\n``` language-text\n$> yarn pack\n```\n\n## Examples\n\nCreate an archive from the active workspace :\n\n``` language-text\nyarn pack\n```\n\nList the files that would be made part of the workspace's archive :\n\n``` language-text\nyarn pack --dry-run\n```\n\nName and output the archive in a dedicated folder :\n\n``` language-text\nyarn pack --out /artifacts/%s-%v.tgz\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will turn the active workspace into a compressed archive suitable for publishing. The archive will by default be stored at the root of the workspace (`package.tgz`).\n\nIf the `-o,---out` is set the archive will be created at the specified path. The `%s` and `%v` variables can be used within the path and will be respectively replaced by the package name and version.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/pack](https://yarnpkg.com/cli/pack)"
- name: yarn patch
  id: cli/patch
  summary: Prepare a package for patching
  description: "# yarn patch\n\nPrepare a package for patching.\n\n## Usage\n\n``` language-text\n$> yarn patch <package>\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will cause a package to be extracted in a temporary directory intended to be editable at will.\n\nOnce you're done with your changes, run `yarn patch-commit -s <path>` (with `<path>` being the temporary directory you received) to generate a patchfile and register it into your top-level manifest via the `patch:` protocol. Run `yarn patch-commit -h` for more details.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/patch](https://yarnpkg.com/cli/patch)"
- name: yarn patch-commit
  id: cli/patch-commit
  summary: Generate a patch out of a directory
  description: "# yarn patch-commit\n\nGenerate a patch out of a directory.\n\n## Usage\n\n``` language-text\n$> yarn patch-commit <patchFolder>\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nBy default, this will print a patchfile on stdout based on the diff between the folder passed in and the original version of the package. Such file is suitable for consumption with the `patch:` protocol.\n\nWith the `-s,--save` option set, the patchfile won't be printed on stdout anymore and will instead be stored within a local file (by default kept within `.yarn/patches`, but configurable via the `patchFolder` setting). A `resolutions` entry will also be added to your top-level manifest, referencing the patched package via the `patch:` protocol.\n\nNote that only folders generated by `yarn patch` are accepted as valid input for `yarn patch-commit`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/patch-commit](https://yarnpkg.com/cli/patch-commit)"
- name: yarn plugin import
  id: cli/plugin/import
  summary: Download a plugin
  description: "# yarn plugin import\n\nDownload a plugin.\n\n## Usage\n\n``` language-text\n$> yarn plugin import <name>\n```\n\n## Examples\n\nDownload and activate the \"@yarnpkg/plugin-exec\" plugin :\n\n``` language-text\nyarn plugin import @yarnpkg/plugin-exec\n```\n\nDownload and activate the \"@yarnpkg/plugin-exec\" plugin (shorthand) :\n\n``` language-text\nyarn plugin import exec\n```\n\nDownload and activate a community plugin :\n\n``` language-text\nyarn plugin import https://example.org/path/to/plugin.js\n```\n\nActivate a local plugin :\n\n``` language-text\nyarn plugin import ./path/to/plugin.js\n```\n\n## Details\n\nThis command downloads the specified plugin from its remote location and updates the configuration to reference it in further CLI invocations.\n\nThree types of plugin references are accepted:\n\n- If the plugin is stored within the Yarn repository, it can be referenced by name.\n\n- Third-party plugins can be referenced directly through their public urls.\n\n- Local plugins can be referenced by their path on the disk.\n\nPlugins cannot be downloaded from the npm registry, and aren't allowed to have dependencies (they need to be bundled into a single file, possibly thanks to the `@yarnpkg/builder` package).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/plugin/import](https://yarnpkg.com/cli/plugin/import)"
- name: yarn plugin import from sources
  id: cli/plugin/import/from/sources
  summary: Build a plugin from sources
  description: "# yarn plugin import from sources\n\nBuild a plugin from sources.\n\n## Usage\n\n``` language-text\n$> yarn plugin import from sources <name>\n```\n\n## Examples\n\nBuild and activate the \"@yarnpkg/plugin-exec\" plugin :\n\n``` language-text\nyarn plugin import from sources @yarnpkg/plugin-exec\n```\n\nBuild and activate the \"@yarnpkg/plugin-exec\" plugin (shorthand) :\n\n``` language-text\nyarn plugin import from sources exec\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command clones the Yarn repository into a temporary folder, builds the specified contrib plugin and updates the configuration to reference it in further CLI invocations.\n\nThe plugins can be referenced by their short name if sourced from the official Yarn repository.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/plugin/import/from/sources](https://yarnpkg.com/cli/plugin/import/from/sources)"
- name: yarn plugin list
  id: cli/plugin/list
  summary: List the available official plugins
  description: "# yarn plugin list\n\nList the available official plugins.\n\n## Usage\n\n``` language-text\n$> yarn plugin list\n```\n\n## Examples\n\nList the official plugins :\n\n``` language-text\nyarn plugin list\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command prints the plugins available directly from the Yarn repository. Only those plugins can be referenced by name in `yarn plugin import`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/plugin/list](https://yarnpkg.com/cli/plugin/list)"
- name: yarn plugin remove
  id: cli/plugin/remove
  summary: Remove a plugin
  description: "# yarn plugin remove\n\nRemove a plugin.\n\n## Usage\n\n``` language-text\n$> yarn plugin remove <name>\n```\n\n## Examples\n\nRemove a plugin imported from the Yarn repository :\n\n``` language-text\nyarn plugin remove @yarnpkg/plugin-typescript\n```\n\nRemove a plugin imported from a local file :\n\n``` language-text\nyarn plugin remove my-local-plugin\n```\n\n## Details\n\nThis command deletes the specified plugin from the .yarn/plugins folder and removes it from the configuration.\n\n**Note:** The plugins have to be referenced by their name property, which can be obtained using the `yarn plugin runtime` command. Shorthands are not allowed.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/plugin/remove](https://yarnpkg.com/cli/plugin/remove)"
- name: yarn plugin runtime
  id: cli/plugin/runtime
  summary: List the active plugins
  description: "# yarn plugin runtime\n\nList the active plugins.\n\n## Usage\n\n``` language-text\n$> yarn plugin runtime\n```\n\n## Examples\n\nList the currently active plugins :\n\n``` language-text\nyarn plugin runtime\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command prints the currently active plugins. Will be displayed both builtin plugins and external plugins.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/plugin/runtime](https://yarnpkg.com/cli/plugin/runtime)"
- name: yarn rebuild
  id: cli/rebuild
  summary: Rebuild the project's native packages
  description: "# yarn rebuild\n\nRebuild the project's native packages.\n\n## Usage\n\n``` language-text\n$> yarn rebuild ...\n```\n\n## Examples\n\nRebuild all packages :\n\n``` language-text\nyarn rebuild\n```\n\nRebuild fsevents only :\n\n``` language-text\nyarn rebuild fsevents\n```\n\n## Details\n\nThis command will automatically cause Yarn to forget about previous compilations of the given packages and to run them again.\n\nNote that while Yarn forgets the compilation, the previous artifacts aren't erased from the filesystem and may affect the next builds (in good or bad). To avoid this, you may remove the .yarn/unplugged folder, or any other relevant location where packages might have been stored (Yarn may offer a way to do that automatically in the future).\n\nBy default all packages will be rebuilt, but you can filter the list by specifying the names of the packages you want to clear from memory.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/rebuild](https://yarnpkg.com/cli/rebuild)"
- name: yarn remove
  id: cli/remove
  summary: Remove dependencies from the project
  description: "# yarn remove\n\nRemove dependencies from the project.\n\n## Usage\n\n``` language-text\n$> yarn remove ...\n```\n\n## Examples\n\nRemove a dependency from the current project :\n\n``` language-text\nyarn remove lodash\n```\n\nRemove a dependency from all workspaces at once :\n\n``` language-text\nyarn remove lodash --all\n```\n\nRemove all dependencies starting with `eslint-` :\n\n``` language-text\nyarn remove 'eslint-*'\n```\n\nRemove all dependencies with the `@babel` scope :\n\n``` language-text\nyarn remove '@babel/*'\n```\n\nRemove all dependencies matching `react-dom` or `react-helmet` :\n\n``` language-text\nyarn remove 'react-{dom,helmet}'\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will remove the packages matching the specified patterns from the current workspace.\n\nIf the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n- `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n- `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\nThis command accepts glob patterns as arguments (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/remove](https://yarnpkg.com/cli/remove)"
- name: yarn run
  id: cli/run
  summary: Run a script defined in the package.json
  description: "# yarn run\n\nRun a script defined in the package.json.\n\n## Usage\n\n``` language-text\n$> yarn run <scriptName> ...\n```\n\n## Examples\n\nRun the tests from the local workspace :\n\n``` language-text\nyarn run test\n```\n\nSame thing, but without the \"run\" keyword :\n\n``` language-text\nyarn test\n```\n\nInspect Webpack while running :\n\n``` language-text\nyarn run --inspect-brk webpack\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will run a tool. The exact tool that will be executed will depend on the current state of your workspace:\n\n- If the `scripts` field from your local package.json contains a matching script name, its definition will get executed.\n\n- Otherwise, if one of the local workspace's dependencies exposes a binary with a matching name, this binary will get executed.\n\n- Otherwise, if the specified name contains a colon character and if one of the workspaces in the project contains exactly one script with a matching name, then this script will get executed.\n\nWhatever happens, the cwd of the spawned process will be the workspace that declares the script (which makes it possible to call commands cross-workspaces using the third syntax).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/run](https://yarnpkg.com/cli/run)"
- name: yarn search
  id: cli/search
  summary: Open the search interface
  description: "# yarn search\n\n> **Plugin**\n>\n> To use this command, first install the `interactive-tools` plugin: `yarn plugin import interactive-tools`\n\nOpen the search interface.\n\n## Usage\n\n``` language-text\n$> yarn search\n```\n\n## Examples\n\nOpen the search window :\n\n``` language-text\nyarn search\n```\n\n## Details\n\nThis command opens a fullscreen terminal interface where you can search for and install packages from the npm registry.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/search](https://yarnpkg.com/cli/search)"
- name: yarn set resolution
  id: cli/set/resolution
  summary: Enforce a package resolution
  description: "# yarn set resolution\n\nEnforce a package resolution.\n\n## Usage\n\n``` language-text\n$> yarn set resolution <descriptor> <resolution>\n```\n\n## Examples\n\nForce all instances of lodash@npm:^1.2.3 to resolve to 1.5.0 :\n\n``` language-text\nyarn set resolution lodash@npm:^1.2.3 1.5.0\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command updates the resolution table so that `descriptor` is resolved by `resolution`.\n\nNote that by default this command only affect the current resolution table - meaning that this \"manual override\" will disappear if you remove the lockfile, or if the package disappear from the table. If you wish to make the enforced resolution persist whatever happens, add the `-s,--save` flag which will also edit the `resolutions` field from your top-level manifest.\n\nNote that no attempt is made at validating that `resolution` is a valid resolution entry for `descriptor`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/set/resolution](https://yarnpkg.com/cli/set/resolution)"
- name: yarn set version
  id: cli/set/version
  summary: Lock the Yarn version used by the project
  description: "# yarn set version\n\nLock the Yarn version used by the project.\n\n## Usage\n\n``` language-text\n$> yarn set version <version>\n```\n\n## Examples\n\nDownload the latest release from the Yarn repository :\n\n``` language-text\nyarn set version latest\n```\n\nDownload the latest canary release from the Yarn repository :\n\n``` language-text\nyarn set version canary\n```\n\nDownload the latest classic release from the Yarn repository :\n\n``` language-text\nyarn set version classic\n```\n\nDownload the most recent Yarn 3 build :\n\n``` language-text\nyarn set version 3.x\n```\n\nDownload a specific Yarn 2 build :\n\n``` language-text\nyarn set version 2.0.0-rc.30\n```\n\nSwitch back to a specific Yarn 1 release :\n\n``` language-text\nyarn set version 1.22.1\n```\n\nUse a release from the local filesystem :\n\n``` language-text\nyarn set version ./yarn.cjs\n```\n\nDownload the version used to invoke the command :\n\n``` language-text\nyarn set version self\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will download a specific release of Yarn directly from the Yarn GitHub repository, will store it inside your project, and will change the `yarnPath` settings from your project `.yarnrc.yml` file to point to the new file.\n\nA very good use case for this command is to enforce the version of Yarn used by the any single member of your team inside a same project - by doing this you ensure that you have control on Yarn upgrades and downgrades (including on your deployment servers), and get rid of most of the headaches related to someone using a slightly different version and getting a different behavior than you.\n\nThe version specifier can be:\n\n- a tag:\n\n  - `latest` / `berry` / `stable` -\\> the most recent stable berry (`>=2.0.0`) release\n\n  - `canary` -\\> the most recent canary (release candidate) berry (`>=2.0.0`) release\n\n  - `classic` -\\> the most recent classic (`^0.x || ^1.x`) release\n\n- a semver range (e.g. `2.x`) -\\> the most recent version satisfying the range (limited to berry releases)\n\n- a semver version (e.g. `2.4.1`, `1.22.1`)\n\n- a local file referenced through either a relative or absolute path\n\n- `self` -\\> the version used to invoke the command\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/set/version](https://yarnpkg.com/cli/set/version)"
- name: yarn set version from sources
  id: cli/set/version/from/sources
  summary: Build Yarn from master
  description: "# yarn set version from sources\n\nBuild Yarn from master.\n\n## Usage\n\n``` language-text\n$> yarn set version from sources\n```\n\n## Examples\n\nBuild Yarn from master :\n\n``` language-text\nyarn set version from sources\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will clone the Yarn repository into a temporary folder, then build it. The resulting bundle will then be copied into the local project.\n\nBy default, it also updates all contrib plugins to the same commit the bundle is built from. This behavior can be disabled by using the `--skip-plugins` flag.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/set/version/from/sources](https://yarnpkg.com/cli/set/version/from/sources)"
- name: yarn stage
  id: cli/stage
  summary: Add all yarn files to your vcs
  description: "# yarn stage\n\n> **Plugin**\n>\n> To use this command, first install the `stage` plugin: `yarn plugin import stage`\n\nAdd all yarn files to your vcs.\n\n## Usage\n\n``` language-text\n$> yarn stage\n```\n\n## Examples\n\nAdds all modified project files to the staging area :\n\n``` language-text\nyarn stage\n```\n\nCreates a new commit containing all modified project files :\n\n``` language-text\nyarn stage --commit\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will add to your staging area the files belonging to Yarn (typically any modified `package.json` and `.yarnrc.yml` files, but also linker-generated files, cache data, etc). It will take your ignore list into account, so the cache files won't be added if the cache is ignored in a `.gitignore` file (assuming you use Git).\n\nRunning `--reset` will instead remove them from the staging area (the changes will still be there, but won't be committed until you stage them back).\n\nSince the staging area is a non-existent concept in Mercurial, Yarn will always create a new commit when running this command on Mercurial repositories. You can get this behavior when using Git by using the `--commit` flag which will directly create a commit.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/stage](https://yarnpkg.com/cli/stage)"
- name: yarn unlink
  id: cli/unlink
  summary: Disconnect the local project from another one
  description: "# yarn unlink\n\nDisconnect the local project from another one.\n\n## Usage\n\n``` language-text\n$> yarn unlink ...\n```\n\n## Examples\n\nUnregister a remote workspace in the current project :\n\n``` language-text\nyarn unlink ~/ts-loader\n```\n\nUnregister all workspaces from a remote project in the current project :\n\n``` language-text\nyarn unlink ~/jest --all\n```\n\nUnregister all previously linked workspaces :\n\n``` language-text\nyarn unlink --all\n```\n\nUnregister all workspaces matching a glob :\n\n``` language-text\nyarn unlink '@babel/*' 'pkg-{a,b}'\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will remove any resolutions in the project-level manifest that would have been added via a yarn link with similar arguments.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/unlink](https://yarnpkg.com/cli/unlink)"
- name: yarn unplug
  id: cli/unplug
  summary: Force the unpacking of a list of packages
  description: "# yarn unplug\n\nForce the unpacking of a list of packages.\n\n## Usage\n\n``` language-text\n$> yarn unplug ...\n```\n\n## Examples\n\nUnplug the lodash dependency from the active workspace :\n\n``` language-text\nyarn unplug lodash\n```\n\nUnplug all instances of lodash referenced by any workspace :\n\n``` language-text\nyarn unplug lodash -A\n```\n\nUnplug all instances of lodash referenced by the active workspace and its dependencies :\n\n``` language-text\nyarn unplug lodash -R\n```\n\nUnplug all instances of lodash, anywhere :\n\n``` language-text\nyarn unplug lodash -AR\n```\n\nUnplug one specific version of lodash :\n\n``` language-text\nyarn unplug lodash@1.2.3\n```\n\nUnplug all packages with the `@babel` scope :\n\n``` language-text\nyarn unplug '@babel/*'\n```\n\nUnplug all packages (only for testing, not recommended) :\n\n``` language-text\nyarn unplug -R '*'\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will add the selectors matching the specified patterns to the list of packages that must be unplugged when installed.\n\nA package being unplugged means that instead of being referenced directly through its archive, it will be unpacked at install time in the directory configured via `pnpUnpluggedFolder`. Note that unpacking packages this way is generally not recommended because it'll make it harder to store your packages within the repository. However, it's a good approach to quickly and safely debug some packages, and can even sometimes be required depending on the context (for example when the package contains shellscripts).\n\nRunning the command will set a persistent flag inside your top-level `package.json`, in the `dependenciesMeta` field. As such, to undo its effects, you'll need to revert the changes made to the manifest and run `yarn install` to apply the modification.\n\nBy default, only direct dependencies from the current workspace are affected. If `-A,--all` is set, direct dependencies from the entire project are affected. Using the `-R,--recursive` flag will affect transitive dependencies as well as direct ones.\n\nThis command accepts glob patterns inside the scope and name components (not the range). Make sure to escape the patterns to prevent your own shell from trying to expand them.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/unplug](https://yarnpkg.com/cli/unplug)"
- name: yarn up
  id: cli/up
  summary: Upgrade dependencies across the project
  description: "# yarn up\n\nUpgrade dependencies across the project.\n\n## Usage\n\n``` language-text\n$> yarn up ...\n```\n\n## Examples\n\nUpgrade all instances of lodash to the latest release :\n\n``` language-text\nyarn up lodash\n```\n\nUpgrade all instances of lodash to the latest release, but ask confirmation for each :\n\n``` language-text\nyarn up lodash -i\n```\n\nUpgrade all instances of lodash to 1.2.3 :\n\n``` language-text\nyarn up lodash@1.2.3\n```\n\nUpgrade all instances of packages with the `@babel` scope to the latest release :\n\n``` language-text\nyarn up '@babel/*'\n```\n\nUpgrade all instances of packages containing the word `jest` to the latest release :\n\n``` language-text\nyarn up '*jest*'\n```\n\nUpgrade all instances of packages with the `@babel` scope to 7.0.0 :\n\n``` language-text\nyarn up '@babel/*@7.0.0'\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command upgrades the packages matching the list of specified patterns to their latest available version across the whole project (regardless of whether they're part of `dependencies` or `devDependencies` - `peerDependencies` won't be affected). This is a project-wide command: all workspaces will be upgraded in the process.\n\nIf `-R,--recursive` is set the command will change behavior and no other switch will be allowed. When operating under this mode `yarn up` will force all ranges matching the selected packages to be resolved again (often to the highest available versions) before being stored in the lockfile. It however won't touch your manifests anymore, so depending on your needs you might want to run both `yarn up` and `yarn up -R` to cover all bases.\n\nIf `-i,--interactive` is set (or if the `preferInteractive` settings is toggled on) the command will offer various choices, depending on the detected upgrade paths. Some upgrades require this flag in order to resolve ambiguities.\n\nThe, `-C,--caret`, `-E,--exact` and `-T,--tilde` options have the same meaning as in the `add` command (they change the modifier used when the range is missing or a tag, and are ignored when the range is explicitly set).\n\nIf the `--mode=<mode>` option is set, Yarn will change which artifacts are generated. The modes currently supported are:\n\n- `skip-build` will not run the build scripts at all. Note that this is different from setting `enableScripts` to false because the later will disable build scripts, and thus affect the content of the artifacts generated on disk, whereas the former will just disable the build step - but not the scripts themselves, which just won't run.\n\n- `update-lockfile` will skip the link step altogether, and only fetch packages that are missing from the lockfile (or that have no associated checksums). This mode is typically used by tools like Renovate or Dependabot to keep a lockfile up-to-date without incurring the full install cost.\n\nGenerally you can see `yarn up` as a counterpart to what was `yarn upgrade --latest` in Yarn 1 (ie it ignores the ranges previously listed in your manifests), but unlike `yarn upgrade` which only upgraded dependencies in the current workspace, `yarn up` will upgrade all workspaces at the same time.\n\nThis command accepts glob patterns as arguments (if valid Descriptors and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n**Note:** The ranges have to be static, only the package scopes and names can contain glob patterns.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/up](https://yarnpkg.com/cli/up)"
- name: yarn upgrade-interactive
  id: cli/upgrade-interactive
  summary: Open the upgrade interface
  description: "# yarn upgrade-interactive\n\n> **Plugin**\n>\n> To use this command, first install the `interactive-tools` plugin: `yarn plugin import interactive-tools`\n\nOpen the upgrade interface.\n\n## Usage\n\n``` language-text\n$> yarn upgrade-interactive\n```\n\n## Examples\n\nOpen the upgrade window :\n\n``` language-text\nyarn upgrade-interactive\n```\n\n## Details\n\nThis command opens a fullscreen terminal interface where you can see any out of date packages used by your application, their status compared to the latest versions available on the remote registry, and select packages to upgrade.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/upgrade-interactive](https://yarnpkg.com/cli/upgrade-interactive)"
- name: yarn version
  id: cli/version
  summary: Apply a new version to the current package
  description: "# yarn version\n\n> **Plugin**\n>\n> To use this command, first install the `version` plugin: `yarn plugin import version`\n\nApply a new version to the current package.\n\n## Usage\n\n``` language-text\n$> yarn version <strategy>\n```\n\n## Examples\n\nImmediately bump the version to the next major :\n\n``` language-text\nyarn version major\n```\n\nPrepare the version to be bumped to the next major :\n\n``` language-text\nyarn version major --deferred\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will bump the version number for the given package, following the specified strategy:\n\n- If `major`, the first number from the semver range will be increased (`X.0.0`).\n\n- If `minor`, the second number from the semver range will be increased (`0.X.0`).\n\n- If `patch`, the third number from the semver range will be increased (`0.0.X`).\n\n- If prefixed by `pre` (`premajor`, ...), a `-0` suffix will be set (`0.0.0-0`).\n\n- If `prerelease`, the suffix will be increased (`0.0.0-X`); the third number from the semver range will also be increased if there was no suffix in the previous version.\n\n- If `decline`, the nonce will be increased for `yarn version check` to pass without version bump.\n\n- If a valid semver range, it will be used as new version.\n\n- If unspecified, Yarn will ask you for guidance.\n\nFor more information about the `--deferred` flag, consult our documentation ([https://yarnpkg.com/features/release-workflow#deferred-versioning](../features/release-workflow#deferred-versioning)).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/version](https://yarnpkg.com/cli/version)"
- name: yarn version apply
  id: cli/version/apply
  summary: Apply all the deferred version bumps at once
  description: "# yarn version apply\n\n> **Plugin**\n>\n> To use this command, first install the `version` plugin: `yarn plugin import version`\n\nApply all the deferred version bumps at once.\n\n## Usage\n\n``` language-text\n$> yarn version apply\n```\n\n## Examples\n\nApply the version change to the local workspace :\n\n``` language-text\nyarn version apply\n```\n\nApply the version change to all the workspaces in the local workspace :\n\n``` language-text\nyarn version apply --all\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will apply the deferred version changes and remove their definitions from the repository.\n\nNote that if `--prerelease` is set, the given prerelease identifier (by default `rc.%d`) will be used on all new versions and the version definitions will be kept as-is.\n\nBy default only the current workspace will be bumped, but you can configure this behavior by using one of:\n\n- `--recursive` to also apply the version bump on its dependencies\n\n- `--all` to apply the version bump on all packages in the repository\n\nNote that this command will also update the `workspace:` references across all your local workspaces, thus ensuring that they keep referring to the same workspaces even after the version bump.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/version/apply](https://yarnpkg.com/cli/version/apply)"
- name: yarn version check
  id: cli/version/check
  summary: Check that all the relevant packages have been bumped
  description: "# yarn version check\n\n> **Plugin**\n>\n> To use this command, first install the `version` plugin: `yarn plugin import version`\n\nCheck that all the relevant packages have been bumped.\n\n## Usage\n\n``` language-text\n$> yarn version check\n```\n\n## Examples\n\nCheck whether the modified packages need a bump :\n\n``` language-text\nyarn version check\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\n**Warning:** This command currently requires Git.\n\nThis command will check that all the packages covered by the files listed in argument have been properly bumped or declined to bump.\n\nIn the case of a bump, the check will also cover transitive packages - meaning that should `Foo` be bumped, a package `Bar` depending on `Foo` will require a decision as to whether `Bar` will need to be bumped. This check doesn't cross packages that have declined to bump.\n\nIn case no arguments are passed to the function, the list of modified files will be generated by comparing the HEAD against `master`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/version/check](https://yarnpkg.com/cli/version/check)"
- name: yarn why
  id: cli/why
  summary: Display the reason why a package is needed
  description: "# yarn why\n\nDisplay the reason why a package is needed.\n\n## Usage\n\n``` language-text\n$> yarn why <package>\n```\n\n## Examples\n\nExplain why lodash is used in your project :\n\n``` language-text\nyarn why lodash\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command prints the exact reasons why a package appears in the dependency tree.\n\nIf `-R,--recursive` is set, the listing will go in depth and will list, for each workspaces, what are all the paths that lead to the dependency. Note that the display is somewhat optimized in that it will not print the package listing twice for a single package, so if you see a leaf named \"Foo\" when looking for \"Bar\", it means that \"Foo\" already got printed higher in the tree.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/why](https://yarnpkg.com/cli/why)"
- name: yarn workspace
  id: cli/workspace
  summary: Run a command within the specified workspace
  description: "# yarn workspace\n\nRun a command within the specified workspace.\n\n## Usage\n\n``` language-text\n$> yarn workspace <workspaceName> <commandName> ...\n```\n\n## Examples\n\nAdd a package to a single workspace :\n\n``` language-text\nyarn workspace components add -D react\n```\n\nRun build script on a single workspace :\n\n``` language-text\nyarn workspace components run build\n```\n\n## Details\n\nThis command will run a given sub-command on a single workspace.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/workspace](https://yarnpkg.com/cli/workspace)"
- name: yarn workspaces focus
  id: cli/workspaces/focus
  summary: Install a single workspace and its dependencies
  description: "# yarn workspaces focus\n\n> **Plugin**\n>\n> To use this command, first install the `workspace-tools` plugin: `yarn plugin import workspace-tools`\n\nInstall a single workspace and its dependencies.\n\n## Usage\n\n``` language-text\n$> yarn workspaces focus ...\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will run an install as if the specified workspaces (and all other workspaces they depend on) were the only ones in the project. If no workspaces are explicitly listed, the active one will be assumed.\n\nNote that this command is only very moderately useful when using zero-installs, since the cache will contain all the packages anyway - meaning that the only difference between a full install and a focused install would just be a few extra lines in the `.pnp.cjs` file, at the cost of introducing an extra complexity.\n\nIf the `-A,--all` flag is set, the entire project will be installed. Combine with `--production` to replicate the old `yarn install --production`.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/workspaces/focus](https://yarnpkg.com/cli/workspaces/focus)"
- name: yarn workspaces foreach
  id: cli/workspaces/foreach
  summary: Run a command on all workspaces
  description: "# yarn workspaces foreach\n\n> **Plugin**\n>\n> To use this command, first install the `workspace-tools` plugin: `yarn plugin import workspace-tools`\n\nRun a command on all workspaces.\n\n## Usage\n\n``` language-text\n$> yarn workspaces foreach <commandName> ...\n```\n\n## Examples\n\nPublish current and all descendant packages :\n\n``` language-text\nyarn workspaces foreach npm publish --tolerate-republish\n```\n\nRun build script on current and all descendant packages :\n\n``` language-text\nyarn workspaces foreach run build\n```\n\nRun build script on current and all descendant packages in parallel, building package dependencies first :\n\n``` language-text\nyarn workspaces foreach -pt run build\n```\n\nRun build script on several packages and all their dependencies, building dependencies first :\n\n``` language-text\nyarn workspaces foreach -ptR --from '{workspace-a,workspace-b}' run build\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will run a given sub-command on current and all its descendant workspaces. Various flags can alter the exact behavior of the command:\n\n- If `-p,--parallel` is set, the commands will be ran in parallel; they'll by default be limited to a number of parallel tasks roughly equal to half your core number, but that can be overridden via `-j,--jobs`, or disabled by setting `-j unlimited`.\n\n- If `-p,--parallel` and `-i,--interlaced` are both set, Yarn will print the lines from the output as it receives them. If `-i,--interlaced` wasn't set, it would instead buffer the output from each process and print the resulting buffers only after their source processes have exited.\n\n- If `-t,--topological` is set, Yarn will only run the command after all workspaces that it depends on through the `dependencies` field have successfully finished executing. If `--topological-dev` is set, both the `dependencies` and `devDependencies` fields will be considered when figuring out the wait points.\n\n- If `-A,--all` is set, Yarn will run the command on all the workspaces of a project. By default yarn runs the command only on current and all its descendant workspaces.\n\n- If `-R,--recursive` is set, Yarn will find workspaces to run the command on by recursively evaluating `dependencies` and `devDependencies` fields, instead of looking at the `workspaces` fields.\n\n- If `--from` is set, Yarn will use the packages matching the 'from' glob as the starting point for any recursive search.\n\n- If `--since` is set, Yarn will only run the command on workspaces that have been modified since the specified ref. By default Yarn will use the refs specified by the `changesetBaseRefs` configuration option.\n\n- The command may apply to only some workspaces through the use of `--include` which acts as a whitelist. The `--exclude` flag will do the opposite and will be a list of packages that mustn't execute the script. Both flags accept glob patterns (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\nAdding the `-v,--verbose` flag will cause Yarn to print more information; in particular the name of the workspace that generated the output will be printed at the front of each line.\n\nIf the command is `run` and the script being run does not exist the child workspace will be skipped without error.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/workspaces/foreach](https://yarnpkg.com/cli/workspaces/foreach)"
- name: yarn workspaces list
  id: cli/workspaces/list
  summary: List all available workspaces
  description: "# yarn workspaces list\n\nList all available workspaces.\n\n## Usage\n\n``` language-text\n$> yarn workspaces list\n```\n\n## Options\n\n[TABLE]\n\n## Details\n\nThis command will print the list of all workspaces in the project.\n\n- If `--since` is set, Yarn will only list workspaces that have been modified since the specified ref. By default Yarn will use the refs specified by the `changesetBaseRefs` configuration option.\n\n- If `-R,--recursive` is set, Yarn will find workspaces to run the command on by recursively evaluating `dependencies` and `devDependencies` fields, instead of looking at the `workspaces` fields.\n\n- If both the `-v,--verbose` and `--json` options are set, Yarn will also return the cross-dependencies between each workspaces (useful when you wish to automatically generate Buck / Bazel rules).\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/cli/workspaces/list](https://yarnpkg.com/cli/workspaces/list)"
- name: Yarnrc files (.yarnrc.yml)
  id: configuration/yarnrc
  summary: Yarnrc files (named this way because they must be called .yarnrc.yml) are the one place where you'll be able to configure Yarn's internal settings
  description: "# Yarnrc files (.yarnrc.yml)\n\nYarnrc files (named this way because they must be called `.yarnrc.yml`) are the one place where you'll be able to configure Yarn's internal settings. While Yarn will automatically find them in the parent directories, they should usually be kept at the root of your project (often your repository). **Starting from the v2, they must be written in valid Yaml and have the right extension** (simply calling your file `.yarnrc` won't do).\n\nEnvironment variables can be accessed from setting definitions by using the `${NAME}` syntax when defining the values. By default Yarn will require the variables to be present, but this can be turned off by using either `${NAME-fallback}` (which will return `fallback` if `NAME` isn't set) or `${NAME:-fallback}` (which will return `fallback` if `NAME` isn't set, or is an empty string).\n\nFinally, note that most settings can also be defined through environment variables (at least for the simpler ones; arrays and objects aren't supported yet). To do this, just prefix the names and write them in snake case: `YARN_CACHE_FOLDER` will set the cache folder (such values will overwrite any that might have been defined in the RC files - use them sparingly).\n\n## cacheFolder\n\nThe path where the downloaded packages are stored on your system. They'll be normalized, compressed, and saved under the form of zip archives with standardized names. The cache is deemed to be relatively safe to be shared by multiple projects, even when multiple Yarn instances run at the same time on different projects. For setting a global cache folder, you should use `enableGlobalCache` instead.\n\ncacheFolder: \"./.yarn/cache\"\n\n## caFilePath\n\nPath to file containing one or multiple Certificate Authority signing certificates\n\ncaFilePath: \"./exampleCA.pem\"\n\n## changesetBaseRefs\n\nThe base git refs that the current HEAD is compared against in the version plugin. This overrides the default behavior of comparing against master, origin/master, upstream/master, main, origin/main, and upstream/main. Supports git branches, tags, and commits.\n\nchangesetBaseRefs:\n\n\\-\n\n\"master\"\n\n\\-\n\n\"origin/master\"\n\n\\-\n\n\"upstream/master\"\n\n\\-\n\n\"main\"\n\n\\-\n\n\"origin/main\"\n\n\\-\n\n\"upstream/main\"\n\n## changesetIgnorePatterns\n\nAn Array of glob patterns. Files matching the following patterns (in terms of relative paths compared to the root of the project) will be ignored by the `yarn version check` command.\n\nchangesetIgnorePatterns:\n\n\\-\n\n\"\\*\\*/\\*.test.{js,ts}\"\n\n## checksumBehavior\n\nIf `throw` (the default), Yarn will throw an exception on `yarn install` if it detects that a package doesn't match the checksum stored within the lockfile. If `update`, the lockfile checksum will be updated to match the new value. If `ignore`, the checksum check will not happen.\n\nchecksumBehavior: \"throw\"\n\n## compressionLevel\n\nThe compression level employed for zip archives, with 0 being 'no compression, faster' and 9 being 'heavy compression, slower'. The default is 'mixed', which is a variant of 9 where files may be stored uncompressed if the builtin libzip heuristic thinks it will lead to a more sensible result.\n\ncompressionLevel: \"mixed\"\n\n## constraintsPath\n\nThe path of the constraints file.\n\nconstraintsPath: \"./constraints.pro\"\n\n## defaultLanguageName\n\nDefault language mode that should be used when a package doesn't offer any insight.\n\ndefaultLanguageName: \"node\"\n\n## defaultProtocol\n\nYarn is a modular package manager that can resolve packages from various sources. As such, semver ranges and tag names don't only work with the npm registry - just change the default protocol to something else and your semver ranges will be fetched from whatever source you select.\n\ndefaultProtocol: \"npm:\"\n\n## defaultSemverRangePrefix\n\nThe default prefix for semantic version dependency ranges, which is used for new dependencies that are installed to a manifest. Possible values are `\"^\"` (the default), `\"~\"` or `\"\"`.\n\ndefaultSemverRangePrefix: \"^\"\n\n## deferredVersionFolder\n\nThe folder where the versioning files are stored.\n\ndeferredVersionFolder: \"./.yarn/versions\"\n\n## enableColors\n\nIf true (by default detects terminal capabilities), Yarn will format its pretty-print its output by using colors to differentiate important parts of its messages.\n\nenableColors: true\n\n## enableGlobalCache\n\nIf true, Yarn will disregard the `cacheFolder` settings and will store the cache files into a folder shared by all local projects sharing the same configuration.\n\nenableGlobalCache: false\n\n## enableHyperlinks\n\nIf true (by default detects terminal capabilities), the CLI is allowed to use hyperlinks in its output.\n\nenableHyperlinks: true\n\n## enableImmutableCache\n\nIf true, Yarn will refuse the change the cache in any way (whether it would add files or remove them) when running `yarn install`.\n\nenableImmutableCache: false\n\n## enableImmutableInstalls\n\nIf true (the default on CI), Yarn will refuse to change the installation artifacts (apart from the cache) when running an install. This flag is quite intrusive, you typically should only set it on your CI by manually passing the `--immutable` flag to `yarn install`.\n\nenableImmutableInstalls: false\n\n## enableInlineBuilds\n\nIf true (the default on CI environments), Yarn will print the build output directly within the terminal instead of buffering it in a log file.\n\nenableInlineBuilds: false\n\n## enableMirror\n\nIf true (the default), Yarn will use the global folder as indirection between the network and the actual cache. This makes installs much faster for projects that don't already benefit from Zero-Installs.\n\nenableMirror: true\n\n## enableNetwork\n\nIf false, Yarn will never make any request to the network by itself, and will throw an exception rather than let it happen. It's a very useful setting for CI, which typically want to make sure they aren't loading their dependencies from the network by mistake.\n\nenableNetwork: true\n\n## enableProgressBars\n\nIf true (the default outside of CI environments), Yarn will show progress bars for long-running events.\n\nenableProgressBars: true\n\n## enableScripts\n\nIf false, Yarn will not execute the `postInstall` scripts when installing the project. Note that you can now also disable scripts on a per-package basis thanks to `dependenciesMeta`.\n\nenableScripts: true\n\n## enableStrictSsl\n\nIf false, SSL certificate errors will be ignored\n\nenableStrictSsl: true\n\n## enableTelemetry\n\nIf true (the default outside of CI environments), Yarn will periodically send anonymous data to our servers tracking some usage information such as the number of dependency in your project, how many install you ran, etc. Consult the [Telemetry](../advanced/telemetry) page for more details about it.\n\nenableTelemetry: true\n\n## enableTimers\n\nIf false, Yarn will not print the time spent running each sub-step when running various commands. This is typically needed for testing purposes, when you want each execution to have exactly the same output as the previous ones.\n\nenableTimers: true\n\n## enableTransparentWorkspaces\n\nIf false, Yarn won't link workspaces just because their versions happen to match a semver range. Disabling this setting will require that all workspace accesses are made through the `workspace:` protocol. This is usually only needed in some very specific circumstances.\n\nenableTransparentWorkspaces: true\n\n## globalFolder\n\nThe path where all system-global files (for example the list of all packages registered through `yarn link`) are stored.\n\nglobalFolder: \"./.yarn/global\"\n\n## httpProxy\n\nDefines a proxy to use when making an HTTP request. Note that Yarn only supports HTTP proxies at the moment (help welcome!).\n\nhttpProxy: \"http://proxy:4040\"\n\n## httpsProxy\n\nDefines a proxy to use when making an HTTPS request. Note that Yarn only supports HTTP proxies at the moment (help welcome!).\n\nhttpsProxy: \"http://proxy:4040\"\n\n## httpTimeout\n\nTimeout of each http request in milliseconds\n\nhttpTimeout: 60000\n\n## httpRetry\n\nRetry times on http failure\n\nhttpRetry: 3\n\n## ignoreCwd\n\nIf true, the `--cwd` flag will be ignored.\n\nignoreCwd: false\n\n## ignorePath\n\nIf true, the local executable will be ignored when using the global one.\n\nignorePath: false\n\n## immutablePatterns\n\nAn array of patterns for files and directories that aren't allowed to change when running installs with the \\`--immutable\\` flag set.\n\nimmutablePatterns:\n\n\\-\n\n\"\\*\\*/.pnp.\\*\"\n\n## initScope\n\nScope used when creating packages via the `init` command.\n\ninitScope: \"yarnpkg\"\n\n## initFields\n\nAdditional fields to set when creating packages via the `init` command.\n\ninitFields:\n\n### homepage\n\nAll properties will be added verbatim to the generated package.json.\n\nhomepage: \"https://yarnpkg.com\"\n\n## installStatePath\n\nPath of the file where the install state will be persisted.\n\ninstallStatePath: \"./.yarn/install-state.gz\"\n\n## logFilters\n\nDefines overrides for log levels for message names or message text. Through this setting you can hide specific messages or give them a more important visibility.\n\nlogFilters:\n\n\\-\n\n### code\n\nSelects all messages with the given code.\n\ncode: \"YN0005\"\n\n### level\n\nApplies the specified log level to all selected messages. Can be one of `info`, `warning`, `error`, or `discard` if you wish to hide those messages altogether.\n\nlevel: \"error\"\n\n\\-\n\n### text\n\nSelects exactly one message that must match the given text. In case a message matches both `code`-based and `text`-based filters, the `text`-based ones will take precedence over the `code`-based ones.\n\ntext: \"lorem-ipsum@npm:1.2.3 lists build scripts, but its build has been explicitly disabled through configuration\"\n\n### level\n\nApplies the specified log level to all selected messages. Can be one of `info`, `warning`, `error`, or `discard` if you wish to hide those messages altogether.\n\nlevel: \"error\"\n\n\\-\n\n### pattern\n\nSelects exactly one message that must match the given glob pattern. In case a message matches both `pattern`-based and `code`-based filters, the `pattern`-based ones will take precedence over the other ones. Patterns can be overriden on a case-by-case basis by using the `text` filter, which has precedence over `pattern`.\n\npattern: \"lorem-ipsum@\\* lists build scripts, but its build has been explicitly disabled through configuration\"\n\n### level\n\nApplies the specified log level to all selected messages. Can be one of `info`, `warning`, `error`, or `discard` if you wish to hide those messages altogether.\n\nlevel: \"error\"\n\n## lockfileFilename\n\nDefines the name of the lockfiles that will be generated by Yarn.\n\nlockfileFilename: \"yarn.lock\"\n\n## networkConcurrency\n\nDefines how many requests are allowed to run at the same time. Yarn defaults to 50 concurrent requests but it may be required to limit it even more when working behind proxies that can't handle large amounts of concurrent requests.\n\nnetworkConcurrency: 8\n\n## networkSettings\n\nAdditional network settings, per hostname\n\nnetworkSettings:\n\n### \\*.example.com\n\nThe hostname to override settings for (glob patterns are supported)\n\n\\*.example.com:\n\n### caFilePath\n\nSee [`caFilePath`](#caFilePath).\n\ncaFilePath: \"./exampleCA.pem\"\n\n### enableNetwork\n\nSee [`enableNetwork`](#enableNetwork).\n\nenableNetwork: true\n\n### httpProxy\n\nSee [`httpProxy`](#httpProxy).\n\nhttpProxy: \"http://proxy:4040\"\n\n### httpsProxy\n\nSee [`httpsProxy`](#httpsProxy).\n\nhttpsProxy: \"http://proxy:4040\"\n\n## nmHoistingLimits\n\nDefines the highest point where packages can be hoisted. One of `workspaces` (don't hoist packages past the workspace that depends on them), `dependencies` (packages aren't hoisted past the direct dependencies for each workspace), or `none` (the default, packages are hoisted as much as possible). This setting can be overriden per-workspace through the [`installConfig.hoistingLimits` field](manifest#installConfig.hoistingLimits).\n\nnmHoistingLimits: \"none\"\n\n## nmSelfReferences\n\nDefines whether workspaces are allowed to require themselves - results in creation of self-referencing symlinks. This setting can be overriden per-workspace through the [`installConfig.selfReferences` field](manifest#installConfig.selfReferences).\n\nnmSelfReferences: true\n\n## nmMode\n\nIf set to `hardlinks-local` Yarn will utilize hardlinks to reduce disk space consumption inside `node_modules` directories in a current project. With `hardlinks-global` Yarn will use global content addressable storage to reduce `node_modules` size across all the projects using this option.\n\nnmMode: \"classic\"\n\n## nodeLinker\n\nDefines what linker should be used for installing Node packages (useful to enable the node-modules plugin), one of: `pnp`, `pnpm` and `node-modules`.\n\nnodeLinker: \"pnp\"\n\n## npmAlwaysAuth\n\nIf true, Yarn will always send the authentication credentials when making a request to the registries. This typically shouldn't be needed.\n\nnpmAlwaysAuth: false\n\n## npmAuditRegistry\n\nDefines the registry that must be used when auditing dependencies. Doesn't need to be defined, in which case the value of `npmRegistryServer` will be used.\n\nnpmAuditRegistry: \"https://npm.pkg.github.com\"\n\n## npmAuthIdent\n\nDefines the authentication credentials to use by default when accessing your registries (equivalent to `_auth` in the v1). This settings is strongly discouraged in favor of `npmAuthToken`.\n\nnpmAuthIdent: \"username:password\"\n\n## npmAuthToken\n\nDefines the authentication credentials to use by default when accessing your registries (equivalent to `_authToken` in the v1). If you're using [`npmScopes`](#npmScopes) to define multiple registries, the [`npmRegistries`](#npmRegistries) dictionary allows you to override these credentials on a per-registry basis.\n\nnpmAuthToken: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n\n## npmPublishAccess\n\nDefines the default access to use when publishing packages to the npm registry. Valid values are `public` and `restricted`, but `restricted` usually requires to register for a paid plan (this is up to the registry you use).\n\nnpmPublishAccess: \"public\"\n\n## npmPublishRegistry\n\nDefines the registry that must be used when pushing packages. Doesn't need to be defined, in which case the value of `npmRegistryServer` will be used. Overridden by `publishConfig.registry`.\n\nnpmPublishRegistry: \"https://npm.pkg.github.com\"\n\n## npmRegistries\n\nOn top of the global configuration, registries can be configured on a per-scope basis (for example to instruct Yarn to use your private registry when accessing packages from a given scope). The following properties are supported:\n\nnpmRegistries:\n\n### //npm.pkg.github.com\n\nThis key represent the registry that's covered by the settings defined in the nested object. The protocol is optional (using `https://npm.pkg.github.com` would work just as well).\n\n//npm.pkg.github.com:\n\n### npmAlwaysAuth\n\nSee [`npmAlwaysAuth`](#npmAlwaysAuth).\n\nnpmAlwaysAuth: false\n\n### npmAuthIdent\n\nSee [`npmAuthIdent`](#npmAuthIdent).\n\nnpmAuthIdent: \"username:password\"\n\n### npmAuthToken\n\nSee [`npmAuthToken`](#npmAuthToken).\n\nnpmAuthToken: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n\n## npmRegistryServer\n\nDefines the hostname of the remote server from where Yarn should fetch the metadata and archives when querying the npm registry. Should you want to define different registries for different scopes, see `npmScopes`. To define the authentication scheme for your servers, see `npmAuthToken`. The Hostname must use the `HTTPS` protocol, but this can be changed by adding it to the [`unsafeHttpWhitelist`](#unsafeHttpWhitelist).\n\nnpmRegistryServer: \"https://registry.yarnpkg.com\"\n\n## npmScopes\n\nOn top of the global configuration, registries can be configured on a per-scope basis (for example to instruct Yarn to use your private registry when accessing packages from a given scope). The following properties are supported:\n\nnpmScopes:\n\n### my-company\n\nThis key represent the scope that's covered by the settings defined in the nested object. Note that it mustn't start with the `@` character.\n\nmy-company:\n\n### npmPublishRegistry\n\nSee [`npmPublishRegistry`](#npmPublishRegistry).\n\nnpmPublishRegistry: \"https://registry.yarnpkg.com\"\n\n### npmRegistryServer\n\nSee [`npmRegistryServer`](#npmRegistryServer).\n\nnpmRegistryServer: \"https://registry.yarnpkg.com\"\n\n### npmAlwaysAuth\n\nSee [`npmAlwaysAuth`](#npmAlwaysAuth).\n\nnpmAlwaysAuth: false\n\n### npmAuthIdent\n\nSee [`npmAuthIdent`](#npmAuthIdent).\n\nnpmAuthIdent: \"username:password\"\n\n### npmAuthToken\n\nSee [`npmAuthToken`](#npmAuthToken).\n\nnpmAuthToken: \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n\n## packageExtensions\n\nSome packages may have been specified incorrectly with regard to their dependencies - for example with one dependency being missing, causing Yarn to refuse it the access. The `packageExtensions` fields offer a way to extend the existing package definitions with additional information. If you use it, consider sending a PR upstream and contributing your extension to the [`plugin-compat` database](https://github.com/yarnpkg/berry/blob/master/packages/plugin-compat/sources/extensions.ts). Note: This field is made to add dependencies; if you need to rewrite existing ones, prefer the [`resolutions`](manifest#resolutions) field.\n\npackageExtensions:\n\n### webpack@\\*\n\nEach key is a descriptor covering a semver range. The extensions will be applied to any package whose version matches the specified range. This is true regardless of where the package comes from, so no distinction on whether they come from git or a registry, for example. Only the version matters.\n\nwebpack@\\*:\n\ndependencies:\n\nlodash: \"^4.15.0\"\n\npeerDependencies:\n\nwebpack-cli: \"\\*\"\n\npeerDependenciesMeta:\n\nwebpack-cli:\n\noptional: true\n\n## pnpDataPath\n\nThe location where Yarn will read and write the `.pnp.meta.json` file.\n\npnpDataPath: \"./.pnp.data.json\"\n\n## pnpEnableEsmLoader\n\nIf true, Yarn will generate an experimental ESM loader (`.pnp.loader.mjs`). Yarn tries to automatically detect whether ESM support is required.\n\npnpEnableEsmLoader: false\n\n## pnpEnableInlining\n\nIf true (the default), Yarn will generate a single `.pnp.cjs` file that contains all the required data for your project to work properly. If toggled off, Yarn will also generate a `.pnp.data.json` file meant to be consumed by the `@yarnpkg/pnp` package.\n\npnpEnableInlining: true\n\n## pnpFallbackMode\n\nEnumeration whose values (`none`, `dependencies-only`, `all`) define in which capacity should the PnP hook allow packages to rely on the builtin fallback mechanism. In `dependencies-only` mode (the default), your workspaces aren't allowed to use it.\n\npnpFallbackMode: \"dependencies-only\"\n\n## pnpIgnorePatterns\n\nAn Array of glob patterns. Files matching the following locations (in term of relative path compared to the generated `.pnp.cjs` file) will not be covered by PnP and will use the regular Node resolution. Typically only needed if you have subprojects that aren't yet part of your workspace tree.\n\npnpIgnorePatterns:\n\n\\-\n\n\"./subdir/\\*\"\n\n## pnpMode\n\nIf `strict` (the default), Yarn won't allow modules to require packages they don't explicitly list in their own dependencies. If `loose`, Yarn will allow access to the packages that would have been hoisted to the top-level under 1.x installs. Note that, even in loose mode, such calls are unsafe (hoisting rules aren't predictable) and should be discouraged.\n\npnpMode: \"strict\"\n\n## pnpShebang\n\nA header that will be prepended to the generated `.pnp.cjs` file. You're allowed to write multiple lines, but this is slightly frowned upon.\n\npnpShebang: \"#!/usr/bin/env node\"\n\n## pnpUnpluggedFolder\n\nThe path where unplugged packages will be stored on the disk.\n\npnpUnpluggedFolder: \"./.yarn/unplugged\"\n\n## preferAggregateCacheInfo\n\nIf true, Yarn will only print a one-line report of any cache changes.\n\npreferAggregateCacheInfo: false\n\n## preferDeferredVersions\n\nIf true, Yarn will use the deferred versioning (`--deferred`) by default when running the `yarn version` family of commands. This can be overruled on a by-command basis by manually setting the `--immediate` flag.\n\npreferDeferredVersions: false\n\n## preferInteractive\n\nIf true, Yarn will ask for your guidance when some actions would be improved by being disambiguated. Enabling this setting also unlocks some features (for example the `yarn add` command will suggest to reuse the same dependencies as other workspaces if pertinent).\n\npreferInteractive: false\n\n## preferTruncatedLines\n\nIf true, Yarn will truncate lines that would go beyond the size of the terminal. If progress bars are disabled, lines will never be truncated. Forgettable lines (e.g. the fetch step logs) are always truncated.\n\npreferTruncatedLines: false\n\n## progressBarStyle\n\nWhich style of progress bar should be used (only when progress bars are enabled). Valid values can be found [here](https://github.com/yarnpkg/berry/blob/ac2668904bdcd804e531291c749b9d17b8d3acd7/packages/yarnpkg-core/sources/StreamReport.ts#L40).\n\nprogressBarStyle: \"default\"\n\n## rcFilename\n\nThis setting defines the name of the files that Yarn looks for when resolving the rc files. For obvious reasons this settings cannot be set within rc files, and must be defined in the environment using the `YARN_RC_FILENAME` variable.\n\nrcFilename: \".yarnrc.yml\"\n\n## supportedArchitectures\n\nDefines the systems for which Yarn should install packages.\n\nsupportedArchitectures:\n\n### os\n\nThe list of operating systems to cover.\n\nos:\n\n\\-\n\n\"current\"\n\n\\-\n\n\"darwin\"\n\n\\-\n\n\"linux\"\n\n\\-\n\n\"win32\"\n\n### cpu\n\nThe list of CPUs to cover.\n\ncpu:\n\n\\-\n\n\"current\"\n\n\\-\n\n\"x86\"\n\n\\-\n\n\"ia32\"\n\n## telemetryInterval\n\nThis setting defines the minimal amount of time between two telemetry uploads, in days. By default we only send one request per week, making it impossible for us to track your usage with a lower granularity.\n\ntelemetryInterval: 7\n\n## telemetryUserId\n\nBy default, we don't assign unique IDs in the telemetry we send, so we have no way to know which data originates from which project. This setting can be used to force a user ID to be sent to our telemetry server. Frankly, it's only useful in some very specific use cases. For example, we use it on the Yarn repository in order to exclude our own usage from the public dashboards (since we necessarily run Yarn more often here than anywhere else, the resulting data would be biased).\n\ntelemetryUserId: \"yarnpkg/berry\"\n\n## unsafeHttpWhitelist\n\nThis setting lists the hostnames for which using the HTTP protocol is allowed. Any other hostname will be required to use HTTPS instead. The reason behind this decision and more details can be found [here](https://github.com/yarnpkg/berry/pull/416).\n\nGlob patterns are supported.\n\nunsafeHttpWhitelist:\n\n\\-\n\n\"\\*.example.org\"\n\n\\-\n\n\"example.org\"\n\n## virtualFolder\n\nDue to a particularity in how Yarn installs packages which list peer dependencies, some packages will be mapped to multiple virtual directories that don't actually exist on the filesystem. This settings tells Yarn where to put them. Note that the folder name *must* be `__virtual__`.\n\nvirtualFolder: \"./.yarn/\\_\\_virtual\\_\\_\"\n\n## yarnPath\n\nThe path of a Yarn binary, which will be executed instead of any other (including the global one) for any command run within the directory covered by the rc file. If the file extension ends with `.js` it will be required, and will be spawned in any other case.\n\nThe `yarnPath` setting is currently the preferred way to install Yarn within a project, as it ensures that your whole team will use the exact same Yarn version, without having to individually keep it up-to-date.\n\nyarnPath: \"./scripts/yarn-2.0.0-rc001.js\"\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/configuration/yarnrc](https://yarnpkg.com/configuration/yarnrc)"
- name: Zero-Installs
  id: features/zero-installs
  summary: 'While not a feature in itself, the term "Zero Install" encompasses a lot of Yarn features tailored around one specific goal - to make your projects as stable and fast as possible by removing the main source of entropy from the equation: Yarn itself'
  description: "# Zero-Installs\n\nWhile not a feature in itself, the term \"Zero Install\" encompasses a lot of Yarn features tailored around one specific goal - to make your projects as stable and fast as possible by removing the main source of entropy from the equation: Yarn itself.\n\n> **Important:** Zero-install is an *optional* philosophy. It has some drawbacks, and while we believe this workflow to be a defining feature for professional-grade projects we don't have any plans to ignore or deprecate the typical `yarn install` workflow in any way, now or in the future.\n\n- [How does Yarn impact a project's stability?](#how-does-yarn-impact-a-projects-stability)\n\n- [How do you reach this \"zero-install\" state you're advocating for?](#how-do-you-reach-this-zero-install-state-youre-advocating-for)\n\n- [Concerns](#concerns)\n\n  - [Is it different from just checking-in the `node_modules` folder?](#is-it-different-from-just-checking-in-the-node_modules-folder)\n  - [Does it have security implications?](#does-it-have-security-implications)\n\n## How does Yarn impact a project's stability?\n\nYarn does its best to guarantee that running `yarn install` twice will give you the same result in both cases. The main way it does this is through a lockfile, which contains all the information needed for a project to be installed in a reproducible way across systems. But is it good enough?\n\nWhile Yarn does its best to guarantee that what works now will keep working, there's always the off chance that a future Yarn release will introduce a bug that will prevent you from installing your project. Or maybe your production environments will change and `yarn install` won't be able to write in the temporary directories anymore. Or maybe the network will fail and your packages won't be available anymore. Or maybe your credentials will rotate and you will start getting authentication issues. Or ... so many things can go wrong, and not all of them are things we can control.\n\nNote that these challenges are not unique to Yarn — you may remember a time when npm used to erase production servers due to a bug that reached one of their releases. This is exactly what we mean: any code that runs is code that can fail. And thanks to Murphy's law, we know that something that can fail *will* eventually fail. From there, it becomes clear that the only sure way to prevent such issues is to run as little code as possible.\n\n## How do you reach this \"zero-install\" state you're advocating for?\n\nIn order to make a project zero-install, you must be able to use it as soon as you clone it. This is very easy starting from Yarn 2!\n\n- First, ensure that your project is using [Plug'n'Play](pnp) to resolve dependencies via the cache folder and **not** from `node_modules`.\n\n  - While in theory you could check-in your `node_modules` folder rather than the cache, in practice the `node_modules` contains a gigantic amount of files that frequently change location and mess with Git's optimizations. By contrast, the Yarn cache contains exactly one file per package, that only change when the packages themselves change.\n\n- The cache folder is by default stored within your project folder (in `.yarn/cache`). Just make sure you add it to your repository (see also, [Offline Cache](offline-cache)).\n\n  - Again, this whole workflow is optional. If at some point you decide that in the end you prefer to keep using a global cache, just toggle on `enableGlobalCache` in the [yarnrc settings](../configuration/yarnrc#enableGlobalCache) and it'll be back to normal.\n\n- When running `yarn install`, Yarn will generate a `.pnp.cjs` file. Add it to your repository as well - it contains the dependency tree that Node will use to load your packages.\n\n- Depending on whether your dependencies have install scripts or not (we advise you to avoid it if you can, and prefer wasm-powered alternatives) you may also want to add the `.yarn/unplugged` entries.\n\nAnd that's it! Push your changes to your repository, checkout a new one somewhere, and check whether running `yarn start` (or whatever other script you'd normally use) works.\n\n## Concerns\n\n### Is it different from just checking-in the `node_modules` folder?\n\nYes, very much. To give you an idea, a `node_modules` folder of 135k uncompressed files (for a total of 1.2GB) gives a Yarn cache of 2k binary archives (for a total of 139MB). Git simply cannot support the former, while the latter is perfectly fine.\n\nAnother huge difference is the number of changes. Back in Yarn 1, when updating a package, a huge amount of files had to be recreated, or even simply moved. When the same happens in a Yarn 2 install, you get a very predictable result: exactly one changed file for each added/removed package. This in turn has beneficial side effects in terms of performance and security, since you can easily spot the invalid checksums on a per-package basis.\n\n### Does it have security implications?\n\nNote that, by design, this setup requires that you trust people modifying your repository. In particular, projects accepting PRs from external users will have to be careful that the PRs affecting the package archives are legit (since it would otherwise be possible to a malicious user to send a PR for a new dependency after having altered its archive content). The best way to do this is to add a CI step (for untrusted PRs only) that uses the `--check-cache` flag:\n\n``` language-text\n$> yarn install --check-cache\n```\n\nThis way Yarn will re-download the package files from whatever their remote location would be and will report any mismatching checksum.\n\n© 2016–present Yarn Contributors  \nLicensed under the BSD License.  \n[https://yarnpkg.com/features/zero-installs](https://yarnpkg.com/features/zero-installs)"
