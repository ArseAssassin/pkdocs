---
name: Flow
slug: flow
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  ¬© 2013‚Äìpresent Facebook Inc.
  Licensed under the MIT License.
  https://flow.org/en/docs/
homepage: https://flow.org/

---
- name: .flowconfig
  id: config
  summary: Every Flow project contains a .flowconfig file
  description: "# .flowconfig\n\nEvery Flow project contains a `.flowconfig` file. You can configure Flow by modifying `.flowconfig`. New projects or projects that are starting to use Flow can generate a default `.flowconfig` by running `flow init`.\n\n## `.flowconfig` format\n\nThe `.flowconfig` uses a custom format that vaguely resembles INI files.\n\nThe `.flowconfig` consists of different sections:\n\n- [`[include]`](include)\n- [`[ignore]`](ignore)\n- [`[untyped]`](untyped)\n- [`[libs]`](https://flow.org/en/docs/libs)\n- [`[lints]`](lints)\n- [`[options]`](options)\n- [`[version]`](version)\n- [`[declarations]`](declarations)\n- [`[strict]`](https://flow.org/en/strict/#toc-enabling-flow-strict-in-a-flowconfig)\n\n## Comments\n\nComment support was added in v0.23.0. Lines beginning with zero or more spaces followed by an `#` or `;` or `üí©` are ignored. For example:\n\n``` plaintext\n# This is a comment\n  # This is a comment\n; This is a comment\n  ; This is a comment\nüí© This is a comment\n  üí© This is a comment\n```\n\n## Where to put the `.flowconfig`\n\nThe location of the `.flowconfig` is significant. Flow treats the directory that contains the `.flowconfig` as the *project root*. By default Flow includes all the source code under the project root. The paths in the [\\[include\\] section](include) are relative to the project root. Some other configuration also lets you reference the project root via the macro `<PROJECT_ROOT>`.\n\nMost people put the `.flowconfig` in the root of their project (i.e. next to the `package.json`). Some people put all their code in a `src/` directory and therefore put the `.flowconfig` at `src/.flowconfig`.\n\n## Example\n\nSay you have the following directory structure, with your `.flowconfig` in `mydir`:\n\n``` text\notherdir\n‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ othercode.js\nmydir\n‚îú‚îÄ‚îÄ .flowconfig\n‚îú‚îÄ‚îÄ build\n‚îÇ   ‚îú‚îÄ‚îÄ first.js\n‚îÇ   ‚îî‚îÄ‚îÄ shim.js\n‚îú‚îÄ‚îÄ lib\n‚îÇ   ‚îî‚îÄ‚îÄ flow\n‚îú‚îÄ‚îÄ node_modules\n‚îÇ   ‚îî‚îÄ‚îÄ es6-shim\n‚îî‚îÄ‚îÄ src\n    ‚îú‚îÄ‚îÄ first.js\n    ‚îî‚îÄ‚îÄ shim.js\n```\n\nHere is an example of how you could use the `.flowconfig` directives.\n\n``` text\n[include]\n../otherdir/src\n\n[ignore]\n.*/build/.*\n\n[libs]\n./lib\n```\n\nNow `flow` will include a directory outside the `.flowconfig` path in its check, ignore the `build` directory and use the declarations in `lib`.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config](https://flow.org/en/docs/config)"
- name: .flowconfig [declarations]
  id: config/declarations
  summary: Often third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow
  description: "# .flowconfig \\[declarations\\]\n\nOften third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow. In those cases it may be useful to use type information from the third-party libraries without typechecking their contents.\n\n## `[declarations]`\n\nThe `[declarations]` section in a `.flowconfig` file tells Flow to parse files matching the specified regular expressions in *declaration mode*. In declaration mode the code is not typechecked. However, the signatures of functions, classes, etc are extracted and used by the typechecker when checking other code.\n\nConceptually one can think of declaration mode as if Flow still typechecks the files but acts as if there is a comment that matches [`suppress_comment`](../options#toc-suppress-comment-regex) on every line.\n\nSee also `[untyped]`(untyped) for not typechecking files, and instead using `any` for all contents.\n\nThings to keep in mind:\n\n1.  Declaration mode should only be used for existing third-party code. You should never use this for code under your control.\n2.  These are [OCaml regular expressions](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp).\n3.  These regular expressions match against absolute paths. They probably should start with `.*`\n\nAn example `[declarations]` section might look like:\n\n``` plaintext\n[declarations]\n.*/third_party/.*\n.*/src/\\(foo\\|bar\\)/.*\n.*\\.decl\\.js\n```\n\nThis `[declarations]` section will parse in declaration mode:\n\n1.  Any file or directory under a directory named `third_party`\n2.  Any file or directory under `.*/src/foo` or under `.*/src/bar`\n3.  Any file that ends with the extension `.decl.js`\n\nStarting with Flow v0.23.0, you may use the `<PROJECT_ROOT>` placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project‚Äôs root directory. This is useful for writing regular expressions that are relative rather than absolute.\n\nFor example, you can write:\n\n``` plaintext\n[declarations]\n<PROJECT_ROOT>/third_party/.*\n```\n\nWhich would parse in declaration mode any file or directory under the directory named `third_party/` within the project root. However, unlike the previous example‚Äôs `.*/third_party/.*`, it would NOT parse files or directories under directories named `third_party/`, like `src/third_party/`.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/declarations](https://flow.org/en/docs/config/declarations)"
- name: .flowconfig [ignore]
  id: config/ignore
  summary: Flow needs to know which files to read and watch for changes
  description: "# .flowconfig \\[ignore\\]\n\nFlow needs to know which files to read and watch for changes. This set of files is determined by taking all included files and excluding all the ignored files.\n\n## `[ignore]`\n\nThe `[ignore]` section in a `.flowconfig` file tells Flow to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.\n\nThings to keep in mind:\n\n1.  These are [OCaml regular expressions](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp).\n2.  These regular expressions match against absolute paths. They probably should start with `.*`\n3.  Ignores are processed AFTER includes. If you both include and ignore a file it will be ignored.\n\nAn example `[ignore]` section might look like:\n\n``` plaintext\n[ignore]\n.*/__tests__/.*\n.*/src/\\(foo\\|bar\\)/.*\n.*\\.ignore\\.js\n```\n\nThis `[ignore]` section will ignore:\n\n1.  Any file or directory under a directory named `__tests__`\n2.  Any file or directory under `.*/src/foo` or under `.*/src/bar`\n3.  Any file that ends with the extension `.ignore.js`\n\nStarting with Flow v0.23.0, you may use the `<PROJECT_ROOT>` placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project‚Äôs root directory. This is useful for writing regular expressions that are relative rather than absolute.\n\nFor example, you can write:\n\n``` plaintext\n[ignore]\n<PROJECT_ROOT>/__tests__/.*\n```\n\nWhich would ignore any file or directory under the directory named `__tests__/` within the project root. However, unlike the previous example‚Äôs `.*/__tests__/.*`, it would NOT ignore files or directories under other directories named `__tests__/`, like `src/__tests__/`.\n\n## Exclusions\n\nSometimes you may want to ignore all files inside a directory with the exception of a few. An optional prefix ‚Äú!‚Äù which negates the pattern may help. With this, any matching file excluded by a previous pattern will become included again.\n\n``` plaintext\n[ignore]\n<PROJECT_ROOT>/node_modules/.*\n!<PROJECT_ROOT>/node_modules/not-ignored-package-A/.*\n!<PROJECT_ROOT>/node_modules/not-ignored-package-B/.*\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/ignore](https://flow.org/en/docs/config/ignore)"
- name: .flowconfig [include]
  id: config/include
  summary: Flow needs to know which files to read and watch for changes
  description: "# .flowconfig \\[include\\]\n\nFlow needs to know which files to read and watch for changes. This set of files is determined by taking all included files and excluding all the ignored files.\n\nThe `[include]` section in a `.flowconfig` file tells Flow to include the specified files or directories. Including a directory recursively includes all the files under that directory. Symlinks are followed as long as they lead to a file or directory that is also included. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.\n\nThe project root directory (where your `.flowconfig` lives) is automatically included.\n\nFor example, if `/path/to/root/.flowconfig` contains the following `[include]` section:\n\n``` plaintext\n[include]\n../externalFile.js\n../externalDir/\n../otherProject/*.js\n../otherProject/**/coolStuff/\n```\n\nThen when Flow checks the project in `/path/to/root`, it will read and watch\n\n1.  `/path/to/root/` (automatically included)\n2.  `/path/to/externalFile.js`\n3.  `/path/to/externalDir/`\n4.  Any file in `/path/to/otherProject/` that ends in `.js`\n5.  Any directory under `/path/to/otherProject` named `coolStuff/`\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/include](https://flow.org/en/docs/config/include)"
- name: .flowconfig [libs]
  id: config/libs
  summary: The [libs] section in a .flowconfig file tells Flow to include the specified library definitions when type checking your code
  description: "# .flowconfig \\[libs\\]\n\nThe `[libs]` section in a `.flowconfig` file tells Flow to include the specified [library definitions](https://flow.org/en/libdefs/) when type checking your code. Multiple libraries can be specified. By default, the `flow-typed` folder in your project root directory is included as a library directory. This default allows you to use [`flow-typed`](https://github.com/flowtype/flow-typed) to install library definitions without additional configuration.\n\nEach line in the `[libs]` section is a path to the library file or directory which you would like to include. These paths can be relative to the project root directory or absolute. Including a directory recursively includes all the files under that directory as library files.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/libs](https://flow.org/en/docs/config/libs)"
- name: .flowconfig [lints]
  id: config/lints
  summary: Check out the linting docs for more information
  description: "# .flowconfig \\[lints\\]\n\nThe `[lints]` section in a `.flowconfig` file can contain several key-value pairs of the form:\n\n``` plaintext\n[lints]\nruleA=severityA\nruleB=severityB\n```\n\nCheck out the [linting docs](https://flow.org/en/linting) for more information.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/lints](https://flow.org/en/docs/config/lints)"
- name: .flowconfig [options]
  id: config/options
  summary: Any options that are omitted will use their default values
  description: "# .flowconfig \\[options\\]\n\nThe `[options]` section in a `.flowconfig` file can contain several key-value pairs of the form:\n\n``` plaintext\n[options]\nkeyA=valueA\nkeyB=valueB\n```\n\nAny options that are omitted will use their default values. Some options can be overridden with command line flags.\n\n## Available options\n\n- [`all`](#toc-all-boolean)\n- [`autoimports`](#toc-autoimports-boolean)\n- [`babel_loose_array_spread`](#toc-babel-loose-array-spread-boolean)\n- [`emoji`](#toc-emoji-boolean)\n- [`exact_by_default`](#toc-exact-by-default-boolean)\n- [`experimental.const_params`](#toc-experimental-const-params-boolean)\n- [`include_warnings`](#toc-include-warnings-boolean)\n- [`inference_mode`](#toc-inference-mode-classic-constrain-writes)\n- [`lazy_mode`](#toc-lazy-mode-boolean)\n- [`log.file`](#toc-log-file-string)\n- [`max_header_tokens`](#toc-max-header-tokens-integer)\n- [`module.file_ext`](#toc-module-file-ext-string)\n- [`module.ignore_non_literal_requires`](#toc-module-ignore-non-literal-requires-boolean)\n- [`module.name_mapper`](#toc-module-name-mapper-regex-string)\n- [`module.name_mapper.extension`](#toc-module-name-mapper-extension-string-string)\n- [`module.system`](#toc-module-system-node-haste)\n- [`module.system.node.main_field`](#toc-module-system-node-main-field-string)\n- [`module.system.node.resolve_dirname`](#toc-module-system-node-resolve-dirname-string)\n- [`module.use_strict`](#toc-module-use-strict-boolean)\n- [`munge_underscores`](#toc-munge-underscores-boolean)\n- [`no_flowlib`](#toc-no-flowlib-boolean)\n- [`react.runtime`](#toc-react-runtime-automatic-classic)\n- [`server.max_workers`](#toc-server-max-workers-integer)\n- [`sharedmemory.dirs`](#toc-sharedmemory-dirs-string)\n- [`sharedmemory.minimum_available`](#toc-sharedmemory-minimum-available-unsigned-integer)\n- [`sharedmemory.hash_table_pow`](#toc-sharedmemory-hash-table-pow-unsigned-integer)\n- [`sharedmemory.heap_size`](#toc-sharedmemory-heap-size-unsigned-integer)\n- [`sharedmemory.log_level`](#toc-sharedmemory-log-level-unsigned-integer)\n- [`suppress_type`](#toc-suppress-type-string)\n- [`temp_dir`](#toc-temp-dir-string)\n- [`traces`](#toc-traces-integer)\n\nThe following options are deprecated and have been removed in the latest version of Flow:\n\n- [`strip_root`](#toc-strip-root-boolean)\n- [`suppress_comment`](#toc-suppress-comment-regex)\n- [`types_first`](#toc-types-first-boolean)\n- [`well_formed_exports`](#toc-well-formed-exports-boolean)\n- [`esproposal.class_instance_fields`](#toc-esproposal-class-instance-fields-enable-ignore-warn)\n- [`esproposal.class_static_fields`](#toc-esproposal-class-static-fields-enable-ignore-warn)\n- [`esproposal.decorators`](#toc-esproposal-decorators-ignore-warn)\n- [`esproposal.export_star_as`](#toc-esproposal-export-star-as-enable-ignore-warn)\n- [`esproposal.optional_chaining`](#toc-esproposal-optional-chaining-enable-ignore-warn)\n- [`esproposal.nullish_coalescing`](#toc-esproposal-nullish-coalescing-enable-ignore-warn)\n\n### `all` *`(boolean)`*\n\nSet this to `true` to check all files, not just those with `@flow`.\n\nThe default value for `all` is `false`.\n\n### `autoimports` *`(boolean)`* ‚â•0.143.0 \n\nWhen enabled, IDE autocomplete suggests the exports of other files, and the necessary `import` statements are automatically inserted. A ‚Äúquick fix‚Äù code action is also provided on undefined variables that suggests matching imports.\n\nThe default value for `autoimports` is `true` as of Flow v0.155.0.\n\n### `babel_loose_array_spread` *`(boolean)`*\n\nSet this to `true` to check that array spread syntax is only used with arrays, not arbitrary iterables (such as `Map` or `Set`). This is useful if you transform your code with Babel in [loose mode](https://babeljs.io/docs/en/babel-plugin-transform-spread#loose) which makes this non-spec-compliant assumption at runtime.\n\nFor example:\n\n``` javascript\nconst set = new Set();\nconst values = [...set]; // Valid ES2015, but Set is not compatible with $ReadOnlyArray in Babel loose mode\n```\n\nThe default value for `babel_loose_array_spread` is `false`.\n\n### `emoji` *`(boolean)`*\n\nSet this to `true` to add emoji to the status messages that Flow outputs when it‚Äôs busy checking your project.\n\nThe default value for `emoji` is `false`.\n\n### `exact_by_default` *`(boolean)`*\n\nSet this to `true` to indicate that Flow should interpret object types as exact by default. When this flag is `false`, Flow has the following behavior:\n\n``` javascript\n{foo: number} // inexact\n{| foo: number |} // exact\n{foo: number, ...} // inexact\n```\n\nWhen this flag is `true`, Flow has the following behavior:\n\n``` javascript\n{foo: number} // exact\n{| foo: number |} // exact\n{foo: number, ...} // inexact\n```\n\nThe default value is `false`.\n\n### `experimental.const_params` *`(boolean)`*\n\nSetting this to `true` makes Flow treat all function parameters as const bindings. Reassigning a param is an error which lets Flow be less conservative with refinements.\n\nThe default value is `false`.\n\n### `inference_mode` *`(classic | constrain_writes)`* ‚â•0.184.0 \n\nSetting this to `constrain_writes` will enable the constrained-writes inference mode.\n\nFor more info, see the [constrained-writes docs](../lang/constrained-writes).\n\nThe default value is `classic`\n\n### `include_warnings` *`(boolean)`*\n\nSetting this to `true` makes Flow commands include warnings in the error output. Warnings are hidden by default in the CLI to avoid console spew. (An IDE is a much better interface to show warnings.)\n\nThe default value is `false`.\n\n### `lazy_mode` *`(boolean)`*\n\nFor more on lazy modes, see the [lazy modes docs](../lang/lazy-modes).\n\nSetting `lazy_mode` in the `.flowconfig` will cause new Flow servers for that root to use lazy mode (or no lazy mode if set to `false`). This option can be overridden from the CLI using the `--lazy-mode` flag.\n\nThe default value is `false`.\n\n### `log.file` *`(string)`*\n\nThe path to the log file (defaults to `/tmp/flow/<escaped root path>.log`).\n\n### `max_header_tokens` *`(integer)`*\n\nFlow tries to avoid parsing non-flow files. This means Flow needs to start lexing a file to see if it has `@flow` or `@noflow` in it. This option lets you configure how much of the file Flow lexes before it decides there is no relevant docblock.\n\n- Neither `@flow` nor `@noflow` - Parse this file with Flow syntax disallowed and do not typecheck it.\n- @flow - Parse this file with Flow syntax allowed and typecheck it.\n- @noflow - Parse this file with Flow syntax allowed and do not typecheck it. This is meant as an escape hatch to suppress Flow in a file without having to delete all the Flow-specific syntax.\n\nThe default value of `max_header_tokens` is 10.\n\n### `module.file_ext` *`(string)`*\n\nBy default, Flow will look for files with the extensions `.js`, `.jsx`, `.mjs`, `.cjs` and `.json`. You can override this behavior with this option.\n\nFor example, if you do:\n\n``` plaintext\n[options]\nmodule.file_ext=.foo\nmodule.file_ext=.bar\n```\n\nThen Flow will instead look for the file extensions `.foo` and `.bar`.\n\n> **Note:** you can specify `module.file_ext` multiple times\n\n### `module.ignore_non_literal_requires` *`(boolean)`*\n\nSet this to `true` and Flow will no longer complain when you use `require()` with something other than a string literal.\n\nThe default value is `false`.\n\n### `module.name_mapper` *`(regex -> string)`*\n\nSpecify a regular expression to match against module names, and a replacement pattern, separated by a `->`.\n\nFor example:\n\n``` plaintext\nmodule.name_mapper='^image![a-zA-Z0-9$_]+$' -> 'ImageStub'\n```\n\nThis makes Flow treat `require('image!foo.jpg')` as if it were `require('ImageStub')`.\n\nThese are [OCaml regular expressions](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp). Use `\\(` and `\\)` (slashes required!) to create a capturing group, which you can refer to in the replacement pattern as `\\1` (up to `\\9`).\n\n> **Note:** you can specify `module.name_mapper` multiple times\n\n### `module.name_mapper.extension` *`(string -> string)`*\n\nSpecify a file extension to match, and a replacement module name, separated by a `->`.\n\n> **Note:** This is just shorthand for `module.name_mapper='^\\(.*\\)\\.EXTENSION$' -> 'TEMPLATE'`)\n\nFor example:\n\n``` plaintext\nmodule.name_mapper.extension='css' -> '<PROJECT_ROOT>/CSSFlowStub.js.flow'\n```\n\nMakes Flow treat `require('foo.css')` as if it were `require(PROJECT_ROOT + '/CSSFlowStub')`.\n\n> **Note:** You can specify `module.name_mapper.extension` multiple times for different extensions.\n\n### `module.system` *`(node|haste)`*\n\nThe module system to use to resolve `import` and `require`. [Haste](https://github.com/facebook/node-haste) is used in React Native.\n\nThe default is `node`.\n\n### `module.system.node.main_field` *`(string)`*\n\nFlow reads `package.json` files for the `\"name\"` and `\"main\"` fields to figure out the name of the module and which file should be used to provide that module.\n\nSo if Flow sees this in the `.flowconfig`:\n\n``` plaintext\n[options]\nmodule.system.node.main_field=foo\nmodule.system.node.main_field=bar\nmodule.system.node.main_field=baz\n```\n\nand then it comes across a `package.json` with\n\n``` plaintext\n{\n  \"name\": \"kittens\",\n  \"main\": \"main.js\",\n  \"bar\": \"bar.js\",\n  \"baz\": \"baz.js\"\n}\n```\n\nFlow will use `bar.js` to provide the `\"kittens\"` module.\n\nIf this option is unspecified, Flow will always use the `\"main\"` field.\n\nSee [this GitHub issue for the original motivation](https://github.com/facebook/flow/issues/5725)\n\n### `module.system.node.resolve_dirname` *`(string)`*\n\nBy default, Flow will look in directories named `node_modules` for node modules. You can configure this behavior with this option.\n\nFor example, if you do:\n\n``` plaintext\n[options]\nmodule.system.node.resolve_dirname=node_modules\nmodule.system.node.resolve_dirname=custom_node_modules\n```\n\nThen Flow will look in directories named `node_modules` or `custom_node_modules`.\n\n> **Note:** you can specify `module.system.node.resolve_dirname` multiple times\n\n### `module.use_strict` *`(boolean)`*\n\nSet this to `true` if you use a transpiler that adds `\"use strict\";` to the top of every module.\n\nThe default value is `false`.\n\n### `munge_underscores` *`(boolean)`*\n\nSet this to `true` to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with [`jstransform`‚Äôs ES6 class transform](https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js), which enforces the same privacy at runtime.\n\nThe default value is `false`.\n\n### `no_flowlib` *`(boolean)`*\n\nFlow has builtin library definitions. Setting this to `true` will tell Flow to ignore the builtin library definitions.\n\nThe default value is `false`.\n\n### `react.runtime` *`(automatic|classic)`* ‚â•0.123.0 \n\nSet this to `automatic` if you are using React‚Äôs automatic runtime in `@babel/plugin-transform-react-jsx`. Otherwise, use `classic`. [See the babel documentation](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx) for details about the transform.\n\nThe default value is `automatic`.\n\n### `server.max_workers` *`(integer)`*\n\nThe maximum number of workers the Flow server can start. By default, the server will use all available cores.\n\n### `sharedmemory.dirs` *`(string)`*\n\nThis affects Linux only.\n\nFlow‚Äôs shared memory lives in a memory mapped file. On more modern versions of Linux (3.17+), there is a system call `memfd_create` which allows Flow to create the file anonymously and only in memory. However, in older kernels, Flow needs to create a file on the file system. Ideally this file lives on a memory-backed tmpfs. This option lets you decide where that file is created.\n\nBy default this option is set to `/dev/shm` and `/tmp`\n\n> **Note:** You can specify `sharedmemory.dirs` multiple times.\n\n### `sharedmemory.minimum_available` *`(unsigned integer)`*\n\nThis affects Linux only.\n\nAs explained in the [`sharedmemory.dirs`](options) option‚Äôs description, Flow needs to create a file on a filesystem for older kernels. `sharedmemory.dirs` specifies a list of locations where the shared memory file can be created. For each location, Flow will check to make sure the filesystem has enough space for the shared memory file. If Flow will likely run out of space, it skips that location and tries the next. This option lets you configure the minimum amount of space needed on a filesystem for shared memory.\n\nBy default it is 536870912 (2^29 bytes, which is half a gigabyte).\n\n### `sharedmemory.hash_table_pow` *`(unsigned integer)`*\n\nThe 3 largest parts of the shared memory are a dependency table, a hash table, and a heap. While the heap grows and shrinks, the two tables are allocated in full. This option lets you change the size of the hash table.\n\nSetting this option to X means the table will support up to 2^X elements, which is 16\\*2^X bytes.\n\nBy default, this is set to 19 (Table size is 2^19, which is 8 megabytes)\n\n### `sharedmemory.heap_size` *`(unsigned integer)`*\n\nThis option configures the maximum possible size for the shared heap. You should most likely not need to configure this, as it doesn‚Äôt really affect how much RSS Flow uses. However, if you are working on a massive codebase you might see the following error after init: ‚ÄúHeap init size is too close to max heap size; GC will never get triggered!‚Äù In this case, you may need to increase the size of the heap.\n\nBy default, this is set to 26843545600 (25 \\* 2^30 bytes, which is 25GiB)\n\n### `sharedmemory.log_level` *`(unsigned integer)`*\n\nSetting this to 1 will cause Flow to output some stats about the data that is serialized into and deserialized out of shared memory.\n\nBy default this is 0.\n\n### `suppress_type` *`(string)`*\n\nThis option lets you alias `any` with a given string. This is useful for explaining why you‚Äôre using `any`. For example, let‚Äôs say you sometimes want to sometimes use `any` to suppress an error and sometimes to mark a TODO. Your code might look like\n\n``` plaintext\nvar myString: any = 1 + 1;\nvar myBoolean: any = 1 + 1;\n```\n\nIf you add the following to your configuration:\n\n``` plaintext\n[options]\nsuppress_type=$FlowFixMe\nsuppress_type=$FlowTODO\n```\n\nYou can update your code to the more readable:\n\n``` plaintext\nvar myString: $FlowFixMe = 1 + 1;\nvar myBoolean: $FlowTODO = 1 + 1;\n```\n\n> **Note:** You can specify `suppress_type` multiple times.\n\n### `temp_dir` *`(string)`*\n\nTell Flow which directory to use as a temp directory. Can be overridden with the command line flag `--temp-dir`.\n\nThe default value is `/tmp/flow`.\n\n### `traces` *`(integer)`*\n\nEnables traces on all error output (showing additional details about the flow of types through the system), to the depth specified. This can be very expensive, so is disabled by default.\n\n### `strip_root` *`(boolean)`* ‚â§0.48 \n\nObsolete. Set this to `true` to always strip the root directory from file paths in error messages when using `--json`, `--from emacs`, and `--from vim`. Do not use this option. Instead, pass the command line flag `--strip-root`.\n\nBy default this is `false`.\n\n### `suppress_comment` *`(regex)`* ‚â§0.126 \n\nDefines a magical comment that suppresses any Flow errors on the following line. For example:\n\n``` plaintext\nsuppress_comment= \\\\(.\\\\|\\n\\\\)*\\\\$FlowFixMe\n```\n\nwill match a comment like this:\n\n``` plaintext\n// $FlowFixMe: suppressing this error until we can refactor\nvar x : string = 123;\n```\n\nand suppress the error. If there is no error on the next line (the suppression is unnecessary), an ‚ÄúUnused suppression‚Äù warning will be shown instead.\n\nIf no suppression comments are specified in your config, Flow will apply one default: `// $FlowFixMe`.\n\n> **Note:** You can specify `suppress_comment` multiple times. If you do define any `suppress_comment`s, the built-in `$FlowFixMe` suppression will be erased in favor of the regexps you specify. If you wish to use `$FlowFixMe` with some additional custom suppression comments, you must manually specify `\\\\(.\\\\|\\n\\\\)*\\\\$FlowFixMe` in your custom list of suppressions.\n\n> **Note:** In version v0.127.0, the option to specify the suppression comment syntax was removed. `$FlowFixMe`, `$FlowIssue`, `$FlowExpectedError`, and `$FlowIgnore` became the only standard suppressions.\n\n### `types_first` *`(boolean)`* ‚â•0.125.0  ‚â§0.142 \n\nFor more on types-first mode, see the [types-first docs](../lang/types-first).\n\nFlow builds intermediate artifacts to represent signatures of modules as they are checked. If this option is set to `false`, then these artifacts are built using inferred type information. If this option is set to `true`, then they are built using type annotations at module boundaries.\n\nThe default value for `types_first` is `true` (as of version 0.134).\n\n### `well_formed_exports` *`(boolean)`* ‚â•0.125.0  ‚â§0.142 \n\nEnforce the following restrictions on file exports:\n\n- Statements manipulating `module.exports` and the `exports` alias may only appear as top-level statements.\n- Parts of the source that are visible from a file‚Äôs exports need to be annotated unless their type can be trivially inferred (e.g. the exported expression is a numeric literal). This is a requirement for types-first mode to function properly. Failure to properly annotate exports raise `signature-verification-failure`s.\n\nThis option is set to `true` by default, since it is implied by [`types_first`](#toc-types-first-boolean), but the option is useful on its own when upgrading a project from classic mode to types-first mode.\n\n### `well_formed_exports.includes` *`(string)`* ‚â•0.128.0  ‚â§0.142 \n\nLimit the scope of the `well_formed_exports` requirement to a specific directory of this project. For example\n\n``` plaintext\nwell_formed_exports=true\nwell_formed_exports.includes=<PROJECT_ROOT>/dirA\nwell_formed_exports.includes=<PROJECT_ROOT>/dirB\n```\n\nwill only report export related errors in files under `dirA` and `dirB`. This option requires `well_formed_exports` to be set to `true`.\n\nThe purpose of this option is to help prepare a codebase for Flow types-first mode. See [this section](#toc-seal-your-intermediate-results) for more.\n\nBetween versions v0.125.0 and v0.127.0, this option was named `well_formed_exports.whitelist`.\n\n### `esproposal.class_instance_fields` *`(enable|ignore|warn)`* ‚â§0.148 \n\nSet this to `warn` to indicate that Flow should give a warning on use of instance [class fields](https://github.com/tc39/proposal-class-public-fields) per the pending spec.\n\nYou may also set this to `ignore` to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class).\n\nThe default value of this option is `enable`, which allows use of this proposed syntax.\n\n### `esproposal.class_static_fields` *`(enable|ignore|warn)`* ‚â§0.148 \n\nSet this to `warn` to indicate that Flow should give a warning on use of static [class fields](https://github.com/tc39/proposal-class-public-fields) per the pending spec.\n\nYou may also set this to `ignore` to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class).\n\nThe default value of this option is `enable`, which allows use of this proposed syntax.\n\n### `esproposal.decorators` *`(ignore|warn)`* ‚â§0.148 \n\nSet this to `ignore` to indicate that Flow should ignore decorators.\n\nThe default value of this option is `warn`, which gives a warning on use since this proposal is still very early-stage.\n\n### `esproposal.export_star_as` *`(enable|ignore|warn)`* ‚â§0.148 \n\nSet this to `enable` to indicate that Flow should support the `export * as` syntax from [leebyron‚Äôs proposal](https://github.com/leebyron/ecmascript-more-export-from).\n\nYou may also set this to `ignore` to indicate that Flow should simply ignore the syntax. The default value of this option is `warn`, which gives a warning on use since this proposal is still very early-stage.\n\n### `esproposal.optional_chaining` *`(enable|ignore|warn)`* ‚â§0.148 \n\nSet this to `enable` to indicate that Flow should support the use of [optional chaining](https://github.com/tc39/proposal-optional-chaining) per the pending spec.\n\nYou may also set this to `ignore` to indicate that Flow should simply ignore the syntax.\n\nThe default value of this option is `warn`, which gives a warning on use since this proposal is still very early-stage.\n\n### `esproposal.nullish_coalescing` *`(enable|ignore|warn)`* ‚â§0.148 \n\nSet this to `enable` to indicate that Flow should support the use of [nullish coalescing](https://github.com/tc39/proposal-nullish-coalescing) per the pending spec.\n\nYou may also set this to `ignore` to indicate that Flow should simply ignore the syntax.\n\nThe default value of this option is `warn`, which gives a warning on use since this proposal is still very early-stage.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/options](https://flow.org/en/docs/config/options)"
- name: .flowconfig [untyped]
  id: config/untyped
  summary: Flow needs to know which files to parse and of those how to handle any Flow types within them
  description: "# .flowconfig \\[untyped\\]\n\nFlow needs to know which files to parse and of those how to handle any Flow types within them. For third party libraries you may wish to not parse, parse but not preserve types, or parse but not raise errors, depending on the quality and compatibility of their Flow implementation.\n\nDifferent sections are available to specify different behaviours, and by combining them most use cases are expected to be met.\n\n## `[untyped]`\n\nThe `[untyped]` section in a `.flowconfig` file tells Flow to not typecheck files matching the specified regular expressions and instead throw away types and treat modules as `any`.\n\nThis is different from the `[ignore]` config section that causes matching files to be ignored by the module resolver, which inherently makes them un-typechecked, and also unresolvable by `import` or `require`. When ignored `[libs]` must then be specified for each `import` using `flow-typed`, which may not always be desired.\n\nIt is also different from the `[declarations]` section. This also does not typecheck the file contents, but `[declarations]` does extract and use the signatures of functions, classes, etc, when checking other code.\n\n`[untyped]` instead causes a file to be ignored by the typechecker as if it had `noflow` in it, resolve modules as `any` type, but allow them to NOT be ignored by the module resolver. Any matching file is skipped by Flow (not even parsed, like other `noflow` files!), but can still be `require()`‚Äòd.\n\nThings to keep in mind:\n\n1.  These are [OCaml regular expressions](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp).\n2.  These regular expressions match against absolute paths. They probably should start with `.*`\n\nAn example `[untyped]` section might look like:\n\n``` plaintext\n[untyped]\n.*/third_party/.*\n.*/src/\\(foo\\|bar\\)/.*\n.*\\.untype\\.js\n```\n\nThis `[untyped]` section will parse:\n\n1.  Any file or directory under a directory named `third_party`\n2.  Any file or directory under `.*/src/foo` or under `.*/src/bar`\n3.  Any file that ends with the extension `.untype.js`\n\nStarting with Flow v0.23.0, you may use the `<PROJECT_ROOT>` placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project‚Äôs root directory. This is useful for writing regular expressions that are relative rather than absolute.\n\nFor example, you can write:\n\n``` plaintext\n[untyped]\n<PROJECT_ROOT>/third_party/.*\n```\n\nWhich would parse in declaration mode any file or directory under the directory named `third_party/` within the project root. However, unlike the previous example‚Äôs `.*/third_party/.*`, it would NOT parse files or directories under directories named `third_party/`, like `src/third_party/`.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/untyped](https://flow.org/en/docs/config/untyped)"
- name: .flowconfig [version]
  id: config/version
  summary: You can specify in the .flowconfig which version of Flow you expect to use
  description: "# .flowconfig \\[version\\]\n\nYou can specify in the `.flowconfig` which version of Flow you expect to use. You do this with the `[version]` section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.\n\nSo if you have the following in your `.flowconfig`:\n\n``` plaintext\n[version]\n0.22.0\n```\n\nand you try to use Flow v0.21.0, then Flow will immediately error with the message\n\n`\"Wrong version of Flow. The config specifies version 0.22.0 but this is version 0.21.0\"`\n\nSo far, we support the following ways to specify supported versions\n\n- Explicit versions, (e.g. `0.22.0`, which only matches `0.22.0`).\n- Intersection ranges, which are ANDed together, (e.g. `>=0.13.0 <0.14.0`, which matches `0.13.0` and `0.13.5` but not `0.14.0`).\n- Caret ranges, which allow changes that do not modify the left-most non-zero digit (e.g. `^0.13.0` expands into `>=0.13.0 <0.14.0`, and `^0.13.1` expands into `>=0.13.1 <0.14.0`, whereas `^1.2.3` expands into `>=1.2.3 <2.0.0`).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/config/version](https://flow.org/en/docs/config/version)"
- name: Any Types
  id: types/any
  summary: 'Warning: Do not mistake any with mixed'
  description: "# Any Types\n\n> **Warning:** Do not mistake `any` with `mixed`. [Read more](../mixed)\n\nIf you want a way to opt-out of using the type checker, `any` is the way to do it. **Using `any` is completely unsafe, and should be avoided whenever possible.**\n\nFor example, the following code will not report any errors:\n\n``` javascript\n// @flow\nfunction add(one: any, two: any): number {\n  return one + two;\n}\n\nadd(1, 2);     // Works.\nadd(\"1\", \"2\"); // Works.\nadd({}, []);   // Works.\n```\n\nEven code that will cause runtime errors will not be caught by Flow:\n\n``` javascript\n// @flow\nfunction getNestedProperty(obj: any) {\n  return obj.foo.bar.baz;\n}\n\ngetNestedProperty({});\n```\n\nThere are only a couple of scenarios where you might consider using `any`:\n\n1.  When you are in the process of converting existing code to using Flow types and you are currently blocked on having the code type checked (maybe other code needs to be converted first).\n2.  When you are certain your code works and for some reason Flow is unable to type check it correctly. There are a (decreasing) number of idioms in JavaScript that Flow is unable to statically type.\n\n## Avoid leaking `any`\n\nWhen you have a value with the type `any`, you can cause Flow to infer `any` for the results of all of the operations you perform.\n\nFor example, if you get a property on an object typed `any`, the resulting value will also have the type `any`.\n\n``` javascript\n// @flow\nfunction fn(obj: any) {\n  let foo /* (:any) */ = obj.foo;\n}\n```\n\nYou could then use the resulting value in another operation, such as adding it as if it were a number and the result will also be `any`.\n\n``` javascript\n// @flow\nfunction fn(obj: any) {\n  let foo /* (:any) */ = obj.foo;\n  let bar /* (:any) */ = foo * 2;\n}\n```\n\nYou could continue this process until `any` has leaked all over your code.\n\n``` javascript\n// @flow\nfunction fn(obj: any) /* (:any) */ {\n  let foo /* (:any) */ = obj.foo;\n  let bar /* (:any) */ = foo * 2;\n  return bar;\n}\n\nlet bar /* (:any) */ = fn({ foo: 2 });\nlet baz /* (:any) */ = \"baz:\" + bar;\n```\n\nPrevent this from happening by cutting `any` off as soon as possible by casting it to another type.\n\n``` javascript\n// @flow\nfunction fn(obj: any) {\n  let foo: number = obj.foo;\n}\n```\n\nNow your code will not leak `any`.\n\n``` javascript\n// @flow\nfunction fn(obj: any) /* (:number) */ {\n  let foo: number = obj.foo;\n  let bar /* (:number) */ = foo * 2;\n  return bar;\n}\n\nlet bar /* (:number) */ = fn({ foo: 2 });\nlet baz /* (:string) */ = \"baz:\" + bar;\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/any](https://flow.org/en/docs/types/any)"
- name: Array Types
  id: types/arrays
  summary: 'Note: Arrays are also sometimes used as tuples in JavaScript, these are annotated differently in Flow'
  description: "# Array Types\n\n> **Note:** Arrays are also sometimes used as tuples in JavaScript, these are annotated differently in Flow. See the Tuple docs for more information.\n\nArrays are a special list-like type of object in JavaScript. You can create arrays a couple different ways.\n\n``` javascript\nnew Array(1, 2, 3); // [1, 2, 3];\nnew Array(3);       // [undefined, undefined, undefined]\n[1, 2, 3];          // [1, 2, 3];\n```\n\nYou can also create arrays and add values to them later on:\n\n``` javascript\nlet arr = []; // []\narr[0] = 1;   // [1]\narr[1] = 2;   // [1, 2]\narr[2] = 3;   // [1, 2, 3]\n```\n\n## `Array` Type\n\nTo create an array type you can use `Array<Type>` type where `Type` is the type of elements in the array. For example, to create a type for an array of numbers you use `Array<number>`.\n\n``` javascript\nlet arr: Array<number> = [1, 2, 3];\n```\n\nYou can put any type within `Array<Type>`.\n\n``` javascript\nlet arr1: Array<boolean> = [true, false, true];\nlet arr2: Array<string> = [\"A\", \"B\", \"C\"];\nlet arr3: Array<mixed> = [1, true, \"three\"]\n```\n\n## `Array` Type Shorthand Syntax\n\nThere‚Äôs also a slightly shorter form of this syntax: `Type[]`.\n\n``` javascript\nlet arr: number[] = [0, 1, 2, 3];\n```\n\nJust note that `?Type[]` is the equivalent of `?Array<T>` and not `Array<?T>`.\n\n``` javascript\n// @flow\nlet arr1: ?number[] = null;   // Works!\nlet arr2: ?number[] = [1, 2]; // Works!\nlet arr3: ?number[] = [null]; // Error!\n```\n\nIf you want to make it `Array<?T>` you can use parenthesis like: `(?Type)[]`\n\n``` javascript\n// @flow\nlet arr1: (?number)[] = null;   // Error!\nlet arr2: (?number)[] = [1, 2]; // Works!\nlet arr3: (?number)[] = [null]; // Works!\n```\n\n## Array access is unsafe\n\nWhen you retrieve an element from an array there is always a possibility that it is `undefined`. You could have either accessed an index which is out of the bounds of the array, or the element could not exist because it is a ‚Äúsparse array‚Äù.\n\nFor example, you could be accessing an element that is out of the bounds of the array.\n\n``` javascript\n// @flow\nlet array: Array<number> = [0, 1, 2];\nlet value: number = array[3]; // Works.\n                       // ^ undefined\n```\n\nOr you could be accessing an element that does not exist if it is a ‚Äúsparse array‚Äù.\n\n``` javascript\n// @flow\nlet array: Array<number> = [];\n\narray[0] = 0;\narray[2] = 2;\n\nlet value: number = array[1]; // Works.\n                       // ^ undefined\n```\n\nIn order to make this safe, Flow would have to mark every single array access as ‚Äú*possibly undefined‚Äù*.\n\nFlow does not do this because it would be extremely inconvenient to use. You would be forced to refine the type of every value you get when accessing an array.\n\n``` javascript\nlet array: Array<number> = [0, 1, 2];\nlet value: number | void = array[1];\n\nif (value !== undefined) {\n  // number\n}\n```\n\nAs Flow is made to be smarter it may be possible in the future to fix this problem, but for now you should be aware of it.\n\n## `$ReadOnlyArray<T>`\n\nSimilar to [`$ReadOnly<T>`](../utilities#toc-readonly), it is the supertype of all arrays and all tuples and represents a read-only view of an array. It does not contain any methods that will allow an object of this type to be mutated (no `push()`, `pop()`, etc.).\n\n``` javascript\n// @flow\nconst readonlyArray: $ReadOnlyArray<number> = [1, 2, 3]\n\nconst first = readonlyArray[0] // OK to read\nreadonlyArray[1] = 20          // Error!\nreadonlyArray.push(4)          // Error!\n```\n\nNote that an array of type `$ReadOnlyArray<T>` can still have mutable *elements*:\n\n``` javascript\n// @flow\nconst readonlyArray: $ReadOnlyArray<{x: number}> = [{x: 1}];\nreadonlyArray[0] = {x: 42}; // Error!\nreadonlyArray[0].x = 42; // OK\n```\n\nThe main advantage to using `$ReadOnlyArray` instead of `Array` is that `$ReadOnlyArray`‚Äôs type parameter is *covariant* while `Array`‚Äôs type parameter is *invariant*. That means that `$ReadOnlyArray<number>` is a subtype of `$ReadOnlyArray<number | string>` while `Array<number>` is NOT a subtype of `Array<number | string>`. So it‚Äôs often useful to use `$ReadOnlyArray` in type annotations for arrays of various types of elements. Take, for instance, the following scenario:\n\n``` javascript\n// @flow\nconst someOperation = (arr: Array<number | string>) => {\n  // Here we could do `arr.push('a string')`\n}\n\nconst array: Array<number> = [1]\nsomeOperation(array) // Error!\n```\n\nSince the parameter `arr` of the `someOperation` function is typed as a mutable `Array`, pushing a string into it would be possible inside that scope, which would then break the type contract of the outside `array` variable. By annotating the parameter as `$ReadOnlyArray` instead in this case, Flow can be sure this won‚Äôt happen and no errors will occur:\n\n``` javascript\n// @flow\nconst someOperation = (arr: $ReadOnlyArray<number | string>) => {\n  // Nothing can be added to `arr`\n}\n\nconst array: Array<number> = [1]\nsomeOperation(array) // Works!\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/arrays](https://flow.org/en/docs/types/arrays)"
- name: Atom
  id: editors/atom
  summary: If you‚Äôre using Atom you have a bunch of options to integrate Flow into your code base
  description: "# Atom\n\nIf you‚Äôre using [Atom](https://atom.io) you have a bunch of options to integrate Flow into your code base.\n\n## Flow for Atom IDE\n\n``` sh\napm install atom-ide-ui && apm install ide-flowtype\n```\n\n[Flow for Atom IDE](https://atom.io/packages/ide-flowtype) is extracted from [Nuclide](https://nuclide.io), and works with the [Atom IDE](https://ide.atom.io/) UI. It brings the core features you expect in a full-featured IDE into Atom, such as language-aware autocomplete, diagnostics, go-to-definition, type hints, and symbol outlines.\n\n## Flow-IDE\n\n``` sh\napm install flow-ide\n```\n\n[Flow-IDE](https://atom.io/packages/flow-ide) is a smaller package that only provides you with a linter and autocomplete functionality. It, too, currently lacks support for on-the-fly linting.\n\n## Linter-Flow\n\n``` sh\napm install linter-flow\n```\n\nIn case you‚Äôre looking for something even more minimal, [linter-flow](https://atom.io/packages/linter-flow) may be worth your attention. It only lints your code and provides no other features, but it does support on-the-fly linting.\n\n## Autocomplete-Flow\n\n``` sh\napm install autocomplete-flow\n```\n\n[autocomplete-flow](https://atom.io/packages/autocomplete-flow) is another purpose-built tool that only does one thing. This package, as the name suggests, will give your flow enabled code autocomplete suggestions and nothing else.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors/atom](https://flow.org/en/docs/editors/atom)"
- name: Babel
  id: tools/babel
  summary: Flow and Babel are designed to work great together
  description: "# Babel\n\nFlow and [Babel](http://babeljs.io/) are designed to work great together. It takes just a few steps to set them up together.\n\nIf you don‚Äôt have Babel setup already, you can do that by following [this guide](http://babeljs.io/docs/setup/).\n\nOnce you have Babel setup, install `@babel/preset-flow` with either [Yarn](https://yarnpkg.com/) or [npm](https://www.npmjs.com/).\n\n``` sh\nyarn add --dev @babel/preset-flow\n# or\nnpm install --save-dev @babel/preset-flow\n```\n\nThen add `flow` to your Babel presets config.\n\n``` json\n{\n  \"presets\": [\"@babel/preset-flow\"]\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/tools/babel](https://flow.org/en/docs/tools/babel)"
- name: Children
  id: react/children
  summary: React elements can have zero, one, or many children
  description: "# Children\n\nReact elements can have zero, one, or many children. Being able to type these children with Flow allows you to build expressive APIs with React children.\n\nGenerally, the type you should first try when adding a type for the children of your React component is [`React.Node`](../types#toc-react-node).\n\nLike this:\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  children?: React.Node,\n};\n\nfunction MyComponent(props: Props) {\n  return <div>{props.children}</div>;\n}\n```\n\n> **Note:** You need to use `import * as React from 'react'` here instead of `import React from 'react'` to get access to the [`React.Node`](../types#toc-react-node) type. We explain why that is in the [React Type Reference](../types).\n\nHowever, if you want to do anything more powerful with the React children API then you will need a strong intuition of how React handles children. Let us look at a couple of cases before continuing to help build that intuition.\n\nIf you already have a strong intuition about how React children work then feel free to [skip to our examples demonstrating how to type various children patterns that commonly show up in React components](#examples).\n\nOur first case is an element with no children:\n\n``` javascript\n<MyComponent />;\n\n// which is the same as...\nReact.createElement(MyComponent, {});\n```\n\nIf you pass in no children when creating an element of `MyComponent` then `props.children` will not be set. If you try to access `props.children`, it will be undefined.\n\nWhat happens when you have a single child?\n\n``` javascript\n<MyComponent>{42}</MyComponent>;\n\n// which is the same as...\nReact.createElement(MyComponent, {}, 42);\n```\n\nIf you pass in a single value then `props.children` will be *exactly* that single value. Here `props.children` will be the number 42. Importantly, `props.children` will not be an array! It will be *exactly* the number 42.\n\nWhat happens when you have multiple children?\n\n``` javascript\n<MyComponent>{1}{2}</MyComponent>;\n\n// which is the same as...\nReact.createElement(MyComponent, {}, 1, 2);\n```\n\nNow, if you pass two values then `props.children` will be an array. Specifically in this case `props.children` will be `[1, 2]`.\n\nMultiple children may also look like:\n\n``` javascript\n<MyComponent>{'hello'} world</MyComponent>;\n\n// which is the same as...\nReact.createElement(MyComponent, {}, 'hello', ' world');\n```\n\nIn which `props.children` would be the array `['hello', ' world']`.\n\nor:\n\n``` javascript\n<MyComponent>{'hello'} <strong>world</strong></MyComponent>;\n\n// which is the same as...\nReact.createElement(\n  MyComponent,\n  {},\n  'hello',\n  ' ',\n  React.createElement('strong', {}, 'world'),\n);\n```\n\nIn which `props.children` would be the array `['hello', ' ', <strong>world</strong>]`.\n\nMoving on to the next case. What happens if we have a single child, but that child is an array?\n\n``` javascript\n<MyComponent>{[1, 2]}</MyComponent>;\n\n// which is the same as...\nReact.createElement(MyComponent, {}, [1, 2]);\n```\n\nThis follows the same rule that when you pass in a single child then `props.children` will be *exactly* that value. Even though `[1, 2]` is an array it is a single value and so `props.children` will be *exactly* that value. That is to say `props.children` will be the array `[1, 2]` and not an array of arrays.\n\nThis case happens often when you use `array.map()` such as in:\n\n``` javascript\n<MyComponent>\n  {messages.map(message => <strong>{message}</strong>)}\n</MyComponent>\n\n// which is the same as...\nReact.createElement(\n  MyComponent,\n  {},\n  messages.map(message => React.createElement('strong', {}, message)),\n);\n```\n\nSo a single array child is left alone, but what happens if we have multiple children that are arrays?\n\n``` javascript\n<MyComponent>{[1, 2]}{[3, 4]}</MyComponent>;\n\n// which is the same as...\nReact.createElement(MyComponent, {}, [1, 2], [3, 4]);\n```\n\nHere `props.children` will be an array of arrays. Specifically `props.children` will be `[[1, 2], [3, 4]]`.\n\nThe rule to remember with React children is that if you have no children then `props.children` will not be set, if you have one single child then `props.children` will be set to exactly that value, and if you have two or more children then `props.children` will be a new array of those values.\n\n> **Note:** Watch out for whitespace! Take the following:\n>\n> ``` plaintext\n> <MyComponent>{42}  </MyComponent>\n> ```\n>\n> This compiles to: `React.createElement(MyComponent, {}, 42, ' ')`. (With the spaces!) See how the spaces show up as part of the children? In this case `props.children` would be `[42, ' ']` and *not* the number 42. However, the following is fine:\n>\n> ``` plaintext\n> <MyComponent>\n>   {42}\n> </MyComponent>\n> ```\n>\n> It will compile to what you would expect: `React.createElement(MyComponent, {}, 42)`.\n>\n> Newlines and indentation after newlines are stripped, but watch out for whitespace when using a component with strict types around what children may be.\n\n> **Note:** Watch out for comments! Take the following:\n>\n> ``` plaintext\n> <MyComponent>\n>   // some comment...\n>   {42}\n> </MyComponent>\n> ```\n>\n> This compiles to: `React.createElement(MyComponent, {}, '// some comment...', 42)`. See how the comment is included in the element‚Äôs children? In this case `props.children` would be `['// some comment...', 42]` which includes the comment. To write comments in JSX use the following syntax:\n>\n> ``` plaintext\n> <MyComponent>\n>   {/* some comment... */}\n>   {42}\n> </MyComponent>\n> ```\n\nNow let's see how you would take this intuition and type the children of various React components.\n\n## Only allowing a specific element type as children.\n\nSometimes you only want a specific component as the children to your React component. This often happens when you are building a table component which needs specific column children components, or a tab bar which needs specific configuration for each tab. One such tab bar component that uses this pattern is React Native‚Äôs `<TabBarIOS>` component.\n\n[React Native‚Äôs `<TabBarIOS>` component](http://facebook.github.io/react-native/docs/tabbarios.html) only allows React element children and those elements *must* have a component type of `<TabBarIOS.Item>`. You are expected to use `<TabBarIOS>` like:\n\n``` javascript\n<TabBarIOS>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n</TabBarIOS>\n```\n\nYou are not allowed to do the following when using `<TabBarIOS>`:\n\n``` javascript\n<TabBarIOS>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n  <View>{/* ... */}</View>\n  <SomeOtherComponent>{/* ... */}</SomeOtherComponent>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n</TabBarIOS>\n```\n\nSee how we added `<View>` and `<SomeOtherComponent>` as children to `<TabBarIOS>`? This is not allowed and `<TabBarIOS>` will throw an error. How do we make sure Flow does not allow this pattern?\n\n``` javascript\nimport * as React from 'react';\n\nclass TabBarIOSItem extends React.Component<{}> {\n  // implementation...\n}\n\ntype Props = {\n  children: React.ChildrenArray<React.Element<typeof TabBarIOSItem>>,\n};\n\nclass TabBarIOS extends React.Component<Props> {\n  static Item = TabBarIOSItem;\n  // implementation...\n}\n\n<TabBarIOS>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n  <TabBarIOS.Item>{/* ... */}</TabBarIOS.Item>\n</TabBarIOS>;\n```\n\nWe set the type of props to `React.ChildrenArray<React.Element<typeof TabBarIOSItem>>` which will guarantee that `<TabBarIOS>` must only have children that are `TabBarIOS.Item` React elements.\n\nOur [types reference](../types) has more information about both [`React.ChildrenArray<T>`](../types#toc-react-childrenarray) and [`React.Element<typeof Component>`](../types#toc-react-element).\n\n> **Note:** If you want methods like `map()` and `forEach()` or to handle a [`React.ChildrenArray<T>`](../types#toc-react-childrenarray) as a normal JavaScript array then React provides the [`React.Children` API](https://facebook.github.io/react/docs/react-api.html#react.children) to do just this. It has functions like `React.Children.toArray(props.children)` that you can use to treat your [`React.ChildrenArray<T>`](../types#toc-react-childrenarray) as a flat array.\n\n## Enforcing that a component only gets a single child.\n\nSometimes you want to enforce that your component will *only* receive a single child. You could use [`React.Children.only()` function](https://facebook.github.io/react/docs/react-api.html#react.children.only) to enforce this constraint, but you could also enforce this in Flow. To do this, instead of wrapping the type for your children in [`React.ChildrenArray<T>`](../types#toc-react-childrenarray), specify a single element argument, like so:\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  children: React.Element<any>,\n};\n\nfunction MyComponent(props: Props) {\n  // implementation...\n}\n\n// Not allowed! You must have children.\n<MyComponent />;\n\n// Not ok! We have multiple element children.\n<MyComponent>\n  <div />\n  <div />\n  <div />\n</MyComponent>;\n\n// This is ok. We have a single element child.\n<MyComponent>\n  <div />\n</MyComponent>;\n```\n\n## Typing function children or other exotic children types.\n\nReact allows you to pass *any* value as the children of a React component. There are some creative uses of this capability such as using a function for children which could look like this:\n\n``` javascript\n<MyComponent>\n  {data => (\n    <div>{data.foo}</div>\n  )}\n</MyComponent>\n```\n\n`react-router` version 4 asks for a [function as the children to its `<Route>` component](https://reacttraining.com/react-router/core/api/Route/children-func). You would provide a function as the children to `react-router` like this:\n\n``` javascript\n<Route path={to}>\n  {({ match }) => (\n    <li className={match ? 'active' : ''}>\n      <Link to={to} {...rest}/>\n    </li>\n  )}\n</Route>\n```\n\n(Example adapted from the [`react-router` documentation](https://reacttraining.com/react-router/core/api/Route/children-func).)\n\nHere is how you would type the `<Route>` component in Flow:\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  children: (data: { match: boolean }) => React.Node,\n  path: string,\n  // other props...\n};\n\nclass Route extends React.Component<Props> {\n  // implementation...\n}\n\n<Route path={to}>\n  {({ match }) => (\n    <li className={match ? 'active' : ''}>\n      <Link to={to} {...rest}/>\n    </li>\n  )}\n</Route>;\n```\n\nThe type for `children` is a function that takes in some object type and returns a [`React.Node`](../types#toc-react-node) which is the type for any value that can be rendered by React. A `children` function does not need to return [`React.Node`](../types#toc-react-node). It could return any type, but in this case `react-router` wants to render the result returned by the `children` function.\n\nThis pattern is also not limited to function children. You could also pass in arbitrary object or class types.\n\n# Using `React.Node` but without some primitive types like strings.\n\n[`React.Node`](../types#toc-react-node) is the general type for children, but sometimes you might want to use [`React.Node`](../types#toc-react-node) while excluding some primitives like strings and numbers. [The React Native `<View>` component](http://facebook.github.io/react-native/docs/view.html) does this, for example.\n\n[The React Native `<View>` component](http://facebook.github.io/react-native/docs/view.html) will allow any primitive value or any React element as its children. However, `<View>` does not allow strings or numbers as children! You could use [`React.Node`](../types#toc-react-node) as the children type for `<View>`, however [`React.Node`](../types#toc-react-node) includes strings which we don‚Äôt want for `<View>`. So we need to create our own type.\n\n``` javascript\nimport * as React from 'react';\n\ntype ReactNodeWithoutStrings = React.ChildrenArray<\n  | void\n  | null\n  | boolean\n  | React.Element<any>\n>;\n\ntype Props = {\n  children?: ReactNodeWithoutStrings,\n  // other props...\n};\n\nclass View extends React.Component<Props> {\n  // implementation...\n}\n```\n\n[`React.ChildrenArray<T>`](../types#toc-react-childrenarray) is a type that models React nested array data structure for children. `ReactNodeWithoutStrings` uses [`React.ChildrenArray<T>`](../types#toc-react-childrenarray) to be an arbitrarily nested array of null, boolean, or React elements.\n\n[`React.Element<typeof Component>`](../types#toc-react-element) is the type of a React element like `<div/>` or `<MyComponent/>`. Notably elements are not the same as components!\n\n> **Note:** If you want methods like `map()` and `forEach()` or to handle a [`React.ChildrenArray<T>`](../types#toc-react-childrenarray) as a normal JavaScript array then React provides the [`React.Children` API](https://facebook.github.io/react/docs/react-api.html#react.children) to do just this. It has functions like `React.Children.toArray(props.children)` that you can use to treat your [`React.ChildrenArray<T>`](../types#toc-react-childrenarray) as a flat array.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/children](https://flow.org/en/docs/react/children)"
- name: Class Types
  id: types/classes
  summary: JavaScript classes in Flow operate both as a value and a type
  description: "# Class Types\n\nJavaScript [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) in Flow operate both as a value and a type.\n\nYou write classes the same way you would without Flow, but then you can use the name of the class as a type.\n\n``` javascript\nclass MyClass {\n  // ...\n}\n\nlet myInstance: MyClass = new MyClass();\n```\n\nThis is because classes in Flow are [nominally typed](https://flow.org/en/lang/nominal-structural).\n\n## Class Syntax\n\nClasses in Flow are identical to normal JavaScript classes, but with added types.\n\n#### Class Methods\n\nJust like in functions, class methods can have annotations for both parameters (input) and returns (output).\n\n``` javascript\nclass MyClass {\n  method(value: string): number { /* ... */ }\n}\n```\n\nAlso just like regular functions, class methods may have `this` annotations as well. However, if one is not provided, Flow will infer the class instance type (or the class type for static methods) instead of `mixed`. When an explicit `this` parameter is provided, it must be a [supertype](https://flow.org/en/lang/subtypes/) of the class instance type (or class type for static methods).\n\n``` javascript\nclass MyClass {\n  method(this : interface { x : string }): void { /* ... */ } // x is missing in `MyClass`\n}\n```\n\nUnlike class properties, however, class methods cannot be unbound or rebound from the class on which you defined them. So all of the following are errors in Flow:\n\n``` javascript\nlet c = new MyClass();\nc.method;\nlet {method} = c;\nc.method.bind({});\n```\n\n#### Class Fields (Properties)\n\nWhenever you want to use a class field in Flow you must first give it an annotation.\n\n``` javascript\n// @flow\nclass MyClass {\n  method() {\n    // $ExpectError\n    this.prop = 42; // Error!\n  }\n}\n```\n\nFields are annotated within the body of the class with the field name followed by a colon `:` and the type.\n\n``` javascript\n// @flow\nclass MyClass {\n  prop: number;\n  method() {\n    this.prop = 42;\n  }\n}\n```\n\nFields added outside of the class definition need to be annotated within the body of the class.\n\n``` javascript\n// @flow\nfunction func_we_use_everywhere (x: number): number {\n  return x + 1;\n}\nclass MyClass {\n  static constant: number;\n  static helper: (number) => number;\n  function_property: number => number;\n}\nMyClass.helper = func_we_use_everywhere\nMyClass.constant = 42\nMyClass.prototype.function_property = func_we_use_everywhere\n```\n\nFlow also supports using the [class properties syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#field_declarations).\n\n``` javascript\nclass MyClass {\n  prop = 42;\n}\n```\n\nWhen using this syntax, you are not required to give it a type annotation. But you still can if you need to.\n\n``` javascript\nclass MyClass {\n  prop: number = 42;\n}\n```\n\n#### Class Constructors\n\nYou can initialize your class properties in class constructors.\n\n``` javascript\nclass MyClass {\n  foo: number;\n\n  constructor() {\n    this.foo = 1;\n  }\n}\n```\n\nYou must first call `super(...)` in a derived class before you can access `this` and `super`.\n\n``` javascript\nclass Base {\n  bar: number;\n}\nclass MyClass extends Base {\n  foo: number;\n\n  constructor() {\n    this.foo; // Error\n    this.bar; // Error\n    super.bar; // Error\n    super();\n    this.foo; // OK\n    this.bar; // OK\n    super.bar; // OK\n  }\n}\n```\n\nHowever, Flow will not enforce that all class properties are initialized in constructors.\n\n``` javascript\nclass MyClass {\n  foo: number;\n  bar: number;\n\n  constructor() {\n    this.foo = 1;\n  }\n\n  useBar() {\n    (this.bar: number); // No errors.\n  }\n}\n```\n\n#### Class Generics\n\nClasses can also have their own [generics](../generics).\n\n``` javascript\nclass MyClass<A, B, C> {\n  property: A;\n  method(val: B): C {\n    // ...\n  }\n}\n```\n\nClass generics are [parameterized](../generics#toc-parameterized-generics). When you use a class as a type you need to pass parameters for each of its generics.\n\n``` javascript\n// @flow\nclass MyClass<A, B, C> {\n  constructor(arg1: A, arg2: B, arg3: C) {\n    // ...\n  }\n}\n\nvar val: MyClass<number, boolean, string> = new MyClass(1, true, 'three');\n```\n\n## Classes in annotations\n\nWhen you use the name of your class in an annotation, it means an *instance* of your class:\n\n``` javascript\n//@flow\nclass MyClass {}\n(MyClass: MyClass); // Error\n(new MyClass(): MyClass); // Ok\n```\n\nSee [here](../utilities#toc-class) for details on `Class<T>`, which allows you to refer to the type of the class in an annotation.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/classes](https://flow.org/en/docs/types/classes)"
- name: Comment Types
  id: types/comments
  summary: Flow supports a comment-based syntax, which makes it possible to use Flow without having to compile your files
  description: "# Comment Types\n\nFlow supports a comment-based syntax, which makes it possible to use Flow without having to compile your files.\n\n``` javascript\n// @flow\n\n/*::\ntype MyAlias = {\n  foo: number,\n  bar: boolean,\n  baz: string,\n};\n*/\n\nfunction method(value /*: MyAlias */) /*: boolean */ {\n  return value.bar;\n}\n\nmethod({ foo: 1, bar: true, baz: [\"oops\"] });\n```\n\nThese comments allow Flow to work in plain JavaScript files without any additional work.\n\n## Comment types syntax\n\nThere are two primary pieces of the syntax: type includes and type annotations.\n\n### Comment type include\n\nIf you want to have Flow treat a comment as if it were normal syntax, you can do so by adding a double colon `::` to the start of the comment.\n\n``` javascript\n/*::\ntype Foo = {\n  foo: number,\n  bar: boolean,\n  baz: string\n};\n*/\n\nclass MyClass {\n  /*:: prop: string; */\n}\n```\n\nThis includes the code into the syntax that Flow sees.\n\n``` javascript\ntype Foo = {\n  foo: number,\n  bar: boolean,\n  baz: string\n};\n\nclass MyClass {\n  prop: string;\n}\n```\n\nBut JavaScript ignores these comments, so all it has is the valid syntax.\n\n``` javascript\nclass MyClass {\n\n}\n```\n\nThis syntax is also available in a `flow-include` form.\n\n``` javascript\n/*flow-include\ntype Foo = {\n  foo: number,\n  bar: boolean,\n  baz: string\n};\n*/\n\nclass MyClass {\n  /*flow-include prop: string; */\n}\n```\n\n### Comment type annotation\n\nInstead of typing out a full include every time, you can also use the type annotation shorthand with a single colon `:` at the start of the comment.\n\n``` javascript\nfunction method(param /*: string */) /*: number */ {\n  // ...\n}\n```\n\nThis would be the same as including a type annotation inside an include comment.\n\n``` javascript\nfunction method(param /*:: : string */) /*:: : number */ {\n  // ...\n}\n```\n\n> **Note:** If you want to use optional function parameters you‚Äôll need to use the include comment form.\n\n> **Special thanks to**: [Jarno Rantanen](https://github.com/jareware) for building [flotate](https://github.com/jareware/flotate) and supporting us merging his syntax upstream into Flow.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/comments](https://flow.org/en/docs/types/comments)"
- name: Components
  id: react/components
  summary: Adding Flow types to your React components is incredibly powerful
  description: "# Components\n\nAdding Flow types to your React components is incredibly powerful. After typing your component, Flow will statically ensure that you are using the component in the way it was designed to be used.\n\nEarly in React‚Äôs history the library provided [`PropTypes`](https://facebook.github.io/react/docs/typechecking-with-proptypes.html) which performed basic runtime checks. Flow is much more powerful as it can tell you when you are misusing a component without running your code.\n\nThere are some Babel plugins which will generate `PropTypes` from Flow types such as [`babel-plugin-react-flow-props-to-prop-types`](https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types) if you want both static and runtime checks.\n\n## Class Components\n\nBefore we show how to type a React class component with Flow, let us first show how you would write a React class component *without* Flow but with React‚Äôs prop types. You would extend `React.Component` and add a static `propTypes` property.\n\n``` javascript\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nclass MyComponent extends React.Component {\n  static propTypes = {\n    foo: PropTypes.number.isRequired,\n    bar: PropTypes.string,\n  };\n\n  render() {\n    return <div>{this.props.bar}</div>;\n  }\n}\n```\n\nNow, let‚Äôs Flowify the component we just wrote:\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  foo: number,\n  bar?: string,\n};\n\nclass MyComponent extends React.Component<Props> {\n  render() {\n    this.props.doesNotExist; // Error! You did not define a `doesNotExist` prop.\n\n    return <div>{this.props.bar}</div>;\n  }\n}\n\n<MyComponent foo={42} />;\n```\n\nWe removed our dependency on `prop-types` and added a Flow object type named `Props` with the same shape as the prop types but using Flow‚Äôs static type syntax. Then we passed our new `Props` type into `React.Component` as a type argument.\n\nNow if you try to use `<MyComponent>` with a string for `foo` instead of a number you will get an error.\n\nNow wherever we use `this.props` in our React component Flow will treat it as the `Props` type we defined.\n\n> **Note:** If you don‚Äôt need to use the `Props` type again you could also define it inline: `extends React.Component<{ foo: number, bar?: string }>`.\n\n> **Note:** We import `React` as a namespace here with `import * as React from 'react'` instead of as a default with `import React from 'react'`. When importing React as an ES module you may use either style, but importing as a namespace gives you access to React‚Äôs [utility types](../types).\n\n`React.Component<Props, State>` is a [generic type](https://flow.org/en/types/generics/) that takes two type arguments. Props and state. The second type argument, `State`, is optional. By default it is undefined so you can see in the example above we did not include `State`. We will learn more about state in the next section‚Ä¶\n\n### Adding State\n\nTo add a type for state to your React class component then create a new object type, in the example below we name it `State`, and pass it as the second type argument to `React.Component`.\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = { /* ... */ };\n\ntype State = {\n  count: number,\n};\n\nclass MyComponent extends React.Component<Props, State> {\n  state = {\n    count: 0,\n  };\n\n  componentDidMount() {\n    setInterval(() => {\n      this.setState(prevState => ({\n        count: prevState.count + 1,\n      }));\n    }, 1000);\n  }\n\n  render() {\n    return <div>Count: {this.state.count}</div>;\n  }\n}\n\n<MyComponent />;\n```\n\nIn the example above we are using a [React `setState()` updater function](https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous) but you could also pass a partial state object to `setState()`.\n\n> **Note:** If you don‚Äôt need to use the `State` type again you could also define it inline: `extends React.Component<{}, { count: number }>`.\n\n### Using Default Props\n\nReact supports the notion of `defaultProps` which you can think of as default function arguments. When you create an element and you did not include a prop with a default then React will substitute that prop with its corresponding value from `defaultProps`. Flow supports this notion as well. To type default props add a `static defaultProps` property to your class.\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  foo: number, // foo is required.\n  bar: string, // bar is required.\n};\n\nclass MyComponent extends React.Component<Props> {\n  static defaultProps = {\n    foo: 42, // ...but we have a default prop for foo.\n  };\n}\n\n// So we don't need to include foo.\n<MyComponent bar={\"abc\"} />\n```\n\nFlow will infer the type of your default props from `static defaultProps` so you don‚Äôt have to add any type annotations to use default props.\n\n> **Note:** You don‚Äôt need to make `foo` nullable in your `Props` type. Flow will make sure that `foo` is optional if you have a default prop for `foo`.\n\nIf you would like to add a type annotation to `defaultProps` you can define the type as\n\n``` javascript\ntype DefaultProps = {|\n  foo: number,\n|}\n```\n\nand spread that into the `Props` type:\n\n``` javascript\ntype Props = {\n  ...DefaultProps,\n  bar: string,\n}\n```\n\nThis way you avoid duplicating the properties that happen to have a default value.\n\n## Stateless Functional Components\n\nIn addition to classes, React also supports stateless functional components. You type these components like you would type a function:\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  foo: number,\n  bar?: string,\n};\n\nfunction MyComponent(props: Props) {\n  props.doesNotExist; // Error! You did not define a `doesNotExist` prop.\n\n  return <div>{props.bar}</div>;\n}\n\n<MyComponent foo={42} />\n```\n\n### Using Default Props for Functional Components\n\nReact also supports default props on stateless functional components. Similarly to class components, default props for stateless functional components will work without any extra type annotations.\n\n``` javascript\nimport * as React from 'react';\n\ntype Props = {\n  foo: number, // foo is required.\n};\n\nfunction MyComponent(props: Props) {}\n\nMyComponent.defaultProps = {\n  foo: 42, // ...but we have a default prop for foo.\n};\n\n// So we don't need to include foo.\n<MyComponent />;\n```\n\n> **Note:** You don‚Äôt need to make `foo` nullable in your `Props` type. Flow will make sure that `foo` is optional if you have a default prop for `foo`.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/components](https://flow.org/en/docs/react/components)"
- name: Constrained Writes
  id: lang/constrained-writes
  summary: As of Flow v0.186.0, unannotated variables will be inferred to have a precise type by their initializer or initial assignment, and all subsequent assignments to that variable will be constrained by this type
  description: "# Constrained Writes\n\nAs of Flow v0.186.0, unannotated variables will be inferred to have a precise type by their initializer or initial assignment, and all subsequent assignments to that variable will be constrained by this type. This page shows some examples of how Flow determines what type an unannotated variable is inferred to have.\n\n**If you want a variable to have a different type than what Flow infers for it, you can always add a type annotation to the variable‚Äôs declaration. That will override everything discussed in this page!**\n\n## Variables initialized at their declarations\n\nThe common case for unannotated variables is very straightforward: when a variable is declared with an initializer that is not the literal `null`, that variable will from then on have the type of the initializer, and future writes to the variable will be constrained by that type [(try flow)](https://flow.org/try/#0JYWwDg9gTgLgBAKjgQwM5wEoFNkGN4BmUEIcA5FDvmQNwBQdMAnmFnAArFjoC8cA3gB84YLgC44IYAA8sAEziCAvvTpysuADbJKcAG4640iQDsAriABGWKPXVadbA1DhNTF67bUbtu5yK5UCU4IblVNLHhRCDkzfDg+AFlkGAALADpUAEdYAAppAEo4AGpXegB6crgAA2jY-Gq4VLQ4ZlYa8ysbaroI+ABhEkgTLBN4Plz+aLAlYMCingA+AThKGDMoEzgAHkWpriVt8uWlOkqawfAIEbHG5vQ2rGrsPBh0y+HRmAAVFixtkLcRY9PpwLAREBfBI7D7XKH8dKI6aoJRwY5wM5VargrCQ25NFqPGovfDpACiEK+2xJb1hNx+fwBgUWwKAA):\n\n``` javascript\nlet product = Math.sqrt(x) * y;\n// `product` has type `number`\nlet Component = ({prop}: Props) => { return <>{prop}</> }\n// `Component` has type`React.ComponentType<Props>`\nlet element = <Component {...props} />\n// `element` has type `React.Element<React.ComponentType<Props>>`\n```\n\nAny subsequent assignments to `product`, `Component`, or `element` will be checked against the types that Flow infers for the initializers, and if conflicting types are assigned, Flow will signal an error [(try flow)](https://flow.org/try/#0JYWwDg9gTgLgBAKjgQwM5wEoFNkGN4BmUEIcA5FDvmQNwBQdMAnmFnAArFjoC8cA3gB84YLgC44IYAA8sAEziCAvvTpysuADbJKcAG4640iQDsAriABGWKPXVadbA1DhNTF67bUbtu5yK5UCU4IblVNLHhRCDkzfDg+AFlkGAALADpUAEdYAAppAEo4AGpXegB6crgAA2jY-Gq4VLQ4ZlYa8ysbaroI+ABhEkgTLBN4Plz+aLAlYMCingA+AThKGDMoEzgAHkWpriVt8uWlOkqawfAIEbHG5vQ2rGrsPBh0y+HRmAAVFixtkLcRY9PpwLAREBfBI7D7XKH8dKI6aoJRwY5wM5VargrCQ25NFqPGovfDpACiEK+2xJb1hNx+fwBgUWwIYRIA8mkbIDeAJhBAuVAAPrTCRSWQKZR2HyOfSGTmpGx0r4SXIK7nzBLLGnpAByMSw0ocfkMAsVwuREnVUB5DHO+pgbDSKTguVwG0oY00TCKMCgTAAtARNBAAO5wOQQLCoExkeDNPROxVwEbh6wJ4DQOAQAhwMwmZAmEwClLyOVQYDISwRVCYsEF6vyAA0cFQEDgwHgkejsfgqCwSejbBaNmIUFQ6TodTi4zgACJ2RsU1hw9P4sAJ4i5zQ0VUyVAx3RlWNoZMzTYRQcrYKeQtlvxVpENltdvxzxaDkcTjvzvvDzi8VnbZrWPeAEURd9L1CFE0UWH89wPaAgA):\n\n``` javascript\nproduct = \"Our new product is...\"; // Error\nComponent = ({other_prop}: OtherProps) => { return <>{other_prop}</> }; // Error\nelement = <OtherComponent {...other_props} />; // Error\n```\n\nIf you want these examples to typecheck, and for Flow to realize that different kinds of values can be written to these variables, you must add a type annotation reflecting this more general type to their declarations [(try flow)](https://flow.org/try/#0JYWwDg9gTgLgBAKjgQwM5wEoFNkGN4BmUEIcA5FDvmQNwBQdMAnmFnAArFjoC8cA3gB84YLgC44IYAA8sAEziCAvvTpysuADbJKcAG4640iQDsAriABGWKPXVadbA1DhNTF67bUbtu5yK5UCU4IblVNLHhRCDkzfHcrG0U4VBgoYBMAczg+AFlkGAALADpUAEdYAAppAEo4AGpXcMi4AGESSBMsExgJKVkFPkr+aLAlYMC6ngA+AThKGDMoEzgAHmmRriVVgHpZpTodnbgAOQg4TIgYuGZWG-PKUSxUbvgi4FQAQkxntLjF3S4GJsDKpHByBgReBYCIgV4SbB4GDFM7qHJraa7WYMRgsNgAeSKNhC3HRQjgECJUAA+qM+jJ5IoVN4HH5DITCjZ2uAIF0ehJKhziZMcrNEfgUcC7D5HPpDJTOTTRkE4EKoCTUAxorF8OiAET4pZwLoAdwCMX+cA+xRtevo3M6r3RwwVNlpWwkao1U1m-HmkSWK3W-FdSq2WLgKjgdBhWDhPXRqzVDt5Tv4NuKofdoVQSjgexocCAA):\n\n``` javascript\nlet product: number | string = ...\nlet Component: mixed = ... // No good type to represent this! Consider restructuring\nlet element: React.Node = ...\n```\n\n## Variables declared without initializers\n\nOften variables are declared without initializers. In such cases, Flow will try to choose the ‚Äúfirst‚Äù assignment or assignments to the variable to define its type. ‚ÄúFirst‚Äù here means both top-to-bottom and nearer-scope to deeper-scope‚Äîwe‚Äôll try to choose an assignment that happens in the same function scope as the variable‚Äôs declaration, and only look inside nested functions if we don‚Äôt find any assignments locally [(try flow)](https://flow.org/try/#0DYUwLgBGD2AOAyIBuJgEEDOGCWBzAdiACYDcAUGQGYCu+AxmNtPhABaqwgBOAFAJQQA3mQhQ4iFOix5CRCAF4IAFgBMJCAHoNEAKJcu0LhGwtqsOtAC2J3BBRcczCNEoQAYsGgB3AFwQABjAIyKiYOATE-mwAhhhQAJ6cARhgXDb+ZAC+FEESodIRcooARAASqJ4QXobARMXqWhAAKqzYcV5pYCAQRODc1oRxYOx20VwA5EOJIGS5IVLhsgpQXNQgDdp6BkYmEGYWA7b2jiwu7p6+AXOSYTKRMVNJ-ilp+Lj+QA).\n\n``` javascript\nlet topLevelAssigned;\n\nfunction helper() {\n  topLevelAssigned = 42; // Error: `topLevelAssigned` has type `string`\n}\n\ntopLevelAssigned = \"Hello world\"; // This write determines the var's type\ntopLevelAssigned = true; // Error: `topLevelAssigned` has type `string`\n```\n\nIf there are two or more possible ‚Äúfirst assignments,‚Äù due to an if or switch statement, they‚Äôll both count‚Äîthis is one of the few ways that Flow will still infer unions for variable types [(try flow)](https://flow.org/try/#0CYUwxgNghgTiAEA3W8wHsB2wCWAXbmAXPAEZpoQhQYDcAUHZbvALYCeAcgK4skgwB5GAGVcMbBgDm9OtgBm8ABToseAhgCU8AN514rTjz6CRYiZPgBeeABYATPQC+8EBADOCXfvbde-IaLiUlbwAEQAEq4QaPAA7mgwEMChTgw+Rv6mQRbWdgCMNPAA9EXwchIgdOl+JoHmIaEA4uTAJGwgKcWl5RiV1cYBZsHWclDuIIUl8ACiMDAJ8BLwXAAO6Cz1iPxu6vBoCgBi0bHEAAb9mXVSp-AAFlBu8LhsKwinGBkw8AA+8G5DklOQA):\n\n``` javascript\nlet myNumberOrString;\n\nif (condition) {\n  myNumberOrString = 42; // Determines type\n} else {\n  myNumberOrString = \"Hello world\"; // Determines type\n}\n\nmyNumberOrString = 21; // fine, compatible with type\nmyNumberOrString = \"Goodbye\"; // fine, compatible with type\nmyNumberOrString = false; // Error: `myNumberOrString` has type `number | string`\n```\n\nThis only applies when the variable is written to in both branches, however. If only one branch contains a write, that write becomes the type of the variable afterwards (though Flow will still check to make sure that the variable is definitely initialized) [(try flow)](https://flow.org/try/#0CYUwxgNghgTiAEA3W8wHsB2wCWAXbmAXPAEZpoQhQYDcAUHZbvJiAEIzVgAWAggM79sAcwwhg9OtgBm8ABToseAhgCU8AN514LMRy59BIscHgBeeACIAEiAgQ08AO5oYEYAEJL9AL4NW+hg8AkKi4gB0uGgAqgAOsSAwAMJQ-CByqjTwAPTZ8ACiMDCuxAAGAZxBhqEmpfAAtlAAnqQIAK4Y2J34UBDYAF7idBUGIcbi5vAALABMWbkFRa7wXfBtsej1XcJIiUKYLLIAYg5OZSNVY2HAddyp8LhNCfCl-Lgw26VAA):\n\n``` javascript\nlet oneBranchAssigned;\n\nif (condition) {\n  oneBranchAssigned = \"Hello world!\";\n}\n\noneBranchAssigned.toUpperCase(); // Error: `oneBranchAssigned` may be uninitialized\noneBranchAssigned = 42; // Error: `oneBranchAssigned` has type `string`\n```\n\n## Variables initialized to `null`\n\nFinally, the one exception to the general principle that variable‚Äôs types are determined by their first assignment(s) is when a variable is initialized as (or whose first assignment is) the literal value `null`. In such cases, the *next* non-null assignment (using the same rules as above) determines the rest of the variable‚Äôs type, and the overall type of the variable becomes a union of `null` and the type of the subsequent assignment. This supports the common pattern where a variable starts off as `null` before getting assigned by a value of some other type [(try flow)](https://flow.org/try/#0GYVwdgxgLglg9mABMGYAmBJAIgNQIYA2IApgDwAqAfABRozQBciA3gNoDWxAnkwM5QAnVAHMAuk3IBfAJQSWAKESICxKIhhp8BRAF5EYEAQIBuRAHoz6sDFiEYAL2JpEeXogAGBo+8XI4AxGoIBH5ETi4rRDpoaQUlJRhgQPDdHT0Acmx02OZfePVNQl0o+igOblFTC0QMMGBiAKgACzw1dw0td0QWtyguAAdiDy9tAB9Ech98yV8ZhKTqDqK0vRGcvMRmgTgAd31iPYBRAW2BagAiADk4RGIwQQjgfxqsAEJz6WNZ3wFVEAEkEsTPJJEA).\n\n``` javascript\nfunction findIDValue<T>(dict: {[key: string]: T}): T {\n  let idVal = null; // initialized as `null`\n  for (const key in dict) {\n    if (key === 'ID') {\n      idVal = dict[key]; // Infer that `idVal` has type `null | T`\n    }\n  }\n  if (idVal === null) {\n    throw new Error(\"No entry for ID!\");\n  }\n  return idVal;\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/constrained-writes](https://flow.org/en/docs/lang/constrained-writes)"
- name: Context
  id: react/context
  summary: Flow can typecheck your React components that use the context API introduced in React 16.3
  description: "# Context\n\nFlow can typecheck your React components that use the [context API](https://reactjs.org/docs/context.html) introduced in React 16.3.\n\n> **Note:** Typing context values requires Flow 0.70 or later.\n\nFlow will infer types from the way you use a context‚Äôs `{ Provider, Consumer }` pair:\n\n``` javascript\nimport React from \"react\";\n\nconst Theme = React.createContext();\n\n<Theme.Provider value=\"light\" />;\n\n<Theme.Consumer>{value => value.toUpperCase()}</Theme.Consumer>; // Error! `value` is nullable.\n\n<Theme.Consumer>\n  {value =>\n    value\n      ? value.toUpperCase() // Valid: `value` is a string.\n      : null\n  }\n</Theme.Consumer>;\n```\n\nIf your context has a default value, Flow will type your consumer component accordingly:\n\n``` javascript\nimport React from \"react\";\n\nconst Theme = React.createContext(\"light\");\n\n<Theme.Consumer>{value => value.toUpperCase()}</Theme.Consumer>; // Valid: `value` is a non-nullable string.\n```\n\nTo explicitly specify the type of a context value, pass a type parameter to `createContext`:\n\n``` javascript\nimport React from \"react\";\n\nconst Theme = React.createContext<\"light\" | \"dark\">(\"light\");\n\n<Theme.Provider value=\"blue\" />; // Error! \"blue\" is not one of the allowed values.\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/context](https://flow.org/en/docs/react/context)"
- name: Create React App
  id: tools/create-react-app
  summary: Create React App already supports Flow by default
  description: "# Create React App\n\n[Create React App](https://github.com/facebookincubator/create-react-app) already supports Flow by default. All you need to do is [install Flow](https://flow.org/en/install/) and create a `.flowconfig` file by running `flow init`.\n\n``` sh\ncreate-react-app my-app && cd my-app\nyarn add --dev flow-bin\nyarn run flow init\n```\n\nFlow will be run as part of create-react-app‚Äôs scripts.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/tools/create-react-app](https://flow.org/en/docs/tools/create-react-app)"
- name: Creating Library Definitions
  id: libdefs/creation
  summary: Before spending the time to write your own libdef, we recommend that you look to see if there is already a libdef for the third-party code that you‚Äôre addressing
  description: "# Creating Library Definitions\n\nBefore spending the time to write your own libdef, we recommend that you look to see if there is already a libdef for the third-party code that you‚Äôre addressing. `flow-typed` is a [tool and repository](https://github.com/flowtype/flow-typed/) for sharing common libdefs within the Flow community ‚Äì so it‚Äôs a good way to knock out a good chunk of any public libdefs you might need for your project.\n\nHowever sometimes there isn‚Äôt a pre-existing libdef or you have third-party code that isn‚Äôt public and/or you really just need to write a libdef yourself. To do this you‚Äôll start by creating a `.js` file for each libdef you‚Äôre going to write and put them in the `/flow-typed` directory at the root of your project. In these libdef file(s) you‚Äôll use a special set of Flow syntax (explained below) to describe the interfaces of the relevant third-party code.\n\n## Declaring A Global Function\n\nTo declare a global function that should be accessible throughout your project, use the `declare function` syntax in a libdef file:\n\n**flow-typed/myLibDef.js**\n\n``` javascript\ndeclare function foo(a: number): string;\n```\n\nThis tells Flow that any code within the project can reference the `foo` global function, and that the function takes one argument (a `number`) and it returns a `string`.\n\n## Declaring A Global Class\n\nTo declare a global class that should be accessible throughout your project, use the `declare class` syntax in a libdef file:\n\n**flow-typed/myLibDef.js**\n\n``` javascript\ndeclare class URL {\n  constructor(urlStr: string): URL;\n  toString(): string;\n\n  static compare(url1: URL, url2: URL): boolean;\n}\n```\n\nThis tells Flow that any code within the project can reference the `URL` global class. Note that this class definition does not have any implementation details ‚Äì it exclusively defines the interface of the class.\n\n## Declaring A Global Variable\n\nTo declare a global variable that should be accessible throughout your project, use the `declare var` syntax in a libdef file:\n\n**flow-typed/myLibDef.js**\n\n``` javascript\ndeclare var PI: number;\n```\n\nThis tells Flow that any code within the project can reference the `PI` global variable ‚Äì which, in this case, is a `number`.\n\n## Declaring A Global Type\n\nTo declare a global type that should be accessible throughout your project, use the `declare type` syntax in a libdef file:\n\n**flow-typed/myLibDef.js**\n\n``` javascript\ndeclare type UserID = number;\n```\n\nThis tells Flow that any code within the project can reference the `UserID` global type ‚Äì which, in this case, is just an alias for `number`.\n\n## Declaring A Module\n\nOften, third-party code is organized in terms of modules rather than globals. To write a libdef that declares the presence of a module you‚Äôll want to use the `declare module` syntax:\n\n``` javascript\ndeclare module \"some-third-party-library\" {\n  // This is where we'll list the module's exported interface(s)\n}\n```\n\nThe name specified in quotes after `declare module` can be any string, but it should correspond to the same string you‚Äôd use to `require` or `import` the third-party module into your project. For defining modules that are accessed via a relative `require`/`import` path, please see the docs on the [`.flow` files](https://flow.org/en/declarations)\n\nWithin the body of a `declare module` block, you can specify the set of exports for that module. However, before we start talking about exports we have to talk about the two kinds of modules that Flow supports: CommonJS and ES modules.\n\nFlow can handle both CommonJS and ES modules, but there are some relevant differences between the two that need to be considered when using `declare module`.\n\n### Declaring An ES Module\n\n[ES modules](http://exploringjs.com/es6/ch_modules.html) have two kinds of exports: A **named** export and a **default** export. Flow supports the ability to declare either or both of these kinds of exports within a `declare module` body as follows:\n\n###### Named Exports\n\n**flow-typed/some-es-module.js**\n\n``` javascript\ndeclare module \"some-es-module\" {\n  // Declares a named \"concatPath\" export\n  declare export function concatPath(dirA: string, dirB: string): string;\n}\n```\n\nNote that you can also declare other things inside the body of the `declare module`, and those things will be scoped to the body of the `declare module` ‚Äì **but they will not be exported from the module**:\n\n**flow-typed/some-es-module.js**\n\n``` javascript\ndeclare module \"some-es-module\" {\n  // Defines the type of a Path class within this `declare module` body, but\n  // does not export it. It can only be referenced by other things inside the\n  // body of this `declare module`\n  declare class Path {\n    toString(): string;\n  }\n\n  // Declares a named \"concatPath\" export which returns an instance of the\n  // `Path` class (defined above)\n  declare export function concatPath(dirA: string, dirB: string): Path;\n}\n```\n\n###### Default Exports\n\n**flow-typed/some-es-module.js**\n\n``` javascript\ndeclare module \"some-es-module\" {\n  declare class URL {\n    constructor(urlStr: string): URL;\n    toString(): string;\n\n    static compare(url1: URL, url2: URL): boolean;\n  }\n\n  // Declares a default export whose type is `typeof URL`\n  declare export default typeof URL;\n}\n```\n\nIt is also possible to declare both **named** and **default** exports in the same `declare module` body.\n\n### Declaring A CommonJS Module\n\nCommonJS modules have a single value that is exported (the `module.exports` value). To describe the type of this single value within a `declare module` body, you‚Äôll use the `declare module.exports` syntax:\n\n**flow-typed/some-commonjs-module.js**\n\n``` javascript\ndeclare module \"some-commonjs-module\" {\n  // The export of this module is an object with a \"concatPath\" method\n  declare module.exports: {\n    concatPath(dirA: string, dirB: string): string;\n  };\n}\n```\n\nNote that you can also declare other things inside the body of the `declare module`, and those things will be scoped to the body of the `declare module`, **but they will not be exported from the module**:\n\n**flow-typed/some-commonjs-module.js**\n\n``` javascript\ndeclare module \"some-commonjs-module\" {\n  // Defines the type of a Path class within this `declare module` body, but\n  // does not export it. It can only be referenced by other things inside the\n  // body of this `declare module`\n  declare class Path {\n    toString(): string;\n  }\n\n  // The \"concatPath\" function now returns an instance of the `Path` class\n  // (defined above).\n  declare module.exports: {\n    concatPath(dirA: string, dirB: string): Path\n  };\n}\n```\n\nNOTE: Because a given module cannot be both an ES module and a CommonJS module, it is an error to mix `declare export [...]` with `declare module.exports: ...` in the same `declare module` body.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/libdefs/creation](https://flow.org/en/docs/libdefs/creation)"
- name: Declaration Files
  id: declarations
  summary: 'Let‚Äôs look at a more general, and sometimes more convenient way to declare types for modules: .flow files'
  description: "# Declaration Files\n\n## What‚Äôs a Declaration File?\n\nLet‚Äôs look at a more general, and sometimes more convenient way to declare types for modules: `.flow` files.\n\nThere are two possible use cases, depending on whether an implementation file exists or not.\n\nIn the first case, the exported types of a module are declared in a *declaration file* `<FILENAME>.flow`, that is located in the same directory as the corresponding *implementation file* `<FILENAME>`. The declaration file completely shadows the colocated implementation. In other words, Flow will completely ignore `<FILENAME>` and just read `<FILENAME>.flow` instead.\n\nIn the second case, the implementation file is missing entirely. `<FILENAME>.flow` is treated as if it is named `<FILENAME>`.\n\nNote that the `.flow` extension applies both to `.js` files as well as `.json` ones. The corresponding declaration files have extensions `.js.flow` and `.json.flow`, respectively.\n\nNow let‚Äôs see an example of the first case documented above. Suppose we have the following code in a file `src/LookBeforeYouLeap.js`:\n\n``` javascript\n// @flow\nimport { isLeapYear } from \"./Misc\";\nif (isLeapYear(\"2020\")) console.log(\"Yay!\");\n```\n\nand suppose that `src/Misc.js` has an incompatible implementation of `isLeapYear`:\n\n``` javascript\n// @flow\nexport function isLeapYear(year: number): boolean {\n  return year % 4 == 0; // yeah, this is approximate\n}\n```\n\nIf we now create a declaration file `src/Misc.js.flow`, the declarations in it will be used instead of the code in `src/Misc.js`. Let‚Äôs say we have the following declarations in `src/Misc.js.flow`.\n\n> NOTE: The syntax for declarations in a declaration file is the same as we‚Äôve seen in [Creating Library Definitions section](https://flow.org/en/libdefs/creation).\n\n``` javascript\n// @flow\ndeclare export function isLeapYear(year: string): boolean;\n```\n\nWhat do you think will happen?\n\nRight, the `isLeapYear` call in `src/LookBeforeYouLeap.js` will typecheck, since the `year` parameter expects a `string` in the declaration file.\n\nAs this example shows, declaration files must be written with care: it is up to the programmer to ensure they are correct, otherwise they may hide type errors.\n\n## Inlining declarations in regular code\n\nSometimes it is useful to make declarations inline, as part of the source of an implementation file.\n\nIn the following example, say you want to finish writing the function `fooList` without bothering to mock up its dependencies first: a function `foo` that takes a `number` and returns a `string`, and a class `List` that has a `map` method. You can do this by including declarations for `List` and `foo`:\n\n``` javascript\ndeclare class List<T> {\n  map<U>(f: (x: T) => U): List<U>;\n}\ndeclare function foo(n: number): string;\n\nfunction fooList(ns: List<number>): List<string> {\n  return ns.map(foo);\n}\n```\n\nJust don‚Äôt forget to replace the declarations with proper implementations.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/declarations](https://flow.org/en/docs/declarations)"
- name: Defining enums
  id: enums/defining-enums
  summary: Learn how to define a Flow Enum
  description: "# Defining enums\n\nLearn how to define a Flow Enum. Looking for a quick overview? Check out the [Quickstart Guide](../index#toc-quickstart).\n\nAn enum declaration is a statement. Its name defines both a value (from which to [access its members](../using-enums#toc-accessing-enum-members), and call its [methods](../using-enums#toc-methods)), and a type (which can be [used as an annotation](../using-enums#toc-using-as-a-type-annotation) for the type of its members).\n\nEnum members must all be of the same type, and those members can be one of four types: [string](#toc-string-enums), [number](#toc-number-enums), [boolean](#toc-boolean-enums), and [symbol](#toc-symbol-enums).\n\nEvery enum has some common properties:\n\n### Consistent member type\n\nThe type of the enum members must be consistent. For example, you can‚Äôt mix `string` and `number` members in one enum. They must all be strings, numbers, or booleans (you do not provide values for `symbol` based enums).\n\n### Member name starting character\n\nMember names must be valid identifiers (e.g. not start with numbers), and must not start with lowercase `a` through `z`. Names starting with those letters are reserved for enum [methods](../using-enums#toc-methods) (e.g. `Status.cast(...)`).\n\nThis is not allowed:\n\n``` javascript\n// @flow\nenum Status {\n  active, // Error: names can't start with lowercase 'a' through 'z'\n}\n```\n\n### Unique member names\n\nMember names must be unique. This is not allowed:\n\n``` javascript\n// @flow\nenum Status {\n  Active,\n  Active, // Error: the name 'Active` was already used above\n}\n```\n\n### Literal member values\n\nIf you specify a value for an enum member, it must be a literal (string, number, or boolean), not a computed value. This is not allowed:\n\n``` javascript\n// @flow\nenum Status {\n  Active = 1 + 2, // Error: the value must be a literal\n}\n```\n\n### Unique member values\n\nMember values must be unique. This is not allowed:\n\n``` javascript\nenum Status {\n  Active = 1,\n  Paused = 1, // Error: the value has already been used above\n}\n```\n\n### Fixed at declaration\n\nAn enum is not extendable, so you can‚Äôt add new members after the fact while your code is running. At runtime, enum member values can‚Äôt change and the members can‚Äôt be deleted. In this way they act like a frozen object.\n\n## String enums\n\nString enums are the default. If you don‚Äôt specify an `of` clause (e.g. `enum Status of number {}`, `enum Status of symbol {}`, etc.), and do not specify any values (e.g. `enum Status {Active = 1}`) then the definition will default to be a string enum.\n\nUnlike the other types of enums (e.g. number enums), you can either specify values for the enum members, or not specify values and allow them to be defaulted.\n\nIf you don‚Äôt specify values for your enum members, they default to strings which are the same as the name of your members.\n\n``` javascript\nenum Status {\n  Active,\n  Paused,\n  Off,\n}\n```\n\nIs the same as:\n\n``` javascript\nenum Status {\n  Active = 'Active',\n  Paused = 'Paused',\n  Off = 'Off',\n}\n```\n\nYou must consistently either specify the value for all members, or none of the members. This is not allowed:\n\n``` javascript\n// @flow\nenum Status {\n  Active = 'active',\n  Paused = 'paused',\n  Off, // Error: you must specify a value for all members (or none of the members)\n}\n```\n\nOptionally, you can use an `of` clause:\n\n``` javascript\nenum Status of string {\n  Active,\n  Paused,\n  Off,\n}\n```\n\nWe infer the type of the enum based on its values if there is no `of` clause. Using an `of` clause will ensure that if you use incorrect values, the error message will always interpret it as an enum of that type.\n\n## Number enums\n\nNumber enums must have their values specified.\n\nYou can specify a number enum like this:\n\n``` javascript\nenum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\n```\n\nOptionally, you can use an `of` clause:\n\n``` javascript\nenum Status of number {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\n```\n\nWe do not allow defaulting of number enums (unlike some other languages), because if a member from the middle of such an enum is added or removed, all subsequent member values would be changed. This can be unsafe (e.g. push safety, serialization, logging). Requiring the user to be explicit about the renumbering makes them think about the consequences of doing so.\n\nThe value provided must be a number literal. (Note: there is no literal for negative numbers in JavaScript, they are the application of a unary `-` operation on a number literal.) We could expand allowed values in the future to include certain non-literals, if requests to do so arise.\n\n## Boolean enums\n\nBoolean enums must have their values specified. Boolean enums can only have two members.\n\nYou can specify a boolean enum like this:\n\n``` javascript\nenum Status {\n  Active = true,\n  Off = false,\n}\n```\n\nOptionally, you can use an `of` clause:\n\n``` javascript\nenum Status of boolean {\n  Active = true,\n  Off = false,\n}\n```\n\n## Symbol enums\n\nSymbol enums can‚Äôt have their values specified. Each member is a new symbol, with the symbol description set to the name of the member. You must use the `of` clause with symbol enums, to distinguish them from string enums, which are the default when omitting values.\n\nYou can specify a symbol enum like this:\n\n``` javascript\nenum Status of symbol {\n  Active,\n  Paused,\n  Off,\n}\n```\n\n## Flow Enums with Unknown Members\n\nYou can specify that your enum contains ‚Äúunknown members‚Äù by adding a `...` to the end of the declaration:\n\n``` javascript\nenum Status {\n  Active,\n  Paused,\n  Off,\n  ...\n}\n```\n\nWhen this is used, Flow will always require a `default` when [switching over the enum](../using-enums#toc-exhaustive-checking-with-unknown-members), even if all known enum members are checked. The `default` checks for ‚Äúunknown‚Äù members you haven‚Äôt explicitly listed.\n\nThis feature is useful when an enum value crosses some boundary and the enum declaration on each side may have different memebers. For example, an enum definition which is used on both the client and the server: an enum member could be added, which would be immediately seen by the server, but could be sent to an outdated client which isn‚Äôt yet aware of the new member.\n\nOne use case for this would be the JS output of [GraphQL Enums](https://graphql.org/learn/schema/#enumeration-types): Flow Enums with unknown members could be used instead of the added `'%future added value'` member.\n\n## Enums at runtime\n\nEnums exist as values at runtime. We use a [Babel transform](https://www.npmjs.com/package/babel-plugin-transform-flow-enums) to transform Flow Enum declarations into calls to the [enums runtime](https://www.npmjs.com/package/flow-enums-runtime) (read more in the [enabling enums documentation](../enabling-enums)). We use a runtime so all enums can share an implementation of the enum [methods](../using-enums#toc-methods).\n\nWe use `Object.create(null)` for enums‚Äô prototype (which has the enum methods), so properties in `Object.prototype` will not pollute enums. The only own properties of the enum object are the enum members. The members are non-enumerable (use the [`.members()` method](../using-enums#toc-members) for that). The entire enum object is frozen, so it cannot be modified.\n\n## Style guide\n\n### Naming enums\n\nWe encourage you to define enum names in `PascalCase`, following the naming conventions of other types. All caps names (e.g. `STATUS`) are harder to read and discouraged.\n\nWe encourage you to name enums in the singular. E.g. `Status`, not `Statuses`. Just like the type of `true` and `false` is `boolean`, not `booleans`.\n\nDon‚Äôt append `Enum` to the name (e.g. don‚Äôt name your enum `StatusEnum`). This is unnecessary, just like we don‚Äôt append `Class` to every class name, and `Type` to every type alias.\n\n### Naming enum members\n\nWe encourage you to define enum member names in `PascalCase`. All caps names (e.g. `ACTIVE`) are harder to read and discouraged. Additionally, since Flow enforces that these are constants, you don‚Äôt need to use the name to signal that intent to the programmer.\n\nSee also: the rule about [enum member name starting characters](#toc-member-name-starting-character).\n\n### Don‚Äôt create a separate type\n\nA Flow Enum, like a class, is both a type and a value. You don‚Äôt need to create a separate type alias, you can use the enum name.\n\n### Use dot access for accessing members\n\nPrefer `Status.Active` vs. `const {Active} = Status; Active`. This makes it easier find uses of the enum with text search, and makes it clearer to the reader what enum is involved. Additionally, this is required for [switch statements involving enums](../using-enums#toc-exhaustively-checking-enums-with-a-switch).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/enums/defining-enums](https://flow.org/en/docs/enums/defining-enums)"
- name: Depth Subtyping
  id: lang/depth-subtyping
  summary: It‚Äôs valid to use an Employee instance where a Person instance is expected
  description: "# Depth Subtyping\n\nAssume we have two classes, which have a subtype relationship:\n\n``` javascript\nclass Person { name: string }\nclass Employee extends Person { department: string }\n```\n\nIt‚Äôs valid to use an `Employee` instance where a `Person` instance is expected.\n\n``` javascript\n// @flow\nclass Person { name: string }\nclass Employee extends Person { department: string }\n\nvar employee: Employee = new Employee;\nvar person: Person = employee; // OK\n```\n\nHowever, it is not valid to use an object containing an `Employee` instance where an object containing a `Person` instance is expected.\n\n``` javascript\n// @flow\nclass Person { name: string }\nclass Employee extends Person { department: string }\n\nvar employee: { who: Employee } = { who: new Employee };\n// $ExpectError\nvar person: { who: Person } = employee; // Error\n```\n\nThis is an error because objects are mutable. The value referenced by the `employee` variable is the same as the value referenced by the `person` variable.\n\n``` javascript\nperson.who = new Person;\n```\n\nIf we write into the `who` property of the `person` object, we‚Äôve also changed the value of `employee.who`, which is explicitly annotated to be an `Employee` instance.\n\nIf we prevented any code from ever writing a new value to the object through the `person` variable, it would be safe to use the `employee` variable. Flow provides a syntax for this:\n\n``` javascript\n// @flow\nclass Person { name: string }\nclass Employee extends Person { department: string }\n\nvar employee: { who: Employee } = { who: new Employee };\nvar person: { +who: Person } = employee; // OK\n// $ExpectError\nperson.who = new Person; // Error!\n```\n\nThe plus sign indicates that the `who` property is ‚Äúcovariant.‚Äù Using a covariant property allows us to use objects which have subtype-compatible values for that property. By default, object properties are invariant, which allow both reads and writes, but are more restrictive in the values they accept.\n\nRead more about [property variance](variance).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/depth-subtyping](https://flow.org/en/docs/lang/depth-subtyping)"
- name: Editors
  id: editors
  summary: You can benefit from having Flow run as you develop by integrating into your editor
  description: "# Editors\n\nYou can benefit from having Flow run as you develop by integrating into your editor.\n\nEditor plugins are provided and maintained by the community. If you have trouble configuring or using a specific plugin for your IDE, please visit the project‚Äôs repo or search for a community provided answer.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors](https://flow.org/en/docs/editors)"
- name: Emacs
  id: editors/emacs
  summary: ¬© 2013‚Äìpresent Facebook Inc
  description: "# Emacs\n\n## flow-for-emacs\n\nYou can add support for Flow in Emacs by using [flow-for-emacs](https://github.com/flowtype/flow-for-emacs)\n\n## Requirements\n\n- Requires Flow to be installed and available on your path.\n- Requires projects containing JavaScript files to be initialised with flow init.\n- Requires JavaScript files to be marked with /\\* @flow \\*/ at the top.\n\n## Installation\n\n``` sh\ncd ~/.emacs.d/\ngit clone https://github.com/flowtype/flow-for-emacs.git\necho -e \"\\n(load-file \\\"~/.emacs.d/flow-for-emacs/flow.el\\\")\" >> ~/.emacs\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors/emacs](https://flow.org/en/docs/editors/emacs)"
- name: Enabling enums in your project
  id: enums/enabling-enums
  summary: If you have any other tool which examines your code, you need to update it as well
  description: "# Enabling enums in your project\n\n## Upgrade tooling\n\nTo enable Flow Enums in your repo, you must first update the following packages:\n\n- Upgrade to at least Flow 0.159\n  - Flow needs to have some configuration set to enable enums - see below.\n- Upgrade [Prettier](https://prettier.io/) to at least version 2.2\n  - As of that version, Prettier can handle parsing and pretty printing Flow Enums out of the box.\n  - You must use the `flow` [parser option](https://prettier.io/docs/en/options.html#parser) for JavaScript files to be able to format Flow Enums.\n- Upgrade [Babel](https://babeljs.io/) to at least version 7.13.0\n  - As of that version, Babel can parse Flow Enums. However, to enable this parsing some configuration needs to be supplied, and additionally it does not include the transform required - see below.\n- Upgrade [jscodeshift](https://github.com/facebook/jscodeshift) to at least version 0.11.0\n- Upgrade [hermes-parser](https://www.npmjs.com/package/hermes-parser) to at least version 0.4.8\n- For ESLint, either:\n  - Use [hermes-eslint](https://www.npmjs.com/package/hermes-eslint) as your ESLint parser, at least version 0.4.8\n  - Or upgrade [babel-eslint](https://github.com/babel/babel-eslint) to version 10.1.0\n    - As of that version, `babel-eslint` can handle Flow Enums out of the box.\n    - Do not upgrade to 11.x, this branch does not support Flow Enums.\n  - Or use another solution using Babel 7.13.0 or later, with Flow enabled - this may also work\n\nIf you have any other tool which examines your code, you need to update it as well. If it uses [flow-parser](https://www.npmjs.com/package/flow-parser), [hermes-parser](https://www.npmjs.com/package/hermes-parser) or `@babel/parser`, upgrade those as per the instructions above. If it uses some other parser, you will need to implement parsing Flow Enums in that parser. You can look at the existing code in Babel, Flow, and Hermes parsers to guide your work.\n\n## Enable enums\n\n- In your `.flowconfig`, under the `[options]` heading, add `enums=true`\n- Add the Flow Enums Babel transform. It turns enum declaration AST nodes into calls to the runtime: [babel-plugin-transform-flow-enums](https://www.npmjs.com/package/babel-plugin-transform-flow-enums). Add it to your development dependencies and adjust your Babel configuration to use the transform. The transform by default requires the runtime package directly (below), but you can configure this.\n- Add the Flow Enum runtime package to your production dependencies. This will be required and used at runtime to create Flow Enums: [flow-enums-runtime](https://www.npmjs.com/package/flow-enums-runtime)\n\n## Enable suggested ESLint rules\n\nEnums can be exhaustively checked in `switch` statements, so may increase the use of `switch` statements compared to before. To prevent common issues with `switch` statements, we suggest you enable these ESLint rules (at least as warnings):\n\n- [no-fallthrough](https://eslint.org/docs/rules/no-fallthrough): This prevents the user from accidentally forgetting a `break` statement at the end of their switch case, while supporting common use-cases.\n- [no-case-declarations](https://eslint.org/docs/rules/no-case-declarations): This prevents lexicaly scoped declarations (`let`, `const`) from being introduced in a switch case, without wrapping that case in a new block. Otherwise, declarations in different cases could conflict.\n\nWe also have some Flow Enums specific rules as part of [eslint-plugin-fb-flow](https://www.npmjs.com/package/eslint-plugin-fb-flow):\n\n- [use-flow-enums](https://www.npmjs.com/package/eslint-plugin-fb-flow#use-flow-enums): Suggests that enum-like `Object.freeze` and `keyMirror` usage be turned into Flow Enums instead.\n- [flow-enums-default-if-possible](https://www.npmjs.com/package/eslint-plugin-fb-flow#flow-enums-default-if-possible): Auto-fixes string enums with specified values identical to the member names to defaulted enums.\n- [no-flow-enums-object-mapping](https://www.npmjs.com/package/eslint-plugin-fb-flow#no-flow-enums-object-mapping): Suggests using a function with a switch to map enum values to other values, instead of an object literal.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/enums/enabling-enums](https://flow.org/en/docs/enums/enabling-enums)"
- name: Error Suppressions
  id: errors
  summary: Flow reports many different kinds of errors for many common programming mistakes, but not every JavaScript pattern can be understood by Flow
  description: "# Error Suppressions\n\nFlow reports many different kinds of errors for many common programming mistakes, but not every JavaScript pattern can be understood by Flow. If you are confident your code is correct, and that Flow is erroring too conservatively, you can suppress the error so that Flow does not report it.\n\n## What is a Suppression?\n\nA suppression is a special kind of comment that you can place on the line before a type error. It tells Flow not to report that error when checking your code. Suppression comments look like the following:\n\n``` plaintext\n// <SUPPRESSOR>[<CODE>] extra text\n```\n\nA suppressor can be one of the following:\n\n- `$FlowFixMe`: for type errors that you intend to fix later\n- `$FlowIssue`: for a type error that you suspect is an issue with Flow\n- `$FlowExpectedError`: for a location where you expect Flow to produce a type error (for instance, when performing an invalid type cast).\n- `$FlowIgnore`: for locations where you want Flow to ignore your code\n\nNote that all of the suppressors behave identically; we simply recommend using them as described here for your own ease of reference.\n\nThe `<CODE>` portion of a suppression is optional, but when included specifies which [error code](#toc-making-suppressions-more-granular-with-error-codes) the suppression affects.\n\nSome examples of suppression comments:\n\n``` plaintext\n// $FlowFixMe\n\n// $FlowIssue[incompatible-type]\n\n/* $FlowIgnore[prop-missing] some other text here */\n\n/* $FlowFixMe[incompatible-cast] this\n    is a multi-line\n    comment */\n\n{ /* $FlowIssue this is how you suppress errors inside JSX */ }\n```\n\nIn order to be a valid suppression comment, there are also some conditions that must be true:\n\n- No text can precede the suppressor, or come between the suppressor and the code. For example: `// some text then $FlowFixMe` is not a valid suppression, nor is `// $FlowIssue some text [incompatible-type]` or \\` //$FlowFixMe \\[prop-missing\\]\\` (note the space here!).\n- Suppressions must be on the line immediately before the error they suppress, otherwise they will not apply.\n\n## Making Suppressions More Granular with Error Codes\n\nSuppressible Flow errors will also have an error code associated with them (after version 0.127). This code concisely describes the type of issue the error is reporting, and is different between different kinds of errors.\n\nIn order to prevent suppressions from suppressing different kinds of type errors on the same line (by default suppressions without codes suppress every error on the following line), you can add an error code to your suppression. For example: `// $FlowFixMe[incompatible-type]` would only suppress errors with the `incompatible-type` code. So:\n\n``` javascript\n//$FlowFixMe[incompatible-type]\n(3 : string);\n```\n\nwould report no errors, but\n\n``` javascript\n//$FlowFixMe[prop-missing]\n(3 : string);\n```\n\nwould still report a type incompatibility.\n\nTo suppress multiple error codes on the same line, you can stack suppression comments one after another, and they will all apply to the first non-comment line like so:\n\n``` javascript\nlet y : number | { x : number }  = 1;\n\n// $FlowFixMe[incompatible-type]\n// $FlowFixMe[prop-missing]\n(y.x : string);\n```\n\nThis will suppress both of the two errors on this line.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/errors](https://flow.org/en/docs/errors)"
- name: ESLint
  id: tools/eslint
  summary: ESLint is a static analysis tool which can help you quickly find and fix bugs and stylistic errors in your code
  description: "# ESLint\n\nESLint is a static analysis tool which can help you quickly find and fix bugs and stylistic errors in your code. The rules ESLint provide complement the checks provided by Flow‚Äôs type system.\n\nYou can quick-start setup ESLint, install `hermes-eslint` with either [Yarn](https://yarnpkg.com/) or [npm](https://www.npmjs.com/).\n\n``` sh\nyarn add --dev eslint hermes-eslint eslint-plugin-ft-flow\n# or\nnpm install --save-dev eslint hermes-eslint eslint-plugin-ft-flow\n```\n\nThen create a `.eslintrc.js` file in your project root with the following:\n\n``` javascript\nmodule.exports = {\n  root: true,\n  parser: 'hermes-eslint',\n  plugins: [\n    'ft-flow'\n  ],\n  extends: [\n    'eslint:recommended',\n    'plugin:ft-flow/recommended',\n  ],\n};\n```\n\nFor more information about configuring ESLint, [check out the ESLint docs](https://eslint.org/).\n\nYou can then lint your codebase with:\n\n``` sh\nyarn run eslint . --ext .js,.jsx\n# or\nnpm run eslint . --ext .js,.jsx\n```\n\n## Usage With Prettier\n\nIf you use [`prettier`](https://www.npmjs.com/package/prettier), there is also a helpful config to help ensure ESLint doesn‚Äôt report on formatting issues that prettier will fix: [`eslint-config-prettier`](https://www.npmjs.com/package/eslint-config-prettier).\n\nUsing this config by adding it to the ***end*** of your `extends`:\n\n``` diff\nmodule.exports = {\n    root: true,\n    parser: 'hermes-eslint',\n    plugins: [\n      'ft-flow'\n    ],\n    extends: [\n      'eslint:recommended',\n      'plugin:ft-flow/recommended',\n+     'prettier',\n    ],\n  };\n```\n\n## Additional Plugins\n\nESLint plugins provide additional rules and other functionality on top of ESLint. Below are just a few examples that might be useful:\n\n- Helpful language rules by the Flow team: [`eslint-plugin-fb-flow`](https://www.npmjs.com/package/eslint-plugin-fb-flow)\n- React best practices: [`eslint-plugin-react`](https://www.npmjs.com/package/eslint-plugin-react) and [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks)\n- Jest testing: [`eslint-plugin-jest`](https://www.npmjs.com/package/eslint-plugin-jest)\n- Import/export conventions : [`eslint-plugin-import`](https://www.npmjs.com/package/eslint-plugin-import)\n- NodeJS best practices: [`eslint-plugin-node`](https://www.npmjs.com/package/eslint-plugin-node)\n- ESLint comment restrictions: [`eslint-plugin-eslint-comments`](https://www.npmjs.com/package/eslint-plugin-eslint-comments)\n\nEvery plugin that is out there includes documentation on the various configurations and rules they offer. A typical plugin might be used like:\n\n``` diff\nmodule.exports = {\n    root: true,\n    parser: 'hermes-eslint',\n    plugins: [\n      'ft-flow'\n+     'jest',\n    ],\n    extends: [\n      'eslint:recommended',\n      'plugin:ft-flow/recommended',\n+     'plugin:jest/recommended',\n    ],\n  };\n```\n\nSearch [‚Äúeslint-plugin‚Äù on npm](https://www.npmjs.com/search?q=eslint-plugin) for more.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/tools/eslint](https://flow.org/en/docs/tools/eslint)"
- name: Event Handling
  id: react/events
  summary: In the React docs ‚ÄúHandling Events‚Äù section a few different recommendations are provided on how to define event handlers
  description: "# Event Handling\n\nIn the [React docs ‚ÄúHandling Events‚Äù section](https://facebook.github.io/react/docs/handling-events.html) a few different recommendations are provided on how to define event handlers. If you are using Flow we recommend that you use [property initializer syntax](https://babeljs.io/docs/plugins/transform-class-properties/) as it is the easiest to statically type. Property initializer syntax looks like this:\n\n``` javascript\nclass MyComponent extends React.Component<{}> {\n  handleClick = event => { /* ... */ };\n}\n```\n\nTo type event handlers you may use the `SyntheticEvent<T>` types like this:\n\n``` javascript\nimport * as React from 'react';\n\nclass MyComponent extends React.Component<{}, { count: number }> {\n  handleClick = (event: SyntheticEvent<HTMLButtonElement>) => {\n    // To access your button instance use `event.currentTarget`.\n    (event.currentTarget: HTMLButtonElement);\n\n    this.setState(prevState => ({\n      count: prevState.count + 1,\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.handleClick}>\n          Increment\n        </button>\n      </div>\n    );\n  }\n}\n```\n\nThere are also more specific synthetic event types like `SyntheticKeyboardEvent<T>`, `SyntheticMouseEvent<T>`, or `SyntheticTouchEvent<T>`. The `SyntheticEvent<T>` types all take a single type argument. The type of the HTML element the event handler was placed on.\n\nIf you don‚Äôt want to add the type of your element instance you can also use `SyntheticEvent` with *no* type arguments like so: `SyntheticEvent<>`.\n\n> **Note:** To get the element instance, like `HTMLButtonElement` in the example above, it is a common mistake to use `event.target` instead of `event.currentTarget`. The reason why you want to use `event.currentTarget` is that `event.target` may be the wrong element due to [event propagation](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation).\n\n> **Note:** React uses its own event system so it is important to use the `SyntheticEvent` types instead of the DOM types such as `Event`, `KeyboardEvent`, and `MouseEvent`.\n\nThe `SyntheticEvent<T>` types that React provides and the DOM events they are related to are:\n\n- `SyntheticEvent<T>` for [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event)\n- `SyntheticAnimationEvent<T>` for [AnimationEvent](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent)\n- `SyntheticCompositionEvent<T>` for [CompositionEvent](https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent)\n- `SyntheticInputEvent<T>` for [InputEvent](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent)\n- `SyntheticUIEvent<T>` for [UIEvent](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent)\n- `SyntheticFocusEvent<T>` for [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent)\n- `SyntheticKeyboardEvent<T>` for [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent)\n- `SyntheticMouseEvent<T>` for [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent)\n- `SyntheticDragEvent<T>` for [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent)\n- `SyntheticWheelEvent<T>` for [WheelEvent](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent)\n- `SyntheticTouchEvent<T>` for [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)\n- `SyntheticTransitionEvent<T>` for [TransitionEvent](https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent)\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/events](https://flow.org/en/docs/react/events)"
- name: FAQ
  id: faq
  summary: Flow does not keep track of side effects, so any function call may potentially nullify your check
  description: "# FAQ\n\n## I checked that `foo.bar` is not `null`, but Flow still thinks it is. Why does this happen and how can I fix it?\n\nFlow does not keep track of side effects, so any function call may potentially nullify your check. This is called [refinement invalidation](lang/refinements#toc-refinement-invalidations).\n\nExample ([https://flow.org/try](https://flow.org/try/#0C4TwDgpgBACghgJzgWygXigbwFBSgI0QC4oB+AZ2AQEsA7AcwBpsBfbAMwFdaBjYagPa0oyEADFuPABTsBAkvCTIAlCUo0GWXFGrsoMuQDpCCZVrx4eQ8gIA2EQ7YH0pAIh4ALCDwDWEACYAhK7KANzaAJAIEMCcCMKyAsaIoVAA9GlQ7E4A7lAQCAgCCOSGUACSeiACnFBWyMgQtMBQwF511nYOTkw6LTnFPuTabHja0bHxUK7+EOxwnLYt6nT0ruEsQA)):\n\n``` javascript\n// @flow\ntype Param = {\n  bar: ?string,\n}\nfunction myFunc(foo: Param): string {\n  if (foo.bar) {\n    console.log(\"checked!\");\n    return foo.bar; // Flow errors. If you remove the console.log, it works\n  }\n\n  return \"default string\";\n}\n```\n\nYou can get around this by storing your checked values in local variables:\n\n``` javascript\n// @flow\ntype Param = {\n  bar: ?string,\n}\nfunction myFunc(foo: Param): string {\n  if (foo.bar) {\n    const bar = foo.bar;\n    console.log(\"checked!\");\n    return bar; // Ok!\n  }\n\n  return \"default string\";\n}\n```\n\n## I checked that my object is of type A, so why does Flow still believe it‚Äôs A \\| B?\n\nRefinement invalidation can also happen with [disjoint unions](types/unions#toc-disjoint-unions). Any function call will invalidate any refinement.\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRoyZAAVJQBbTFhuZDCwpNT0mj7QN1JYALy4VTCAAwASBhz4zDzJaUwNUABGCYSazVE1gAYDhOcaLQ1HIA)):\n\n``` javascript\n// @flow\ntype Response =\n  | { type: 'success', value: string }\n  | { type: 'error', error: Error };\n\nconst handleResponse = (response: Response) => {\n  if (response.type === 'success') {\n    setTimeout(() => {\n      console.log(`${response.value} 1`)\n    }, 1000);\n  }\n};\n```\n\nHere, a work around would be to extract the part of the value you‚Äôre interested in, or to move the if check inside the `setTimeout` call:\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagEqYM7qwB2+2AvKIqKAD6gDeoaWAXKAOT4CuAxrwXwcANKABuAQ2jdM7fMgBOAS2IBzUAF9qdRswyzOmBQtgKRoIyYXsAosdOaA3IkS8S80AAsJxACbRMPEJ3ClAACgUCIlIDIOiyAEpQcgA+Rm0lSHDI4JiAOhYKckouPgF8ISSGbRo3UmRxKRlk0Bz4zDzJaUwa0DJkABUlAFtMWG5kMLCk1PSaedA6-FgAvLhVMIADABIGLpkNUABGTYTejVEjgAYbhOcaLQ1HIA)):\n\n``` javascript\n// @flow\ntype Response =\n  | { type: 'success', value: string }\n  | { type: 'error', error: Error };\n\nconst handleResponse = (response: Response) => {\n  if (response.type === 'success') {\n    const value = response.value\n    setTimeout(() => {\n      console.log(`${value} 1`)\n    }, 1000);\n  }\n};\n```\n\n## I‚Äôm in a closure and Flow ignores the if check that asserts that `foo.bar` is defined. Why?\n\nIn the previous section we showed how refinement is lost after a function call. The exact same thing happens within closures, since Flow does not track how your value might change before the closure is called.\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQcUxJaVjIWHwAURpBAAtwrFcvAD5k1NThEmJMuDpwgAMAFULsUs9QYMJQABIqLtJ4hj5QGhJHUGQO0Cj5kmxegaoojxHtPmaEm1S+BMQ+IA)):\n\n``` javascript\n// @flow\ntype Person = {age: ?number}\nconst people = [{age: 12}, {age: 18}, {age: 24}];\nconst oldPerson: Person = {age: 70};\nif (oldPerson.age) {\n  people.forEach(person => {\n    console.log(`The person is ${person.age} and the old one is ${oldPerson.age}`);\n  })\n}\n```\n\nThe solution here is to move the if check in the `forEach`, or to assign the `age` to an intermediate variable.\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQAXAngBwKagAqYE4DOsAdqALygDeAhgOaYBcoA-CQK4C2ARgQL6IAxqULJQWWOmjZKAbVoNmARgBMfADTV6TUEoAcGrYtAqALHwC6AbiEixsaABM8RUsxfEylBToDsABj4bAEtIUAAKB2cCTwA6bQBKakRQUGESUVBtClAoj1J4hhtUiSlMWMhYfABRGkEAC3CsVy8APmTU1PTiaVi4OnCAAwAVeuxmz1BgwlAAEioJgu0+LJJHUGQx3KdckmxpuZ8+QYTi0D4ExD4gA)):\n\n``` javascript\n// @flow\ntype Person = {age: ?number}\nconst people = [{age: 12}, {age: 18}, {age: 24}];\nconst oldPerson: Person = {age: 70};\nif (oldPerson.age) {\n  const age = oldPerson.age;\n  people.forEach(person => {\n    console.log(`The person is ${person.age} and the old one is ${age}`);\n  })\n}\n```\n\n## But Flow should understand that this function cannot invalidate this refinement, right?\n\nFlow is not [complete](https://flow.org/en/lang/types-and-expressions/#soundness-and-completeness), so it cannot check all code perfectly. Instead, Flow will make conservative assumptions to try to be sound.\n\n## Why can‚Äôt I use a function in my if-clause to check the type of a property?\n\nFlow doesn‚Äôt track refinements made in separated function calls.\n\nExample ([https://flow.org/try](https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTW4UPigATwAHKhBMBWUXdy8fKlQUNABydkMs6WwE9CtbDlxHZU5uRAQKpXoAJk4JIA))\n\n``` javascript\n// @flow\nconst add = (first: number, second: number) => first + second;\nconst val: string | number = ...\nconst isNumber = (valueToRefine: ?number) => typeof valueToRefine === 'number';\nif (isNumber(val)) add(val, 2);\n```\n\nHowever, Flow has [predicates functions](types/functions#toc-predicate-functions) that can do these checks via `%checks`.\n\nExample ([https://flow.org/try](https://flow.org/try/#0MYewdgzgLgBAhgEwTAvDAFAMwJYCdoBcMYArgLYBGAprgDQwRWhgJGmU0CUqAfDDvlgBqBk3AIA3AChm0GADc4AGyLRc2MAHMYAH2LlquVDACM02bGwQAcgZrH0ipSSoAVEACUqOMFTZ2jPTUNTU4iAFJgAAsmAGsIXhgoAE8AByoQTAVlF3cvHypUFDQAcnZDEulsLPQrWw5cR2VObkQEJqV6ACZOCSA))\n\n``` javascript\n// @flow\nconst add = (first: number, second: number) => first + second;\nconst val: string | number = ...\nconst isNumber = (valueToRefine: ?number): %checks => typeof valueToRefine === 'number';\nif (isNumber(val)) add(val, 2);\n```\n\n## Why can‚Äôt I pass an `Array<string>` to a function that takes an `Array<string |¬†number>`\n\nThe function‚Äôs argument allows `string` values in its array, but in this case Flow prevents the original array from receiving a `number`. Inside the function, you would be able to push a `number` to the argument array, causing the type of the original array to no longer be accurate. You can fix this error by changing the type of the argument to `$ReadOnlyArray<string |¬†number>`. This prevents the function body from pushing anything to the array, allowing it to accept narrower types.\n\nAs an example, this would not work:\n\n``` javascript\n// @flow\n\nconst fn = (arr: Array<string | number>) => {\n  // arr.push(123) NOTE! Array<string> passed in and after this it would also include numbers if allowed\n  return arr;\n};\n\nconst arr: Array<string> = ['abc'];\n\nfn(arr); // Error!\n```\n\nbut with `$ReadOnlyArray` you can achieve what you were looking for:\n\n``` javascript\n// @flow\nconst fn = (arr: $ReadOnlyArray<string | number>) => {\n  // arr.push(321) NOTE! Since you are using $ReadOnlyArray<...> you cannot push anything to it\n  return arr;\n};\n\nconst arr: Array<string> = ['abc'];\n\nfn(arr);\n```\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QACnLFijUAEEx5egB5OxDDQDmoAD4ACmvgC2AI1LEAfAEoBx0AG9EASFSjiAOgAO+djiE8ATAGZzqAByAPIAKgCiAIRSMvKKyiqWLuTs7KSUoMqg5DQZ5JBYRqC4GOyZRPAE0HnQ7LCZNCzQ+JSkoDoGRmUYkNnQcPDpdmRY+MQ02WIA3IgAvqwcRI48EtLEsgpYSqqWggDaAOTk+iwHALozKGDcPCJiplOgqHIAtG+g+I2wurqkNFywYigIzEQHsSKRZCoN4w2Fw+EIxFIqFgABKFGodHoLwAbl0MLRmIg2DROKBuN4BMJHBIACToqjBLFrDbxVQabR6Qwmcz8Sw2UCCp5gRyudyeXzeHgBMAhCLRADKyhYbXoBEmbXcCVA9IxTIYLPkTmNljV+FALByNFgRDcHmyNHoJXZWHq2GGpFG40mxDmC1JSzE3lWsU220SVMOx1OF2QFLuxG8DyAA))\n\n## Why can‚Äôt I pass `{ a: string }` to a function that takes `{ a: string |¬†number }`\n\nThe function argument allows `string` values in its field, but in this case Flow prevents the original object from having a `number` written to it. Within the body of the function you would be able to mutate the object so that the property `a` would receive a `number`, causing the type of the original object to no longer be accurate. You can fix this error by making the property covariant (read-only): `{ +a: string |¬†number }`. This prevents the function body from writing to the property, making it safe to pass more restricted types to the function.\n\nAs an example, this would not work:\n\n``` javascript\n// @flow\n\nconst fn = (obj: {| a: string | number |}) => {\n  // obj.a = 123;\n  return obj;\n};\n\nconst object: {| a: string |} = {a: 'str' };\n\nfn(object); // Error!\n```\n\nbut with a covariant property you can achieve what you were looking for:\n\n``` javascript\n// @flow\nconst fn = (obj: {| +a: string | number |}) => {\n  // obj.a = 123 NOTE! Since you are using covariant {| +a: string | number |}, you can't mutate it\n  return obj;\n};\n\nconst object: {| a: string |} = { a: 'str' };\n\nfn(object);\n```\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQiSgOoEsAuALWBXLUAJwFMBDAE1gDtoBPALmQGNaBnIyGgRlAF5QAClgAjAFaNQAbwA+oclM7EMNAOahZAApr4AtqNLEtsgL4BKAQD4ZiAJCox4gHTkBoHgCYAzKBAA5AHkAFQBRAEIZbUVQZVUNM1AAB3J2dlJKUFUFGkzySCwjUFwMdiyieAJoTMNQXQMijEgFaDh4DPsyLHxiGlAnAG5EU1YOIidSFiweKTktGLj1TVN3aRiAcmV10FMhlDBuHhEJSenzAb8wAB4AWjvQfBo2PT1SGiJsyFhiUCNib-Y4XCyFQdzB4IhkKh0JhILAACUKNQ6PQbgA3IzsDC0ZiINg0TigbiedzHSRRUAAagWWBUS209UMPzMln4NmkiFAoAcYCcrncXl8ARCEVAAGVVCxSKB6AQFGQHlilmw0eQVOR3lEtNSlLT4podPomcsADQyuUsDXrIh6QjkQrlTqkbq9foSIYjPFjN3iU6eWbyGl0hIrQTSBRSTa07a7ZDEsl+85AA))\n\n## Why can‚Äôt I refine a union of objects?\n\nThere are two potential reasons:\n\n1.  You are using inexact objects.\n2.  You are destructuring the object. When destructuring, Flow loses track of object properties.\n\nBroken example:\n\n``` javascript\n/* @flow */\n\ntype Action =\n  | {type: 'A', payload: string}\n  | {type: 'B', payload: number};\n\n// Not OK\nconst fn = ({type, payload}: Action) => {\n  switch (type) {\n    case 'A': return payload.length;\n    case 'B': return payload + 10;\n  }\n}\n```\n\nFixed example:\n\n``` javascript\n/* @flow */\n\ntype Action =\n  | {type: 'A', payload: string}\n  | {type: 'B', payload: number};\n\n// OK\nconst fn = (action: Action) => {\n  switch (action.type) {\n    case 'A': return action.payload.length;\n    case 'B': return action.payload + 10;\n  }\n}\n```\n\n([https://flow.org/try](https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVAXAngBwKZgCCAxhgJZwB2YAvGKmGAD5gDe2+AXGAOSE8AaMDgCGWeCIAm3AM4YATmUoBzAL6MGzNhzzceAIUHCxE6WEoBXALYAjPPNUBudMGBgA8gGlUxKnLBQAIy0YAAUIqQUlNwk5FQAlLQAfGyaMghkGMQAFmERcZQAdDqJrJqMxCIyBHw83PJ4GBby1PlRhaLicFKFMHgqGNnOjBVVNYb1jc2tkVQdJt2SYADUYIEADMNgqqg7Lm4AcnAYHp5gFpS+Vlb9J1Bw8mD28g8yAISorr6U-lAATCFQuxcHghJ1TKoYrNKIkaCkyq5GOlMjkwiVUoiRpVqrx+JMmi1jF0en0BkNPm4sWNeBMwA0CdRwYsVmtNhTGDtEaogA))\n\nSecond example:\n\n- broken: [https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA)\n- fixed: [https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA)\n\n## I got a ‚ÄúMissing type annotation‚Äù error. Where does it come from?\n\nFlow requires type annotations at module boundaries to make sure it can scale. To read more about that, check out our [blog post](https://medium.com/flow-type/asking-for-required-annotations-64d4f9c1edf8) about that.\n\nThe most common case you‚Äôll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance, in this [example](https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA), flow will complain:\n\n``` javascript\nexport const add = a => a + 1;\n```\n\nThe fix here is to add types to the parameters of `add`.\n\nExample ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKABTkBcoRArgLYBGyWAlHQB8ocqADUoAIwBuIA)):\n\n``` javascript\nexport const add = (a: number) => a + 1;\n```\n\nTo see how you can annotate exported React components, check out our docs on [HOCs](https://flow.org/en/react/hoc/#toc-exporting-wrapped-components).\n\nThere are other cases where this happens, and they might be harder to understand. You‚Äôll get an error like `Missing type annotation for U` For instance, you wrote this [code](https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA):\n\n``` javascript\nconst array = ['a', 'b']\nexport const genericArray = array.map(a => a)\n```\n\nHere, Flow will complain on the `export`, asking for a type annotation. Flow wants you to annotate exports returned by a generic function. The type of `Array.prototype.map` is `map<U>(callbackfn: (value: T, index: number, array: Array<T>) => U, thisArg?: any): Array<U>`. The `<U>` corresponds to what is called a [generic](types/generics), to express the fact that the type of the function passed to map is linked to the type of the array.\n\nUnderstanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of `genericArray`.\n\nYou can do that by adding an explicit type argument:\n\n``` javascript\nconst array = ['a', 'b'];\nexport const genericArray = array.map<string>(a => a);\n```\n\nor by annotating the exported constant ([https://flow.org/try](https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA)):\n\n``` javascript\nconst array = ['a', 'b']\nexport const genericArray: Array<string> = array.map(a => a)\n```\n\n## Flow cannot understand the types of my higher order React component, how can I help it?\n\nTypings HOCs can be complicated. While you can follow the [docs about it](react/hoc), sometimes it can be easier to type the returned component.\n\nFor instance, in this [example](https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0sDciiNsAOxJ4SlHABUAnukqgAvKABCpSgGEmmAZQF45APlDpG6MvtAAeZaPUZB2vAG8AdC6OwTAX1A5plOQCIAIwBXHBxBf1BgPR5+ITwAcW1KLGQaRVDwgXlQAAoHHxkAGlAaAAtkaAATdgEPAEp5A3MQsMFvXzkC3y9BVWg0gGsu3MazOJJYaEonOABzXJYaAZpByiqWeo89B3LKmu0Pc2BWrJjeCbwMtoEALgoOHCcbTXspGXNdiura+6paJ4AOVgVUo2xyogkvlySS0qXSmUE9S4QA), we don‚Äôt type the HOC (setType), but the component created with it, `Button`. To do so, we use the type `React.ComponentType`.\n\n``` javascript\n// @flow\nimport * as React from 'react';\n\nconst setType = BaseComponent => props => <BaseComponent {...props} type=\"button\" />;\nconst GenericButton = ({type, children}) => <button type={type} onClick={() => console.log('clicked')}>{children}</button>;\n\nconst Button: React.ComponentType<{children: React.Node}> = setType(GenericButton);\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/faq](https://flow.org/en/docs/faq)"
- name: Flow Annotate-Exports
  id: cli/annotate-exports
  summary: Upgrading to Types-First mode may require a substantial number of type annotations at module boundaries
  description: "# Flow Annotate-Exports\n\nUpgrading to [Types-First](https://flow.org/en/lang/types-first) mode may require a substantial number of type annotations at module boundaries. To help with the process of upgrading large codebases, we are providing a codemod command, whose goal is to fill in these missing annotations. This command is included in the Flow binary in versions `>= 0.125`.\n\n> Note: As of version 0.134, types-first is the default mode. If you are using a version `>=0.134`, make sure you set `types_first=false` in your .flowconfig while running this codemod.\n\nThis command uses types that Flow infers, to fill in positions that would otherwise raise *signature-verification* failures. It will include the necessary type import statements, as long as the respective types are exported from their defining modules.\n\nIt is designed for use on multiple files at once, rather than one file at a time. For this reason it doesn‚Äôt connect to an existing Flow server, but rather starts a checking process of its own.\n\nAs is typical with such mechanized approaches, it comes with a few caveats:\n\n1.  It won‚Äôt be able to fill in every required type annotation. Some cases will require manual effort.\n2.  Inserted annotations may cause new flow errors, since it‚Äôs not always possible to match inferred type with types that can be written as annotations.\n3.  File formatting may be affected. If a code formatter (e.g. prettier) is used, it is recommended that you run it after the codemod has finished running.\n\n## How to apply the codemod\n\nA typical way to invoke this command is\n\n``` plaintext\nflow codemod annotate-exports \\\n  --write \\\n  --repeat \\\n  --log-level info \\\n  /path/to/folder \\\n  2> out.log\n```\n\nThis command will transform files under `/path/to/folder`. This does not need to be the root directory (the one containing `.flowconfig`).\n\nIt uses the following flags:\n\n- `--write` will update files that require annotations under `/path/to/folder` in-place. Without this flag the resulting files will be printed on the command line.\n\n- `--repeat` ensures that the transformation will be applied until no more files change. This mode is necessary here, because each new type the codemod adds may require new locations to be annotated.\n\n- `--log-level info` outputs useful debugging information in the standard error stream. This option might lead to verbose output, so we‚Äôre redirecting the error output to a log file `out.log`.\n\nAnother convenient way to provide the input is by passing the flag\n\n``` plaintext\n--input-file file.txt\n```\n\nwhere `file.txt` contains a specific list of files to be transformed.\n\n## Codemod output\n\nAfter each iteration of the codemod, a summary will be printed on the CLI. This summary includes statistical information about the number of annotations that were added, and how many locations were skipped. It also prints counts for various kinds of errors that were encountered. These can be matched to the errors printed in the logs.\n\nA common error case is when a type `A`, defined in a file `a.js`, but not exported, is inferred in file `b.js`. The codemod will skip adding this annotation and report an error in the logs. The fix this case, you can export `A` in `a.js`. Note that it is not necessary to manually import `A` in `b.js`. The codemod will do this automatically.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/cli/annotate-exports](https://flow.org/en/docs/cli/annotate-exports)"
- name: Flow CLI
  id: cli
  summary: The flow command line tool is made to be easy-to-use for simple cases
  description: "# Flow CLI\n\nThe flow command line tool is made to be easy-to-use for simple cases.\n\nUsing the command `flow` will type-check your current directory if the `.flowconfig` file is present. A flow server will automatically be started if needed.\n\nThe CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the [Nuclide](https://nuclide.io/) editor integrates with Flow to provide autocompletion, type errors, etc. in its UI.\n\nTo find out more about the CLI just type:\n\n``` sh\nflow --help\n```\n\nThis will give you information about everything that flow can do. Running this command should print something like this:\n\n``` plaintext\nUsage: flow [COMMAND] [PROJECT_ROOT]\n\nValid values for COMMAND:\n  ast              Print the AST\n  autocomplete     Queries autocompletion information\n  batch-coverage   Shows aggregate coverage information for a group of files or directories\n  check            Does a full Flow check and prints the results\n  check-contents   Run typechecker on contents from stdin\n  config           Read or write the .flowconfig file\n  coverage         Shows coverage information for a given file\n  cycle            Output .dot file for cycle containing the given file\n  find-module      Resolves a module reference to a file\n  find-refs        Gets the reference locations of a variable or property\n  force-recheck    Forces the server to recheck a given list of files\n  get-def          Gets the definition location of a variable or property\n  get-imports      Get names of all modules imported by one or more given modules\n  graph            Outputs dependency graphs of flow repositories\n  init             Initializes a directory to be used as a flow root directory\n  ls               Lists files visible to Flow\n  lsp              Acts as a server for the Language Server Protocol over stdin/stdout [experimental]\n  print-signature  Prints the type signature of a file as extracted in types-first mode\n  server           Runs a Flow server in the foreground\n  start            Starts a Flow server\n  status           (default) Shows current Flow errors by asking the Flow server\n  stop             Stops a Flow server\n  type-at-pos      Shows the type at a given file and position\n  version          Print version information\n\nDefault values if unspecified:\n  COMMAND         status\n  PROJECT_ROOT    current folder\n\nStatus command options:\n  --color              Display terminal output in color. never, always, auto (default: auto)\n  --from               Specify client (for use by editor plugins)\n  --help               This list of options\n  --json               Output results in JSON format\n  --no-auto-start      If the server is not running, do not start it; just exit\n  --old-output-format  Use old output format (absolute file names, line and column numbers)\n  --one-line           Escapes newlines so that each error prints on one line\n  --quiet              Suppresses the server-status information that would have been printed to stderr\n  --retries            Set the number of retries. (default: 3)\n  --show-all-errors    Print all errors (the default is to truncate after 50 errors)\n  --strip-root         Print paths without the root\n  --temp-dir           Directory in which to store temp files (default: /tmp/flow/)\n  --timeout            Maximum time to wait, in seconds\n  --version            Print version number and exit\n```\n\nExample with custom project root:\n\n``` sh\nmydir\n‚îú‚îÄ‚îÄ frontend\n‚îÇ   ‚îú‚îÄ‚îÄ .flowconfig\n‚îÇ   ‚îî‚îÄ‚îÄ app.js\n‚îî‚îÄ‚îÄ backend\n```\n\n``` sh\nflow check frontend\n```\n\nYou can then, further dig into particular COMMANDs by adding the `--help` flag.\n\nSo, for example, if you want to know more about how the autocomplete works, you can use this command:\n\n``` sh\nflow autocomplete --help\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/cli](https://flow.org/en/docs/cli)"
- name: Flow Coverage
  id: cli/coverage
  summary: The coverage command provides a metric of the amount of checking that Flow has performed on each part of your code
  description: "# Flow Coverage\n\nThe coverage command provides a metric of the amount of checking that Flow has performed on each part of your code. A program with high Flow coverage should increase your confidence that Flow has detected any potential runtime errors.\n\nThe determining factor for this is the presence of [`any`](../types/any) in the inferred type of each expression. An expression whose inferred type is `any` is considered *uncovered*, otherwise it is considered *covered*.\n\nTo see why this metric was chosen for determining Flow‚Äôs effectiveness, consider the example\n\n``` javascript\nconst one: any = 1;\none();\n```\n\nThis code leads to a runtime type error, since we are attempting to perform a call on a number. Flow, however, does not flag an error here, because we have annotated variable `one` as `any`. Flow‚Äôs checking is effectively turned off whenever `any` is involved, so it will silently allow the call. The use of this *unsafe* type has rendered the type checker ineffective, and the coverage metric is here to surface this, by reporting all instances of `one` as uncovered.\n\n## Design Space\n\n**Which types should be ‚Äúcovered‚Äù?**\n\nWhat was described above is a rather coarse grained way to determine coverage. One could imagine a criterion that flags expressions as uncovered if *any* part of their type includes `any`, for example `Array<any>`. While there is value in a metric like this, the ‚Äúuncovered‚Äù part of the type will typically be uncovered through various operations on values of this type. For example, in the code\n\n``` javascript\ndeclare var arr: Array<any>;\narr.forEach(x => {});\n```\n\nthe parameter `x` will be flagged as uncovered. Also, in practice, a strict criterion like this would be too noisy and rather expensive to compute on the fly.\n\n**Union types**\n\nAn exception to this principle are union types: the type `number | any` is considered *uncovered*, even though technically `any` is not the top-level constructor. Unions merely encode an option among *a set of* other types. In that sense we are conservatively viewing an expression as uncovered, when at least one possible type of that expression causes limited checking. For example, in the code\n\n``` javascript\nlet x: number | any = 1;\nx = \"a\";\n```\n\nFlow will let you assign anything to `x`, which reduces confidence in the use of `x` as a number. Thus `x` is considered uncovered.\n\n**The empty type**\n\nAn interesting type from a coverage perspective is the `empty` type. This type roughly corresponds to *dead code*. As such checking around expressions with type `empty` is more relaxed, but for a good reason: this code will not be executed at runtime. Since it is a common practice to clean up such code, Flow coverage will also report code whose type is inferred to be `empty`, but distinguishes it from the case of `any`.\n\n## Command Line Use\n\nTo find out the coverage of a file foo.js with the following contents\n\n``` javascript\n// @flow\nfunction add(one: any, two: any): number {\n  return one + two;\n}\n\nadd(1, 2);\n```\n\nyou can issue the following command\n\n``` plaintext\n$ flow coverage file.js\nCovered: 50.00% (5 of 10 expressions)\n```\n\nThis output means that 5 out of the 10 nodes of this program were inferred to have type `any`. To see exactly which parts are uncovered you can also pass one of the following flags:\n\n- `--color`: This will print foo.js on the terminal with the uncovered locations in red color.\n- `--json`: This will list out all location spans that are uncovered under the tag `\"uncovered_locs\"`.\n\nFinally, as an example of dead code, consider the code\n\n``` javascript\nfunction untypedAdd(one, two) {\n  return one + two;\n}\n```\n\nNote that function `untypedAdd` is never called, so `one` and `two` will be inferred to have type `empty`. In the colored version of this command these parts appear in blue color, and in the JSON version they are under the tag `\"empty_locs\"`.\n\n**Use on multiple files**\n\nIf you want to check coverage of multiple files at once, Flow offers the `batch-coverage` command:\n\n``` plaintext\n$ flow batch-coverage dir/\n```\n\nwill report coverage statistics for each file under `dir/`, as well as aggregate results.\n\nNote that `batch-coverage` requires a non-lazy Flow server.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/cli/coverage](https://flow.org/en/docs/cli/coverage)"
- name: Flow Enums
  id: enums
  summary: Flow Enums define a fixed set of constants which create their own type
  description: "# Flow Enums\n\nFlow Enums define a fixed set of constants which create their own type.\n\nUnlike other features of Flow, Flow Enums exist as values at runtime, as well as existing as types.\n\n[Read how to enable Flow Enums in your project](enabling-enums).\n\n## Benefits\n\nEnums provide several benefits over existing patterns:\n\n- Reduce repetition: Enum declarations provide both the type and the value of the enum.\n- Improve Flow performance: Enums are guaranteed to have good type-checking performance, unlike unions which may be expensive to type-check in certain situations.\n- Enable new functionality: Enums come with a `cast` [method](using-enums#toc-methods), which converts from a primitive type to an enum type safely.\n- Enhance safety: Enums define their own type which does not implicitly coerce to and from other types (e.g. from `string`s), and are required to be [exhaustively checked in switch statements](using-enums#toc-exhaustively-checking-enums-with-a-switch). These properties can help prevent logic bugs.\n\n## Quickstart\n\n### [Defining enums](defining-enums)\n\nAn enum named `Status` with three members: `Active`, `Paused`, and `Off`.\n\n``` javascript\nenum Status {\n  Active,\n  Paused,\n  Off,\n}\n```\n\nBy default, enums define members with string values which mirror their names. You can also explicitly set values:\n\n``` javascript\nenum Status {\n  Active = 'active',\n  Paused = 'paused',\n  Off = 'off',\n}\n```\n\nYou can use numbers as well:\n\n``` javascript\nenum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\n```\n\nValues must be unique, literals, and all of the same type. Check out the [full docs on defining enums](defining-enums) to learn more.\n\n### [Using enums](using-enums)\n\nTo access an enum member, use dot access:\n\n``` javascript\nStatus.Active\n```\n\nTo use the enum type as an annotation, use the enum name:\n\n``` javascript\nconst status: Status = Status.Active;\n```\n\nCast from the representation type (in this case, a `string`) to the enum type:\n\n``` javascript\nconst status: Status | void = Status.cast(someString);\n```\n\nYou can easily provide a default value with the `??` operator:\n\n``` javascript\nconst status: Status = Status.cast(someString) ?? Status.Off;\n```\n\nRead more about the [other methods enums provide](using-enums#toc-methods), including `isValid`, `members`, and `getName`.\n\nCast an enum type to its representation type (must be done explicitly):\n\n``` javascript\n(status: string)\n```\n\nChecks of enums in `switch` statements are exhaustive - we ensure you check all members:\n\n``` javascript\n// ERROR: Incomplete exhaustive check: the member `Off` of enum `Status`\n// has not been considered in check of `status`.\nswitch (status) {\n  case Status.Active: ...; break;\n  case Status.Paused: ...; break;\n  // We forgot to add `case: Status.Off:` here, resulting in error above.\n  // Using `default:` would also work to check all remaining members.\n}\n```\n\nRead more about [exhaustively checking enums](using-enums#toc-exhaustively-checking-enums-with-a-switch).\n\nCheck out the [the full docs on using enums](using-enums) to learn more.\n\n## When to use Flow Enums\n\nIf you previously defined a union type of literals, you can use an enum to define that type instead. Instead of\n\n``` javascript\ntype Status =\n  | 'Active'\n  | 'Paused'\n  | 'Off';\n\nconst x: Status = 'Active';\n```\n\nor\n\n``` javascript\nconst Status = Object.freeze({\n  Active: 'Active',\n  Paused: 'Paused',\n  Off: 'Off',\n});\ntype StatusType = $Keys<typeof Status>;\nconst x: StatusType = Status.Active;\n```\n\nyou can use:\n\n``` javascript\nenum Status {\n  Active,\n  Paused,\n  Off,\n}\nconst x: Status = Status.Active;\n```\n\nSee [migrating from legacy patterns](migrating-legacy-patterns) to learn more about migrating legacy JavaScript enum patterns to Flow Enums.\n\n## When to not use Flow Enums\n\nEnums are designed to cover many use cases and exhibit certain benefits. The design makes a variety of trade-offs to make this happen, and in certain situations, these trade-offs might not be right for you. In those cases, you can continue to use existing patterns to satisfy your use cases. [Read more about those situations](using-enums#toc-when-to-not-use-enums).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/enums](https://flow.org/en/docs/enums)"
- name: Flow Strict
  id: strict
  summary: You can enable stronger safety guarantees in Flow (such as banning any/Object/Function types and requiring all dependencies to be typed) by adding @flow strict to your files
  description: "# Flow Strict\n\nYou can enable stronger safety guarantees in Flow (such as banning `any`/`Object`/`Function` types and requiring all dependencies to be typed) by adding **`@flow strict`** to your files.\n\n## Overview\n\nFlow was designed for easy adoption, so it allows you opt-out of type checking in certain situations, permitting unsafe behaviors. But since many codebases now have a high adoption of Flow types, this trade-off can be flipped. You can use *Flow Strict* to disallow previously-allowed unsafe patterns. This gives you improved safety guarantees that catch more bugs and make refactoring easier. And you can implement these stronger guarantees incrementally, on a file-by-file basis.\n\n## Features\n\nEnabling Flow Strict for a file means that several previously-allowed patterns will now trigger a Flow error. Each disallowed pattern has a corresponding [Flow Lint](https://flow.org/en/linting/) rule which triggers the error. The list of rules enabled for `@flow strict` is configured in each `.flowconfig`. Here are the recommended rules:\n\n- [`nonstrict-import`](https://flow.org/en/linting/rule-reference/#toc-nonstrict-import): Triggers an error when importing from a module which is not also `@flow strict`. This is very important, because it means that when a file is marked as strict, all of its dependencies are strict as well.\n- [`unclear-type`](https://flow.org/en/linting/rule-reference/#toc-unclear-type): Triggers an error when using `Object`, `Function`, or `any` in a type annotation.\n- [`untyped-import`](https://flow.org/en/linting/rule-reference/#toc-untyped-import): Triggers an error when importing from an untyped module.\n- [`untyped-type-import`](https://flow.org/en/linting/rule-reference/#toc-untyped-type-import): Triggers an error when importing a type from an untyped module.\n- [`unsafe-getters-setters`](https://flow.org/en/linting/rule-reference/#toc-unsafe-getters-setters): Triggers an error when using getters and setters, which can be unsafe.\n- [`sketchy-null`](https://flow.org/en/linting/rule-reference/#toc-sketchy-null): Triggers an error when doing an existence check on a value that could be null/undefined or falsey.\n\nFor a full list of available lint rules, see the [Lint Rule Reference](https://flow.org/en/linting/rule-reference/).\n\nAdditionally, note that function parameters are considered const (i.e., treated as if they were declared with `const` rather than `let`). This feature is not yet configurable in Flow Strict; it is always on.\n\n## Enabling Flow Strict in a .flowconfig\n\nFlow Strict is configured in each `.flowconfig`. To enable:\n\n1.  Add a `[strict]` section to the `.flowconfig`.\n\n2.  List the lint rules to enable . These are strongly recommended:\n\n    ``` text\n    [strict]\n    nonstrict-import\n    unclear-type\n    unsafe-getters-setters\n    untyped-import\n    untyped-type-import\n    ```\n\n    Also recommended, but optional as it may be too noisy in some codebases: `sketchy-null`\n\nWe recommend you enable all your desired rules from the beginning, then adopt Flow Strict file-by-file. This works better than enabling a single rule, adding `@flow strict` to many files, and then adding more rules to the config.\n\n## Adoption\n\nAdd `@flow strict` to a file and fix all errors that appear. Because Flow Strict requires dependencies to also be strict (if the `nonstrict-import` rule is enabled), start at the leaves of the dependency tree and work up from there. Do not add `$FlowFixMe` to suppress the new errors as they appear; just add `@flow strict` once all issues have been resolved. Since the most common reasons for using `$FlowFixMe` stem from reliance on untyped dependencies or behavior, future issues should be greatly reduced once Flow Strict is enabled.\n\nBe liberal with enabling Flow Strict. Unlike adding or removing `@flow`, adding or removing `@flow strict` (by itself) does not change Flow coverage. It only prevents or allows certain new unsafe behavior from being added in the future. Even if in the future Flow Strict has to be disabled for the file, at least unsafe behavior was prevented from being added in the meantime.\n\nLibrary definitions are considered strict (as they can be included in many different projects with contradicting strict configurations).\n\n## Strict Local\n\nIf you enable the `nonstrict-import` rule in your Flow Strict configuration (recommended), then all dependencies of a strict file must also be strict. While this the optimal goal, for large pre-existing codebases it may be beneficial to allow some of the benefits of Flow Strict to be put in use before all dependencies are strict.\n\n`@flow strict-local` is the same as `@flow strict`, except it does not require its dependencies to also be strict (i.e. it is ‚Äúlocally‚Äù strict). It does not have a separate configuration: it uses the same configuration as Flow Strict, just without the `nonstrict-import` rule.\n\nOnce all the dependencies of a `@flow strict-local` file are strict, the file can be upgraded to a `@flow strict` file. A `@flow strict` file cannot depend on a `@flow strict-local` file as this would break the `nonstrict-import` rule.\n\n## What‚Äôs Ahead\n\nEventually, some features of Flow Strict could become the default behavior of Flow, if those features prove successful and achieve widespread adoption.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/strict](https://flow.org/en/docs/strict)"
- name: flow-remove-types
  id: tools/flow-remove-types
  summary: flow-remove-types is a small CLI tool for stripping Flow type annotations from files
  description: "# flow-remove-types\n\n[`flow-remove-types`](https://github.com/facebook/flow/tree/master/packages/flow-remove-types) is a small CLI tool for stripping Flow type annotations from files. It‚Äôs a lighter-weight alternative to Babel for projects that don‚Äôt need everything Babel provides.\n\nFirst install `flow-remove-types` with either [Yarn](https://yarnpkg.com/) or [npm](https://www.npmjs.com/).\n\n``` sh\nyarn add --dev flow-remove-types\n# or\nnpm install --save-dev flow-remove-types\n```\n\nIf you then put all your source files in a `src` directory you can compile them to another directory by running:\n\n``` sh\nyarn run flow-remove-types src/ -d lib/\n```\n\nYou can add this to your `package.json` scripts easily.\n\n``` json\n{\n  \"name\": \"my-project\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"build\": \"flow-remove-types src/ -d lib/\",\n    \"prepublish\": \"yarn run build\"\n  }\n}\n```\n\n> **Note:** You‚Äôll probably want to add a `prepublish` script that runs this transform as well, so that it runs before you publish your code to the npm registry.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/tools/flow-remove-types](https://flow.org/en/docs/tools/flow-remove-types)"
- name: Flowlint Comments
  id: linting/flowlint-comments
  summary: Configuring lint settings with flowlint comments allows you to specify different settings within a file and different settings to different regions of different files
  description: "# Flowlint Comments\n\nConfiguring lint settings with `flowlint` comments allows you to specify different settings within a file and different settings to different regions of different files. These comments come in three forms:\n\n- [flowlint](#toc-flowlint)\n- [flowlint-line](#toc-flowlint-line)\n- [flowlint-next-line](#toc-flowlint-next-line)\n\nIn all forms, whitespace and asterisks between words are ignored, allowing for flexible formatting.\n\n## flowlint\n\nThe basic `flowlint` comment takes a comma-delimited list of `rule:severity` pairs and applies those settings for the rest of the source file until overridden. This has three primary purposes: applying settings over a block, applying settings over a file, and applying settings over part of a line.\n\n**settings over a block of code:** A pair of `flowlint` comments can be used to apply a certain setting over a block of code. For example, to disabling the untyped-type-import lint over a block of type imports would look like this:\n\n``` javascript\nimport type {\n  // flowlint untyped-type-import:off\n  Foo,\n  Bar,\n  Baz,\n  // flowlint untyped-type-import:error\n} from './untyped.js';\n```\n\n**settings over a file:** A `flowlint` comment doesn‚Äôt have to have a matching comment to form a block. An unmatched comment simply applies its settings to the rest of the file. You could use this, for example, to suppress all sketchy-null-check lints in a particular file:\n\n``` javascript\n// flowlint sketchy-null:off\n...\n```\n\n**settings over part of a line:** The settings applied by `flowlint` start and end right at the comment itself. This means that you can do things like\n\n``` javascript\nfunction (a: ?boolean, b: ?boolean) {\n  if (/* flowlint sketchy-null-bool:off */a/* flowlint sketchy-null-bool:warn */ && b) {\n    ...\n  } else {\n    ...\n  }\n}\n```\n\nif you want control at an even finer level than you get from the line-based comments.\n\n## flowlint-line\n\nA `flowlint-line` comment works similarly to a `flowlint` comment, except it only applies its settings to the current line instead of applying them for the rest of the file. The primary use for `flowlint-line` comments is to suppress a lint on a particular line:\n\n``` javascript\nfunction (x: ?boolean) {\n  if (x) { // flowlint-line sketchy-null-bool:off\n    ...\n  } else {\n    ...\n  }\n}\n```\n\n## flowlint-next-line\n\n`flowlint-next-line` works the same as `flowlint-line`, except it applies its settings to the next line instead of the current line:\n\n``` javascript\nfunction (x: ?boolean) {\n  // flowlint-next-line sketchy-null-bool:off\n  if (x) {\n    ...\n  } else {\n    ...\n  }\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/linting/flowlint-comments](https://flow.org/en/docs/linting/flowlint-comments)"
- name: Function Types
  id: types/functions
  summary: 'Functions have two places where types are applied: Parameters (input) and the return value (output)'
  description: "# Function Types\n\nFunctions have two places where types are applied: Parameters (input) and the return value (output).\n\n``` javascript\n// @flow\nfunction concat(a: string, b: string): string {\n  return a + b;\n}\n\nconcat(\"foo\", \"bar\"); // Works!\n// $ExpectError\nconcat(true, false);  // Error!\n```\n\nUsing inference, these types are often optional:\n\n``` javascript\n// @flow\nfunction concat(a, b) {\n  return a + b;\n}\n\nconcat(\"foo\", \"bar\"); // Works!\n// $ExpectError\nconcat(true, false);  // Error!\n```\n\nSometimes Flow‚Äôs inference will create types that are more permissive than you want them to be.\n\n``` javascript\n// @flow\nfunction concat(a, b) {\n  return a + b;\n}\n\nconcat(\"foo\", \"bar\"); // Works!\nconcat(1, 2);         // Works!\n```\n\nFor that reason (and others), it‚Äôs useful to write types for important functions.\n\n## Syntax of functions\n\nThere are three forms of functions that each have their own slightly different syntax.\n\n### Function Declarations\n\nHere you can see the syntax for function declarations with and without types added.\n\n``` javascript\nfunction method(str, bool, ...nums) {\n  // ...\n}\n\nfunction method(str: string, bool?: boolean, ...nums: Array<number>): void {\n  // ...\n}\n```\n\n### Arrow Functions\n\nHere you can see the syntax for arrow functions with and without types added.\n\n``` javascript\nlet method = (str, bool, ...nums) => {\n  // ...\n};\n\nlet method = (str: string, bool?: boolean, ...nums: Array<number>): void => {\n  // ...\n};\n```\n\n### Function Types\n\nHere you can see the syntax for writing types that are functions.\n\n``` javascript\n(str: string, bool?: boolean, ...nums: Array<number>) => void\n```\n\nYou may also optionally leave out the parameter names.\n\n``` javascript\n(string, boolean | void, Array<number>) => void\n```\n\nYou might use these functions types for something like a callback.\n\n``` javascript\nfunction method(callback: (error: Error | null, value: string | null) => void) {\n  // ...\n}\n```\n\n## Function Parameters\n\nFunction parameters can have types by adding a colon `:` followed by the type after the name of the parameter.\n\n``` javascript\nfunction method(param1: string, param2: boolean) {\n  // ...\n}\n```\n\n## Optional Parameters\n\nYou can also have optional parameters by adding a question mark `?` after the name of the parameter and before the colon `:`.\n\n``` javascript\nfunction method(optionalValue?: string) {\n  // ...\n}\n```\n\nOptional parameters will accept missing, `undefined`, or matching types. But they will not accept `null`.\n\n``` javascript\n// @flow\nfunction method(optionalValue?: string) {\n  // ...\n}\n\nmethod();          // Works.\nmethod(undefined); // Works.\nmethod(\"string\");  // Works.\n// $ExpectError\nmethod(null);      // Error!\n```\n\n### Rest Parameters\n\nJavaScript also supports having rest parameters or parameters that collect an array of arguments at the end of a list of parameters. These have an ellipsis `...` before them.\n\nYou can also add type annotations for rest parameters using the same syntax but with an `Array`.\n\n``` javascript\nfunction method(...args: Array<number>) {\n  // ...\n}\n```\n\nYou can pass as many arguments as you want into a rest parameter.\n\n``` javascript\n// @flow\nfunction method(...args: Array<number>) {\n  // ...\n}\n\nmethod();        // Works.\nmethod(1);       // Works.\nmethod(1, 2);    // Works.\nmethod(1, 2, 3); // Works.\n```\n\n> Note: If you add a type annotation to a rest parameter, it must always explicitly be an `Array` type.\n\n### Function Returns\n\nFunction returns can also add a type using a colon `:` followed by the type after the list of parameters.\n\n``` javascript\nfunction method(): number {\n  // ...\n}\n```\n\nReturn types ensure that every branch of your function returns the same type. This prevents you from accidentally not returning a value under certain conditions.\n\n``` javascript\n// @flow\n// $ExpectError\nfunction method(): boolean {\n  if (Math.random() > 0.5) {\n    return true;\n  }\n}\n```\n\nAsync functions implicitly return a promise, so the return type must always be a `Promise`.\n\n``` javascript\n// @flow\nasync function method(): Promise<number> {\n  return 123;\n}\n```\n\n### Function `this`\n\nEvery function in JavaScript can be called with a special context named `this`. You can call a function with any context that you want. Flow allows you to annotate the type for this context by adding a special parameter at the start of the function‚Äôs parameter list:\n\n``` javascript\n// @flow\nfunction method<T>(this: { x: T }) : T {\n  return this.x;\n}\n\nvar num: number = method.call({x : 42});\nvar str: string = method.call({x : 42}); // error\n```\n\nThis parameter has no effect at runtime, and is erased along with types when Flow is transformed into JavaScript. When present, `this` parameters must always appear at the very beginning of the function‚Äôs parameter list, and must have an annotation. Additionally, [arrow functions](../types#toc-arrow-functions) may not have a `this` parameter annotation, as these functions bind their `this` parameter at the definition site, rather than the call site.\n\nIf an explicit `this` parameter is not provided, Flow will attempt to infer one based on usage. If `this` is not mentioned in the body of the function, Flow will infer `mixed` for its `this` parameter.\n\n### Predicate Functions\n\nSometimes you will want to move the condition from an `if` statement into a function:\n\n``` javascript\nfunction concat(a: ?string, b: ?string): string {\n  if (a && b) {\n    return a + b;\n  }\n  return '';\n}\n```\n\nHowever, Flow will flag an error in the code below:\n\n``` javascript\nfunction truthy(a, b): boolean {\n  return a && b;\n}\n\nfunction concat(a: ?string, b: ?string): string {\n  if (truthy(a, b)) {\n    // $ExpectError\n    return a + b;\n  }\n  return '';\n}\n```\n\nYou can fix this by making `truthy` a *predicate function*, by using the `%checks` annotation like so:\n\n``` javascript\nfunction truthy(a, b): boolean %checks {\n  return !!a && !!b;\n}\n\nfunction concat(a: ?string, b: ?string): string {\n  if (truthy(a, b)) {\n    return a + b;\n  }\n  return '';\n}\n```\n\n#### Limitations of predicate functions\n\nThe body of these predicate functions need to be expressions (i.e. local variable declarations are not supported). But it‚Äôs possible to call other predicate functions inside a predicate function. For example:\n\n``` javascript\nfunction isString(y): %checks {\n  return typeof y === \"string\";\n}\n\nfunction isNumber(y): %checks {\n  return typeof y === \"number\";\n}\n\nfunction isNumberOrString(y): %checks {\n  return isString(y) || isNumber(y);\n}\n\nfunction foo(x): string | number {\n  if (isNumberOrString(x)) {\n    return x + x;\n  } else {\n    return x.length; // no error, because Flow infers that x can only be an array\n  }\n}\n\nfoo('a');\nfoo(5);\nfoo([]);\n```\n\nAnother limitation is on the range of predicates that can be encoded. The refinements that are supported in a predicate function must refer directly to the value that is passed in as an argument to the respective call.\n\nFor example, consider the *inlined* refinement\n\n``` javascript\ndeclare var obj: { n?: number };\n\nif (obj.n) {\n  const n: number = obj.n;\n}\n```\n\nHere, Flow will let you refine `obj.n` from `?number` to `number`. Note that the refinement here is on the property `n` of `obj`, rather than `obj` itself.\n\nIf you tried to create a *predicate* function\n\n``` javascript\nfunction bar(a): %checks {\n  return a.n;\n}\n```\n\nto encode the same condition, then the following refinement would fail\n\n``` javascript\nif (bar(obj)) {\n  // $ExpectError\n  const n: number = obj.n;\n}\n```\n\nThis is because the only refinements supported through `bar` would be on `obj` itself.\n\n### Callable Objects\n\nCallable objects can be typed, for example:\n\n``` javascript\ntype CallableObj = {\n  (number, number): number,\n  bar: string\n};\n\nfunction add(x, y) {\n  return x + y;\n}\n\n// $ExpectError\n(add: CallableObj);\n\nadd.bar = \"hello world\";\n\n(add: CallableObj);\n```\n\n### `Function` Type\n\n> NOTE: For new code prefer `any` or `(...args: Array<any>) => any`. `Function` has become an alias to `any` and will be deprecated and removed in a future version of Flow.\n\nSometimes it is useful to write types that accept arbitrary functions, for those you should write `() => mixed` like this:\n\n``` javascript\nfunction method(func: () => mixed) {\n  // ...\n}\n```\n\nHowever, if you need to opt-out of the type checker, and don‚Äôt want to go all the way to `any`, you can instead use `(...args: Array<any>) => any`. (Note that [`any`](../any) is unsafe and should be avoided). For historical reasons, the `Function` keyword is still available.\n\nFor example, the following code will not report any errors:\n\n``` javascript\nfunction method(func: (...args: Array<any>) => any) {\n  func(1, 2);     // Works.\n  func(\"1\", \"2\"); // Works.\n  func({}, []);   // Works.\n}\n\nmethod(function(a: number, b: number) {\n  // ...\n});\n```\n\nNeither will this:\n\n``` javascript\nfunction method(obj: Function) {\n  obj = 10;\n}\n\nmethod(function(a: number, b: number) {\n  // ...\n});\n```\n\n> ***You should follow [all the same rules](../any) as `any` when using `Function`.***\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/functions](https://flow.org/en/docs/types/functions)"
- name: Generic Types
  id: types/generics
  summary: Generics (sometimes referred to as polymorphic types) are a way of abstracting a type away
  description: "# Generic Types\n\nGenerics (sometimes referred to as polymorphic types) are a way of abstracting a type away.\n\nImagine writing the following `identity` function which returns whatever value was passed.\n\n``` javascript\nfunction identity(value) {\n  return value;\n}\n```\n\nWe would have a lot of trouble trying to write specific types for this function since it could be anything.\n\n``` javascript\nfunction identity(value: string): string {\n  return value;\n}\n```\n\nInstead we can create a generic (or polymorphic type) in our function and use it in place of other types.\n\n``` javascript\nfunction identity<T>(value: T): T {\n  return value;\n}\n```\n\nGenerics can be used within functions, function types, classes, type aliases, and interfaces.\n\n> **Warning:** Flow does not infer generic types. If you want something to have a generic type, **annotate it**. Otherwise, Flow may infer a type that is less polymorphic than you expect.\n\nIn the following example, we forget to properly annotate `identity` with a generic type, so we run into trouble when we try to assign it to `func`. On the other hand, `genericIdentity` is properly typed, and we are able to use it as expected.\n\n``` javascript\n// @flow\n\ntype IdentityWrapper = {\n  func<T>(T): T\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction genericIdentity<T>(value: T): T {\n  return value;\n}\n\n// $ExpectError\nconst bad: IdentityWrapper = { func: identity }; // Error!\nconst good: IdentityWrapper = { func: genericIdentity }; // Works!\n```\n\n### Syntax of generics\n\nThere are a number of different places where generic types appear in syntax.\n\n##### Functions with generics\n\nFunctions can create generics by adding the type parameter list `<T>` before the function parameter list.\n\nYou can use generics in the same places you‚Äôd add any other type in a function (parameter or return types).\n\n``` javascript\nfunction method<T>(param: T): T {\n  // ...\n}\n\nfunction<T>(param: T): T {\n  // ...\n}\n```\n\n##### Function types with generics\n\nFunction types can create generics in the same way as normal functions, by adding the type parameter list `<T>` before the function type parameter list.\n\nYou can use generics in the same places you‚Äôd add any other type in a function type (parameter or return types).\n\n``` javascript\n<T>(param: T) => T\n```\n\nWhich then gets used as its own type.\n\n``` javascript\nfunction method(func: <T>(param: T) => T) {\n  // ...\n}\n```\n\n##### Classes with generics\n\nClasses can create generics by placing the type parameter list before the body of the class.\n\n``` javascript\nclass Item<T> {\n  // ...\n}\n```\n\nYou can use generics in the same places you‚Äôd add any other type in a class (property types and method parameter/return types).\n\n``` javascript\nclass Item<T> {\n  prop: T;\n\n  constructor(param: T) {\n    this.prop = param;\n  }\n\n  method(): T {\n    return this.prop;\n  }\n}\n```\n\n##### Type aliases with generics\n\n``` javascript\ntype Item<T> = {\n  foo: T,\n  bar: T,\n};\n```\n\n##### Interfaces with generics\n\n``` javascript\ninterface Item<T> {\n  foo: T,\n  bar: T,\n}\n```\n\n##### Supplying Type Arguments to Callables\n\nYou can give callable entities type arguments for their generics directly in the call:\n\n``` javascript\n//@flow\nfunction doSomething<T>(param: T): T {\n  // ...\n  return param;\n}\n\ndoSomething<number>(3);\n```\n\nYou can also give generic classes type arguments directly in the `new` expression:\n\n``` javascript\n//@flow\nclass GenericClass<T> {}\nconst c = new GenericClass<number>();\n```\n\nIf you only want to specify some of the type arguments, you can use `_` to let flow infer a type for you:\n\n``` javascript\n//@flow\nclass GenericClass<T, U, V>{}\nconst c = new GenericClass<_, number, _>()\n```\n\n> **Warning:** For performance purposes, we always recommend you annotate with concrete arguments when you can. `_` is not unsafe, but it is slower than explicitly specifying the type arguments.\n\n## Behavior of generics\n\n#### Generics act like variables\n\nGeneric types work a lot like variables or function parameters except that they are used for types. You can use them whenever they are in scope.\n\n``` javascript\nfunction constant<T>(value: T): () => T {\n  return function(): T {\n    return value;\n  };\n}\n```\n\n#### Create as many generics as you need\n\nYou can have as many of these generics as you need in the type parameter list, naming them whatever you want:\n\n``` javascript\nfunction identity<One, Two, Three>(one: One, two: Two, three: Three) {\n  // ...\n}\n```\n\n#### Generics track values around\n\nWhen using a generic type for a value, Flow will track the value and make sure that you aren‚Äôt replacing it with something else.\n\n``` javascript\n// @flow\nfunction identity<T>(value: T): T {\n  // $ExpectError\n  return \"foo\"; // Error!\n}\n\nfunction identity<T>(value: T): T {\n  // $ExpectError\n  value = \"foo\"; // Error!\n  // $ExpectError\n  return value;  // Error!\n}\n```\n\nFlow tracks the specific type of the value you pass through a generic, letting you use it later.\n\n``` javascript\n// @flow\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nlet one: 1 = identity(1);\nlet two: 2 = identity(2);\n// $ExpectError\nlet three: 3 = identity(42);\n```\n\n#### Adding types to generics\n\nSimilar to `mixed`, generics have an ‚Äúunknown‚Äù type. You‚Äôre not allowed to use a generic as if it were a specific type.\n\n``` javascript\n// @flow\nfunction logFoo<T>(obj: T): T {\n  // $ExpectError\n  console.log(obj.foo); // Error!\n  return obj;\n}\n```\n\nYou could refine the type, but the generic will still allow any type to be passed in.\n\n``` javascript\n// @flow\nfunction logFoo<T>(obj: T): T {\n  if (obj && obj.foo) {\n    console.log(obj.foo); // Works.\n  }\n  return obj;\n}\n\nlogFoo({ foo: 'foo', bar: 'bar' });  // Works.\nlogFoo({ bar: 'bar' }); // Works. :(\n```\n\nInstead, you could add a type to your generic like you would with a function parameter.\n\n``` javascript\n// @flow\nfunction logFoo<T: { foo: string }>(obj: T): T {\n  console.log(obj.foo); // Works!\n  return obj;\n}\n\nlogFoo({ foo: 'foo', bar: 'bar' });  // Works!\n// $ExpectError\nlogFoo({ bar: 'bar' }); // Error!\n```\n\nThis way you can keep the behavior of generics while only allowing certain types to be used.\n\n``` javascript\n// @flow\nfunction identity<T: number>(value: T): T {\n  return value;\n}\n\nlet one: 1 = identity(1);\nlet two: 2 = identity(2);\n// $ExpectError\nlet three: \"three\" = identity(\"three\");\n```\n\n#### Generic types act as bounds\n\n``` javascript\n// @flow\nfunction identity<T>(val: T): T {\n  return val;\n}\n\nlet foo: 'foo' = 'foo';           // Works!\nlet bar: 'bar' = identity('bar'); // Works!\n```\n\nIn Flow, most of the time when you pass one type into another you lose the original type. So that when you pass a specific type into a less specific one Flow ‚Äúforgets‚Äù it was once something more specific.\n\n``` javascript\n// @flow\nfunction identity(val: string): string {\n  return val;\n}\n\nlet foo: 'foo' = 'foo';           // Works!\n// $ExpectError\nlet bar: 'bar' = identity('bar'); // Error!\n```\n\nGenerics allow you to hold onto the more specific type while adding a constraint. In this way types on generics act as ‚Äúbounds‚Äù.\n\n``` javascript\n// @flow\nfunction identity<T: string>(val: T): T {\n  return val;\n}\n\nlet foo: 'foo' = 'foo';           // Works!\nlet bar: 'bar' = identity('bar'); // Works!\n```\n\nNote that when you have a value with a bound generic type, you can‚Äôt use it as if it were a more specific type.\n\n``` javascript\n// @flow\nfunction identity<T: string>(val: T): T {\n  let str: string = val; // Works!\n  // $ExpectError\n  let bar: 'bar'  = val; // Error!\n  return val;\n}\n\nidentity('bar');\n```\n\n#### Parameterized generics\n\nGenerics sometimes allow you to pass types in like arguments to a function. These are known as parameterized generics (or parametric polymorphism).\n\nFor example, a type alias with a generic is parameterized. When you go to use it you will have to provide a type argument.\n\n``` javascript\ntype Item<T> = {\n  prop: T,\n}\n\nlet item: Item<string> = {\n  prop: \"value\"\n};\n```\n\nYou can think of this like passing arguments to a function, only the return value is a type that you can use.\n\nClasses (when being used as a type), type aliases, and interfaces all require that you pass type arguments. Functions and function types do not have parameterized generics.\n\n***Classes***\n\n``` javascript\n// @flow\nclass Item<T> {\n  prop: T;\n  constructor(param: T) {\n    this.prop = param;\n  }\n}\n\nlet item1: Item<number> = new Item(42); // Works!\n// $ExpectError\nlet item2: Item = new Item(42); // Error!\n```\n\n***Type Aliases***\n\n``` javascript\n// @flow\ntype Item<T> = {\n  prop: T,\n};\n\nlet item1: Item<number> = { prop: 42 }; // Works!\n// $ExpectError\nlet item2: Item = { prop: 42 }; // Error!\n```\n\n***Interfaces***\n\n``` javascript\n// @flow\ninterface HasProp<T> {\n  prop: T,\n}\n\nclass Item {\n  prop: string;\n}\n\n(Item.prototype: HasProp<string>); // Works!\n// $ExpectError\n(Item.prototype: HasProp); // Error!\n```\n\n##### Adding defaults to parameterized generics\n\nYou can also provide defaults for parameterized generics just like parameters of a function.\n\n``` javascript\ntype Item<T: number = 1> = {\n  prop: T,\n};\n\nlet foo: Item<> = { prop: 1 };\nlet bar: Item<2> = { prop: 2 };\n```\n\nYou must always include the brackets `<>` when using the type (just like parentheses for a function call).\n\n#### Variance Sigils\n\nYou can also specify the subtyping behavior of a generic via variance sigils. By default, generics behave invariantly, but you may add a `+` to their declaration to make them behave covariantly, or a `-` to their declaration to make them behave contravariantly. See [our docs on variance](https://flow.org/en/lang/variance) for a more information on variance in Flow.\n\nVariance sigils allow you to be more specific about how you intend to use your generics, giving Flow the power to do more precise type checking. For example, you may want this relationship to hold:\n\n``` javascript\n//@flow\ntype GenericBox<+T> = T;\n\nvar x: GenericBox<number> = 3;\n(x: GenericBox<number| string>);\n```\n\nThe example above could not be accomplished without the `+` variance sigil:\n\n``` javascript\n//@flow\ntype GenericBoxError<T> = T;\n\nvar x: GenericBoxError<number> = 3;\n(x: GenericBoxError<number| string>); // number | string is not compatible with number.\n```\n\nNote that if you annotate your generic with variance sigils then Flow will check to make sure those types only appear in positions that make sense for that variance sigil. For example, you cannot declare a generic type parameter to behave covariantly and use it in a contravariant position:\n\n``` javascript\n//@flow\ntype NotActuallyCovariant<+T> = (T) => void;\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/generics](https://flow.org/en/docs/types/generics)"
- name: Getting Started
  id: getting-started
  summary: Flow is a static type checker for your JavaScript code
  description: "# Getting Started\n\nFlow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale.\n\nFlow checks your code for errors through **static type annotations**. These *types* allow you to tell Flow how you want your code to work, and Flow will make sure it does work that way.\n\n``` javascript\n// @flow\nfunction square(n: number): number {\n  return n * n;\n}\n\nsquare(\"2\"); // Error!\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/getting-started](https://flow.org/en/docs/getting-started)"
- name: Getting Started
  id: react
  summary: Developers will often use Flow and React together, so it is important that Flow can effectively type both common and advanced React patterns
  description: "# Getting Started\n\nDevelopers will often use Flow and React together, so it is important that Flow can effectively type both common and advanced React patterns. This guide will teach you how to use Flow to create safer React applications.\n\nIn this guide we will assume you know [the React basics](https://facebook.github.io/react/docs/hello-world.html) and focus on adding types for patterns you are already familiar with. We will be using examples based on `react-dom`, but all of these patterns work in other environments like `react-native` as well.\n\n## Setup Flow with React\n\nFlow and Babel work well together, so it doesn‚Äôt take much to adopt Flow as a React user who already uses Babel. If you need to setup Babel with Flow, you can follow [this guide](https://flow.org/en/tools/babel/).\n\nBabel also [works out of the box with Create React App](https://flow.org/en/tools/create-react-app/), just install Flow and create a `.flowconfig`.\n\n## React Runtimes\n\nFlow supports the `@babel/plugin-transform-react-jsx` runtime options required to use JSX without explicitly importing the React namespace.\n\nIf you are using the new automatic runtime, use this configuration in your `.flowconfig` so that Flow knows to auto-import `jsx`:\n\n``` ini\n[options]\nreact.runtime=automatic\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react](https://flow.org/en/docs/react)"
- name: Higher-order Components
  id: react/hoc
  summary: A popular pattern in React is the higher-order component pattern, so it‚Äôs important that we can provide effective types for higher-order components in Flow
  description: "# Higher-order Components\n\nA popular pattern in React is the [higher-order component pattern](https://facebook.github.io/react/docs/higher-order-components.html), so it‚Äôs important that we can provide effective types for higher-order components in Flow. If you don‚Äôt already know what a higher-order component is then make sure to read the [React documentation on higher-order components](https://facebook.github.io/react/docs/higher-order-components.html) before continuing.\n\nIn 0.89.0, we introduced [`React.AbstractComponent`](../types#toc-react-abstractcomponent), which gives you more expressive power when writing HOCs and library definitions.\n\nLet‚Äôs take a look at how you can type some example HOCs.\n\n## The Trivial HOC\n\nLet‚Äôs start with the simplest HOC:\n\n``` javascript\n//@flow\nimport * as React from 'react';\n\nfunction trivialHOC<Config: {}>(\n  Component: React.AbstractComponent<Config>\n): React.AbstractComponent<Config> {\n  return Component;\n}\n```\n\nThis is a basic template for what your HOCs might look like. At runtime, this HOC doesn‚Äôt do anything at all. Let‚Äôs take a look at some more complex examples.\n\n## Injecting Props\n\nA common use case for higher-order components is to inject a prop. The HOC automatically sets a prop and returns a component which no longer requires that prop. For example, consider a navigation prop, or in the case of [`react-redux` a `store` prop](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options). How would one type this?\n\nTo remove a prop from the config, we can take a component that includes the prop and return a component that does not. It‚Äôs best to construct these types using object type spread.\n\n``` javascript\n//@flow\nimport * as React from 'react';\n\ntype InjectedProps = {| foo: number |}\n\nfunction injectProp<Config>(\n  Component: React.AbstractComponent<{| ...Config, ...InjectedProps |}>\n): React.AbstractComponent<Config> {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\nclass MyComponent extends React.Component<{|\n  a: number,\n  b: number,\n  ...InjectedProps,\n|}> {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// We don't need to pass in `foo` even though `MyComponent` requires it.\n<MyEnhancedComponent a={1} b={2} />;\n```\n\n## Preserving the Instance Type of a Component\n\nRecall that the instance type of a function component is `void`. Our example above wraps a component in a function, so the returned component has the instance type `void`.\n\n``` javascript\n//@flow\nimport * as React from 'react';\n\ntype InjectedProps = {| foo: number |}\n\nfunction injectProp<Config>(\n  Component: React.AbstractComponent<{| ...Config, ...InjectedProps |}>\n): React.AbstractComponent<Config> {\n  return function WrapperComponent(\n    props: Config,\n  ) {\n    return <Component {...props} foo={42} />;\n  };\n}\n\nclass MyComponent extends React.Component<{|\n  a: number,\n  b: number,\n  ...InjectedProps,\n|}> {}\n\nconst MyEnhancedComponent = injectProp(MyComponent);\n\n// If we create a ref object for the component, it will never be assigned\n// an instance of MyComponent!\nconst ref = React.createRef<MyComponent>();\n\n// Error, mixed is incompatible with MyComponent.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n```\n\nWe get this error message because `React.AbstractComponent<Config>` doesn‚Äôt set the `Instance` type parameter, so it is automatically set to `mixed`. If we wanted to preserve the instance type of the component, we can use [`React.forwardRef`](https://reactjs.org/docs/forwarding-refs.html):\n\n``` javascript\n//@flow\nimport * as React from 'react';\n\ntype InjectedProps = {| foo: number |}\n\nfunction injectAndPreserveInstance<Config, Instance>(\n  Component: React.AbstractComponent<{| ...Config, ...InjectedProps |}, Instance>\n): React.AbstractComponent<Config, Instance> {\n  return React.forwardRef<Config, Instance>((props, ref) =>\n      <Component ref={ref} foo={3} {...props} />\n  );\n}\n\nclass MyComponent extends React.Component<{\n  a: number,\n  b: number,\n  ...InjectedProps,\n}> {}\n\nconst MyEnhancedComponent = injectAndPreserveInstance(MyComponent);\n\nconst ref = React.createRef<MyComponent>();\n\n// All good! The ref is forwarded.\n<MyEnhancedComponent ref={ref} a={1} b={2} />;\n```\n\n## Exporting Wrapped Components\n\nIf you try to export a wrapped component, chances are that you‚Äôll run into a missing annotation error:\n\n``` javascript\n//@flow\nimport * as React from 'react';\n\nfunction trivialHOC<Config: {}>(\n  Component: React.AbstractComponent<Config>,\n): React.AbstractComponent<Config> {\n  return Component;\n}\n\ntype DefaultProps = {| foo: number |};\ntype Props = {...DefaultProps, bar: number};\n\nclass MyComponent extends React.Component<Props> {\n  static defaultProps: DefaultProps = {foo: 3};\n}\n\n// Error, missing annotation for Config.\nconst MyEnhancedComponent = trivialHOC(MyComponent);\n\nmodule.exports = MyEnhancedComponent;\n```\n\nIf your component has no `defaultProps`, you can use `Props` as a type argument for `Config`.\n\nIf your component does have `defaultProps`, you don‚Äôt want to just add `Props` as a type argument to `trivialHOC` because that will get rid of the `defaultProps` information that flow has about your component.\n\nThis is where [`React.Config<Props, DefaultProps>`](../types#toc-react-config) comes in handy! We can use the type for Props and DefaultProps to calculate the `Config` type for our component.\n\n``` javascript\n//@flow\nimport * as React from 'react';\n\nfunction trivialHOC<Config: {}>(\n  Component: React.AbstractComponent<Config>,\n): React.AbstractComponent<Config> {\n  return Component;\n}\n\ntype DefaultProps = {| foo: number |};\ntype Props = {...DefaultProps, bar: number};\n\nclass MyComponent extends React.Component<Props> {\n  static defaultProps: DefaultProps = {foo: 3};\n}\n\nconst MyEnhancedComponent = trivialHOC<React.Config<Props, DefaultProps>>(MyComponent);\n\n// Ok!\nmodule.exports = MyEnhancedComponent;\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/hoc](https://flow.org/en/docs/react/hoc)"
- name: IDE Integration
  id: linting/ide-integration
  summary: In most editors, Flow warnings are likely to be rendered the same way as other warnings are rendered by that editor
  description: "# IDE Integration\n\nIn most editors, Flow warnings are likely to be rendered the same way as other warnings are rendered by that editor.\n\nMost editors will likely display all Flow warnings, which is fine for small- to medium-scale projects, or projects with fewer unsuppressed warnings.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/linting/ide-integration](https://flow.org/en/docs/linting/ide-integration)"
- name: Indexed Access Types
  id: types/indexed-access
  summary: Flow‚Äôs Indexed Access Types allow you to get the type of a property from an object, array, or tuple type
  description: "# Indexed Access Types\n\nFlow‚Äôs Indexed Access Types allow you to get the type of a property from an [object](../objects), [array](../arrays), or [tuple](../tuples) type.\n\nIndexed Access Types are a replacement for the [`$PropertyType`](../utilities#toc-propertytype) and [`$ElementType`](../utilities#toc-elementtype) utility types. If you‚Äôre familiar with those utility types already, here is a quick conversion guide:\n\n- `$PropertyType<Obj, 'prop'>` ‚Üí `Obj['prop']`\n- `$ElementType<Obj, T>` ‚Üí `Obj[T]`\n- `$ElementType<$PropertyType<Obj, 'prop'>, T>` ‚Üí `Obj['prop'][T]`\n\n## Indexed Access Type Usage\n\nAccess an object type‚Äôs property:\n\n``` javascript\n// @flow\ntype Cat = {\n  name: string,\n  age: number,\n  hungry: boolean,\n};\n\ntype Hungry = Cat['hungry']; // type Hungry = boolean\nconst isHungry: Hungry = true; // OK - `Hungry` is an alias for `boolean`\n\n// The index can be a type, not just a literal:\ntype AgeProp = 'age';\ntype Age = Cat[AgeProp]; // type Age = number\nconst catAge: Age = 6; // OK - `Age` is an alias for `number`\n```\n\nAccess an array type‚Äôs element, by getting the type at the array‚Äôs indices (which are `number`s):\n\n``` javascript\n// @flow\ntype CatNames = Array<string>;\n\ntype CatName = CatNames[number]; // type CatName = string\nconst myCatsName: CatName = 'whiskers'; // OK - `CatName` is an alias for `string`\n```\n\nAccess a tuple type‚Äôs elements:\n\n``` javascript\n// @flow\ntype Pair = [string, number];\n\nconst name: Pair[0] = 'whiskers'; // OK - `Pair[0]` is an alias for `string`\nconst age: Pair[1] = 6; // OK - `Pair[1]` is an alias for `number`\nconst wrong: Pair[2] = true; // Error - `Pair` only has two elements\n```\n\nThe index can be a union, including the result of calling [`$Keys<...>`](../utilities#toc-keys):\n\n``` javascript\n// @flow\ntype Cat = {\n  name: string,\n  age: number,\n  hungry: boolean,\n};\n\ntype Values = Cat[$Keys<Cat>]; // type Values = string | number | boolean\n```\n\nThe index can also be a generic:\n\n``` javascript\n// @flow\nfunction getProp<O: {+[string]: mixed}, K: $Keys<O>>(o: O, k: K): O[K] {\n  return o[k];\n}\n\nconst x: number = getProp({a: 42}, 'a'); // OK\nconst y: string = getProp({a: 42}, 'a'); // Error - `number` is not a `string`\ngetProp({a: 42}, 'b'); // Error - `b` does not exist in object type\n```\n\nYou can nest these accesses:\n\n``` javascript\n// @flow\ntype Cat = {\n  name: string,\n  age: number,\n  hungry: boolean,\n  personality: {\n    friendly: boolean,\n    hungerLevel: number,\n  }\n};\n\ntype Friendly = Cat['personality']['friendly']; // type Friendly = boolean\nconst isFriendly: Friendly = true; // Pet the cat\n```\n\n## Optional Indexed Access Types\n\nOptional Indexed Access Types work like optional chaining. They allow you to access properties from nullable object types. If before you did:\n\n``` javascript\ntype T = $ElementType<$NonMaybeType<Obj>, 'prop'> | void;\n```\n\nYou can now do:\n\n``` javascript\ntype T = Obj?.['prop'];\n```\n\nLike optional chaining, the resulting types of Optional Indexed Access Types include `void`. If you have a long chain of nested optional accesses, you can wrap the entire thing with a `$NonMaybeType<...>` if you don‚Äôt want `void` in your resulting type.\n\nExample:\n\n``` javascript\n// @flow\ntype TasksContent = ?{\n  tasks?: Array<{\n    items?: {\n      metadata?: {\n        title: string,\n        completed: boolean,\n      },\n    },\n  }>,\n};\n\ntype TaskData = TasksContent?.['tasks']?.[number]?.['items']?.['metadata'];\n```\n\nThere is one small difference between optional chaining and Optional Indexed Access Types. If the object type you access is not nullable, the resulting type in optional chaining will not include `void`. With Optional Indexed Access Types, for implementation reasons, the resulting type will always include `void`. However, if your object type is not nullable then you don‚Äôt need to use an Optional Indexed Access Type, but should just use a regular Indexed Access Type.\n\n## Adoption\n\nTo use Indexed Access Types, you need to upgrade your infrastructure so that it supports the syntax:\n\n- `flow` and `flow-parser`: 0.155\n- `prettier`: 2.3.2\n- `babel`: 7.14\n\nWe have created an ESLint rule that warns on `$ElementType` and `$PropertyType` usage and recommends Indexed Access Types instead. It includes an auto-fixer that can handle most cases. You can simply enable this rule on your codebase and autofix all existing issues.\n\nInstall [`eslint-plugin-fb-flow`](https://www.npmjs.com/package/eslint-plugin-fb-flow), and add `fb-flow` to your ESLint plugin list. Then enable the rule in your ESLint config:\n\n``` plaintext\n'fb-flow/use-indexed-access-type': 1,\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/indexed-access](https://flow.org/en/docs/types/indexed-access)"
- name: Interface Types
  id: types/interfaces
  summary: Classes in Flow are nominally typed
  description: "# Interface Types\n\nClasses in Flow are nominally typed. This means that when you have two separate classes you cannot use one in place of the other even when they have the same exact properties and methods.\n\n``` javascript\n// @flow\nclass Foo {\n  serialize() { return '[Foo]'; }\n}\n\nclass Bar {\n  serialize() { return '[Bar]'; }\n}\n\n// $ExpectError\nconst foo: Foo = new Bar(); // Error!\n```\n\nInstead, you can use `interface` in order to declare the structure of the class that you are expecting.\n\n``` javascript\n// @flow\ninterface Serializable {\n  serialize(): string;\n}\n\nclass Foo {\n  serialize() { return '[Foo]'; }\n}\n\nclass Bar {\n  serialize() { return '[Bar]'; }\n}\n\nconst foo: Serializable = new Foo(); // Works!\nconst bar: Serializable = new Bar(); // Works!\n```\n\nYou can also declare an anonymous interface:\n\n``` javascript\n// @flow\nclass Foo {\n  a : number\n}\n\n(new Foo() : interface { a : number });\n```\n\nYou can also use `implements` to tell Flow that you want the class to match an interface. This prevents you from making incompatible changes when editing the class.\n\n``` javascript\n// @flow\ninterface Serializable {\n  serialize(): string;\n}\n\nclass Foo implements Serializable {\n  serialize() { return '[Foo]'; } // Works!\n}\n\nclass Bar implements Serializable {\n  // $ExpectError\n  serialize() { return 42; } // Error!\n}\n```\n\nYou can also use `implements` with multiple interfaces.\n\n``` javascript\nclass Foo implements Bar, Baz {\n  // ...\n}\n```\n\n## Interface Syntax\n\nInterfaces are created using the keyword `interface` followed by its name and a block which contains the body of the type definition.\n\n``` javascript\ninterface MyInterface {\n  // ...\n}\n```\n\nThe syntax of the block matches the syntax of object types and has all of the same features.\n\n#### Interface Methods\n\nYou can add methods to interfaces following the same syntax as class methods. Any `this` parameters you provide are also subject to the same restrictions as class methods.\n\n``` javascript\ninterface MyInterface {\n  method(value: string): number;\n}\n```\n\nAlso like [class methods](../classes#toc-class-methods), interface methods must also remain bound to the interface on which they were defined.\n\n#### Interface Properties\n\nYou can add properties to interfaces following the same syntax as class properties.\n\n``` javascript\ninterface MyInterface {\n  property: string;\n}\n```\n\nInterface properties can be optional as well.\n\n``` javascript\ninterface MyInterface {\n  property?: string;\n}\n```\n\n#### Interfaces as maps\n\nYou can create [‚Äúindexer properties‚Äù](../objects#toc-objects-as-maps) the same way as with objects.\n\n``` javascript\ninterface MyInterface {\n  [key: string]: number;\n}\n```\n\n### Interface Generics\n\nInterfaces can also have their own [generics](../generics).\n\n``` javascript\ninterface MyInterface<A, B, C> {\n  property: A;\n  method(val: B): C;\n}\n```\n\nInterface generics are [parameterized](../generics#toc-parameterized-generics). When you use an interface you need to pass parameters for each of its generics.\n\n``` javascript\n// @flow\ninterface MyInterface<A, B, C> {\n  foo: A;\n  bar: B;\n  baz: C;\n}\n\nvar val: MyInterface<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n```\n\n## Interface property variance (read-only and write-only)\n\nInterface properties are [invariant](https://flow.org/en/lang/variance/) by default. But you can add modifiers to make them covariant (read-only) or contravariant (write-only).\n\n``` javascript\ninterface MyInterface {\n  +covariant: number;     // read-only\n  -contravariant: number; // write-only\n}\n```\n\n### Covariant (read-only) properties on interfaces\n\nYou can make a property covariant by adding a plus symbol `+` in front of the property name.\n\n``` javascript\ninterface MyInterface {\n  +readOnly: number | string;\n}\n```\n\nThis allows you to pass a more specific type in place of that property.\n\n``` javascript\n// @flow\ninterface Invariant {  property: number | string }\ninterface Covariant { +readOnly: number | string }\n\nvar x : { property : number } = { property : 42 };\nvar y : { readOnly : number } = { readOnly : 42 };\n\nvar value1: Invariant = x; // Error!\nvar value2: Covariant = y; // Works\n```\n\nBecause of how covariance works, covariant properties also become read-only when used. Which can be useful over normal properties.\n\n``` javascript\n// @flow\ninterface Invariant {  property: number | string }\ninterface Covariant { +readOnly: number | string }\n\nfunction method1(value: Invariant) {\n  value.property;        // Works!\n  value.property = 3.14; // Works!\n}\n\nfunction method2(value: Covariant) {\n  value.readOnly;        // Works!\n  // $ExpectError\n  value.readOnly = 3.14; // Error!\n}\n```\n\n### Contravariant (write-only) properties on interfaces\n\nYou can make a property contravariant by adding a minus symbol - in front of the property name.\n\n``` javascript\ninterface InterfaceName {\n  -writeOnly: number;\n}\n```\n\nThis allows you to pass a less specific type in place of that property.\n\n``` javascript\n// @flow\ninterface Invariant     {  property: number }\ninterface Contravariant { -writeOnly: number }\n\nvar numberOrString = Math.random() > 0.5 ? 42 : 'forty-two';\n\n// $ExpectError\nvar value1: Invariant     = { property: numberOrString };  // Error!\nvar value2: Contravariant = { writeOnly: numberOrString }; // Works!\n```\n\nBecause of how contravariance works, contravariant properties also become write-only when used. Which can be useful over normal properties.\n\n``` javascript\ninterface Invariant     {   property: number }\ninterface Contravariant { -writeOnly: number }\n\nfunction method1(value: Invariant) {\n  value.property;        // Works!\n  value.property = 3.14; // Works!\n}\n\nfunction method2(value: Contravariant) {\n  // $ExpectError\n  value.writeOnly;        // Error!\n  value.writeOnly = 3.14; // Works!\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/interfaces](https://flow.org/en/docs/types/interfaces)"
- name: Intersection Types
  id: types/intersections
  summary: Sometimes it is useful to create a type which is all of a set of other types
  description: "# Intersection Types\n\nSometimes it is useful to create a type which is ***all of*** a set of other types. For example, you might want to write a function which accepts an object which is the combination of other object types. For this, Flow supports **intersection types**.\n\n``` javascript\n// @flow\ntype A = { a: number };\ntype B = { b: boolean };\ntype C = { c: string };\n\nfunction method(value: A & B & C) {\n  // ...\n}\n\n// $ExpectError\nmethod({ a: 1 }); // Error!\n// $ExpectError\nmethod({ a: 1, b: true }); // Error!\nmethod({ a: 1, b: true, c: 'three' }); // Works!\n```\n\n## Intersection type syntax\n\nIntersection types are any number of types which are joined by an ampersand `&`.\n\n``` javascript\nType1 & Type2 & ... & TypeN\n```\n\nYou may also add a leading ampersand which is useful when breaking intersection types onto multiple lines.\n\n``` javascript\ntype Foo =\n  & Type1\n  & Type2\n  & ...\n  & TypeN\n```\n\nEach of the members of a intersection type can be any type, even another intersection type.\n\n``` javascript\ntype Foo = Type1 & Type2;\ntype Bar = Type3 & Type4;\n\ntype Baz = Foo & Bar;\n```\n\n## Intersection types require all in, but one out\n\nIntersection types are the opposite of union types. When calling a function that accepts an intersection type, we must pass in ***all of those types***. But inside of our function we only have to treat it as ***any one of those types***.\n\n``` javascript\n// @flow\ntype A = { a: number };\ntype B = { b: boolean };\ntype C = { c: string };\n\nfunction method(value: A & B & C) {\n  var a: A = value;\n  var b: B = value;\n  var c: C = value;\n}\n```\n\nEven as we treat our value as just one of the types, we do not get an error because it satisfies all of them.\n\n## Intersection of function types\n\nA common use of intersection types is to express functions that return different results based on the input we pass in. Suppose for example that we want to write the type of a function that\n\n- returns a string, when we pass in the value `\"string\"`,\n- returns a number, when we pass in the value `\"number\"`, and\n- returns any possible type (`mixed`), when we pass in any other string.\n\nThe type of this function will be\n\n``` javascript\ntype Fn =\n  & ((x: \"string\") => string)\n  & ((x: \"number\") => number)\n  & ((x: string) => null);\n```\n\nEach line in the above definition is called an *overload*, and we say that functions of type `Fn` are *overloaded*.\n\nNote the use of parentheses around the arrow types. These are necessary to override the precedence of the ‚Äúarrow‚Äù constructor over the intersection.\n\n### Calling an overloaded function\n\nUsing the above definition we can declare a function `fn` that has the following behavior:\n\n``` javascript\ndeclare var fn: Fn;\nvar n: string = fn(\"string\"); // okay\nvar n: number = fn(\"number\"); // okay\nvar n: boolean = fn(\"boolean\"); // error: null is incompatible with number\n```\n\nFlow achieves this behavior by matching the type of the argument to the *first* overload with a compatible parameter type. Notice for example that the argument `\"string\"` matches both the first and the last overload. Flow will just pick the first one. If no overload matches, Flow will raise an error at the call site.\n\n### Declaring overloaded functions\n\nAn equivalent way to declare the same function `fn` would be by using consecutive ‚Äúdeclare function‚Äù statements\n\n``` javascript\ndeclare function fn(x: \"string\"): string;\ndeclare function fn(x: \"number\"): number;\ndeclare function fn(x: string): null;\n```\n\nA limitation in Flow is that it can‚Äôt *check* the body of a function against an intersection type. In other words, if we provided the following implementation for `fn` right after the above declarations\n\n``` javascript\nfunction fn(x) {\n  if (x === \"string\") { return \"\"; }\n  else if (x === \"number\") { return 0; }\n  else { return null; }\n}\n```\n\nFlow silently accepts it (and uses `Fn` as the inferred type), but does not check the implementation against this signature. This makes this kind of declaration a better suited candidate for library definitions, where implementations are omitted.\n\n## Intersections of object types\n\nWhen you create an intersection of object types, you merge all of their properties together.\n\nFor example, when you create an intersection of two objects with different sets of properties, it will result in an object with all of the properties.\n\n``` javascript\n// @flow\ntype One = { foo: number };\ntype Two = { bar: boolean };\n\ntype Both = One & Two;\n\nvar value: Both = {\n  foo: 1,\n  bar: true\n};\n```\n\nWhen you have properties that overlap by having the same name, Flow follows the same strategy as with overloaded functions: it will return the type of the first property that matches this name.\n\nFor example, if you merge two objects with a property named `prop`, first with a type of number and second with a type of boolean, accessing `prop` will return `number`.\n\n``` javascript\ntype One = { prop: number };\ntype Two = { prop: boolean };\n\ndeclare var both: One & Two;\n\nvar prop1: number = both.prop; // okay\nvar prop2: boolean = both.prop; // Error: number is incompatible with boolean\n```\n\n**Note:** When it comes to objects, the order-specific way in which intersection types are implemented in Flow, may often seem counterintuitive from a set theoretic point of view. In sets, the operands of intersection can change order arbitrarily (commutative property). For this reason, it is a better practice to define this kind of operation over object types using the *spread* operator, e.g. `{ ...One, ...Two }`, where the ordering semantics are better specified.\n\n## Impossible intersection types\n\nUsing intersection types, it is possible to create types which are impossible to create at runtime. Intersection types will allow you to combine any set of types, even ones that conflict with one another.\n\nFor example, you can create an intersection of a number and a string.\n\n``` javascript\n// @flow\ntype NumberAndString = number & string;\n\nfunction method(value: NumberAndString) {\n  // ...\n}\n\n// $ExpectError\nmethod(3.14); // Error!\n// $ExpectError\nmethod('hi'); // Error!\n```\n\nBut you can‚Äôt possibly create a value which is both a *number and a string*, but you can create a type for it. There‚Äôs no practical use for creating types like this, but it‚Äôs a side effect of how intersection types work.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/intersections](https://flow.org/en/docs/types/intersections)"
- name: Lazy Modes
  id: lang/lazy-modes
  summary: By default, the Flow server will typecheck all your code
  description: "# Lazy Modes\n\nBy default, the Flow server will typecheck all your code. This way it can answer questions like ‚Äúare there any Flow errors anywhere in my code‚Äù. This is very useful for tooling, like a continuous integration hook which prevents code changes which introduce Flow errors.\n\nHowever, sometimes a Flow user might not care about all the code. If they are editing a file `foo.js`, they might only want Flow to typecheck the subset of the repository needed to answer questions about `foo.js`. Since Flow would only check a smaller number of files, this would be faster. This is the motivation behind Flow‚Äôs lazy mode.\n\n## Classifying Files\n\nLazy mode classifes your code into four categories:\n\n1.  **Focused files**. These are the files which the user cares about.\n2.  **Dependent files**. These are the files which depend on the focused files. Changes to the focused files might cause type errors in the dependent files.\n3.  **Dependency files**. These are the files which are needed in order to typecheck the focused or dependent files.\n4.  **Unchecked files**. All other files.\n\nLazy mode will still find all the JavaScript files and parse them. But it won‚Äôt typecheck the unchecked files.\n\n## Choosing Focused Files\n\nFocused files are all of the files that have changed in one of the following ways.\n\nFlow will focus files when they change on disk, using Flow‚Äôs built-in file watcher (‚Äúdfind‚Äù) or Watchman.\n\nSo, all files that change while Flow is running will be focused. But what about files that change when Flow is not running? If you‚Äôre using Git or Mercurial, Flow will ask it for all of the files that have changed since the mergebase with ‚Äúmaster‚Äù (the common ancestor of the current commit and the master branch).\n\nIf you‚Äôre not using ‚Äúmaster‚Äù (e.g. ‚Äúmain‚Äù instead), you can change this with the `file_watcher.mergebase_with` config. If you‚Äôre working from a clone, you might want to set this to ‚Äúorigin/master‚Äù (for Git), which will focus all files that have changed locally, even if you commit to your local ‚Äúmaster‚Äù branch.\n\nThe net result is that Flow will find the same errors in lazy mode as in a full check, so long as there are no errors upstream. For example, if your CI ensures that there are no errors in ‚Äúmaster,‚Äù then it‚Äôs redundant for Flow to check all of the unchanged files for errors that can‚Äôt exist.\n\n## Using Lazy Mode\n\nTo enable lazy mode, set `lazy_mode=true` in the `.flowconfig`.\n\nTo start a Flow server in lazy mode manually, run\n\n``` bash\nflow server --lazy-mode true\n```\n\n## Forcing Flow to Treat a File as Focused\n\nYou can force Flow to treat one or more files as focused from the CLI.\n\n``` bash\nflow force-recheck --focus ./path/to/A.js /path/to/B.js\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/lazy-modes](https://flow.org/en/docs/lang/lazy-modes)"
- name: Library Definitions
  id: libdefs
  summary: Most real JavaScript programs depend on third-party code and not just code immediately under the control of the project
  description: "# Library Definitions\n\n## What‚Äôs a ‚ÄúLibrary Definition‚Äù?\n\nMost real JavaScript programs depend on third-party code and not just code immediately under the control of the project. That means a project using Flow may need to reference outside code that either doesn‚Äôt have type information or doesn‚Äôt have accurate and/or precise type information. In order to handle this, Flow supports the concept of a ‚Äúlibrary definition‚Äù (AKA ‚Äúlibdef‚Äù).\n\nA libdef is a special file that informs Flow about the type signature of some specific third-party module or package of modules that your application uses. If you‚Äôre familiar with languages that have header files (like `C++`), you can think of libdefs as a similar concept.\n\nThese special files use the same `.js` extension as normal JS code, but they are placed in a directory called `flow-typed` in the root directory of your project. Placement in this directory tells Flow to interpret them as libdefs rather than normal JS files.\n\n> NOTE: Using the `/flow-typed` directory for libdefs is a convention that enables Flow to JustWork‚Ñ¢ out of the box and encourages consistency across projects that use Flow, but it is also possible to explicitly configure Flow to look elsewhere for libdefs using the [`[libs]` section of your `.flowconfig`](https://flow.org/en/config/libs).\n\n## General Best Practices\n\n**Try to provide a libdef for each third-party library your project uses**\n\nIf a third-party library that has no type information is used by your project, Flow will treat it like any other untyped dependency and mark all of its exports as `any`. Interestingly, this is the only place that Flow will implicitly inject `any` into your program.\n\nBecause of this behavior, it is a best practice to find or write libdefs for as many of the third-party libraries that you use as you can. We recommend checking out the `flow-typed` [tool and repository](https://github.com/flowtype/flow-typed/blob/master/README.md) , which helps you quickly find and install pre-existing libdefs for your third-party dependencies.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/libdefs](https://flow.org/en/docs/libdefs)"
- name: Lint Rule Reference
  id: linting/rule-reference
  summary: While all isn‚Äôt technically a lint rule, it‚Äôs worth mentioning here
  description: "# Lint Rule Reference\n\n## Available Lint Rules\n\n- [`all`](#toc-all)\n- [`ambiguous-object-type`](#toc-ambiguous-object-type)\n- [`deprecated-type`](#toc-deprecated-type)\n- [`deprecated-utility`](#toc-deprecated-utility)\n- [`implicit-inexact-object`](#toc-implicit-inexact-object)\n- [`nonstrict-import`](#toc-nonstrict-import)\n- [`sketchy-null`](#toc-sketchy-null)\n- [`sketchy-number`](#toc-sketchy-number)\n- [`unclear-type`](#toc-unclear-type)\n- [`unnecessary-invariant`](#toc-unnecessary-invariant)\n- [`unnecessary-optional-chain`](#toc-unnecessary-optional-chain)\n- [`unsafe-getters-setters`](#toc-unsafe-getters-setters)\n- [`untyped-import`](#toc-untyped-import)\n- [`untyped-type-import`](#toc-untyped-type-import)\n\n### `all`\n\nWhile `all` isn‚Äôt technically a lint rule, it‚Äôs worth mentioning here. `all` sets the default level for lint rules that don‚Äôt have a level set explicitly. `all` can only occur as the first entry in a `.flowconfig` or as the first rule in a `--lints` flag. It‚Äôs not allowed in comments at all because it would have different semantics than would be expected.\n\n### `ambiguous-object-type`\n\nLike [`implicit-inexact-object`](#toc-implicit-inexact-object), except triggers even when the `exact_by_default` option is set to `true`.\n\n### `deprecated-type`\n\nTriggers when you use the `*` (existential) type, as this type is unsafe and usually just equivalent to `any`. The effect of `*` can generally be achieved by simply not providing a type annotation.\n\n### `deprecated-utility`\n\nTriggers when you use the `$Supertype` or `$Subtype` utility types, as these types are unsafe and equivalent to `any`.\n\n### `implicit-inexact-object`\n\nTriggers when you use object type syntax without explicitly specifying exactness or inexactness.\n\nThis lint setting is ignored when `exact_by_default` is set to `true`.\n\n``` plaintext\ntype A = {x: number}; // Error\ntype B = {x: number, ...} // Ok\ntype C = {| x: number |} // Ok\n```\n\n### `nonstrict-import`\n\nUsed in conjuction with [Flow Strict](https://flow.org/en/strict/). Triggers when importing a non `@flow strict` module. When enabled, dependencies of a `@flow strict` module must also be `@flow strict`.\n\n### `sketchy-null`\n\nTriggers when you do an existence check on a value that can be either null/undefined or falsey.\n\nFor example:\n\n``` javascript\nconst x: ?number = 5;\nif (x) {} // sketchy because x could be either null or 0.\n\nconst y: number = 5;\nif (y) {} // not sketchy because y can't be null, only 0.\n\nconst z: ?{foo: number} = {foo: 5};\nif (z) {} // not sketchy, because z can't be falsey, only null/undefined.\n```\n\nSetting `sketchy-null` sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:\n\n- `sketchy-null-bool`\n- `sketchy-null-number`\n- `sketchy-null-string`\n- `sketchy-null-mixed`\n\nThe type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this `.flowconfig` `[lints]` section:\n\n``` plaintext\n[lints]\nsketchy-null=warn\nsketchy-null-bool=off\n```\n\nand now\n\n``` javascript\nfunction foo (bar: ?bool): void {\n  if (bar) {\n    ...\n  } else {\n    ...\n  }\n}\n```\n\ndoesn‚Äôt report a warning.\n\nSuppressing one type of sketchy null check only suppresses that type, so, for example\n\n``` javascript\n// flowlint sketchy-null:warn, sketchy-null-bool:off\nconst x: ?(number | bool) = 0;\nif (x) {}\n```\n\nwould still have a sketchy-null-number warning on line 3.\n\n### `sketchy-number`\n\nTriggers when a `number` is used in a manner which may lead to unexpected results if the value is falsy. Currently, this lint triggers if a `number` appears in:\n\n- the left-hand side of an `&&` expression.\n\nAs a motivating example, consider this common idiom in React:\n\n``` javascript\n{showFoo && <Foo />}\n```\n\nHere, `showFoo` is a boolean which controls whether or not to display the `<Foo />` element. If `showFoo` is true, then this evaluates to `{<Foo />}`. If `showFoo` is false, then this evaluates to `{false}`, which doesn‚Äôt display anything.\n\nNow suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:\n\n``` javascript\n{count && <>[{count} comments]</>}\n```\n\nIf `count` is, say, `5`, then this displays ‚Äú\\[5 comments\\]‚Äù. However, if `count` is `0`, then this displays ‚Äú0‚Äù instead of displaying nothing. (This problem is unique to `number` because `0` and `NaN` are the only falsy values which React renders with a visible result.) This could be subtly dangerous: if this immediately follows another numerical value, it might appear to the user that we have multiplied that value by 10! Instead, we should do a proper conditional check:\n\n``` javascript\n{count ? <>[{count} comments]</> : null}\n```\n\n### `unclear-type`\n\nTriggers when you use `any`, `Object`, or `Function` as type annotations. These types are unsafe.\n\n### `unnecessary-invariant`\n\nTriggers when you use `invariant` to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a `boolean`, then the lint will not fire even if the condition must be `true` at runtime.\n\nNote that this lint does not trigger when we know a condition is always `false`. It is a common idiom to use `invariant()` or `invariant(false, ...)` to throw in code that should be unreachable.\n\n### `unnecessary-optional-chain`\n\nTriggers when you use `?.` where it isn‚Äôt needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:\n\n``` javascript\ntype Foo = {\n  bar: number\n}\n\ndeclare var foo: Foo;\nfoo?.bar; // Lint: unnecessary-optional-chain\n```\n\nThe second is when the left-hand-side could be nullish, but the short-circuiting behavior of `?.` is sufficient to handle it anyway:\n\n``` javascript\ntype Foo = {\n  bar: {\n    baz: number\n  }\n}\n\ndeclare var foo: ?Foo;\nfoo?.bar?.baz; // Lint: unnecessary-optional-chain\n```\n\nIn the second example, the first use of `?.` is valid, since `foo` is potentially nullish, but the second use of `?.` is unnecessary. The left-hand-side of the second `?.` (`foo?.bar`) can only be nullish as a result of `foo` being nullish, and when `foo` is nullish, short-circuiting lets us avoid the second `?.` altogether!\n\n``` javascript\nfoo?.bar.baz;\n```\n\nThis makes it clear to the reader that `bar` is not a potentially nullish property.\n\n### `unsafe-getters-setters`\n\nTriggers when you use getters or setters. Getters and setters can have side effects and are unsafe.\n\nFor example:\n\n``` javascript\nconst o = {\n  get a() { return 4; }, // Error: unsafe-getters-setters\n  set b(x: number) { this.c = x; }, // Error: unsafe-getters-setters\n  c: 10,\n};\n```\n\n### `untyped-import`\n\nTriggers when you import from an untyped file. Importing from an untyped file results in those imports being typed as `any`, which is unsafe.\n\n### `untyped-type-import`\n\nTriggers when you import a type from an untyped file. Importing a type from an untyped file results in an `any` alias, which is typically not the intended behavior. Enabling this lint brings extra attention to this case and can help improve Flow coverage of typed files by limiting the spread of implicit `any` types.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/linting/rule-reference](https://flow.org/en/docs/linting/rule-reference)"
- name: Linting Overview
  id: linting
  summary: Flow contains a linting framework that can tell you about more than just type errors
  description: "# Linting Overview\n\nFlow contains a linting framework that can tell you about more than just type errors. This framework is highly configurable in order to show you the information you want and hide the information you don‚Äôt.\n\n## Configuring Lints in the `.flowconfig`\n\nLint settings can be specified in the `.flowconfig` \\[lints\\] section as a list of `rule=severity` pairs. These settings apply globally to the entire project.\n\n**Example:**\n\n``` plaintext\n[lints]\n# all=off by default\nall=warn\nuntyped-type-import=error\nsketchy-null-bool=off\n```\n\n## Configuring Lints from the CLI\n\nLint settings can be specified using the `--lints` flag of a Flow server command as a comma-delimited list of `rule=severity` pairs. These settings apply globally to the entire project.\n\n**Example:**\n\n``` plaintext\nflow start --lints \"all=warn, untyped-type-import=error, sketchy-null-bool=off\"\n```\n\n## Configuring Lints with Comments\n\nLint settings can be specified inside a file using `flowlint` comments. These settings apply to a region of a file, or a single line, or part of a line. For more details see [Flowlint Comments](flowlint-comments).\n\n**Example:**\n\n``` javascript\n /* flowlint\n  *   sketchy-null:error,\n  *   untyped-type-import:error\n  */\nconst x: ?number = 0;\n\nif (x) {} // Error\nimport type {Foo} from './untyped.js'; // Error\n\n// flowlint-next-line sketchy-null:off\nif (x) {} // No Error\n\nif (x) {} /* flowlint-line sketchy-null:off */ // No Error\n\n// flowlint sketchy-null:off\nif (x) {} // No Error\nif (x) {} // No Error\nimport type {Bar} from './untyped.js'; // Error; unlike a $FlowFixMe, a flowlint comment only suppresses one particular type of error.\n// flowlint sketchy-null:error\n```\n\n## Lint Settings Precedence\n\nLint settings in `flowlint` comments have the highest priority, followed by lint rules in the `--lints` flag, followed by the `.flowconfig`. This order allows you to use `flowlint` comments for fine-grained linting control, the `--lints` flag for trying out new lint settings, and the `.flowconfig` for stable project-wide settings.\n\nWithin the -lints flag and the flowconfig, rules lower down override rules higher up, allowing you to write things like\n\n``` plaintext\n[lints]\nsketchy-null=warn\nsketchy-null-bool=off\n```\n\nThe lint settings parser is fairly intelligent and will stop you if you write a redundant rule, a rule that gets completely overwritten, or an unused suppression. This should prevent most accidental misconfigurations of lint rules.\n\n## Severity Levels and Meanings\n\n**off:** The lint is ignored. Setting a lint to `off` is similar to suppressing a type error with a suppression comment, except with much more granularity.\n\n**warn:** Warnings are a new severity level introduced by the linting framework. They are treated differently than errors in a couple of ways:\n\n- Warnings don‚Äôt affect the exit code of Flow. If Flow finds warnings but no errors, it still returns 0.\n- Warnings aren‚Äôt shown on the CLI by default, to avoid spew. CLI warnings can be enabled by passing the ‚Äìinclude-warnings flag to the Flow server or the Flow client, or by setting ‚Äúinclude_warnings=true‚Äù in the `.flowconfig`. This is good for smaller projects that want to see all project warnings at once.\n- Warnings have special [IDE Integration](ide-integration).\n\n**error:** Lints with severity `error` are treated exactly the same as any other Flow error.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/linting](https://flow.org/en/docs/linting)"
- name: Literal Types
  id: types/literals
  summary: Flow has primitive types for literal values, but can also use literal values as types
  description: "# Literal Types\n\nFlow has [primitive types](../primitives) for literal values, but can also use literal values as types.\n\nFor example, instead of accepting `number` type, we could accept only the literal value `2`.\n\n``` javascript\n// @flow\nfunction acceptsTwo(value: 2) {\n  // ...\n}\n\nacceptsTwo(2);   // Works!\n// $ExpectError\nacceptsTwo(3);   // Error!\n// $ExpectError\nacceptsTwo(\"2\"); // Error!\n```\n\nYou can use primitive values for these types:\n\n- Booleans: like `true` or `false`\n- Numbers: like `42` or `3.14`\n- Strings: like `\"foo\"` or `\"bar\"`\n\nUsing these with [union types](../unions) is powerful:\n\n``` javascript\n// @flow\nfunction getColor(name: \"success\" | \"warning\" | \"danger\") {\n  switch (name) {\n    case \"success\" : return \"green\";\n    case \"warning\" : return \"yellow\";\n    case \"danger\"  : return \"red\";\n  }\n}\n\ngetColor(\"success\"); // Works!\ngetColor(\"danger\");  // Works!\n// $ExpectError\ngetColor(\"error\");   // Error!\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/literals](https://flow.org/en/docs/types/literals)"
- name: Maybe Types
  id: types/maybe
  summary: It‚Äôs common for JavaScript code to introduce ‚Äúoptional‚Äù values so that you have the option of leaving out the value or passing null instead
  description: "# Maybe Types\n\nIt‚Äôs common for JavaScript code to introduce ‚Äúoptional‚Äù values so that you have the option of leaving out the value or passing `null` instead.\n\nUsing Flow you can use Maybe types for these values. Maybe types work with any other type by simply prefixing it with a question mark `?` such as `?number` as a sort of modifier.\n\nMaybe types accept the provided type as well as `null` or `undefined`. So `?number` would mean `number`, `null`, or `undefined`.\n\n``` javascript\n// @flow\nfunction acceptsMaybeNumber(value: ?number) {\n  // ...\n}\n\nacceptsMaybeNumber(42);        // Works!\nacceptsMaybeNumber();          // Works!\nacceptsMaybeNumber(undefined); // Works!\nacceptsMaybeNumber(null);      // Works!\nacceptsMaybeNumber(\"42\");      // Error!\n```\n\nIn the case of objects, a **missing** property is not the same thing as an explicitly `undefined` property.\n\n``` javascript\n// @flow\nfunction acceptsMaybeProp({ value }: { value: ?number }) {\n  // ...\n}\n\nacceptsMaybeProp({ value: undefined }); // Works!\nacceptsMaybeProp({});                   // Error!\n```\n\nIf you want to allow missing properties, use [optional property](../objects#toc-optional-object-type-properties) syntax, where the `?` is placed *before* the colon. It is also possible to combine both syntaxes for an optional maybe type, for example `{ value?: ?number }`.\n\n## Refining Maybe types\n\nImagine we have the type `?number`, if we want to use that value as a `number` we‚Äôll need to first check that it is not `null` or `undefined`.\n\n``` javascript\n// @flow\nfunction acceptsMaybeNumber(value: ?number) {\n  if (value !== null && value !== undefined) {\n    return value * 2;\n  }\n}\n```\n\nYou can simplify the two checks against `null` and `undefined` using a single `!= null` check which will do both.\n\n``` javascript\n// @flow\nfunction acceptsMaybeNumber(value: ?number) {\n  if (value != null) {\n    return value * 2;\n  }\n}\n```\n\nYou could also flip it around, and check to make sure that the value has a type of `number` before using it.\n\n``` javascript\n// @flow\nfunction acceptsMaybeNumber(value: ?number) {\n  if (typeof value === 'number') {\n    return value * 2;\n  }\n}\n```\n\nHowever, type refinements can be lost. For instance, calling a function after refining the type of an object‚Äôs property will invalidate this refinement. Consult the [Refinement Invalidations](https://flow.org/en/lang/refinements/#toc-refinement-invalidations) docs for more details, to understand why Flow works this way, and how you can avoid this common pitfall.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/maybe](https://flow.org/en/docs/types/maybe)"
- name: Migrating from legacy patterns
  id: enums/migrating-legacy-patterns
  summary: Learn how to migrate to Flow Enums from legacy JavaScript enum patterns like Object.freeze
  description: "# Migrating from legacy patterns\n\nLearn how to migrate to Flow Enums from legacy JavaScript enum patterns like `Object.freeze`.\n\nFirst, learn how to [update the enum definition site](#toc-updating-definitions), and next learn how to [update files that import and use the enum](#toc-updating-usage).\n\n## Updating definitions\n\n### Object.freeze\n\nIf you are using `Object.freeze`, you can migrate to an enum if the values of the object are:\n\n- All the same primitive type, and that type is `boolean`, `string`, `number`, or `symbol`.\n- All literals.\n- Contain no duplicate values.\n\nReplace\n\n``` javascript\nconst Status = Object.freeze({\n  Active: 1,\n  Paused: 2,\n  Off: 3,\n});\n\nexport type StatusType = $Values<typeof Status>;\n\nexport default Status;\n```\n\nwith\n\n``` javascript\nexport default enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\n```\n\n- Check to ensure that the key names do not start with lowercase ‚Äòa‚Äô-‚Äòz‚Äô (disallowed in enums). If they do, you‚Äôll need to rename the member names.\n- Remove any usage of `$Keys<...>` or `$Values<...>` on the enum type, these are no longer needed as a Flow Enum defines a type itself (its name).\n- Delete any type exports based on the enum, as you just need to export the Flow Enum. A Flow Enum acts as both a type and a value (like a class).\n\nThen, take a look at [how to update files that import and use the enum](#toc-updating-usage).\n\n### keyMirror\n\nThe `keyMirror` utility creates an object whose values are mirrors of its key names. You can replace `keyMirror` usage with a string based enum.\n\nReplace\n\n``` javascript\nimport keyMirror from 'keyMirror';\n\nconst Status = keyMirror({\n  Active: null,\n  Paused: null,\n  Off: null,\n});\n\nexport type StatusType = $Keys<typeof Status>;\n\nexport default Status;\n```\n\nwith\n\n``` javascript\nexport default enum Status {\n  Active,\n  Paused,\n  Off,\n}\n```\n\n- Check to ensure that the key names do not start with lowercase ‚Äòa‚Äô-‚Äòz‚Äô (disallowed in enums). If they do, you‚Äôll need to rename the member names.\n- Remove any usage of `$Keys<...>` on the enum type, it‚Äôs no longer needed as a Flow Enum defines a type itself (its name).\n- Delete any type exports based on the enum, you just need to export the Flow Enum. A Flow Enum acts as both a type and a value (like a class).\n\nThen, take a look at [how to update files that import and use the enum](#toc-updating-usage).\n\n## Updating usage\n\n### Fix type imports\n\nPrevious patterns required you to export (and then import) a type separate from the enum itself. Flow Enums are both types and values (like a class), so you just need to export the Flow Enum itself. Since there is now one export, you only need one import. Read more about [exporting enums](../using-enums#toc-exporting-enums) and [importing enums](../using-enums#toc-importing-enums).\n\nIf you previously had:\n\n``` javascript\nconst Status = Object.freeze({\n  Active: 1,\n  Paused: 2,\n  Off: 3,\n});\nexport type StatusType = $Values<typeof Status>;\nexport default Status;\n```\n\nAnd you‚Äôve replaced it with:\n\n``` javascript\nexport default enum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\n```\n\nThen you need to fix the imports as well:\n\n#### If both type and value were imported\n\nFor a user of the enum, if you previously imported both the type and the value, you can delete the type import and update annotations used.\n\nChange\n\n``` javascript\nimport type {StatusType} from 'status';\n\nimport Status from 'status';\n\nconst myStatus: StatusType = Status.Active;\n```\n\nto\n\n``` javascript\n// Type import is deleted\n\nimport Status from 'status';\n\nconst myStatus: Status = Status.Active; // Changed type annotation to just `Status`\n```\n\n#### If only the type was imported\n\nFor a user of the enum, if you previously imported just the type, change the type import to a default import rather than a named import.\n\nChange\n\n``` javascript\nimport type {StatusType} from 'status';\n\nfunction isActive(status: StatusType) { ... }\n```\n\nto\n\n``` javascript\n// Remove the braces `{` `}` and changed the name - this is a default import now\nimport type Status from 'status';\n\nfunction isActive(status: Status) { ... } // Changed type annotation to just `Status`\n```\n\n### Mapping enums to other values\n\nSometimes you want to map from an enum value to some other value. Previously, we sometimes used object literals for this. With Flow Enums, use a function with a `switch` instead. The switch is [exhaustively checked](../using-enums#toc-exhaustively-checking-enums-with-a-switch), so Flow will ensure you update your mapping when you add or remove Flow Enum members.\n\nReplace this pattern\n\n``` javascript\nconst STATUS_ICON: {[Status]: string} = {\n  [Status.Active]: 'green-checkmark',\n  [Status.Paused]: 'grey-pause',\n  [Status.Off]: 'red-x',\n};\nconst icon = STATUS_ICON[status];\n```\n\nwith\n\n``` javascript\nfunction statusIcon(status: Status): string {\n  switch (status) {\n    case Status.Active:\n      return 'green-checkmark';\n    case Status.Paused:\n      return 'grey-pause';\n    case Status.Off:\n      return 'red-x';\n  }\n}\nconst icon = statusIcon(status);\n```\n\nRead more about [mapping enums to other values](../using-enums#toc-mapping-enums-to-other-values).\n\n### Usage as the representation type (e.g. a string)\n\nYou can‚Äôt use a Flow Enum directly as its representation type (e.g. a `string`). If you get Flow errors about using an enum as its representation type, first try to refactor your code so that it expects the enum type instead of the representation type (e.g. change annotations from `string` to `Status`). If you really want to use the enum as its representation type, you can add in explicit casts. See [casting to represetation type](../using-enums#toc-casting-to-representation-type).\n\n### Casting to the enum type\n\nIf before you cast from an enum‚Äôs representation type (e.g. `string`) to the enum type with something like this:\n\n``` javascript\nfunction castToStatus(input: number): StatusType | void {\n  switch(input) {\n    case 1: return Status.Active;\n    case 2: return Status.Paused;\n    case 3: return Status.Off;\n    default: return undefined;\n  }\n}\n\ncastToStatus(x);\n```\n\nYou can now just use the [cast](../using-enums#toc-cast) method:\n\n``` javascript\nStatus.cast(x);\n```\n\n### Update switch statements\n\nFlow Enums are exhaustively checked in `switch` statements. You might need to update your code when you are switching over an enum value. Read more at [exhaustively checking enums in switch statements](../using-enums#toc-exhaustively-checking-enums-with-a-switch).\n\n### Operations over enum members\n\nIf previously you used functionality like `Object.values`, `Object.keys`, or `for-in` loops to get and operate on the enum members, you can use the [members method](../using-enums#toc-members) instead.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/enums/migrating-legacy-patterns](https://flow.org/en/docs/enums/migrating-legacy-patterns)"
- name: Mixed Types
  id: types/mixed
  summary: Here the input value can only be a number
  description: "# Mixed Types\n\nIn general, programs have several different categories of types:\n\n**A single type:**\n\nHere the input value can only be a `number`.\n\n``` javascript\nfunction square(n: number) {\n  return n * n;\n}\n```\n\n**A group of different possible types:**\n\nHere the input value could be either a `string` or a `number`.\n\n``` javascript\nfunction stringifyBasicValue(value: string | number) {\n  return '' + value;\n}\n```\n\n**A type based on another type:**\n\nHere the return type will be the same as the type of whatever value is passed into the function.\n\n``` javascript\nfunction identity<T>(value: T): T {\n  return value;\n}\n```\n\nThese three are the most common categories of types. They will make up the majority of the types you‚Äôll be writing.\n\nHowever, there is also a fourth category.\n\n**An arbitrary type that could be anything:**\n\nHere the passed in value is an unknown type, it could be any type and the function would still work.\n\n``` javascript\nfunction getTypeOf(value: mixed): string {\n  return typeof value;\n}\n```\n\nThese unknown types are less common, but are still useful at times.\n\nYou should represent these values with `mixed`.\n\n## Anything goes in, Nothing comes out\n\n`mixed` will accept any type of value. Strings, numbers, objects, functions‚Äì anything will work.\n\n``` javascript\n// @flow\nfunction stringify(value: mixed) {\n  // ...\n}\n\nstringify(\"foo\");\nstringify(3.14);\nstringify(null);\nstringify({});\n```\n\nWhen you try to use a value of a `mixed` type you must first figure out what the actual type is or you‚Äôll end up with an error.\n\n``` javascript\n// @flow\nfunction stringify(value: mixed) {\n  // $ExpectError\n  return \"\" + value; // Error!\n}\n\nstringify(\"foo\");\n```\n\nInstead you must ensure the value is a certain type by refining it.\n\n``` javascript\n// @flow\nfunction stringify(value: mixed) {\n  if (typeof value === 'string') {\n    return \"\" + value; // Works!\n  } else {\n    return \"\";\n  }\n}\n\nstringify(\"foo\");\n```\n\nBecause of the `typeof value === 'string'` check, Flow knows the `value` can only be a `string` inside of the `if` statement. This is known as a [refinement](https://flow.org/en/lang/refinements/).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/mixed](https://flow.org/en/docs/types/mixed)"
- name: Module Types
  id: types/modules
  summary: It is often useful to share types in between modules (files)
  description: "# Module Types\n\n## Importing and exporting types\n\nIt is often useful to share types in between modules (files). In Flow, you can export type aliases, interfaces, and classes from one file and import them in another.\n\n**`exports.js`**\n\n``` javascript\n// @flow\nexport default class Foo {};\nexport type MyObject = { /* ... */ };\nexport interface MyInterface { /* ... */ };\n```\n\n**`imports.js`**\n\n``` javascript\n// @flow\nimport type Foo, {MyObject, MyInterface} from './exports';\n```\n\n> ***Don‚Äôt forget to mention `@flow` on top of file, otherwise flow won‚Äôt report errors***.\n\n## Importing and exporting values\n\nFlow also supports importing the type of values exported by other modules using [`typeof`](../typeof).\n\n**`exports.js`**\n\n``` javascript\n// @flow\nconst myNumber = 42;\nexport default myNumber;\nexport class MyClass {\n  // ...\n}\n```\n\n**`imports.js`**\n\n``` javascript\n// @flow\nimport typeof myNumber from './exports';\nimport typeof {MyClass} from './exports';\n```\n\nJust like other type imports, this code will be stripped away by a compiler and will not add a dependency on the other module.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/modules](https://flow.org/en/docs/types/modules)"
- name: Nominal & Structural Typing
  id: lang/nominal-structural
  summary: An important attribute of every type system is whether they are structural or nominal, they can even be mixed within a single type system
  description: "# Nominal & Structural Typing\n\nAn important attribute of every type system is whether they are structural or nominal, they can even be mixed within a single type system. So it‚Äôs important to know the difference.\n\nA type is something like a string, a boolean, an object, or a class. They have names and they have structures. Primitives like strings or booleans have a very simple structure and only go by one name.\n\nMore complex types like object or classes have more complex structures. They each get their own name even if they sometimes have the same structure overall.\n\nA static type checker uses either the names or the structure of the types in order to compare them against other types. Checking against the name is nominal typing and checking against the structure is structural typing.\n\n### Nominal typing\n\nLanguages like C++, Java, and Swift have primarily nominal type systems.\n\n``` javascript\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Error!\n```\n\nHere you can see a pseudo-example of a nominal type system erroring out when you‚Äôre trying to put a `Bar` where a `Foo` is required because they have different names.\n\n### Structural typing\n\nLanguages like OCaml, Haskell, and Elm have primarily structural type systems.\n\n``` javascript\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Works!\n```\n\nHere you can see a pseudo-example of a structural type system passing when you‚Äôre trying to put a Bar where a `Foo` is required because their structure is exactly the same.\n\nBut as soon as you change the shape it will start to cause errors.\n\n``` javascript\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: number) { /* ... */ } }\n\nlet foo: Foo = new Bar(); // Error!\n```\n\nIt can get a little bit more complicated than this.\n\nWe‚Äôve demonstrated both nominal and structure typing of classes, but there are also other complex types like objects and functions which can also be either nominal or structural. Even further, they can be different within the same type system (most of the languages listed before has features of both).\n\nFor example, Flow uses structural typing for objects and functions, but nominal typing for classes.\n\n#### Functions are structurally typed\n\nWhen comparing a function type with a function it must have the same structure in order to be considered valid.\n\n``` javascript\n// @flow\ntype FuncType = (input: string) => void;\nfunction func(input: string) { /* ... */ }\nlet test: FuncType = func; // Works!\n```\n\n#### Objects are structurally typed\n\nWhen comparing an object type with an object it must have the same structure in order to be considered valid.\n\n``` javascript\ntype ObjType = { property: string };\nlet obj = { property: \"value\" };\nlet test: ObjType = obj;\n```\n\n#### Classes are nominally typed\n\nWhen you have two classes with the same structure, they still are not considered equivalent because Flow uses nominal typing for classes.\n\n``` javascript\n// @flow\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\nlet test: Foo = new Bar(); // Error!\n```\n\nIf you wanted to use a class structurally you could do that using an interface:\n\n``` javascript\ninterface Interface {\n  method(value: string): void;\n};\n\nclass Foo { method(input: string) { /* ... */ } }\nclass Bar { method(input: string) { /* ... */ } }\n\nlet test1: Interface = new Foo(); // Okay.\nlet test2: Interface = new Bar(); // Okay.\n```\n\n### Mixing nominal and structural typing\n\nThe design decision in Flow around mixing nominal and structural typing was chosen based on how objects, functions, and classes are already used in JavaScript.\n\nThe JavaScript language is a bunch of object-oriented ideas and functional ideas mixed together. Developer‚Äôs usage of JavaScript tends to be mixed as well. Classes (or constructor functions) being the more object-oriented side and functions (as lambdas) and objects tend to be more on the functional side, developers use both simultaneously.\n\nWhen someone writes a class, they are declaring a *thing*. This thing might have the same structure as something else but they still serve different purposes. Imagine two component classes that both have `render()` methods, these components could still have totally different purposes, but in a structural type system they‚Äôd be considered exactly the same.\n\nFlow chooses what is natural for JavaScript, and should behave the way you expect it to.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/nominal-structural](https://flow.org/en/docs/lang/nominal-structural)"
- name: Object Types
  id: types/objects
  summary: Objects can be used in many different ways in JavaScript
  description: "# Object Types\n\nObjects can be used in many different ways in JavaScript. There are a number of different ways to type them in order to support all the different use cases.\n\nIn Flow, there are two different kinds of object types: exact object types and inexact object types.\n\nIn general, we recommend using [exact object types](#toc-exact-object-types) whenever possible. Exact object types are more precise and interact better with other type system features, like spreads.\n\n## Object type syntax\n\nObject types try to match the syntax for objects in JavaScript as much as possible. Using curly braces `{}` and name-value pairs using a colon `:` split by commas `,`.\n\n``` javascript\n// @flow\nvar obj1: { foo: boolean } = { foo: true };\nvar obj2: {\n  foo: number,\n  bar: boolean,\n  baz: string,\n} = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n```\n\n> **Note:** Previously object types used semicolons `;` for splitting name-value pairs. While the syntax is still valid, you should use commas `,`.\n\n#### Optional object type properties\n\nIn JavaScript, accessing a property that doesn‚Äôt exist evaluates to `undefined`. This is a common source of errors in JavaScript programs, so Flow turns these into type errors.\n\n``` javascript\n// @flow\nvar obj = { foo: \"bar\" };\n// $ExpectError\nobj.bar; // Error!\n```\n\nIf you have an object that sometimes does not have a property you can make it an *optional property* by adding a question mark `?` after the property name in the object type.\n\n``` javascript\n// @flow\nvar obj: { foo?: boolean } = {};\n\nobj.foo = true;    // Works!\n// $ExpectError\nobj.foo = 'hello'; // Error!\n```\n\nIn addition to their set value type, these optional properties can either be `void` or omitted altogether. However, they cannot be `null`.\n\n``` javascript\n// @flow\nfunction acceptsObject(value: { foo?: string }) {\n  // ...\n}\n\nacceptsObject({ foo: \"bar\" });     // Works!\nacceptsObject({ foo: undefined }); // Works!\n// $ExpectError\nacceptsObject({ foo: null });      // Error!\nacceptsObject({});                 // Works!\n```\n\n### Object methods\n\nMethod syntax in objects has the same runtime behavior as a function property. These two objects are equivalent at runtime:\n\n``` javascript\n// @flow\nlet a = {\n  foo : function () { return 3; }\n};\nlet b = {\n  foo() { return 3; }\n}\n```\n\nHowever, despite their equivalent runtime behavior, Flow checks them slightly differently. In particular, object properties written with method syntax are read-only; Flow will not allow you to write a new value to them.\n\n``` javascript\n// @flow\nlet b = {\n  foo() { return 3; }\n}\nb.foo = () => { return 2; } // Error!\n```\n\nAdditionally, object methods do not allow the use of `this` in their bodies, in order to guarantee simple behavior for their `this` parameters. Prefer to reference the object by name instead of using `this`.\n\n``` javascript\n// @flow\nlet a = {\n  x : 3,\n  foo() { return this.x; } // error!\n}\nlet b = {\n  x : 3,\n  foo() { return b.x; } // works!\n}\n```\n\n## Object type inference\n\nFlow can infer the type of object literals in two different ways depending on how they are used.\n\n### Sealed objects\n\nWhen you create an object with its properties, you create a *sealed* object type in Flow. These sealed objects will know all of the properties you declared them with and the types of their values.\n\n``` javascript\n// @flow\nvar obj = {\n  foo: 1,\n  bar: true,\n  baz: 'three'\n};\n\nvar foo: number  = obj.foo; // Works!\nvar bar: boolean = obj.bar; // Works!\n// $ExpectError\nvar baz: null    = obj.baz; // Error!\nvar bat: string  = obj.bat; // Error!\n```\n\nBut when objects are sealed, Flow will not allow you to add new properties to them.\n\n``` javascript\n// @flow\nvar obj = {\n  foo: 1\n};\n\n// $ExpectError\nobj.bar = true;    // Error!\n// $ExpectError\nobj.baz = 'three'; // Error!\n```\n\nThe workaround here might be to turn your object into an *unsealed object*.\n\n### Unsealed objects\n\nWhen you create an object without any properties, you create an *unsealed* object type in Flow. These unsealed objects will not know all of their properties and will allow you to add new ones.\n\n``` javascript\n// @flow\nvar obj = {};\n\nobj.foo = 1;       // Works!\nobj.bar = true;    // Works!\nobj.baz = 'three'; // Works!\n```\n\nThe inferred type of the property becomes what you set it to.\n\n``` javascript\n// @flow\nvar obj = {};\nobj.foo = 42;\nvar num: number = obj.foo;\n```\n\n##### Reassigning unsealed object properties\n\nSimilar to [`var` and `let` variables](../variables#toc-reassigning-variables) if you reassign a property of an unsealed object, by default Flow will give it the type of all possible assignments.\n\n``` javascript\n// @flow\nvar obj = {};\n\nif (Math.random()) obj.prop = true;\nelse obj.prop = \"hello\";\n\n// $ExpectError\nvar val1: boolean = obj.prop; // Error!\n// $ExpectError\nvar val2: string  = obj.prop; // Error!\nvar val3: boolean | string = obj.prop; // Works!\n```\n\nSometimes Flow is able to figure out (with certainty) the type of a property after reassignment. In that case, Flow will give it the known type.\n\n``` javascript\n// @flow\nvar obj = {};\n\nobj.prop = true;\nobj.prop = \"hello\";\n\n// $ExpectError\nvar val1: boolean = obj.prop; // Error!\nvar val2: string  = obj.prop; // Works!\n```\n\nAs Flow gets smarter and smarter, it will figure out the types of properties in more scenarios.\n\n##### Unknown property lookup on unsealed objects is unsafe\n\nUnsealed objects allow new properties to be written at any time. Flow ensures that reads are compatible with writes, but does not ensure that writes happen before reads (in the order of execution).\n\nThis means that reads from unsealed objects with no matching writes are never checked. This is an unsafe behavior of Flow which may be improved in the future.\n\n``` javascript\nvar obj = {};\n\nobj.foo = 1;\nobj.bar = true;\n\nvar foo: number  = obj.foo; // Works!\nvar bar: boolean = obj.bar; // Works!\nvar baz: string  = obj.baz; // Works?\n```\n\n## Exact object types\n\nIn Flow, it is considered safe to pass an object with extra properties where a normal object type is expected.\n\n``` javascript\n// @flow\nfunction method(obj: { foo: string }) {\n  // ...\n}\n\nmethod({\n  foo: \"test\", // Works!\n  bar: 42      // Works!\n});\n```\n\n> **Note:** This is because of [‚Äúwidth subtyping‚Äù](https://flow.org/en/lang/width-subtyping/).\n\nSometimes it is useful to disable this behavior and only allow a specific set of properties. For this, Flow supports ‚Äúexact‚Äù object types.\n\n``` javascript\n{| foo: string, bar: number |}\n```\n\nUnlike regular object types, it is not valid to pass an object with ‚Äúextra‚Äù properties to an exact object type.\n\n``` javascript\n// @flow\nvar foo: {| foo: string |} = { foo: \"Hello\", bar: \"World!\" }; // Error!\n```\n\nIntersections of exact object types may not work as you expect. If you need to combine exact object types, use object type spread:\n\n``` javascript\n// @flow\n\ntype FooT = {| foo: string |};\ntype BarT = {| bar: number |};\n\ntype FooBarFailT = FooT & BarT;\ntype FooBarT = {| ...FooT, ...BarT |};\n\nconst fooBarFail: FooBarFailT = { foo: '123', bar: 12 }; // Error!\nconst fooBar: FooBarT = { foo: '123', bar: 12 }; // Works!\n```\n\n## Explicit inexact object types\n\nIn addition to the default `{}` syntax, you can explicitly indicate an inexact object by using an ellipsis at the end of your property list:\n\n``` javascript\n// @flow\n\ntype Inexact = {foo: number, ...};\n```\n\n[Flow is planning to make object types exact by default](https://medium.com/flow-type/on-the-roadmap-exact-objects-by-default-16b72933c5cf). This is available via an [option in your flowconfig](https://flow.org/en/config/options/#toc-exact-by-default-boolean). You can also read our [upgrade guide](https://medium.com/flow-type/how-to-upgrade-to-exact-by-default-object-type-syntax-7aa44b4d08ab) for steps to enable this option in your own project.\n\nIn a project using exact-by-default syntax, the explicit inexact object type syntax is the only way to express an inexact object type.\n\n## Objects as maps\n\nNewer versions of the JavaScript standard include a `Map` class, but it is still very common to use objects as maps as well. In this use case, an object will likely have properties added to it and retrieved throughout its lifecycle. Furthermore, the property keys may not even be known statically, so writing out a type annotation would not be possible.\n\nFor objects like these, Flow provides a special kind of property, called an ‚Äúindexer property.‚Äù An indexer property allows reads and writes using any key that matches the indexer key type.\n\n``` javascript\n// @flow\nvar o: { [string]: number } = {};\no[\"foo\"] = 0;\no[\"bar\"] = 1;\nvar foo: number = o[\"foo\"];\n```\n\nAn indexer can be optionally named, for documentation purposes:\n\n``` javascript\n// @flow\nvar obj: { [user_id: number]: string } = {};\nobj[1] = \"Julia\";\nobj[2] = \"Camille\";\nobj[3] = \"Justin\";\nobj[4] = \"Mark\";\n```\n\nWhen an object type has an indexer property, property accesses are assumed to have the annotated type, even if the object does not have a value in that slot at runtime. It is the programmer‚Äôs responsibility to ensure the access is safe, as with arrays.\n\n``` javascript\nvar obj: { [number]: string } = {};\nobj[42].length; // No type error, but will throw at runtime\n```\n\nIndexer properties can be mixed with named properties:\n\n``` javascript\n// @flow\nvar obj: {\n  size: number,\n  [id: number]: string\n} = {\n  size: 0\n};\n\nfunction add(id: number, name: string) {\n  obj[id] = name;\n  obj.size++;\n}\n```\n\n### `Object` Type\n\n> NOTE: For new code, prefer `any` or `{ [key: string]: any}`. `Object` is an alias to [`any`](../any) and will be deprecated and removed in a future version of Flow.\n\nSometimes it is useful to write types that accept arbitrary objects, for those you should write `{}` like this:\n\n``` javascript\nfunction method(obj: {}) {\n  // ...\n}\n```\n\nHowever, if you need to opt-out of the type checker, and don‚Äôt want to go all the way to `any`, you could use `{ [key: string]: any}`. (Note that [`any`](../any) is unsafe and should be avoided). For historical reasons, the `Object` keyword is still available. In previous versions of Flow, `Object` was the same as `{ [key: string]: any}`.\n\nFor example, the following code will not report any errors:\n\n``` javascript\nfunction method(obj: { [key: string]: any }) {\n  obj.foo = 42;               // Works.\n  let bar: boolean = obj.bar; // Works.\n  obj.baz.bat.bam.bop;        // Works.\n}\n\nmethod({ baz: 3.14, bar: \"hello\" });\n```\n\nNeither will this:\n\n``` javascript\nfunction method(obj: Object) {\n  obj = 10;\n}\n\nmethod({ baz: 3.14, bar: \"hello\" });\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/objects](https://flow.org/en/docs/types/objects)"
- name: Opaque Type Aliases
  id: types/opaque-types
  summary: Opaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined
  description: "# Opaque Type Aliases\n\nOpaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined.\n\n``` javascript\nopaque type ID = string;\n```\n\nOpaque type aliases, like regular type aliases, may be used anywhere a type can be used.\n\n``` javascript\n// @flow\nopaque type ID = string;\n\nfunction identity(x: ID): ID {\n  return x;\n}\nexport type {ID};\n```\n\n## Opaque Type Alias Syntax\n\nOpaque type aliases are created using the words `opaque type` followed by its name, an equals sign `=`, and a type definition.\n\n``` javascript\nopaque type Alias = Type;\n```\n\nYou can optionally add a subtyping constraint to an opaque type alias by adding a colon `:` and a type after the name.\n\n``` javascript\nopaque type Alias: SuperType = Type;\n```\n\nAny type can appear as the super type or type of an opaque type alias.\n\n``` javascript\nopaque type StringAlias = string;\nopaque type ObjectAlias = {\n  property: string,\n  method(): number,\n};\nopaque type UnionAlias = 1 | 2 | 3;\nopaque type AliasAlias: ObjectAlias = ObjectAlias;\nopaque type VeryOpaque: AliasAlias = ObjectAlias;\n```\n\n## Opaque Type Alias Type Checking\n\n### Within the Defining File\n\nWhen in the same file the alias is defined, opaque type aliases behave exactly as regular [type aliases](../aliases) do.\n\n``` javascript\n//@flow\nopaque type NumberAlias = number;\n\n(0: NumberAlias);\n\nfunction add(x: NumberAlias, y: NumberAlias): NumberAlias {\n    return x + y;\n}\nfunction toNumberAlias(x: number): NumberAlias { return x; }\nfunction toNumber(x: NumberAlias): number { return x; }\n```\n\n### Outside the Defining File\n\nWhen importing an opaque type alias, it behaves like a [nominal type](https://flow.org/en/lang/nominal-structural/#toc-nominal-typing), hiding its underlying type.\n\n**`exports.js`**\n\n``` javascript\nexport opaque type NumberAlias = number;\n```\n\n**`imports.js`**\n\n``` javascript\nimport type {NumberAlias} from './exports';\n\n(0: NumberAlias) // Error: 0 is not a NumberAlias!\n\nfunction convert(x: NumberAlias): number {\n  return x; // Error: x is not a number!\n}\n```\n\n### Subtyping Constraints\n\nWhen you add a subtyping constraint to an opaque type alias, we allow the opaque type to be used as the super type when outside of the defining file.\n\n**`exports.js`**\n\n``` javascript\nexport opaque type ID: string = string;\n```\n\n**`imports.js`**\n\n``` javascript\nimport type {ID} from './exports';\n\nfunction formatID(x: ID): string {\n    return \"ID: \" + x; // Ok! IDs are strings.\n}\n\nfunction toID(x: string): ID {\n    return x; // Error: strings are not IDs.\n}\n```\n\nWhen you create an opaque type alias with a subtyping constraint, the type in the type position must be a subtype of the type in the super type position.\n\n``` javascript\n//@flow\nopaque type Bad: string = number; // Error: number is not a subtype of string\nopaque type Good: {x: string} = {x: string, y: number};\n```\n\n### Generics\n\nOpaque type aliases can also have their own [generics](../generics), and they work exactly as generics do in regular [type aliases](../aliases#toc-type-alias-generics)\n\n``` javascript\n// @flow\nopaque type MyObject<A, B, C>: { foo: A, bar: B } = {\n  foo: A,\n  bar: B,\n  baz: C,\n};\n\nvar val: MyObject<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n```\n\n### Library Definitions\n\nYou can also declare opaque type aliases in [libdefs](../libdefs). There, you omit the underlying type, but may still optionally include a super type.\n\n``` javascript\ndeclare opaque type Foo;\ndeclare opaque type PositiveNumber: number;\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/opaque-types](https://flow.org/en/docs/types/opaque-types)"
- name: Primitive Types
  id: types/primitives
  summary: The primitive types appear in the language as either literal values
  description: "# Primitive Types\n\nJavaScript has a number of different primitive types ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)):\n\n- Booleans\n- Strings\n- Numbers\n- `null`\n- `undefined` (`void` in Flow types)\n- Symbols (new in ECMAScript 2015)\n\nThe primitive types appear in the language as either literal values.\n\n``` javascript\ntrue;\n\"hello\";\n3.14;\nnull;\nundefined;\n```\n\nOr as constructed wrapper objects.\n\n``` javascript\nnew Boolean(false);\nnew String(\"world\");\nnew Number(42);\n```\n\nTypes for literal values are lowercase.\n\n``` javascript\n// @flow\nfunction method(x: number, y: string, z: boolean) {\n  // ...\n}\n\nmethod(3.14, \"hello\", true);\n```\n\nTypes for the wrapper objects are capitalized (the same as their constructor).\n\n``` javascript\n// @flow\nfunction method(x: Number, y: String, z: Boolean) {\n  // ...\n}\n\nmethod(new Number(42), new String(\"world\"), new Boolean(false));\n```\n\nThese wrapper objects are rarely used.\n\n## Booleans\n\nBooleans are `true` and `false` values in JavaScript. The `boolean` type in Flow accepts these values.\n\n``` javascript\n// @flow\nfunction acceptsBoolean(value: boolean) {\n  // ...\n}\n\nacceptsBoolean(true);  // Works!\nacceptsBoolean(false); // Works!\nacceptsBoolean(\"foo\"); // Error!\n```\n\nJavaScript can also implicitly convert other types of values into booleans.\n\n``` javascript\nif (42) {} // 42 => true\nif (\"\") {} // \"\" => false\n```\n\nFlow understands these conversions and will allow any of them as part of an `if` statement and other types of expressions.\n\nBoolean types need you to be explicit by converting non-booleans. You can do that with `Boolean(x)` or `!!x`.\n\n``` javascript\n// @flow\nfunction acceptsBoolean(value: boolean) {\n  // ...\n}\n\nacceptsBoolean(0);          // Error!\nacceptsBoolean(Boolean(0)); // Works!\nacceptsBoolean(!!0);        // Works!\n```\n\nRemember that `boolean` and `Boolean` are different types.\n\n- A `boolean` is a literal value like `true` or `false` or the result of an expression like `a === b`.\n- A `Boolean` is a wrapper object created by the global `new Boolean(x)` constructor.\n\n## Numbers\n\nUnlike many other languages, JavaScript only has one type of number. These values may appear as `42` or `3.14`. JavaScript also considers `Infinity` and `NaN` to be numbers. The `number` type captures everything JavaScript considers a number.\n\n``` javascript\n// @flow\nfunction acceptsNumber(value: number) {\n  // ...\n}\n\nacceptsNumber(42);       // Works!\nacceptsNumber(3.14);     // Works!\nacceptsNumber(NaN);      // Works!\nacceptsNumber(Infinity); // Works!\nacceptsNumber(\"foo\");    // Error!\n```\n\nRemember that `number` and `Number` are different types.\n\n- A `number` is a literal value like `42` or `3.14` or the result of an expression like `parseFloat(x)`.\n- A `Number` is a wrapper object created by the global `new Number(x)` constructor.\n\n## Strings\n\nStrings are `\"foo\"` values in JavaScript. The `string` type in Flow accepts these values.\n\n``` javascript\n// @flow\nfunction acceptsString(value: string) {\n  // ...\n}\n\nacceptsString(\"foo\"); // Works!\nacceptsString(false); // Error!\n```\n\nJavaScript implicitly converts other types of values into strings by concatenating them.\n\n``` javascript\n\"foo\" + 42; // \"foo42\"\n\"foo\" + {}; // \"foo[object Object]\"\n```\n\nFlow will only accept strings and number when concatenating them to strings.\n\n``` javascript\n// @flow\n\"foo\" + \"foo\"; // Works!\n\"foo\" + 42;    // Works!\n\"foo\" + {};    // Error!\n\"foo\" + [];    // Error!\n```\n\nYou must be explicit and convert other types into strings. You can do this by using the String method or using another method for stringifying values.\n\n``` javascript\n// @flow\n\"foo\" + String({});     // Works!\n\"foo\" + [].toString();  // Works!\n\"\" + JSON.stringify({}) // Works!\n```\n\nRemember that `string` and `String` are different types.\n\n- A `string` is a literal value like `\"foo\"` or the result of an expression like `\"\" + 42`.\n- A `String` is a wrapper object created by the global `new String(x)` constructor.\n\n## `null` and `void`\n\nJavaScript has both `null` and `undefined`. Flow treats these as separate types: `null` and `void` (for `undefined`).\n\n``` javascript\n// @flow\nfunction acceptsNull(value: null) {\n  /* ... */\n}\n\nfunction acceptsUndefined(value: void) {\n  /* ... */\n}\n\nacceptsNull(null);      // Works!\nacceptsNull(undefined); // Error!\nacceptsUndefined(null);      // Error!\nacceptsUndefined(undefined); // Works!\n```\n\n`null` and `void` also appear in other types.\n\n### Maybe types\n\nMaybe types are for places where a value is optional and you can create them by adding a question mark in front of the type such as `?string` or `?number`.\n\nIn addition to the `type` in `?type`, maybe types can also be `null` or `void`.\n\n``` javascript\n// @flow\nfunction acceptsMaybeString(value: ?string) {\n  // ...\n}\n\nacceptsMaybeString(\"bar\");     // Works!\nacceptsMaybeString(undefined); // Works!\nacceptsMaybeString(null);      // Works!\nacceptsMaybeString();          // Works!\n```\n\n### Optional object properties\n\nObject types can have optional properties where a question mark `?` comes after the property name.\n\n``` javascript\n{ propertyName?: string }\n```\n\nIn addition to their set value type, these optional properties can either be `void` or omitted altogether. However, they cannot be `null`.\n\n``` javascript\n// @flow\nfunction acceptsObject(value: { foo?: string }) {\n  // ...\n}\n\nacceptsObject({ foo: \"bar\" });     // Works!\nacceptsObject({ foo: undefined }); // Works!\nacceptsObject({ foo: null });      // Error!\nacceptsObject({});                 // Works!\n```\n\n### Optional function parameters\n\nFunctions can have optional parameters where a question mark `?` comes after the parameter name.\n\n``` javascript\nfunction method(param?: string) { /* ... */ }\n```\n\nIn addition to their set type, these optional parameters can either be `void` or omitted altogether. However, they cannot be `null`.\n\n``` javascript\n// @flow\nfunction acceptsOptionalString(value?: string) {\n  // ...\n}\n\nacceptsOptionalString(\"bar\");     // Works!\nacceptsOptionalString(undefined); // Works!\nacceptsOptionalString(null);      // Error!\nacceptsOptionalString();          // Works!\n```\n\n### Function parameters with defaults\n\nFunction parameters can also have defaults. This is a feature of ECMAScript 2015.\n\n``` javascript\nfunction method(value: string = \"default\") { /* ... */ }\n```\n\nIn addition to their set type, default parameters can also be `void` or omitted altogether. However, they cannot be `null`.\n\n``` javascript\n// @flow\nfunction acceptsOptionalString(value: string = \"foo\") {\n  // ...\n}\n\nacceptsOptionalString(\"bar\");     // Works!\nacceptsOptionalString(undefined); // Works!\nacceptsOptionalString(null);      // Error!\nacceptsOptionalString();          // Works!\n```\n\n## Symbols\n\nSymbols are created with `Symbol()` in JavaScript. Flow has basic support for symbols, using the `symbol` type.\n\n``` javascript\n// @flow\nfunction acceptsSymbol(value: symbol) {\n  // ...\n}\n\nacceptsSymbol(Symbol()); // Works!\nacceptsSymbol(Symbol.isConcatSpreadable); // Works!\nacceptsSymbol(false); // Error!\n```\n\nYou can use `typeof x === \"symbol\"` to refine to a symbol.\n\n``` plaintext\nconst x: symbol | number = Symbol();\nif (typeof x === \"symbol\") {\n  const y: symbol = x;\n} else {\n  const z: number = x;\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/primitives](https://flow.org/en/docs/types/primitives)"
- name: Redux
  id: react/redux
  summary: Typing your state object, works the same as typing any other object in Flow
  description: "# Redux\n\n[Redux](http://redux.js.org) has three major parts that should be typed:\n\n- State\n- Actions\n- Reducers\n\n## Typing Redux state\n\nTyping your [state](http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth) object, works the same as typing any other object in Flow.\n\n``` javascript\ntype State = {\n  users: Array<{\n    id: string,\n    name: string,\n    age: number,\n    phoneNumber: string,\n  }>,\n  activeUserID: string,\n  // ...\n};\n```\n\nWe can use this type alias to make sure reducers work correctly.\n\n### Typing Redux state immutability\n\nRedux state [is meant to be immutable](http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only): creating a new state object instead of changing properties on a single object.\n\nYou can enforce this in Flow by making every property effectively ‚Äúread-only‚Äù using ‚Äúcovariant‚Äù properties throughout your state object.\n\n``` javascript\ntype State = {\n  +users: Array<{\n    +id: string,\n    +name: string,\n    +age: number,\n    +phoneNumber: string,\n  }>,\n  +activeUserID: string,\n  // ...\n};\n```\n\nNow Flow will complain when you try to write to any of these properties.\n\n``` javascript\n// @flow\ntype State = {\n  +foo: string\n};\n\nlet state: State = {\n  foo: \"foo\"\n};\n\nstate.foo = \"bar\"; // Error!\n```\n\n## Typing Redux actions\n\nThe base type for Redux [actions](http://redux.js.org/docs/basics/Actions.html) is an object with a `type` property.\n\n``` javascript\ntype Action = {\n  +type: string,\n};\n```\n\nBut you‚Äôll want to use more specific types for your actions using disjoint unions and each individual type of action.\n\n``` javascript\ntype Action =\n  | { type: \"FOO\", foo: number }\n  | { type: \"BAR\", bar: boolean }\n  | { type: \"BAZ\", baz: string };\n```\n\nUsing disjoint unions, Flow will be able to understand your reducers much better.\n\n### Typing Redux action creators\n\nIn order to type your Redux [action creators](http://redux.js.org/docs/basics/Actions.html#action-creators), you‚Äôll want to split up your `Action` disjoint union into separate action types.\n\n``` javascript\ntype FooAction = { type: \"FOO\", foo: number };\ntype BarAction = { type: \"BAR\", bar: boolean };\n\ntype Action =\n  | FooAction\n  | BarAction;\n```\n\nThen to type the action creator, just add a return type of the appropriate action.\n\n``` javascript\n// @flow\ntype FooAction = { type: \"FOO\", foo: number };\ntype BarAction = { type: \"BAR\", bar: boolean };\n\ntype Action =\n  | FooAction\n  | BarAction;\n\nfunction foo(value: number): FooAction {\n  return { type: \"FOO\", foo: value };\n}\n\nfunction bar(value: boolean): BarAction {\n  return { type: \"BAR\", bar: value };\n}\n```\n\n### Typing Redux thunk actions\n\nIn order to type your Redux [thunk actions](http://redux.js.org/docs/advanced/AsyncActions.html#async-action-creators), you‚Äôll add types for `ThunkAction` as a function `Dispatch`, and `GetState`. `GetState` is a function that returns an `Object`. `Dispatch` accepts a disjoint union of `Action`, `ThunkAction`, `PromiseAction` and `Array<Action>` and can return `any`.\n\n``` javascript\ntype Dispatch = (action: Action | ThunkAction | PromiseAction) => any;\ntype GetState = () => State;\ntype ThunkAction = (dispatch: Dispatch, getState: GetState) => any;\ntype PromiseAction = Promise<Action>;\n```\n\nThen to type a thunk action creator, add a return type of a `ThunkAction` to your action creator.\n\n``` javascript\ntype Action =\n  | { type: \"FOO\", foo: number }\n  | { type: \"BAR\", bar: boolean };\n\ntype GetState = () => State;\ntype PromiseAction = Promise<Action>;\ntype ThunkAction = (dispatch: Dispatch, getState: GetState) => any;\ntype Dispatch = (action: Action | ThunkAction | PromiseAction | Array<Action>) => any;\n\n\nfunction foo(): ThunkAction {\n  return (dispatch, getState) => {\n    const baz = getState().baz\n    dispatch({ type: \"BAR\", bar: true })\n    doSomethingAsync(baz)\n      .then(value => {\n        dispatch({ type: \"FOO\", foo: value })\n      })\n    }\n}\n```\n\n## Typing Redux reducers\n\n[Reducers](http://redux.js.org/docs/basics/Reducers.html) take the state and actions that we‚Äôve typed and pulls them together for one method.\n\n``` javascript\nfunction reducer(state: State, action: Action): State {\n  // ...\n}\n```\n\nYou can also validate that you have handled every single type of action by using the `empty` type in your `default` case.\n\n``` javascript\n// @flow\ntype State = { +value: boolean };\n\ntype FooAction = { type: \"FOO\", foo: boolean };\ntype BarAction = { type: \"BAR\", bar: boolean };\n\ntype Action = FooAction | BarAction;\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"FOO\": return { ...state, value: action.foo };\n    case \"BAR\": return { ...state, value: action.bar };\n    default:\n      (action: empty);\n      return state;\n  }\n}\n```\n\n## Flow + Redux resources\n\n- [Using Redux with Flow](http://frantic.im/using-redux-with-flow) - Alex Kotliarskyi\n- [Redux and Flowtype](https://medium.com/@cdebotton/redux-and-flowtype-69ff1dd09036#.fsrm1amlk) - Christian de Botton\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/redux](https://flow.org/en/docs/react/redux)"
- name: ref functions
  id: react/refs
  summary: React allows you to grab the instance of an element or component with ref functions
  description: "# ref functions\n\nReact allows you to grab the instance of an element or component with [`ref` functions](https://facebook.github.io/react/docs/refs-and-the-dom.html). To use a ref function add a [maybe instance type](https://flow.org/en/types/maybe/) to your class and assign your instance to that property in your ref function.\n\n``` javascript\nimport * as React from 'react';\n\nclass MyComponent extends React.Component<{}> {\n  // The `?` here is important because you may not always have the instance.\n  button: ?HTMLButtonElement;\n\n  render() {\n    return <button ref={button => (this.button = button)}>Toggle</button>;\n  }\n}\n```\n\nThe `?` in `?HTMLButtonElement` is important. In the example above the first argument to `ref` will be `HTMLButtonElement | null` as React will [call your `ref` callback with null](https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element) when the component unmounts. Also, the `button` property on `MyComponent` will not be set until React has finished rendering. Until then your `button` ref will be undefined. Protect yourself against these cases and use a `?` (like in `?HTMLButtonElement`) to protect yourself from bugs.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/refs](https://flow.org/en/docs/react/refs)"
- name: Sublime Text
  id: editors/sublime-text
  summary: You may also wish to install a popular SublimeLinter plugin for Flow like SublimeLinter-flow
  description: "# Sublime Text\n\n## Flow For Sublime Text 2 and 3\n\n[Sublime Text](https://www.sublimetext.com/) can be integrated with Flow by using [Package Control](https://packagecontrol.io)\n\n- Install the Package Control plugin if you don‚Äôt have it\n- Press Ctrl+Shift+P to bring up the Command Palette (or use Tools \\> Command Palette menu)\n- Select Package Control: Install Package\n- Type ‚ÄòFlow‚Äô to find ‚ÄòFlow for Sublime Text 2 and 3‚Äô\n- Select ‚ÄòFlow for Sublime Text 2 and 3‚Äô to install\n\n## SublimeLinter-flow\n\nYou may also wish to install a popular SublimeLinter plugin for Flow like [SublimeLinter-flow](https://packagecontrol.io/packages/SublimeLinter-flow).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors/sublime-text](https://flow.org/en/docs/editors/sublime-text)"
- name: Subsets & Subtypes
  id: lang/subtypes
  summary: A type like number, boolean, or string describes a set of possible values
  description: "# Subsets & Subtypes\n\n## What is a subtype?\n\nA type like `number`, `boolean`, or `string` describes a set of possible values. A `number` describes every possible number, so a single number (such as `42`) would be a *subtype* of the `number` type. Conversely, `number` would be a *supertype* of the type `42`.\n\nIf we want to know whether one type is the subtype of another, we need to look at all the possible values for both types and figure out if the other has a *subset* of the values.\n\nFor example, if we had a `TypeA` which described the numbers 1 through 3, and a `TypeB` which described the numbers 1 through 5: `TypeA` would be considered a *subtype* of `TypeB`, because `TypeA` is a subset of `TypeB`.\n\n``` javascript\ntype TypeA = 1 | 2 | 3;\ntype TypeB = 1 | 2 | 3 | 4 | 5;\n```\n\nConsider a `TypeLetters` which described the strings: ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù, and a `TypeNumbers` which described the numbers: 1, 2, 3. Neither of them would be a subtype of the other, as they each contain a completely different set of values.\n\n``` javascript\ntype TypeLetters = \"A\" | \"B\" | \"C\";\ntype TypeNumbers =  1  |  2  |  3;\n```\n\nFinally, if we had a `TypeA` which described the numbers 1 through 3, and a `TypeB` which described the numbers 3 through 5. Neither of them would be a subtype of the other. Even though they both have 3 and describe numbers, they each have some unique items.\n\n``` javascript\ntype TypeA = 1 | 2 | 3;\ntype TypeB = 3 | 4 | 5;\n```\n\n## When are subtypes used?\n\nMost of the work that Flow does is comparing types against one another.\n\nFor example, in order to know if you are calling a function correctly, Flow needs to compare the arguments you are passing with the parameters the function expects.\n\nThis often means figuring out if the value you are passing in is a subtype of the value you are expecting.\n\nSo if I write a function that expects the numbers 1 through 5, any subtype of that set will be acceptable.\n\n``` javascript\n// @flow\nfunction f(param: 1 | 2 | 3 | 4 | 5) {\n  // ...\n}\n\ndeclare var oneOrTwo: 1 |  2; // Subset of the input parameters type.\ndeclare var fiveOrSix: 5 | 6; // Not a subset of the input parameters type.\n\nf(oneOrTwo); // Works!\n// $ExpectError\nf(fiveOrSix); // Error!\n```\n\n## Subtypes of complex types\n\nFlow needs to compare more than just sets of primitive values, it also needs to be able to compare objects, functions, and every other type that appears in the language.\n\n### Subtypes of objects\n\nYou can start to compare two objects by their keys. If one object contains all the keys of another object, then it may be a subtype.\n\nFor example, if we had an `ObjectA` which contained the key `foo`, and an `ObjectB` which contained the keys `foo` and `bar`. Then it‚Äôs possible that `ObjectB` is a subtype of `ObjectA`.\n\n``` javascript\n// @flow\ntype ObjectA = { foo: string };\ntype ObjectB = { foo: string, bar: number };\n\nlet objectB: ObjectB = { foo: 'test', bar: 42 };\nlet objectA: ObjectA = objectB; // Works!\n```\n\nBut we also need to compare the types of the values. If both objects had a key `foo` but one was a `number` and the other was a `string`, then one would not be the subtype of the other.\n\n``` javascript\n// @flow\ntype ObjectA = { foo: string };\ntype ObjectB = { foo: number, bar: number };\n\nlet objectB: ObjectB = { foo: 1, bar: 2 };\n// $ExpectError\nlet objectA: ObjectA = objectB; // Error!\n```\n\nIf these values on the object happen to be other objects, we would have to compare those against one another. We need to compare every value recursively until we can decide if we have a subtype or not.\n\n### Subtypes of functions\n\nSubtyping rules for functions are more complicated. So far, we‚Äôve seen that `A` is a subtype of `B` if `B` contains all possible values for `A`. For functions, it‚Äôs not clear how this relationship would apply. To simplify things, you can think of a function type `A` as being a subtype of a function type `B` if functions of type `A` can be used wherever a function of type `B` is expected.\n\nLet‚Äôs say we have a function type and a few functions. Which of the functions can be used safely in code that expects the given function type?\n\n``` javascript\ntype FuncType = (1 | 2) => \"A\" | \"B\";\n\nlet f1: (1 | 2) => \"A\" | \"B\" | \"C\" = (x) => /* ... */\nlet f2: (1 | null) => \"A\" | \"B\" = (x) => /* ... */\nlet f3: (1 | 2 | 3) => \"A\" = (x) => /* ... */\n```\n\n- `f1` can return a value that `FuncType` never does, so code that relies on `FuncType` might not be safe if `f1` is used. Its type is not a subtype of `FuncType`.\n- `f2` can‚Äôt handle all the argument values that `FuncType` does, so code that relies on `FuncType` can‚Äôt safely use `f2`. Its type is also not a subtype of `FuncType`.\n- `f3` can accept all the argument values that `FuncType` does, and only returns values that `FuncType` does, so its type is a subtype of `FuncType`.\n\nIn general, the function subtyping rule is this: A function type `B` is a subtype of a function type `A` if and only if `B`‚Äôs inputs are a superset of `A`‚Äôs, and `B`‚Äôs outputs are a subset of `A`‚Äôs. The subtype must accept *at least* the same inputs as its parent, and must return *at most* the same outputs.\n\nThe decision of which direction to apply the subtyping rule on inputs and outputs is governed by variance, which is the topic of the next section.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/subtypes](https://flow.org/en/docs/lang/subtypes)"
- name: Tools
  id: tools
  summary: ¬© 2013‚Äìpresent Facebook Inc
  description: "# Tools\n\n[](tools/babel)\n\n### Babel\n\nLearn how to use Flow with Babel\n\n[](tools/eslint)\n\n### ESLint\n\nLearn how to use Flow with ESLint\n\n[](tools/flow-remove-types)\n\n### flow-remove-types\n\nLearn how to use Flow with flow-remove-types\n\n[](tools/create-react-app)\n\n### Create React App\n\nLearn how to use Flow with Create React App\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/tools](https://flow.org/en/docs/tools)"
- name: Tuple Types
  id: types/tuples
  summary: Tuples are a sort of list but with a limited set of items
  description: "# Tuple Types\n\nTuples are a sort of list but with a limited set of items. In JavaScript, tuples are created using arrays.\n\nIn Flow you can create tuples using the `[type, type, type]` syntax.\n\n``` javascript\nlet tuple1: [number] = [1];\nlet tuple2: [number, boolean] = [1, true];\nlet tuple3: [number, boolean, string] = [1, true, \"three\"];\n```\n\nWhen you are getting a value from a tuple at a specific index, it will return the type at that index.\n\n``` javascript\n// @flow\nlet tuple: [number, boolean, string] = [1, true, \"three\"];\n\nlet num  : number  = tuple[0]; // Works!\nlet bool : boolean = tuple[1]; // Works!\nlet str  : string  = tuple[2]; // Works!\n```\n\nTrying to access an index that does not exist results in an index-out-of-bounds error.\n\n``` javascript\n// @flow\nlet tuple: [number, boolean, string] = [1, true, \"three\"];\n\nlet none = tuple[3]; // Error!\n```\n\nIf Flow doesn‚Äôt know which index you are trying to access it will return all possible types.\n\n``` javascript\n// @flow\nlet tuple: [number, boolean, string] = [1, true, \"three\"];\n\nfunction getItem(n: number) {\n  let val: number | boolean | string = tuple[n];\n  // ...\n}\n```\n\nWhen setting a new value inside a tuple, the new value must match the type at that index.\n\n``` javascript\n// @flow\nlet tuple: [number, boolean, string] = [1, true, \"three\"];\n\ntuple[0] = 2;     // Works!\ntuple[1] = false; // Works!\ntuple[2] = \"foo\"; // Works!\n\n// $ExpectError\ntuple[0] = \"bar\"; // Error!\n// $ExpectError\ntuple[1] = 42;    // Error!\n// $ExpectError\ntuple[2] = false; // Error!\n```\n\n## Strictly enforced tuple length (arity)\n\nThe length of the tuple is known as the ‚Äúarity‚Äù. The length of a tuple is strictly enforced in Flow.\n\n#### Tuples only match tuples with same length\n\nThis means that a shorter tuple can‚Äôt be used in place of a longer one.\n\n``` javascript\n// @flow\nlet tuple1: [number, boolean]       = [1, true];\n// $ExpectError\nlet tuple2: [number, boolean, void] = tuple1; // Error!\n```\n\nAlso, a longer tuple can‚Äôt be used in place of a shorter one.\n\n``` javascript\n// @flow\nlet tuple1: [number, boolean, void] = [1, true];\n// $ExpectError\nlet tuple2: [number, boolean]       = tuple1; // Error!\n```\n\n#### Tuples don‚Äôt match array types\n\nSince Flow does not know the length of an array, an `Array<T>` type cannot be passed into a tuple.\n\n``` javascript\n// @flow\nlet array: Array<number>    = [1, 2];\n// $ExpectError\nlet tuple: [number, number] = array; // Error!\n```\n\nAlso a tuple type cannot be passed into to an `Array<T>` type, since then you could mutate the tuple in an unsafe way.\n\n``` javascript\n// @flow\nlet tuple: [number, number] = [1, 2];\n// $ExpectError\nlet array: Array<number>    = tuple; // Error!\n```\n\n#### Cannot use mutating array methods on tuples\n\nYou cannot use `Array.prototype` methods that mutate the tuple, only ones that do not.\n\n``` javascript\n// @flow\nlet tuple: [number, number] = [1, 2];\ntuple.join(', '); // Works!\n// $ExpectError\ntuple.push(3);    // Error!\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/tuples](https://flow.org/en/docs/types/tuples)"
- name: Type Aliases
  id: types/aliases
  summary: When you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a type alias
  description: "# Type Aliases\n\nWhen you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a **type alias**.\n\n``` javascript\n// @flow\ntype MyObject = {\n  foo: number,\n  bar: boolean,\n  baz: string,\n};\n```\n\nThese type aliases can be used anywhere a type can be used.\n\n``` javascript\n// @flow\ntype MyObject = {\n  // ...\n};\n\nvar val: MyObject = { /* ... */ };\nfunction method(val: MyObject) { /* ... */ }\nclass Foo { constructor(val: MyObject) { /* ... */ } }\n```\n\n## Type Alias Syntax\n\nType aliases are created using the keyword `type` followed by its name, an equals sign `=`, and a type definition.\n\n``` javascript\ntype Alias = Type;\n```\n\nAny type can appear inside a type alias.\n\n``` javascript\ntype NumberAlias = number;\ntype ObjectAlias = {\n  property: string,\n  method(): number,\n};\ntype UnionAlias = 1 | 2 | 3;\ntype AliasAlias = ObjectAlias;\n```\n\n### Type Alias Generics\n\nType aliases can also have their own [generics](../generics).\n\n``` javascript\ntype MyObject<A, B, C> = {\n  property: A,\n  method(val: B): C,\n};\n```\n\nType alias generics are [parameterized](../generics#toc-parameterized-generics). When you use a type alias you need to pass parameters for each of its generics.\n\n``` javascript\n// @flow\ntype MyObject<A, B, C> = {\n  foo: A,\n  bar: B,\n  baz: C,\n};\n\nvar val: MyObject<number, boolean, string> = {\n  foo: 1,\n  bar: true,\n  baz: 'three',\n};\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/aliases](https://flow.org/en/docs/types/aliases)"
- name: Type Annotations
  id: types
  summary: Adding type annotations is an important part of your interaction with Flow
  description: "# Type Annotations\n\nAdding type annotations is an important part of your interaction with Flow.\n\nFlow has a powerful ability to infer the types of your programs. The majority of your code can rely on it. Still, there are places where you‚Äôll want to add types.\n\nImagine the following `concat` function for concatenating two strings together.\n\n``` javascript\nfunction concat(a, b) {\n  return a + b;\n}\n```\n\nWhen you use this function, Flow knows exactly what is going on.\n\n``` javascript\nconcat(\"A\", \"B\"); // Works!\n```\n\nHowever, you can use the `+` operator on strings or numbers, so this would also be valid.\n\n``` javascript\nconcat(1, 2); // Works!\n```\n\nBut suppose you only want to allow strings in your function. For that you can add types.\n\n``` javascript\nfunction concat(a: string, b: string) {\n  return a + b;\n}\n```\n\nNow you‚Äôll get a warning from Flow if you try to use numbers.\n\n``` javascript\n// @flow\nfunction concat(a: string, b: string) {\n  return a + b;\n}\n\nconcat(\"A\", \"B\"); // Works!\nconcat(1, 2); // Error!\n```\n\nSetting up ‚Äúboundaries‚Äù with your types means you can tell Flow your intent on top of the inference it already does.\n\nThis guide will teach you the syntax and semantics of all the different types you can have in Flow.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types](https://flow.org/en/docs/types)"
- name: Type Casting Expressions
  id: types/casting
  summary: Sometimes it is useful to assert a type without using something like a function or a variable to do so
  description: "# Type Casting Expressions\n\nSometimes it is useful to assert a type without using something like a function or a variable to do so. For this Flow supports an inline type cast expression syntax which can be used in a number of different ways.\n\n## Type Cast Expression Syntax\n\nIn order to create a type cast expression around a `value`, add a colon `:` with the `Type` and wrap the expression with parentheses `(` `)`.\n\n``` javascript\n(value: Type)\n```\n\n> **Note:** The parentheses are necessary to avoid ambiguity with other syntax.\n\nType cast expressions can appear anywhere an expression can appear.\n\n``` javascript\nlet val = (value: Type);\nlet obj = { prop: (value: Type) };\nlet arr = ([(value: Type), (value: Type)]: Array<Type>);\n```\n\nThe value itself can also be an expression:\n\n``` javascript\n(2 + 2: number);\n```\n\nWhen you strip the types all that is left is the value.\n\n``` javascript\n(value: Type);\n```\n\n``` javascript\nvalue;\n```\n\n## Type Assertions\n\nUsing type cast expressions you can assert that values are certain types.\n\n``` javascript\n// @flow\nlet value = 42;\n\n(value: 42);     // Works!\n(value: number); // Works!\n(value: string); // Error!\n```\n\nAsserting types in this way works the same as types do anywhere else.\n\n## Type Casting\n\nWhen you write a type cast expression, the result of that expression is the value with the provided type. If you hold onto the resulting value, it will have the new type.\n\n``` javascript\n// @flow\nlet value = 42;\n\n(value: 42);     // Works!\n(value: number); // Works!\n\nlet newValue = (value: number);\n\n// $ExpectError\n(newValue: 42);     // Error!\n(newValue: number); // Works!\n```\n\n## Using type cast expressions\n\n> **Note:** We‚Äôre going to go through a stripped down example for demonstrating how to make use of type cast expressions. This example is not solved well in practice.\n\n### Type Casting through any\n\nBecause type casts work the same as all other type annotations, you can only cast values to less specific types. You cannot change the type or make it something more specific.\n\nBut you can use any to cast to whatever type you want.\n\n``` javascript\nlet value = 42;\n\n(value: number); // Works!\n// $ExpectError\n(value: string); // Error!\n\nlet newValue = ((value: any): string);\n\n// $ExpectError\n(newValue: number); // Error!\n(newValue: string); // Works!\n```\n\nBy casting the value to any, you can then cast to whatever you want.\n\nThis is unsafe and not recommended. But it‚Äôs sometimes useful when you are doing something with a value which is very difficult or impossible to type and want to make sure that the result has the desired type.\n\nFor example, the following function for cloning an object.\n\n``` javascript\nfunction cloneObject(obj) {\n  const clone = {};\n\n  Object.keys(obj).forEach(key => {\n    clone[key] = obj[key];\n  });\n\n  return clone;\n}\n```\n\nIt would be hard to create a type for this because we‚Äôre creating a new object based on another object.\n\nIf we cast through any, we can return a type which is more useful.\n\n``` javascript\n// @flow\nfunction cloneObject(obj) {\n  const clone = {};\n\n  Object.keys(obj).forEach(key => {\n    clone[key] = obj[key];\n  });\n\n  return ((clone: any): typeof obj); // <<\n}\n\nconst clone = cloneObject({\n  foo: 1,\n  bar: true,\n  baz: 'three'\n});\n\n(clone.foo: 1);       // Works!\n(clone.bar: true);    // Works!\n(clone.baz: 'three'); // Works!\n```\n\n### Type checking through type assertions\n\nIf we want to validate what kinds of types are coming into our `cloneObject` method from before, we could write the following annotation:\n\n``` javascript\nfunction cloneObject(obj: { [key: string]: mixed }) {\n  // ...\n}\n```\n\nBut now we have a problem. Our `typeof obj` annotation also gets this new annotation which defeats the entire purpose.\n\n``` javascript\n// @flow\nfunction cloneObject(obj: { [key: string]: mixed }) {\n  const clone = {};\n  // ...\n  return ((clone: any): typeof obj);\n}\n\nconst clone = cloneObject({\n  foo: 1,\n  bar: true,\n  baz: 'three'\n});\n\n// $ExpectError\n(clone.foo: 1);       // Error!\n// $ExpectError\n(clone.bar: true);    // Error!\n// $ExpectError\n(clone.baz: 'three'); // Error!\n```\n\nInstead we can assert the type within the function using a type assertion and now we‚Äôre validating our inputs.\n\n``` javascript\n// @flow\nfunction cloneObject(obj) {\n  (obj: { [key: string]: mixed });\n  // ...\n}\n\ncloneObject({ foo: 1 }); // Works!\n// $ExpectError\ncloneObject([1, 2, 3]);  // Error!\n```\n\nNow type inference can keep working for `typeof obj` which returns the expected shape of the object.\n\n``` javascript\n// @flow\nfunction cloneObject(obj) {\n  (obj: { [key: string]: mixed }); // <<\n\n  const clone = {};\n  // ...\n  return ((clone: any): typeof obj);\n}\n\nconst clone = cloneObject({\n  foo: 1,\n  bar: true,\n  baz: 'three'\n});\n\n(clone.foo: 1);       // Works!\n(clone.bar: true);    // Works!\n(clone.baz: 'three'); // Works!\n```\n\n> **Note:** This is not the proper solution to the above problem, it was being used for demonstration only. The correct solution is annotating the function like this:\n\n``` javascript\nfunction cloneObject<T: { [key: string]: mixed }>(obj: T): $Shape<T> {\n // ...\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/casting](https://flow.org/en/docs/types/casting)"
- name: Type Reference
  id: react/types
  summary: React exports a handful of utility types that may be useful to you when typing advanced React patterns
  description: "# Type Reference\n\nReact exports a handful of utility types that may be useful to you when typing advanced React patterns. In previous sections we have seen a few of them. The following is a complete reference for each of these types along with some examples for how/where to use them.\n\nTable of contents:\n\n- [`React.Node`](#toc-react-node)\n- [`React.Element<typeof Component>`](#toc-react-element)\n- [`React.ChildrenArray<T>`](#toc-react-childrenarray)\n- [`React.AbstractComponent<Config, Instance>`](#toc-react-abstractcomponent)\n- [`React.ComponentType<Props>`](#toc-react-componenttype)\n- [`React.StatelessFunctionalComponent<Props>`](#toc-react-statelessfunctionalcomponent)\n- [`React.ElementType`](#toc-react-elementtype)\n- [`React.Key`](#toc-react-key)\n- [`React.Ref<typeof Component>`](#toc-react-ref)\n- [`React.ElementProps<typeof Component>`](#toc-react-elementprops)\n- [`React.ElementConfig<typeof Component>`](#toc-react-elementconfig)\n- [`React.ElementRef<typeof Component>`](#toc-react-elementref)\n- [`React.Config<Props, DefaultProps>`](#toc-react-config)\n\nThese types are all exported as named type exports from the `react` module. If you want to access them as members on the `React` object (e.g. [`React.Node`](#toc-react-node) or [`React.StatelessFunctionalComponent`](#toc-react-statelessfunctionalcomponent)) and you are importing React as an ES module then you should import `React` as a namespace:\n\n``` javascript\nimport * as React from 'react';\n```\n\nIf you are using CommonJS you can also require React:\n\n``` javascript\nconst React = require('react');\n```\n\nYou can also use named type imports in either an ES module environment or a CommonJS environment:\n\n``` javascript\nimport type {Node} from 'react';\n```\n\nWe will refer to all the types in the following reference as if we imported them with:\n\n``` javascript\nimport * as React from 'react';\n```\n\n> **Note:** While importing React with a default import works:\n>\n> ``` plaintext\n> import React from 'react';\n> ```\n>\n> You will have access to all of the values that React exports, but you will **not** have access to the types documented below! This is because Flow will not add types to a default export since the default export could be any value (like a number). Flow will add exported named types to an ES namespace object which you can get with `import * as React from 'react'` since Flow knows if you export a value with the same name as an exported type.\n>\n> Again, if you import React with: `import React from 'react'` you will be able to access `React.Component`, `React.createElement()`, `React.Children`, and other JavaScript *values*. However, you will not be able to access [`React.Node`](#toc-react-node), [`React.ChildrenArray`](#toc-react-childrenarray) or other Flow *types*. You will need to use a named type import like: `import type {Node} from 'react'` in addition to your default import.\n\n## `React.Node`\n\nThis represents any node that can be rendered in a React application. `React.Node` can be null, a boolean, a number, a string, a React element, or an array of any of those types recursively.\n\nIf you need a return type for your component `render()` methods then you should use `React.Node`. However, if you need a generic type for a children prop, use `?React.Node`; children can be undefined, when `render()` can‚Äôt return `undefined`.\n\nHere is an example of `React.Node` being used as the return type to `render()`:\n\n``` javascript\nclass MyComponent extends React.Component<{}> {\n  render(): React.Node {\n    // ...\n  }\n}\n```\n\nIt may also be used as the return type of a stateless functional component:\n\n``` javascript\nfunction MyComponent(props: {}): React.Node {\n  // ...\n}\n```\n\nYou don‚Äôt need to annotate the return type of either your `render()` method or a stateless functional component. However, if you want to annotate the return type then `React.Node` is the generic to use.\n\nHere is an example of `React.Node` as the prop type for children:\n\n``` javascript\nfunction MyComponent({ children }: { children: React.Node }) {\n  return <div>{children}</div>;\n}\n```\n\nAll `react-dom` JSX intrinsics have `React.Node` as their children type. `<div>`, `<span>`, and all the rest.\n\nThe definition of `React.Node` can be roughly approximated with a [`React.ChildrenArray<T>`](#toc-react-childrenarray):\n\n``` javascript\ntype Node = React.ChildrenArray<void | null | boolean | string | number | React.Element<any>>;\n```\n\n## `React.Element<typeof Component>`\n\nA React element is the type for the value of a JSX element:\n\n``` javascript\nconst element: React.Element<'div'> = <div />;\n```\n\n`React.Element<typeof Component>` is also the return type of `React.createElement()`.\n\nA `React.Element<typeof Component>` takes a single type argument, `typeof Component`. `typeof Component` is the component type of the React element. For an intrinsic element, `typeof Component` will be the string literal for the intrinsic you used. Here are a few examples with DOM intrinsics:\n\n``` javascript\n(<div />: React.Element<'div'>); // OK\n(<span />: React.Element<'span'>); // OK\n(<div />: React.Element<'span'>); // Error: div is not a span.\n```\n\n`typeof Component` can also be your React class component or stateless functional component.\n\n``` javascript\nclass Foo extends React.Component<{}> {}\nfunction Bar(props: {}) {}\n\n(<Foo />: React.Element<typeof Foo>); // OK\n(<Bar />: React.Element<typeof Bar>); // OK\n(<Foo />: React.Element<typeof Bar>); // Error: Foo is not Bar\n```\n\nTake note of the `typeof`, it is required! `Foo` without `typeof` would be the type of an instance of `Foo`. So: `(new Foo(): Foo)`. We want the type *of* `Foo` not the type of an instance of `Foo`. So: `(Foo: typeof Foo)`. `Class<Foo>` would also work here, but we prefer `typeof` for consistency with stateless functional components.\n\nWe also need `typeof` for `Bar` because `Bar` is a value. So we want to get the type *of* the value `Bar`. `(Bar: Bar)` is an error because `Bar` cannot be used as a type, so the following is correct: `(Bar: typeof Bar)`.\n\n## `React.ChildrenArray<T>`\n\nA React children array can be a single value or an array nested to any level. It is designed to be used with the [`React.Children` API](https://reactjs.org/docs/react-api.html#reactchildren).\n\nFor example if you want to get a normal JavaScript array from a `React.ChildrenArray<T>` see the following example:\n\n``` javascript\nimport * as React from 'react';\n\n// A children array can be a single value...\nconst children: React.ChildrenArray<number> = 42;\n// ...or an arbitrarily nested array.\nconst children: React.ChildrenArray<number> = [[1, 2], 3, [4, 5]];\n\n// Using the `React.Children` API can flatten the array.\nconst array: Array<number> = React.Children.toArray(children);\n```\n\n## `React.AbstractComponent<Config, Instance>`\n\n`React.AbstractComponent<Config, Instance>` (v0.89.0+) represents a component with a config of type Config and instance of type Instance.\n\nInstance is optional and is mixed by default.\n\nA class or function component with config `Config` may be used in places that expect `React.AbstractComponent<Config>`.\n\nThis is Flow‚Äôs most abstract representation of a React component, and is most useful for writing HOCs and library definitions.\n\n## `React.ComponentType<Props>`\n\nThis is a union of a class component or a stateless functional component. This is the type you want to use for functions that receive or return React components such as higher-order components or other utilities.\n\nHere is how you may use `React.ComponentType<Props>` with [`React.Element<typeof Component>`](#toc-react-element) to construct a component with a specific set of props:\n\n``` javascript\ntype Props = {\n  foo: number,\n  bar: number,\n};\n\nfunction createMyElement<C: React.ComponentType<Props>>(\n  Component: C,\n): React.Element<C> {\n  return <Component foo={1} bar={2} />;\n}\n```\n\n`React.ComponentType<Props>` does not include intrinsic JSX element types like `div` or `span`. See [`React.ElementType`](#toc-react-elementtype) if you also want to include JSX intrinsics.\n\nThe definition for `React.ComponentType<Props>` is roughly:\n\n``` javascript\ntype ComponentType<Props> =\n  | React.StatelessFunctionalComponent<Props>\n  | Class<React.Component<Props, any>>;\n```\n\n> **Note:** In 0.89.0+, React.ComponentType is an alias for React.AbstractComponent\\<Config, any\\>, which represents a component with config type Config and any instance type.\n\n## `React.StatelessFunctionalComponent<Props>`\n\nThis is the type of a React stateless functional component.\n\nThe definition for `React.StatelessFunctionalComponent<Props>` is roughly:\n\n``` javascript\ntype StatelessFunctionalComponent<Props> =\n  (props: Props) => React.Node;\n```\n\nThere is a little bit more to the definition of `React.StatelessFunctionalComponent<Props>` for context and props.\n\n## `React.ElementType`\n\nSimilar to [`React.ComponentType<Props>`](#toc-react-componenttype) except it also includes JSX intrinsics (strings).\n\nThe definition for `React.ElementType` is roughly:\n\n``` javascript\ntype ElementType =\n  | string\n  | React.ComponentType<any>;\n```\n\n## `React.MixedElement`\n\nThe most general type of all React elements (similar to `mixed` for all values). `React.MixedElement` is defined as `React.Element<React.ElementType>`.\n\nA common use case of this type is when we want to annotate an element with a type that hides the element details. For example\n\n``` javascript\nconst element: React.MixedElement = <div />;\n```\n\n## `React.Key`\n\nThe type of the key prop on React elements. It is a union of strings and numbers defined as:\n\n``` javascript\ntype Key = string | number;\n```\n\n## `React.Ref<typeof Component>`\n\nThe type of the [ref prop on React elements](https://facebook.github.io/react/docs/refs-and-the-dom.html). `React.Ref<typeof Component>` could be a string or a ref function.\n\nThe ref function will take one and only argument which will be the element instance which is retrieved using [`React.ElementRef<typeof Component>`](#toc-react-elementref) or null since [React will pass null into a ref function when unmounting](https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element).\n\nLike [`React.Element<typeof Component>`](#toc-react-element), `typeof Component` must be the type *of* a React component so you need to use `typeof` as in `React.Ref<typeof MyComponent>`.\n\nThe definition for `React.Ref<typeof Component>` is roughly:\n\n``` javascript\ntype Ref<C> =\n  | string\n  | (instance: React.ElementRef<C> | null) => mixed;\n```\n\n## `React.ElementProps<typeof Component>`\n\nGets the props for a React element type, *without* preserving the optionality of `defaultProps`. `typeof Component` could be the type of a React class component, a stateless functional component, or a JSX intrinsic string. This type is used for the `props` property on [`React.Element<typeof Component>`](#toc-react-element).\n\nLike [`React.Element<typeof Component>`](#toc-react-element), `typeof Component` must be the type *of* a React component so you need to use `typeof` as in `React.ElementProps<typeof MyComponent>`.\n\n> **Note:** Because [`React.ElementProps`](#toc-react-elementprops) does not preserve the optionality of `defaultProps`, [`React.ElementConfig`](#toc-react-elementconfig) (which does) is more often the right choice, especially for simple props pass-through as with [higher-order components](../hoc#toc-supporting-defaultprops-with-react-elementconfig).\n\n## `React.ElementConfig<typeof Component>`\n\nLike `React.ElementProps<typeof Component>` this utility gets the type of a component‚Äôs props but *preserves* the optionality of `defaultProps`!\n\nFor example,\n\n``` javascript\nimport * as React from 'react';\n\nclass MyComponent extends React.Component<{foo: number}> {\n  static defaultProps = {foo: 42};\n\n  render() {\n    return this.props.foo;\n  }\n}\n\n// `React.ElementProps<>` requires `foo` even though it has a `defaultProp`.\n({foo: 42}: React.ElementProps<typeof MyComponent>);\n\n// `React.ElementConfig<>` does not require `foo` since it has a `defaultProp`.\n({}: React.ElementConfig<typeof MyComponent>);\n```\n\nLike [`React.Element<typeof Component>`](#toc-react-element), `typeof Component` must be the type *of* a React component so you need to use `typeof` as in `React.ElementProps<typeof MyComponent>`.\n\n## `React.ElementRef<typeof Component>`\n\nGets the instance type for a React element. The instance will be different for various component types:\n\n- React class components will be the class instance. So if you had `class Foo extends React.Component<{}> {}` and used `React.ElementRef<typeof Foo>` then the type would be the instance of `Foo`.\n- React stateless functional components do not have a backing instance and so `React.ElementRef<typeof Bar>` (when `Bar` is `function Bar() {}`) will give you the undefined type.\n- JSX intrinsics like `div` will give you their DOM instance. For `React.ElementRef<'div'>` that would be `HTMLDivElement`. For `React.ElementRef<'input'>` that would be `HTMLInputElement`.\n\nLike [`React.Element<typeof Component>`](#toc-react-element), `typeof Component` must be the type *of* a React component so you need to use `typeof` as in `React.ElementRef<typeof MyComponent>`.\n\n## `React.Config<Props, DefaultProps>`\n\nCalculates a config object from props and default props. This is most useful for annotating HOCs that are abstracted over configs. See our [docs on writing HOCs](../hoc) for more information.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/react/types](https://flow.org/en/docs/react/types)"
- name: Type Refinements
  id: lang/refinements
  summary: Refinements are a frequently used aspect of many type systems
  description: "# Type Refinements\n\nRefinements are a frequently used aspect of many type systems. They are so ingrained in the way that we program and even the way that we think you might not even notice them.\n\nIn the code below, value can either be `\"A\"` or `\"B\"`.\n\n``` javascript\n// @flow\nfunction method(value: \"A\" | \"B\") {\n  if (value === \"A\") {\n    // value is \"A\"\n  }\n}\n```\n\nInside of the if block we know that value must be `\"A\"` because that‚Äôs the only time the if-statement will be truthy.\n\nThe ability for a static type checker to be able to tell that the value inside the if statement must be `\"A\"` is known as a refinement.\n\nNext we‚Äôll add an else block to our if statement.\n\n``` javascript\n// @flow\nfunction method(value: \"A\" | \"B\") {\n  if (value === \"A\") {\n    // value is \"A\"\n  } else {\n    // value is \"B\"\n  }\n}\n```\n\nInside of the else block we know that value must be `\"B\"` because it can only be `\"A\"` or `\"B\"` and we‚Äôve removed `\"A\"` from the possibilities.\n\nYou can expand this even further and keep refining possibilities away:\n\n``` javascript\n// @flow\nfunction method(value: \"A\" | \"B\" | \"C\" | \"D\") {\n  if (value === \"A\") {\n    // value is \"A\"\n  } else if (value === \"B\") {\n    // value is \"B\"\n  } else if (value === \"C\") {\n    // value is \"C\"\n  } else {\n    // value is \"D\"\n  }\n}\n```\n\nRefinements can also come in other forms other than testing for equality:\n\n``` javascript\n// @flow\nfunction method(value: boolean | Array<string> | Event) {\n  if (typeof value === \"boolean\") {\n    // value is a boolean\n  } else if (Array.isArray(value)) {\n    // value is an Array\n  } else if (value instanceof Event) {\n    // value is an Event\n  }\n}\n```\n\nOr you could refine on the shape of objects.\n\n``` javascript\n// @flow\ntype A = { type: \"A\" };\ntype B = { type: \"B\" };\n\nfunction method(value: A | B) {\n  if (value.type === \"A\") {\n    // value is A\n  } else {\n    // value is B\n  }\n}\n```\n\nWhich also applies to nested types within objects.\n\n``` javascript\n// @flow\nfunction method(value: { prop?: string }) {\n  if (value.prop) {\n    value.prop.charAt(0);\n  }\n}\n```\n\n## Refinement Invalidations\n\nIt is also possible to invalidate refinements, for example:\n\n``` javascript\n// @flow\nfunction otherMethod() { /* ... */ }\n\nfunction method(value: { prop?: string }) {\n  if (value.prop) {\n    otherMethod();\n    // $ExpectError\n    value.prop.charAt(0);\n  }\n}\n```\n\nThe reason for this is that we don‚Äôt know that `otherMethod()` hasn‚Äôt done something to our value. Imagine the following scenario:\n\n``` javascript\n// @flow\nvar obj = { prop: \"test\" };\n\nfunction otherMethod() {\n  if (Math.random() > 0.5) {\n    delete obj.prop;\n  }\n}\n\nfunction method(value: { prop?: string }) {\n  if (value.prop) {\n    otherMethod();\n    // $ExpectError\n    value.prop.charAt(0);\n  }\n}\n\nmethod(obj);\n```\n\nInside of `otherMethod()` we sometimes remove `prop`. Flow doesn‚Äôt know if the `if (value.prop)` check is still true, so it invalidates the refinement.\n\nThere‚Äôs a straightforward way to get around this. Store the value before calling another method and use the stored value instead. This way you can prevent the refinement from invalidating.\n\n``` javascript\n// @flow\nfunction otherMethod() { /* ... */ }\n\nfunction method(value: { prop?: string }) {\n  if (value.prop) {\n    var prop = value.prop;\n    otherMethod();\n    prop.charAt(0);\n  }\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/refinements](https://flow.org/en/docs/lang/refinements)"
- name: Type System
  id: lang
  summary: Developers like coding in JavaScript because it helps them move fast
  description: "# Type System\n\n### JavaScript: The Good and the Bad\n\nDevelopers like coding in JavaScript because it helps them move fast. The language facilitates fast prototyping of ideas via dynamic typing. The runtime provides the means for fast iteration on those ideas via dynamic compilation. This fuels a fast edit-refresh cycle, which promises an immersive coding experience that is quite appealing to creative developers.\n\nHowever, evolving and growing a JavaScript codebase is notoriously challenging. Developers cannot move fast when they break stuff. They hit frequent interruptions, spending a lot of time debugging silly mistakes, unraveling assumptions and guarantees made by libraries written by others, etc.\n\nIn principle, this overhead can be mitigated by adding a layer of types to the codebase, and building tools that use type information to solve the above problems. For example, types can be used to identify bugs, to document interfaces of libraries, and so on.\n\nThe idea of using types to manage code evolution and growth in JavaScript (and related languages) is not new. In fact, several useful type systems have been built for JavaScript in recent years. However, type systems differ in their goals. On one end of the spectrum are permissive type systems that provide some degree of linting against likely errors, without regard for correctness. On the other end of the spectrum are restrictive type systems that can guarantee the correctness of static code optimizations, at the cost of interoperability. Another area that has not seen a lot of focus is the performance of type checking itself.\n\n## Flow: Goals\n\nFlow is a static type checker for JavaScript that we built at Facebook. The overall mission of Flow is to deliver an immersive coding experience for JavaScript developers‚Äîa fast edit-refresh cycle‚Äîeven as the codebase evolves and grows. In engineering terms, we identify two concrete goals that are important to this mission: *precision* and *speed*. These goals pervasively drive the design and implementation.\n\n#### Precision\n\nJavaScript bugs can have significant impact at Facebook. Developers want to find and fix as many bugs as they can by the time their code rolls out into production. So we must care about soundness. At the same time, we must also care about not reporting too many spurious errors, because a low signal/noise ratio implies a low fix rate.\n\nIn other words, we want Flow‚Äôs analysis to be precise in practice‚Äîit must model essential characteristics of the language accurately enough to understand the difference between idiomatic code and unintentional mistakes.\n\nPrecision also has other desirable consequences. When types are trustworthy, developers tend to rely on them to structure their code and reason about it, leading to cleaner and more efficient code with fewer dynamic checks. When type errors are trustworthy, developers can focus on what their code does rather than thinking about how to rewrite their code to satisfy (or work around) the type system.\n\nFinally, precision enables useful developer tools to be built. In particular, the quality of results reported by Flow when the developer asks for the type of an expression, the definition reaching a reference, or the set of possible completions at a point through an IDE is correlated with the precision of Flow‚Äôs analysis.\n\n#### Speed\n\nPrecision usually comes at the cost of speed. But while a precise analysis is desirable, most of the appeal of JavaScript is lost if we slow down the edit-refresh cycle by making developers wait as we compile.\n\nIn other words, we must engineer Flow‚Äôs analysis to be extremely fast‚Äîit must respond to code changes without noticeable delay, while still being precise enough in practice.\n\nLike precision, speed also has other significant effects. When bugs are reported as the developer makes changes to code, they become part of the editing process‚Äîthe developer doesn‚Äôt need to run the code to detect bugs, and tracing bugs back to the code becomes simpler. Similarly, when the IDE can show the type of an expression, the definition reaching a reference, etc. as the developer is coding, we have observed that productivity can improve dramatically.\n\n#### What makes Flow precise?\n\nOne of the main contributors of Flow‚Äôs precision is path-sensitivity: the way types interact with runtime tests. The essence of many JavaScript idioms is to put together ad hoc sets of runtime values and to take them apart with shallow, structural (in)equality checks. In Flow, the set of runtime values that a variable may contain is described by its type, and a runtime test on that variable refines the type to a smaller set. This ability turns out to be quite powerful and general in practice.\n\n#### What makes Flow fast?\n\nThe key to Flow‚Äôs speed is modularity: the ability to break the analysis into file-sized chunks that can be assembled later.\n\nFortunately, JavaScript is already written using files as modules, so we modularize our analysis simply by asking that modules have explicitly typed signatures. (We still infer types for the vast majority of code ‚Äúlocal‚Äù to modules.) Coincidentally, developers consider this good software engineering practice anyway.\n\nWith modularity, we can aggressively parallelize our analysis. Furthermore, when files change, we can incrementally analyze only those files that depend on the changed files. Together, these choices have helped scale the analysis to millions of lines of code.\n\nUnder the hood, Flow relies on a high-throughput low-latency systems infrastructure that enables distribution of tasks among parallel workers, and communication of results in parallel via shared memory. Combined with an architecture where the analysis of a codebase is updated automatically in the background on file system changes, Flow delivers near-instantaneous feedback as the developer edits and rebases code, even in a large repository.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang](https://flow.org/en/docs/lang)"
- name: Type Variance
  id: lang/variance
  summary: Variance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it
  description: "# Type Variance\n\nVariance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it. Let‚Äôs walk through each form of variance.\n\nFirst we‚Äôll setup a couple of classes that extend one another.\n\n``` javascript\nclass Noun {}\nclass City extends Noun {}\nclass SanFrancisco extends City {}\n```\n\nWe‚Äôll use these classes to write a method that has each kind of variance.\n\n> **Note:** The `*variantOf` types below are not a part of Flow, they are being used to explain variance.\n\n### Invariance\n\n``` javascript\nfunction method(value: InvariantOf<City>) {...}\n\nmethod(new Noun());         // error...\nmethod(new City());         // okay\nmethod(new SanFrancisco()); // error...\n```\n\n- Invariance *does not* accept **supertypes**.\n- Invariance *does not* accept **subtypes**.\n\n### Covariance\n\n``` javascript\nfunction method(value: CovariantOf<City>) {...}\n\nmethod(new Noun());         // error...\nmethod(new City());         // okay\nmethod(new SanFrancisco()); // okay\n```\n\n- Covariance *does not* accept **supertypes**.\n- Covariance *does* accept **subtypes**.\n\n### Contravariance\n\n``` javascript\nfunction method(value: ContravariantOf<City>) {...}\n\nmethod(new Noun());         // okay\nmethod(new City());         // okay\nmethod(new SanFrancisco()); // error...\n```\n\n- Contravariance *does* accept **supertypes**.\n- Contravariance *does not* accept **subtypes**.\n\n### Bivariance\n\n``` javascript\nfunction method(value: BivariantOf<City>) {...}\nmethod(new Noun());         // okay\nmethod(new City());         // okay\nmethod(new SanFrancisco()); // okay\n```\n\n- Bivariance *does* accept **supertypes**.\n- Bivariance *does* accept **subtypes**.\n\nAs a result of having weak dynamic typing, JavaScript doesn‚Äôt have any of these, you can use any type at any time.\n\n## Variance in Classes\n\nTo get a sense of when and why the different kinds of variance matters, let‚Äôs talk about methods of subclasses and how they get type checked.\n\nWe‚Äôll quickly set up our `BaseClass` which will define just one method that accepts an input value with the type `City` and a returned output also with the type `City`.\n\n``` javascript\nclass BaseClass {\n  method(value: City): City { ... }\n}\n```\n\nNow, let‚Äôs walk through different definitions of `method()` in a couple different *subclasses*.\n\n### Equally specific inputs and outputs ‚Äî Good\n\nTo start, we can define a SubClass that extends our BaseClass. Here you can see that the value and the return type are both City just like in BaseClass:\n\n``` javascript\nclass SubClass extends BaseClass {\n  method(value: City): City { ... }\n}\n```\n\nThis is okay because if something else in your program is using `SubClass` as if it were a `BaseClass`, it would still be using a `City` and wouldn‚Äôt cause any issues.\n\n### More specific outputs ‚Äî Good\n\nNext, we‚Äôll have a different `SubClass` that returns a more specific type:\n\n``` javascript\nclass SubClass extends BaseClass {\n  method(value: City): SanFrancisco { ... }\n}\n```\n\nThis is also okay because if something is using `SubClass` as if it were a `BaseClass` they would still have access to the same interface as before because `SanFrancisco` is just a `City` with a little more information.\n\n### Less specific outputs ‚Äî Bad\n\nNext, we‚Äôll have a different `SubClass` that returns a less specific type:\n\n``` javascript\nclass SubClass extends BaseClass {\n  method(value: City): Noun { ... } // ERROR!!\n}\n```\n\nIn Flow this will cause an error because if you are expecting to get a return value of a `City`, you may be using something that doesn‚Äôt exist on `Noun`, which could easily cause an error at runtime.\n\n### Less specific inputs ‚Äî Good\n\nNext, we‚Äôll have another SubClass that accepts a value of a less specific type.\n\n``` javascript\nclass SubClass extends BaseClass {\n  method(value: Noun): City { ... }\n}\n```\n\nThis is perfectly fine because if we pass in a more specific type we‚Äôll still have all the information we need to be compatible with `Noun`.\n\n### More specific inputs ‚Äî Bad\n\nFinally, we‚Äôll have yet another `SubClass` that accepts a value of a more specific type.\n\n``` javascript\nclass SubClass extends BaseClass {\n  method(value: SanFrancisco): City { ... } // ERROR!!\n}\n```\n\nThis is an error in Flow because if you are expecting a `SanFrancisco` and you get a `City` you could be using something that only exists on `SanFrancisco` which would cause an error at runtime.\n\nAll of this is why Flow has contravariant inputs (accepts less specific types to be passed in), and covariant outputs (allows more specific types to be returned).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/variance](https://flow.org/en/docs/lang/variance)"
- name: Typeof Types
  id: types/typeof
  summary: JavaScript has a typeof operator which returns a string describing a value
  description: "# Typeof Types\n\nJavaScript has a `typeof` operator which returns a string describing a value.\n\n``` javascript\ntypeof 1 === 'number'\ntypeof true === 'boolean'\ntypeof 'three' === 'string'\n```\n\nHowever it is limited in that this string only describes so much about the type.\n\n``` javascript\ntypeof { foo: true } === 'object'\ntypeof { bar: true } === 'object'\ntypeof [true, false] === 'object'\n```\n\nIn Flow, there is a similar `typeof` operator, but it‚Äôs much more powerful.\n\n## `typeof` type syntax\n\nThe `typeof` operator returns the Flow type of a given value to be used as a type.\n\n``` javascript\n// @flow\nlet num1 = 42;\nlet num2: typeof num1 = 3.14;     // Works!\n// $ExpectError\nlet num3: typeof num1 = 'world';  // Error!\n\nlet bool1 = true;\nlet bool2: typeof bool1 = false;  // Works!\n// $ExpectError\nlet bool3: typeof bool1 = 42;     // Error!\n\nlet str1 = 'hello';\nlet str2: typeof str1 = 'world'; // Works!\n// $ExpectError\nlet str3: typeof str1 = false;   // Error!\n```\n\nYou can use any value with `typeof`:\n\n``` javascript\n// @flow\nlet obj1 = { foo: 1, bar: true, baz: 'three' };\nlet obj2: typeof obj1 = { foo: 42, bar: false, baz: 'hello' };\n\nlet arr1 = [1, 2, 3];\nlet arr2: typeof arr1 = [3, 2, 1];\n```\n\n## `typeof` inherits behaviors of inference\n\nFlow does all sorts of type inference on your code so that you don‚Äôt have to type annotate anything. Generally, inference avoids getting in your way while still preventing you from introducing bugs.\n\nBut when you use `typeof`, you‚Äôre taking the results of Flow‚Äôs inference and asserting it as a type. While this can be very useful, it can also lead to some unexpected results.\n\nFor example, when you use literal values in Flow, their inferred type is the primitive that it belongs to. Thus, the number 42 has the inferred type of `number`. You can see this when you use `typeof`.\n\n``` javascript\n// @flow\nlet num1 = 42;\nlet num2: typeof num1 = 3.14;    // Works!\n\nlet bool1 = true;\nlet bool2: typeof bool1 = false; // Works!\n\nlet str1 = 'hello';\nlet str2: typeof str1 = 'world'; // Works!\n```\n\nHowever, this only happens with the inferred type. If you specify the literal type, it will be used in `typeof`.\n\n``` javascript\n// @flow\nlet num1: 42 = 42;\n// $ExpectError\nlet num2: typeof num1 = 3.14;    // Error!\n\nlet bool1: true = true;\n// $ExpectError\nlet bool2: typeof bool1 = false; // Error!\n\nlet str1: 'hello' = 'hello';\n// $ExpectError\nlet str2: typeof str1 = 'world'; // Error!\n```\n\n## `typeof` inherits behaviors of other types\n\nThere are many different types in Flow, some of these types behave differently than others. These differences make sense for that particular type but not for others.\n\nWhen you use `typeof`, you‚Äôre inserting another type with all of its behaviors. This can make `typeof` seem inconsistent where it is not.\n\nFor example, if you use `typeof` with a class you need to remember that classes are *nominally* typed instead of *structurally* typed. So that two classes with the same exact shape are not considered equivalent.\n\n``` javascript\n// @flow\nclass MyClass {\n  method(val: number) { /* ... */ }\n}\n\nclass YourClass {\n  method(val: number) { /* ... */ }\n}\n\n// $ExpectError\nlet test1: typeof MyClass = YourClass; // Error!\nlet test2: typeof MyClass = MyClass;   // Works!\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/typeof](https://flow.org/en/docs/types/typeof)"
- name: Types & Expressions
  id: lang/types-and-expressions
  summary: 'In JavaScript there are many types of values: numbers, strings, booleans, functions, objects, and more'
  description: "# Types & Expressions\n\nIn JavaScript there are many types of values: numbers, strings, booleans, functions, objects, and more.\n\n``` javascript\n(1234: number);\n(\"hi\": string);\n(true: boolean);\n([1, 2]: Array<number>);\n({ prop: \"value\" }: Object);\n(function method() {}: Function);\n```\n\nThese values can be used in many different ways:\n\n``` javascript\n1 + 2;\n\"foo\" + \"bar\";\n!true;\n[1, 2].push(3);\nlet value = obj.prop;\nobj.prop = \"value\";\nmethod(\"value\");\n```\n\nAll of these different expressions create a new type which is a result of the types of values and the operations run on them.\n\n``` javascript\nlet num: number = 1 + 2;\nlet str: string = \"foo\" + \"bar\";\n```\n\nIn Flow every value and expression has a type.\n\n## Figuring out types statically\n\nFlow needs a way to be able to figure out the type of every expression. But it can‚Äôt just run your code to figure it out, if it did it would be affected by any issues that your code has. For example, if you created an infinite loop Flow would wait for it to finish forever.\n\nInstead, Flow needs to be able to figure out the type of a value by analyzing it without running it (static analysis). It works its way through every known type and starts to figure out what all the expressions around them result in.\n\nFor example, to figure out the result of the following expression, Flow needs to figure out what its values are first.\n\n``` javascript\nval1 + val2;\n```\n\nIf the values are numbers, then the expression results in a number. If the values are strings, then the expression results in a string. There are a number of different possibilities here, so Flow must look up what the values are.\n\nIf Flow is unable to figure out what the exact type is for each value, Flow must figure out what every possible value is and check to make sure that the code around it will still work with all of the possible types.\n\n## Soundness and Completeness\n\nWhen you run your code, a single expression will only be run with a limited set of values. But still Flow checks *every* possible value. In this way Flow is checking too many things or *over-approximating* what will be valid code.\n\nBy checking every possible value, Flow might catch errors that will not actually occur when the code is run. Flow does this in order to be *‚Äúsound‚Äù*.\n\nIn type systems, ***soundness*** is the ability for a type checker to catch every single error that *might* happen at runtime. This comes at the cost of sometimes catching errors that will not actually happen at runtime.\n\nOn the flip-side, ***completeness*** is the ability for a type checker to only ever catch errors that *would* happen at runtime. This comes at the cost of sometimes missing errors that will happen at runtime.\n\nIn an ideal world, every type checker would be both sound *and* complete so that it catches *every* error that *will* happen at runtime.\n\nFlow tries to be as sound and complete as possible. But because JavaScript was not designed around a type system, Flow sometimes has to make a tradeoff. When this happens Flow tends to favor soundness over completeness, ensuring that code doesn‚Äôt have any bugs.\n\nSoundness is fine as long as Flow isn‚Äôt being too noisy and preventing you from being productive. Sometimes when soundness would get in your way too much, Flow will favor completeness instead. There‚Äôs only a handful of cases where Flow does this.\n\nOther type systems will favor completeness instead, only reporting real errors in favor of possibly missing errors. Unit/Integration testing is an extreme form of this approach. Often this comes at the cost of missing the errors that are the most complicated to find, leaving that part up to the developer.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/types-and-expressions](https://flow.org/en/docs/lang/types-and-expressions)"
- name: Types-First
  id: lang/types-first
  summary: Flow checks codebases by processing each file separately in dependency order
  description: "# Types-First\n\nFlow checks codebases by processing each file separately in dependency order. After a file has been checked, a signature is extracted and stored in main memory, to be used for files that depend on it. Currently, the default mode (we‚Äôll also refer to it as *classic* mode) builds these signatures by using the types inferred for the file‚Äôs exports. In the new *types-first* architecture, Flow relies on annotations available at the boundaries of files to build these signatures.\n\nThe benefit of this new architecture is dual:\n\n1.  It dramatically improves *performance*, in particular when it comes to rechecks. Suppose we want Flow to check a file `foo.js`, for which it hasn‚Äôt checked its dependencies yet. Classic mode would need to check all dependencies and generate signatures from them first, before it could check `foo.js`. In types-first, Flow extracts the dependency signatures just by looking at the annotations around the exports. This process is mostly syntactic, and therefore much faster than full type inference.\n\n2.  It improves error *reliability*. Inferred types often become complicated, and may lead to errors being reported in downstream files, far away from their actual source. Type annotations at file boundaries of files can help localize such errors, and address them in the file that introduced them.\n\nThe caveat of this new version is that it requires exported parts of the code to be annotated with types, or to be expressions whose type can be trivially inferred (for example numbers and strings).\n\n## How to upgrade your codebase to Types-First\n\n### Upgrade Flow version\n\nTypes-first mode is officially released with version 0.125, but has been available in *experimental* status as of version 0.102. If you are currently on an older Flow version, you‚Äôd have to first upgrade Flow. Using the latest Flow version is the best way to benefit from the performance benefits outlined above.\n\n### Prepare your codebase for Types-First\n\nTypes-first requires annotations at module boundaries in order to build type signature for files. If these annotations are missing, then a `signature-verification-failure` is raised, and the exported type for the respective part of the code will be `any`.\n\nTo see what types are missing to make your codebase types-first ready, add the following line to the `[options]` section of the `.flowconfig` file:\n\n``` plaintext\nwell_formed_exports=true\n```\n\nConsider for example a file `foo.js` that exports a function call to `foo`\n\n``` javascript\ndeclare function foo<T>(x: T): T;\nmodule.exports = foo(1);\n```\n\nThe return type of function calls is currently not trivially inferable (due to features like polymorphism, overloading etc.). Their result needs to be annotated and so you‚Äôd see the following error:\n\n``` plaintext\nCannot build a typed interface for this module. You should annotate the exports\nof this module with types. Cannot determine the type of this call expression. Please\nprovide an annotation, e.g., by adding a type cast around this expression.\n(`signature-verification-failure`)\n\n   4‚îÇ module.exports = foo(1);\n                       ^^^^^^\n```\n\nTo resolve this, you can add an annotation like the following:\n\n``` javascript\ndeclare function foo<T>(x: T): T;\nmodule.exports = (foo(1): number);\n```\n\n> Note: As of version 0.134, types-first is the default mode. This mode automatically enables `well_formed_exports`, so you would see these errors without explicitly setting this flag. It is advisable to set `types_first=false` during this part of the upgrade.\n\n#### Seal your intermediate results\n\nAs you make progress adding types to your codebase, you can include directories so that they don‚Äôt regress as new code gets committed, and until the entire project has well-formed exports. You can do this by adding lines like the following to your .flowconfig:\n\n``` plaintext\nwell_formed_exports.includes=<PROJECT_ROOT>/path/to/directory\n```\n\n> Warning: That this is a *substring* check, not a regular expression (for performance reasons).\n\n#### A codemod for large codebases\n\nAdding the necessary annotations to large codebases can be quite tedious. To ease this burden, we are providing a codemod based on Flow‚Äôs inference, that can be used to annotate multiple files in bulk. See [this tutorial](https://flow.org/en/cli/annotate-exports/) for more.\n\n### Enable the types-first flag\n\nOnce you have eliminated signature verification errors, you can turn on the types-first mode, by adding the following line to the `[options]` section of the `.flowconfig` file:\n\n``` plaintext\ntypes_first=true\n```\n\nYou can also pass `--types-first` to the `flow check` or `flow start` commands.\n\nThe `well_formed_exports` flag from before is implied by `types_first`. Once this process is completed and types-first has been enabled, you can remove `well_formed_exports`.\n\nUnfortunately, it is not possible to enable types-first mode for part of your repo; this switch affects all files managed by the current `.flowconfig`.\n\n> Note: The above flags are available in versions of Flow `>=0.102` with the `experimental.` prefix (and prior to v0.128, it used `whitelist` in place of `includes`):\n>\n> ``` plaintext\n> experimental.well_formed_exports=true\n> experimental.well_formed_exports.whitelist=<PROJECT_ROOT>/path/to/directory\n> experimental.types_first=true\n> ```\n\n> Note: If you are using a version where types-first is enabled by default (ie. `>=0.134`), make sure you set `types_first=false` in your .flowconfig while running the codemods.\n\n### Deal with newly introduced errors\n\nSwitching between classic and types-first mode may cause some new Flow errors, besides signature-verification failures that we mentioned earlier. These errors are due differences in the way types based on annotations are interpreted, compared to their respective inferred types.\n\nBelow are some common error patterns and how to overcome them.\n\n#### Array tuples treated as regular arrays in exports\n\nIn types-first, an array literal in an *export position*\n\n``` javascript\nmodule.exports = [e1, e2];\n```\n\nis treated as having type `Array<t1 | t2>`, where `e1` and `e2` have types `t1` and `t2`, instead of the tuple type `[t1, t2]`.\n\nIn classic mode, the inferred type encompassed both types at the same time. This might cause errors in importing files that expect for example to find type `t1` in the first position of the import.\n\n**Fix:** If a tuple type is expected, then the annotation `[t1, t2]` needs to be explicitly added on the export side.\n\n#### Indirect object assignments in exports\n\nFlow allows the code\n\n``` javascript\nfunction foo(): void {}\nfoo.x = () => {};\nfoo.x.y = 2;\nmodule.exports = foo;\n```\n\nbut in types-first the exported type will be\n\n``` plaintext\n{\n  (): void;\n  x: () => void;\n}\n```\n\nIn other words it won‚Äôt take into account the update on `y`.\n\n**Fix:** To include the update on `y` in the exported type, the export will need to be annotated with the type\n\n``` plaintext\n{\n  (): void;\n  x: { (): void; y: number; };\n};\n```\n\nThe same holds for more complex assignment patterns like\n\n``` javascript\nfunction foo(): void {}\nObject.assign(foo, { x: 1});\nmodule.exports = foo;\n```\n\nwhere you‚Äôll need to manually annotate the export with `{ (): void; x: number }`, or assignments preceding the function definition\n\n``` javascript\nfoo.x = 1;\nfunction foo(): void {}\nmodule.exports = foo;\n```\n\nNote that in the last example, Flow types-first will pick up the static update if it was after the definition:\n\n``` javascript\nfunction foo(): void {}\nfoo.x = 1;\nmodule.exports = foo;\n```\n\n### Exported variables with updates\n\nThe types-first signature extractor will not pick up subsequent update of an exported let-bound variables. Consider the example\n\n``` javascript\nlet foo: number | string = 1;\nfoo = \"blah\";\nmodule.exports = foo;\n```\n\nIn classic mode the exported type would be `string`. In types-first it will be `number | string`, so if downstream typing depends on the more precise type, then you might get some errors.\n\n**Fix:** Introduce a new variable on the update and export that one. For example\n\n``` javascript\nconst foo1: number | string = 1;\nconst foo2 = \"blah\";\nmodule.exports = foo2;\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/types-first](https://flow.org/en/docs/lang/types-first)"
- name: Union Types
  id: types/unions
  summary: Sometimes it‚Äôs useful to create a type which is one of a set of other types
  description: "# Union Types\n\nSometimes it‚Äôs useful to create a type which is ***one of*** a set of other types. For example, you might want to write a function which accepts a set of primitive value types. For this Flow supports **union types**.\n\n``` javascript\n// @flow\nfunction toStringPrimitives(value: number | boolean | string) {\n  return String(value);\n}\n\ntoStringPrimitives(1);       // Works!\ntoStringPrimitives(true);    // Works!\ntoStringPrimitives('three'); // Works!\n\n// $ExpectError\ntoStringPrimitives({ prop: 'val' }); // Error!\n// $ExpectError\ntoStringPrimitives([1, 2, 3, 4, 5]); // Error!\n```\n\n## Union type syntax\n\nUnion types are any number of types which are joined by a vertical bar `|`.\n\n``` javascript\nType1 | Type2 | ... | TypeN\n```\n\nYou may also add a leading vertical bar which is useful when breaking union types onto multiple lines.\n\n``` javascript\ntype Foo =\n  | Type1\n  | Type2\n  | ...\n  | TypeN\n```\n\nEach of the members of a union type can be any type, even another union type.\n\n``` javascript\ntype Numbers = 1 | 2;\ntype Colors = 'red' | 'blue'\n\ntype Fish = Numbers | Colors;\n```\n\nIf you have enabled [Flow Enums](https://flow.org/en/enums/), they may be an alternative to unions of primitive values.\n\n## Union types requires one in, but all out\n\nWhen calling our function that accepts a union type we must pass in ***one of those types***. But inside of our function we are required to handle ***all of the possible types***.\n\nLet‚Äôs rewrite our function to handle each type individually.\n\n``` javascript\n// @flow\n// $ExpectError\nfunction toStringPrimitives(value: number | boolean | string): string { // Error!\n  if (typeof value === 'number') {\n    return String(value);\n  } else if (typeof value === 'boolean') {\n    return String(value);\n  }\n}\n```\n\nYou‚Äôll notice that if we do not handle each possible type of our value, Flow will give us an error.\n\n## Unions & Refinements\n\nWhen you have a value which is a union type it‚Äôs often useful to break it apart and handle each individual type separately. With union types in Flow you can ‚Äúrefine‚Äù the value down to a single type.\n\nFor example, if we have a value with a union type that is a `number`, a `boolean`, or a `string`, we can treat the number case separately by using JavaScript‚Äôs `typeof` operator.\n\n``` javascript\n// @flow\nfunction toStringPrimitives(value: number | boolean | string) {\n  if (typeof value === 'number') {\n    return value.toLocaleString([], { maximumSignificantDigits: 3 }); // Works!\n  }\n  // ...\n}\n```\n\nBy checking the typeof our value and testing to see if it is a number, Flow knows that inside of that block it is only a number. We can then write code which treats our value as a number inside of that block.\n\n### Disjoint Object Unions\n\nThere‚Äôs a special type of union in Flow known as a ‚Äúdisjoint object union‚Äù which can be used in [refinements](https://flow.org/en/lang/refinements/). These disjoint object unions are made up of any number of object types which are each tagged by a single property.\n\nFor example, imagine we have a function for handling a response from a server after we‚Äôve sent it a request. When the request is successful, we‚Äôll get back an object with a `type` property set to `'success'` and a `value` that we‚Äôve updated.\n\n``` javascript\n{ type: 'success', value: 23 };\n```\n\nWhen the request fails, we‚Äôll get back an object with `type` set to `'error'` and an `error` property describing the error.\n\n``` javascript\n{ type: 'error', error: 'Bad request' };\n```\n\nWe can try to express both of these objects in a single object type. However, we‚Äôll quickly run into issues where we know a property exists based on the `type` property but Flow does not.\n\n``` javascript\n// @flow\ntype Response = {\n  type: 'success' | 'error',\n  value?: number,\n  error?: string\n};\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    // $ExpectError\n    const value: number = response.value; // Error!\n  } else {\n    // $ExpectError\n    const error: string = response.error; // Error!\n  }\n}\n```\n\nTrying to combine these two separate types into a single one will only cause us trouble.\n\nInstead, if we create a union type of both object types, Flow will be able to know which object we‚Äôre using based on the `type` property.\n\n``` javascript\n// @flow\ntype Response =\n  | { type: 'success', value: 23 }\n  | { type: 'error', error: string };\n\nfunction handleResponse(response: Response) {\n  if (response.type === 'success') {\n    const value: number = response.value; // Works!\n  } else {\n    const error: string = response.error; // Works!\n  }\n}\n```\n\nIn order to use this pattern, there must be a key that is in every object in your union (in our example above, `type`), and every object must set a different [literal type](../literals) for that key (in our example, the string `'success'`, and the string `'error'`). You can use any kind of literal type, including numbers and booleans.\n\n### Disjoint unions with exact types\n\nDisjoint unions require you to use a single property to distinguish each object type. You cannot distinguish two different objects by different properties.\n\n``` javascript\n// @flow\ntype Success = { success: true, value: boolean };\ntype Failed  = { error: true, message: string };\n\nfunction handleResponse(response:  Success | Failed) {\n  if (response.success) {\n    // $ExpectError\n    var value: boolean = response.value; // Error!\n  }\n}\n```\n\nThis is because in Flow it is okay to pass an object value with more properties than the object type expects (because of width subtyping).\n\n``` javascript\n// @flow\ntype Success = { success: true, value: boolean };\ntype Failed  = { error: true, message: string };\n\nfunction handleResponse(response:  Success | Failed) {\n  // ...\n}\n\nhandleResponse({\n  success: true,\n  error: true,\n  value: true,\n  message: 'hi'\n});\n```\n\nUnless the objects somehow conflict with one another there is no way to distinguish them.\n\nHowever, to get around this you could use **exact object types**.\n\n``` javascript\n// @flow\ntype Success = {| success: true, value: boolean |};\ntype Failed  = {| error: true, message: string |};\n\ntype Response = Success | Failed;\n\nfunction handleResponse(response: Response) {\n  if (response.success) {\n    var value: boolean = response.value;\n  } else {\n    var message: string = response.message;\n  }\n}\n```\n\nWith exact object types, we cannot have additional properties, so the objects conflict with one another and we are able to distinguish which is which.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/unions](https://flow.org/en/docs/types/unions)"
- name: Usage
  id: usage
  summary: Once you have installed Flow, you will want to get a feel of how to use Flow at the most basic level
  description: "# Usage\n\nOnce you have [installed](https://flow.org/en/install/) Flow, you will want to get a feel of how to use Flow at the most basic level. For most new Flow projects, you will follow this general pattern:\n\n- [Initialize your project](#toc-initialize-your-project) with `flow init`.\n- Start the [Flow background process](#toc-run-the-flow-background-process) with `flow`.\n- [Determine](#toc-prepare-your-code-for-flow) which files Flow will monitor with `// @flow`.\n- [Write Flow code](#toc-write-flow-code) for your project.\n- [Check your code](#toc-check-your-code) for type errors.\n\n## Initialize Your Project\n\nPreparing a project for Flow requires only one command:\n\n``` sh\nflow init\n```\n\nRun this command at the top level of your project to create one, empty file called [`.flowconfig`](https://flow.org/en/config/). At its most basic level, `.flowconfig` tells the Flow background process the root of where to begin checking Flow code for errors.\n\nAnd that is it. Your project is now Flow-enabled.\n\n> It is common to have an empty `.flowconfig` file for your project. However, you can [configure and customize Flow](https://flow.org/en/config/) in many ways through options available to be added to `.flowconfig`.\n\n## Run the Flow Background Process\n\nThe core benefit to Flow is its ability to quickly check your code for errors. Once you have enabled your project for Flow, you can start the process that allows Flow to check your code incrementally and with great speed.\n\n``` sh\nflow status\n```\n\nThis command first starts a background process that will check all [Flow files](#toc-prepare-your-code-for-flow) for errors. The background process continues running, monitoring changes to your code and checking those changes incrementally for errors.\n\n> You can also type `flow` to accomplish the same effect as `status` is the default flag to the `flow` binary.\n\n> Only one background process will be running at any given time, so if you run `flow status` multiple times, it will use the same process.\n\n> To stop the background process, run `flow stop`.\n\n## Prepare Your Code for Flow\n\nThe Flow background process monitors all Flow files. However, how does it know which files are Flow files and, thus, should be checked? Placing the following **before any code** in a JavaScript file is the flag the process uses to answer that question.\n\n``` javascript\n// @flow\n```\n\nThis flag is in the form of a normal JavaScript comment annotated with `@flow`. The Flow background process gathers all the files with this flag and uses the type information available from all of these files to ensure consistency and error free programming.\n\n> You can also use the form `/* @flow */` for the flag as well.\n\n> For files in your project without this flag, the Flow background process skips and ignores the code (unless you call `flow check --all`, which is beyond the scope of basic usage).\n\n## Write Flow Code\n\nNow that all the setup and initialization is complete, you are ready to write actual Flow code. For each file that you have flagged with `// @flow`, you now have the full power of Flow and its type-checking available to you. Here is an example Flow file:\n\n``` javascript\n// @flow\n\nfunction foo(x: ?number): string {\n  if (x) {\n    return x;\n  }\n  return \"default string\";\n}\n```\n\nNotice the types added to the parameter of the function along with a return type at the end of the function. You might be able to tell from looking at this code that there is an error in the return type since the function can also return a `number`. However, you do not need to visually inspect the code since the Flow background process will be able to catch this error for you when you [check your code](#toc-check-your-code).\n\n## Check Your Code\n\nThe great thing about Flow is that you can get near real-time feedback on the state of your code. At any point that you want to check for errors, just run:\n\n``` sh\n# equivalent to `flow status`\nflow\n```\n\nThe first time this is run, the [Flow background process](#toc-run-flow-background-process) will be spawned and all of your Flow files will be checked. Then, as you continue to iterate on your project, the background process will continuously monitor your code such that when you run `flow` again, the updated result will be near instantaneous.\n\nFor the [code above](#toc-write-flow-code), running `flow` will yield:\n\n``` sh\ntest.js:5\n  5:     return x;\n                ^ number. This type is incompatible with the expected return type of\n  3: function foo(x: ?number): string {\n                               ^^^^^^ string\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/usage](https://flow.org/en/docs/usage)"
- name: Using enums
  id: enums/using-enums
  summary: Flow Enums are not a syntax for union types
  description: "# Using enums\n\n- [Accessing enum members](#toc-accessing-enum-members)\n- [Using as a type annotation](#toc-using-as-a-type-annotation)\n- [Casting to representation type](#toc-casting-to-representation-type)\n- [Methods](#toc-methods)\n  - [.cast](#toc-cast)\n  - [.isValid](#toc-isvalid)\n  - [.members](#toc-members)\n  - [.getName](#toc-getname)\n- [Exhaustively checking enums with a `switch`](#toc-exhaustively-checking-enums-with-a-switch)\n- [Exhaustive checking with unknown members](#toc-exhaustive-checking-with-unknown-members)\n- [Mapping enums to other values](#toc-mapping-enums-to-other-values)\n- [Enums in a union](#toc-enums-in-a-union)\n- [Exporting enums](#toc-exporting-enums)\n- [Importing enums](#toc-importing-enums)\n- [Generic enums](#toc-generic-enums)\n- [When to not use enums](#toc-when-to-not-use-enums)\n\nFlow Enums are not a syntax for [union types](https://flow.org/en/types/unions/). They are their own type, and each member of a Flow Enum has the same type. Large union types can cause performance issues, as Flow has to consider each member as a separate type. With Flow Enums, no matter how large your enum is, Flow will always exhibit good performance as it only has one type to keep track of.\n\nWe use the following enum in the examples below:\n\n``` javascript\nenum Status {\n  Active,\n  Paused,\n  Off,\n}\n```\n\n## Accessing enum members\n\nAccess members with the dot syntax:\n\n``` javascript\nconst status = Status.Active;\n```\n\nYou can‚Äôt use computed access:\n\n``` javascript\nconst x = \"Active\";\nStatus[x]; // Error: computed access on enums is not allowed\n```\n\n## Using as a type annotation\n\nThe enum declaration defines both a value (from which you can access the enum members and methods) and a type of the same name, which is the type of the enum members.\n\n``` javascript\nfunction calculateStatus(): Status {\n  ...\n}\n\nconst status: Status = calculateStatus();\n```\n\n## Casting to representation type\n\nEnums do not implicitly coerce to their representation type or vice-versa. If you want to convert from the enum type to the representation type, you can use an explicit cast `(x: string)`:\n\n``` javascript\nconst s: string = Status.Active; // Error: 'Status' is not compatible with 'string'\n\nconst statusString: string = (Status.Active: string);\n```\n\nTo convert from a nullable enum type to nullable string, you can do:\n\n``` javascript\nconst maybeStatus: ?Status = ....;\n\nconst maybeStatusString: ?string = maybeStatus && (maybeStatus: string);\n```\n\nIf you want to convert from the representation type (e.g. `string`) to an enum type (if valid), check out the [cast method](#toc-cast).\n\n## Methods\n\nEnum declarations also define some helpful methods.\n\nBelow, `TEnum` is the type of the enum (e.g. `Status`), and `TRepresentationType` is the type of the representation type for that enum (e.g. `string`).\n\n### .cast\n\nType: `cast(input: ?TRepresentationType): TEnum | void`\n\nThe `cast` method allows you to safely convert a primitive value, like a `string`, to the enum type (if it is a valid value of the enum), and `undefined` otherwise.\n\n``` javascript\nconst data: string = getData();\nconst maybeStatus: Status | void = Status.cast(data);\nif (maybeStatus != null) {\n  const status: Status = maybeStatus;\n  // do stuff with status\n}\n```\n\nSet a default value in one line with the `??` operator:\n\n``` javascript\nconst status: Status = Status.cast(data) ?? Status.Off;\n```\n\nThe type of the argument of `cast` depends on the type of enum. If it is a [string enum](../defining-enums#toc-string-enums), the type of the argument will be `string`. If it is a [number enum](../defining-enums#toc-number-enums), the type of the argument will be `number`, and so on. If you wish to cast a `mixed` value, first use a `typeof` refinement:\n\n``` javascript\nconst data: mixed = ...;\nif (typeof data === 'string') {\n  const maybeStatus: Status | void = Status.cast(data);\n}\n```\n\n`cast` uses `this` (representing the object of enum members), so if you want to pass the function itself as a value, you should use an arrow function. For example:\n\n``` javascript\nconst strings: Array<string> = ...;\n// WRONG: const statuses: Array<?Status> = strings.map(Status.cast);\nconst statuses: Array<?Status> = strings.map((input) => Status.cast(input)); // Correct\n```\n\nRuntime cost: For [mirrored string enums](../defining-enums#toc-string-enums) (e.g `enum E {A, B}`), as the member names are the same as the values, the runtime cost is constant - equivalent to calling `.hasOwnProperty`. For other enums, a `Map` is created on the first call, and subsequent calls simply call `.has` on the cached map. Thus the cost is amoritzed constant.\n\n### .isValid\n\nType: `isValid(input: ?TRepresentationType): boolean`\n\nThe `isValid` method is like `cast`, but simply returns a boolean: `true` if the input supplied is a valid enum value, and `false` if it is not.\n\n``` javascript\nconst data: string = getData();\nconst isStatus: boolean = Status.isValid(data);\n```\n\n`isValid` uses `this` (representing the object of enum members), so if you want to pass the function itself as a value, you should use an arrow function. For example:\n\n``` javascript\nconst strings: Array<string> = ...;\n// WRONG: const statusStrings = strings.filter(Status.isValid);\nconst statusStrings = strings.filter((input) => Status.isValid(input)); // Correct\n```\n\nRuntime cost: The same as described under `.cast` above.\n\n### .members\n\nType: `members(): Iterator<TEnum>`\n\nThe `members` method returns an [iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#iterators) (that is iterable) of all the enum members.\n\n``` javascript\nconst buttons = [];\nfunction getButtonForStatus(status: Status) { ...  }\n\nfor (const status of Status.members()) {\n  buttons.push(getButtonForStatus(status));\n}\n```\n\nThe iteration order is guaranteed to be the same as the order of the members in the declaration.\n\nThe enum is not enumerable or iterable itself (e.g. a for-in/for-of loop over the enum will not iterate over its members), you have to use the `.members()` method for that purpose.\n\nYou can convert the iterable into an `Array` using: `Array.from(Status.members())`. You can make use of [`Array.from`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)‚Äôs second argument to map over the values at the same time you construct the array: e.g. `const buttonArray = Array.from(Status.members(), status => getButtonForStatus(status));`.\n\n### .getName\n\nType: `getName(value: TEnum): string`\n\nThe `getName` method maps enum values to the string name of that value‚Äôs enum member. When using `number`/`boolean`/`symbol` enums, this can be useful for debugging and for generating internal CRUD UIs. For example:\n\n``` javascript\nenum Status {\n  Active = 1,\n  Paused = 2,\n  Off = 3,\n}\nconst status: Status = ...;\n\nconsole.log(Status.getName(status));\n// Will print a string, either \"Active\", \"Paused\", or \"Off\" depending on the value.\n```\n\nRuntime cost: The same as described under `.cast` above. A single cached reverse map from enum value to enum name is used for `.cast`, `.isValid`, and `.getName`. The first call of any of those methods will create this cached map.\n\n## Exhaustively checking enums with a `switch`\n\nWhen checking an enum value in a `switch` statement, we enforce that you check against all possible enum members, and don‚Äôt include redundant cases. This helps ensure you consider all possibilities when writing code that uses enums. It especially helps with refactoring when adding or removing members, by pointing out the different places you need to update.\n\n``` javascript\nconst status: Status = ...;\n\nswitch (status) { // Good, all members checked\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n}\n```\n\nYou can use `default` to match all members not checked so far:\n\n``` javascript\nswitch (status) {\n  case Status.Active:\n    break;\n  default: // When `Status.Paused` or `Status.Off`\n    break;\n}\n```\n\nYou can check multiple enum members in one switch case:\n\n``` javascript\nswitch (status) {\n  case Status.Active:\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n}\n```\n\nYou must match against all of the members of the enum (or supply a `default` case):\n\n``` javascript\n// Error: you haven't checked 'Status.Off' in the switch\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n}\n```\n\nYou can‚Äôt repeat cases (as this would be dead code!):\n\n``` javascript\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n  case Status.Paused: // Error: you already checked for 'Status.Paused'\n    break;\n}\n```\n\nA `default` case is redundant if you‚Äôve already matched all cases:\n\n``` javascript\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n  default: // Error: you've already checked all cases, the 'default' is redundant\n    break;\n}\n// The following is OK because the `default` covers the `Status.Off` case:\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  default:\n    break;\n}\n```\n\nExcept if you are switching over an enum with [unknown members](../defining-enums#toc-flow-enums-with-unknown-members).\n\nIf you nest exhaustively checked switches inside exhaustively checked switches, and are returning from each branch, you must add a `break;` after the nested switch:\n\n``` javascript\nswitch (status) {\n  case Status.Active:\n    return 1;\n  case Status.Paused:\n    return 2;\n  case Status.Off:\n    switch (otherStatus) {\n      case Status.Active:\n        return 1;\n      case Status.Paused:\n        return 2;\n      case Status.Off:\n        return 3;\n    }\n    break;\n}\n```\n\nRemember, you can add blocks to your switch cases. They are useful if you want to use local variables:\n\n``` javascript\nswitch (status) {\n  case Status.Active: {\n    const x = f();\n    ...\n    break;\n  }\n  case Status.Paused: {\n    const x = g();\n    ...\n    break;\n  }\n  case Status.Off: {\n    const y = ...;\n    ...\n    break;\n  }\n}\n```\n\nIf you didn‚Äôt add blocks in this example, the two declarations of `const x` would conflict and result in an error.\n\nEnums are not checked exhaustively in `if` statements or other contexts other than `switch` statements.\n\n## Exhaustive checking with unknown members\n\nIf your enum has [unknown members](../defining-enums#toc-flow-enums-with-unknown-members) (specified with the `...`), e.g.\n\n``` javascript\nenum Status {\n  Active,\n  Paused,\n  Off,\n  ...\n}\n```\n\nThen a `default` is always required when switching over the enum. The `default` checks for ‚Äúunknown‚Äù members you haven‚Äôt explicitly listed.\n\n``` javascript\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off:\n    break;\n  default:\n    // Checks for members not explicitly listed\n}\n```\n\nYou can use the `require-explicit-enum-switch-cases` [Flow Lint](https://flow.org/en/linting/flowlint-comments/) to require that all known members are explicitly listed as cases. For example:\n\n``` javascript\n// flowlint-next-line require-explicit-enum-switch-cases:error\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  default:\n    break;\n}\n```\n\nWill trigger an error (without the lint there would be no error):\n\n``` javascript\nIncomplete exhaustive check: the member `Off` of enum `Status` has not been\nconsidered in check of `status`. The default case does not check for the missing\nmembers as the `require-explicit-enum-switch-cases` lint has been enabled.\n```\n\nYou can fix if by doing:\n\n``` javascript\n// flowlint-next-line require-explicit-enum-switch-cases:error\nswitch (status) {\n  case Status.Active:\n    break;\n  case Status.Paused:\n    break;\n  case Status.Off: // Added the missing `Status.Off` case\n    break;\n  default:\n    break;\n}\n```\n\nThe `require-explicit-enum-switch-cases` lint is not one to enable globally, but rather on a per-`switch` basis when you want the behavior. With normal enums, for each `switch` statement on it, you can either provide a `default` or not, and thus decide if you want to require each case explicitly listed or not. Similarly for Flow Enums with unknown members, you can also enable this lint on a per-switch basis.\n\nThe lint works for switches of regular Flow Enum types as well. It in effect bans the usage of `default` in that `switch` statement, by requiring the explicit listing of all enum members as cases.\n\n## Mapping enums to other values\n\nThere are a variety of reasons you may want to map an enum value to another value, e.g. a label, icon, element, and so on.\n\nWith previous patterns, it was common to use object literals for this purpose, however with Flow Enums we prefer functions which contain a switch, which we can exhaustively check.\n\nInstead of:\n\n``` javascript\nconst STATUS_ICON: {[Status]: string} = {\n  [Status.Active]: 'green-checkmark',\n  [Status.Paused]: 'grey-pause',\n  [Status.Off]: 'red-x',\n};\nconst icon = STATUS_ICON[status];\n```\n\nWhich doesn‚Äôt actually guarantee that we are mapping each `Status` to some value, use:\n\n``` javascript\nfunction getStatusIcon(status: Status): string {\n  switch (status) {\n    case Status.Active:\n      return 'green-checkmark';\n    case Status.Paused:\n      return 'grey-pause';\n    case Status.Off:\n      return 'red-x';\n  }\n}\nconst icon = getStatusIcon(status);\n```\n\nIn the future if you add or remove an enum member, Flow will tell you to update the switch as well so it‚Äôs always accurate.\n\nIf you actually want a dictionary which is not exhaustive, you can use a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map):\n\n``` javascript\nconst counts = new Map<Status, number>([\n  [Status.Active, 2],\n  [Status.Off, 5],\n]);\nconst activeCount: Status | void = counts.get(Status.Active);\n```\n\nFlow Enums cannot be used as keys in object literals, as [explained later on this page](#toc-distinct-object-keys).\n\n## Enums in a union\n\nIf your enum value is in a union (e.g. `?Status`), first refine to only the enum type:\n\n``` javascript\nconst status: ?Status = ...;\n\nif (status != null) {\n  (status: Status); // 'status' is refined to 'Status' at this point\n  switch (status) {\n    case Status.Active: break;\n    case Status.Paused: break;\n    case Status.Off: break;\n  }\n}\n```\n\nIf you want to refine *to* the enum value, you can use `typeof` with the representation type, for example:\n\n``` javascript\nconst val: Status | number = ...;\n\n// 'Status' is a string enum\nif (typeof val === 'string') {\n  (val: Status); // 'val' is refined to 'Status' at this point\n  switch (val) {\n    case Status.Active: break;\n    case Status.Paused: break;\n    case Status.Off: break;\n  }\n}\n```\n\n## Exporting enums\n\nAn enum is a type and a value (like a class is). To export both the type and the value, export it like a you would a value:\n\n``` javascript\nexport enum Status {}\n```\n\nOr, as the default export (note: you must always specify an enum name, `export default enum {}` is not allowed):\n\n``` javascript\nexport default enum Status {}\n```\n\nUsing CommonJS:\n\n``` javascript\nenum Status {}\nmodule.exports = Status;\n```\n\nTo export **only** its type, but not the value, you can do:\n\n``` javascript\nenum Status_ {}\nexport type Status = Status_;\n```\n\nSince `export type` introduces a new binding with that name, the enum and the exported type must have different names. Other functions within the file will still have access to the enum implementation.\n\n## Importing enums\n\nIf you have exported an enum like this:\n\n``` javascript\n// status.js\nexport default enum Status {\n  Active,\n  Paused,\n  Off,\n}\n```\n\nYou can import it as both a value and a type like this:\n\n``` javascript\nimport Status from 'status';\n\nconst x: Status /* used as type */ = Status.Active /* used as value */;\n```\n\nIf you only need to use the type, you can import it as a type:\n\n``` javascript\nimport type Status from 'status';\n\nfunction printStatus(status: Status) {\n  ...\n}\n```\n\nUsing CommonJS:\n\n``` javascript\nconst Status = require('status');\n```\n\n## Generic enums\n\nThere is currently no way to specify a generic enum type, but there have been enough requests that it is something we will look into in the future.\n\nFor some use cases of generic enums, you can currently ask users to supply functions which call the enum [methods](#toc-methods) instead (rather than passing in the enum itself), for example:\n\n``` javascript\nfunction castToEnumArray<TRepresentationType, TEnum>(\n  f: TRepresentationType => TEnum,\n  xs: Array<TRepresentationType>,\n): Array<TEnum | void> {\n  return xs.map(f);\n}\n\ncastToEnumArray((input) => Status.cast(input), [\"Active\", \"Paused\", \"Invalid\"]);\n```\n\n## When to not use enums\n\nEnums are designed to cover many use cases and exhibit certain benefits. The design makes a variety of trade-offs to make this happen, and in certain situations, these trade-offs might not be right for you. In these cases, you can continue to use existing patterns to satisfy your use cases.\n\n### Distinct object keys\n\nYou can‚Äôt use enum members as distinct object keys.\n\nThe following pattern works because the types of `LegacyStatus.Active` and `LegacyStatus.Off` are different. One has the type `'Active'` and one has the type `'Off'`.\n\n``` javascript\nconst LegacyStatus = Object.freeze({\n  Active: 'Active',\n  Paused: 'Paused',\n  Off: 'Off',\n});\nconst o = {\n  [LegacyStatus.Active]: \"hi\",\n  [LegacyStatus.Off]: 1,\n};\nconst x: string = o[LegacyStatus.Active]; // OK\nconst y: number = o[LegacyStatus.Off]; // OK\nconst z: boolean = o[LegacyStatus.Active]; // Error - as expected\n```\n\nWe can‚Äôt use the same pattern with enums. All enum members have the same type, the enum type, so Flow can‚Äôt track the relationship between keys and values.\n\nIf you wish to map from an enum value to another value, you should use a [function with an exhaustively-checked switch instead](#toc-mapping-enums-to-other-values).\n\n### Disjoint object unions\n\nA defining feature of enums is that unlike unions, each enum member does not form its own separate type. Every member has the same type, the enum type. This allows enum usage to be analyzed by Flow in a consistently fast way, however it means that in certain situations which require separate types, we can‚Äôt use enums. Consider the following union, following the [disjoint object union](https://flow.org/en/types/unions/#toc-disjoint-unions) pattern:\n\n``` javascript\ntype Action =\n  | {type: 'Upload', data: string}\n  | {type: 'Delete', id: number};\n```\n\nEach object type in the union has a single common field (`type`) which is used to distinguish which object type we are dealing with.\n\nWe can‚Äôt use enum types for this field, because for this mechanism to work, the type of that field must be different in each member of the union, but enum members all have the same type.\n\nIn the future, we might add the ability for enums to encapsulate additional data besides a key and a primitive value - this would allow us to replace disjoint object unions.\n\n### Guaranteed inlining\n\nFlow Enums are designed to allow for inlining (e.g. [member values must be literals](../defining-enums#toc-literal-member-values), [enums are frozen](../defining-enums#toc-fixed-at-declaration)), however the inlining itself needs to be part of the build system (whatever you use) rather than Flow itself.\n\nWhile enum member access (e.g. `Status.Active`) can be inlined (other than [symbol enums](../defining-enums#toc-symbol-enums) which cannot be inlined due to the nature of symbols), usage of its methods (e.g. `Status.cast(x)`) cannot be inlined.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/enums/using-enums](https://flow.org/en/docs/enums/using-enums)"
- name: Utility Types
  id: types/utilities
  summary: Flow provides a set of utility types to operate on other types, and can be useful for different scenarios
  description: "# Utility Types\n\nFlow provides a set of utility types to operate on other types, and can be useful for different scenarios.\n\nTable of contents:\n\n- [`$Keys<T>`](#toc-keys)\n- [`$Values<T>`](#toc-values)\n- [`$ReadOnly<T>`](#toc-readonly)\n- [`$Exact<T>`](#toc-exact)\n- [`$Diff<A, B>`](#toc-diff)\n- [`$Rest<A, B>`](#toc-rest)\n- [`$PropertyType<T, k>`](#toc-propertytype)\n- [`$ElementType<T, K>`](#toc-elementtype)\n- [`$NonMaybeType<T>`](#toc-nonmaybe)\n- [`$ObjMap<T, F>`](#toc-objmap)\n- [`$ObjMapi<T, F>`](#toc-objmapi)\n- [`$ObjMapConst<O, T>`](#toc-objmapconst)\n- [`$KeyMirror<O>`](#toc-keymirror)\n- [`$TupleMap<T, F>`](#toc-tuplemap)\n- [`$Call<F, T...>`](#toc-call)\n- [`Class<T>`](#toc-class)\n- [`$Shape<T>`](#toc-shape)\n- [`$Exports<T>`](#toc-exports)\n- [`$Supertype<T>`](#toc-supertype)\n- [`$Subtype<T>`](#toc-subtype)\n- [`Existential Type (*)`](#toc-existential-type)\n\n## `$Keys<T>`\n\nIn Flow you can [use union types similar to enums](../literals):\n\n``` javascript\n// @flow\ntype Suit = \"Diamonds\" | \"Clubs\" | \"Hearts\" | \"Spades\";\n\nconst clubs: Suit = 'Clubs';\nconst wrong: Suit = 'wrong'; // 'wrong' is not a Suit\n```\n\nThis is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).\n\nSuppose for example that you want to associate a value to each suit of the previous example.\n\nYou could do\n\n``` javascript\n// @flow\ntype Suit = \"Diamonds\" | \"Clubs\" | \"Hearts\" | \"Spades\";\n\nconst suitNumbers = {\n  Diamonds: 1,\n  Clubs: 2,\n  Hearts: 3,\n  Spades: 4\n};\n\nfunction printSuitNumber(suit: Suit) {\n  console.log(suitNumbers[suit]);\n}\n\nprintSuitNumber('Diamonds'); // 1\nprintSuitNumber('foo'); // 'foo' is not a Suit\n```\n\nbut this doesn‚Äôt feel very DRY, as we had to explicitly define the suit names twice.\n\nIn situations like this one, you can leverage the `$Keys<T>` operator. Let‚Äôs see another example, this time using `$Keys`:\n\n``` javascript\n// @flow\nconst countries = {\n  US: \"United States\",\n  IT: \"Italy\",\n  FR: \"France\"\n};\n\ntype Country = $Keys<typeof countries>;\n\nconst italy: Country = 'IT';\nconst nope: Country = 'nope'; // 'nope' is not a Country\n```\n\nIn the example above, the type of `Country` is equivalent to `type Country = 'US' | 'IT' | 'FR'`, but Flow was able to extract it from the keys of `countries`.\n\n## `$Values<T>`\n\n`$Values<T>` represents the union type of all the value types (not the values, but their *types*!) of the enumerable properties in an [Object Type](../objects) `T`.\n\nFor example:\n\n``` javascript\n// @flow\ntype Props = {\n  name: string,\n  age: number,\n};\n\n// The following two types are equivalent:\ntype PropValues = string | number;\ntype Prop$Values = $Values<Props>;\n\nconst name: Prop$Values = 'Jon';  // OK\nconst age: Prop$Values = 42;  // OK\nconst fn: Prop$Values = () => {};  // Error! function is not part of the union type\n```\n\n## `$ReadOnly<T>`\n\n`$ReadOnly<T>` is a type that represents the read-only version of a given [object type](../objects) `T`. A read-only object type is an object type whose keys are all [read-only](../interfaces#toc-interface-property-variance-read-only-and-write-only).\n\nThis means that the following 2 types are equivalent:\n\n``` javascript\ntype ReadOnlyObj = {\n  +key: any,  // read-only field, marked by the `+` annotation\n};\n```\n\n``` javascript\ntype ReadOnlyObj = $ReadOnly<{\n  key: any,\n}>;\n```\n\nThis is useful when you need to use a read-only version of an object type you‚Äôve already defined, without manually having to re-define and annotate each key as read-only. For example:\n\n``` javascript\n// @flow\ntype Props = {\n  name: string,\n  age: number,\n  // ...\n};\n\ntype ReadOnlyProps = $ReadOnly<Props>;\n\nfunction render(props: ReadOnlyProps) {\n  const {name, age} = props;  // OK to read\n  props.age = 42;             // Error when writing\n  // ...\n}\n```\n\nAdditionally, other utility types, such as [`$ObjMap<T>`](#toc-objmap), may strip any read/write annotations, so `$ReadOnly<T>` is a handy way to quickly make the object read-only again after operating on it:\n\n``` javascript\ntype Obj = {\n  +key: any,\n};\n\ntype MappedObj = $ReadOnly<$ObjMap<Obj, TypeFn>> // Still read-only\n```\n\n> Note: `$ReadOnly` is only for making read-only *object* types. See the Array docs for how to [type read-only arrays with `$ReadOnlyArray`](../arrays#toc-readonlyarray).\n\n## `$Exact<T>`\n\n`$Exact<{name: string}>` is a synonym for `{| name: string |}` as in the [Object documentation](../objects#toc-exact-object-types).\n\n``` javascript\n// @flow\ntype ExactUser = $Exact<{name: string}>;\ntype ExactUserShorthand = {| name: string |};\n\nconst user2 = {name: 'John Wilkes Booth'};\n// These will both be satisfied because they are equivalent\n(user2: ExactUser);\n(user2: ExactUserShorthand);\n```\n\n## `$Diff<A, B>`\n\nAs the name hints, `$Diff<A, B>` is the type representing the set difference of `A` and `B`, i.e. `A \\ B`, where `A` and `B` are both [object types](../objects). Here‚Äôs an example:\n\n``` javascript\n// @flow\ntype Props = { name: string, age: number };\ntype DefaultProps = { age: number };\ntype RequiredProps = $Diff<Props, DefaultProps>;\n\nfunction setProps(props: RequiredProps) {\n  // ...\n}\n\nsetProps({ name: 'foo' });\nsetProps({ name: 'foo', age: 42, baz: false }); // you can pass extra props too\nsetProps({ age: 42 }); // error, name is required\n```\n\nAs you may have noticed, the example is not a random one. `$Diff` is exactly what the React definition file uses to define the type of the props accepted by a React Component.\n\nNote that `$Diff<A, B>` will error if the object you are removing properties from does not have the property being removed, i.e. if `B` has a key that doesn‚Äôt exist in `A`:\n\n``` javascript\n// @flow\ntype Props = { name: string, age: number };\ntype DefaultProps = { age: number, other: string }; // Will error due to this `other` property not being in Props.\ntype RequiredProps = $Diff<Props, DefaultProps>;\n\nfunction setProps(props: RequiredProps) {\n  props.name;\n  // ...\n}\n```\n\nAs a workaround, you can specify the property not present in `A` as optional. For example:\n\n``` javascript\ntype A = $Diff<{}, {nope: number}>; // Error\ntype B = $Diff<{}, {nope: number | void}>; // OK\n```\n\n## `$Rest<A, B>`\n\n`$Rest<A, B>` is the type that represents the runtime object rest operation, e.g.: `const {foo, ...rest} = obj`, where `A` and `B` are both [object types](../objects). The resulting type from this operation will be an object type containing `A`‚Äôs *own* properties that are not *own* properties in `B`. In flow, we treat all properties on [exact object types](../objects#toc-exact-object-types) as [own](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty). In in-exact objects, a property may or may not be own.\n\nFor example:\n\n``` javascript\n// @flow\ntype Props = { name: string, age: number };\n\nconst props: Props = {name: 'Jon', age: 42};\nconst {age, ...otherProps} = props;\n(otherProps: $Rest<Props, {|age: number|}>);\notherProps.age;  // Error\n```\n\nThe main difference with [`$Diff<A, B>`](#toc-diff), is that `$Rest<A, B>` aims to represent the true runtime rest operation, which implies that exact object types are treated differently in `$Rest<A, B>`. For example, `$Rest<{|n: number|}, {}>` will result in `{|n?: number|}` because an in-exact empty object may have an `n` property, while `$Diff<{|n: number|}, {}>` will result in `{|n: number|}`.\n\n## `$PropertyType<T, k>`\n\n**WARNING:** `$PropertyType` is deprecated as of Flow version 0.155, and will be removed in a future version of Flow. Use [Indexed Access Types](../indexed-access) instead. `$PropertyType<T, 'k'>` is now `T['k']`.\n\nA `$PropertyType<T, k>` is the type at a given key `k`. As of Flow v0.36.0, `k` must be a literal string.\n\n``` javascript\n// @flow\ntype Person = {\n  name: string,\n  age: number,\n  parent: Person\n};\n\nconst newName: $PropertyType<Person, 'name'> = 'Toni Braxton';\nconst newAge: $PropertyType<Person, 'age'> = 51;\nconst newParent: $PropertyType<Person, 'parent'> = 'Evelyn Braxton';\n```\n\nThis can be especially useful for referring to the type of React props, or, even the entire `props` type itself.\n\n``` javascript\n// @flow\nimport React from 'react';\n\ntype Props = {\n  text: string,\n  onMouseOver: ({x: number, y: number}) => void\n}\n\nclass Tooltip extends React.Component<Props> {\n  props: Props;\n}\n\nconst someProps: $PropertyType<Tooltip, 'props'> = {\n  text: 'foo',\n  onMouseOver: (data: {x: number, y: number}) => undefined\n};\n\nconst otherProps: $PropertyType<Tooltip, 'props'> = {\n  text: 'foo'\n  // Missing the `onMouseOver` definition\n};\n```\n\nYou can even nest lookups:\n\n``` javascript\n// @flow\ntype PositionHandler = $PropertyType<$PropertyType<Tooltip, 'props'>, 'onMouseOver'>;\nconst handler: PositionHandler = (data: {x: number, y: number}) => undefined;\nconst handler2: PositionHandler = (data: string) => undefined; // wrong parameter types\n```\n\nYou can use this in combination with `Class<T>` to get static props:\n\n``` javascript\n// @flow\nclass BackboneModel {\n  static idAttribute: string | false;\n}\n\ntype ID = $PropertyType<Class<BackboneModel>, 'idAttribute'>;\nconst someID: ID = '1234';\nconst someBadID: ID = true;\n```\n\n## `$ElementType<T, K>`\n\n**WARNING:** `$ElementType` is deprecated as of Flow version 0.155, and will be removed in a future version of Flow. Use [Indexed Access Types](../indexed-access) instead. `$ElementType<T, K>` is now `T[K]`.\n\n`$ElementType<T, K>` is the type that represents the type of every element inside an [array](../arrays), [tuple](../tuples) or [object](../objects) type `T`, that matches the given *key* type `K`.\n\nFor example:\n\n``` javascript\n// @flow\n\n// Using objects:\ntype Obj = {\n  name: string,\n  age: number,\n}\n('Jon': $ElementType<Obj, 'name'>);\n(42: $ElementType<Obj, 'age'>);\n(true: $ElementType<Obj, 'name'>); // Nope, `name` is not a boolean\n(true: $ElementType<Obj, 'other'>); // Nope, property `other` is not in Obj\n\n// Using tuples:\ntype Tuple = [boolean, string];\n(true: $ElementType<Tuple, 0>);\n('foo': $ElementType<Tuple, 1>);\n('bar': $ElementType<Tuple, 2>); // Nope, can't access position 2\n```\n\nIn the above case, we‚Äôre using literal values as `K`, similarly to [`$PropertyType<T, k>`](#toc-propertytype). However, when using `$ElementType<T, K>`, `K` is allowed to be any type, as long as that type exists on the keys of `T`. For example:\n\n``` javascript\n// @flow\n\n// Using objects\ntype Obj = { [key: string]: number };\n(42: $ElementType<Obj, string>);\n(42: $ElementType<Obj, boolean>); // Nope, object keys aren't booleans\n(true: $ElementType<Obj, string>); // Nope, elements are numbers\n\n\n// Using arrays, we don't statically know the size of the array, so you can just use the `number` type as the key:\ntype Arr = Array<boolean>;\n(true: $ElementType<Arr, number>);\n(true: $ElementType<Arr, boolean>); // Nope, array indices aren't booleans\n('foo': $ElementType<Arr, number>); // Nope, elements are booleans\n```\n\nYou can also nest calls to `$ElementType<T, K>`, which is useful when you need to access the types inside nested structures:\n\n``` javascript\n// @flow\ntype NumberObj = {\n  nums: Array<number>,\n};\n\n(42: $ElementType<$ElementType<NumberObj, 'nums'>, number>);\n```\n\nAdditionally, one of the things that also makes `$ElementType<T, K>` more powerful than [`$PropertyType<T, k>`](#toc-propertytype) is that you can use it with generics. For example:\n\n``` javascript\n// @flow\nfunction getProp<O: {+[string]: mixed}, P: $Keys<O>>(o: O, p: P): $ElementType<O, P> {\n  return o[p];\n}\n\n(getProp({a: 42}, 'a'): number); // OK\n(getProp({a: 42}, 'a'): string); // Error: number is not a string\ngetProp({a: 42}, 'b'); // Error: `b` does not exist\n```\n\n## `$NonMaybeType<T>`\n\n`$NonMaybeType<T>` converts a type `T` to a non-maybe type. In other words, the values of `$NonMaybeType<T>` are the values of `T` except for `null` and `undefined`.\n\n``` javascript\n// @flow\ntype MaybeName = ?string;\ntype Name = $NonMaybeType<MaybeName>;\n\n('Gabriel': MaybeName); // Ok\n(null: MaybeName); // Ok\n('Gabriel': Name); // Ok\n(null: Name); // Error! null can't be annotated as Name because Name is not a maybe type\n```\n\n## `$ObjMap<T, F>`\n\n`ObjMap<T, F>` takes an [object type](../objects) `T`, and a [function type](../functions) `F`, and returns the object type obtained by mapping the type of each value in the object with the provided function type `F`. In other words, `$ObjMap` will [call](#toc-call) (at the type level) the given function type `F` for every property value type in `T`, and return the resulting object type from those calls.\n\nLet‚Äôs see an example. Suppose you have a function called `run` that takes an object of thunks (functions in the form `() => A`) as input:\n\n``` javascript\n// @flow\nfunction run<O: {[key: string]: Function}>(o: O) {\n  return Object.keys(o).reduce((acc, k) => Object.assign(acc, { [k]: o[k]() }), {});\n}\n```\n\nThe function‚Äôs purpose is to run all the thunks and return an object made of values. What‚Äôs the return type of this function?\n\nThe keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we‚Äôre essentially mapping over the object to produce new values for the keys. How to express this at a type level?\n\nThis is where `ObjMap<T, F>` comes in handy.\n\n``` javascript\n// @flow\n\n// let's write a function type that takes a `() => V` and returns a `V` (its return type)\ntype ExtractReturnType = <V>(() => V) => V;\n\ndeclare function run<O: {[key: string]: Function}>(o: O): $ObjMap<O, ExtractReturnType>;\n\nconst o = {\n  a: () => true,\n  b: () => 'foo'\n};\n\n(run(o).a: boolean); // Ok\n(run(o).b: string);  // Ok\n// $ExpectError\n(run(o).b: boolean); // Nope, b is a string\n// $ExpectError\nrun(o).c;            // Nope, c was not in the original object\n```\n\nThis is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird‚Äôs [`Promise.props`](http://bluebirdjs.com/docs/api/promise.props.html) function, which is like `Promise.all` but takes an object as input.\n\nHere‚Äôs a possible declaration of this function, which is very similar to our first example:\n\n``` javascript\n// @flow\ndeclare function props<A, O: { [key: string]: A }>(promises: O): Promise<$ObjMap<O, typeof $await>>;\n```\n\nAnd use:\n\n``` javascript\n// @flow\nconst promises = { a: Promise.resolve(42) };\nprops(promises).then(o => {\n  (o.a: 42); // Ok\n  // $ExpectError\n  (o.a: 43); // Error, flow knows it's 42\n});\n```\n\n## `$ObjMapi<T, F>`\n\n`ObjMapi<T, F>` is similar to [`ObjMap<T, F>`](#toc-objmap). The difference is that function type `F` will be [called](#toc-call) with both the key and value types of the elements of the object type `T`, instead of just the value types. For example:\n\n``` javascript\n// @flow\nconst o = {\n  a: () => true,\n  b: () => 'foo'\n};\n\ntype ExtractReturnObjectType = <K, V>(K, () => V) => { k: K, v: V };\n\ndeclare function run<O: {...}>(o: O): $ObjMapi<O, ExtractReturnObjectType>;\n\n(run(o).a: { k: 'a', v: boolean }); // Ok\n(run(o).b: { k: 'b', v: string });  // Ok\n// $ExpectError\n(run(o).a: { k: 'b', v: boolean }); // Nope, a.k is \"a\"\n// $ExpectError\n(run(o).b: { k: 'b', v: number });  // Nope, b.v is a string\n// $ExpectError\nrun(o).c;                           // Nope, c was not in the original object\n```\n\n## `$ObjMapConst<O, T>`\n\n`$ObjMapConst<Obj, T>` is a special case of `$ObjMap<Obj, F>`, when `F` is a constant function type, e.g. `() => T`. Instead of writing `$ObjMap<Obj, () => T>`, you can write `$ObjMapConst<Obj, T>`. For example:\n\n``` javascript\n// @flow\nconst obj = {\n  a: true,\n  b: 'foo'\n};\n\ndeclare function run<O: {...}>(o: O): $ObjMapConst<O, number>;\n\n// newObj is of type {a: number, b: number}\nconst newObj = run(obj);\n\n(newObj.a: number); // Ok\n// $ExpectedError\n(newObj.b: string); // Error property b is a number\n```\n\nTip: Prefer using `$ObjMapConst` instead of `$ObjMap` (if possible) to fix certain kinds of `[invalid-exported-annotation]` errors.\n\n## `$KeyMirror<O>`\n\n`$KeyMirror<Obj>` is a special case of `$ObjMapi<Obj, F>`, when `F` is the identity function type, ie. `<K>(K) => K`. In other words, it maps each property of an object to the type of the property key. Instead of writing `$ObjMapi<Obj, <K>(K) => K>`, you can write `$KeyMirror<Obj>`. For example:\n\n``` javascript\n// @flow\nconst obj = {\n  a: true,\n  b: 'foo'\n};\n\ndeclare function run<O: {...}>(o: O): $KeyMirror<O>;\n\n// newObj is of type {a: 'a', b: 'b'}\nconst newObj = run(obj);\n\n(newObj.a: 'a'); // Ok\n// $ExpectedError\n(newObj.b: 'a'); // Error string 'b' is incompatible with 'a'\n```\n\nTip: Prefer using `$KeyMirror` instead of `$ObjMapi` (if possible) to fix certain kinds of `[invalid-exported-annotation]` errors.\n\n## `$TupleMap<T, F>`\n\n`$TupleMap<T, F>` takes an iterable type `T` (e.g.: [`Tuple`](../tuples) or [`Array`](../arrays)), and a [function type](../functions) `F`, and returns the iterable type obtained by mapping the type of each value in the iterable with the provided function type `F`. This is analogous to the Javascript function `map`.\n\nFollowing our example from [`$ObjMap<T>`](#toc-objmap), let‚Äôs assume that `run` takes an array of functions, instead of an object, and maps over them returning an array of the function call results. We could annotate its return type like this:\n\n``` javascript\n// @flow\n\n// Function type that takes a `() => V` and returns a `V` (its return type)\ntype ExtractReturnType = <V>(() => V) => V\n\nfunction run<A, I: Array<() => A>>(iter: I): $TupleMap<I, ExtractReturnType> {\n  return iter.map(fn => fn());\n}\n\nconst arr = [() => 'foo', () => 'bar'];\n(run(arr)[0]: string); // OK\n(run(arr)[1]: string); // OK\n(run(arr)[1]: boolean); // Error\n```\n\n## `$Call<F, T...>`\n\n`$Call<F, T...>` is a type that represents the result of calling the given [function type](../functions) `F` with 0 or more arguments `T...`. This is analogous to calling a function at runtime (or more specifically, it‚Äôs analogous to calling [`Function.prototype.call`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)), but at the type level; this means that function type calls happens statically, i.e. not at runtime.\n\nLet‚Äôs see a couple of examples:\n\n``` javascript\n// @flow\n\n// Takes an object type, returns the type of its `prop` key\ntype ExtractPropType = <T>({prop: T}) => T;\ntype Obj = {prop: number};\ntype PropType = $Call<ExtractPropType, Obj>;  // Call `ExtractPropType` with `Obj` as an argument\ntype Nope = $Call<ExtractPropType, {nope: number}>;  // Error: argument doesn't match `Obj`.\n\n(5: PropType); // OK\n(true: PropType);  // Error: PropType is a number\n(5: Nope);  // Error\n```\n\n``` javascript\n// @flow\n\n// Takes a function type, and returns its return type\n// This is useful if you want to get the return type of some function without actually calling it at runtime.\ntype ExtractReturnType = <R>(() => R) => R;\ntype Fn = () => number;\ntype ReturnType = $Call<ExtractReturnType, Fn> // Call `ExtractReturnType` with `Fn` as an argument\n\n(5: ReturnType);  // OK\n(true: ReturnType);  // Error: ReturnType is a number\n```\n\n`$Call` can be very powerful because it allows you to make calls in type-land that you would otherwise have to do at runtime. The type-land calls happen statically and will be erased at runtime.\n\nLet‚Äôs look at a couple of more advanced examples:\n\n``` javascript\n// @flow\n\n// Extracting deeply nested types:\ntype NestedObj = {|\n  +status: ?number,\n  +data: ?$ReadOnlyArray<{|\n    +foo: ?{|\n       +bar: number,\n    |},\n  |}>,\n|};\n\n// If you wanted to extract the type for `bar`, you could use $Call:\ntype BarType = $Call<\n  <T>({\n    +data: ?$ReadOnlyArray<{\n      +foo: ?{\n        +bar: ?T\n      },\n    }>,\n  }) => T,\n  NestedObj,\n>;\n\n(5: BarType);\n(true: BarType);  // Error: `bar` is not a boolean\n```\n\n``` javascript\n// @flow\n\n// Getting return types:\nfunction getFirstValue<V>(map: Map<string, V>): ?V {\n  for (const [key, value] of map.entries()) {\n    return value;\n  }\n  return null;\n}\n\n// Using $Call, we can get the actual return type of the function above, without calling it at runtime:\ntype Value = $Call<typeof getFirstValue, Map<string, number>>;\n\n(5: Value);\n(true: Value);  // Error: Value is a `number`\n\n\n// We could generalize it further:\ntype GetMapValue<M> =\n  $Call<typeof getFirstValue, M>;\n\n(5: GetMapValue<Map<string, number>>);\n(true: GetMapValue<Map<string, boolean>>);\n(true: GetMapValue<Map<string, number>>);  // Error: value is a `number`\n```\n\n## `Class<T>`\n\nGiven a type `T` representing instances of a class `C`, the type `Class<T>` is the type of the class `C`. For example:\n\n``` javascript\n// @flow\nclass Store {}\nclass ExtendedStore extends Store {}\nclass Model {}\n\nfunction makeStore(storeClass: Class<Store>) {\n  return new storeClass();\n}\n\n(makeStore(Store): Store);\n(makeStore(ExtendedStore): Store);\n(makeStore(Model): Model); // error\n(makeStore(ExtendedStore): Model); // Flow infers the return type\n```\n\nFor classes that take type parameters, you must also provide the parameter. For example:\n\n``` javascript\n// @flow\nclass ParamStore<T> {\n  constructor(data: T) {}\n}\n\nfunction makeParamStore<T>(storeClass: Class<ParamStore<T>>, data: T): ParamStore<T> {\n  return new storeClass(data);\n}\n(makeParamStore(ParamStore, 1): ParamStore<number>);\n(makeParamStore(ParamStore, 1): ParamStore<boolean>); // failed because of the second parameter\n```\n\n## `$Shape<T>`\n\nA variable of type `$Shape<T>`, where `T` is some object type, can be assigned objects `o` that contain a subset of the properties included in `T`. For each property `p: S` of `T`, the type of a potential binding of `p` in `o` must be compatible with `S`.\n\nFor example\n\n``` javascript\n// @flow\ntype Person = {\n  age: number,\n  name: string,\n}\ntype PersonDetails = $Shape<Person>;\n\nconst person1: Person = {age: 28};  // Error: missing `name`\nconst person2: Person = {name: 'a'};  // Error: missing `age`\nconst person3: PersonDetails = {age: 28};  // OK\nconst person4: PersonDetails = {name: 'a'};  // OK\nconst person5: PersonDetails = {age: 28, name: 'a'};  // OK\nconst person6: PersonDetails = {age: '28'};  // Error: string is incompatible with number\n```\n\n> Note: `$Shape<T>` is **not** equivalent to `T` with all its fields marked as optional. In particular, Flow unsoundly allows `$Shape<T>` to be used as a `T` in several contexts. For example in\n>\n> ``` plaintext\n> const personShape: PersonDetails = {age: 28};\n> (personShape: Person);\n> ```\n>\n> Flow will unsoundly allow this last cast to succeed. If this behavior is not wanted, then this utility type should be avoided.\n\n## `$Exports<T>`\n\nThe following are functionally equivalent\n\n``` javascript\nimport typeof * as T from 'my-module';\n```\n\n``` javascript\ntype T = $Exports<'my-module'>;\n```\n\nThe advantage of the `$Exports` syntax is that you can `export` the type on the same line\n\n``` javascript\nexport type T = $Exports<'my-module'>;\n```\n\nwhere as you would otherwise need to export an alias in the `import typeof` case\n\n``` javascript\nimport typeof * as T from 'my-module';\nexport type MyModuleType = T;\n```\n\n## `$Supertype<T>`\n\nThis utility has been deprecated and should be avoided. See [here](https://flow.org/en/linting/rule-reference/#toc-deprecated-utility) for details.\n\n## `$Subtype<T>`\n\nThis utility has been deprecated and should be avoided. See [here](https://flow.org/en/linting/rule-reference/#toc-deprecated-utility) for details.\n\n## Existential Type (`*`)\n\nThis utility has been deprecated and should be avoided. See [here](https://flow.org/en/linting/rule-reference/#toc-deprecated-type) for details.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/utilities](https://flow.org/en/docs/types/utilities)"
- name: Variable Types
  id: types/variables
  summary: When you are declaring a new variable, you may optionally declare its type
  description: "# Variable Types\n\nWhen you are declaring a new variable, you may optionally declare its type.\n\nJavaScript has three ways of declaring local variables:\n\n- `var` - declares a variable, optionally assigning a value. ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var))\n- `let` - declares a block-scoped variable, optionally assigning a value. ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let))\n- `const` - declares a block-scoped variable, assigning a value that cannot be re-assigned. ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const))\n\nIn Flow these fall into two groups:\n\n- `let` and `var` - variables that **can** be reassigned.\n- `const` - variables that **cannot** be reassigned.\n\n``` javascript\nvar varVariable = 1;\nlet letVariable = 1;\nconst constVariable = 1;\n\nvarVariable = 2;   // Works!\nletVariable = 2;   // Works!\n// $ExpectError\nconstVariable = 2; // Error!\n```\n\n## `const`\n\nSince a `const` variable cannot be re-assigned at a later time it is fairly simple.\n\nFlow can either infer the type from the value you are assigning to it or you can provide it with a type.\n\n``` javascript\n// @flow\nconst foo /* : number */ = 1;\nconst bar: number = 2;\n```\n\n## `var` and `let`\n\nSince `var` and `let` can be re-assigned, there‚Äôs a few more rules you‚Äôll need to know about.\n\nSimilar to `const`, Flow can either infer the type from the value you are assigning to it or you can provide it with a type:\n\n``` javascript\n// @flow\nvar fooVar /* : number */ = 1;\nlet fooLet /* : number */ = 1;\nvar barVar: number = 2;\nlet barLet: number = 2;\n```\n\nWhen you provide a type, you will be able to re-assign the value, but it must always be of a compatible type.\n\n``` javascript\n// @flow\nlet foo: number = 1;\nfoo = 2;   // Works!\n// $ExpectError\nfoo = \"3\"; // Error!\n```\n\nWhen you do not provide a type, the inferred type will do one of two things if you re-assign it.\n\n## Reassigning variables\n\nBy default when you re-assign a variable, Flow will give it the type of all possible assignments.\n\n``` javascript\nlet foo = 42;\n\nif (Math.random()) foo = true;\nif (Math.random()) foo = \"hello\";\n\nlet isOneOf: number | boolean | string = foo; // Works!\n```\n\nSometimes Flow is able to figure out (with certainty) the type of a variable after re-assignment. In that case, Flow will give it the known type.\n\n``` javascript\n// @flow\nlet foo = 42;\nlet isNumber: number = foo; // Works!\n\nfoo = true;\nlet isBoolean: boolean = foo; // Works!\n\nfoo = \"hello\";\nlet isString: string = foo; // Works!\n```\n\nIf statements, functions, and other conditionally run code can all prevent Flow from being able to figure out precisely what a type will be.\n\n``` javascript\n// @flow\nlet foo = 42;\n\nfunction mutate() {\n  foo = true;\n  foo = \"hello\";\n}\n\nmutate();\n\n// $ExpectError\nlet isString: string = foo; // Error!\n```\n\nAs Flow gets smarter and smarter, there should be fewer instances of these scenarios.\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/types/variables](https://flow.org/en/docs/types/variables)"
- name: Vim
  id: editors/vim
  summary: Flow‚Äôs editor integration is primarily via the Language Server Protocol
  description: "# Vim\n\nFlow‚Äôs editor integration is primarily via the [Language Server Protocol](https://microsoft.github.io/language-server-protocol/). There are [many vim LSP clients](https://microsoft.github.io/language-server-protocol/implementors/tools/) to choose from, such as [ALE](#toc-ale).\n\n## ALE\n\nThe Asynchronous Lint Engine (ALE) plugin for Vim 8+ and NeoVim, [vim-ale](https://github.com/w0rp/ale), is a generalized linting engine with support for Flow and many other tools.\n\n### Installation\n\nFollow the [instructions](https://github.com/w0rp/ale#3-installation) in the ALE README.\n\nConfigure ALE to use the `flow-language-server` linter for JavaScript files:\n\n``` vim\n\" In ~/.vim/ftplugin/javascript.vim, or somewhere similar.\n\n\" Enables only Flow for JavaScript. See :ALEInfo for a list of other available\n\" linters. NOTE: the `flow` linter uses an old API; prefer `flow-language-server`.\nlet b:ale_linters = ['flow-language-server']\n\n\" Or in ~/.vim/vimrc:\nlet g:ale_linters = {\n\\   'javascript': ['flow-language-server'],\n\\}\n```\n\n## coc.nvim-neovim\n\n[Coc](https://github.com/neoclide/coc.nvim) is an intellisense engine for vim8 & neovim.\n\n### Setup\n\n``` vim\nset nocompatible\nfiletype off\n\n\" install coc.nvim using Plug or preffered plugin manager\ncall plug#begin('~/.vim/plugged')\nPlug 'neoclide/coc.nvim', {'branch': 'release'}\ncall plug#end()\n\nfiletype plugin indent on\n\n\" ======= coc settings\nset updatetime=300\nset shortmess+=c\n\n\" Use leader T to show documentation in preview window\nnnoremap <leader>t :call <SID>show_documentation()<CR>\n\n\nfunction! s:show_documentation()\n  if (index(['vim','help'], &filetype) >= 0)\n    execute 'h '.expand('&lt;cword&gt;')\n  else\n    call CocAction('doHover')\n  endif\nendfunction\n\n\" instead of having ~/.vim/coc-settings.json\nlet s:LSP_CONFIG = {\n\\  'flow': {\n\\    'command': exepath('flow'),\n\\    'args': ['lsp'],\n\\    'filetypes': ['javascript', 'javascriptreact'],\n\\    'initializationOptions': {},\n\\    'requireRootPattern': 1,\n\\    'settings': {},\n\\    'rootPatterns': ['.flowconfig']\n\\  }\n\\}\n\nlet s:languageservers = {}\nfor [lsp, config] in items(s:LSP_CONFIG)\n  let s:not_empty_cmd = !empty(get(config, 'command'))\n  if s:not_empty_cmd | let s:languageservers[lsp] = config | endif\nendfor\n\nif !empty(s:languageservers)\n  call coc#config('languageserver', s:languageservers)\n  endif\n```\n\n## LanguageClient-neovim\n\nAnother way to add support for Flow in Vim is to use [LanguageClient-neovim](https://github.com/autozimu/LanguageClient-neovim).\n\n- Suports vim 8 and neovim\n- Adds completions to omnifunc\n- Checks JavaScript files for type errors on save\n- Look up types under cursor\n\n### Requirements\n\n- Requires Flow to be installed and available on your path.\n- Requires projects containing JavaScript files to be initialised with flow init.\n- Requires JavaScript files to be marked with /\\* @flow \\*/ at the top.\n\n### Pathogen\n\n``` sh\ncd ~/.vim/bundle\ngit clone git://github.com/autozimu/LanguageClient-neovim.git\n```\n\n### NeoBundle\n\nAdd this to your ~/.vimrc\n\n``` vim\nNeoBundleLazy 'autozimu/LanguageClient-neovim', {\n    \\ 'autoload': {\n    \\     'filetypes': 'javascript'\n    \\ }}\n```\n\nWith Flow build step, using flow-bin\n\n``` vim\nNeoBundleLazy 'autozimu/LanguageClient-neovim', {\n    \\ 'autoload': {\n    \\     'filetypes': 'javascript'\n    \\ },\n    \\ 'build': {\n    \\     'mac': 'npm install -g flow-bin',\n    \\     'unix': 'npm install -g flow-bin'\n    \\ }}\n```\n\n### VimPlug\n\n``` vim\nPlug 'autozimu/LanguageClient-neovim', {\n    \\ 'branch': 'next',\n    \\ 'do': 'bash install.sh && npm install -g flow-bin',\n    \\ }\n```\n\n### Setup\n\n``` vim\nlet g:LanguageClient_rootMarkers = {\n\\   'javascript': ['.flowconfig', 'package.json']\n\\ }\nlet g:LanguageClient_serverCommands={\n\\   'javascript': ['flow', 'lsp'],\n\\   'javascript.jsx': ['flow', 'lsp']\n\\}\n\n\" check the type under cursor w/ leader T\nnnoremap <leader>t :call LanguageClient_textDocument_hover()<CR>\nnnoremap <leader>y :call LanguageClient_textDocument_definition()<CR>\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors/vim](https://flow.org/en/docs/editors/vim)"
- name: Visual Studio Code
  id: editors/vscode
  summary: Support for Flow in Visual Studio Code is provided by the Flow Language Support extension
  description: "# Visual Studio Code\n\nSupport for Flow in [Visual Studio Code](https://code.visualstudio.com/) is provided by the [Flow Language Support](https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode) extension. It provides all the functionality you would expect:\n\n- IntelliSense (Autocomplete)\n- Go to Definition / Peek Definition\n- Diagnostics (Errors, Warnings)\n- Hover type information\n- Toggleable code coverage reports\n\n## Installation\n\nSearch for ‚ÄúFlow Language Support‚Äù in the VS Code extensions panel or install through the [Marketplace](https://marketplace.visualstudio.com/items?itemName=flowtype.flow-for-vscode).\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors/vscode](https://flow.org/en/docs/editors/vscode)"
- name: WebStorm
  id: editors/webstorm
  summary: ¬© 2013‚Äìpresent Facebook Inc
  description: "# WebStorm\n\nWebstorm installation instructions can be found here:\n\n- [WebStorm 2016.3](https://www.jetbrains.com/help/webstorm/2016.3/using-the-flow-type-checker.html)\n- [WebStorm 2017.1](https://www.jetbrains.com/help/webstorm/2017.1/flow-type-checker.html)\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/editors/webstorm](https://flow.org/en/docs/editors/webstorm)"
- name: Width Subtyping
  id: lang/width-subtyping
  summary: It‚Äôs safe to use an object with ‚Äúextra‚Äù properties in a position that is annotated with a specific set of properties
  description: "# Width Subtyping\n\nIt‚Äôs safe to use an object with ‚Äúextra‚Äù properties in a position that is annotated with a specific set of properties.\n\n``` javascript\n// @flow\nfunction method(obj: { foo: string }) {\n  // ...\n}\n\nmethod({\n  foo: \"test\", // Works!\n  bar: 42      // Works!\n});\n```\n\nWithin `method`, we know that `obj` has at least a property `foo` and the property access expression `obj.foo` will have type `string`.\n\nThis is a kind of subtyping commonly referred to as ‚Äúwidth subtyping‚Äù because a type that is ‚Äúwider‚Äù (i.e., has more properties) is a subtype of a narrower type.\n\nSo in the following example, `obj2` is a *subtype* of `obj1`.\n\n``` javascript\nlet obj1 = { foo: 'test' };\nlet obj2 = { foo: 'test', bar: 42 };\n```\n\nHowever, it‚Äôs often useful to know that a property is definitely absent.\n\n``` javascript\n// @flow\nfunction method(obj: { foo: string } | { bar: number }) {\n  if (obj.foo) {\n    (obj.foo: string); // Error!\n  }\n}\n```\n\nThe above code has a type error because Flow would also allow the call expression `method({ foo: 1, bar: 2 })`, because `{ foo: number, bar: number }` is a subtype of `{ bar: number }`, one of the members of the parameter‚Äôs union type.\n\nFor cases like this where it‚Äôs useful to assert the absence of a property, Flow provides a special syntax for [‚Äúexact‚Äù object types](https://flow.org/en/types/objects/#toc-exact-object-types).\n\n``` javascript\n// @flow\nfunction method(obj: {| foo: string |} | {| bar: number |}) {\n  if (obj.foo) {\n    (obj.foo: string); // Works!\n  }\n}\n```\n\n[Exact object types](https://flow.org/en/types/objects/#toc-exact-object-types) disable width subtyping, and do not allow additional properties to exist.\n\nUsing exact object types lets Flow know that no extra properties will exist at runtime, which allows [refinements](../refinements) to get more specific.\n\n``` javascript\n// @flow\nfunction method(obj: {| foo: string |} | {| bar: number |}) {\n  if (obj.foo) {\n    (obj.foo: string); // Works!\n  }\n}\n```\n\n¬© 2013‚Äìpresent Facebook Inc.  \nLicensed under the MIT License.  \n[https://flow.org/en/docs/lang/width-subtyping](https://flow.org/en/docs/lang/width-subtyping)"
