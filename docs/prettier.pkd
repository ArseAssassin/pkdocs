---
name: Prettier
slug: prettier
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © James Long and contributors
  https://prettier.io/docs/en/
homepage: https://prettier.io/

---
- name: --cache
  id: cli#--cache
  summary: If this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed
  belongs_to: CLI
  description: |-
    ## `--cache`

    If this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed.

    - Prettier version
    - Options
    - Node.js version
    - (if `--cache-strategy` is `metadata`) file metadata, such as timestamps
    - (if `--cache-strategy` is `content`) content of the file

    ``` jsx
    prettier . --write --cache
    ```

    Running Prettier without `--cache` will delete the cache.

    Also, since the cache file is stored in `./node_modules/.cache/prettier/.prettier-cache`, so you can use `rm ./node_modules/.cache/prettier/.prettier-cache` to remove it manually.

    > Plugins version and implementation are not used as cache keys. We recommend that you delete the cache when updating plugins.
- name: --cache-location
  id: cli#--cache-location
  summary: Path to the cache file location used by --cache flag
  belongs_to: CLI
  description: |-
    ## `--cache-location`

    Path to the cache file location used by `--cache` flag. If you don't explicit `--cache-location`, Prettier saves cache file at `./node_modules/.cache/prettier/.prettier-cache`.

    If a file path is passed, that file is used as the cache file.

    ``` jsx
    prettier . --write --cache --cache-location=path/to/cache-file
    ```
- name: --cache-strategy
  id: cli#--cache-strategy
  summary: Strategy for the cache to use for detecting changed files
  belongs_to: CLI
  description: "## `--cache-strategy`\n\nStrategy for the cache to use for detecting changed files. Can be either `metadata` or `content`.\n\nIn general, `metadata` is faster. However, `content` is useful for updating the timestamp without changing the file content. This can happen, for example, during git operations such as `git clone`, because it does not track file modification times.\n\nIf no strategy is specified, `content` will be used.\n\n``` jsx\nprettier . --write --cache --cache-strategy metadata\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/cli](https://prettier.io/docs/en/cli)"
- name: --check
  id: cli#--check
  summary: When you want to check if your files are formatted, you can run Prettier with the --check flag (or -c)
  belongs_to: CLI
  description: |-
    ## `--check`

    When you want to check if your files are formatted, you can run Prettier with the `--check` flag (or `-c`). This will output a human-friendly message and a list of unformatted files, if any.

    ``` jsx
    prettier . --check
    ```

    Console output if all files are formatted:

    ``` jsx
    Checking formatting...
    All matched files use Prettier code style!
    ```

    Console output if some of the files require re-formatting:

    ``` jsx
    Checking formatting...
    [warn] src/fileA.js
    [warn] src/fileB.js
    [warn] Code style issues found in 2 files. Run Prettier with --write to fix.
    ```

    The command will return exit code `1` in the second case, which is helpful inside the CI pipelines. Human-friendly status messages help project contributors react on possible problems. To minimise the number of times `prettier --check` finds unformatted files, you may be interested in configuring a [pre-commit hook](precommit) in your repo. Applying this practice will minimise the number of times the CI fails because of code formatting problems.

    If you need to pipe the list of unformatted files to another command, you can use [`--list-different`](cli#--list-different) flag instead of `--check`.

    ### Exit codes

    | Code | Information                         |
    |------|-------------------------------------|
    | `0`  | Everything formatted properly       |
    | `1`  | Something wasn’t formatted properly |
    | `2`  | Something’s wrong with Prettier     |
- name: --config-precedence
  id: cli#--config-precedence
  summary: Defines how config file should be evaluated in combination of CLI options
  belongs_to: CLI
  description: |-
    ## `--config-precedence`

    Defines how config file should be evaluated in combination of CLI options.

    **cli-override (default)**

    CLI options take precedence over config file

    **file-override**

    Config file take precedence over CLI options

    **prefer-file**

    If a config file is found will evaluate it and ignore other CLI options. If no config file is found, CLI options will evaluate as normal.

    This option adds support to editor integrations where users define their default configuration but want to respect project specific configuration.
- name: --debug-check
  id: cli#--debug-check
  summary: If you're worried that Prettier will change the correctness of your code, add --debug-check to the command
  belongs_to: CLI
  description: |-
    ## `--debug-check`

    If you're worried that Prettier will change the correctness of your code, add `--debug-check` to the command. This will cause Prettier to print an error message if it detects that code correctness might have changed. Note that `--write` cannot be used with `--debug-check`.
- name: --find-config-path and --config
  id: cli#--find-config-path-and---config
  summary: If you are repeatedly formatting individual files with prettier, you will incur a small performance cost when Prettier attempts to look up a configuration file
  belongs_to: CLI
  description: |-
    ## `--find-config-path` and `--config`

    If you are repeatedly formatting individual files with `prettier`, you will incur a small performance cost when Prettier attempts to look up a [configuration file](configuration). In order to skip this, you may ask Prettier to find the config file once, and re-use it later on.

    ``` jsx
    $ prettier --find-config-path path/to/file.js
    path/to/.prettierrc
    ```

    This will provide you with a path to the configuration file, which you can pass to `--config`:

    ``` jsx
    prettier path/to/file.js --write --config path/to/.prettierrc
    ```

    You can also use `--config` if your configuration file lives somewhere where Prettier cannot find it, such as a `config/` directory.

    If you don’t have a configuration file, or want to ignore it if it does exist, you can pass `--no-config` instead.
- name: --ignore-path
  id: cli#--ignore-path
  summary: Path to a file containing patterns that describe files to ignore
  belongs_to: CLI
  description: "## `--ignore-path`\n\nPath to a file containing patterns that describe files to ignore. By default, Prettier looks for `./.gitignore` and `./.prettierignore`.  \nMultiple values are accepted."
- name: --ignore-unknown
  id: cli#--ignore-unknown
  summary: With --ignore-unknown (or -u), prettier will ignore unknown files matched by patterns
  belongs_to: CLI
  description: |-
    ## `--ignore-unknown`

    With `--ignore-unknown` (or `-u`), prettier will ignore unknown files matched by patterns.

    ``` jsx
    prettier "**/*" --write --ignore-unknown
    ```
- name: --list-different
  id: cli#--list-different
  summary: Another useful flag is --list-different (or -l) which prints the filenames of files that are different from Prettier formatting
  belongs_to: CLI
  description: |-
    ## `--list-different`

    Another useful flag is `--list-different` (or `-l`) which prints the filenames of files that are different from Prettier formatting. If there are differences the script errors out, which is useful in a CI scenario.

    ``` jsx
    prettier . --single-quote --list-different
    ```

    You can also use [`--check`](cli#--check) flag, which works the same way as `--list-different`, but also prints a human-friendly summary message to stdout.
- name: --log-level
  id: cli#--log-level
  summary: Change the level of logging for the CLI
  belongs_to: CLI
  description: |-
    ## `--log-level`

    Change the level of logging for the CLI. Valid options are:

    - `error`
    - `warn`
    - `log` (default)
    - `debug`
    - `silent`
- name: --no-config
  id: cli#--no-config
  summary: Do not look for a configuration file
  belongs_to: CLI
  description: |-
    ## `--no-config`

    Do not look for a configuration file. The default settings will be used.
- name: --no-editorconfig
  id: cli#--no-editorconfig
  summary: Don’t take .editorconfig into account when parsing configuration
  belongs_to: CLI
  description: |-
    ## `--no-editorconfig`

    Don’t take `.editorconfig` into account when parsing configuration. See the [`prettier.resolveConfig` docs](api) for details.
- name: --no-error-on-unmatched-pattern
  id: cli#--no-error-on-unmatched-pattern
  summary: Prevent errors when pattern is unmatched
  belongs_to: CLI
  description: |-
    ## `--no-error-on-unmatched-pattern`

    Prevent errors when pattern is unmatched.
- name: --stdin-filepath
  id: cli#--stdin-filepath
  summary: A path to the file that the Prettier CLI will treat like stdin
  belongs_to: CLI
  description: |-
    ## `--stdin-filepath`

    A path to the file that the Prettier CLI will treat like stdin. For example:

    *abc.css*

    ``` jsx
    .name{display: none;
    }
    ```

    *shell*

    ``` jsx
    $ cat abc.css | prettier --stdin-filepath abc.css
    .name {
      display: none;
    }
    ```
- name: --with-node-modules
  id: cli#--with-node-modules
  summary: Prettier CLI will ignore files located in node_modules directory
  belongs_to: CLI
  description: |-
    ## `--with-node-modules`

    Prettier CLI will ignore files located in `node_modules` directory. To opt out from this behavior, use `--with-node-modules` flag.
- name: --write
  id: cli#--write
  summary: This rewrites all processed files in place
  belongs_to: CLI
  description: |-
    ## `--write`

    This rewrites all processed files in place. This is comparable to the `eslint --fix` workflow. You can also use `-w` alias.
- name: '[Deprecated] JSX Brackets'
  id: options#deprecated-jsx-brackets
  summary: Put the > of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements)
  belongs_to: Options
  description: "## \\[Deprecated\\] JSX Brackets\n\n*This option has been deprecated in v2.4.0, use --bracket-same-line instead*\n\nPut the `>` of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).\n\nValid options:\n\n- `true` - Example:\n\n``` jsx\n      \n        <button\n        className\n        =\"prettier-class\"\n        id\n        =\"prettier-id\"\n        onClick\n        ={this.handleClick}\n        >\n      \n      \n  Click Here\n\n      \n        </button\n        >\n      \n    \n```\n\n- `false` - Example:\n\n``` jsx\n      \n        <button\n        className\n        =\"prettier-class\"\n        id\n        =\"prettier-id\"\n        onClick\n        ={this.handleClick}\n        >\n      \n      \n  Click Here\n\n      \n        </button\n        >\n      \n    \n```\n\n| Default | CLI Override              | API Override                 |\n|---------|---------------------------|------------------------------|\n| `false` | `--jsx-bracket-same-line` | `jsxBracketSameLine: <bool>` |"
- name: ALE
  id: vim#alehttpsgithubcomdense-analysisale
  summary: ALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide
  belongs_to: Vim Setup
  description: |-
    ## [ALE](https://github.com/dense-analysis/ale)

    ALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide.

    The best way to install ALE is with your favorite plugin manager for Vim, such as [vim-plug](https://github.com/junegunn/vim-plug):

    ``` jsx
    Plug 'dense-analysis/ale'
    ```

    You can find further instructions on the [ALE repository](https://github.com/dense-analysis/ale#3-installation).

    ALE will try to use Prettier installed locally before looking for a global installation.

    Enable the Prettier fixer for the languages you use:

    ``` jsx
    letg:ale_fixers = {
    \   'javascript': ['prettier'],
    \   'css': ['prettier'],
    \}
    ```

    ALE supports both *linters* and *fixers*. If you don’t specify which *linters* to run, **all available tools for all supported languages will be run,** and you might get a correctly formatted file with a bunch of lint errors. To disable this behavior you can tell ALE to run only linters you've explicitly configured (more info in the [FAQ](https://github.com/dense-analysis/ale/blob/ed8104b6ab10f63c78e49b60d2468ae2656250e9/README.md#faq-disable-linters)):

    ``` jsx
    letg:ale_linters_explicit = 1
    ```

    You can then run `:ALEFix` in a JavaScript or CSS file to run Prettier.

    To have ALE run Prettier on save:

    ``` jsx
    letg:ale_fix_on_save = 1
    ```

    It’s recommended to use a [config file](configuration), but you can also add options in your `.vimrc`:

    ``` jsx
    letg:ale_javascript_prettier_options = '--single-quote --trailing-comma all'
    ```
- name: API
  id: api
  summary: If you want to run Prettier programmatically, check this page out
  description: "# API\n\nIf you want to run Prettier programmatically, check this page out.\n\n``` jsx\nimport * as prettier from \"prettier\";\n```\n\nOur public APIs are all asynchronous, if you must use synchronous version for some reason, you can try [`@prettier/sync`](https://github.com/prettier/prettier-synchronized).\n\n## `prettier.format(source, options)`\n\n`format` is used to format text using Prettier. `options.parser` must be set according to the language you are formatting (see the [list of available parsers](options#parser)). Alternatively, `options.filepath` can be specified for Prettier to infer the parser from the file extension. Other [options](options) may be provided to override the defaults.\n\n``` jsx\nawait prettier.format(\"foo ( );\", { semi: false, parser: \"babel\" });\n// -> 'foo()\\n'\n```\n\n## `prettier.check(source [, options])`\n\n`check` checks to see if the file has been formatted with Prettier given those options and returns a `Promise<boolean>`. This is similar to the `--check` or `--list-different` parameter in the CLI and is useful for running Prettier in CI scenarios.\n\n## `prettier.formatWithCursor(source [, options])`\n\n`formatWithCursor` both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.\n\nThe `cursorOffset` option should be provided, to specify where the cursor is.\n\n``` jsx\nawait prettier.formatWithCursor(\" 1\", { cursorOffset: 2, parser: \"babel\" });\n// -> { formatted: '1;\\n', cursorOffset: 1 }\n```\n\n## `prettier.resolveConfig(fileUrlOrPath [, options])`\n\n`resolveConfig` can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as `options.config` if you don’t wish to search for it. A promise is returned which will resolve to:\n\n- An options object, providing a [config file](configuration) was found.\n- `null`, if no file was found.\n\nThe promise will be rejected if there was an error parsing the configuration file.\n\nIf `options.useCache` is `false`, all caching will be bypassed.\n\n``` jsx\nconst text = await fs.readFile(filePath, \"utf8\");\nconst options = await prettier.resolveConfig(filePath);\nconst formatted = await prettier.format(text, options);\n```\n\nIf `options.editorconfig` is `true` and an [`.editorconfig` file](https://editorconfig.org/) is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by `.prettierrc`, etc. Currently, the following EditorConfig properties are supported:\n\n- `end_of_line`\n- `indent_style`\n- `indent_size`/`tab_width`\n- `max_line_length`\n\n## `prettier.resolveConfigFile([fileUrlOrPath])`\n\n`resolveConfigFile` can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling `resolveConfig`). A promise is returned which will resolve to:\n\n- The path of the configuration file.\n- `null`, if no file was found.\n\nThe promise will be rejected if there was an error parsing the configuration file.\n\nThe search starts at `process.cwd()`, or at the directory of `fileUrlOrPath` if provided.\n\n``` jsx\nconst configFile = await prettier.resolveConfigFile(filePath);\n// you got the path of the configuration file\n```\n\n## `prettier.clearConfigCache()`\n\nWhen Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.\n\n## `prettier.getFileInfo(fileUrlOrPath [, options])`\n\n`getFileInfo` can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:\n\n``` jsx\n{\n  ignored: boolean;\n  inferredParser: string | null;\n}\n```\n\nThe promise will be rejected if the type of `fileUrlOrPath` is not `string` or `URL`.\n\nSetting `options.ignorePath` (`string | URL | (string | URL)[]`) and `options.withNodeModules` (`boolean`) influence the value of `ignored` (`false` by default).\n\nIf the given `fileUrlOrPath` is ignored, the `inferredParser` is always `null`.\n\nProviding [plugin](plugins) paths in `options.plugins` (`string[]`) helps extract `inferredParser` for files that are not supported by Prettier core.\n\nWhen setting `options.resolveConfig` (`boolean`, default `true`) to `false`, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.\n\n## `prettier.getSupportInfo()`\n\nReturns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.\n\nThe support information looks like this:\n\n``` jsx\n{\n  languages: Array<{\n    name: string;\n    parsers: string[];\n    group?: string;\n    tmScope?: string;\n    aceMode?: string;\n    codemirrorMode?: string;\n    codemirrorMimeType?: string;\n    aliases?: string[];\n    extensions?: string[];\n    filenames?: string[];\n    linguistLanguageId?: number;\n    vscodeLanguageIds?: string[];\n  }>;\n}\n```\n\n## Custom Parser API (removed)\n\n*Removed in v3.0.0 (superseded by the Plugin API)*\n\nBefore [plugins](plugins) were a thing, Prettier had a similar but more limited feature called custom parsers. It’s been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.\n\n❌ Custom parser API (removed):\n\n``` jsx\nimport { format } from \"prettier\";\n\nformat(\"lodash ( )\", {\n  parser(text, { babel }) {\n    const ast = babel(text);\n    ast.program.body[0].expression.callee.name = \"_\";\n    return ast;\n  },\n});\n// -> \"_();\\n\"\n```\n\n✔️ Plugin API:\n\n``` jsx\nimport { format } from \"prettier\";\nimport * as prettierPluginBabel from \"prettier/plugins/babel\";\n\nconst myCustomPlugin = {\n  parsers: {\n    \"my-custom-parser\": {\n      async parse(text) {\n        const ast = await prettierPluginBabel.parsers.babel.parse(text);\n        ast.program.body[0].expression.callee.name = \"_\";\n        return ast;\n      },\n      astFormat: \"estree\",\n    },\n  },\n};\n\nawait format(\"lodash ( )\", {\n  parser: \"my-custom-parser\",\n  plugins: [myCustomPlugin],\n});\n// -> \"_();\\n\"\n```\n\n> Note: Overall, doing codemods this way isn’t recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using [jscodeshift](https://github.com/facebook/jscodeshift) if you need codemods.\n\nAs part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a `parse` function via the `--parser` option. Use the `--plugin` CLI option or the `plugins` API option instead to [load plugins](plugins#using-plugins).\n\n© James Long and contributors  \n[https://prettier.io/docs/en/api](https://prettier.io/docs/en/api)"
- name: Arrow Function Parentheses
  id: options#arrow-function-parentheses
  summary: Include parentheses around a sole arrow function parameter
  belongs_to: Options
  description: |-
    ## Arrow Function Parentheses

    *First available in v1.9.0, default value changed from `avoid` to `always` in v2.0.0*

    Include parentheses around a sole arrow function parameter.

    Valid options:

    - `"always"` - Always include parens. Example: `(x) => x`
    - `"avoid"` - Omit parens when possible. Example: `x => x`

    | Default    | CLI Override                    | API Override                    |
    |------------|---------------------------------|---------------------------------|
    | `"always"` | `--arrow-parens <always|avoid>` | `arrowParens: "<always|avoid>"` |

    At first glance, avoiding parentheses may look like a better choice because of less visual noise. However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes. Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.
- name: Atom
  id: editors#atom
  summary: Atom users can install the prettier-atom package, or one of the more minimalistic mprettier and miniprettier packages
  belongs_to: Editor Integration
  description: |-
    ## Atom

    Atom users can install the [prettier-atom](https://github.com/prettier/prettier-atom) package, or one of the more minimalistic [mprettier](https://github.com/t9md/atom-mprettier) and [miniprettier](https://github.com/duailibe/atom-miniprettier) packages.
- name: Available as part of the Tidelift Subscription
  id: for-enterprise#available-as-part-of-the-tidelift-subscription
  summary: Tidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications
  belongs_to: For Enterprise
  description: "## Available as part of the Tidelift Subscription\n\nTidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use.\n\n[Learn more](https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise) [Request a demo](https://tidelift.com/subscription/request-a-demo?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise)\n\n  \n\n### Enterprise-ready open source software—managed for you\n\nThe Tidelift Subscription is a managed open source subscription for application dependencies covering millions of open source projects across JavaScript, Python, Java, PHP, Ruby, .NET, and more.\n\nYour subscription includes:\n\n**Security updates**\n\nTidelift’s security response team coordinates patches for new breaking security vulnerabilities and alerts immediately through a private channel, so your software supply chain is always secure.\n\n**Licensing verification and indemnification**\n\nTidelift verifies license information to enable easy policy enforcement and adds intellectual property indemnification to cover creators and users in case something goes wrong. You always have a 100% up-to-date bill of materials for your dependencies to share with your legal team, customers, or partners.\n\n**Maintenance and code improvement**\n\nTidelift ensures the software you rely on keeps working as long as you need it to work. Your managed dependencies are actively maintained and we recruit additional maintainers where required.\n\n**Package selection and version guidance**\n\nWe help you choose the best open source packages from the start—and then guide you through updates to stay on the best releases as new issues arise.\n\n**Roadmap input**\n\nTake a seat at the table with the creators behind the software you use. Tidelift’s participating maintainers earn more income as their software is used by more subscribers, so they’re interested in knowing what you need.\n\n**Tooling and cloud integration**\n\nTidelift works with GitHub, GitLab, BitBucket, and more. We support every cloud platform (and other deployment targets, too).\n\nThe end result? All of the capabilities you expect from commercial-grade software, for the full breadth of open source you use. That means less time grappling with esoteric open source trivia, and more time building your own applications—and your business.\n\n[Learn more](https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise) [Request a demo](https://tidelift.com/subscription/request-a-demo?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise)\n\n© James Long and contributors  \n[https://prettier.io/docs/en/for-enterprise](https://prettier.io/docs/en/for-enterprise)"
- name: Basic Configuration
  id: configuration#basic-configuration
  summary: null
  belongs_to: Configuration File
  description: "## Basic Configuration\n\nJSON:\n\n``` jsx\n{\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 4,\n  \"semi\": false,\n  \"singleQuote\": true\n}\n```\n\nJS (ES Modules):\n\n``` jsx\n// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs/**\n * @see https://prettier.io/docs/en/configuration.html\n * @type {import(\"prettier\").Config}\n */const config = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n\nexport default config;\n```\n\nJS (CommonJS):\n\n``` jsx\n// prettier.config.js, .prettierrc.js, prettier.config.cjs, or .prettierrc.cjs/**\n * @see https://prettier.io/docs/en/configuration.html\n * @type {import(\"prettier\").Config}\n */const config = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n\nmodule.exports = config;\n```\n\nYAML:\n\n``` jsx\n      # .prettierrc or .prettierrc.yaml\n      trailingComma:\n      \"es5\"\n      tabWidth:\n      4\n      semi:\n      false\n      singleQuote:\n      true\n    \n```\n\nTOML:\n\n``` jsx\n# .prettierrc.tomltrailingComma = \"es5\"\ntabWidth = 4\nsemi = false\nsingleQuote = true\n```"
- name: Bracket Line
  id: options#bracket-line
  summary: Put the > of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements)
  belongs_to: Options
  description: |-
    ## Bracket Line

    Put the `>` of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).

    Valid options:

    - `true` - Example:

    ``` jsx
    <buttonclassName="prettier-class"id="prettier-id"onClick={this.handleClick}>
      Click Here
    </button>
    ```

    - `false` - Example:

    ``` jsx
    <buttonclassName="prettier-class"id="prettier-id"onClick={this.handleClick}>
      Click Here
    </button>
    ```

    | Default | CLI Override          | API Override              |
    |---------|-----------------------|---------------------------|
    | `false` | `--bracket-same-line` | `bracketSameLine: <bool>` |
- name: Bracket Spacing
  id: options#bracket-spacing
  summary: Print spaces between brackets in object literals
  belongs_to: Options
  description: |-
    ## Bracket Spacing

    Print spaces between brackets in object literals.

    Valid options:

    - `true` - Example: `{ foo: bar }`.
    - `false` - Example: `{foo: bar}`.

    | Default | CLI Override           | API Override             |
    |---------|------------------------|--------------------------|
    | `true`  | `--no-bracket-spacing` | `bracketSpacing: <bool>` |
- name: Browser
  id: browser
  summary: Run Prettier in the browser using its standalone version
  description: "# Browser\n\nRun Prettier in the browser using its **standalone** version. This version doesn’t depend on Node.js. It only formats the code and has no support for config files, ignore files, CLI usage, or automatic loading of plugins.\n\nThe standalone version comes as:\n\n- ES modules: `standalone.mjs`, starting in version 3.0 (In version 2, `esm/standalone.mjs`.)\n- UMD: `standalone.js`, starting in version 1.13\n\nThe [`browser` field](https://github.com/defunctzombie/package-browser-field-spec) in Prettier’s `package.json` points to `standalone.js`. That’s why you can just `import` or `require` the `prettier` module to access Prettier’s API, and your code can stay compatible with both Node and the browser as long as webpack or another bundler that supports the `browser` field is used. This is especially convenient for [plugins](plugins).\n\n### `prettier.format(code, options)`\n\nRequired options:\n\n- **[`parser`](options#parser) (or [`filepath`](options#file-path))**: One of these options has to be specified for Prettier to know which parser to use.\n\n- **`plugins`**: Unlike the `format` function from the [Node.js-based API](api#prettierformatsource--options), this function doesn’t load plugins automatically. The `plugins` option is required because all the parsers included in the Prettier package come as plugins (for reasons of file size). These plugins are files in <https://unpkg.com/browse/prettier@3.3.3/plugins/>. Note that `estree` plugin should be loaded when printing JavaScript, TypeScript, Flow, or JSON.\n\n  You need to load the ones that you’re going to use and pass them to `prettier.format` using the `plugins` option.\n\nSee below for examples.\n\n## Usage\n\n### Global\n\n``` jsx\n<script src=\"https://unpkg.com/prettier@3.3.3/standalone.js\"></script>\n<script src=\"https://unpkg.com/prettier@3.3.3/plugins/graphql.js\"></script>\n<script>\n  (async () => {\n    const formatted = await prettier.format(\"type Query { hello: String }\", {\n      parser: \"graphql\",\n      plugins: prettierPlugins,\n    });\n  })();\n</script>\n```\n\nNote that the [`unpkg` field](https://unpkg.com/#examples) in Prettier’s `package.json` points to `standalone.js`, that’s why `https://unpkg.com/prettier` can also be used instead of `https://unpkg.com/prettier/standalone.js`.\n\n### ES Modules\n\n``` jsx\n<script type=\"module\">\n  import * as prettier from \"https://unpkg.com/prettier@3.3.3/standalone.mjs\";\n  import prettierPluginGraphql from \"https://unpkg.com/prettier@3.3.3/plugins/graphql.mjs\";\n\n  const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins: [prettierPluginGraphql],\n  });\n</script>\n```\n\n### AMD\n\n``` jsx\ndefine([\n  \"https://unpkg.com/prettier@3.3.3/standalone.js\",\n  \"https://unpkg.com/prettier@3.3.3/plugins/graphql.js\",\n], async (prettier, ...plugins) => {\n  const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins,\n  });\n});\n```\n\n### CommonJS\n\n``` jsx\nconst prettier = require(\"prettier/standalone\");\nconst plugins = [require(\"prettier/plugins/graphql\")];\n\n(async () => {\n  const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins,\n  });\n})();\n```\n\nThis syntax doesn’t necessarily work in the browser, but it can be used when bundling the code with browserify, Rollup, webpack, or another bundler.\n\n### Worker\n\n``` jsx\nimportScripts(\"https://unpkg.com/prettier@3.3.3/standalone.js\");\nimportScripts(\"https://unpkg.com/prettier@3.3.3/plugins/graphql.js\");\n\n(async () => {\n  const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins: prettierPlugins,\n  });\n})();\n```\n\n## Parser plugins for embedded code\n\nIf you want to format [embedded code](options#embedded-language-formatting), you need to load related plugins too. For example:\n\n``` jsx\n<script type=\"module\">\n  import * as prettier from \"https://unpkg.com/prettier@3.3.3/standalone.mjs\";\n  import prettierPluginBabel from \"https://unpkg.com/prettier@3.3.3/plugins/babel.mjs\";\n  import prettierPluginEstree from \"https://unpkg.com/prettier@3.3.3/plugins/estree.mjs\";\n\n  console.log(\n    await prettier.format(\"const html=/* HTML */ `<DIV> </DIV>`\", {\n      parser: \"babel\",\n      plugins: [prettierPluginBabel, prettierPluginEstree],\n    }),\n  );\n  // Output: const html = /* HTML */ `<DIV> </DIV>`;\n</script>\n```\n\nThe HTML code embedded in JavaScript stays unformatted because the `html` parser hasn’t been loaded. Correct usage:\n\n``` jsx\n<script type=\"module\">\n  import * as prettier from \"https://unpkg.com/prettier@3.3.3/standalone.mjs\";\n  import prettierPluginBabel from \"https://unpkg.com/prettier@3.3.3/plugins/babel.mjs\";\n  import prettierPluginEstree from \"https://unpkg.com/prettier@3.3.3/plugins/estree.mjs\";\n  import prettierPluginHtml from \"https://unpkg.com/prettier@3.3.3/plugins/html.mjs\";\n\n  console.log(\n    await prettier.format(\"const html=/* HTML */ `<DIV> </DIV>`\", {\n      parser: \"babel\",\n      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],\n    }),\n  );\n  // Output: const html = /* HTML */ `<div></div>`;\n</script>\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/browser](https://prettier.io/docs/en/browser)"
- name: Building and enforcing a style guide
  id: why-prettier#building-and-enforcing-a-style-guide
  summary: By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles
  belongs_to: Why Prettier?
  description: |-
    ## Building and enforcing a style guide

    By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. [It is generally accepted that having a common style guide is valuable for a project and team](https://www.smashingmagazine.com/2012/10/why-coding-style-matters/) but getting there is a very painful and unrewarding process. People get very emotional around particular ways of writing code and nobody likes spending time writing and receiving nits.

    So why choose the “Prettier style guide” over any other random style guide? Because Prettier is the only “style guide” that is fully automatic. Even if Prettier does not format all code 100% the way you’d like, it’s worth the “sacrifice” given the unique benefits of Prettier, don’t you think?

    - “We want to free mental threads and end discussions around style. While sometimes fruitful, these discussions are for the most part wasteful.”
    - “Literally had an engineer go through a huge effort of cleaning up all of our code because we were debating ternary style for the longest time and were inconsistent about it. It was dumb, but it was a weird on-going “great debate” that wasted lots of little back and forth bits. It’s far easier for us all to agree now: just run Prettier, and go with that style.”
    - “Getting tired telling people how to style their product code.”
    - “Our top reason was to stop wasting our time debating style nits.”
    - “Having a githook set up has reduced the amount of style issues in PRs that result in broken builds due to ESLint rules or things I have to nit-pick or clean up later.”
    - “I don’t want anybody to nitpick any other person ever again.”
    - “It reminds me of how Steve Jobs used to wear the same clothes every day because he has a million decisions to make and he didn’t want to be bothered to make trivial ones like picking out clothes. I think Prettier is like that.”
- name: Clean up an existing codebase
  id: why-prettier#clean-up-an-existing-codebase
  summary: Since coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases
  belongs_to: Why Prettier?
  description: |-
    ## Clean up an existing codebase

    Since coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases. Running Prettier in this case is a quick win, the codebase is now uniform and easier to read without spending hardly any time.

    - “Take a look at the code :) I just need to restore sanity.”
    - “We inherited a ~2000 module ES6 code base, developed by 20 different developers over 18 months, in a global team. Felt like such a win without much research.”

    &nbsp;
- name: CLI
  id: cli
  summary: Use the prettier command to run Prettier from the command line
  description: "# CLI\n\nUse the `prettier` command to run Prettier from the command line.\n\n``` jsx\nprettier [options] [file/dir/glob ...]\n```\n\n> To run your locally installed version of Prettier, prefix the command with `npx` or `yarn` (if you use Yarn), i.e. `npx prettier --help`, or `yarn prettier --help`.\n\nTo format a file in-place, use `--write`. (Note: This overwrites your files!)\n\nIn practice, this may look something like:\n\n``` jsx\nprettier . --write\n```\n\nThis command formats all files supported by Prettier in the current directory and its subdirectories.\n\nIt’s recommended to always make sure that `prettier --write .` only formats what you want in your project. Use a [`.prettierignore`](ignore) file to ignore things that should not be formatted.\n\nA more complicated example:\n\n``` jsx\nprettier docs package.json \"{app,__{tests,mocks}__}/**/*.js\" --write --single-quote --trailing-comma all\n```\n\n> Don’t forget the **quotes** around the globs! The quotes make sure that Prettier CLI expands the globs rather than your shell, which is important for cross-platform usage.\n\n> It’s better to use a [configuration file](configuration) for formatting options like `--single-quote` and `--trailing-comma` instead of passing them as CLI flags. This way the Prettier CLI, [editor integrations](editors), and other tooling can all know what options you use.\n\n## File patterns\n\nGiven a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path.\n\n- If the path points to an existing file, Prettier CLI proceeds with that file and doesn’t resolve the path as a glob pattern.\n\n- If the path points to an existing directory, Prettier CLI recursively finds supported files in that directory. This resolution process is based on file extensions and well-known file names that Prettier and its [plugins](plugins) associate with supported languages.\n\n- Otherwise, the entry is resolved as a glob pattern using the [glob syntax from the `fast-glob` module](https://github.com/mrmlnc/fast-glob#pattern-syntax).\n\nPrettier CLI will ignore files located in `node_modules` directory. To opt out from this behavior, use `--with-node-modules` flag.\n\nPrettier CLI will not follow symbolic links when expanding arguments.\n\nTo escape special characters in globs, one of the two escaping syntaxes can be used: `prettier \"\\[my-dir]/*.js\"` or `prettier \"[[]my-dir]/*.js\"`. Both match all JS files in a directory named `[my-dir]`, however the latter syntax is preferable as the former doesn’t work on Windows, where backslashes are treated as path separators.\n\n## `--check`\n\nWhen you want to check if your files are formatted, you can run Prettier with the `--check` flag (or `-c`). This will output a human-friendly message and a list of unformatted files, if any.\n\n``` jsx\nprettier . --check\n```\n\nConsole output if all files are formatted:\n\n``` jsx\nChecking formatting...\nAll matched files use Prettier code style!\n```\n\nConsole output if some of the files require re-formatting:\n\n``` jsx\nChecking formatting...\n[warn] src/fileA.js\n[warn] src/fileB.js\n[warn] Code style issues found in 2 files. Run Prettier with --write to fix.\n```\n\nThe command will return exit code `1` in the second case, which is helpful inside the CI pipelines. Human-friendly status messages help project contributors react on possible problems. To minimise the number of times `prettier --check` finds unformatted files, you may be interested in configuring a [pre-commit hook](precommit) in your repo. Applying this practice will minimise the number of times the CI fails because of code formatting problems.\n\nIf you need to pipe the list of unformatted files to another command, you can use [`--list-different`](cli#--list-different) flag instead of `--check`.\n\n### Exit codes\n\n| Code | Information                         |\n|------|-------------------------------------|\n| `0`  | Everything formatted properly       |\n| `1`  | Something wasn’t formatted properly |\n| `2`  | Something’s wrong with Prettier     |\n\n## `--debug-check`\n\nIf you're worried that Prettier will change the correctness of your code, add `--debug-check` to the command. This will cause Prettier to print an error message if it detects that code correctness might have changed. Note that `--write` cannot be used with `--debug-check`.\n\n## `--find-config-path` and `--config`\n\nIf you are repeatedly formatting individual files with `prettier`, you will incur a small performance cost when Prettier attempts to look up a [configuration file](configuration). In order to skip this, you may ask Prettier to find the config file once, and re-use it later on.\n\n``` jsx\n$ prettier --find-config-path path/to/file.js\npath/to/.prettierrc\n```\n\nThis will provide you with a path to the configuration file, which you can pass to `--config`:\n\n``` jsx\nprettier path/to/file.js --write --config path/to/.prettierrc\n```\n\nYou can also use `--config` if your configuration file lives somewhere where Prettier cannot find it, such as a `config/` directory.\n\nIf you don’t have a configuration file, or want to ignore it if it does exist, you can pass `--no-config` instead.\n\n## `--ignore-path`\n\nPath to a file containing patterns that describe files to ignore. By default, Prettier looks for `./.gitignore` and `./.prettierignore`.  \nMultiple values are accepted.\n\n## `--list-different`\n\nAnother useful flag is `--list-different` (or `-l`) which prints the filenames of files that are different from Prettier formatting. If there are differences the script errors out, which is useful in a CI scenario.\n\n``` jsx\nprettier . --single-quote --list-different\n```\n\nYou can also use [`--check`](cli#--check) flag, which works the same way as `--list-different`, but also prints a human-friendly summary message to stdout.\n\n## `--no-config`\n\nDo not look for a configuration file. The default settings will be used.\n\n## `--config-precedence`\n\nDefines how config file should be evaluated in combination of CLI options.\n\n**cli-override (default)**\n\nCLI options take precedence over config file\n\n**file-override**\n\nConfig file take precedence over CLI options\n\n**prefer-file**\n\nIf a config file is found will evaluate it and ignore other CLI options. If no config file is found, CLI options will evaluate as normal.\n\nThis option adds support to editor integrations where users define their default configuration but want to respect project specific configuration.\n\n## `--no-editorconfig`\n\nDon’t take `.editorconfig` into account when parsing configuration. See the [`prettier.resolveConfig` docs](api) for details.\n\n## `--with-node-modules`\n\nPrettier CLI will ignore files located in `node_modules` directory. To opt out from this behavior, use `--with-node-modules` flag.\n\n## `--write`\n\nThis rewrites all processed files in place. This is comparable to the `eslint --fix` workflow. You can also use `-w` alias.\n\n## `--log-level`\n\nChange the level of logging for the CLI. Valid options are:\n\n- `error`\n- `warn`\n- `log` (default)\n- `debug`\n- `silent`\n\n## `--stdin-filepath`\n\nA path to the file that the Prettier CLI will treat like stdin. For example:\n\n*abc.css*\n\n``` jsx\n.name {\n  display: none;\n}\n```\n\n*shell*\n\n``` jsx\n$ cat abc.css | prettier --stdin-filepath abc.css\n.name {\n  display: none;\n}\n```\n\n## `--ignore-unknown`\n\nWith `--ignore-unknown` (or `-u`), prettier will ignore unknown files matched by patterns.\n\n``` jsx\nprettier \"**/*\" --write --ignore-unknown\n```\n\n## `--no-error-on-unmatched-pattern`\n\nPrevent errors when pattern is unmatched.\n\n## `--cache`\n\nIf this option is enabled, the following values are used as cache keys and the file is formatted only if one of them is changed.\n\n- Prettier version\n- Options\n- Node.js version\n- (if `--cache-strategy` is `metadata`) file metadata, such as timestamps\n- (if `--cache-strategy` is `content`) content of the file\n\n``` jsx\nprettier . --write --cache\n```\n\nRunning Prettier without `--cache` will delete the cache.\n\nAlso, since the cache file is stored in `./node_modules/.cache/prettier/.prettier-cache`, so you can use `rm ./node_modules/.cache/prettier/.prettier-cache` to remove it manually.\n\n> Plugins version and implementation are not used as cache keys. We recommend that you delete the cache when updating plugins.\n\n## `--cache-location`\n\nPath to the cache file location used by `--cache` flag. If you don't explicit `--cache-location`, Prettier saves cache file at `./node_modules/.cache/prettier/.prettier-cache`.\n\nIf a file path is passed, that file is used as the cache file.\n\n``` jsx\nprettier . --write --cache --cache-location=path/to/cache-file\n```\n\n## `--cache-strategy`\n\nStrategy for the cache to use for detecting changed files. Can be either `metadata` or `content`.\n\nIn general, `metadata` is faster. However, `content` is useful for updating the timestamp without changing the file content. This can happen, for example, during git operations such as `git clone`, because it does not track file modification times.\n\nIf no strategy is specified, `content` will be used.\n\n``` jsx\nprettier . --write --cache --cache-strategy metadata\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/cli](https://prettier.io/docs/en/cli)"
- name: coc-prettier
  id: vim#coc-prettierhttpsgithubcomneoclidecoc-prettier
  summary: Prettier extension for coc.nvim which requires neovim or vim8.1
  belongs_to: Vim Setup
  description: |-
    ## [coc-prettier](https://github.com/neoclide/coc-prettier)

    Prettier extension for [coc.nvim](https://github.com/neoclide/coc.nvim) which requires neovim or vim8.1. Install coc.nvim with your favorite plugin manager, such as [vim-plug](https://github.com/junegunn/vim-plug):

    ``` jsx
    Plug 'neoclide/coc.nvim', {'branch': 'release'}
    ```

    And install coc-prettier by command:

    ``` jsx
    CocInstall coc-prettier
    ```

    Setup `Prettier` command in your `init.vim` or `.vimrc`

    ``` jsx
    command! -nargs=0 Prettier :call CocAction('runCommand', 'prettier.formatFile')
    ```

    Update your `coc-settings.json` for languages that you want format on save.

    ``` jsx
    {
      "coc.preferences.formatOnSaveFiletypes": ["css", "markdown"]
    }
    ```

    [coc-prettier](https://github.com/neoclide/coc-prettier) have same configurations of [prettier-vscode](https://github.com/prettier/prettier-vscode), open `coc-settings.json` by `:CocConfig` to get autocompletion support.
- name: Command Line File Patterns
  id: ignore#command-line-file-patterns
  summary: See fast-glob to learn more about advanced glob syntax
  belongs_to: Ignoring Code
  description: "## Command Line File Patterns\n\nFor one-off commands, when you want to exclude some files without adding them to `.prettierignore`, negative patterns can come in handy:\n\n``` jsx\nprettier . \"!**/*.{js,jsx,vue}\" --write\n```\n\nSee [fast-glob](cli#file-patterns) to learn more about advanced glob syntax.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/ignore](https://prettier.io/docs/en/ignore)"
- name: Community Plugins
  id: plugins#community-plugins
  summary: null
  belongs_to: Plugins
  description: |-
    ## Community Plugins

    - [`prettier-plugin-apex`](https://github.com/dangmai/prettier-plugin-apex) by [**@dangmai**](https://github.com/dangmai)
    - [`prettier-plugin-astro`](https://github.com/withastro/prettier-plugin-astro) by [**@withastro contributors**](https://github.com/withastro/prettier-plugin-astro/graphs/contributors)
    - [`prettier-plugin-elm`](https://github.com/gicentre/prettier-plugin-elm) by [**@giCentre**](https://github.com/gicentre)
    - [`prettier-plugin-erb`](https://github.com/adamzapasnik/prettier-plugin-erb) by [**@adamzapasnik**](https://github.com/adamzapasnik)
    - [`prettier-plugin-gherkin`](https://github.com/mapado/prettier-plugin-gherkin) by [**@mapado**](https://github.com/mapado)
    - [`prettier-plugin-glsl`](https://github.com/NaridaL/glsl-language-toolkit/tree/main/packages/prettier-plugin-glsl) by [**@NaridaL**](https://github.com/NaridaL)
    - [`prettier-plugin-go-template`](https://github.com/NiklasPor/prettier-plugin-go-template) by [**@NiklasPor**](https://github.com/NiklasPor)
    - [`prettier-plugin-java`](https://github.com/jhipster/prettier-java) by [**@JHipster**](https://github.com/jhipster)
    - [`prettier-plugin-jinja-template`](https://github.com/davidodenwald/prettier-plugin-jinja-template) by [**@davidodenwald**](https://github.com/davidodenwald)
    - [`prettier-plugin-jsonata`](https://github.com/Stedi/prettier-plugin-jsonata) by [**@Stedi**](https://github.com/Stedi)
    - [`prettier-plugin-kotlin`](https://github.com/Angry-Potato/prettier-plugin-kotlin) by [**@Angry-Potato**](https://github.com/Angry-Potato)
    - [`prettier-plugin-motoko`](https://github.com/dfinity/prettier-plugin-motoko) by [**@dfinity**](https://github.com/dfinity)
    - [`prettier-plugin-nginx`](https://github.com/joedeandev/prettier-plugin-nginx) by [**@joedeandev**](https://github.com/joedeandev)
    - [`prettier-plugin-prisma`](https://github.com/umidbekk/prettier-plugin-prisma) by [**@umidbekk**](https://github.com/umidbekk)
    - [`prettier-plugin-properties`](https://github.com/eemeli/prettier-plugin-properties) by [**@eemeli**](https://github.com/eemeli)
    - [`prettier-plugin-rust`](https://github.com/jinxdash/prettier-plugin-rust) by [**@jinxdash**](https://github.com/jinxdash)
    - [`prettier-plugin-sh`](https://github.com/un-ts/prettier/tree/master/packages/sh) by [**@JounQin**](https://github.com/JounQin)
    - [`prettier-plugin-sql`](https://github.com/un-ts/prettier/tree/master/packages/sql) by [**@JounQin**](https://github.com/JounQin)
    - [`prettier-plugin-sql-cst`](https://github.com/nene/prettier-plugin-sql-cst) by [**@nene**](https://github.com/nene)
    - [`prettier-plugin-solidity`](https://github.com/prettier-solidity/prettier-plugin-solidity) by [**@mattiaerre**](https://github.com/mattiaerre)
    - [`prettier-plugin-svelte`](https://github.com/sveltejs/prettier-plugin-svelte) by [**@sveltejs**](https://github.com/sveltejs)
    - [`prettier-plugin-toml`](https://github.com/bd82/toml-tools/tree/master/packages/prettier-plugin-toml) by [**@bd82**](https://github.com/bd82)

    &nbsp;
- name: Configuration File
  id: configuration
  summary: The configuration file will be resolved starting from the location of the file being formatted, and searching up the file tree until a config file is (or isn’t) found
  description: "# Configuration File\n\nYou can configure Prettier via (in order of precedence):\n\n- A `\"prettier\"` key in your `package.json`, or [`package.yaml`](https://github.com/pnpm/pnpm/pull/1799) file.\n- A `.prettierrc` file written in JSON or YAML.\n- A `.prettierrc.json`, `.prettierrc.yml`, `.prettierrc.yaml`, or `.prettierrc.json5` file.\n- A `.prettierrc.js`, or `prettier.config.js` file that exports an object using `export default` or `module.exports` (depends on the [`type`](https://nodejs.org/api/packages.html#type) value in your `package.json`).\n- A `.prettierrc.mjs`, or `prettier.config.mjs` file that exports an object using `export default`.\n- A `.prettierrc.cjs`, or `prettier.config.cjs` file that exports an object using `module.exports`.\n- A `.prettierrc.toml` file.\n\nThe configuration file will be resolved starting from the location of the file being formatted, and searching up the file tree until a config file is (or isn’t) found.\n\nPrettier intentionally doesn’t support any kind of global configuration. This is to make sure that when a project is copied to another computer, Prettier’s behavior stays the same. Otherwise, Prettier wouldn’t be able to guarantee that everybody in a team gets the same consistent results.\n\nThe options you can use in the configuration file are the same as the [API options](options).\n\n## Basic Configuration\n\nJSON:\n\n``` jsx\n{\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 4,\n  \"semi\": false,\n  \"singleQuote\": true\n}\n```\n\nJS (ES Modules):\n\n``` jsx\n// prettier.config.js, .prettierrc.js, prettier.config.mjs, or .prettierrc.mjs\n\n/**\n * @see https://prettier.io/docs/en/configuration.html\n * @type {import(\"prettier\").Config}\n */\nconst config = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n\nexport default config;\n```\n\nJS (CommonJS):\n\n``` jsx\n// prettier.config.js, .prettierrc.js, prettier.config.cjs, or .prettierrc.cjs\n\n/**\n * @see https://prettier.io/docs/en/configuration.html\n * @type {import(\"prettier\").Config}\n */\nconst config = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n\nmodule.exports = config;\n```\n\nYAML:\n\n``` jsx\n# .prettierrc or .prettierrc.yaml\ntrailingComma: \"es5\"\ntabWidth: 4\nsemi: false\nsingleQuote: true\n```\n\nTOML:\n\n``` jsx\n# .prettierrc.toml\ntrailingComma = \"es5\"\ntabWidth = 4\nsemi = false\nsingleQuote = true\n```\n\n## Configuration Overrides\n\nOverrides let you have different configuration for certain file extensions, folders and specific files.\n\nPrettier borrows ESLint’s [override format](https://eslint.org/docs/latest/user-guide/configuring/configuration-files#how-do-overrides-work).\n\nJSON:\n\n``` jsx\n{\n  \"semi\": false,\n  \"overrides\": [\n    {\n      \"files\": \"*.test.js\",\n      \"options\": {\n        \"semi\": true\n      }\n    },\n    {\n      \"files\": [\"*.html\", \"legacy/**/*.js\"],\n      \"options\": {\n        \"tabWidth\": 4\n      }\n    }\n  ]\n}\n```\n\nYAML:\n\n``` jsx\nsemi: false\noverrides:\n  - files: \"*.test.js\"\n    options:\n      semi: true\n  - files:\n      - \"*.html\"\n      - \"legacy/**/*.js\"\n    options:\n      tabWidth: 4\n```\n\n`files` is required for each override, and may be a string or array of strings. `excludeFiles` may be optionally provided to exclude files for a given rule, and may also be a string or array of strings.\n\n## Sharing configurations\n\nSharing a Prettier configuration is simple: just publish a module that exports a configuration object, say `@company/prettier-config`, and reference it in your `package.json`:\n\n``` jsx\n{\n  \"name\": \"my-cool-library\",\n  \"version\": \"9000.0.1\",\n  \"prettier\": \"@company/prettier-config\"\n}\n```\n\nIf you don’t want to use `package.json`, you can use any of the supported extensions to export a string, e.g. `.prettierrc.json`:\n\n``` jsx\n\"@company/prettier-config\"\n```\n\nAn example configuration repository is available [here](https://github.com/azz/prettier-config).\n\n> Note: This method does **not** offer a way to *extend* the configuration to overwrite some properties from the shared configuration. If you need to do that, import the file in a `.prettierrc.js` file and export the modifications, e.g:\n>\n> ``` jsx\n> import companyPrettierConfig from \"@company/prettier-config\";\n>\n> export default {\n>   ...companyPrettierConfig,\n>   semi: false,\n> };\n> ```\n\n## Setting the [parser](options#parser) option\n\nBy default, Prettier automatically infers which parser to use based on the input file extension. Combined with `overrides` you can teach Prettier how to parse files it does not recognize.\n\nFor example, to get Prettier to format its own `.prettierrc` file, you can do:\n\n``` jsx\n{\n  \"overrides\": [\n    {\n      \"files\": \".prettierrc\",\n      \"options\": { \"parser\": \"json\" }\n    }\n  ]\n}\n```\n\nYou can also switch to the `flow` parser instead of the default `babel` for .js files:\n\n``` jsx\n{\n  \"overrides\": [\n    {\n      \"files\": \"*.js\",\n      \"options\": {\n        \"parser\": \"flow\"\n      }\n    }\n  ]\n}\n```\n\n**Note:** *Never* put the `parser` option at the top level of your configuration. *Only* use it inside `overrides`. Otherwise you effectively disable Prettier’s automatic file extension based parser inference. This forces Prettier to use the parser you specified for *all* types of files – even when it doesn’t make sense, such as trying to parse a CSS file as JavaScript.\n\n## Configuration Schema\n\nIf you’d like a JSON schema to validate your configuration, one is available here: <https://json.schemastore.org/prettierrc>.\n\n## EditorConfig\n\nIf a [`.editorconfig` file](https://editorconfig.org/) is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by `.prettierrc`, etc.\n\nHere’s an annotated description of how different properties map to Prettier’s behavior:\n\n``` jsx\n# Stop the editor from looking for .editorconfig files in the parent directories\n# root = true\n\n[*]\n# Non-configurable Prettier behaviors\ncharset = utf-8\ninsert_final_newline = true\n# Caveat: Prettier won’t trim trailing whitespace inside template strings, but your editor might.\n# trim_trailing_whitespace = true\n\n# Configurable Prettier behaviors\n# (change these if your Prettier config differs)\nend_of_line = lf\nindent_style = space\nindent_size = 2\nmax_line_length = 80\n```\n\nHere’s a copy+paste-ready `.editorconfig` file if you use the default options:\n\n``` jsx\n[*]\ncharset = utf-8\ninsert_final_newline = true\nend_of_line = lf\nindent_style = space\nindent_size = 2\nmax_line_length = 80\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/configuration](https://prettier.io/docs/en/configuration)"
- name: Configuration Overrides
  id: configuration#configuration-overrides
  summary: Overrides let you have different configuration for certain file extensions, folders and specific files
  belongs_to: Configuration File
  description: "## Configuration Overrides\n\nOverrides let you have different configuration for certain file extensions, folders and specific files.\n\nPrettier borrows ESLint’s [override format](https://eslint.org/docs/latest/user-guide/configuring/configuration-files#how-do-overrides-work).\n\nJSON:\n\n``` jsx\n{\n  \"semi\": false,\n  \"overrides\": [\n    {\n      \"files\": \"*.test.js\",\n      \"options\": {\n        \"semi\": true\n      }\n    },\n    {\n      \"files\": [\"*.html\", \"legacy/**/*.js\"],\n      \"options\": {\n        \"tabWidth\": 4\n      }\n    }\n  ]\n}\n```\n\nYAML:\n\n``` jsx\n      semi:\n      false\n      overrides:\n      -\n      files:\n      \"*.test.js\"\n      options:\n      semi:\n      true\n      -\n      files:\n      -\n      \"*.html\"\n      -\n      \"legacy/**/*.js\"\n      options:\n      tabWidth:\n      4\n    \n```\n\n`files` is required for each override, and may be a string or array of strings. `excludeFiles` may be optionally provided to exclude files for a given rule, and may also be a string or array of strings."
- name: Configuration Schema
  id: configuration#configuration-schema
  summary: 'If you’d like a JSON schema to validate your configuration, one is available here: https://json.schemastore.org/prettierrc'
  belongs_to: Configuration File
  description: |-
    ## Configuration Schema

    If you’d like a JSON schema to validate your configuration, one is available here: <https://json.schemastore.org/prettierrc>.
- name: CSS
  id: ignore#css
  summary: null
  belongs_to: Ignoring Code
  description: "## CSS\n\n``` jsx\n      /* prettier-ignore */\n      .my    ugly rule\n      {\n      }\n    \n```"
- name: Custom Parser API (removed)
  id: api#custom-parser-api-removed
  summary: Before plugins were a thing, Prettier had a similar but more limited feature called custom parsers
  belongs_to: API
  description: "## Custom Parser API (removed)\n\n*Removed in v3.0.0 (superseded by the Plugin API)*\n\nBefore [plugins](plugins) were a thing, Prettier had a similar but more limited feature called custom parsers. It’s been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.\n\n❌ Custom parser API (removed):\n\n``` jsx\nimport{ format } from \"prettier\";\n\nformat(\"lodash ( )\", {\n  parser(text, { babel }) {\n    const ast = babel(text);\n    ast.program.body[0].expression.callee.name = \"_\";\n    return ast;\n  },\n});\n// -> \"_();\\n\"\n```\n\n✔️ Plugin API:\n\n``` jsx\nimport{ format } from \"prettier\";\nimport * as prettierPluginBabel from \"prettier/plugins/babel\";\n\nconst myCustomPlugin = {\n  parsers: {\n    \"my-custom-parser\": {\n      async parse(text) {\n        const ast = await prettierPluginBabel.parsers.babel.parse(text);\n        ast.program.body[0].expression.callee.name = \"_\";\n        return ast;\n      },\n      astFormat: \"estree\",\n    },\n  },\n};\n\nawait format(\"lodash ( )\", {\n  parser: \"my-custom-parser\",\n  plugins: [myCustomPlugin],\n});\n// -> \"_();\\n\"\n```\n\n> Note: Overall, doing codemods this way isn’t recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using [jscodeshift](https://github.com/facebook/jscodeshift) if you need codemods.\n\nAs part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a `parse` function via the `--parser` option. Use the `--plugin` CLI option or the `plugins` API option instead to [load plugins](plugins#using-plugins).\n\n© James Long and contributors  \n[https://prettier.io/docs/en/api](https://prettier.io/docs/en/api)"
- name: Developing Plugins
  id: plugins#developing-plugins
  summary: Languages is an array of language definitions that your plugin will contribute to Prettier
  belongs_to: Plugins
  description: "## Developing Plugins\n\nPrettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:\n\n- `languages`\n- `parsers`\n- `printers`\n- `options`\n- `defaultOptions`\n\n### `languages`\n\nLanguages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in [`prettier.getSupportInfo()`](api#prettiergetsupportinfo).\n\nIt **must** include `name` and `parsers`.\n\n``` jsx\nexportconst languages = [\n  {\n    // The language name\n    name: \"InterpretedDanceScript\",\n    // Parsers that can parse this language.\n    // This can be built-in parsers, or parsers you have contributed via this plugin.\n    parsers: [\"dance-parse\"],\n  },\n];\n```\n\n### `parsers`\n\nParsers convert code as a string into an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree).\n\nThe key must match the name in the `parsers` array from `languages`. The value contains a parse function, an AST format name, and two location extraction functions (`locStart` and `locEnd`).\n\n``` jsx\nexportconst parsers = {\n  \"dance-parse\": {\n    parse,\n    // The name of the AST that\n    astFormat: \"dance-ast\",\n    hasPragma,\n    locStart,\n    locEnd,\n    preprocess,\n  },\n};\n```\n\nThe signature of the `parse` function is:\n\n``` jsx\nfunctionparse(text:string, options: object): Promise<AST> | AST;\n```\n\nThe location extraction functions (`locStart` and `locEnd`) return the starting and ending locations of a given AST node:\n\n``` jsx\nfunctionlocStart(node: object): number;\n```\n\n*(Optional)* The pragma detection function (`hasPragma`) should return if the text contains the pragma comment.\n\n``` jsx\nfunctionhasPragma(text:string):boolean;\n```\n\n*(Optional)* The preprocess function can process the input text before passing into `parse` function.\n\n``` jsx\nfunctionpreprocess(text:string, options: object): string;\n```\n\n### `printers`\n\nPrinters convert ASTs into a Prettier intermediate representation, also known as a Doc.\n\nThe key must match the `astFormat` that the parser produces. The value contains an object with a `print` function. All other properties (`embed`, `preprocess`, etc.) are optional.\n\n``` jsx\nexportconst printers = {\n  \"dance-ast\": {\n    print,\n    embed,\n    preprocess,\n    getVisitorKeys,\n    insertPragma,\n    canAttachComment,\n    isBlockComment,\n    printComment,\n    getCommentChildNodes,\n    handleComments: {\n      ownLine,\n      endOfLine,\n      remaining,\n    },\n  },\n};\n```\n\n#### The printing process\n\nPrettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like `printWidth`). A *printer*'s job is to take the AST generated by `parsers[<parser name>].parse` and return a Doc. A Doc is constructed using [builder commands](https://github.com/prettier/prettier/blob/main/commands.md):\n\n``` jsx\nimport{ doc } from \"prettier\";\n\nconst { join, line, ifBreak, group } = doc.builders;\n```\n\nThe printing process consists of the following steps:\n\n1.  **AST preprocessing** (optional). See [`preprocess`](#optional-preprocess).\n2.  **Comment attachment** (optional). See [Handling comments in a printer](#handling-comments-in-a-printer).\n3.  **Processing embedded languages** (optional). The [`embed`](#optional-embed) method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, `embed` may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.\n4.  **Recursive printing**. A doc is recursively constructed from the AST. Starting from the root node:\n    - If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.\n    - Otherwise, the `print(path, options, print): Doc` method is called. It composes a doc for the current node, often by printing child nodes using the `print` callback.\n\n#### `print`\n\nMost of the work of a plugin's printer will take place in its `print` function, whose signature is:\n\n``` jsx\nfunctionprint(// Path to the AST node to print\n  path: AstPath,\n  options: object,\n  // Recursively print a child node\n  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,\n): Doc;\n```\n\nThe `print` function is passed the following parameters:\n\n- **`path`**: An object, which can be used to access nodes in the AST. It’s a stack-like data structure that maintains the current state of the recursion. It is called “path” because it represents the path to the current node from the root of the AST. The current node is returned by `path.node`.\n- **`options`**: A persistent object, which contains global options and which a plugin may mutate to store contextual data.\n- **`print`**: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer’s `print` function and passes itself to it. Thus, the two `print` functions – the one from the core and the one from the plugin – call each other while descending down the AST recursively.\n\nHere’s a simplified example to give an idea of what a typical implementation of `print` looks like:\n\n``` jsx\nimport{ doc } from \"prettier\";\n\nconst { group, indent, join, line, softline } = doc.builders;\n\nfunction print(path, options, print) {\n  const node = path.node;\n\n  switch (node.type) {\n    case \"list\":\n      return group([\n        \"(\",\n        indent([softline, join(line, path.map(print, \"elements\"))]),\n        softline,\n        \")\",\n      ]);\n\n    case \"pair\":\n      return group([\n        \"(\",\n        indent([softline, print(\"left\"), line, \". \", print(\"right\")]),\n        softline,\n        \")\",\n      ]);\n\n    case \"symbol\":\n      return node.name;\n  }\n\n  throw new Error(`Unknown node type: ${node.type}`);\n}\n```\n\nCheck out [prettier-python's printer](https://github.com/prettier/prettier-python/blob/034ba8a9551f3fa22cead41b323be0b28d06d13b/src/printer.js#L174) for some examples of what is possible.\n\n#### (optional) `embed`\n\nA printer can have the `embed` method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:\n\n``` jsx\nfunctionembed(// Path to the current AST node\n  path: AstPath,\n  // Current options\n  options: Options,\n):\n  | ((\n      // Parses and prints the passed text using a different parser.\n      // You should set `options.parser` to specify which parser to use.\n      textToDoc: (text: string, options: Options) => Promise<Doc>,\n      // Prints the current node or its descendant node with the current printer\n      print: (\n        selector?: string | number | Array<string | number> | AstPath,\n      ) => Doc,\n      // The following two arguments are passed for convenience.\n      // They're the same `path` and `options` that are passed to `embed`.\n      path: AstPath,\n      options: Options,\n    ) => Promise<Doc | undefined> | Doc | undefined)\n  | Doc\n  | undefined;\n```\n\nThe `embed` method is similar to the `print` method in that it maps AST nodes to docs, but unlike `print`, it has power to do async work by returning an async function. That function's first parameter, the `textToDoc` async function, can be used to render a doc using a different plugin.\n\nIf a function returned from `embed` returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the `print` method won’t be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from `embed`, however `textToDoc` and the `print` callback aren’t available at that case. Return a function to get them.\n\nIf `embed` returns `undefined`, or if a function it returned returns `undefined` or a promise that resolves to `undefined`, the node will be printed normally with the `print` method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the `PRETTIER_DEBUG` environment variable to a non-empty value if you want Prettier to rethrow these errors.\n\nFor example, a plugin that has nodes with embedded JavaScript might have the following `embed` method:\n\n``` jsx\nfunctionembed(path, options){const node = path.node;\n  if (node.type === \"javascript\") {\n    return async (textToDoc) => {\n      return [\n        \"<script>\",\n        hardline,\n        await textToDoc(node.javaScriptCode, { parser: \"babel\" }),\n        hardline,\n        \"</script>\",\n      ];\n    };\n  }\n}\n```\n\nIf the [`--embedded-language-formatting`](options#embedded-language-formatting) option is set to `off`, the embedding step is entirely skipped, `embed` isn’t called, and all nodes are printed with the `print` method.\n\n#### (optional) `preprocess`\n\nThe `preprocess` method can process the AST from the parser before passing it into the `print` method.\n\n``` jsx\nfunctionpreprocess(ast:AST, options: Options): AST | Promise<AST>;\n```\n\n#### (optional) `getVisitorKeys`\n\nThis property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has [cycles](https://en.wikipedia.org/wiki/Cycle_(graph_theory)), such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.\n\nIts signature is:\n\n``` jsx\nfunctiongetVisitorKeys(node, nonTraversableKeys: Set<string>): string[];\n```\n\nThe default `getVisitorKeys`:\n\n``` jsx\nfunctiongetVisitorKeys(node, nonTraversableKeys){return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));\n}\n```\n\nThe second argument `nonTraversableKeys` is a set of common keys and keys that prettier used internal.\n\nIf you have full list of visitor keys\n\n``` jsx\nconst visitorKeys = {\n  Program: [\"body\"],\n  Identifier: [],\n  // ...\n};\n\nfunction getVisitorKeys(node /* , nonTraversableKeys*/) {\n  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`\n  return visitorKeys[node.type] ?? [];\n}\n```\n\nIf you only need exclude a small set of keys\n\n``` jsx\nconst ignoredKeys = new Set([\"prev\", \"next\", \"range\"]);\n\nfunction getVisitorKeys(node, nonTraversableKeys) {\n  return Object.keys(node).filter(\n    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),\n  );\n}\n```\n\n#### (optional) `insertPragma`\n\nA plugin can implement how a pragma comment is inserted in the resulting code when the `--insert-pragma` option is used, in the `insertPragma` function. Its signature is:\n\n``` jsx\nfunctioninsertPragma(text:string):string;\n```\n\n#### Handling comments in a printer\n\nComments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its `print` function or rely on Prettier's comment algorithm.\n\nBy default, if the AST has a top-level `comments` property, Prettier assumes that `comments` stores an array of comment nodes. Prettier will then use the provided `parsers[<plugin>].locStart`/`locEnd` functions to search for the AST node that each comment \"belongs\" to. Comments are then attached to these nodes **mutating the AST in the process**, and the `comments` property is deleted from the AST root. The `*Comment` functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the `printComment(path, options): Doc` function and insert the returned doc into the (hopefully) correct place.\n\n#### (optional) `getCommentChildNodes`\n\nBy default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:\n\n``` jsx\nfunctiongetCommentChildNodes(// The node whose children should be returned.\n  node: AST,\n  // Current options\n  options: object,\n): AST[] | undefined;\n```\n\nReturn `[]` if the node has no children or `undefined` to fall back on the default behavior.\n\n#### (optional) `printComment`\n\nCalled whenever a comment node needs to be printed. It has the signature:\n\n``` jsx\nfunctionprintComment(// Path to the current comment node\n  commentPath: AstPath,\n  // Current options\n  options: object,\n): Doc;\n```\n\n#### (optional) `canAttachComment`\n\n``` jsx\nfunctioncanAttachComment(node:AST):boolean;\n```\n\nThis function is used for deciding whether a comment can be attached to a particular AST node. By default, *all* AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like\n\n``` jsx\nfunctioncanAttachComment(node){return node.type && node.type !== \"comment\";\n}\n```\n\n#### (optional) `isBlockComment`\n\n``` jsx\nfunctionisBlockComment(node:AST):boolean;\n```\n\nReturns whether or not the AST node is a block comment.\n\n#### (optional) `handleComments`\n\nThe `handleComments` object contains three optional functions, each with signature\n\n``` jsx\n(// The AST node corresponding to the comment\n  comment: AST,\n  // The full source code text\n  text: string,\n  // The global options object\n  options: object,\n  // The AST\n  ast: AST,\n  // Whether this comment is the last comment\n  isLastComment: boolean,\n) => boolean;\n```\n\nThese functions are used to override Prettier's default comment attachment algorithm. `ownLine`/`endOfLine`/`remaining` is expected to either manually attach a comment to a node and return `true`, or return `false` and let Prettier attach the comment.\n\nBased on the text surrounding a comment node, Prettier dispatches:\n\n- `ownLine` if a comment has only whitespace preceding it and a newline afterwards,\n- `endOfLine` if a comment has a newline afterwards but some non-whitespace preceding it,\n- `remaining` in all other cases.\n\nAt the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of `enclosingNode`, `precedingNode`, or `followingNode`. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).\n\n#### Manually attaching a comment\n\nThe `util.addTrailingComment`/`addLeadingComment`/`addDanglingComment` functions can be used to manually attach a comment to an AST node. An example `ownLine` function that ensures a comment does not follow a \"punctuation\" node (made up for demonstration purposes) might look like:\n\n``` jsx\nimport{ util } from \"prettier\";\n\nfunction ownLine(comment, text, options, ast, isLastComment) {\n  const { precedingNode } = comment;\n  if (precedingNode && precedingNode.type === \"punctuation\") {\n    util.addTrailingComment(precedingNode, comment);\n    return true;\n  }\n  return false;\n}\n```\n\nNodes with comments are expected to have a `comments` property containing an array of comments. Each comment is expected to have the following properties: `leading`, `trailing`, `printed`.\n\nThe example above uses `util.addTrailingComment`, which automatically sets `comment.leading`/`trailing`/`printed` to appropriate values and adds the comment to the AST node's `comments` array.\n\nThe `--debug-print-comments` CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (`ownLine`/`endOfLine`/`remaining`, `leading`/`trailing`/`dangling`) and to which node it was attached. For Prettier’s built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).\n\n### `options`\n\n`options` is an object containing the custom options your plugin supports.\n\nExample:\n\n``` jsx\n      export\n      default\n      {\n      // ... plugin implementation\n      options\n      :\n      {\n      openingBraceNewLine\n      :\n      {\n      type\n      :\n      \"boolean\"\n      ,\n      category\n      :\n      \"Global\"\n      ,\n      default\n      :\n      true\n      ,\n      description\n      :\n      \"Move open brace for code blocks onto new line.\"\n      ,\n      }\n      ,\n      }\n      ,\n      }\n      ;\n    \n```\n\n### `defaultOptions`\n\nIf your plugin requires different default values for some of Prettier’s core options, you can specify them in `defaultOptions`:\n\n``` jsx\n      export\n      default\n      {\n      // ... plugin implementation\n      defaultOptions\n      :\n      {\n      tabWidth\n      :\n      4\n      ,\n      }\n      ,\n      }\n      ;\n    \n```\n\n### Utility functions\n\nA `util` module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the `util-shared` module provides the following limited set of utility functions for plugins:\n\n``` jsx\ntypeQuote='\"'|\"'\";typeSkipOptions={ backwards?: boolean };\n\nfunction getMaxContinuousCount(text: string, searchString: string): number;\n\nfunction getStringWidth(text: string): number;\n\nfunction getAlignmentSize(\n  text: string,\n  tabWidth: number,\n  startIndex?: number,\n): number;\n\nfunction getIndentSize(value: string, tabWidth: number): number;\n\nfunction skip(\n  characters: string | RegExp,\n): (\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n) => number | false;\n\nfunction skipWhitespace(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipSpaces(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipToLineEnd(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipEverythingButNewLine(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipInlineComment(\n  text: string,\n  startIndex: number | false,\n): number | false;\n\nfunction skipTrailingComment(\n  text: string,\n  startIndex: number | false,\n): number | false;\n\nfunction skipNewline(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction hasNewline(\n  text: string,\n  startIndex: number,\n  options?: SkipOptions,\n): boolean;\n\nfunction hasNewlineInRange(\n  text: string,\n  startIndex: number,\n  startIndex: number,\n): boolean;\n\nfunction hasSpaces(\n  text: string,\n  startIndex: number,\n  options?: SkipOptions,\n): boolean;\n\nfunction makeString(\n  rawText: string,\n  enclosingQuote: Quote,\n  unescapeUnnecessaryEscapes?: boolean,\n): string;\n\nfunction getNextNonSpaceNonCommentCharacter(\n  text: string,\n  startIndex: number,\n): string;\n\nfunction getNextNonSpaceNonCommentCharacterIndex(\n  text: string,\n  startIndex: number,\n): number | false;\n\nfunction isNextLineEmpty(text: string, startIndex: number): boolean;\n\nfunction isPreviousLineEmpty(text: string, startIndex: number): boolean;\n```\n\n### Tutorials\n\n- [How to write a plugin for Prettier](https://medium.com/@fvictorio/how-to-write-a-plugin-for-prettier-a0d98c845e70): Teaches you how to write a very basic Prettier plugin for TOML.\n\n&nbsp;"
- name: Disclaimer about non-standard syntax
  id: rationale#disclaimer-about-non-standard-syntax
  summary: Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification
  belongs_to: Rationale
  description: |-
    ## Disclaimer about non-standard syntax

    Prettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.
- name: Easy to adopt
  id: why-prettier#easy-to-adopt
  summary: We've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience
  belongs_to: Why Prettier?
  description: |-
    ## Easy to adopt

    We've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience. When you're ready to push Prettier into your codebase, not only should it be painless for you to do it technically but the newly formatted codebase should not generate major controversy and be accepted painlessly by your co-workers.

    - “It’s low overhead. We were able to throw Prettier at very different kinds of repos without much work.”
    - “It’s been mostly bug free. Had there been major styling issues during the course of implementation we would have been wary about throwing this at our JS codebase. I’m happy to say that’s not the case.”
    - “Everyone runs it as part of their pre commit scripts, a couple of us use the editor on save extensions as well.”
    - “It’s fast, against one of our larger JS codebases we were able to run Prettier in under 13 seconds.”
    - “The biggest benefit for Prettier for us was being able to format the entire code base at once.”

    &nbsp;
- name: Editor Integration
  id: editors
  summary: To get the most out of Prettier, it’s recommended to run it from your editor
  description: "# Editor Integration\n\nTo get the most out of Prettier, it’s recommended to run it from your editor.\n\nIf your editor does not support Prettier, you can instead [run Prettier with a file watcher](watching-files).\n\n**Note!** It’s important to [install](install) Prettier locally in every project, so each project gets the correct Prettier version.\n\n## Visual Studio Code\n\n`prettier-vscode` can be installed using the extension sidebar – it’s called “Prettier - Code formatter.” [Check its repository for configuration and shortcuts](https://github.com/prettier/prettier-vscode).\n\nIf you’d like to toggle the formatter on and off, install [`vscode-status-bar-format-toggle`](https://marketplace.visualstudio.com/items?itemName=tombonnike.vscode-status-bar-format-toggle).\n\n## Emacs\n\nCheck out the [prettier-emacs](https://github.com/prettier/prettier-emacs) repo, or [prettier.el](https://github.com/jscheid/prettier.el). The package [Apheleia](https://github.com/raxod502/apheleia) supports multiple code formatters, including Prettier.\n\n## Vim\n\n[vim-prettier](https://github.com/prettier/vim-prettier) is a Prettier-specific Vim plugin. [Neoformat](https://github.com/sbdchd/neoformat), [ALE](https://github.com/w0rp/ale), and [coc-prettier](https://github.com/neoclide/coc-prettier) are multi-language Vim linter/formatter plugins that support Prettier.\n\nFor more details see [the Vim setup guide](vim).\n\n## Helix\n\nA formatter can be specified in your [Helix language configuration](https://docs.helix-editor.com/languages.html#language-configuration), which will take precedence over any language servers.\n\nFor more details see the [Helix external binary formatter configuration for Prettier](https://github.com/helix-editor/helix/wiki/External-formatter-configuration#prettier).\n\n## Sublime Text\n\nSublime Text support is available through Package Control and the [JsPrettier](https://packagecontrol.io/packages/JsPrettier) plug-in.\n\n## JetBrains WebStorm, PHPStorm, PyCharm...\n\nSee the [WebStorm setup guide](webstorm).\n\n## Visual Studio\n\nInstall the [JavaScript Prettier extension](https://github.com/madskristensen/JavaScriptPrettier).\n\n## Atom\n\nAtom users can install the [prettier-atom](https://github.com/prettier/prettier-atom) package, or one of the more minimalistic [mprettier](https://github.com/t9md/atom-mprettier) and [miniprettier](https://github.com/duailibe/atom-miniprettier) packages.\n\n## Espresso\n\nEspresso users can install the [espresso-prettier](https://github.com/eablokker/espresso-prettier) plugin.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/editors](https://prettier.io/docs/en/editors)"
- name: EditorConfig
  id: configuration#editorconfig
  summary: If a .editorconfig file is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration
  belongs_to: Configuration File
  description: "## EditorConfig\n\nIf a [`.editorconfig` file](https://editorconfig.org/) is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by `.prettierrc`, etc.\n\nHere’s an annotated description of how different properties map to Prettier’s behavior:\n\n``` jsx\n# Stop the editor from looking for .editorconfig files in the parent directories# root = true[*]# Non-configurable Prettier behaviorscharset = utf-8\ninsert_final_newline = true\n# Caveat: Prettier won’t trim trailing whitespace inside template strings, but your editor might.\n# trim_trailing_whitespace = true\n\n# Configurable Prettier behaviors\n# (change these if your Prettier config differs)\nend_of_line = lf\nindent_style = space\nindent_size = 2\nmax_line_length = 80\n```\n\nHere’s a copy+paste-ready `.editorconfig` file if you use the default options:\n\n``` jsx\n[*]charset = utf-8\ninsert_final_newline = true\nend_of_line = lf\nindent_style = space\nindent_size = 2\nmax_line_length = 80\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/configuration](https://prettier.io/docs/en/configuration)"
- name: Emacs
  id: editors#emacs
  summary: Check out the prettier-emacs repo, or prettier.el
  belongs_to: Editor Integration
  description: |-
    ## Emacs

    Check out the [prettier-emacs](https://github.com/prettier/prettier-emacs) repo, or [prettier.el](https://github.com/jscheid/prettier.el). The package [Apheleia](https://github.com/raxod502/apheleia) supports multiple code formatters, including Prettier.
- name: Embedded Language Formatting
  id: options#embedded-language-formatting
  summary: Control whether Prettier formats quoted code embedded in the file
  belongs_to: Options
  description: |-
    ## Embedded Language Formatting

    *First available in v2.1.0*

    Control whether Prettier formats quoted code embedded in the file.

    When Prettier identifies cases where it looks like you've placed some code it knows how to format within a string in another file, like in a tagged template in JavaScript with a tag named `html` or in code blocks in Markdown, it will by default try to format that code.

    Sometimes this behavior is undesirable, particularly in cases where you might not have intended the string to be interpreted as code. This option allows you to switch between the default behavior (`auto`) and disabling this feature entirely (`off`).

    Valid options:

    - `"auto"` – Format embedded code if Prettier can automatically identify it.
    - `"off"` - Never automatically format embedded code.

    | Default  | CLI Override                                | API Override                               |
    |----------|---------------------------------------------|--------------------------------------------|
    | `"auto"` | `--embedded-language-formatting=<off|auto>` | `embeddedLanguageFormatting: "<off|auto>"` |
- name: End of Line
  id: options#end-of-line
  summary: For historical reasons, there exist two common flavors of line endings in text files
  belongs_to: Options
  description: |-
    ## End of Line

    *First available in v1.15.0, default value changed from `auto` to `lf` in v2.0.0*

    For historical reasons, there exist two common flavors of line endings in text files. That is `\n` (or `LF` for *Line Feed*) and `\r\n` (or `CRLF` for *Carriage Return + Line Feed*). The former is common on Linux and macOS, while the latter is prevalent on Windows. Some details explaining why it is so [can be found on Wikipedia](https://en.wikipedia.org/wiki/Newline).

    When people collaborate on a project from different operating systems, it becomes easy to end up with mixed line endings in a shared git repository. It is also possible for Windows users to accidentally change line endings in a previously committed file from `LF` to `CRLF`. Doing so produces a large `git diff` and thus makes the line-by-line history for a file (`git blame`) harder to explore.

    If you want to make sure that your entire git repository only contains Linux-style line endings in files covered by Prettier:

    1.  Ensure Prettier’s `endOfLine` option is set to `lf` (this is a default value since v2.0.0)
    2.  Configure [a pre-commit hook](precommit) that will run Prettier
    3.  Configure Prettier to run in your CI pipeline using [`--check` flag](cli#--check). If you use Travis CI, set [the `autocrlf` option](https://docs.travis-ci.com/user/customizing-the-build#git-end-of-line-conversion-control) to `input` in `.travis.yml`.
    4.  Add `* text=auto eol=lf` to the repo’s `.gitattributes` file. You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted `LF` to `CRLF` on checkout.

    All modern text editors in all operating systems are able to correctly display line endings when `\n` (`LF`) is used. However, old versions of Notepad for Windows will visually squash such lines into one as they can only deal with `\r\n` (`CRLF`).

    Valid options:

    - `"lf"` – Line Feed only (`\n`), common on Linux and macOS as well as inside git repos
    - `"crlf"` - Carriage Return + Line Feed characters (`\r\n`), common on Windows
    - `"cr"` - Carriage Return character only (`\r`), used very rarely
    - `"auto"` - Maintain existing line endings (mixed values within one file are normalised by looking at what’s used after the first line)

    | Default | CLI Override                      | API Override                     |
    |---------|-----------------------------------|----------------------------------|
    | `"lf"`  | `--end-of-line <lf|crlf|cr|auto>` | `endOfLine: "<lf|crlf|cr|auto>"` |

    Setting `end_of_line` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s end of line usage, unless overridden.
- name: ESLint (and other linters)
  id: install#eslint-and-other-linters
  summary: If you use ESLint, install eslint-config-prettier to make ESLint and Prettier play nice with each other
  belongs_to: Install
  description: |-
    ## ESLint (and other linters)

    If you use ESLint, install [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier#installation) to make ESLint and Prettier play nice with each other. It turns off all ESLint rules that are unnecessary or might conflict with Prettier. There’s a similar config for Stylelint: [stylelint-config-prettier](https://github.com/prettier/stylelint-config-prettier)

    (See [Prettier vs. Linters](comparison) to learn more about formatting vs linting, [Integrating with Linters](integrating-with-linters) for more in-depth information on configuring your linters, and [Related projects](related-projects) for even more integration possibilities, if needed.)
- name: ESLint Integrations
  id: related-projects#eslint-integrations
  summary: null
  belongs_to: Related Projects
  description: |-
    ## ESLint Integrations

    - [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) turns off all ESLint rules that are unnecessary or might conflict with Prettier
    - [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier) runs Prettier as an ESLint rule and reports differences as individual ESLint issues
    - [prettier-eslint](https://github.com/prettier/prettier-eslint) passes `prettier` output to `eslint --fix`
    - [prettier-standard](https://github.com/sheerun/prettier-standard) uses `prettierx` and `prettier-eslint` to format code with `standard` rules
- name: Espresso
  id: editors#espresso
  summary: Espresso users can install the espresso-prettier plugin
  belongs_to: Editor Integration
  description: "## Espresso\n\nEspresso users can install the [espresso-prettier](https://github.com/eablokker/espresso-prettier) plugin.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/editors](https://prettier.io/docs/en/editors)"
- name: Experimental Ternaries
  id: options#experimental-ternaries
  summary: Try prettier's new ternary formatting before it becomes the default behavior
  belongs_to: Options
  description: |-
    ## Experimental Ternaries

    Try prettier's [new ternary formatting](https://github.com/prettier/prettier/pull/13183) before it becomes the default behavior.

    Valid options:

    - `true` - Use curious ternaries, with the question mark after the condition.
    - `false` - Retain the default behavior of ternaries; keep question marks on the same line as the consequent.

    | Default | CLI Override               | API Override                    |
    |---------|----------------------------|---------------------------------|
    | `false` | `--experimental-ternaries` | `experimentalTernaries: <bool>` |
- name: File Path
  id: options#file-path
  summary: Specify the file name to use to infer which parser to use
  belongs_to: Options
  description: |-
    ## File Path

    Specify the file name to use to infer which parser to use.

    For example, the following will use the CSS parser:

    ``` jsx
    cat foo | prettier --stdin-filepath foo.css
    ```

    This option is only useful in the CLI and API. It doesn’t make sense to use it in a configuration file.

    | Default | CLI Override                | API Override           |
    |---------|-----------------------------|------------------------|
    | None    | `--stdin-filepath <string>` | `filepath: "<string>"` |
- name: File patterns
  id: cli#file-patterns
  summary: Given a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path
  belongs_to: CLI
  description: |-
    ## File patterns

    Given a list of paths/patterns, the Prettier CLI first treats every entry in it as a literal path.

    - If the path points to an existing file, Prettier CLI proceeds with that file and doesn’t resolve the path as a glob pattern.

    - If the path points to an existing directory, Prettier CLI recursively finds supported files in that directory. This resolution process is based on file extensions and well-known file names that Prettier and its [plugins](plugins) associate with supported languages.

    - Otherwise, the entry is resolved as a glob pattern using the [glob syntax from the `fast-glob` module](https://github.com/mrmlnc/fast-glob#pattern-syntax).

    Prettier CLI will ignore files located in `node_modules` directory. To opt out from this behavior, use `--with-node-modules` flag.

    Prettier CLI will not follow symbolic links when expanding arguments.

    To escape special characters in globs, one of the two escaping syntaxes can be used: `prettier "\[my-dir]/*.js"` or `prettier "[[]my-dir]/*.js"`. Both match all JS files in a directory named `[my-dir]`, however the latter syntax is preferable as the former doesn’t work on Windows, where backslashes are treated as path separators.
- name: For Enterprise
  id: for-enterprise
  summary: Tidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications
  description: "# For Enterprise\n\n## Available as part of the Tidelift Subscription\n\nTidelift is working with the maintainers of Prettier and thousands of other open source projects to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use.\n\n[Learn more](https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise) [Request a demo](https://tidelift.com/subscription/request-a-demo?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise)\n\n  \n\n### Enterprise-ready open source software—managed for you\n\nThe Tidelift Subscription is a managed open source subscription for application dependencies covering millions of open source projects across JavaScript, Python, Java, PHP, Ruby, .NET, and more.\n\nYour subscription includes:\n\n**Security updates**\n\nTidelift’s security response team coordinates patches for new breaking security vulnerabilities and alerts immediately through a private channel, so your software supply chain is always secure.\n\n**Licensing verification and indemnification**\n\nTidelift verifies license information to enable easy policy enforcement and adds intellectual property indemnification to cover creators and users in case something goes wrong. You always have a 100% up-to-date bill of materials for your dependencies to share with your legal team, customers, or partners.\n\n**Maintenance and code improvement**\n\nTidelift ensures the software you rely on keeps working as long as you need it to work. Your managed dependencies are actively maintained and we recruit additional maintainers where required.\n\n**Package selection and version guidance**\n\nWe help you choose the best open source packages from the start—and then guide you through updates to stay on the best releases as new issues arise.\n\n**Roadmap input**\n\nTake a seat at the table with the creators behind the software you use. Tidelift’s participating maintainers earn more income as their software is used by more subscribers, so they’re interested in knowing what you need.\n\n**Tooling and cloud integration**\n\nTidelift works with GitHub, GitLab, BitBucket, and more. We support every cloud platform (and other deployment targets, too).\n\nThe end result? All of the capabilities you expect from commercial-grade software, for the full breadth of open source you use. That means less time grappling with esoteric open source trivia, and more time building your own applications—and your business.\n\n[Learn more](https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise) [Request a demo](https://tidelift.com/subscription/request-a-demo?utm_source=npm-prettier&utm_medium=referral&utm_campaign=enterprise)\n\n© James Long and contributors  \n[https://prettier.io/docs/en/for-enterprise](https://prettier.io/docs/en/for-enterprise)"
- name: Forks
  id: related-projects#forks
  summary: null
  belongs_to: Related Projects
  description: |-
    ## Forks

    - [prettierx](https://github.com/brodybits/prettierx) less opinionated fork of Prettier

    &nbsp;
- name: Git hooks
  id: install#git-hooks
  summary: In addition to running Prettier from the command line (prettier --write), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well
  belongs_to: Install
  description: |-
    ## Git hooks

    In addition to running Prettier from the command line (`prettier --write`), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well. This makes sure all your commits are formatted, without having to wait for your CI build to finish.

    For example, you can do the following to have Prettier run before each commit:

    1.  Install [husky](https://github.com/typicode/husky) and [lint-staged](https://github.com/okonet/lint-staged):

    npm

    yarn

    pnpm

    bun

    ``` jsx
    npm install --save-dev husky lint-staged
    npx husky init
    node --eval "fs.writeFileSync('.husky/pre-commit','npx lint-staged\n')"
    ```

    ``` jsx
    yarn add --dev husky lint-staged
    npx husky init
    node --eval "fs.writeFileSync('.husky/pre-commit','npx lint-staged\n')"
    ```

    > If you use Yarn 2, see <https://typicode.github.io/husky/#/?id=yarn-2>

    ``` jsx
    pnpm add --save-dev husky lint-staged
    npx husky init
    node --eval "fs.writeFileSync('.husky/pre-commit','pnpm exec lint-staged\n')"
    ```

    ``` jsx
    bun add --dev husky lint-staged
    bunx husky init
    bun --eval "fs.writeFileSync('.husky/pre-commit','bunx lint-staged\n')"
    ```

    2.  Add the following to your `package.json`:

    ``` jsx
    {
      "lint-staged": {
        "**/*": "prettier --write --ignore-unknown"
      }
    }
    ```

    > Note: If you use ESLint, make sure lint-staged runs it before Prettier, not after.

    See [Pre-commit Hook](precommit) for more information.
- name: GraphQL
  id: ignore#graphql
  summary: null
  belongs_to: Ignoring Code
  description: |-
    ## GraphQL

    ``` jsx
    {
      # prettier-ignore
      addReaction(input:{superLongInputFieldName:"MDU6SXNzdWUyMzEzOTE1NTE=",content:HOORAY}) {
        reaction {content}
      }
    }
    ```
- name: Handlebars
  id: ignore#handlebars
  summary: null
  belongs_to: Ignoring Code
  description: "## Handlebars\n\n``` jsx\n      {{! prettier-ignore }}\n      <div>\n  \"hello! my parent was ignored\"\n  \n      {{#my-crazy-component     \"shall\"     be=\"preserved\"}}\n      \n        <This\n      is  =  \"also preserved as is\"\n    />\n      \n      {{/my-crazy-component}}\n      \n        </div>\n      \n    \n```"
- name: Helix
  id: editors#helix
  summary: A formatter can be specified in your Helix language configuration, which will take precedence over any language servers
  belongs_to: Editor Integration
  description: |-
    ## Helix

    A formatter can be specified in your [Helix language configuration](https://docs.helix-editor.com/languages.html#language-configuration), which will take precedence over any language servers.

    For more details see the [Helix external binary formatter configuration for Prettier](https://github.com/helix-editor/helix/wiki/External-formatter-configuration#prettier).
- name: Helping Newcomers
  id: why-prettier#helping-newcomers
  summary: Prettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase
  belongs_to: Why Prettier?
  description: |-
    ## Helping Newcomers

    Prettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase. One may think that it’s only useful for people with very limited programming experience, but we've seen it quicken the ramp up time from experienced engineers joining the company, as they likely used a different coding style before, and developers coming from a different programming language.

    - “My motivations for using Prettier are: appearing that I know how to write JavaScript well.”
    - “I always put spaces in the wrong place, now I don’t have to worry about it anymore.”
    - “When you're a beginner you're making a lot of mistakes caused by the syntax. Thanks to Prettier, you can reduce these mistakes and save a lot of time to focus on what really matters.”
    - “As a teacher, I will also tell to my students to install Prettier to help them to learn the JS syntax and have readable files.”

    &nbsp;
- name: How does it compare to ESLint/TSLint/stylelint, etc.?
  id: comparison#how-does-it-compare-to-eslinttslintstylelint-etc
  summary: Prettier does nothing to help with those kind of rules
  belongs_to: Prettier vs. Linters
  description: "## How does it compare to ESLint/TSLint/stylelint, etc.?\n\nLinters have two categories of rules:\n\n**Formatting rules**: eg: [max-len](https://eslint.org/docs/rules/max-len), [no-mixed-spaces-and-tabs](https://eslint.org/docs/rules/no-mixed-spaces-and-tabs), [keyword-spacing](https://eslint.org/docs/rules/keyword-spacing), [comma-style](https://eslint.org/docs/rules/comma-style)…\n\nPrettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it’s not possible for the programmer to make a mistake there anymore :)\n\n**Code-quality rules**: eg [no-unused-vars](https://eslint.org/docs/rules/no-unused-vars), [no-extra-bind](https://eslint.org/docs/rules/no-extra-bind), [no-implicit-globals](https://eslint.org/docs/rules/no-implicit-globals), [prefer-promise-reject-errors](https://eslint.org/docs/rules/prefer-promise-reject-errors)…\n\nPrettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!\n\nIn other words, use **Prettier for formatting** and **linters for catching bugs!**\n\n© James Long and contributors  \n[https://prettier.io/docs/en/comparison](https://prettier.io/docs/en/comparison)"
- name: HTML
  id: ignore#html
  summary: null
  belongs_to: Ignoring Code
  description: |-
    ## HTML

    ``` jsx
    <!-- prettier-ignore --><divclass="x">hello world</div><!-- prettier-ignore-attribute --><div(mousedown)="       onStart    (    )         "(mouseup)="         onEnd      (    )         "></div><!-- prettier-ignore-attribute (mouseup) --><div(mousedown)="onStart()"(mouseup)="         onEnd      (    )         "></div>
    ```
- name: HTML Whitespace Sensitivity
  id: options#html-whitespace-sensitivity
  summary: First available in v1.15.0
  belongs_to: Options
  description: |-
    ## HTML Whitespace Sensitivity

    *First available in v1.15.0. First available for Handlebars in 2.3.0*

    Specify the global whitespace sensitivity for HTML, Vue, Angular, and Handlebars. See [whitespace-sensitive formatting](https://prettier.io/blog/2018/11/07/1.15.0#whitespace-sensitive-formatting) for more info.

    Valid options:

    - `"css"` - Respect the default value of CSS `display` property. For Handlebars treated same as `strict`.
    - `"strict"` - Whitespace (or the lack of it) around all tags is considered significant.
    - `"ignore"` - Whitespace (or the lack of it) around all tags is considered insignificant.

    | Default | CLI Override                                        | API Override                                       |
    |---------|-----------------------------------------------------|----------------------------------------------------|
    | `"css"` | `--html-whitespace-sensitivity <css|strict|ignore>` | `htmlWhitespaceSensitivity: "<css|strict|ignore>"` |
- name: Ignoring Code
  id: ignore
  summary: Use .prettierignore to ignore (i.e
  description: "# Ignoring Code\n\nUse `.prettierignore` to ignore (i.e. not reformat) certain files and folders completely.\n\nUse “prettier-ignore” comments to ignore parts of files.\n\n## Ignoring Files: .prettierignore\n\nTo exclude files from formatting, create a `.prettierignore` file in the root of your project. `.prettierignore` uses [gitignore syntax](https://git-scm.com/docs/gitignore#_pattern_format).\n\nExample:\n\n``` jsx\n# Ignore artifacts:\nbuild\ncoverage\n\n# Ignore all HTML files:\n**/*.html\n```\n\nIt’s recommended to have a `.prettierignore` in your project! This way you can run `prettier --write .` to make sure that everything is formatted (without mangling files you don’t want, or choking on generated files). And – your editor will know which files *not* to format!\n\nBy default prettier ignores files in version control systems directories (\".git\", \".sl\", \".svn\" and \".hg\") and `node_modules` (unless the [`--with-node-modules` CLI option](cli#--with-node-modules) is specified). Prettier will also follow rules specified in the \".gitignore\" file if it exists in the same directory from which it is run.\n\nSo by default it will be\n\n``` jsx\n**/.git\n**/.svn\n**/.hg\n**/node_modules\n```\n\nand\n\n``` jsx\n**/.git\n**/.svn\n**/.hg\n```\n\nif [`--with-node-modules` CLI option](cli#--with-node-modules) provided\n\n(See also the [`--ignore-path` CLI option](cli#--ignore-path).)\n\n## JavaScript\n\nA JavaScript comment of `// prettier-ignore` will exclude the next node in the abstract syntax tree from formatting.\n\nFor example:\n\n``` jsx\nmatrix(\n  1, 0, 0,\n  0, 1, 0,\n  0, 0, 1\n)\n\n// prettier-ignore\nmatrix(\n  1, 0, 0,\n  0, 1, 0,\n  0, 0, 1\n)\n```\n\nwill be transformed to:\n\n``` jsx\nmatrix(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n// prettier-ignore\nmatrix(\n  1, 0, 0,\n  0, 1, 0,\n  0, 0, 1\n)\n```\n\n## JSX\n\n``` jsx\n<div>{/* prettier-ignore */}<span     ugly  format=''   /></div>\n```\n\n## HTML\n\n``` jsx\n<!-- prettier-ignore -->\n<div         class=\"x\"       >hello world</div            >\n\n<!-- prettier-ignore-attribute -->\n<div\n  (mousedown)=\"       onStart    (    )         \"\n  (mouseup)=\"         onEnd      (    )         \"\n></div>\n\n<!-- prettier-ignore-attribute (mouseup) -->\n<div\n  (mousedown)=\"onStart()\"\n  (mouseup)=\"         onEnd      (    )         \"\n></div>\n```\n\n## CSS\n\n``` jsx\n/* prettier-ignore */\n.my    ugly rule\n{\n\n}\n```\n\n## Markdown\n\n``` jsx\n<!-- prettier-ignore -->\nDo   not    format   this\n```\n\n### Range Ignore\n\n*available in v1.12.0+*\n\nThis type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g. [`all-contributors`](https://github.com/kentcdodds/all-contributors), [`markdown-toc`](https://github.com/jonschlinkert/markdown-toc), etc.\n\n``` jsx\n<!-- prettier-ignore-start -->\n<!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->\n\n| MY | AWESOME | AUTO-GENERATED | TABLE |\n|-|-|-|-|\n| a | b | c | d |\n\n<!-- SOMETHING AUTO-GENERATED BY TOOLS - END -->\n<!-- prettier-ignore-end -->\n```\n\n## YAML\n\nTo ignore a part of a YAML file, `# prettier-ignore` should be placed on the line immediately above the ignored node:\n\n``` jsx\n# prettier-ignore\nkey  : value\nhello: world\n```\n\n## GraphQL\n\n``` jsx\n{\n  # prettier-ignore\n  addReaction(input:{superLongInputFieldName:\"MDU6SXNzdWUyMzEzOTE1NTE=\",content:HOORAY}) {\n    reaction {content}\n  }\n}\n```\n\n## Handlebars\n\n``` jsx\n{{! prettier-ignore }}\n<div>\n  \"hello! my parent was ignored\"\n  {{#my-crazy-component     \"shall\"     be=\"preserved\"}}\n    <This\n      is  =  \"also preserved as is\"\n    />\n  {{/my-crazy-component}}\n</div>\n```\n\n## Command Line File Patterns\n\nFor one-off commands, when you want to exclude some files without adding them to `.prettierignore`, negative patterns can come in handy:\n\n``` jsx\nprettier . \"!**/*.{js,jsx,vue}\" --write\n```\n\nSee [fast-glob](cli#file-patterns) to learn more about advanced glob syntax.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/ignore](https://prettier.io/docs/en/ignore)"
- name: 'Ignoring Files: .prettierignore'
  id: ignore#ignoring-files-prettierignore
  summary: To exclude files from formatting, create a .prettierignore file in the root of your project
  belongs_to: Ignoring Code
  description: |-
    ## Ignoring Files: .prettierignore

    To exclude files from formatting, create a `.prettierignore` file in the root of your project. `.prettierignore` uses [gitignore syntax](https://git-scm.com/docs/gitignore#_pattern_format).

    Example:

    ``` jsx
    # Ignore artifacts:
    build
    coverage

    # Ignore all HTML files:
    **/*.html
    ```

    It’s recommended to have a `.prettierignore` in your project! This way you can run `prettier --write .` to make sure that everything is formatted (without mangling files you don’t want, or choking on generated files). And – your editor will know which files *not* to format!

    By default prettier ignores files in version control systems directories (".git", ".sl", ".svn" and ".hg") and `node_modules` (unless the [`--with-node-modules` CLI option](cli#--with-node-modules) is specified). Prettier will also follow rules specified in the ".gitignore" file if it exists in the same directory from which it is run.

    So by default it will be

    ``` jsx
    **/.git
    **/.svn
    **/.hg
    **/node_modules
    ```

    and

    ``` jsx
    **/.git
    **/.svn
    **/.hg
    ```

    if [`--with-node-modules` CLI option](cli#--with-node-modules) provided

    (See also the [`--ignore-path` CLI option](cli#--ignore-path).)
- name: Insert Pragma
  id: options#insert-pragma
  summary: Prettier can insert a special @format marker at the top of files specifying that the file has been formatted with Prettier
  belongs_to: Options
  description: |-
    ## Insert Pragma

    *First available in v1.8.0*

    Prettier can insert a special `@format` marker at the top of files specifying that the file has been formatted with Prettier. This works well when used in tandem with the `--require-pragma` option. If there is already a docblock at the top of the file then this option will add a newline to it with the `@format` marker.

    Note that “in tandem” doesn’t mean “at the same time”. When the two options are used simultaneously, `--require-pragma` has priority, so `--insert-pragma` is ignored. The idea is that during an incremental adoption of Prettier in a big codebase, the developers participating in the transition process use `--insert-pragma` whereas `--require-pragma` is used by the rest of the team and automated tooling to process only files already transitioned. The feature has been inspired by Facebook’s [adoption strategy](https://prettier.io/blog/2017/05/03/1.3.0#facebook-adoption-update).

    | Default | CLI Override      | API Override           |
    |---------|-------------------|------------------------|
    | `false` | `--insert-pragma` | `insertPragma: <bool>` |
- name: Install
  id: install
  summary: Next, create a .prettierignore file to let the Prettier CLI and editors know which files to not format
  description: "# Install\n\nFirst, install Prettier locally:\n\nnpm\n\nyarn\n\npnpm\n\nbun\n\n``` jsx\nnpm install --save-dev --save-exact prettier\n```\n\n``` jsx\nyarn add --dev --exact prettier\n```\n\n``` jsx\npnpm add --save-dev --save-exact prettier\n```\n\n``` jsx\nbun add --dev --exact prettier\n```\n\nThen, create an empty config file to let editors and other tools know you are using Prettier:\n\n``` jsx\nnode --eval \"fs.writeFileSync('.prettierrc','{}\\n')\"\n```\n\nNext, create a [.prettierignore](ignore) file to let the Prettier CLI and editors know which files to *not* format. Here’s an example:\n\n``` jsx\nnode --eval \"fs.writeFileSync('.prettierignore','# Ignore artifacts:\\nbuild\\ncoverage\\n')\"\n```\n\n> Tip! Prettier will follow rules specified in .gitignore if it exists in the same directory from which it is run. You can also base your .prettierignore on .eslintignore (if you have one).\n\n> Another tip! If your project isn’t ready to format, say, HTML files yet, add `*.html`.\n\nNow, format all files with Prettier:\n\nnpm\n\nyarn\n\npnpm\n\nbun\n\n``` jsx\nnpx prettier . --write\n```\n\n> What is that `npx` thing? `npx` ships with `npm` and lets you run locally installed tools. We’ll leave off the `npx` part for brevity throughout the rest of this file!\n>\n> Note: If you forget to install Prettier first, `npx` will temporarily download the latest version. That’s not a good idea when using Prettier, because we change how code is formatted in each release! It’s important to have a locked down version of Prettier in your `package.json`. And it’s faster, too.\n\n``` jsx\nyarn prettier . --write\n```\n\n> What is `yarn` doing at the start? `yarn prettier` runs the locally installed version of Prettier. We’ll leave off the `yarn` part for brevity throughout the rest of this file!\n\n``` jsx\npnpm exec prettier . --write\n```\n\n> What is `pnpm` doing at the start? `pnpm prettier` runs the locally installed version of Prettier. We’ll leave off the `pnpm` part for brevity throughout the rest of this file!\n\n``` jsx\nbun prettier . --write\n```\n\n> What is `bun` doing at the start? `bun prettier` runs the locally installed version of Prettier. We’ll leave off the `bun` part for brevity throughout the rest of this file!\n\n`prettier --write .` is great for formatting everything, but for a big project it might take a little while. You may run `prettier --write app/` to format a certain directory, or `prettier --write app/components/Button.js` to format a certain file. Or use a *glob* like `prettier --write \"app/**/*.test.js\"` to format all tests in a directory (see [fast-glob](https://github.com/mrmlnc/fast-glob#pattern-syntax) for supported glob syntax).\n\nIf you have a CI setup, run the following as part of it to make sure that everyone runs Prettier. This avoids merge conflicts and other collaboration issues!\n\n``` jsx\nnpx prettier . --check\n```\n\n`--check` is like `--write`, but only checks that files are already formatted, rather than overwriting them. `prettier --write` and `prettier --check` are the most common ways to run Prettier.\n\n## Set up your editor\n\nFormatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file. When a line has gotten so long while coding that it won’t fit your screen, just hit a key and watch it magically be wrapped into multiple lines! Or when you paste some code and the indentation gets all messed up, let Prettier fix it up for you without leaving your editor.\n\nSee [Editor Integration](editors) for how to set up your editor. If your editor does not support Prettier, you can instead [run Prettier with a file watcher](watching-files).\n\n> **Note:** Don’t skip the regular local install! Editor plugins will pick up your local version of Prettier, making sure you use the correct version in every project. (You wouldn’t want your editor accidentally causing lots of changes because it’s using a newer version of Prettier than your project!)\n>\n> And being able to run Prettier from the command line is still a good fallback, and needed for CI setups.\n\n## ESLint (and other linters)\n\nIf you use ESLint, install [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier#installation) to make ESLint and Prettier play nice with each other. It turns off all ESLint rules that are unnecessary or might conflict with Prettier. There’s a similar config for Stylelint: [stylelint-config-prettier](https://github.com/prettier/stylelint-config-prettier)\n\n(See [Prettier vs. Linters](comparison) to learn more about formatting vs linting, [Integrating with Linters](integrating-with-linters) for more in-depth information on configuring your linters, and [Related projects](related-projects) for even more integration possibilities, if needed.)\n\n## Git hooks\n\nIn addition to running Prettier from the command line (`prettier --write`), checking formatting in CI, and running Prettier from your editor, many people like to run Prettier as a pre-commit hook as well. This makes sure all your commits are formatted, without having to wait for your CI build to finish.\n\nFor example, you can do the following to have Prettier run before each commit:\n\n1.  Install [husky](https://github.com/typicode/husky) and [lint-staged](https://github.com/okonet/lint-staged):\n\nnpm\n\nyarn\n\npnpm\n\nbun\n\n``` jsx\nnpm install --save-dev husky lint-staged\nnpx husky init\nnode --eval \"fs.writeFileSync('.husky/pre-commit','npx lint-staged\\n')\"\n```\n\n``` jsx\nyarn add --dev husky lint-staged\nnpx husky init\nnode --eval \"fs.writeFileSync('.husky/pre-commit','npx lint-staged\\n')\"\n```\n\n> If you use Yarn 2, see <https://typicode.github.io/husky/#/?id=yarn-2>\n\n``` jsx\npnpm add --save-dev husky lint-staged\nnpx husky init\nnode --eval \"fs.writeFileSync('.husky/pre-commit','pnpm exec lint-staged\\n')\"\n```\n\n``` jsx\nbun add --dev husky lint-staged\nbunx husky init\nbun --eval \"fs.writeFileSync('.husky/pre-commit','bunx lint-staged\\n')\"\n```\n\n2.  Add the following to your `package.json`:\n\n``` jsx\n{\n  \"lint-staged\": {\n    \"**/*\": \"prettier --write --ignore-unknown\"\n  }\n}\n```\n\n> Note: If you use ESLint, make sure lint-staged runs it before Prettier, not after.\n\nSee [Pre-commit Hook](precommit) for more information.\n\n## Summary\n\nTo summarize, we have learned to:\n\n- Install an exact version of Prettier locally in your project. This makes sure that everyone in the project gets the exact same version of Prettier. Even a patch release of Prettier can result in slightly different formatting, so you wouldn’t want different team members using different versions and formatting each other’s changes back and forth.\n- Add a `.prettierrc` to let your editor know that you are using Prettier.\n- Add a `.prettierignore` to let your editor know which files *not* to touch, as well as for being able to run `prettier --write .` to format the entire project (without mangling files you don’t want, or choking on generated files).\n- Run `prettier --check .` in CI to make sure that your project stays formatted.\n- Run Prettier from your editor for the best experience.\n- Use [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) to make Prettier and ESLint play nice together.\n- Set up a pre-commit hook to make sure that every commit is formatted.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/install](https://prettier.io/docs/en/install)"
- name: Integrating with Linters
  id: integrating-with-linters
  summary: Linters usually contain not only code quality rules, but also stylistic rules
  description: "# Integrating with Linters\n\nLinters usually contain not only code quality rules, but also stylistic rules. Most stylistic rules are unnecessary when using Prettier, but worse – they might conflict with Prettier! Use Prettier for code formatting concerns, and linters for code-quality concerns, as outlined in [Prettier vs. Linters](comparison).\n\nLuckily it’s easy to turn off rules that conflict or are unnecessary with Prettier, by using these pre-made configs:\n\n- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier)\n\nCheck out the above links for instructions on how to install and set things up.\n\n## Notes\n\nWhen searching for both Prettier and your linter on the Internet you’ll probably find more related projects. These are **generally not recommended,** but can be useful in certain circumstances.\n\nFirst, we have plugins that let you run Prettier as if it was a linter rule:\n\n- [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier)\n- [stylelint-prettier](https://github.com/prettier/stylelint-prettier)\n\nThese plugins were especially useful when Prettier was new. By running Prettier inside your linters, you didn’t have to set up any new infrastructure and you could re-use your editor integrations for the linters. But these days you can run `prettier --check .` and most editors have Prettier support.\n\nThe downsides of those plugins are:\n\n- You end up with a lot of red squiggly lines in your editor, which gets annoying. Prettier is supposed to make you forget about formatting – and not be in your face about it!\n- They are slower than running Prettier directly.\n- They’re yet one layer of indirection where things may break.\n\nFinally, we have tools that run `prettier` and then immediately lint files by running, for example, `eslint --fix` on them.\n\n- [prettier-eslint](https://github.com/prettier/prettier-eslint)\n- [prettier-stylelint](https://github.com/hugomrdias/prettier-stylelint)\n\nThose are useful if some aspect of Prettier’s output makes Prettier completely unusable to you. Then you can have for example `eslint --fix` fix that up for you. The downside is that these tools are much slower than just running Prettier.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/integrating-with-linters](https://prettier.io/docs/en/integrating-with-linters)"
- name: JavaScript
  id: ignore#javascript
  summary: A JavaScript comment of // prettier-ignore will exclude the next node in the abstract syntax tree from formatting
  belongs_to: Ignoring Code
  description: "## JavaScript\n\nA JavaScript comment of `// prettier-ignore` will exclude the next node in the abstract syntax tree from formatting.\n\nFor example:\n\n``` jsx\n      matrix\n      (\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      )\n      // prettier-ignore\n      matrix\n      (\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      )\n    \n```\n\nwill be transformed to:\n\n``` jsx\n      matrix\n      (\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      )\n      ;\n      // prettier-ignore\n      matrix\n      (\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      ,\n      0\n      ,\n      0\n      ,\n      0\n      ,\n      1\n      )\n    \n```"
- name: JetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)
  id: webstorm#jetbrains-ides-webstorm-intellij-idea-pycharm-etc
  summary: WebStorm comes with built-in support for Prettier
  belongs_to: WebStorm Setup
  description: "## JetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)\n\nWebStorm comes with built-in support for Prettier. If you’re using other JetBrains IDE like IntelliJ IDEA, PhpStorm, or PyCharm, make sure you have this [plugin](https://plugins.jetbrains.com/plugin/10456-prettier) installed and enabled in *Preferences / Settings \\| Plugins*.\n\nFirst, you need to install and configure Prettier. You can find instructions on how to do it [here](https://www.jetbrains.com/help/webstorm/prettier.html#ws_prettier_install).\n\nOnce it’s done, you can do a few things in your IDE. You can use the **Reformat with Prettier** action (*Opt+Shift+Cmd+P* on macOS or *Alt+Shift+Ctrl+P* on Windows and Linux) to format the selected code, a file, or a whole directory.\n\nYou can also configure WebStorm to run Prettier on save (*Cmd+S/Ctrl+S*) or use it as the default formatter (*Opt+Cmd+L/Ctrl+Alt+L*). For this, open *Preferences / Settings \\| Languages & Frameworks \\| JavaScript \\| Prettier* and tick the corresponding checkbox: **On save** and/or **On ‘Reformat Code’** action.\n\nBy default, WebStorm will apply formatting to all *.js, .ts, .jsx*, and *.tsx* files that you’ve edited in your project. To apply the formatting to other file types, or to limit formatting to files located only in specific directories, you can customize the default configuration by using [glob patterns](https://github.com/isaacs/node-glob).\n\nFor more information, see [WebStorm online help](https://www.jetbrains.com/help/webstorm/prettier.html).\n\n© James Long and contributors  \n[https://prettier.io/docs/en/webstorm](https://prettier.io/docs/en/webstorm)"
- name: JetBrains WebStorm, PHPStorm, PyCharm...
  id: editors#jetbrains-webstorm-phpstorm-pycharm
  summary: See the WebStorm setup guide
  belongs_to: Editor Integration
  description: |-
    ## JetBrains WebStorm, PHPStorm, PyCharm...

    See the [WebStorm setup guide](webstorm).
- name: JSX
  id: ignore#jsx
  summary: null
  belongs_to: Ignoring Code
  description: "## JSX\n\n``` jsx\n      \n        <div\n        >\n      \n      {\n      /* prettier-ignore */\n      }\n      \n        <span\n        ugly\n        format\n        \n          =\n          '\n          '\n        \n        />\n      \n      \n        </div\n        >\n      \n    \n```"
- name: JSX Quotes
  id: options#jsx-quotes
  summary: Use single quotes instead of double quotes in JSX
  belongs_to: Options
  description: |-
    ## JSX Quotes

    Use single quotes instead of double quotes in JSX.

    | Default | CLI Override         | API Override             |
    |---------|----------------------|--------------------------|
    | `false` | `--jsx-single-quote` | `jsxSingleQuote: <bool>` |
- name: Markdown
  id: ignore#markdown
  summary: This type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g
  belongs_to: Ignoring Code
  description: |-
    ## Markdown

    ``` jsx
    <!-- prettier-ignore -->
    Do   not    format   this
    ```

    ### Range Ignore

    *available in v1.12.0+*

    This type of ignore is only allowed to be used in top-level and aimed to disable formatting for auto-generated content, e.g. [`all-contributors`](https://github.com/kentcdodds/all-contributors), [`markdown-toc`](https://github.com/jonschlinkert/markdown-toc), etc.

    ``` jsx
    <!-- prettier-ignore-start --><!-- SOMETHING AUTO-GENERATED BY TOOLS - START -->

    | MY | AWESOME | AUTO-GENERATED | TABLE |
    |-|-|-|-|
    | a | b | c | d |

    <!-- SOMETHING AUTO-GENERATED BY TOOLS - END -->
    <!-- prettier-ignore-end -->
    ```
- name: Misc
  id: related-projects#misc
  summary: null
  belongs_to: Related Projects
  description: "## Misc\n\n- [parallel-prettier](https://github.com/microsoft/parallel-prettier) is an alternative CLI that formats files in parallel to speed up large projects\n- [prettier_d](https://github.com/josephfrazier/prettier_d.js) runs Prettier as a server to avoid Node.js startup delay\n- [pretty-quick](https://github.com/azz/pretty-quick) formats changed files with Prettier\n- [rollup-plugin-prettier](https://github.com/mjeanroy/rollup-plugin-prettier) allows you to use Prettier with Rollup\n- [jest-runner-prettier](https://github.com/keplersj/jest-runner-prettier) is Prettier as a Jest runner\n- [prettier-chrome](https://github.com/u3u/prettier-chrome) is an extension that runs Prettier in the browser\n- [spotless](https://github.com/diffplug/spotless) lets you run prettier from [gradle](https://github.com/diffplug/spotless/tree/main/plugin-gradle#prettier) or [maven](https://github.com/diffplug/spotless/tree/main/plugin-maven#prettier).\n- [csharpier](https://github.com/belav/csharpier) is a port of Prettier for C#\n- [reviewdog-action-prettier](https://github.com/EPMatt/reviewdog-action-prettier) runs Prettier in GitHub Actions CI/CD workflows\n\n© James Long and contributors  \n[https://prettier.io/docs/en/related-projects](https://prettier.io/docs/en/related-projects)"
- name: Neoformat
  id: vim#neoformathttpsgithubcomsbdchdneoformat
  summary: In order for Neoformat to use a project-local version of Prettier (i.e
  belongs_to: Vim Setup
  description: |-
    ## [Neoformat](https://github.com/sbdchd/neoformat)

    The best way to install Neoformat is with your favorite plugin manager for Vim, such as [vim-plug](https://github.com/junegunn/vim-plug):

    ``` jsx
    Plug 'sbdchd/neoformat'
    ```

    In order for Neoformat to use a project-local version of Prettier (i.e. to use `node_modules/.bin/prettier` instead of looking for `prettier` on `$PATH`), you must set the `neoformat_try_node_exe` option:

    ``` jsx
    letg:neoformat_try_node_exe = 1
    ```

    Run `:Neoformat` or `:Neoformat prettier` in a supported file to run Prettier.

    To have Neoformat run Prettier on save:

    ``` jsx
    autocmd BufWritePre *.js Neoformat
    ```

    You can also make Vim format your code more frequently, by setting an `autocmd` for other events. Here are a couple of useful ones:

    - `TextChanged`: after a change was made to the text in Normal mode
    - `InsertLeave`: when leaving Insert mode

    For example, you can format on both of the above events together with `BufWritePre` like this:

    ``` jsx
    autocmd BufWritePre,TextChanged,InsertLeave *.js Neoformat
    ```

    See `:help autocmd-events` in Vim for details.

    It’s recommended to use a [config file](configuration), but you can also add options in your `.vimrc`:

    ``` jsx
    autocmd FileType javascript setlocal formatprg=prettier\ --single-quote\ --trailing-comma\ es5
    " Use formatprg when available
    let g:neoformat_try_formatprg = 1
    ```

    Each space in Prettier options should be escaped with `\`.
- name: Notes
  id: integrating-with-linters#notes
  summary: When searching for both Prettier and your linter on the Internet you’ll probably find more related projects
  belongs_to: Integrating with Linters
  description: "## Notes\n\nWhen searching for both Prettier and your linter on the Internet you’ll probably find more related projects. These are **generally not recommended,** but can be useful in certain circumstances.\n\nFirst, we have plugins that let you run Prettier as if it was a linter rule:\n\n- [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier)\n- [stylelint-prettier](https://github.com/prettier/stylelint-prettier)\n\nThese plugins were especially useful when Prettier was new. By running Prettier inside your linters, you didn’t have to set up any new infrastructure and you could re-use your editor integrations for the linters. But these days you can run `prettier --check .` and most editors have Prettier support.\n\nThe downsides of those plugins are:\n\n- You end up with a lot of red squiggly lines in your editor, which gets annoying. Prettier is supposed to make you forget about formatting – and not be in your face about it!\n- They are slower than running Prettier directly.\n- They’re yet one layer of indirection where things may break.\n\nFinally, we have tools that run `prettier` and then immediately lint files by running, for example, `eslint --fix` on them.\n\n- [prettier-eslint](https://github.com/prettier/prettier-eslint)\n- [prettier-stylelint](https://github.com/hugomrdias/prettier-stylelint)\n\nThose are useful if some aspect of Prettier’s output makes Prettier completely unusable to you. Then you can have for example `eslint --fix` fix that up for you. The downside is that these tools are much slower than just running Prettier.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/integrating-with-linters](https://prettier.io/docs/en/integrating-with-linters)"
- name: Official Plugins
  id: plugins#official-plugins
  summary: null
  belongs_to: Plugins
  description: |-
    ## Official Plugins

    - [`@prettier/plugin-php`](https://github.com/prettier/plugin-php)
    - [`@prettier/plugin-pug`](https://github.com/prettier/plugin-pug) by [**@Shinigami92**](https://github.com/Shinigami92)
    - [`@prettier/plugin-ruby`](https://github.com/prettier/plugin-ruby)
    - [`@prettier/plugin-xml`](https://github.com/prettier/plugin-xml)
- name: Option 1. lint-staged
  id: precommit#option-1-lint-stagedhttpsgithubcomokonetlint-staged
  summary: 'Use Case: Useful for when you want to use other code quality tools along with Prettier (e.g'
  belongs_to: Pre-commit Hook
  description: |-
    ## Option 1. [lint-staged](https://github.com/okonet/lint-staged)

    **Use Case:** Useful for when you want to use other code quality tools along with Prettier (e.g. ESLint, Stylelint, etc.) or if you need support for partially staged files (`git add --patch`).

    *Make sure Prettier is installed and is in your [`devDependencies`](https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file) before you proceed.*

    ``` jsx
    npx mrm@2 lint-staged
    ```

    This will install [husky](https://github.com/typicode/husky) and [lint-staged](https://github.com/okonet/lint-staged), then add a configuration to the project’s `package.json` that will automatically format supported files in a pre-commit hook.

    Read more at the [lint-staged](https://github.com/okonet/lint-staged#configuration) repo.
- name: Option 2. Husky.Net
  id: precommit#option-2-huskynethttpsgithubcomalirezanethuskynet
  summary: 'Use Case: A dotnet solution to use Prettier along with other code quality tools (e.g'
  belongs_to: Pre-commit Hook
  description: |-
    ## Option 2. [Husky.Net](https://github.com/alirezanet/Husky.Net)

    **Use Case:** A dotnet solution to use Prettier along with other code quality tools (e.g. dotnet-format, ESLint, Stylelint, etc.). It supports multiple file states (staged - last-commit, git-files etc.)

    ``` jsx
    dotnet new tool-manifest
    dotnet tool install husky
    dotnet husky install
    dotnet husky add pre-commit
    ```

    after installation you can add prettier task to the `task-runner.json`.

    ``` jsx
    {
      "command": "npx",
      "args": ["prettier", "--ignore-unknown", "--write", "${staged}"],
      "pathMode": "absolute"
    }
    ```
- name: Option 3. git-format-staged
  id: precommit#option-3-git-format-stagedhttpsgithubcomhallettjgit-format-staged
  summary: 'Use Case: Great for when you want to format partially-staged files, and other options do not provide a good fit for your project'
  belongs_to: Pre-commit Hook
  description: |-
    ## Option 3. [git-format-staged](https://github.com/hallettj/git-format-staged)

    **Use Case:** Great for when you want to format partially-staged files, and other options do not provide a good fit for your project.

    Git-format-staged is used to run any formatter that can accept file content via stdin. It operates differently than other tools that format partially-staged files: it applies the formatter directly to objects in the git object database, and merges changes back to the working tree. This procedure provides several guarantees:

    1.  Changes in commits are always formatted.
    2.  Unstaged changes are never, under any circumstances staged during the formatting process.
    3.  If there are conflicts between formatted, staged changes and unstaged changes then your working tree files are left untouched - your work won’t be overwritten, and there are no stashes to clean up.
    4.  Unstaged changes are not formatted.

    Git-format-staged requires Python v3 or v2.7. Python is usually pre-installed on Linux and macOS, but not on Windows. Use git-format-staged with [husky](https://github.com/typicode/husky):

    npm

    yarn

    pnpm

    bun

    ``` jsx
    npx husky init
    npm install --save-dev git-format-staged
    node --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
    ```

    ``` jsx
    yarn husky init
    yarn add --dev git-format-staged
    node --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
    ```

    ``` jsx
    pnpm exec husky init
    pnpm add --save-dev git-format-staged
    node --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
    ```

    ``` jsx
    bunx husky init
    bun add --dev git-format-staged
    bun --eval "fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \'prettier --ignore-unknown --stdin --stdin-filepath \"{}\"\' .\n')"
    ```

    Add or remove file extensions to suit your project. Note that regardless of which extensions you list formatting will respect any `.prettierignore` files in your project.

    To read about how git-format-staged works see [Automatic Code Formatting for Partially-Staged Files](https://www.olioapps.com/blog/automatic-code-formatting/).
- name: Option 4. Shell script
  id: precommit#option-4-shell-script
  summary: If git is reporting that your prettified files are still modified after committing, you may need to add a post-commit script to update git’s index
  belongs_to: Pre-commit Hook
  description: "## Option 4. Shell script\n\nAlternately you can save this script as `.git/hooks/pre-commit` and give it execute permission:\n\n``` jsx\n#!/bin/sh\nFILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\\\ |g')\n[ -z \"$FILES\" ] && exit 0\n\n# Prettify all selected files\necho \"$FILES\" | xargs ./node_modules/.bin/prettier --ignore-unknown --write\n\n# Add back the modified/prettified files to staging\necho \"$FILES\" | xargs git add\n\nexit 0\n```\n\nIf git is reporting that your prettified files are still modified after committing, you may need to add a [post-commit script to update git’s index](https://github.com/prettier/prettier/issues/2978#issuecomment-334408427).\n\nAdd something like the following to `.git/hooks/post-commit`:\n\n``` jsx\n#!/bin/sh\ngit update-index -g\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/precommit](https://prettier.io/docs/en/precommit)"
- name: Option Philosophy
  id: option-philosophy
  summary: Prettier has a few options because of history
  description: "# Option Philosophy\n\n> Prettier has a few options because of history. **But we won’t add more of them.**\n>\n> Read on to learn more.\n\nPrettier is not a kitchen-sink code formatter that attempts to print your code in any way you wish. It is *opinionated.* Quoting the [Why Prettier?](why-prettier) page:\n\n> By far the biggest reason for adopting Prettier is to stop all the ongoing debates over styles.\n\nYet the more options Prettier has, the further from the above goal it gets. **The debates over styles just turn into debates over which Prettier options to use.** Formatting wars break out with renewed vigour: “Which option values are better? Why? Did we make the right choices?”\n\nAnd it’s not the only cost options have. To learn more about their downsides, see the [issue about resisting adding configuration](https://github.com/prettier/prettier/issues/40), which has more 👍s than any option request issue.\n\nSo why are there any options at all?\n\n- A few were added during Prettier’s infancy to make it take off at all. 🚀\n- A couple were added after “great demand.” 🤔\n- Some were added for compatibility reasons. 👍\n\nOptions that are easier to motivate include:\n\n- `--trailing-comma es5` lets you use trailing commas in most environments without having to transpile (trailing function commas were added in ES2017).\n- `--prose-wrap` is important to support all quirky Markdown renderers in the wild.\n- `--html-whitespace-sensitivity` is needed due to the unfortunate whitespace rules of HTML.\n- `--end-of-line` makes it easier for teams to keep CRLFs out of their git repositories.\n- `--quote-props` is important for advanced usage of the Google Closure Compiler.\n\nBut other options are harder to motivate in hindsight: `--arrow-parens`, `--jsx-single-quote`, `--bracket-same-line` and `--no-bracket-spacing` are not the type of options we’re happy to have. They cause a lot of [bike-shedding](https://en.wikipedia.org/wiki/Law_of_triviality) in teams, and we’re sorry for that. Difficult to remove now, these options exist as a historical artifact and should not motivate adding more options (“If *those* options exist, why can’t this one?”).\n\nFor a long time, we left option requests open in order to let discussions play out and collect feedback. What we’ve learned during those years is that it’s really hard to measure demand. Prettier has grown a lot in usage. What was “great demand” back in the day is not as much today. GitHub reactions and Twitter polls became unrepresentative. What about all silent users? It looked easy to add “just one more” option. But where should we have stopped? When is one too many? Even after adding “that one final option”, there would always be a “top issue” in the issue tracker.\n\nHowever, the time to stop has come. Now that Prettier is mature enough and we see it adopted by so many organizations and projects, the research phase is over. We have enough confidence to conclude that Prettier reached a point where the set of options should be “frozen”. **Option requests aren’t accepted anymore.** We’re thankful to everyone who participated in this difficult journey.\n\nPlease note that as option requests are out of scope for Prettier, they will be closed without discussion. The same applies to requests to preserve elements of input formatting (e.g. line breaks) since that’s nothing else but an option in disguise with all the downsides of “real” options. There may be situations where adding an option can’t be avoided because of technical necessity (e.g. compatibility), but for formatting-related options, this is final.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/option-philosophy](https://prettier.io/docs/en/option-philosophy)"
- name: Options
  id: options
  summary: Prettier ships with a handful of format options
  description: "# Options\n\nPrettier ships with a handful of format options.\n\n**To learn more about Prettier’s stance on options – see the [Option Philosophy](option-philosophy).**\n\nIf you change any options, it’s recommended to do it via a [configuration file](configuration). This way the Prettier CLI, [editor integrations](editors) and other tooling knows what options you use.\n\n## Experimental Ternaries\n\nTry prettier's [new ternary formatting](https://github.com/prettier/prettier/pull/13183) before it becomes the default behavior.\n\nValid options:\n\n- `true` - Use curious ternaries, with the question mark after the condition.\n- `false` - Retain the default behavior of ternaries; keep question marks on the same line as the consequent.\n\n| Default | CLI Override               | API Override                    |\n|---------|----------------------------|---------------------------------|\n| `false` | `--experimental-ternaries` | `experimentalTernaries: <bool>` |\n\n## Print Width\n\nSpecify the line length that the printer will wrap on.\n\n> **For readability we recommend against using more than 80 characters:**\n>\n> In code styleguides, maximum line length rules are often set to 100 or 120. However, when humans write code, they don’t strive to reach the maximum number of columns on every line. Developers often use whitespace to break up long lines for readability. In practice, the average line length often ends up well below the maximum.\n>\n> Prettier’s printWidth option does not work the same way. It is not the hard upper allowed line length limit. It is a way to say to Prettier roughly how long you’d like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified printWidth.\n>\n> Remember, computers are dumb. You need to explicitly tell them what to do, while humans can make their own (implicit) judgements, for example on when to break a line.\n>\n> In other words, don’t try to use printWidth as if it was ESLint’s [max-len](https://eslint.org/docs/rules/max-len) – they’re not the same. max-len just says what the maximum allowed line length is, but not what the generally preferred length is – which is what printWidth specifies.\n\n| Default | CLI Override          | API Override        |\n|---------|-----------------------|---------------------|\n| `80`    | `--print-width <int>` | `printWidth: <int>` |\n\nSetting `max_line_length` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s print width, unless overridden.\n\n(If you don’t want line wrapping when formatting Markdown, you can set the [Prose Wrap](#prose-wrap) option to disable it.)\n\n## Tab Width\n\nSpecify the number of spaces per indentation-level.\n\n| Default | CLI Override        | API Override      |\n|---------|---------------------|-------------------|\n| `2`     | `--tab-width <int>` | `tabWidth: <int>` |\n\nSetting `indent_size` or `tab_width` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s tab width, unless overridden.\n\n## Tabs\n\nIndent lines with tabs instead of spaces.\n\n| Default | CLI Override | API Override      |\n|---------|--------------|-------------------|\n| `false` | `--use-tabs` | `useTabs: <bool>` |\n\nSetting `indent_style` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s tab usage, unless overridden.\n\n(Tabs will be used for *indentation* but Prettier uses spaces to *align* things, such as in ternaries. This behavior is known as [SmartTabs](https://www.emacswiki.org/emacs/SmartTabs).)\n\n## Semicolons\n\nPrint semicolons at the ends of statements.\n\nValid options:\n\n- `true` - Add a semicolon at the end of every statement.\n- `false` - Only add semicolons at the beginning of lines that [may introduce ASI failures](rationale#semicolons).\n\n| Default | CLI Override | API Override   |\n|---------|--------------|----------------|\n| `true`  | `--no-semi`  | `semi: <bool>` |\n\n## Quotes\n\nUse single quotes instead of double quotes.\n\nNotes:\n\n- JSX quotes ignore this option – see [jsx-single-quote](#jsx-quotes).\n- If the number of quotes outweighs the other quote, the quote which is less used will be used to format the string - Example: `\"I'm double quoted\"` results in `\"I'm double quoted\"` and `\"This \\\"example\\\" is single quoted\"` results in `'This \"example\" is single quoted'`.\n\nSee the [strings rationale](rationale#strings) for more information.\n\n| Default | CLI Override     | API Override          |\n|---------|------------------|-----------------------|\n| `false` | `--single-quote` | `singleQuote: <bool>` |\n\n## Quote Props\n\nChange when properties in objects are quoted.\n\nValid options:\n\n- `\"as-needed\"` - Only add quotes around object properties where required.\n- `\"consistent\"` - If at least one property in an object requires quotes, quote all properties.\n- `\"preserve\"` - Respect the input use of quotes in object properties.\n\n| Default       | CLI Override                                    | API Override                                    |\n|---------------|-------------------------------------------------|-------------------------------------------------|\n| `\"as-needed\"` | `--quote-props <as-needed|consistent|preserve>` | `quoteProps: \"<as-needed|consistent|preserve>\"` |\n\nNote that Prettier never unquotes numeric property names in Angular expressions, TypeScript, and Flow because the distinction between string and numeric keys is significant in these languages. See: [Angular](https://codesandbox.io/s/hungry-morse-foj87?file=/src/app/app.component.html), [TypeScript](https://www.typescriptlang.org/play?#code/DYUwLgBAhhC8EG8IEYBcKA0EBM7sQF8AoUSAIzkQgHJlr1ktrt6dCiiATEAY2CgBOICKWhR0AaxABPAPYAzCGGkAHEAugBuLr35CR4CGTKSZG5Wo1ltRKDHjHtQA), [Flow](https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBjOA7AzgFzAA8wBeMAb1TDAAYAuMARlQF8g). Also Prettier doesn’t unquote numeric properties for Vue (see the [issue](https://github.com/prettier/prettier/issues/10127) about that).\n\n## JSX Quotes\n\nUse single quotes instead of double quotes in JSX.\n\n| Default | CLI Override         | API Override             |\n|---------|----------------------|--------------------------|\n| `false` | `--jsx-single-quote` | `jsxSingleQuote: <bool>` |\n\n## Trailing Commas\n\n*Default value changed from `es5` to `all` in v3.0.0*\n\nPrint trailing commas wherever possible in multi-line comma-separated syntactic structures. (A single-line array, for example, never gets trailing commas.)\n\nValid options:\n\n- `\"all\"` - Trailing commas wherever possible (including [function parameters and calls](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas#Trailing_commas_in_functions)). To run, JavaScript code formatted this way needs an engine that supports ES2017 (Node.js 8+ or a modern browser) or [downlevel compilation](https://babeljs.io/docs/en/index). This also enables trailing commas in type parameters in TypeScript (supported since TypeScript 2.7 released in January 2018).\n- `\"es5\"` - Trailing commas where valid in ES5 (objects, arrays, etc.). Trailing commas in type parameters in TypeScript and Flow.\n- `\"none\"` - No trailing commas.\n\n| Default | CLI Override                      | API Override                      |\n|---------|-----------------------------------|-----------------------------------|\n| `\"all\"` | `--trailing-comma <all|es5|none>` | `trailingComma: \"<all|es5|none>\"` |\n\n## Bracket Spacing\n\nPrint spaces between brackets in object literals.\n\nValid options:\n\n- `true` - Example: `{ foo: bar }`.\n- `false` - Example: `{foo: bar}`.\n\n| Default | CLI Override           | API Override             |\n|---------|------------------------|--------------------------|\n| `true`  | `--no-bracket-spacing` | `bracketSpacing: <bool>` |\n\n## Bracket Line\n\nPut the `>` of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).\n\nValid options:\n\n- `true` - Example:\n\n``` jsx\n<button\n  className=\"prettier-class\"\n  id=\"prettier-id\"\n  onClick={this.handleClick}>\n  Click Here\n</button>\n```\n\n- `false` - Example:\n\n``` jsx\n<button\n  className=\"prettier-class\"\n  id=\"prettier-id\"\n  onClick={this.handleClick}\n>\n  Click Here\n</button>\n```\n\n| Default | CLI Override          | API Override              |\n|---------|-----------------------|---------------------------|\n| `false` | `--bracket-same-line` | `bracketSameLine: <bool>` |\n\n## \\[Deprecated\\] JSX Brackets\n\n*This option has been deprecated in v2.4.0, use --bracket-same-line instead*\n\nPut the `>` of a multi-line JSX element at the end of the last line instead of being alone on the next line (does not apply to self closing elements).\n\nValid options:\n\n- `true` - Example:\n\n``` jsx\n<button\n  className=\"prettier-class\"\n  id=\"prettier-id\"\n  onClick={this.handleClick}>\n  Click Here\n</button>\n```\n\n- `false` - Example:\n\n``` jsx\n<button\n  className=\"prettier-class\"\n  id=\"prettier-id\"\n  onClick={this.handleClick}\n>\n  Click Here\n</button>\n```\n\n| Default | CLI Override              | API Override                 |\n|---------|---------------------------|------------------------------|\n| `false` | `--jsx-bracket-same-line` | `jsxBracketSameLine: <bool>` |\n\n## Arrow Function Parentheses\n\n*First available in v1.9.0, default value changed from `avoid` to `always` in v2.0.0*\n\nInclude parentheses around a sole arrow function parameter.\n\nValid options:\n\n- `\"always\"` - Always include parens. Example: `(x) => x`\n- `\"avoid\"` - Omit parens when possible. Example: `x => x`\n\n| Default    | CLI Override                    | API Override                    |\n|------------|---------------------------------|---------------------------------|\n| `\"always\"` | `--arrow-parens <always|avoid>` | `arrowParens: \"<always|avoid>\"` |\n\nAt first glance, avoiding parentheses may look like a better choice because of less visual noise. However, when Prettier removes parentheses, it becomes harder to add type annotations, extra arguments or default values as well as making other changes. Consistent use of parentheses provides a better developer experience when editing real codebases, which justifies the default value for the option.\n\n## Range\n\nFormat only a segment of a file.\n\nThese two options can be used to format code starting and ending at a given character offset (inclusive and exclusive, respectively). The range will extend:\n\n- Backwards to the start of the first line containing the selected statement.\n- Forwards to the end of the selected statement.\n\n| Default    | CLI Override          | API Override        |\n|------------|-----------------------|---------------------|\n| `0`        | `--range-start <int>` | `rangeStart: <int>` |\n| `Infinity` | `--range-end <int>`   | `rangeEnd: <int>`   |\n\n## Parser\n\nSpecify which parser to use.\n\nPrettier automatically infers the parser from the input file path, so you shouldn’t have to change this setting.\n\nBoth the `babel` and `flow` parsers support the same set of JavaScript features (including Flow type annotations). They might differ in some edge cases, so if you run into one of those you can try `flow` instead of `babel`. Almost the same applies to `typescript` and `babel-ts`. `babel-ts` might support JavaScript features (proposals) not yet supported by TypeScript, but it’s less permissive when it comes to invalid code and less battle-tested than the `typescript` parser.\n\nValid options:\n\n- `\"babel\"` (via [@babel/parser](https://github.com/babel/babel/tree/main/packages/babel-parser)) *Named `\"babylon\"` until v1.16.0*\n- `\"babel-flow\"` (same as `\"babel\"` but enables Flow parsing explicitly to avoid ambiguity) *First available in v1.16.0*\n- `\"babel-ts\"` (similar to `\"typescript\"` but uses Babel and its TypeScript plugin) *First available in v2.0.0*\n- `\"flow\"` (via [flow-parser](https://github.com/facebook/flow/tree/master/src/parser))\n- `\"typescript\"` (via [@typescript-eslint/typescript-estree](https://github.com/typescript-eslint/typescript-eslint)) *First available in v1.4.0*\n- `\"espree\"` (via [espree](https://github.com/eslint/espree)) *First available in v2.2.0*\n- `\"meriyah\"` (via [meriyah](https://github.com/meriyah/meriyah)) *First available in v2.2.0*\n- `\"acorn\"` (via [acorn](https://github.com/acornjs/acorn)) *First available in v2.6.0*\n- `\"css\"` (via [postcss](https://github.com/postcss/postcss)) *First available in v1.7.1*\n- `\"scss\"` (via [postcss-scss](https://github.com/postcss/postcss-scss)) *First available in v1.7.1*\n- `\"less\"` (via [postcss-less](https://github.com/shellscape/postcss-less)) *First available in v1.7.1*\n- `\"json\"` (via [@babel/parser parseExpression](https://babeljs.io/docs/en/next/babel-parser.html#babelparserparseexpressioncode-options)) *First available in v1.5.0*\n- `\"json5\"` (same parser as `\"json\"`, but outputs as [json5](https://json5.org/)) *First available in v1.13.0*\n- `\"jsonc\"` (same parser as `\"json\"`, but outputs as \"JSON with Comments\") *First available in v3.2.0*\n- `\"json-stringify\"` (same parser as `\"json\"`, but outputs like `JSON.stringify`) *First available in v1.13.0*\n- `\"graphql\"` (via [graphql/language](https://github.com/graphql/graphql-js/tree/master/src/language)) *First available in v1.5.0*\n- `\"markdown\"` (via [remark-parse](https://github.com/wooorm/remark/tree/main/packages/remark-parse)) *First available in v1.8.0*\n- `\"mdx\"` (via [remark-parse](https://github.com/wooorm/remark/tree/main/packages/remark-parse) and [@mdx-js/mdx](https://github.com/mdx-js/mdx/tree/master/packages/mdx)) *First available in v1.15.0*\n- `\"html\"` (via [angular-html-parser](https://github.com/ikatyang/angular-html-parser/tree/master/packages/angular-html-parser)) *First available in 1.15.0*\n- `\"vue\"` (same parser as `\"html\"`, but also formats vue-specific syntax) *First available in 1.10.0*\n- `\"angular\"` (same parser as `\"html\"`, but also formats angular-specific syntax via [angular-estree-parser](https://github.com/ikatyang/angular-estree-parser)) *First available in 1.15.0*\n- `\"lwc\"` (same parser as `\"html\"`, but also formats LWC-specific syntax for unquoted template attributes) *First available in 1.17.0*\n- `\"yaml\"` (via [yaml](https://github.com/eemeli/yaml) and [yaml-unist-parser](https://github.com/ikatyang/yaml-unist-parser)) *First available in 1.14.0*\n\n| Default | CLI Override        | API Override         |\n|---------|---------------------|----------------------|\n| None    | `--parser <string>` | `parser: \"<string>\"` |\n\nNote: the default value was `\"babylon\"` until v1.13.0.\n\nNote: the Custom parser API has been removed in v3.0.0. Use [plugins](plugins) instead ([how to migrate](api#custom-parser-api)).\n\n## File Path\n\nSpecify the file name to use to infer which parser to use.\n\nFor example, the following will use the CSS parser:\n\n``` jsx\ncat foo | prettier --stdin-filepath foo.css\n```\n\nThis option is only useful in the CLI and API. It doesn’t make sense to use it in a configuration file.\n\n| Default | CLI Override                | API Override           |\n|---------|-----------------------------|------------------------|\n| None    | `--stdin-filepath <string>` | `filepath: \"<string>\"` |\n\n## Require Pragma\n\n*First available in v1.7.0*\n\nPrettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to Prettier.\n\nA file with the following as its first comment will be formatted when `--require-pragma` is supplied:\n\n``` jsx\n/**\n * @prettier\n */\n```\n\nor\n\n``` jsx\n/**\n * @format\n */\n```\n\n| Default | CLI Override       | API Override            |\n|---------|--------------------|-------------------------|\n| `false` | `--require-pragma` | `requirePragma: <bool>` |\n\n## Insert Pragma\n\n*First available in v1.8.0*\n\nPrettier can insert a special `@format` marker at the top of files specifying that the file has been formatted with Prettier. This works well when used in tandem with the `--require-pragma` option. If there is already a docblock at the top of the file then this option will add a newline to it with the `@format` marker.\n\nNote that “in tandem” doesn’t mean “at the same time”. When the two options are used simultaneously, `--require-pragma` has priority, so `--insert-pragma` is ignored. The idea is that during an incremental adoption of Prettier in a big codebase, the developers participating in the transition process use `--insert-pragma` whereas `--require-pragma` is used by the rest of the team and automated tooling to process only files already transitioned. The feature has been inspired by Facebook’s [adoption strategy](https://prettier.io/blog/2017/05/03/1.3.0#facebook-adoption-update).\n\n| Default | CLI Override      | API Override           |\n|---------|-------------------|------------------------|\n| `false` | `--insert-pragma` | `insertPragma: <bool>` |\n\n## Prose Wrap\n\n*First available in v1.8.2*\n\nBy default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g. GitHub comments and BitBucket. To have Prettier wrap prose to the print width, change this option to \"always\". If you want Prettier to force all prose blocks to be on a single line and rely on editor/viewer soft wrapping instead, you can use `\"never\"`.\n\nValid options:\n\n- `\"always\"` - Wrap prose if it exceeds the print width.\n- `\"never\"` - Un-wrap each block of prose into one line.\n- `\"preserve\"` - Do nothing, leave prose as-is. *First available in v1.9.0*\n\n| Default      | CLI Override                           | API Override                           |\n|--------------|----------------------------------------|----------------------------------------|\n| `\"preserve\"` | `--prose-wrap <always|never|preserve>` | `proseWrap: \"<always|never|preserve>\"` |\n\n## HTML Whitespace Sensitivity\n\n*First available in v1.15.0. First available for Handlebars in 2.3.0*\n\nSpecify the global whitespace sensitivity for HTML, Vue, Angular, and Handlebars. See [whitespace-sensitive formatting](https://prettier.io/blog/2018/11/07/1.15.0#whitespace-sensitive-formatting) for more info.\n\nValid options:\n\n- `\"css\"` - Respect the default value of CSS `display` property. For Handlebars treated same as `strict`.\n- `\"strict\"` - Whitespace (or the lack of it) around all tags is considered significant.\n- `\"ignore\"` - Whitespace (or the lack of it) around all tags is considered insignificant.\n\n| Default | CLI Override                                        | API Override                                       |\n|---------|-----------------------------------------------------|----------------------------------------------------|\n| `\"css\"` | `--html-whitespace-sensitivity <css|strict|ignore>` | `htmlWhitespaceSensitivity: \"<css|strict|ignore>\"` |\n\n## Vue files script and style tags indentation\n\n*First available in v1.19.0*\n\nWhether or not to indent the code inside `<script>` and `<style>` tags in Vue files.\n\nValid options:\n\n- `false` - Do not indent script and style tags in Vue files.\n- `true` - Indent script and style tags in Vue files.\n\n| Default | CLI Override                    | API Override                      |\n|---------|---------------------------------|-----------------------------------|\n| `false` | `--vue-indent-script-and-style` | `vueIndentScriptAndStyle: <bool>` |\n\n## End of Line\n\n*First available in v1.15.0, default value changed from `auto` to `lf` in v2.0.0*\n\nFor historical reasons, there exist two common flavors of line endings in text files. That is `\\n` (or `LF` for *Line Feed*) and `\\r\\n` (or `CRLF` for *Carriage Return + Line Feed*). The former is common on Linux and macOS, while the latter is prevalent on Windows. Some details explaining why it is so [can be found on Wikipedia](https://en.wikipedia.org/wiki/Newline).\n\nWhen people collaborate on a project from different operating systems, it becomes easy to end up with mixed line endings in a shared git repository. It is also possible for Windows users to accidentally change line endings in a previously committed file from `LF` to `CRLF`. Doing so produces a large `git diff` and thus makes the line-by-line history for a file (`git blame`) harder to explore.\n\nIf you want to make sure that your entire git repository only contains Linux-style line endings in files covered by Prettier:\n\n1.  Ensure Prettier’s `endOfLine` option is set to `lf` (this is a default value since v2.0.0)\n2.  Configure [a pre-commit hook](precommit) that will run Prettier\n3.  Configure Prettier to run in your CI pipeline using [`--check` flag](cli#--check). If you use Travis CI, set [the `autocrlf` option](https://docs.travis-ci.com/user/customizing-the-build#git-end-of-line-conversion-control) to `input` in `.travis.yml`.\n4.  Add `* text=auto eol=lf` to the repo’s `.gitattributes` file. You may need to ask Windows users to re-clone your repo after this change to ensure git has not converted `LF` to `CRLF` on checkout.\n\nAll modern text editors in all operating systems are able to correctly display line endings when `\\n` (`LF`) is used. However, old versions of Notepad for Windows will visually squash such lines into one as they can only deal with `\\r\\n` (`CRLF`).\n\nValid options:\n\n- `\"lf\"` – Line Feed only (`\\n`), common on Linux and macOS as well as inside git repos\n- `\"crlf\"` - Carriage Return + Line Feed characters (`\\r\\n`), common on Windows\n- `\"cr\"` - Carriage Return character only (`\\r`), used very rarely\n- `\"auto\"` - Maintain existing line endings (mixed values within one file are normalised by looking at what’s used after the first line)\n\n| Default | CLI Override                      | API Override                     |\n|---------|-----------------------------------|----------------------------------|\n| `\"lf\"`  | `--end-of-line <lf|crlf|cr|auto>` | `endOfLine: \"<lf|crlf|cr|auto>\"` |\n\nSetting `end_of_line` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s end of line usage, unless overridden.\n\n## Embedded Language Formatting\n\n*First available in v2.1.0*\n\nControl whether Prettier formats quoted code embedded in the file.\n\nWhen Prettier identifies cases where it looks like you've placed some code it knows how to format within a string in another file, like in a tagged template in JavaScript with a tag named `html` or in code blocks in Markdown, it will by default try to format that code.\n\nSometimes this behavior is undesirable, particularly in cases where you might not have intended the string to be interpreted as code. This option allows you to switch between the default behavior (`auto`) and disabling this feature entirely (`off`).\n\nValid options:\n\n- `\"auto\"` – Format embedded code if Prettier can automatically identify it.\n- `\"off\"` - Never automatically format embedded code.\n\n| Default  | CLI Override                                | API Override                               |\n|----------|---------------------------------------------|--------------------------------------------|\n| `\"auto\"` | `--embedded-language-formatting=<off|auto>` | `embeddedLanguageFormatting: \"<off|auto>\"` |\n\n## Single Attribute Per Line\n\n*First available in v2.6.0*\n\nEnforce single attribute per line in HTML, Vue and JSX.\n\nValid options:\n\n- `false` - Do not enforce single attribute per line.\n- `true` - Enforce single attribute per line.\n\n| Default | CLI Override                  | API Override                     |\n|---------|-------------------------------|----------------------------------|\n| `false` | `--single-attribute-per-line` | `singleAttributePerLine: <bool>` |\n\n© James Long and contributors  \n[https://prettier.io/docs/en/options](https://prettier.io/docs/en/options)"
- name: Parser
  id: options#parser
  summary: Specify which parser to use
  belongs_to: Options
  description: |-
    ## Parser

    Specify which parser to use.

    Prettier automatically infers the parser from the input file path, so you shouldn’t have to change this setting.

    Both the `babel` and `flow` parsers support the same set of JavaScript features (including Flow type annotations). They might differ in some edge cases, so if you run into one of those you can try `flow` instead of `babel`. Almost the same applies to `typescript` and `babel-ts`. `babel-ts` might support JavaScript features (proposals) not yet supported by TypeScript, but it’s less permissive when it comes to invalid code and less battle-tested than the `typescript` parser.

    Valid options:

    - `"babel"` (via [@babel/parser](https://github.com/babel/babel/tree/main/packages/babel-parser)) *Named `"babylon"` until v1.16.0*
    - `"babel-flow"` (same as `"babel"` but enables Flow parsing explicitly to avoid ambiguity) *First available in v1.16.0*
    - `"babel-ts"` (similar to `"typescript"` but uses Babel and its TypeScript plugin) *First available in v2.0.0*
    - `"flow"` (via [flow-parser](https://github.com/facebook/flow/tree/master/src/parser))
    - `"typescript"` (via [@typescript-eslint/typescript-estree](https://github.com/typescript-eslint/typescript-eslint)) *First available in v1.4.0*
    - `"espree"` (via [espree](https://github.com/eslint/espree)) *First available in v2.2.0*
    - `"meriyah"` (via [meriyah](https://github.com/meriyah/meriyah)) *First available in v2.2.0*
    - `"acorn"` (via [acorn](https://github.com/acornjs/acorn)) *First available in v2.6.0*
    - `"css"` (via [postcss](https://github.com/postcss/postcss)) *First available in v1.7.1*
    - `"scss"` (via [postcss-scss](https://github.com/postcss/postcss-scss)) *First available in v1.7.1*
    - `"less"` (via [postcss-less](https://github.com/shellscape/postcss-less)) *First available in v1.7.1*
    - `"json"` (via [@babel/parser parseExpression](https://babeljs.io/docs/en/next/babel-parser.html#babelparserparseexpressioncode-options)) *First available in v1.5.0*
    - `"json5"` (same parser as `"json"`, but outputs as [json5](https://json5.org/)) *First available in v1.13.0*
    - `"jsonc"` (same parser as `"json"`, but outputs as "JSON with Comments") *First available in v3.2.0*
    - `"json-stringify"` (same parser as `"json"`, but outputs like `JSON.stringify`) *First available in v1.13.0*
    - `"graphql"` (via [graphql/language](https://github.com/graphql/graphql-js/tree/master/src/language)) *First available in v1.5.0*
    - `"markdown"` (via [remark-parse](https://github.com/wooorm/remark/tree/main/packages/remark-parse)) *First available in v1.8.0*
    - `"mdx"` (via [remark-parse](https://github.com/wooorm/remark/tree/main/packages/remark-parse) and [@mdx-js/mdx](https://github.com/mdx-js/mdx/tree/master/packages/mdx)) *First available in v1.15.0*
    - `"html"` (via [angular-html-parser](https://github.com/ikatyang/angular-html-parser/tree/master/packages/angular-html-parser)) *First available in 1.15.0*
    - `"vue"` (same parser as `"html"`, but also formats vue-specific syntax) *First available in 1.10.0*
    - `"angular"` (same parser as `"html"`, but also formats angular-specific syntax via [angular-estree-parser](https://github.com/ikatyang/angular-estree-parser)) *First available in 1.15.0*
    - `"lwc"` (same parser as `"html"`, but also formats LWC-specific syntax for unquoted template attributes) *First available in 1.17.0*
    - `"yaml"` (via [yaml](https://github.com/eemeli/yaml) and [yaml-unist-parser](https://github.com/ikatyang/yaml-unist-parser)) *First available in 1.14.0*

    | Default | CLI Override        | API Override         |
    |---------|---------------------|----------------------|
    | None    | `--parser <string>` | `parser: "<string>"` |

    Note: the default value was `"babylon"` until v1.13.0.

    Note: the Custom parser API has been removed in v3.0.0. Use [plugins](plugins) instead ([how to migrate](api#custom-parser-api)).
- name: Parser plugins for embedded code
  id: browser#parser-plugins-for-embedded-code
  summary: If you want to format embedded code, you need to load related plugins too
  belongs_to: Browser
  description: "## Parser plugins for embedded code\n\nIf you want to format [embedded code](options#embedded-language-formatting), you need to load related plugins too. For example:\n\n``` jsx\n      \n        <script\n        type\n        =\"module\"\n        >\n      \n      \n        import*as prettier from \"https://unpkg.com/prettier@3.3.3/standalone.mjs\";\n  import prettierPluginBabel from \"https://unpkg.com/prettier@3.3.3/plugins/babel.mjs\";\n  import prettierPluginEstree from \"https://unpkg.com/prettier@3.3.3/plugins/estree.mjs\";\n\n  console.log(\n    await prettier.format(\"const html=/* HTML */ `<DIV> </DIV>`\", {\n      parser: \"babel\",\n      plugins: [prettierPluginBabel, prettierPluginEstree],\n    }),\n  );\n  // Output: const html = /* HTML */ `<DIV> </DIV>`;\n\n      \n      \n        </script\n        >\n      \n    \n```\n\nThe HTML code embedded in JavaScript stays unformatted because the `html` parser hasn’t been loaded. Correct usage:\n\n``` jsx\n      \n        <script\n        type\n        =\"module\"\n        >\n      \n      \n        import*as prettier from \"https://unpkg.com/prettier@3.3.3/standalone.mjs\";\n  import prettierPluginBabel from \"https://unpkg.com/prettier@3.3.3/plugins/babel.mjs\";\n  import prettierPluginEstree from \"https://unpkg.com/prettier@3.3.3/plugins/estree.mjs\";\n  import prettierPluginHtml from \"https://unpkg.com/prettier@3.3.3/plugins/html.mjs\";\n\n  console.log(\n    await prettier.format(\"const html=/* HTML */ `<DIV> </DIV>`\", {\n      parser: \"babel\",\n      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],\n    }),\n  );\n  // Output: const html = /* HTML */ `<div></div>`;\n\n      \n      \n        </script\n        >\n      \n    \n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/browser](https://prettier.io/docs/en/browser)"
- name: Plugins
  id: plugins
  summary: Plugins are ways of adding new languages or formatting rules to Prettier
  description: "# Plugins\n\nPlugins are ways of adding new languages or formatting rules to Prettier. Prettier’s own implementations of all languages are expressed using the plugin API. The core `prettier` package contains JavaScript and other web-focused languages built in. For additional languages you’ll need to install a plugin.\n\n## Using Plugins\n\nYou can load plugins with:\n\n- The [CLI](cli), via `--plugin`:\n\n  ``` jsx\n  prettier --write main.foo --plugin=prettier-plugin-foo\n  ```\n\n  > Tip: You can set `--plugin` options multiple times.\n\n- The [API](api), via the `plugins` options:\n\n  ``` jsx\n  await prettier.format(\"code\", {\n    parser: \"foo\",\n    plugins: [\"prettier-plugin-foo\"],\n  });\n  ```\n\n- The [Configuration File](configuration):\n\n  ``` jsx\n  {\n    \"plugins\": [\"prettier-plugin-foo\"]\n  }\n  ```\n\nStrings provided to `plugins` are ultimately passed to [`import()` expression](https://nodejs.org/api/esm.html#import-expressions), so you can provide a module/package name, a path, or anything else `import()` takes.\n\n## Official Plugins\n\n- [`@prettier/plugin-php`](https://github.com/prettier/plugin-php)\n- [`@prettier/plugin-pug`](https://github.com/prettier/plugin-pug) by [**@Shinigami92**](https://github.com/Shinigami92)\n- [`@prettier/plugin-ruby`](https://github.com/prettier/plugin-ruby)\n- [`@prettier/plugin-xml`](https://github.com/prettier/plugin-xml)\n\n## Community Plugins\n\n- [`prettier-plugin-apex`](https://github.com/dangmai/prettier-plugin-apex) by [**@dangmai**](https://github.com/dangmai)\n- [`prettier-plugin-astro`](https://github.com/withastro/prettier-plugin-astro) by [**@withastro contributors**](https://github.com/withastro/prettier-plugin-astro/graphs/contributors)\n- [`prettier-plugin-elm`](https://github.com/gicentre/prettier-plugin-elm) by [**@giCentre**](https://github.com/gicentre)\n- [`prettier-plugin-erb`](https://github.com/adamzapasnik/prettier-plugin-erb) by [**@adamzapasnik**](https://github.com/adamzapasnik)\n- [`prettier-plugin-gherkin`](https://github.com/mapado/prettier-plugin-gherkin) by [**@mapado**](https://github.com/mapado)\n- [`prettier-plugin-glsl`](https://github.com/NaridaL/glsl-language-toolkit/tree/main/packages/prettier-plugin-glsl) by [**@NaridaL**](https://github.com/NaridaL)\n- [`prettier-plugin-go-template`](https://github.com/NiklasPor/prettier-plugin-go-template) by [**@NiklasPor**](https://github.com/NiklasPor)\n- [`prettier-plugin-java`](https://github.com/jhipster/prettier-java) by [**@JHipster**](https://github.com/jhipster)\n- [`prettier-plugin-jinja-template`](https://github.com/davidodenwald/prettier-plugin-jinja-template) by [**@davidodenwald**](https://github.com/davidodenwald)\n- [`prettier-plugin-jsonata`](https://github.com/Stedi/prettier-plugin-jsonata) by [**@Stedi**](https://github.com/Stedi)\n- [`prettier-plugin-kotlin`](https://github.com/Angry-Potato/prettier-plugin-kotlin) by [**@Angry-Potato**](https://github.com/Angry-Potato)\n- [`prettier-plugin-motoko`](https://github.com/dfinity/prettier-plugin-motoko) by [**@dfinity**](https://github.com/dfinity)\n- [`prettier-plugin-nginx`](https://github.com/joedeandev/prettier-plugin-nginx) by [**@joedeandev**](https://github.com/joedeandev)\n- [`prettier-plugin-prisma`](https://github.com/umidbekk/prettier-plugin-prisma) by [**@umidbekk**](https://github.com/umidbekk)\n- [`prettier-plugin-properties`](https://github.com/eemeli/prettier-plugin-properties) by [**@eemeli**](https://github.com/eemeli)\n- [`prettier-plugin-rust`](https://github.com/jinxdash/prettier-plugin-rust) by [**@jinxdash**](https://github.com/jinxdash)\n- [`prettier-plugin-sh`](https://github.com/un-ts/prettier/tree/master/packages/sh) by [**@JounQin**](https://github.com/JounQin)\n- [`prettier-plugin-sql`](https://github.com/un-ts/prettier/tree/master/packages/sql) by [**@JounQin**](https://github.com/JounQin)\n- [`prettier-plugin-sql-cst`](https://github.com/nene/prettier-plugin-sql-cst) by [**@nene**](https://github.com/nene)\n- [`prettier-plugin-solidity`](https://github.com/prettier-solidity/prettier-plugin-solidity) by [**@mattiaerre**](https://github.com/mattiaerre)\n- [`prettier-plugin-svelte`](https://github.com/sveltejs/prettier-plugin-svelte) by [**@sveltejs**](https://github.com/sveltejs)\n- [`prettier-plugin-toml`](https://github.com/bd82/toml-tools/tree/master/packages/prettier-plugin-toml) by [**@bd82**](https://github.com/bd82)\n\n## Developing Plugins\n\nPrettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:\n\n- `languages`\n- `parsers`\n- `printers`\n- `options`\n- `defaultOptions`\n\n### `languages`\n\nLanguages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in [`prettier.getSupportInfo()`](api#prettiergetsupportinfo).\n\nIt **must** include `name` and `parsers`.\n\n``` jsx\nexport const languages = [\n  {\n    // The language name\n    name: \"InterpretedDanceScript\",\n    // Parsers that can parse this language.\n    // This can be built-in parsers, or parsers you have contributed via this plugin.\n    parsers: [\"dance-parse\"],\n  },\n];\n```\n\n### `parsers`\n\nParsers convert code as a string into an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree).\n\nThe key must match the name in the `parsers` array from `languages`. The value contains a parse function, an AST format name, and two location extraction functions (`locStart` and `locEnd`).\n\n``` jsx\nexport const parsers = {\n  \"dance-parse\": {\n    parse,\n    // The name of the AST that\n    astFormat: \"dance-ast\",\n    hasPragma,\n    locStart,\n    locEnd,\n    preprocess,\n  },\n};\n```\n\nThe signature of the `parse` function is:\n\n``` jsx\nfunction parse(text: string, options: object): Promise<AST> | AST;\n```\n\nThe location extraction functions (`locStart` and `locEnd`) return the starting and ending locations of a given AST node:\n\n``` jsx\nfunction locStart(node: object): number;\n```\n\n*(Optional)* The pragma detection function (`hasPragma`) should return if the text contains the pragma comment.\n\n``` jsx\nfunction hasPragma(text: string): boolean;\n```\n\n*(Optional)* The preprocess function can process the input text before passing into `parse` function.\n\n``` jsx\nfunction preprocess(text: string, options: object): string;\n```\n\n### `printers`\n\nPrinters convert ASTs into a Prettier intermediate representation, also known as a Doc.\n\nThe key must match the `astFormat` that the parser produces. The value contains an object with a `print` function. All other properties (`embed`, `preprocess`, etc.) are optional.\n\n``` jsx\nexport const printers = {\n  \"dance-ast\": {\n    print,\n    embed,\n    preprocess,\n    getVisitorKeys,\n    insertPragma,\n    canAttachComment,\n    isBlockComment,\n    printComment,\n    getCommentChildNodes,\n    handleComments: {\n      ownLine,\n      endOfLine,\n      remaining,\n    },\n  },\n};\n```\n\n#### The printing process\n\nPrettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like `printWidth`). A *printer*'s job is to take the AST generated by `parsers[<parser name>].parse` and return a Doc. A Doc is constructed using [builder commands](https://github.com/prettier/prettier/blob/main/commands.md):\n\n``` jsx\nimport { doc } from \"prettier\";\n\nconst { join, line, ifBreak, group } = doc.builders;\n```\n\nThe printing process consists of the following steps:\n\n1.  **AST preprocessing** (optional). See [`preprocess`](#optional-preprocess).\n2.  **Comment attachment** (optional). See [Handling comments in a printer](#handling-comments-in-a-printer).\n3.  **Processing embedded languages** (optional). The [`embed`](#optional-embed) method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, `embed` may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.\n4.  **Recursive printing**. A doc is recursively constructed from the AST. Starting from the root node:\n    - If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.\n    - Otherwise, the `print(path, options, print): Doc` method is called. It composes a doc for the current node, often by printing child nodes using the `print` callback.\n\n#### `print`\n\nMost of the work of a plugin's printer will take place in its `print` function, whose signature is:\n\n``` jsx\nfunction print(\n  // Path to the AST node to print\n  path: AstPath,\n  options: object,\n  // Recursively print a child node\n  print: (selector?: string | number | Array<string | number> | AstPath) => Doc,\n): Doc;\n```\n\nThe `print` function is passed the following parameters:\n\n- **`path`**: An object, which can be used to access nodes in the AST. It’s a stack-like data structure that maintains the current state of the recursion. It is called “path” because it represents the path to the current node from the root of the AST. The current node is returned by `path.node`.\n- **`options`**: A persistent object, which contains global options and which a plugin may mutate to store contextual data.\n- **`print`**: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer’s `print` function and passes itself to it. Thus, the two `print` functions – the one from the core and the one from the plugin – call each other while descending down the AST recursively.\n\nHere’s a simplified example to give an idea of what a typical implementation of `print` looks like:\n\n``` jsx\nimport { doc } from \"prettier\";\n\nconst { group, indent, join, line, softline } = doc.builders;\n\nfunction print(path, options, print) {\n  const node = path.node;\n\n  switch (node.type) {\n    case \"list\":\n      return group([\n        \"(\",\n        indent([softline, join(line, path.map(print, \"elements\"))]),\n        softline,\n        \")\",\n      ]);\n\n    case \"pair\":\n      return group([\n        \"(\",\n        indent([softline, print(\"left\"), line, \". \", print(\"right\")]),\n        softline,\n        \")\",\n      ]);\n\n    case \"symbol\":\n      return node.name;\n  }\n\n  throw new Error(`Unknown node type: ${node.type}`);\n}\n```\n\nCheck out [prettier-python's printer](https://github.com/prettier/prettier-python/blob/034ba8a9551f3fa22cead41b323be0b28d06d13b/src/printer.js#L174) for some examples of what is possible.\n\n#### (optional) `embed`\n\nA printer can have the `embed` method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:\n\n``` jsx\nfunction embed(\n  // Path to the current AST node\n  path: AstPath,\n  // Current options\n  options: Options,\n):\n  | ((\n      // Parses and prints the passed text using a different parser.\n      // You should set `options.parser` to specify which parser to use.\n      textToDoc: (text: string, options: Options) => Promise<Doc>,\n      // Prints the current node or its descendant node with the current printer\n      print: (\n        selector?: string | number | Array<string | number> | AstPath,\n      ) => Doc,\n      // The following two arguments are passed for convenience.\n      // They're the same `path` and `options` that are passed to `embed`.\n      path: AstPath,\n      options: Options,\n    ) => Promise<Doc | undefined> | Doc | undefined)\n  | Doc\n  | undefined;\n```\n\nThe `embed` method is similar to the `print` method in that it maps AST nodes to docs, but unlike `print`, it has power to do async work by returning an async function. That function's first parameter, the `textToDoc` async function, can be used to render a doc using a different plugin.\n\nIf a function returned from `embed` returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the `print` method won’t be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from `embed`, however `textToDoc` and the `print` callback aren’t available at that case. Return a function to get them.\n\nIf `embed` returns `undefined`, or if a function it returned returns `undefined` or a promise that resolves to `undefined`, the node will be printed normally with the `print` method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the `PRETTIER_DEBUG` environment variable to a non-empty value if you want Prettier to rethrow these errors.\n\nFor example, a plugin that has nodes with embedded JavaScript might have the following `embed` method:\n\n``` jsx\nfunction embed(path, options) {\n  const node = path.node;\n  if (node.type === \"javascript\") {\n    return async (textToDoc) => {\n      return [\n        \"<script>\",\n        hardline,\n        await textToDoc(node.javaScriptCode, { parser: \"babel\" }),\n        hardline,\n        \"</script>\",\n      ];\n    };\n  }\n}\n```\n\nIf the [`--embedded-language-formatting`](options#embedded-language-formatting) option is set to `off`, the embedding step is entirely skipped, `embed` isn’t called, and all nodes are printed with the `print` method.\n\n#### (optional) `preprocess`\n\nThe `preprocess` method can process the AST from the parser before passing it into the `print` method.\n\n``` jsx\nfunction preprocess(ast: AST, options: Options): AST | Promise<AST>;\n```\n\n#### (optional) `getVisitorKeys`\n\nThis property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has [cycles](https://en.wikipedia.org/wiki/Cycle_(graph_theory)), such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.\n\nIts signature is:\n\n``` jsx\nfunction getVisitorKeys(node, nonTraversableKeys: Set<string>): string[];\n```\n\nThe default `getVisitorKeys`:\n\n``` jsx\nfunction getVisitorKeys(node, nonTraversableKeys) {\n  return Object.keys(node).filter((key) => !nonTraversableKeys.has(key));\n}\n```\n\nThe second argument `nonTraversableKeys` is a set of common keys and keys that prettier used internal.\n\nIf you have full list of visitor keys\n\n``` jsx\nconst visitorKeys = {\n  Program: [\"body\"],\n  Identifier: [],\n  // ...\n};\n\nfunction getVisitorKeys(node /* , nonTraversableKeys*/) {\n  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`\n  return visitorKeys[node.type] ?? [];\n}\n```\n\nIf you only need exclude a small set of keys\n\n``` jsx\nconst ignoredKeys = new Set([\"prev\", \"next\", \"range\"]);\n\nfunction getVisitorKeys(node, nonTraversableKeys) {\n  return Object.keys(node).filter(\n    (key) => !nonTraversableKeys.has(key) && !ignoredKeys.has(key),\n  );\n}\n```\n\n#### (optional) `insertPragma`\n\nA plugin can implement how a pragma comment is inserted in the resulting code when the `--insert-pragma` option is used, in the `insertPragma` function. Its signature is:\n\n``` jsx\nfunction insertPragma(text: string): string;\n```\n\n#### Handling comments in a printer\n\nComments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its `print` function or rely on Prettier's comment algorithm.\n\nBy default, if the AST has a top-level `comments` property, Prettier assumes that `comments` stores an array of comment nodes. Prettier will then use the provided `parsers[<plugin>].locStart`/`locEnd` functions to search for the AST node that each comment \"belongs\" to. Comments are then attached to these nodes **mutating the AST in the process**, and the `comments` property is deleted from the AST root. The `*Comment` functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the `printComment(path, options): Doc` function and insert the returned doc into the (hopefully) correct place.\n\n#### (optional) `getCommentChildNodes`\n\nBy default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:\n\n``` jsx\nfunction getCommentChildNodes(\n  // The node whose children should be returned.\n  node: AST,\n  // Current options\n  options: object,\n): AST[] | undefined;\n```\n\nReturn `[]` if the node has no children or `undefined` to fall back on the default behavior.\n\n#### (optional) `printComment`\n\nCalled whenever a comment node needs to be printed. It has the signature:\n\n``` jsx\nfunction printComment(\n  // Path to the current comment node\n  commentPath: AstPath,\n  // Current options\n  options: object,\n): Doc;\n```\n\n#### (optional) `canAttachComment`\n\n``` jsx\nfunction canAttachComment(node: AST): boolean;\n```\n\nThis function is used for deciding whether a comment can be attached to a particular AST node. By default, *all* AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like\n\n``` jsx\nfunction canAttachComment(node) {\n  return node.type && node.type !== \"comment\";\n}\n```\n\n#### (optional) `isBlockComment`\n\n``` jsx\nfunction isBlockComment(node: AST): boolean;\n```\n\nReturns whether or not the AST node is a block comment.\n\n#### (optional) `handleComments`\n\nThe `handleComments` object contains three optional functions, each with signature\n\n``` jsx\n(\n  // The AST node corresponding to the comment\n  comment: AST,\n  // The full source code text\n  text: string,\n  // The global options object\n  options: object,\n  // The AST\n  ast: AST,\n  // Whether this comment is the last comment\n  isLastComment: boolean,\n) => boolean;\n```\n\nThese functions are used to override Prettier's default comment attachment algorithm. `ownLine`/`endOfLine`/`remaining` is expected to either manually attach a comment to a node and return `true`, or return `false` and let Prettier attach the comment.\n\nBased on the text surrounding a comment node, Prettier dispatches:\n\n- `ownLine` if a comment has only whitespace preceding it and a newline afterwards,\n- `endOfLine` if a comment has a newline afterwards but some non-whitespace preceding it,\n- `remaining` in all other cases.\n\nAt the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of `enclosingNode`, `precedingNode`, or `followingNode`. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).\n\n#### Manually attaching a comment\n\nThe `util.addTrailingComment`/`addLeadingComment`/`addDanglingComment` functions can be used to manually attach a comment to an AST node. An example `ownLine` function that ensures a comment does not follow a \"punctuation\" node (made up for demonstration purposes) might look like:\n\n``` jsx\nimport { util } from \"prettier\";\n\nfunction ownLine(comment, text, options, ast, isLastComment) {\n  const { precedingNode } = comment;\n  if (precedingNode && precedingNode.type === \"punctuation\") {\n    util.addTrailingComment(precedingNode, comment);\n    return true;\n  }\n  return false;\n}\n```\n\nNodes with comments are expected to have a `comments` property containing an array of comments. Each comment is expected to have the following properties: `leading`, `trailing`, `printed`.\n\nThe example above uses `util.addTrailingComment`, which automatically sets `comment.leading`/`trailing`/`printed` to appropriate values and adds the comment to the AST node's `comments` array.\n\nThe `--debug-print-comments` CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (`ownLine`/`endOfLine`/`remaining`, `leading`/`trailing`/`dangling`) and to which node it was attached. For Prettier’s built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).\n\n### `options`\n\n`options` is an object containing the custom options your plugin supports.\n\nExample:\n\n``` jsx\nexport default {\n  // ... plugin implementation\n  options: {\n    openingBraceNewLine: {\n      type: \"boolean\",\n      category: \"Global\",\n      default: true,\n      description: \"Move open brace for code blocks onto new line.\",\n    },\n  },\n};\n```\n\n### `defaultOptions`\n\nIf your plugin requires different default values for some of Prettier’s core options, you can specify them in `defaultOptions`:\n\n``` jsx\nexport default {\n  // ... plugin implementation\n  defaultOptions: {\n    tabWidth: 4,\n  },\n};\n```\n\n### Utility functions\n\nA `util` module from Prettier core is considered a private API and is not meant to be consumed by plugins. Instead, the `util-shared` module provides the following limited set of utility functions for plugins:\n\n``` jsx\ntype Quote = '\"' | \"'\";\ntype SkipOptions = { backwards?: boolean };\n\nfunction getMaxContinuousCount(text: string, searchString: string): number;\n\nfunction getStringWidth(text: string): number;\n\nfunction getAlignmentSize(\n  text: string,\n  tabWidth: number,\n  startIndex?: number,\n): number;\n\nfunction getIndentSize(value: string, tabWidth: number): number;\n\nfunction skip(\n  characters: string | RegExp,\n): (\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n) => number | false;\n\nfunction skipWhitespace(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipSpaces(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipToLineEnd(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipEverythingButNewLine(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction skipInlineComment(\n  text: string,\n  startIndex: number | false,\n): number | false;\n\nfunction skipTrailingComment(\n  text: string,\n  startIndex: number | false,\n): number | false;\n\nfunction skipNewline(\n  text: string,\n  startIndex: number | false,\n  options?: SkipOptions,\n): number | false;\n\nfunction hasNewline(\n  text: string,\n  startIndex: number,\n  options?: SkipOptions,\n): boolean;\n\nfunction hasNewlineInRange(\n  text: string,\n  startIndex: number,\n  startIndex: number,\n): boolean;\n\nfunction hasSpaces(\n  text: string,\n  startIndex: number,\n  options?: SkipOptions,\n): boolean;\n\nfunction makeString(\n  rawText: string,\n  enclosingQuote: Quote,\n  unescapeUnnecessaryEscapes?: boolean,\n): string;\n\nfunction getNextNonSpaceNonCommentCharacter(\n  text: string,\n  startIndex: number,\n): string;\n\nfunction getNextNonSpaceNonCommentCharacterIndex(\n  text: string,\n  startIndex: number,\n): number | false;\n\nfunction isNextLineEmpty(text: string, startIndex: number): boolean;\n\nfunction isPreviousLineEmpty(text: string, startIndex: number): boolean;\n```\n\n### Tutorials\n\n- [How to write a plugin for Prettier](https://medium.com/@fvictorio/how-to-write-a-plugin-for-prettier-a0d98c845e70): Teaches you how to write a very basic Prettier plugin for TOML.\n\n## Testing Plugins\n\nSince plugins can be resolved using relative paths, when working on one you can do:\n\n``` jsx\nimport * as prettier from \"prettier\";\nconst code = \"(add 1 2)\";\nawait prettier.format(code, {\n  parser: \"lisp\",\n  plugins: [\".\"],\n});\n```\n\nThis will resolve a plugin relative to the current working directory.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/plugins](https://prettier.io/docs/en/plugins)"
- name: Pre-commit Hook
  id: precommit
  summary: You can use Prettier with a pre-commit tool
  description: "# Pre-commit Hook\n\nYou can use Prettier with a pre-commit tool. This can re-format your files that are marked as “staged” via `git add` before you commit.\n\n## Option 1. [lint-staged](https://github.com/okonet/lint-staged)\n\n**Use Case:** Useful for when you want to use other code quality tools along with Prettier (e.g. ESLint, Stylelint, etc.) or if you need support for partially staged files (`git add --patch`).\n\n*Make sure Prettier is installed and is in your [`devDependencies`](https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file) before you proceed.*\n\n``` jsx\nnpx mrm@2 lint-staged\n```\n\nThis will install [husky](https://github.com/typicode/husky) and [lint-staged](https://github.com/okonet/lint-staged), then add a configuration to the project’s `package.json` that will automatically format supported files in a pre-commit hook.\n\nRead more at the [lint-staged](https://github.com/okonet/lint-staged#configuration) repo.\n\n## Option 2. [Husky.Net](https://github.com/alirezanet/Husky.Net)\n\n**Use Case:** A dotnet solution to use Prettier along with other code quality tools (e.g. dotnet-format, ESLint, Stylelint, etc.). It supports multiple file states (staged - last-commit, git-files etc.)\n\n``` jsx\ndotnet new tool-manifest\ndotnet tool install husky\ndotnet husky install\ndotnet husky add pre-commit\n```\n\nafter installation you can add prettier task to the `task-runner.json`.\n\n``` jsx\n{\n  \"command\": \"npx\",\n  \"args\": [\"prettier\", \"--ignore-unknown\", \"--write\", \"${staged}\"],\n  \"pathMode\": \"absolute\"\n}\n```\n\n## Option 3. [git-format-staged](https://github.com/hallettj/git-format-staged)\n\n**Use Case:** Great for when you want to format partially-staged files, and other options do not provide a good fit for your project.\n\nGit-format-staged is used to run any formatter that can accept file content via stdin. It operates differently than other tools that format partially-staged files: it applies the formatter directly to objects in the git object database, and merges changes back to the working tree. This procedure provides several guarantees:\n\n1.  Changes in commits are always formatted.\n2.  Unstaged changes are never, under any circumstances staged during the formatting process.\n3.  If there are conflicts between formatted, staged changes and unstaged changes then your working tree files are left untouched - your work won’t be overwritten, and there are no stashes to clean up.\n4.  Unstaged changes are not formatted.\n\nGit-format-staged requires Python v3 or v2.7. Python is usually pre-installed on Linux and macOS, but not on Windows. Use git-format-staged with [husky](https://github.com/typicode/husky):\n\nnpm\n\nyarn\n\npnpm\n\nbun\n\n``` jsx\nnpx husky init\nnpm install --save-dev git-format-staged\nnode --eval \"fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \\'prettier --ignore-unknown --stdin --stdin-filepath \\\"{}\\\"\\' .\\n')\"\n```\n\n``` jsx\nyarn husky init\nyarn add --dev git-format-staged\nnode --eval \"fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \\'prettier --ignore-unknown --stdin --stdin-filepath \\\"{}\\\"\\' .\\n')\"\n```\n\n``` jsx\npnpm exec husky init\npnpm add --save-dev git-format-staged\nnode --eval \"fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \\'prettier --ignore-unknown --stdin --stdin-filepath \\\"{}\\\"\\' .\\n')\"\n```\n\n``` jsx\nbunx husky init\nbun add --dev git-format-staged\nbun --eval \"fs.writeFileSync('.husky/pre-commit', 'git-format-staged -f \\'prettier --ignore-unknown --stdin --stdin-filepath \\\"{}\\\"\\' .\\n')\"\n```\n\nAdd or remove file extensions to suit your project. Note that regardless of which extensions you list formatting will respect any `.prettierignore` files in your project.\n\nTo read about how git-format-staged works see [Automatic Code Formatting for Partially-Staged Files](https://www.olioapps.com/blog/automatic-code-formatting/).\n\n## Option 4. Shell script\n\nAlternately you can save this script as `.git/hooks/pre-commit` and give it execute permission:\n\n``` jsx\n#!/bin/sh\nFILES=$(git diff --cached --name-only --diff-filter=ACMR | sed 's| |\\\\ |g')\n[ -z \"$FILES\" ] && exit 0\n\n# Prettify all selected files\necho \"$FILES\" | xargs ./node_modules/.bin/prettier --ignore-unknown --write\n\n# Add back the modified/prettified files to staging\necho \"$FILES\" | xargs git add\n\nexit 0\n```\n\nIf git is reporting that your prettified files are still modified after committing, you may need to add a [post-commit script to update git’s index](https://github.com/prettier/prettier/issues/2978#issuecomment-334408427).\n\nAdd something like the following to `.git/hooks/post-commit`:\n\n``` jsx\n#!/bin/sh\ngit update-index -g\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/precommit](https://prettier.io/docs/en/precommit)"
- name: Prettier vs. Linters
  id: comparison
  summary: Prettier does nothing to help with those kind of rules
  description: "# Prettier vs. Linters\n\n## How does it compare to ESLint/TSLint/stylelint, etc.?\n\nLinters have two categories of rules:\n\n**Formatting rules**: eg: [max-len](https://eslint.org/docs/rules/max-len), [no-mixed-spaces-and-tabs](https://eslint.org/docs/rules/no-mixed-spaces-and-tabs), [keyword-spacing](https://eslint.org/docs/rules/keyword-spacing), [comma-style](https://eslint.org/docs/rules/comma-style)…\n\nPrettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it’s not possible for the programmer to make a mistake there anymore :)\n\n**Code-quality rules**: eg [no-unused-vars](https://eslint.org/docs/rules/no-unused-vars), [no-extra-bind](https://eslint.org/docs/rules/no-extra-bind), [no-implicit-globals](https://eslint.org/docs/rules/no-implicit-globals), [prefer-promise-reject-errors](https://eslint.org/docs/rules/prefer-promise-reject-errors)…\n\nPrettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!\n\nIn other words, use **Prettier for formatting** and **linters for catching bugs!**\n\n© James Long and contributors  \n[https://prettier.io/docs/en/comparison](https://prettier.io/docs/en/comparison)"
- name: prettier.check(source [, options])
  id: api#prettierchecksource--options
  summary: check checks to see if the file has been formatted with Prettier given those options and returns a Promise<boolean>. This is similar to the --check or --list-different parameter in the CLI and is useful for running Prettier in CI scenarios
  belongs_to: API
  description: |-
    ## `prettier.check(source [, options])`

    `check` checks to see if the file has been formatted with Prettier given those options and returns a `Promise<boolean>`. This is similar to the `--check` or `--list-different` parameter in the CLI and is useful for running Prettier in CI scenarios.
- name: prettier.clearConfigCache()
  id: api#prettierclearconfigcache
  summary: When Prettier loads configuration files and plugins, the file system structure is cached for performance
  belongs_to: API
  description: |-
    ## `prettier.clearConfigCache()`

    When Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.
- name: prettier.format(source, options)
  id: api#prettierformatsource-options
  summary: format is used to format text using Prettier
  belongs_to: API
  description: |-
    ## `prettier.format(source, options)`

    `format` is used to format text using Prettier. `options.parser` must be set according to the language you are formatting (see the [list of available parsers](options#parser)). Alternatively, `options.filepath` can be specified for Prettier to infer the parser from the file extension. Other [options](options) may be provided to override the defaults.

    ``` jsx
    await prettier.format("foo ( );", { semi: false, parser: "babel" });
    // -> 'foo()\n'
    ```
- name: prettier.formatWithCursor(source [, options])
  id: api#prettierformatwithcursorsource--options
  summary: formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code
  belongs_to: API
  description: |-
    ## `prettier.formatWithCursor(source [, options])`

    `formatWithCursor` both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.

    The `cursorOffset` option should be provided, to specify where the cursor is.

    ``` jsx
    await prettier.formatWithCursor(" 1", { cursorOffset: 2, parser: "babel" });
    // -> { formatted: '1;\n', cursorOffset: 1 }
    ```
- name: prettier.getFileInfo(fileUrlOrPath [, options])
  id: api#prettiergetfileinfofileurlorpath--options
  summary: getFileInfo can be used by editor extensions to decide if a particular file needs to be formatted
  belongs_to: API
  description: |-
    ## `prettier.getFileInfo(fileUrlOrPath [, options])`

    `getFileInfo` can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:

    ``` jsx
    {
      ignored: boolean;
      inferredParser: string | null;
    }
    ```

    The promise will be rejected if the type of `fileUrlOrPath` is not `string` or `URL`.

    Setting `options.ignorePath` (`string | URL | (string | URL)[]`) and `options.withNodeModules` (`boolean`) influence the value of `ignored` (`false` by default).

    If the given `fileUrlOrPath` is ignored, the `inferredParser` is always `null`.

    Providing [plugin](plugins) paths in `options.plugins` (`string[]`) helps extract `inferredParser` for files that are not supported by Prettier core.

    When setting `options.resolveConfig` (`boolean`, default `true`) to `false`, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.
- name: prettier.getSupportInfo()
  id: api#prettiergetsupportinfo
  summary: Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports
  belongs_to: API
  description: |-
    ## `prettier.getSupportInfo()`

    Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.

    The support information looks like this:

    ``` jsx
    {
      languages: Array<{
        name: string;
        parsers: string[];
        group?: string;
        tmScope?: string;
        aceMode?: string;
        codemirrorMode?: string;
        codemirrorMimeType?: string;
        aliases?: string[];
        extensions?: string[];
        filenames?: string[];
        linguistLanguageId?: number;
        vscodeLanguageIds?: string[];
      }>;
    }
    ```
- name: prettier.resolveConfig(fileUrlOrPath [, options])
  id: api#prettierresolveconfigfileurlorpath--options
  summary: resolveConfig can be used to resolve configuration for a given source file, passing its path or url as the first argument
  belongs_to: API
  description: |-
    ## `prettier.resolveConfig(fileUrlOrPath [, options])`

    `resolveConfig` can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as `options.config` if you don’t wish to search for it. A promise is returned which will resolve to:

    - An options object, providing a [config file](configuration) was found.
    - `null`, if no file was found.

    The promise will be rejected if there was an error parsing the configuration file.

    If `options.useCache` is `false`, all caching will be bypassed.

    ``` jsx
    const text = await fs.readFile(filePath, "utf8");
    const options = await prettier.resolveConfig(filePath);
    const formatted = await prettier.format(text, options);
    ```

    If `options.editorconfig` is `true` and an [`.editorconfig` file](https://editorconfig.org/) is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by `.prettierrc`, etc. Currently, the following EditorConfig properties are supported:

    - `end_of_line`
    - `indent_style`
    - `indent_size`/`tab_width`
    - `max_line_length`
- name: prettier.resolveConfigFile([fileUrlOrPath])
  id: api#prettierresolveconfigfilefileurlorpath
  summary: resolveConfigFile can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e
  belongs_to: API
  description: |-
    ## `prettier.resolveConfigFile([fileUrlOrPath])`

    `resolveConfigFile` can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling `resolveConfig`). A promise is returned which will resolve to:

    - The path of the configuration file.
    - `null`, if no file was found.

    The promise will be rejected if there was an error parsing the configuration file.

    The search starts at `process.cwd()`, or at the directory of `fileUrlOrPath` if provided.

    ``` jsx
    const configFile = await prettier.resolveConfigFile(filePath);
    // you got the path of the configuration file
    ```
- name: Print Width
  id: options#print-width
  summary: Specify the line length that the printer will wrap on
  belongs_to: Options
  description: |-
    ## Print Width

    Specify the line length that the printer will wrap on.

    > **For readability we recommend against using more than 80 characters:**
    >
    > In code styleguides, maximum line length rules are often set to 100 or 120. However, when humans write code, they don’t strive to reach the maximum number of columns on every line. Developers often use whitespace to break up long lines for readability. In practice, the average line length often ends up well below the maximum.
    >
    > Prettier’s printWidth option does not work the same way. It is not the hard upper allowed line length limit. It is a way to say to Prettier roughly how long you’d like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified printWidth.
    >
    > Remember, computers are dumb. You need to explicitly tell them what to do, while humans can make their own (implicit) judgements, for example on when to break a line.
    >
    > In other words, don’t try to use printWidth as if it was ESLint’s [max-len](https://eslint.org/docs/rules/max-len) – they’re not the same. max-len just says what the maximum allowed line length is, but not what the generally preferred length is – which is what printWidth specifies.

    | Default | CLI Override          | API Override        |
    |---------|-----------------------|---------------------|
    | `80`    | `--print-width <int>` | `printWidth: <int>` |

    Setting `max_line_length` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s print width, unless overridden.

    (If you don’t want line wrapping when formatting Markdown, you can set the [Prose Wrap](#prose-wrap) option to disable it.)
- name: Prose Wrap
  id: options#prose-wrap
  summary: By default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g
  belongs_to: Options
  description: |-
    ## Prose Wrap

    *First available in v1.8.2*

    By default, Prettier will not change wrapping in markdown text since some services use a linebreak-sensitive renderer, e.g. GitHub comments and BitBucket. To have Prettier wrap prose to the print width, change this option to "always". If you want Prettier to force all prose blocks to be on a single line and rely on editor/viewer soft wrapping instead, you can use `"never"`.

    Valid options:

    - `"always"` - Wrap prose if it exceeds the print width.
    - `"never"` - Un-wrap each block of prose into one line.
    - `"preserve"` - Do nothing, leave prose as-is. *First available in v1.9.0*

    | Default      | CLI Override                           | API Override                           |
    |--------------|----------------------------------------|----------------------------------------|
    | `"preserve"` | `--prose-wrap <always|never|preserve>` | `proseWrap: "<always|never|preserve>"` |
- name: Quote Props
  id: options#quote-props
  summary: Change when properties in objects are quoted
  belongs_to: Options
  description: |-
    ## Quote Props

    Change when properties in objects are quoted.

    Valid options:

    - `"as-needed"` - Only add quotes around object properties where required.
    - `"consistent"` - If at least one property in an object requires quotes, quote all properties.
    - `"preserve"` - Respect the input use of quotes in object properties.

    | Default       | CLI Override                                    | API Override                                    |
    |---------------|-------------------------------------------------|-------------------------------------------------|
    | `"as-needed"` | `--quote-props <as-needed|consistent|preserve>` | `quoteProps: "<as-needed|consistent|preserve>"` |

    Note that Prettier never unquotes numeric property names in Angular expressions, TypeScript, and Flow because the distinction between string and numeric keys is significant in these languages. See: [Angular](https://codesandbox.io/s/hungry-morse-foj87?file=/src/app/app.component.html), [TypeScript](https://www.typescriptlang.org/play?#code/DYUwLgBAhhC8EG8IEYBcKA0EBM7sQF8AoUSAIzkQgHJlr1ktrt6dCiiATEAY2CgBOICKWhR0AaxABPAPYAzCGGkAHEAugBuLr35CR4CGTKSZG5Wo1ltRKDHjHtQA), [Flow](https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBjOA7AzgFzAA8wBeMAb1TDAAYAuMARlQF8g). Also Prettier doesn’t unquote numeric properties for Vue (see the [issue](https://github.com/prettier/prettier/issues/10127) about that).
- name: Quotes
  id: options#quotes
  summary: Use single quotes instead of double quotes
  belongs_to: Options
  description: |-
    ## Quotes

    Use single quotes instead of double quotes.

    Notes:

    - JSX quotes ignore this option – see [jsx-single-quote](#jsx-quotes).
    - If the number of quotes outweighs the other quote, the quote which is less used will be used to format the string - Example: `"I'm double quoted"` results in `"I'm double quoted"` and `"This \"example\" is single quoted"` results in `'This "example" is single quoted'`.

    See the [strings rationale](rationale#strings) for more information.

    | Default | CLI Override     | API Override          |
    |---------|------------------|-----------------------|
    | `false` | `--single-quote` | `singleQuote: <bool>` |
- name: Range
  id: options#range
  summary: Format only a segment of a file
  belongs_to: Options
  description: |-
    ## Range

    Format only a segment of a file.

    These two options can be used to format code starting and ending at a given character offset (inclusive and exclusive, respectively). The range will extend:

    - Backwards to the start of the first line containing the selected statement.
    - Forwards to the end of the selected statement.

    | Default    | CLI Override          | API Override        |
    |------------|-----------------------|---------------------|
    | `0`        | `--range-start <int>` | `rangeStart: <int>` |
    | `Infinity` | `--range-end <int>`   | `rangeEnd: <int>`   |
- name: Rationale
  id: rationale
  summary: Prettier is an opinionated code formatter
  description: "# Rationale\n\nPrettier is an opinionated code formatter. This document explains some of its choices.\n\n## What Prettier is concerned about\n\n### Correctness\n\nThe first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules — that’s a bug which needs to be fixed!\n\n### Strings\n\nDouble or single quotes? Prettier chooses the one which results in the fewest number of escapes. `\"It's gettin' better!\"`, not `'It\\'s gettin\\' better!'`. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the [singleQuote](options#quotes) option).\n\nJSX has its own option for quotes: [jsxSingleQuote](options#jsx-quotes). JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for \"HTML\" (JSX).\n\nPrettier maintains the way your string is escaped. For example, `\"🙂\"` won’t be formatted into `\"\\uD83D\\uDE42\"` and vice versa.\n\n### Empty lines\n\nIt turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:\n\n- Prettier collapses multiple blank lines into a single blank line.\n- Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)\n\n### Multi-line objects\n\nBy default, Prettier’s printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See [object lists](https://github.com/prettier/prettier/issues/74#issue-199965534), [nested configs](https://github.com/prettier/prettier/issues/88#issuecomment-275448346), [stylesheets](https://github.com/prettier/prettier/issues/74#issuecomment-275262094) and [keyed methods](https://github.com/prettier/prettier/pull/495#issuecomment-275745434), for example. We haven’t been able to find a good rule for all those cases, so Prettier instead keeps objects multiline if there’s a newline between the `{` and the first key in the original source code. A consequence of this is that long singleline objects are automatically expanded, but short multiline objects are never collapsed.\n\n**Tip:** If you have a multiline object that you’d like to join up into a single line:\n\n``` jsx\nconst user = {\n  name: \"John Doe\",\n  age: 30,\n};\n```\n\n…all you need to do is remove the newline after `{`:\n\n``` jsx\nconst user = {  name: \"John Doe\",\n  age: 30\n};\n```\n\n…and then run Prettier:\n\n``` jsx\nconst user = { name: \"John Doe\", age: 30 };\n```\n\nAnd if you’d like to go multiline again, add in a newline after `{`:\n\n``` jsx\nconst user = {\n name: \"John Doe\", age: 30 };\n```\n\n…and run Prettier:\n\n``` jsx\nconst user = {\n  name: \"John Doe\",\n  age: 30,\n};\n```\n\n> #### ♻️ A note on formatting reversibility\n>\n> The semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn’t found and an urgent fix was needed. However, as a general strategy, Prettier avoids *non-reversible* formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it’s applied.\n>\n> What does **reversible** mean? Once an object literal becomes multiline, Prettier won’t collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.\n\n### Decorators\n\nJust like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators *above* the line they're decorating, sometimes it’s nicer if they're on the *same* line. We haven’t been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn’t ideal, but a pragmatic solution to a difficult problem.\n\n``` jsx\n@Component({\n  selector: \"hero-button\",\n  template: `<button>{{ label }}</button>`,\n})\nclass HeroButtonComponent {\n  // These decorators were written inline and fit on the line so they stay\n  // inline.\n  @Output() change = new EventEmitter();\n  @Input() label: string;\n\n  // These were written multiline, so they stay multiline.\n  @readonly\n  @nonenumerable\n  NODE_TYPE: 2;\n}\n```\n\nThere’s one exception: classes. We don’t think it ever makes sense to inline the decorators for them, so they are always moved to their own line.\n\n``` jsx\n// Before running Prettier:\n@observer class OrderLine {\n  @observable price: number = 0;\n}\n```\n\n``` jsx\n// After running Prettier:\n@observer\nclass OrderLine {\n  @observable price: number = 0;\n}\n```\n\nNote: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:\n\n``` jsx\n@observer\nclass OrderLine {\n  @observable price: number = 0;\n  @observable\n  amount: number = 0;\n}\n```\n\nOne final thing: TC39 has [not yet decided if decorators come before or after `export`](https://github.com/tc39/proposal-decorators/issues/69). In the meantime, Prettier supports both:\n\n``` jsx\n@decorator export class Foo {}\n\nexport @decorator class Foo {}\n```\n\n### Template literals\n\nTemplate literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.\n\nThis means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:\n\n``` jsx\n`this is a long message which contains an interpolation: ${format(data)} <- like this`;\n```\n\nIf you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the `${...}`. Otherwise it will keep everything on a single line, no matter how long it is.\n\nThe team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.\n\n### Semicolons\n\nThis is about using the [noSemi](options#semicolons) option.\n\nConsider this piece of code:\n\n``` jsx\nif (shouldAddLines) {\n  [-1, 1].forEach(delta => addLine(delta * 20))\n}\n```\n\nWhile the above code works just fine without semicolons, Prettier actually turns it into:\n\n``` jsx\nif (shouldAddLines) {\n  ;[-1, 1].forEach(delta => addLine(delta * 20))\n}\n```\n\nThis is to help you avoid mistakes. Imagine Prettier *not* inserting that semicolon and adding this line:\n\n``` jsx\n if (shouldAddLines) {\n+  console.log('Do we even get here??')\n   [-1, 1].forEach(delta => addLine(delta * 20))\n }\n```\n\nOops! The above actually means:\n\n``` jsx\nif (shouldAddLines) {\n  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))\n}\n```\n\nWith a semicolon in front of that `[` such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.\n\nThis practice is also common in [standard](https://standardjs.com/rules.html#semicolons) which uses a semicolon-free style.\n\nNote that if your program currently has a semicolon-related bug in it, Prettier *will not* auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the `(`:\n\n``` jsx\nconsole.log('Running a background task')\n(async () => {\n  await doBackgroundWork()\n})()\n```\n\nIf you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.\n\n``` jsx\nconsole.log(\"Running a background task\")(async () => {\n  await doBackgroundWork();\n})();\n```\n\n### Print width\n\nThe [printWidth](options#print-width) option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you’d like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.\n\nThere are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which [Prettier doesn’t do](#what-prettier-is-_not_-concerned-about)). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)\n\nApart from that, there are a few cases where Prettier intentionally exceeds the print width.\n\n#### Imports\n\nPrettier can break long `import` statements across several lines:\n\n``` jsx\nimport {\n  CollectionDashboard,\n  DashboardPlaceholder,\n} from \"../components/collections/collection-dashboard/main\";\n```\n\nThe following example doesn’t fit within the print width, but Prettier prints it in a single line anyway:\n\n``` jsx\nimport { CollectionDashboard } from \"../components/collections/collection-dashboard/main\";\n```\n\nThis might be unexpected by some, but we do it this way since it was a common request to keep `import`s with single elements in a single line. The same applies for `require` calls.\n\n#### Testing functions\n\nAnother common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn’t help much.\n\n``` jsx\ndescribe(\"NodeRegistry\", () => {\n  it(\"makes no request if there are no nodes to prefetch, even if the cache is stale\", async () => {\n    // The above line exceeds the print width but stayed on one line anyway.\n  });\n});\n```\n\nPrettier has special cases for common testing framework functions such as `describe`, `it` and `test`.\n\n### JSX\n\nPrettier prints things a little differently compared to other JS when JSX is involved:\n\n``` jsx\nfunction greet(user) {\n  return user\n    ? `Welcome back, ${user.name}!`\n    : \"Greetings, traveler! Sign up today!\";\n}\n\nfunction Greet({ user }) {\n  return (\n    <div>{user ? (\n        <p>Welcome back, {user.name}!</p>\n      ) : (\n        <p>Greetings, traveler! Sign up today!</p>\n      )}</div>\n  );\n}\n```\n\nThere are two reasons.\n\nFirst off, lots of people already wrapped their JSX in parentheses, especially in `return` statements. Prettier follows this common style.\n\nSecondly, [the alternate formatting makes it easier to edit the JSX](https://github.com/prettier/prettier/issues/2208). It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.\n\n``` jsx\n<div><p>Greetings, traveler! Sign up today!</p>; {/* <-- Oops! */}</div>\n```\n\n### Comments\n\nWhen it comes to the *content* of comments, Prettier can’t do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can’t know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a `*`), which Prettier can fix the indentation of.\n\nThen there’s the question of *where* to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it’s no easy task because comments can be placed almost anywhere.\n\nGenerally, you get the best results when placing comments **on their own lines,** instead of at the end of lines. Prefer `// eslint-disable-next-line` over `// eslint-disable-line`.\n\nNote that “magic comments” such as `eslint-disable-next-line` and `$FlowFixMe` might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.\n\nImagine this piece of code:\n\n``` jsx\n// eslint-disable-next-line no-eval\nconst result = safeToEval ? eval(input) : fallback(input);\n```\n\nThen you need to add another condition:\n\n``` jsx\n// eslint-disable-next-line no-eval\nconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);\n```\n\nPrettier will turn the above into:\n\n``` jsx\n// eslint-disable-next-line no-eval\nconst result =\n  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);\n```\n\nWhich means that the `eslint-disable-next-line` comment is no longer effective. In this case you need to move the comment:\n\n``` jsx\nconst result =\n  // eslint-disable-next-line no-eval\n  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);\n```\n\nIf possible, prefer comments that operate on line ranges (e.g. `eslint-disable` and `eslint-enable`) or on the statement level (e.g. `/* istanbul ignore next */`), they are even safer. It’s possible to disallow using `eslint-disable-line` and `eslint-disable-next-line` comments using [`eslint-plugin-eslint-comments`](https://github.com/mysticatea/eslint-plugin-eslint-comments).\n\n## Disclaimer about non-standard syntax\n\nPrettier is often able to recognize and format non-standard syntax such as ECMAScript early-stage proposals and Markdown syntax extensions not defined by any specification. The support for such syntax is considered best-effort and experimental. Incompatibilities may be introduced in any release and should not be viewed as breaking changes.\n\n## What Prettier is *not* concerned about\n\nPrettier only *prints* code. It does not transform it. This is to limit the scope of Prettier. Let’s focus on the printing and do it really well!\n\nHere are a few examples of things that are out of scope for Prettier:\n\n- Turning single- or double-quoted strings into template literals or vice versa.\n- Using `+` to break long string literals into parts that fit the print width.\n- Adding/removing `{}` and `return` where they are optional.\n- Turning `?:` into `if`-`else` statements.\n- Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a *transform* rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important [correctness](#correctness) goal.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/rationale](https://prettier.io/docs/en/rationale)"
- name: Related Projects
  id: related-projects
  summary: null
  description: "# Related Projects\n\n## ESLint Integrations\n\n- [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) turns off all ESLint rules that are unnecessary or might conflict with Prettier\n- [eslint-plugin-prettier](https://github.com/prettier/eslint-plugin-prettier) runs Prettier as an ESLint rule and reports differences as individual ESLint issues\n- [prettier-eslint](https://github.com/prettier/prettier-eslint) passes `prettier` output to `eslint --fix`\n- [prettier-standard](https://github.com/sheerun/prettier-standard) uses `prettierx` and `prettier-eslint` to format code with `standard` rules\n\n## stylelint Integrations\n\n- [stylelint-config-prettier](https://github.com/prettier/stylelint-config-prettier) turns off all rules that are unnecessary or might conflict with Prettier.\n- [stylelint-prettier](https://github.com/prettier/stylelint-prettier) runs Prettier as a stylelint rule and reports differences as individual stylelint issues\n- [prettier-stylelint](https://github.com/hugomrdias/prettier-stylelint) passes `prettier` output to `stylelint --fix`\n\n## Forks\n\n- [prettierx](https://github.com/brodybits/prettierx) less opinionated fork of Prettier\n\n## Misc\n\n- [parallel-prettier](https://github.com/microsoft/parallel-prettier) is an alternative CLI that formats files in parallel to speed up large projects\n- [prettier_d](https://github.com/josephfrazier/prettier_d.js) runs Prettier as a server to avoid Node.js startup delay\n- [pretty-quick](https://github.com/azz/pretty-quick) formats changed files with Prettier\n- [rollup-plugin-prettier](https://github.com/mjeanroy/rollup-plugin-prettier) allows you to use Prettier with Rollup\n- [jest-runner-prettier](https://github.com/keplersj/jest-runner-prettier) is Prettier as a Jest runner\n- [prettier-chrome](https://github.com/u3u/prettier-chrome) is an extension that runs Prettier in the browser\n- [spotless](https://github.com/diffplug/spotless) lets you run prettier from [gradle](https://github.com/diffplug/spotless/tree/main/plugin-gradle#prettier) or [maven](https://github.com/diffplug/spotless/tree/main/plugin-maven#prettier).\n- [csharpier](https://github.com/belav/csharpier) is a port of Prettier for C#\n- [reviewdog-action-prettier](https://github.com/EPMatt/reviewdog-action-prettier) runs Prettier in GitHub Actions CI/CD workflows\n\n© James Long and contributors  \n[https://prettier.io/docs/en/related-projects](https://prettier.io/docs/en/related-projects)"
- name: Require Pragma
  id: options#require-pragma
  summary: Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file
  belongs_to: Options
  description: "## Require Pragma\n\n*First available in v1.7.0*\n\nPrettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file. This is very useful when gradually transitioning large, unformatted codebases to Prettier.\n\nA file with the following as its first comment will be formatted when `--require-pragma` is supplied:\n\n``` jsx\n      /**\n * @prettier\n */\n    \n```\n\nor\n\n``` jsx\n      /**\n * @format\n */\n    \n```\n\n| Default | CLI Override       | API Override            |\n|---------|--------------------|-------------------------|\n| `false` | `--require-pragma` | `requirePragma: <bool>` |"
- name: Ride the hype train
  id: why-prettier#ride-the-hype-train
  summary: Purely technical aspects of the projects aren’t the only thing people look into when choosing to adopt Prettier
  belongs_to: Why Prettier?
  description: "## Ride the hype train\n\nPurely technical aspects of the projects aren’t the only thing people look into when choosing to adopt Prettier. Who built and uses it and how quickly it spreads through the community has a non-trivial impact.\n\n- “The amazing thing, for me, is: 1) Announced 2 months ago. 2) Already adopted by, it seems, every major JS project. 3) 7000 stars, 100,000 npm downloads/mo”\n- “Was built by the same people as React & React Native.”\n- “I like to be part of the hot new things.”\n- “Because soon enough people are gonna ask for it.”\n\n© James Long and contributors  \n[https://prettier.io/docs/en/why-prettier](https://prettier.io/docs/en/why-prettier)"
- name: Running manually
  id: vim#running-manually
  summary: If you want something really bare-bones, you can create a custom key binding
  belongs_to: Vim Setup
  description: "## Running manually\n\nIf you want something really bare-bones, you can create a custom key binding. In this example, `gp` (mnemonic: \"get pretty\") is used to run prettier (with options) in the currently active buffer:\n\n``` jsx\nnnoremap gp :silent %!prettier --stdin-filepath %<CR>\n```\n\nNote that if there’s a syntax error in your code, the whole buffer will be replaced with an error message. You’ll need to press `u` to get your code back.\n\nAnother disadvantage of this approach is that the cursor position won’t be preserved.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/vim](https://prettier.io/docs/en/vim)"
- name: Semicolons
  id: options#semicolons
  summary: Print semicolons at the ends of statements
  belongs_to: Options
  description: |-
    ## Semicolons

    Print semicolons at the ends of statements.

    Valid options:

    - `true` - Add a semicolon at the end of every statement.
    - `false` - Only add semicolons at the beginning of lines that [may introduce ASI failures](rationale#semicolons).

    | Default | CLI Override | API Override   |
    |---------|--------------|----------------|
    | `true`  | `--no-semi`  | `semi: <bool>` |
- name: Set up your editor
  id: install#set-up-your-editor
  summary: Formatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file
  belongs_to: Install
  description: |-
    ## Set up your editor

    Formatting from the command line is a good way to get started, but you get the most from Prettier by running it from your editor, either via a keyboard shortcut or automatically whenever you save a file. When a line has gotten so long while coding that it won’t fit your screen, just hit a key and watch it magically be wrapped into multiple lines! Or when you paste some code and the indentation gets all messed up, let Prettier fix it up for you without leaving your editor.

    See [Editor Integration](editors) for how to set up your editor. If your editor does not support Prettier, you can instead [run Prettier with a file watcher](watching-files).

    > **Note:** Don’t skip the regular local install! Editor plugins will pick up your local version of Prettier, making sure you use the correct version in every project. (You wouldn’t want your editor accidentally causing lots of changes because it’s using a newer version of Prettier than your project!)
    >
    > And being able to run Prettier from the command line is still a good fallback, and needed for CI setups.
- name: Setting the parser option
  id: configuration#setting-the-parserdocsenoptionshtmlparser-option
  summary: By default, Prettier automatically infers which parser to use based on the input file extension
  belongs_to: Configuration File
  description: |-
    ## Setting the [parser](options#parser) option

    By default, Prettier automatically infers which parser to use based on the input file extension. Combined with `overrides` you can teach Prettier how to parse files it does not recognize.

    For example, to get Prettier to format its own `.prettierrc` file, you can do:

    ``` jsx
    {
      "overrides": [
        {
          "files": ".prettierrc",
          "options": { "parser": "json" }
        }
      ]
    }
    ```

    You can also switch to the `flow` parser instead of the default `babel` for .js files:

    ``` jsx
    {
      "overrides": [
        {
          "files": "*.js",
          "options": {
            "parser": "flow"
          }
        }
      ]
    }
    ```

    **Note:***Never* put the `parser` option at the top level of your configuration. *Only* use it inside `overrides`. Otherwise you effectively disable Prettier’s automatic file extension based parser inference. This forces Prettier to use the parser you specified for *all* types of files – even when it doesn’t make sense, such as trying to parse a CSS file as JavaScript.
- name: Sharing configurations
  id: configuration#sharing-configurations
  summary: If you don’t want to use package.json, you can use any of the supported extensions to export a string, e.g
  belongs_to: Configuration File
  description: "## Sharing configurations\n\nSharing a Prettier configuration is simple: just publish a module that exports a configuration object, say `@company/prettier-config`, and reference it in your `package.json`:\n\n``` jsx\n{\n  \"name\": \"my-cool-library\",\n  \"version\": \"9000.0.1\",\n  \"prettier\": \"@company/prettier-config\"\n}\n```\n\nIf you don’t want to use `package.json`, you can use any of the supported extensions to export a string, e.g. `.prettierrc.json`:\n\n``` jsx\n      \"@company/prettier-config\"\n    \n```\n\nAn example configuration repository is available [here](https://github.com/azz/prettier-config).\n\n> Note: This method does **not** offer a way to *extend* the configuration to overwrite some properties from the shared configuration. If you need to do that, import the file in a `.prettierrc.js` file and export the modifications, e.g:\n>\n> ``` jsx\n> import companyPrettierConfig from \"@company/prettier-config\";\n>\n> export default {\n>   ...companyPrettierConfig,\n>   semi: false,\n> };\n> ```"
- name: Single Attribute Per Line
  id: options#single-attribute-per-line
  summary: Enforce single attribute per line in HTML, Vue and JSX
  belongs_to: Options
  description: "## Single Attribute Per Line\n\n*First available in v2.6.0*\n\nEnforce single attribute per line in HTML, Vue and JSX.\n\nValid options:\n\n- `false` - Do not enforce single attribute per line.\n- `true` - Enforce single attribute per line.\n\n| Default | CLI Override                  | API Override                     |\n|---------|-------------------------------|----------------------------------|\n| `false` | `--single-attribute-per-line` | `singleAttributePerLine: <bool>` |\n\n© James Long and contributors  \n[https://prettier.io/docs/en/options](https://prettier.io/docs/en/options)"
- name: stylelint Integrations
  id: related-projects#stylelint-integrations
  summary: null
  belongs_to: Related Projects
  description: |-
    ## stylelint Integrations

    - [stylelint-config-prettier](https://github.com/prettier/stylelint-config-prettier) turns off all rules that are unnecessary or might conflict with Prettier.
    - [stylelint-prettier](https://github.com/prettier/stylelint-prettier) runs Prettier as a stylelint rule and reports differences as individual stylelint issues
    - [prettier-stylelint](https://github.com/hugomrdias/prettier-stylelint) passes `prettier` output to `stylelint --fix`

    &nbsp;
- name: Sublime Text
  id: editors#sublime-text
  summary: Sublime Text support is available through Package Control and the JsPrettier plug-in
  belongs_to: Editor Integration
  description: |-
    ## Sublime Text

    Sublime Text support is available through Package Control and the [JsPrettier](https://packagecontrol.io/packages/JsPrettier) plug-in.
- name: Summary
  id: install#summary
  summary: null
  belongs_to: Install
  description: "## Summary\n\nTo summarize, we have learned to:\n\n- Install an exact version of Prettier locally in your project. This makes sure that everyone in the project gets the exact same version of Prettier. Even a patch release of Prettier can result in slightly different formatting, so you wouldn’t want different team members using different versions and formatting each other’s changes back and forth.\n- Add a `.prettierrc` to let your editor know that you are using Prettier.\n- Add a `.prettierignore` to let your editor know which files *not* to touch, as well as for being able to run `prettier --write .` to format the entire project (without mangling files you don’t want, or choking on generated files).\n- Run `prettier --check .` in CI to make sure that your project stays formatted.\n- Run Prettier from your editor for the best experience.\n- Use [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) to make Prettier and ESLint play nice together.\n- Set up a pre-commit hook to make sure that every commit is formatted.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/install](https://prettier.io/docs/en/install)"
- name: Tab Width
  id: options#tab-width
  summary: Specify the number of spaces per indentation-level
  belongs_to: Options
  description: |-
    ## Tab Width

    Specify the number of spaces per indentation-level.

    | Default | CLI Override        | API Override      |
    |---------|---------------------|-------------------|
    | `2`     | `--tab-width <int>` | `tabWidth: <int>` |

    Setting `indent_size` or `tab_width` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s tab width, unless overridden.
- name: Tabs
  id: options#tabs
  summary: Indent lines with tabs instead of spaces
  belongs_to: Options
  description: |-
    ## Tabs

    Indent lines with tabs instead of spaces.

    | Default | CLI Override | API Override      |
    |---------|--------------|-------------------|
    | `false` | `--use-tabs` | `useTabs: <bool>` |

    Setting `indent_style` in an [`.editorconfig` file](https://editorconfig.org/) will configure Prettier’s tab usage, unless overridden.

    (Tabs will be used for *indentation* but Prettier uses spaces to *align* things, such as in ternaries. This behavior is known as [SmartTabs](https://www.emacswiki.org/emacs/SmartTabs).)
- name: Technical Details
  id: technical-details
  summary: This printer is a fork of recast’s printer with its algorithm replaced by the one described by Wadler in "A prettier printer". There still may be leftover code from recast that needs to be cleaned up
  description: "# Technical Details\n\nThis printer is a fork of [recast](https://github.com/benjamn/recast)’s printer with its algorithm replaced by the one described by Wadler in \"[A prettier printer](https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf)\". There still may be leftover code from recast that needs to be cleaned up.\n\nThe basic idea is that the printer takes an AST and returns an intermediate representation of the output, and the printer uses that to generate a string. The advantage is that the printer can \"measure\" the IR and see if the output is going to fit on a line, and break if not.\n\nThis means that most of the logic of printing an AST involves generating an abstract representation of the output involving certain commands. For example, `[\"(\", line, arg, line, \")\"]` would represent a concatenation of opening parens, an argument, and closing parens. But if that doesn’t fit on one line, the printer can break where `line` is specified.\n\nThe [Playground](https://prettier.io/playground) has a special mode for exploring how Prettier’s intermediate representation is printed. To get there, open the sidebar (the \"Show options\" button) and set the `parser` option to the special value `doc-explorer`.\n\nMore (rough) details can be found in [commands.md](https://github.com/prettier/prettier/blob/main/commands.md).\n\n© James Long and contributors  \n[https://prettier.io/docs/en/technical-details](https://prettier.io/docs/en/technical-details)"
- name: Testing Plugins
  id: plugins#testing-plugins
  summary: This will resolve a plugin relative to the current working directory
  belongs_to: Plugins
  description: "## Testing Plugins\n\nSince plugins can be resolved using relative paths, when working on one you can do:\n\n``` jsx\nimport*as prettier from \"prettier\";\nconst code = \"(add 1 2)\";\nawait prettier.format(code, {\n  parser: \"lisp\",\n  plugins: [\".\"],\n});\n```\n\nThis will resolve a plugin relative to the current working directory.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/plugins](https://prettier.io/docs/en/plugins)"
- name: Trailing Commas
  id: options#trailing-commas
  summary: Print trailing commas wherever possible in multi-line comma-separated syntactic structures
  belongs_to: Options
  description: |-
    ## Trailing Commas

    *Default value changed from `es5` to `all` in v3.0.0*

    Print trailing commas wherever possible in multi-line comma-separated syntactic structures. (A single-line array, for example, never gets trailing commas.)

    Valid options:

    - `"all"` - Trailing commas wherever possible (including [function parameters and calls](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas#Trailing_commas_in_functions)). To run, JavaScript code formatted this way needs an engine that supports ES2017 (Node.js 8+ or a modern browser) or [downlevel compilation](https://babeljs.io/docs/en/index). This also enables trailing commas in type parameters in TypeScript (supported since TypeScript 2.7 released in January 2018).
    - `"es5"` - Trailing commas where valid in ES5 (objects, arrays, etc.). Trailing commas in type parameters in TypeScript and Flow.
    - `"none"` - No trailing commas.

    | Default | CLI Override                      | API Override                      |
    |---------|-----------------------------------|-----------------------------------|
    | `"all"` | `--trailing-comma <all|es5|none>` | `trailingComma: "<all|es5|none>"` |
- name: Usage
  id: browser#usage
  summary: Note that the unpkg field in Prettier’s package.json points to standalone.js, that’s why https://unpkg.com/prettier can also be used instead of https://unpkg.com/prettier/standalone.js
  belongs_to: Browser
  description: "## Usage\n\n### Global\n\n``` jsx\n      \n        <script\n        src\n        =\"https://unpkg.com/prettier@3.3.3/standalone.js\"\n        >\n      \n      \n        </script\n        >\n      \n      \n        <script\n        src\n        =\"https://unpkg.com/prettier@3.3.3/plugins/graphql.js\"\n        >\n      \n      \n        </script\n        >\n      \n      \n        <script\n        >\n      \n      \n        (async()=>{const formatted = await prettier.format(\"type Query { hello: String }\", {\n      parser: \"graphql\",\n      plugins: prettierPlugins,\n    });\n  })();\n\n      \n      \n        </script\n        >\n      \n    \n```\n\nNote that the [`unpkg` field](https://unpkg.com/#examples) in Prettier’s `package.json` points to `standalone.js`, that’s why `https://unpkg.com/prettier` can also be used instead of `https://unpkg.com/prettier/standalone.js`.\n\n### ES Modules\n\n``` jsx\n      \n        <script\n        type\n        =\"module\"\n        >\n      \n      \n        import*as prettier from \"https://unpkg.com/prettier@3.3.3/standalone.mjs\";\n  import prettierPluginGraphql from \"https://unpkg.com/prettier@3.3.3/plugins/graphql.mjs\";\n\n  const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins: [prettierPluginGraphql],\n  });\n\n      \n      \n        </script\n        >\n      \n    \n```\n\n### AMD\n\n``` jsx\ndefine([\"https://unpkg.com/prettier@3.3.3/standalone.js\",\"https://unpkg.com/prettier@3.3.3/plugins/graphql.js\",],async(prettier, ...plugins)=>{const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins,\n  });\n});\n```\n\n### CommonJS\n\n``` jsx\nconst prettier = require(\"prettier/standalone\");\nconst plugins = [require(\"prettier/plugins/graphql\")];\n\n(async () => {\n  const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins,\n  });\n})();\n```\n\nThis syntax doesn’t necessarily work in the browser, but it can be used when bundling the code with browserify, Rollup, webpack, or another bundler.\n\n### Worker\n\n``` jsx\nimportScripts(\"https://unpkg.com/prettier@3.3.3/standalone.js\");importScripts(\"https://unpkg.com/prettier@3.3.3/plugins/graphql.js\");(async()=>{const formatted = await prettier.format(\"type Query { hello: String }\", {\n    parser: \"graphql\",\n    plugins: prettierPlugins,\n  });\n})();\n```"
- name: Using Plugins
  id: plugins#using-plugins
  summary: 'Tip: You can set --plugin options multiple times'
  belongs_to: Plugins
  description: |-
    ## Using Plugins

    You can load plugins with:

    - The [CLI](cli), via `--plugin`:

      ``` jsx
      prettier --write main.foo --plugin=prettier-plugin-foo
      ```

      > Tip: You can set `--plugin` options multiple times.

    - The [API](api), via the `plugins` options:

      ``` jsx
      await prettier.format("code", {
        parser: "foo",
        plugins: ["prettier-plugin-foo"],
      });
      ```

    - The [Configuration File](configuration):

      ``` jsx
      {
        "plugins": ["prettier-plugin-foo"]
      }
      ```

    Strings provided to `plugins` are ultimately passed to [`import()` expression](https://nodejs.org/api/esm.html#import-expressions), so you can provide a module/package name, a path, or anything else `import()` takes.
- name: Vim
  id: editors#vim
  summary: vim-prettier is a Prettier-specific Vim plugin
  belongs_to: Editor Integration
  description: |-
    ## Vim

    [vim-prettier](https://github.com/prettier/vim-prettier) is a Prettier-specific Vim plugin. [Neoformat](https://github.com/sbdchd/neoformat), [ALE](https://github.com/w0rp/ale), and [coc-prettier](https://github.com/neoclide/coc-prettier) are multi-language Vim linter/formatter plugins that support Prettier.

    For more details see [the Vim setup guide](vim).
- name: Vim Setup
  id: vim
  summary: Vim users can install either vim-prettier, which is Prettier specific, or Neoformat or ALE which are generalized lint/format engines with support for Prettier
  description: "# Vim Setup\n\nVim users can install either [vim-prettier](https://github.com/prettier/vim-prettier), which is Prettier specific, or [Neoformat](https://github.com/sbdchd/neoformat) or [ALE](https://github.com/dense-analysis/ale) which are generalized lint/format engines with support for Prettier.\n\n## [vim-prettier](https://github.com/prettier/vim-prettier)\n\nSee the [vim-prettier](https://github.com/prettier/vim-prettier) readme for installation and usage instructions.\n\n## [Neoformat](https://github.com/sbdchd/neoformat)\n\nThe best way to install Neoformat is with your favorite plugin manager for Vim, such as [vim-plug](https://github.com/junegunn/vim-plug):\n\n``` jsx\nPlug 'sbdchd/neoformat'\n```\n\nIn order for Neoformat to use a project-local version of Prettier (i.e. to use `node_modules/.bin/prettier` instead of looking for `prettier` on `$PATH`), you must set the `neoformat_try_node_exe` option:\n\n``` jsx\nlet g:neoformat_try_node_exe = 1\n```\n\nRun `:Neoformat` or `:Neoformat prettier` in a supported file to run Prettier.\n\nTo have Neoformat run Prettier on save:\n\n``` jsx\nautocmd BufWritePre *.js Neoformat\n```\n\nYou can also make Vim format your code more frequently, by setting an `autocmd` for other events. Here are a couple of useful ones:\n\n- `TextChanged`: after a change was made to the text in Normal mode\n- `InsertLeave`: when leaving Insert mode\n\nFor example, you can format on both of the above events together with `BufWritePre` like this:\n\n``` jsx\nautocmd BufWritePre,TextChanged,InsertLeave *.js Neoformat\n```\n\nSee `:help autocmd-events` in Vim for details.\n\nIt’s recommended to use a [config file](configuration), but you can also add options in your `.vimrc`:\n\n``` jsx\nautocmd FileType javascript setlocal formatprg=prettier\\ --single-quote\\ --trailing-comma\\ es5\n\" Use formatprg when available\nlet g:neoformat_try_formatprg = 1\n```\n\nEach space in Prettier options should be escaped with `\\`.\n\n## [ALE](https://github.com/dense-analysis/ale)\n\nALE requires either Vim 8 or Neovim as ALE makes use of the asynchronous abilities that both Vim 8 and Neovim provide.\n\nThe best way to install ALE is with your favorite plugin manager for Vim, such as [vim-plug](https://github.com/junegunn/vim-plug):\n\n``` jsx\nPlug 'dense-analysis/ale'\n```\n\nYou can find further instructions on the [ALE repository](https://github.com/dense-analysis/ale#3-installation).\n\nALE will try to use Prettier installed locally before looking for a global installation.\n\nEnable the Prettier fixer for the languages you use:\n\n``` jsx\nlet g:ale_fixers = {\n\\   'javascript': ['prettier'],\n\\   'css': ['prettier'],\n\\}\n```\n\nALE supports both *linters* and *fixers*. If you don’t specify which *linters* to run, **all available tools for all supported languages will be run,** and you might get a correctly formatted file with a bunch of lint errors. To disable this behavior you can tell ALE to run only linters you've explicitly configured (more info in the [FAQ](https://github.com/dense-analysis/ale/blob/ed8104b6ab10f63c78e49b60d2468ae2656250e9/README.md#faq-disable-linters)):\n\n``` jsx\nlet g:ale_linters_explicit = 1\n```\n\nYou can then run `:ALEFix` in a JavaScript or CSS file to run Prettier.\n\nTo have ALE run Prettier on save:\n\n``` jsx\nlet g:ale_fix_on_save = 1\n```\n\nIt’s recommended to use a [config file](configuration), but you can also add options in your `.vimrc`:\n\n``` jsx\nlet g:ale_javascript_prettier_options = '--single-quote --trailing-comma all'\n```\n\n## [coc-prettier](https://github.com/neoclide/coc-prettier)\n\nPrettier extension for [coc.nvim](https://github.com/neoclide/coc.nvim) which requires neovim or vim8.1. Install coc.nvim with your favorite plugin manager, such as [vim-plug](https://github.com/junegunn/vim-plug):\n\n``` jsx\nPlug 'neoclide/coc.nvim', {'branch': 'release'}\n```\n\nAnd install coc-prettier by command:\n\n``` jsx\nCocInstall coc-prettier\n```\n\nSetup `Prettier` command in your `init.vim` or `.vimrc`\n\n``` jsx\ncommand! -nargs=0 Prettier :call CocAction('runCommand', 'prettier.formatFile')\n```\n\nUpdate your `coc-settings.json` for languages that you want format on save.\n\n``` jsx\n{\n  \"coc.preferences.formatOnSaveFiletypes\": [\"css\", \"markdown\"]\n}\n```\n\n[coc-prettier](https://github.com/neoclide/coc-prettier) have same configurations of [prettier-vscode](https://github.com/prettier/prettier-vscode), open `coc-settings.json` by `:CocConfig` to get autocompletion support.\n\n## Running manually\n\nIf you want something really bare-bones, you can create a custom key binding. In this example, `gp` (mnemonic: \"get pretty\") is used to run prettier (with options) in the currently active buffer:\n\n``` jsx\nnnoremap gp :silent %!prettier --stdin-filepath %<CR>\n```\n\nNote that if there’s a syntax error in your code, the whole buffer will be replaced with an error message. You’ll need to press `u` to get your code back.\n\nAnother disadvantage of this approach is that the cursor position won’t be preserved.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/vim](https://prettier.io/docs/en/vim)"
- name: vim-prettier
  id: vim#vim-prettierhttpsgithubcomprettiervim-prettier
  summary: See the vim-prettier readme for installation and usage instructions
  belongs_to: Vim Setup
  description: |-
    ## [vim-prettier](https://github.com/prettier/vim-prettier)

    See the [vim-prettier](https://github.com/prettier/vim-prettier) readme for installation and usage instructions.
- name: Visual Studio
  id: editors#visual-studio
  summary: Install the JavaScript Prettier extension
  belongs_to: Editor Integration
  description: |-
    ## Visual Studio

    Install the [JavaScript Prettier extension](https://github.com/madskristensen/JavaScriptPrettier).
- name: Visual Studio Code
  id: editors#visual-studio-code
  summary: prettier-vscode can be installed using the extension sidebar – it’s called “Prettier - Code formatter.” Check its repository for configuration and shortcuts
  belongs_to: Editor Integration
  description: |-
    ## Visual Studio Code

    `prettier-vscode` can be installed using the extension sidebar – it’s called “Prettier - Code formatter.” [Check its repository for configuration and shortcuts](https://github.com/prettier/prettier-vscode).

    If you’d like to toggle the formatter on and off, install [`vscode-status-bar-format-toggle`](https://marketplace.visualstudio.com/items?itemName=tombonnike.vscode-status-bar-format-toggle).
- name: Vue files script and style tags indentation
  id: options#vue-files-script-and-style-tags-indentation
  summary: Whether or not to indent the code inside <script> and <style> tags in Vue files
  belongs_to: Options
  description: |-
    ## Vue files script and style tags indentation

    *First available in v1.19.0*

    Whether or not to indent the code inside `<script>` and `<style>` tags in Vue files.

    Valid options:

    - `false` - Do not indent script and style tags in Vue files.
    - `true` - Indent script and style tags in Vue files.

    | Default | CLI Override                    | API Override                      |
    |---------|---------------------------------|-----------------------------------|
    | `false` | `--vue-indent-script-and-style` | `vueIndentScriptAndStyle: <bool>` |
- name: Watching For Changes
  id: watching-files
  summary: You can have Prettier watch for changes from the command line by using onchange
  description: "# Watching For Changes\n\nYou can have Prettier watch for changes from the command line by using [onchange](https://www.npmjs.com/package/onchange). For example:\n\n``` jsx\nnpx onchange \"**/*\" -- npx prettier --write --ignore-unknown {{changed}}\n```\n\nOr add the following to your `package.json`:\n\n``` jsx\n{\n  \"scripts\": {\n    \"prettier-watch\": \"onchange \\\"**/*\\\" -- prettier --write --ignore-unknown {{changed}}\"\n  }\n}\n```\n\n© James Long and contributors  \n[https://prettier.io/docs/en/watching-files](https://prettier.io/docs/en/watching-files)"
- name: WebStorm Setup
  id: webstorm
  summary: WebStorm comes with built-in support for Prettier
  description: "# WebStorm Setup\n\n## JetBrains IDEs (WebStorm, IntelliJ IDEA, PyCharm, etc.)\n\nWebStorm comes with built-in support for Prettier. If you’re using other JetBrains IDE like IntelliJ IDEA, PhpStorm, or PyCharm, make sure you have this [plugin](https://plugins.jetbrains.com/plugin/10456-prettier) installed and enabled in *Preferences / Settings \\| Plugins*.\n\nFirst, you need to install and configure Prettier. You can find instructions on how to do it [here](https://www.jetbrains.com/help/webstorm/prettier.html#ws_prettier_install).\n\nOnce it’s done, you can do a few things in your IDE. You can use the **Reformat with Prettier** action (*Opt+Shift+Cmd+P* on macOS or *Alt+Shift+Ctrl+P* on Windows and Linux) to format the selected code, a file, or a whole directory.\n\nYou can also configure WebStorm to run Prettier on save (*Cmd+S/Ctrl+S*) or use it as the default formatter (*Opt+Cmd+L/Ctrl+Alt+L*). For this, open *Preferences / Settings \\| Languages & Frameworks \\| JavaScript \\| Prettier* and tick the corresponding checkbox: **On save** and/or **On ‘Reformat Code’** action.\n\nBy default, WebStorm will apply formatting to all *.js, .ts, .jsx*, and *.tsx* files that you’ve edited in your project. To apply the formatting to other file types, or to limit formatting to files located only in specific directories, you can customize the default configuration by using [glob patterns](https://github.com/isaacs/node-glob).\n\nFor more information, see [WebStorm online help](https://www.jetbrains.com/help/webstorm/prettier.html).\n\n© James Long and contributors  \n[https://prettier.io/docs/en/webstorm](https://prettier.io/docs/en/webstorm)"
- name: What Prettier is concerned about
  id: rationale#what-prettier-is-concerned-about
  summary: The first requirement of Prettier is to output valid code that has the exact same behavior as before formatting
  belongs_to: Rationale
  description: "## What Prettier is concerned about\n\n### Correctness\n\nThe first requirement of Prettier is to output valid code that has the exact same behavior as before formatting. Please report any code where Prettier fails to follow these correctness rules — that’s a bug which needs to be fixed!\n\n### Strings\n\nDouble or single quotes? Prettier chooses the one which results in the fewest number of escapes. `\"It's gettin' better!\"`, not `'It\\'s gettin\\' better!'`. In case of a tie or the string not containing any quotes, Prettier defaults to double quotes (but that can be changed via the [singleQuote](options#quotes) option).\n\nJSX has its own option for quotes: [jsxSingleQuote](options#jsx-quotes). JSX takes its roots from HTML, where the dominant use of quotes for attributes is double quotes. Browser developer tools also follow this convention by always displaying HTML with double quotes, even if the source code uses single quotes. A separate option allows using single quotes for JS and double quotes for \"HTML\" (JSX).\n\nPrettier maintains the way your string is escaped. For example, `\"🙂\"` won’t be formatted into `\"\\uD83D\\uDE42\"` and vice versa.\n\n### Empty lines\n\nIt turns out that empty lines are very hard to automatically generate. The approach that Prettier takes is to preserve empty lines the way they were in the original source code. There are two additional rules:\n\n- Prettier collapses multiple blank lines into a single blank line.\n- Empty lines at the start and end of blocks (and whole files) are removed. (Files always end with a single newline, though.)\n\n### Multi-line objects\n\nBy default, Prettier’s printing algorithm prints expressions on a single line if they fit. Objects are used for a lot of different things in JavaScript, though, and sometimes it really helps readability if they stay multiline. See [object lists](https://github.com/prettier/prettier/issues/74#issue-199965534), [nested configs](https://github.com/prettier/prettier/issues/88#issuecomment-275448346), [stylesheets](https://github.com/prettier/prettier/issues/74#issuecomment-275262094) and [keyed methods](https://github.com/prettier/prettier/pull/495#issuecomment-275745434), for example. We haven’t been able to find a good rule for all those cases, so Prettier instead keeps objects multiline if there’s a newline between the `{` and the first key in the original source code. A consequence of this is that long singleline objects are automatically expanded, but short multiline objects are never collapsed.\n\n**Tip:** If you have a multiline object that you’d like to join up into a single line:\n\n``` jsx\nconst user = {\n  name: \"John Doe\",\n  age: 30,\n};\n```\n\n…all you need to do is remove the newline after `{`:\n\n``` jsx\nconst user = {  name: \"John Doe\",\n  age: 30\n};\n```\n\n…and then run Prettier:\n\n``` jsx\nconst user = { name: \"John Doe\", age: 30 };\n```\n\nAnd if you’d like to go multiline again, add in a newline after `{`:\n\n``` jsx\nconst user = {\n name: \"John Doe\", age: 30 };\n```\n\n…and run Prettier:\n\n``` jsx\nconst user = {\n  name: \"John Doe\",\n  age: 30,\n};\n```\n\n> #### ♻️ A note on formatting reversibility\n>\n> The semi-manual formatting for object literals is in fact a workaround, not a feature. It was implemented only because at the time a good heuristic wasn’t found and an urgent fix was needed. However, as a general strategy, Prettier avoids *non-reversible* formatting like that, so the team is still looking for heuristics that would allow either to remove this behavior completely or at least to reduce the number of situations where it’s applied.\n>\n> What does **reversible** mean? Once an object literal becomes multiline, Prettier won’t collapse it back. If in Prettier-formatted code, we add a property to an object literal, run Prettier, then change our mind, remove the added property, and then run Prettier again, we might end up with a formatting not identical to the initial one. This useless change might even get included in a commit, which is exactly the kind of situation Prettier was created to prevent.\n\n### Decorators\n\nJust like with objects, decorators are used for a lot of different things. Sometimes it makes sense to write decorators *above* the line they're decorating, sometimes it’s nicer if they're on the *same* line. We haven’t been able to find a good rule for this, so Prettier keeps your decorator positioned like you wrote them (if they fit on the line). This isn’t ideal, but a pragmatic solution to a difficult problem.\n\n``` jsx\n@Component({\n  selector: \"hero-button\",\n  template: `<button>{{ label }}</button>`,\n})\nclass HeroButtonComponent {\n  // These decorators were written inline and fit on the line so they stay\n  // inline.\n  @Output() change = new EventEmitter();\n  @Input() label: string;\n\n  // These were written multiline, so they stay multiline.\n  @readonly\n  @nonenumerable\n  NODE_TYPE: 2;\n}\n```\n\nThere’s one exception: classes. We don’t think it ever makes sense to inline the decorators for them, so they are always moved to their own line.\n\n``` jsx\n// Before running Prettier:@observerclassOrderLine{@observable price: number = 0;\n}\n```\n\n``` jsx\n// After running Prettier:@observerclassOrderLine{@observable price: number = 0;\n}\n```\n\nNote: Prettier 1.14.x and older tried to automatically move your decorators, so if you've run an older Prettier version on your code you might need to manually join up some decorators here and there to avoid inconsistencies:\n\n``` jsx\n@observerclassOrderLine{@observable price: number = 0;\n  @observable\n  amount: number = 0;\n}\n```\n\nOne final thing: TC39 has [not yet decided if decorators come before or after `export`](https://github.com/tc39/proposal-decorators/issues/69). In the meantime, Prettier supports both:\n\n``` jsx\n@decorator export class Foo {}\n\nexport @decorator class Foo {}\n```\n\n### Template literals\n\nTemplate literals can contain interpolations. Deciding whether it's appropriate to insert a linebreak within an interpolation unfortunately depends on the semantic content of the template - for example, introducing a linebreak in the middle of a natural-language sentence is usually undesirable. Since Prettier doesn't have enough information to make this decision itself, it uses a heuristic similar to that used for objects: it will only split an interpolation expression across multiple lines if there was already a linebreak within that interpolation.\n\nThis means that a literal like the following will not be broken onto multiple lines, even if it exceeds the print width:\n\n``` jsx\n      \n        `\n        this is a long message which contains an interpolation: \n        ${format(data)}\n         <- like this\n        `\n      \n      ;\n    \n```\n\nIf you want Prettier to split up an interpolation, you'll need to ensure there's a linebreak somewhere within the `${...}`. Otherwise it will keep everything on a single line, no matter how long it is.\n\nThe team would prefer not to depend on the original formatting in this way, but it's the best heuristic we have at the moment.\n\n### Semicolons\n\nThis is about using the [noSemi](options#semicolons) option.\n\nConsider this piece of code:\n\n``` jsx\nif(shouldAddLines){[-1,1].forEach(delta=>addLine(delta *20))}\n```\n\nWhile the above code works just fine without semicolons, Prettier actually turns it into:\n\n``` jsx\nif(shouldAddLines){;[-1,1].forEach(delta=>addLine(delta *20))}\n```\n\nThis is to help you avoid mistakes. Imagine Prettier *not* inserting that semicolon and adding this line:\n\n``` jsx\n if (shouldAddLines) {\n+  console.log('Do we even get here??')\n   [-1, 1].forEach(delta => addLine(delta * 20))\n }\n```\n\nOops! The above actually means:\n\n``` jsx\nif(shouldAddLines){\n  console.log('Do we even get here??')[-1, 1].forEach(delta => addLine(delta * 20))\n}\n```\n\nWith a semicolon in front of that `[` such issues never happen. It makes the line independent of other lines so you can move and add lines without having to think about ASI rules.\n\nThis practice is also common in [standard](https://standardjs.com/rules.html#semicolons) which uses a semicolon-free style.\n\nNote that if your program currently has a semicolon-related bug in it, Prettier *will not* auto-fix the bug for you. Remember, Prettier only reformats code, it does not change the behavior of the code. Take this buggy piece of code as an example, where the developer forgot to place a semicolon before the `(`:\n\n``` jsx\nconsole.log('Running a background task')\n(async () => {\n  await doBackgroundWork()\n})()\n```\n\nIf you feed this into Prettier, it will not alter the behavior of this code, instead, it will reformat it in a way that shows how this code will actually behave when ran.\n\n``` jsx\nconsole.log(\"Running a background task\")(async () => {\n  await doBackgroundWork();\n})();\n```\n\n### Print width\n\nThe [printWidth](options#print-width) option is more of a guideline to Prettier than a hard rule. It is not the upper allowed line length limit. It is a way to say to Prettier roughly how long you’d like lines to be. Prettier will make both shorter and longer lines, but generally strive to meet the specified print width.\n\nThere are some edge cases, such as really long string literals, regexps, comments and variable names, which cannot be broken across lines (without using code transforms which [Prettier doesn’t do](#what-prettier-is-_not_-concerned-about)). Or if you nest your code 50 levels deep your lines are of course going to be mostly indentation :)\n\nApart from that, there are a few cases where Prettier intentionally exceeds the print width.\n\n#### Imports\n\nPrettier can break long `import` statements across several lines:\n\n``` jsx\nimport{\n  CollectionDashboard,\n  DashboardPlaceholder,\n} from \"../components/collections/collection-dashboard/main\";\n```\n\nThe following example doesn’t fit within the print width, but Prettier prints it in a single line anyway:\n\n``` jsx\nimport{ CollectionDashboard } from \"../components/collections/collection-dashboard/main\";\n```\n\nThis might be unexpected by some, but we do it this way since it was a common request to keep `import`s with single elements in a single line. The same applies for `require` calls.\n\n#### Testing functions\n\nAnother common request was to keep lengthy test descriptions in one line, even if it gets too long. In such cases, wrapping the arguments to new lines doesn’t help much.\n\n``` jsx\n      describe\n      (\n      \"NodeRegistry\"\n      ,\n      (\n      )\n      =>\n      {\n      it\n      (\n      \"makes no request if there are no nodes to prefetch, even if the cache is stale\"\n      ,\n      async\n      (\n      )\n      =>\n      {\n      // The above line exceeds the print width but stayed on one line anyway.\n      }\n      )\n      ;\n      }\n      )\n      ;\n    \n```\n\nPrettier has special cases for common testing framework functions such as `describe`, `it` and `test`.\n\n### JSX\n\nPrettier prints things a little differently compared to other JS when JSX is involved:\n\n``` jsx\nfunctiongreet(user){return user\n    ? `Welcome back, ${user.name}!`\n    : \"Greetings, traveler! Sign up today!\";\n}\n\nfunction Greet({ user }) {\n  return (\n    <div>{user ? (\n        <p>Welcome back, {user.name}!</p>\n      ) : (\n        <p>Greetings, traveler! Sign up today!</p>\n      )}</div>\n  );\n}\n```\n\nThere are two reasons.\n\nFirst off, lots of people already wrapped their JSX in parentheses, especially in `return` statements. Prettier follows this common style.\n\nSecondly, [the alternate formatting makes it easier to edit the JSX](https://github.com/prettier/prettier/issues/2208). It is easy to leave a semicolon behind. As opposed to normal JS, a leftover semicolon in JSX can end up as plain text showing on your page.\n\n``` jsx\n      \n        <div\n        >\n      \n      \n        <p\n        >\n      \n      Greetings, traveler! Sign up today!\n      \n        </p\n        >\n      \n      ; \n      {\n      /* <-- Oops! */\n      }\n      \n        </div\n        >\n      \n    \n```\n\n### Comments\n\nWhen it comes to the *content* of comments, Prettier can’t do much really. Comments can contain everything from prose to commented out code and ASCII diagrams. Since they can contain anything, Prettier can’t know how to format or wrap them. So they are left as-is. The only exception to this are JSDoc-style comments (block comments where every line starts with a `*`), which Prettier can fix the indentation of.\n\nThen there’s the question of *where* to put the comments. Turns out this is a really difficult problem. Prettier tries its best to keep your comments roughly where they were, but it’s no easy task because comments can be placed almost anywhere.\n\nGenerally, you get the best results when placing comments **on their own lines,** instead of at the end of lines. Prefer `// eslint-disable-next-line` over `// eslint-disable-line`.\n\nNote that “magic comments” such as `eslint-disable-next-line` and `$FlowFixMe` might sometimes need to be manually moved due to Prettier breaking an expression into multiple lines.\n\nImagine this piece of code:\n\n``` jsx\n// eslint-disable-next-line no-evalconst result = safeToEval ? eval(input) : fallback(input);\n```\n\nThen you need to add another condition:\n\n``` jsx\n// eslint-disable-next-line no-evalconst result = safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);\n```\n\nPrettier will turn the above into:\n\n``` jsx\n// eslint-disable-next-line no-evalconst result =\n  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);\n```\n\nWhich means that the `eslint-disable-next-line` comment is no longer effective. In this case you need to move the comment:\n\n``` jsx\nconst result =\n  // eslint-disable-next-line no-eval\n  safeToEval && settings.allowNativeEval ? eval(input) : fallback(input);\n```\n\nIf possible, prefer comments that operate on line ranges (e.g. `eslint-disable` and `eslint-enable`) or on the statement level (e.g. `/* istanbul ignore next */`), they are even safer. It’s possible to disallow using `eslint-disable-line` and `eslint-disable-next-line` comments using [`eslint-plugin-eslint-comments`](https://github.com/mysticatea/eslint-plugin-eslint-comments)."
- name: What Prettier is not concerned about
  id: rationale#what-prettier-is-_not_-concerned-about
  summary: Prettier only prints code
  belongs_to: Rationale
  description: "## What Prettier is *not* concerned about\n\nPrettier only *prints* code. It does not transform it. This is to limit the scope of Prettier. Let’s focus on the printing and do it really well!\n\nHere are a few examples of things that are out of scope for Prettier:\n\n- Turning single- or double-quoted strings into template literals or vice versa.\n- Using `+` to break long string literals into parts that fit the print width.\n- Adding/removing `{}` and `return` where they are optional.\n- Turning `?:` into `if`-`else` statements.\n- Sorting/moving imports, object keys, class members, JSX keys, CSS properties or anything else. Apart from being a *transform* rather than just printing (as mentioned above), sorting is potentially unsafe because of side effects (for imports, as an example) and makes it difficult to verify the most important [correctness](#correctness) goal.\n\n© James Long and contributors  \n[https://prettier.io/docs/en/rationale](https://prettier.io/docs/en/rationale)"
- name: Why Prettier?
  id: why-prettier
  summary: By far the biggest reason for adopting Prettier is to stop all the on-going debates over styles
  description: "# Why Prettier?\n\n## Building and enforcing a style guide\n\nBy far the biggest reason for adopting Prettier is to stop all the on-going debates over styles. [It is generally accepted that having a common style guide is valuable for a project and team](https://www.smashingmagazine.com/2012/10/why-coding-style-matters/) but getting there is a very painful and unrewarding process. People get very emotional around particular ways of writing code and nobody likes spending time writing and receiving nits.\n\nSo why choose the “Prettier style guide” over any other random style guide? Because Prettier is the only “style guide” that is fully automatic. Even if Prettier does not format all code 100% the way you’d like, it’s worth the “sacrifice” given the unique benefits of Prettier, don’t you think?\n\n- “We want to free mental threads and end discussions around style. While sometimes fruitful, these discussions are for the most part wasteful.”\n- “Literally had an engineer go through a huge effort of cleaning up all of our code because we were debating ternary style for the longest time and were inconsistent about it. It was dumb, but it was a weird on-going “great debate” that wasted lots of little back and forth bits. It’s far easier for us all to agree now: just run Prettier, and go with that style.”\n- “Getting tired telling people how to style their product code.”\n- “Our top reason was to stop wasting our time debating style nits.”\n- “Having a githook set up has reduced the amount of style issues in PRs that result in broken builds due to ESLint rules or things I have to nit-pick or clean up later.”\n- “I don’t want anybody to nitpick any other person ever again.”\n- “It reminds me of how Steve Jobs used to wear the same clothes every day because he has a million decisions to make and he didn’t want to be bothered to make trivial ones like picking out clothes. I think Prettier is like that.”\n\n## Helping Newcomers\n\nPrettier is usually introduced by people with experience in the current codebase and JavaScript but the people that disproportionally benefit from it are newcomers to the codebase. One may think that it’s only useful for people with very limited programming experience, but we've seen it quicken the ramp up time from experienced engineers joining the company, as they likely used a different coding style before, and developers coming from a different programming language.\n\n- “My motivations for using Prettier are: appearing that I know how to write JavaScript well.”\n- “I always put spaces in the wrong place, now I don’t have to worry about it anymore.”\n- “When you're a beginner you're making a lot of mistakes caused by the syntax. Thanks to Prettier, you can reduce these mistakes and save a lot of time to focus on what really matters.”\n- “As a teacher, I will also tell to my students to install Prettier to help them to learn the JS syntax and have readable files.”\n\n## Writing code\n\nWhat usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code. With Prettier editor integration, you can just press that magic key binding and poof, the code is formatted. This is an eye opening experience if anything else.\n\n- “I want to write code. Not spend cycles on formatting.”\n- “It removed 5% that sucks in our daily life - aka formatting”\n- “We're in 2017 and it’s still painful to break a call into multiple lines when you happen to add an argument that makes it go over the 80 columns limit :(“\n\n## Easy to adopt\n\nWe've worked very hard to use the least controversial coding styles, went through many rounds of fixing all the edge cases and polished the getting started experience. When you're ready to push Prettier into your codebase, not only should it be painless for you to do it technically but the newly formatted codebase should not generate major controversy and be accepted painlessly by your co-workers.\n\n- “It’s low overhead. We were able to throw Prettier at very different kinds of repos without much work.”\n- “It’s been mostly bug free. Had there been major styling issues during the course of implementation we would have been wary about throwing this at our JS codebase. I’m happy to say that’s not the case.”\n- “Everyone runs it as part of their pre commit scripts, a couple of us use the editor on save extensions as well.”\n- “It’s fast, against one of our larger JS codebases we were able to run Prettier in under 13 seconds.”\n- “The biggest benefit for Prettier for us was being able to format the entire code base at once.”\n\n## Clean up an existing codebase\n\nSince coming up with a coding style and enforcing it is a big undertaking, it often slips through the cracks and you are left working on inconsistent codebases. Running Prettier in this case is a quick win, the codebase is now uniform and easier to read without spending hardly any time.\n\n- “Take a look at the code :) I just need to restore sanity.”\n- “We inherited a ~2000 module ES6 code base, developed by 20 different developers over 18 months, in a global team. Felt like such a win without much research.”\n\n## Ride the hype train\n\nPurely technical aspects of the projects aren’t the only thing people look into when choosing to adopt Prettier. Who built and uses it and how quickly it spreads through the community has a non-trivial impact.\n\n- “The amazing thing, for me, is: 1) Announced 2 months ago. 2) Already adopted by, it seems, every major JS project. 3) 7000 stars, 100,000 npm downloads/mo”\n- “Was built by the same people as React & React Native.”\n- “I like to be part of the hot new things.”\n- “Because soon enough people are gonna ask for it.”\n\n© James Long and contributors  \n[https://prettier.io/docs/en/why-prettier](https://prettier.io/docs/en/why-prettier)"
- name: Writing code
  id: why-prettier#writing-code
  summary: What usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code
  belongs_to: Why Prettier?
  description: |-
    ## Writing code

    What usually happens once people are using Prettier is that they realize that they actually spend a lot of time and mental energy formatting their code. With Prettier editor integration, you can just press that magic key binding and poof, the code is formatted. This is an eye opening experience if anything else.

    - “I want to write code. Not spend cycles on formatting.”
    - “It removed 5% that sucks in our daily life - aka formatting”
    - “We're in 2017 and it’s still painful to break a call into multiple lines when you happen to add an argument that makes it go over the 80 columns limit :(“

    &nbsp;
- name: YAML
  id: ignore#yaml
  summary: null
  belongs_to: Ignoring Code
  description: "## YAML\n\nTo ignore a part of a YAML file, `# prettier-ignore` should be placed on the line immediately above the ignored node:\n\n``` jsx\n      # prettier-ignore\n      key  :\n      value\n      hello:\n      world\n    \n```"
