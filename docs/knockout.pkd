---
name: Knockout.js
slug: knockout
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © Steven Sanderson, the Knockout.js team, and other contributors
  Licensed under the MIT License.
  https://knockoutjs.com/documentation/introduction.html
homepage: https://knockoutjs.com/

---
- name: Asynchronous error handling
  id: asynchronous-error-handling
  summary: 'Note: This documentation applies to Knockout 3.4.0 and later'
  description: "# Asynchronous error handling\n\n*Note: This documentation applies to Knockout 3.4.0 and later.*\n\n## ko.onError\n\nKnockout wraps internal asynchronous calls and looks for an optional ko.onError callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to ko.onError contains a stack property, which is not true in many browsers when handling errors using window.onerror.\n\nThis functionality applies to errors in the following contexts:\n\n- asynchronous updates made as part of the textInput and value binding\n- component loading of a cached component when not configured for [synchronous loading](component-registration#controlling-synchronousasynchronous-loading)\n- [rate-limited](ratelimit-observable) and [throttled](https://knockoutjs.com/documentation/throttle-extender.html) computeds\n- event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings\n\n## Example\n\n``` javascript\nko.onError = function(error) {\n    myLogger(\"knockout error\", error);\n};\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/asynchronous-error-handling.html](https://knockoutjs.com/documentation/asynchronous-error-handling.html)"
- name: Asynchronous module definition (AMD) with requireJs
  id: amd-loading
  summary: When we say an application is modular, we generally mean it’s composed of a set of highly decoupled, distinct pieces of functionality stored in modules
  description: "# Asynchronous Module Definition (AMD) With RequireJs\n\n### Overview of AMD\n\nExcerpt From [Writing Modular JavaScript With AMD, CommonJs & ES Harmony](http://addyosmani.com/writing-modular-js/):\n\n> When we say an application is modular, we generally mean it’s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.\n>\n> Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn’t provide developers with the means to import such modules of code in a clean, organized manner. It’s one of the concerns with specifications that haven’t required great thought until more recent years where the need for more organized JavaScript applications became apparent.\n>\n> Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it’s still possible to incur naming collisions in your architecture. There’s also no clean way to handle dependency management without some manual effort or third party tools.\n>\n> Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.\n\n### Loading Knockout.js and a ViewModel class via RequireJs\n\nHTML\n\n``` markup\n<html>\n    <head>\n        <script type=\"text/javascript\" data-main=\"scripts/init.js\" src=\"scripts/require.js\"></script>\n    </head>\n    <body>\n        <p>First name: <input data-bind=\"value: firstName\" /></p>\n        <p>First name capitalized: <strong data-bind=\"text: firstNameCaps\"></strong></p>\n    </body>\n</html>\n```\n\nscripts/init.js\n\n``` javascript\nrequire(['knockout-x.y.z', 'appViewModel', 'domReady!'], function(ko, appViewModel) {\n    ko.applyBindings(new appViewModel());\n});\n```\n\nscripts/appViewModel.js\n\n``` javascript\n// Main viewmodel class\ndefine(['knockout-x.y.z'], function(ko) {\n    return function appViewModel() {\n        this.firstName = ko.observable('Bert');\n        this.firstNameCaps = ko.pureComputed(function() {\n            return this.firstName().toUpperCase();\n        }, this);\n    };\n});\n```\n\nOf course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.5.1).\n\n### Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs\n\nDocumentation on Binding Handlers in general can be found [here](http://knockoutjs.com/documentation/custom-bindings.html). This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it’s own module you can restrict it’s use only to the pages that need it. The wrapped module becomes:\n\n``` javascript\ndefine(['knockout-x.y.z'], function(ko){\n    ko.bindingHandlers.hasFocus = {\n        init: function(element, valueAccessor) { ... },\n        update: function(element, valueAccessor) { ... }\n    }\n});\n```\n\nAfter you have defined the module update the input element from the HTML example above to be:\n\n``` markup\n<p>First name: <input data-bind=\"value: firstName, hasFocus: editingName\" /><span data-bind=\"visible: editingName\"> You're editing the name!</span></p>\n```\n\nInclude the module in the list of dependencies for your view model:\n\n``` javascript\ndefine(['knockout-x.y.z', 'customBindingHandlers/hasFocus'], function(ko) {\n    return function appViewModel(){\n        ...\n        // Add an editingName observable\n        this.editingName = ko.observable();\n    };\n});\n```\n\nNote that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.\n\n### RequireJs Download\n\nRequireJs can be downloaded from <http://requirejs.org/docs/download.html>.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/amd-loading.html](https://knockoutjs.com/documentation/amd-loading.html)"
- name: attr binding
  id: attr-binding
  summary: The attr binding provides a generic way to set the value of any attribute for the associated DOM element
  description: "# The \"attr\" binding\n\n### Purpose\n\nThe attr binding provides a generic way to set the value of any attribute for the associated DOM element. This is useful, for example, when you need to set the title attribute of an element, the src of an img tag, or the href of a link based on values in your view model, with the attribute value being updated automatically whenever the corresponding model property changes.\n\n### Example\n\n``` markup\n<a data-bind=\"attr: { href: url, title: details }\">\n    Report\n</a>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        url: ko.observable(\"year-end.html\"),\n        details: ko.observable(\"Report including final year-end statistics\")\n    };\n</script>\n```\n\nThis will set the element’s href attribute to year-end.html and the element’s title attribute to Report including final year-end statistics.\n\n### Parameters\n\n- Main parameter\n\n  You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.\n\n  If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only set the attribute once and will not update it later.\n\n- Additional parameters\n\n  - None\n\n### Note: Setting attributes whose names aren’t legal JavaScript variable names\n\nIf you want to apply the attribute data-something, you *can’t* write this:\n\n``` markup\n<div data-bind=\"attr: { data-something: someValue }\">...</div>\n```\n\n… because data-something isn’t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,\n\n``` markup\n<div data-bind=\"attr: { 'data-something': someValue }\">...</div>\n```\n\n### Note: Setting attributes with a namespace\n\nThe attr binding can be used to set attributes that include a namespace, such as xlink:href:\n\n``` markup\n<a data-bind=\"attr: { 'xlink:href': href }\">\n    <ellipse data-bind=\"attr: red\" />\n</a>\n```\n\n### Note: Using reserved words as attribute names in older browsers\n\nIn older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:\n\n``` markup\n<input data-bind=\"attr: { 'for': someValue }\" />\n```\n\nYou can find a good list of reserved words on [Mozilla’s MDN page here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords).\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/attr-binding.html](https://knockoutjs.com/documentation/attr-binding.html)"
- name: Binding context
  id: binding-context
  summary: A binding context is an object that holds data that you can reference from your bindings
  description: "# Binding context\n\nA *binding context* is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the viewModel parameter you supplied to ko.applyBindings(viewModel). Then, each time you use a control flow binding such as [with](with-binding) or [foreach](foreach-binding), that creates a child binding context that refers to the nested view model data.\n\nBindings contexts offer the following special properties that you can reference in any binding:\n\n- $parent\n\n  This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:\n\n  ``` markup\n  <h1 data-bind=\"text: name\"></h1>\n\n  <div data-bind=\"with: manager\">\n      <!-- Now we're inside a nested binding context -->\n      <span data-bind=\"text: name\"></span> is the\n      manager of <span data-bind=\"text: $parent.name\"></span>\n  </div>\n  ```\n\n- $parents\n\n  This is an array representing all of the parent view models:\n\n  $parents\\[0\\] is the view model from the parent context (i.e., it’s the same as $parent)\n\n  $parents\\[1\\] is the view model from the grandparent context\n\n  $parents\\[2\\] is the view model from the great-grandparent context\n\n  … and so on.\n\n- $root\n\n  This is the main view model object in the root context, i.e., the topmost parent context. It’s usually the object that was passed to ko.applyBindings. It is equivalent to $parents\\[$parents.length - 1\\].\n\n- $component\n\n  If you’re within the context of a particular [component](component-overview) template, then $component refers to the viewmodel for that component. It’s the component-specific equivalent to $root. In the case of nested components, $component refers to the viewmodel for the closest component.\n\n  This is useful, for example, if a component’s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.\n\n- $data\n\n  This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:\n\n  ``` markup\n  <ul data-bind=\"foreach: ['cats', 'dogs', 'fish']\">\n      <li>The value is <span data-bind=\"text: $data\"></span></li>\n  </ul>\n  ```\n\n- $index (only available within foreach bindings)\n\n  This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).\n\n- $parentContext\n\n  This refers to the binding context object at the parent level. This is different from $parent, which refers to the *data* (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.\n\n- $rawData\n\n  This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.\n\n- $componentTemplateNodes\n\n  If you’re within the context of a particular [component](component-overview) template, then $componentTemplateNodes is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see [passing markup into components](component-custom-elements#passing-markup-into-components).\n\nThe following special variables are also available in bindings, but are not part of the binding context object:\n\n- $context\n\n  This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.\n\n- $element\n\n  This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:\n\n  ``` markup\n  <div id=\"item1\" data-bind=\"text: $element.id\"></div>\n  ```\n\n### Controlling or modifying the binding context in custom bindings\n\nJust like the built-in bindings [with](with-binding) and [foreach](foreach-binding), custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under [creating custom bindings that control descendant bindings](custom-bindings-controlling-descendant-bindings).\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/binding-context.html](https://knockoutjs.com/documentation/binding-context.html)"
- name: Binding lifecycle events
  id: binding-lifecycle-events
  summary: 'Note: This feature, introduced in Knockout 3.5.0, is experimental, and may change in future versions'
  description: "# Binding lifecycle events\n\n*Note: This feature, introduced in Knockout 3.5.0, is experimental, and may change in future versions.*\n\nSometimes you might want to run custom post-processing logic on the DOM elements processed by Knockout. For example, if you’re using a JavaScript widgets library such as jQuery UI, you might want to know when a certain section of the DOM is finished binding so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.\n\nKnockout provides two similar events that you can use to be notified when the contents of a node have been bound.\n\n1.  childrenComplete — This event is notified **synchronously** once the child nodes (and all synchronously loaded descendants) have been bound.\n\n2.  descendantsComplete — This event is notified after all descendant nodes have been bound, even if those nodes were loaded and bound **asynchronously**. If all descendant nodes are bound synchronously, this event is notified right after childrenComplete.\n\nThese events will generally be notified even if a node is empty. If the node’s contents are re-rendered, such as by a control-flow binding like [with](with-binding), these events will be notified again.\n\n## Subscribing to lifecycle events\n\nThere are a few different methods to subscribe to these events depending on how and in which context you want to be notified.\n\n### Bindings\n\nTo be notified in your view model, bind your callback function to the event through the node’s data-bind. Pass a function reference (either a function literal or the name of a function on your view model), and Knockout will invoke it when that event is notified. For example,\n\n``` markup\n<div data-bind=\"childrenComplete: myPostProcessingLogic\">...</div>\n```\n\n… and define a corresponding function on your view model:\n\n``` javascript\nviewModel.myPostProcessingLogic = function (nodes) {\n    // You can add custom post-processing logic here\n}\n```\n\nThe provided callback will be run whenever the event is notified, *except if the node is empty*. For the childrenComplete event, the function is called with two parameters, an array of child nodes and the child view model. The descendantsComplete callback function is called with just the parent node.\n\n### Components\n\nTo be notified in a [component](component-overview), you can register a callback function within the component’s createViewModel method. Be sure to dispose the subscription within your component’s dispose function as well, since a component may be disposed and re-created on the same element.\n\n``` javascript\nko.components.register('my-component', {\n    viewModel: {\n        createViewModel: function(params, componentInfo) {\n            var sub = ko.bindingEvent.subscribe(componentInfo.element, 'descendantsComplete', function (node) {\n                // You can add custom post-processing logic here\n            });\n            \n            var vm = new MyViewModel(params);\n            vm.dispose = function () {\n                sub.dispose();\n            }\n        }\n    },\n    template: ...\n});\n```\n\nYou can bind either event using ko.bindingEvent.subscribe, but importantly for components, which are asynchronous by default, the descendantsComplete event will wait for all child components to complete.\n\nAlternatively, components also support a direct method to receive a descendantsComplete notification. If your component view model has a koDescendantsComplete function, Knockout will call it with the component’s node once all descendants are bound. For example.\n\n``` javascript\nfunction SomeComponentViewModel(params) { }\n\nSomeComponentViewModel.prototype.koDescendantsComplete = function (node) {\n    // You can add custom post-processing logic here\n}\n```\n\n### Custom bindings\n\nLike components, [custom bindings that control descendant bindings](custom-bindings-controlling-descendant-bindings) can use ko.bindingEvent.subscribe to run post-processing logic. However, in order to subscribe to the descendantsComplete event, you also need to tell Knockout that your binding is involved in asynchronous notifications.\n\n``` javascript\nko.bindingHandlers.myWidget = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        ko.bindingEvent.subscribe(element, 'descendantsComplete', function () {\n            // Initialize the widget here\n        });\n\n        // startPossiblyAsyncContentBinding is necessary for descendant bindings to notify us of their completion\n        var innerBindingContext = ko.bindingEvent.startPossiblyAsyncContentBinding(element, bindingContext);\n\n        ko.applyBindingsToDescendants(innerBindingContext, element);\n\n        return { controlsDescendantBindings: true };\n    }\n};\n```\n\nGenerally, there would be little reason to subscribe to the childrenComplete event in such a binding since it would be the same as just running your post-processing code after ko.applyBindingsToDescendants.\n\n## Indicating that a control-flow binding “completes” asynchronously\n\nNormally, the [with](with-binding) and [if](if-binding) bindings notify “completeness” even if they are bound to a null or false value and therefore clear the node’s contents instead of binding them. But if you use such a control-flow binding to delay binding until part of your viewmodel is finished initializing, it may be more appropriate to also delay the binding notifications. This could be important to delay an outer node’s descendantsComplete event. To do so, include the completeOn: \"render\" option with the binding. For example:\n\n``` markup\n<div data-bind=\"descendantsComplete: myPostProcessingLogic\">\n    ...\n    <div data-bind=\"with: resultData, completeOn: 'render'\">\n        <h3>Recent tweets fetched at <span data-bind=\"text: retrievalDate\"></span></h3>\n        <ol data-bind=\"foreach: topTweets\">\n            <li data-bind=\"text: text\"></li>\n        </ol>\n    </div>\n    ...\n</div>\n```\n\nWithout the completeOn option, myPostProcessingLogic will be called even if resultData is not set intitially. With the option set as above, myPostProcessingLogic will only be called once resultData is set to a true-like value, and the contents of that node are rendered and bound.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/binding-lifecycle-events.html](https://knockoutjs.com/documentation/binding-lifecycle-events.html)"
- name: Binding preprocessing
  id: binding-preprocessing
  summary: 'Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes'
  description: "# Extending Knockout's binding syntax using preprocessing\n\n*Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It’s not something you’ll normally need to do when building applications with Knockout.*\n\nWith binding preprocessing, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.\n\n## Preprocessing binding strings\n\nYou can hook into Knockout’s logic for interpreting data-bind attributes by providing a *binding preprocessor* for a specific binding (such as click, visible, or any [custom binding](custom-bindings)).\n\nTo do this, attach a preprocess function to the binding handler object:\n\n``` javascript\nko.bindingHandlers.yourBindingHandler.preprocess = function(stringFromMarkup) {\n    // Return stringFromMarkup if you don't want to change anything, or return\n    // some other string if you want Knockout to behave as if that was the\n    // syntax provided in the original HTML\n}\n```\n\nSee later on this page for an API reference.\n\n### Example 1: Setting a default value for a binding\n\nIf you leave off the value of a binding, it’s bound to undefined by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow uniqueName to be bound without a value by making its default value true:\n\n``` javascript\nko.bindingHandlers.uniqueName.preprocess = function(val) {\n    return val || 'true';\n}\n```\n\nNow you can bind it like this:\n\n``` markup\n<input data-bind=\"value: someModelProperty, uniqueName\" />\n```\n\nIf your binding uses a preprocess function but should still have undefined as a default value, the function should return the string \"undefined\" rather than an undefined value. Returning undefined will remove the binding instead.\n\n### Example 2: Binding expressions to events\n\nIf you’d like to be able to bind expressions to click events (rather than a function reference as Knockout expects), you can set up a preprocessor for the click handler to support this syntax:\n\n``` javascript\nko.bindingHandlers.click.preprocess = function(val) {\n    return 'function($data,$event){ ' + val + ' }';\n}\n```\n\nNow you can bind click like this:\n\n``` markup\n<button type=\"button\" data-bind=\"click: myCount(myCount()+1)\">Increment</button>\n```\n\n### Binding preprocessor reference\n\n- ko.bindingHandlers.\\<name\\>.preprocess(value, name, addBindingCallback)\n\n  If defined, this function will be called for each \\<name\\> binding before the binding is evaluated.\n\n  **Parameters:**\n\n  - value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is \"1 + 1\" as a string). If the binding was given without a value, this will be undefined.\n\n  - name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is \"yourBinding\" as a string).\n\n  - addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.\n\n  **Return value**:\n\n  Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.\n\n  For example, if you return value + \".toUpperCase()\" as a string, then yourBinding: \"Bert\" would be interpreted as if the markup contained yourBinding: \"Bert\".toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.\n\n  Don’t return non-string values. That wouldn’t make sense, because markup is always a string.\n\n## Preprocessing DOM nodes\n\nYou can hook into Knockout’s logic for traversing the DOM by providing a *node preprocessor*. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a [foreach binding](foreach-binding)).\n\nTo do this, define a preprocessNode function on your binding provider:\n\n``` javascript\nko.bindingProvider.instance.preprocessNode = function(node) {\n    // Use DOM APIs such as setAttribute to modify 'node' if you wish.\n    // If you want to leave 'node' in the DOM, return null or have no 'return' statement.\n    // If you want to replace 'node' with some other set of nodes,\n    //    - Use DOM APIs such as insertChild to inject the new nodes\n    //      immediately before 'node'\n    //    - Use DOM APIs such as removeChild to remove 'node' if required\n    //    - Return an array of any new nodes that you've just inserted\n    //      so that Knockout can apply any bindings to them\n}\n```\n\nSee later on this page for an API reference.\n\n### Example 3: Virtual template elements\n\nIf you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:\n\n``` javascript\nko.bindingProvider.instance.preprocessNode = function(node) {\n    // Only react if this is a comment node of the form <!-- template: ... -->\n    if (node.nodeType == 8) {\n        var match = node.nodeValue.match(/^\\s*(template\\s*:[\\s\\S]+)/);\n        if (match) {\n            // Create a pair of comments to replace the single comment\n            var c1 = document.createComment(\"ko \" + match[1]),\n                c2 = document.createComment(\"/ko\");\n            node.parentNode.insertBefore(c1, node);\n            node.parentNode.replaceChild(c2, node);\n\n            // Tell Knockout about the new nodes so that it can apply bindings to them\n            return [c1, c2];\n        }\n    }\n}\n```\n\nNow you can include a template in your view like this:\n\n``` markup\n<!-- template: 'some-template' -->\n```\n\n### Preprocessing Reference\n\n- ko.bindingProvider.instance.preprocessNode(node)\n\n  If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace node. Any new nodes must be inserted immediately before node, and if any nodes were added or node was removed, the function must return an array of the new nodes that are now in the document in place of node.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/binding-preprocessing.html](https://knockoutjs.com/documentation/binding-preprocessing.html)"
- name: checked binding
  id: checked-binding
  summary: The checked binding links a checkable form control — i.e., a checkbox (<input type='checkbox'>) or a radio button (<input type='radio'>) — with a property on your view model
  description: "# The \"checked\" binding\n\n### Purpose\n\nThe checked binding links a checkable form control — i.e., a checkbox (\\<input type='checkbox'\\>) or a radio button (\\<input type='radio'\\>) — with a property on your view model.\n\nWhen the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.\n\nNote: For text boxes, drop-down lists, and all non-checkable form controls, use [the value binding](value-binding) to read and write the element’s value, not the checked binding.\n\n### Example with checkbox\n\n``` markup\n<p>Send me spam: <input type=\"checkbox\" data-bind=\"checked: wantsSpam\" /></p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        wantsSpam: ko.observable(true) // Initially checked\n    };\n\n    // ... then later ...\n    viewModel.wantsSpam(false); // The checkbox becomes unchecked\n</script>\n```\n\n### Example adding checkboxes bound to an array\n\n``` markup\n<p>Send me spam: <input type=\"checkbox\" data-bind=\"checked: wantsSpam\" /></p>\n<div data-bind=\"visible: wantsSpam\">\n    Preferred flavors of spam:\n    <div><input type=\"checkbox\" value=\"cherry\" data-bind=\"checked: spamFlavors\" /> Cherry</div>\n    <div><input type=\"checkbox\" value=\"almond\" data-bind=\"checked: spamFlavors\" /> Almond</div>\n    <div><input type=\"checkbox\" value=\"msg\" data-bind=\"checked: spamFlavors\" /> Monosodium Glutamate</div>\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        wantsSpam: ko.observable(true),\n        spamFlavors: ko.observableArray([\"cherry\",\"almond\"]) // Initially checks the Cherry and Almond checkboxes\n    };\n\n    // ... then later ...\n    viewModel.spamFlavors.push(\"msg\"); // Now additionally checks the Monosodium Glutamate checkbox\n</script>\n```\n\n### Example adding radio buttons\n\n``` markup\n<p>Send me spam: <input type=\"checkbox\" data-bind=\"checked: wantsSpam\" /></p>\n<div data-bind=\"visible: wantsSpam\">\n    Preferred flavor of spam:\n    <div><input type=\"radio\" name=\"flavorGroup\" value=\"cherry\" data-bind=\"checked: spamFlavor\" /> Cherry</div>\n    <div><input type=\"radio\" name=\"flavorGroup\" value=\"almond\" data-bind=\"checked: spamFlavor\" /> Almond</div>\n    <div><input type=\"radio\" name=\"flavorGroup\" value=\"msg\" data-bind=\"checked: spamFlavor\" /> Monosodium Glutamate</div>\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        wantsSpam: ko.observable(true),\n        spamFlavor: ko.observable(\"almond\") // Initially selects only the Almond radio button\n    };\n\n    // ... then later ...\n    viewModel.spamFlavor(\"msg\"); // Now only Monosodium Glutamate is checked\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  Knockout sets the element’s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you’re binding to:\n\n  - For **checkboxes**, Knockout will set the element to be *checked* when the parameter value is true, and *unchecked* when it is false. If you give a value that isn’t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false. When the user checks or unchecks the checkbox, Knockout will set your model property to true or false accordingly.\n\n    If the checkedValue parameter is set, that value is used instead of true to represent a *checked* status, and an *unchecked* status is represented with a value of undefined.\n\n    Special consideration is given if your parameter resolves to an array. In this case, Knockout will set the element to be *checked* if its value matches an item in the array, and *unchecked* if it is not contained in the array. The value of a checkbox is either the element’s value attribute or the value specified by the checkedValue parameter. When the user checks or unchecks the checkbox, Knockout will add or remove its value from the array accordingly.\n\n  - For **radio buttons**, Knockout will set the element to be *checked* when the parameter value equals the radio button element’s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=\"almond\" was checked only when the view model’s spamFlavor property was equal to \"almond\".\n\n    When the user changes which radio button is selected, Knockout will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=\"cherry\" would set viewModel.spamFlavor to be \"cherry\".\n\n    Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only *one* of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) – doing this puts them into a group where only one can be selected.\n\n  If your parameter is an observable value, the binding will update the element’s checked state whenever the value changes. If the parameter isn’t observable, it will only set the element’s checked state once and will not update it again later.\n\n- Additional parameters\n\n  - `checkedValue`\n\n    If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element’s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically. For normally boolean checkboxes, this value is used instead of true to represent the *checked* state, with undefined used for the *unchecked* state.\n\n    In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:\n\n    ``` markup\n    <!-- ko foreach: items -->\n        <input type=\"checkbox\" data-bind=\"checkedValue: $data, checked: $root.chosenItems\" />\n        <span data-bind=\"text: itemName\"></span>\n    <!-- /ko -->\n\n    <script type=\"text/javascript\">\n        var viewModel = {\n            items: ko.observableArray([\n                { itemName: 'Choice 1' },\n                { itemName: 'Choice 2' }\n            ]),\n            chosenItems: ko.observableArray()\n        };\n    </script>\n    ```\n\n    If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes bound to an array, it will remove the previous value from the array and add the new value. Otherwise, it will just update the model value.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/checked-binding.html](https://knockoutjs.com/documentation/checked-binding.html)"
- name: class and css bindings
  id: css-binding
  summary: The class and css bindings add or remove one or more named CSS classes to the associated DOM element
  description: "# The \"class\" and \"css\" bindings\n\n### Purpose\n\nThe class and css bindings add or remove one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.\n\n(Note: If you don’t want to apply a CSS class but instead want to assign a style attribute value directly, see [the style binding](style-binding).)\n\n### “class” binding example\n\n``` markup\n<div data-bind=\"class: profitStatus\">\n   Profit Information\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        currentProfit: ko.observable(150000)\n    };\n\n    // Evalutes to a positive value, so initially we apply the \"profitPositive\" class\n    viewModel.profitStatus = ko.pureComputed(function() {\n        return this.currentProfit() < 0 ? \"profitWarning\" : \"profitPositive\";\n    }, viewModel);\n\n    // Causes the \"profitPositive\" class to be removed and \"profitWarning\" class to be added\n    viewModel.currentProfit(-50);\n</script>\n```\n\nThis will apply the CSS class profitPositive when the currentProfit value is positive; otherwise it will apply the profitWarning CSS class.\n\n### “css” binding example\n\n``` markup\n<div data-bind=\"css: { profitWarning: currentProfit() < 0 }\">\n   Profit Information\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        currentProfit: ko.observable(150000) // Positive value, so initially we don't apply the \"profitWarning\" class\n    };\n    viewModel.currentProfit(-50); // Causes the \"profitWarning\" class to be applied\n</script>\n```\n\nThis will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.\n\n### “class” parameters\n\n- Main parameter\n\n  The parameter value should be a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, the binding will update the classes whenever the value changes, removing any previously added classes and adding the class or classes from new value.\n\n  As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting value to determine the appropriate CSS classes to add or remove.\n\n- Additional parameters\n\n  - None\n\n### “css” parameters\n\n- Main parameter\n\n  You should pass a JavaScript object in which the property names are your CSS classes and their values evaluate to true or false according to whether the class should currently be applied.\n\n  You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,\n\n  ``` markup\n  <div data-bind=\"css: { profitWarning: currentProfit() < 0, majorHighlight: isSevere }\">\n  ```\n\n  You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:\n\n  ``` markup\n  <div data-bind=\"css: { profitWarning: currentProfit() < 0, 'major highlight': isSevere }\">\n  ```\n\n  Logically, 'major highlight': isSevere is equivalent to major: isSevere, highlight: isSevere. It’s merely a shortcut syntax if you want two or more CSS classes to be set and unset together.\n\n  Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true. If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only add or remove the class once and will not do so again later. As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.\n\n  For backward compatibility, you can also use the css binding with a string value like the class binding.\n\n- Additional parameters\n\n  - None\n\n### Note: Using the “class” and “css” bindings at the same time\n\nAs long as they reference different CSS class names, you can include both class and css bindings on the same element. Thus you can have some classes that are set based on a true/false value and others that are calculated dynamically. For example:\n\n``` markup\n<div data-bind=\"css: { highlight: isSelected }, class: profitStatus\">...</div>\n```\n\n### Note: Applying CSS classes whose names aren’t legal JavaScript variable names\n\nIf you want to apply the CSS class my-class, you *can’t* write this:\n\n``` markup\n<div data-bind=\"css: { my-class: someValue }\">...</div>\n```\n\n… because my-class isn’t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,\n\n``` markup\n<div data-bind=\"css: { 'my-class': someValue }\">...</div>\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/css-binding.html](https://knockoutjs.com/documentation/css-binding.html)"
- name: click binding
  id: click-binding
  summary: The click binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is clicked
  description: "# The \"click\" binding\n\n### Purpose\n\nThe click binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is clicked. This is most commonly used with elements like button, input, and a, but actually works with any visible DOM element.\n\n### Example\n\n``` markup\n<div>\n    You've clicked <span data-bind=\"text: numberOfClicks\"></span> times\n    <button data-bind=\"click: incrementClickCounter\">Click me</button>\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        numberOfClicks : ko.observable(0),\n        incrementClickCounter : function() {\n            var previousCount = this.numberOfClicks();\n            this.numberOfClicks(previousCount + 1);\n        }\n    };\n</script>\n```\n\nEach time you click the button, this will invoke incrementClickCounter() on the view model, which in turn changes the view model state, which causes the UI to update.\n\n### Parameters\n\n- Main parameter\n\n  The function you want to bind to the element’s click event.\n\n  You can reference any JavaScript function - it doesn’t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.\n\n- Additional parameters\n\n  - None\n\n### Note 1: Passing a “current item” as a parameter to your handler function\n\nWhen calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you’re rendering some UI for each item in a collection, and you need to know which item’s UI was clicked. For example,\n\n``` markup\n<ul data-bind=\"foreach: places\">\n    <li>\n        <span data-bind=\"text: $data\"></span>\n        <button data-bind=\"click: $parent.removePlace\">Remove</button>\n    </li>\n</ul>\n\n <script type=\"text/javascript\">\n     function MyViewModel() {\n         var self = this;\n         self.places = ko.observableArray(['London', 'Paris', 'Tokyo']);\n\n         // The current item will be passed as the first parameter, so we know which place to remove\n         self.removePlace = function(place) {\n             self.places.remove(place)\n         }\n     }\n     ko.applyBindings(new MyViewModel());\n</script>\n```\n\nTwo points to note about this example:\n\n- If you’re inside a nested [binding context](binding-context), for example if you’re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you’ll need to use a prefix such as $parent or $root to locate the handler function.\n- In your viewmodel, it’s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.\n\n### Note 2: Accessing the event object, or passing more parameters\n\nIn some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:\n\n``` markup\n<button data-bind=\"click: myFunction\">\n    Click me\n</button>\n\n <script type=\"text/javascript\">\n    var viewModel = {\n        myFunction: function(data, event) {\n            if (event.shiftKey) {\n                //do something different when user has shift key down\n            } else {\n                //do normal action\n            }\n        }\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\nIf you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:\n\n``` markup\n<button data-bind=\"click: function(data, event) { myFunction('param1', 'param2', data, event) }\">\n    Click me\n</button>\n```\n\nNow, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.\n\nAlternatively, if you prefer to avoid the function literal in your view, you can use the [bind](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind) function, which attaches specific parameter values to a function reference:\n\n``` markup\n<button data-bind=\"click: myFunction.bind($data, 'param1', 'param2')\">\n    Click me\n</button>\n```\n\n### Note 3: Allowing the default click action\n\nBy default, Knockout will prevent the click event from taking any default action. This means that if you use the click binding on an a tag (a link), for example, the browser will only call your handler function and will *not* navigate to the link’s href. This is a useful default because when you use the click binding, it’s normally because you’re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.\n\nHowever, if you *do* want to let the default click action proceed, just return true from your click handler function.\n\n### Note 4: Preventing the event from bubbling\n\nBy default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it, as in this example:\n\n``` markup\n<div data-bind=\"click: myDivHandler\">\n    <button data-bind=\"click: myButtonHandler, clickBubble: false\">\n        Click me\n    </button>\n</div>\n```\n\nNormally, in this case myButtonHandler would be called first, then the click event would bubble up to myDivHandler. However, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.\n\n### Note 5: Interaction with jQuery\n\nKnockout will use jQuery, if it is present, for handling UI events such as click. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:\n\n``` javascript\nko.options.useOnlyNativeEvents = true;\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/click-binding.html](https://knockoutjs.com/documentation/click-binding.html)"
- name: Component
  id: component-overview
  summary: Components are a powerful, clean way of organizing your UI code into self-contained, reusable chunks
  description: "# Components and Custom Elements - Overview\n\n**Components** are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:\n\n- …can represent individual controls/widgets, or entire sections of your application\n- …contain their own view, and usually (but optionally) their own viewmodel\n- …can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems\n- …can receive parameters, and optionally write back changes to them or invoke callbacks\n- …can be composed together (nested) or inherited from other components\n- …can easily be packaged for reuse across projects\n- …let you define your own conventions/logic for configuration and loading\n\nThis pattern is beneficial for large applications, because it **simplifies development** through clear organization and encapsulation, and helps to **improve runtime performance** by incrementally loading your application code and templates as needed.\n\n**Custom elements** are an optional but convenient syntax for consuming components. Instead of needing placeholder \\<div\\>s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., \\<voting-button\\> or \\<product-editor\\>). Knockout takes care to ensure compatibility even with old browsers such as IE 6.\n\n### Example: A like/dislike widget\n\nTo get started, you can register a component using ko.components.register (technically, registration is optional, but it’s the easiest way to get started). A component definition specifies a viewModel and template. For example:\n\n``` markup\nko.components.register('like-widget', {\n    viewModel: function(params) {\n        // Data: value is either null, 'like', or 'dislike'\n        this.chosenValue = params.value;\n        \n        // Behaviors\n        this.like = function() { this.chosenValue('like'); }.bind(this);\n        this.dislike = function() { this.chosenValue('dislike'); }.bind(this);\n    },\n    template:\n        '<div class=\"like-or-dislike\" data-bind=\"visible: !chosenValue()\">\\\n            <button data-bind=\"click: like\">Like it</button>\\\n            <button data-bind=\"click: dislike\">Dislike it</button>\\\n        </div>\\\n        <div class=\"result\" data-bind=\"visible: chosenValue\">\\\n            You <strong data-bind=\"text: chosenValue\"></strong> it\\\n        </div>'\n});\n```\n\n**Normally, you’d load the view model and template from external files** instead of declaring them inline like this. We’ll get to that later.\n\nNow, to use this component, you can reference it from any other view in your application, either using the [component binding](component-binding) or using a [custom element](component-custom-elements). Here’s a live example that uses it as a custom element:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<ul data-bind=\"foreach: products\">\n    <li class=\"product\">\n        <strong data-bind=\"text: name\"></strong>\n        <like-widget params=\"value: userRating\"></like-widget>\n    </li>\n</ul>\n```\n\n#### Source code: View model\n\n``` js\nfunction Product(name, rating) {\n    this.name = name;\n    this.userRating = ko.observable(rating || null);\n}\n\nfunction MyViewModel() {\n    this.products = [\n        new Product('Garlic bread'),\n        new Product('Pain au chocolat'),\n        new Product('Seagull spaghetti', 'like') // This one was already 'liked'\n    ];\n}\n\nko.applyBindings(new MyViewModel());\n```\n\nIn this example, the component both displays and edits an observable property called userRating on the Product view model class.\n\n### Example: Loading the like/dislike widget from external files, on demand\n\nIn most applications, you’ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as [require.js](http://requirejs.org/), then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.\n\nHere’s an example configuration:\n\n``` javascript\nko.components.register('like-or-dislike', {\n    viewModel: { require: 'files/component-like-widget' },\n    template: { require: 'text!files/component-like-widget.html' }\n});\n```\n\n**Requirements**\n\nFor this to work, the files [files/component-like-widget.js](files/component-like-widget.js) and [files/component-like-widget.html](files/component-like-widget) need to exist. Check them out (and *view source* on the .html one) - as you’ll see, this is cleaner and more convenient that including the code inline in the definition.\n\nAlso, you need to have referenced a suitable module loader library (such as [require.js](http://requirejs.org/)) or implemented a [custom component loader](component-loaders) that knows how to grab your files.\n\n**Using the component**\n\nNow like-or-dislike can be consumed in the same way as before, using either a [component binding](component-binding) or a [custom element](component-custom-elements):\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<ul data-bind=\"foreach: products\">\n    <li class=\"product\">\n        <strong data-bind=\"text: name\"></strong>\n        <like-or-dislike params=\"value: userRating\"></like-or-dislike>\n    </li>\n</ul>\n<button data-bind=\"click: addProduct\">Add a product</button>\n```\n\n#### Source code: View model\n\n``` js\nfunction Product(name, rating) {\n    this.name = name;\n    this.userRating = ko.observable(rating || null);\n}\n\nfunction MyViewModel() {\n    this.products = ko.observableArray(); // Start empty\n}\n\nMyViewModel.prototype.addProduct = function() {\n    var name = 'Product ' + (this.products().length + 1);\n    this.products.push(new Product(name));\n};\n\nko.applyBindings(new MyViewModel());\n```\n\nIf you open your browser developer tools’ **Network** inspector before your first click on *Add product*, you’ll see that the component’s .js/.html files are fetched on demand when first required, and thereafter retained for reuse.\n\n### Learn more\n\nMore more detailed information, see:\n\n- [Defining and registering components](component-registration)\n- [Using the component binding](component-binding)\n- [Using custom elements](component-custom-elements)\n- [Advanced: Custom component loaders](component-loaders)\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/component-overview.html](https://knockoutjs.com/documentation/component-overview.html)"
- name: component binding
  id: component-binding
  summary: The component binding injects a specified component into an element, and optionally passes parameters to it
  description: "# The \"component\" binding\n\nThe component binding injects a specified [component](component-overview) into an element, and optionally passes parameters to it.\n\n- [Live example](#live-example)\n- [API](#api)\n- [Component lifecycle](#component-lifecycle)\n- [Note: Template-only components](#note-template-only-components)\n- [Note: Using component without a container element](#note-using-component-without-a-container-element)\n- [Note: Passing markup to components](#note-passing-markup-to-components)\n- [Disposal and memory management](#disposal-and-memory-management)\n\n### Live example\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<h4>First instance, without parameters</h4>\n<div data-bind='component: \"message-editor\"'></div>\n\n<h4>Second instance, passing parameters</h4>\n<div data-bind='component: {\n    name: \"message-editor\",\n    params: { initialText: \"Hello, world!\" }\n}'></div>\n```\n\n#### Source code: View model\n\n``` js\nko.components.register('message-editor', {\n    viewModel: function(params) {\n        this.text = ko.observable(params && params.initialText || '');\n    },\n    template: 'Message: <input data-bind=\"value: text\" /> '\n            + '(length: <span data-bind=\"text: text().length\"></span>)'\n});\n\nko.applyBindings();\n```\n\nNote: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See [an example](component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand) and [registration documentation](component-registration).\n\n### API\n\nThere are two ways to use the component binding:\n\n- **Shorthand syntax**\n\n  If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:\n\n  ``` markup\n  <div data-bind='component: \"my-component\"'></div>\n  ```\n\n  The shorthand value can also be observable. In this case, if it changes, the component binding will [dispose](#disposal-and-memory-management) the old component instance, and inject the newly-referenced component. Example:\n\n  ``` markup\n  <div data-bind='component: observableWhoseValueIsAComponentName'></div>\n  ```\n\n- **Full syntax**\n\n  To supply parameters to the component, pass an object with the following properties:\n\n  - name — the name of the component to inject. Again, this can be observable.\n  - params — an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component’s viewmodel constructor.\n\n  Example:\n\n  ``` markup\n  <div data-bind='component: {\n      name: \"shopping-cart\",\n      params: { mode: \"detailed-list\", items: productsList }\n  }'></div>\n  ```\n\nNote that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is [disposed](#disposal-and-memory-management)\n\n### Component lifecycle\n\nWhen a component binding injects a component,\n\n1.  **Your component loaders are asked to supply the viewmodel factory and template**\n\n    - Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place **once per component type**, since Knockout caches the resulting definitions in memory.\n    - The default component loader supplies viewmodels/templates based on [what you have registered](component-registration). If applicable, this is the phase where it requests any specified AMD modules from your AMD loader.\n\n    Normally, this is an *asynchronous* process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see [Controlling synchronous/asynchronous loading](component-registration#controlling-synchronousasynchronous-loading).\n\n2.  **The component template is cloned and injected into the container element**\n\n    Any existing content is removed and discarded.\n\n3.  **If the component has a viewmodel, it is instantiated**\n\n    If the viewmodel is given as a constructor function, this means Knockout calls new YourViewModel(params).\n\n    If the viewmodel is given as a createViewModel factory function, Knockout calls createViewModel(params, componentInfo), where componentInfo.element is the element into which the not-yet-bound template has already been injected.\n\n    This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs *every time a component is instantiated* and performance would be unacceptable if it involved waiting for network requests.\n\n4.  **The viewmodel is bound to the view**\n\n    Or, if the component has no viewmodel, then the view is bound to any params you’ve supplied to the component binding.\n\n5.  **The component is active**\n\n    Now the component is operating, and can remain on-screen for as long as needed.\n\n    If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.\n\n6.  **The component is torn down, and the viewmodel is disposed**\n\n    If the component binding’s name value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any dispose function on the viewmodel is called just before the container element is removed from the DOM. See also: [disposal and memory management](#disposal-and-memory-management).\n\n    Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no dispose functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.\n\n### Note: Template-only components\n\nComponents usually have viewmodels, but they don’t necessarily have to. A component can specify just a template.\n\nIn this case, the object to which the component’s view is bound is the params object that you passed to the component binding. Example:\n\n``` markup\nko.components.register('special-offer', {\n    template: '<div class=\"offer-box\" data-bind=\"text: productName\"></div>'\n});\n```\n\n… can be injected with:\n\n``` markup\n<div data-bind='component: {\n     name: \"special-offer-callout\",\n     params: { productName: someProduct.name }\n}'></div>\n```\n\n… or, more conveniently, as a [custom element](component-custom-elements):\n\n``` markup\n<special-offer params='productName: someProduct.name'></special-offer>\n```\n\n### Note: Using component without a container element\n\nSometimes you may want to inject a component into a view without using an extra container element. You can do this using *containerless control flow syntax*, which is based on comment tags. For example,\n\n``` markup\n<!-- ko component: \"message-editor\" -->\n<!-- /ko -->\n```\n\n… or passing parameters:\n\n``` markup\n<!-- ko component: {\n    name: \"message-editor\",\n    params: { initialText: \"Hello, world!\", otherParam: 123 }\n} -->\n<!-- /ko -->\n```\n\nThe \\<!-- ko --\\> and \\<!-- /ko --\\> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.\n\n### Note: Passing markup to components\n\nThe element you attach a component binding to may contain further markup. For example,\n\n``` markup\n<div data-bind=\"component: { name: 'my-special-list', params: { items: someArrayOfPeople } }\">\n    <!-- Look, here's some arbitrary markup. By default it gets stripped out\n         and is replaced by the component output. -->\n    The person <em data-bind=\"text: name\"></em>\n    is <em data-bind=\"text: age\"></em> years old.\n</div>\n```\n\nAlthough the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.\n\nThis is useful if you want to build components that represent “container” UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See [a complete example for custom elements](component-custom-elements#passing-markup-into-components), which also works without custom elements using the syntax shown above.\n\n### Disposal and memory management\n\nOptionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a foreach, or an if binding has become false).\n\nYou must use dispose to release any resources that aren’t inherently garbage-collectable. For example:\n\n- setInterval callbacks will continue to fire until explicitly cleared.\n  - Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.\n- ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.\n  - If a dependency is on an external object, then be sure to use .dispose() on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a [*pure* computed](computed-pure) to avoid the need for manual disposal.\n- **Subscriptions** to observables continue to fire until explicitly disposed.\n  - If you have subscribed to an external observable, be sure to use .dispose() on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.\n- Manually-created **event handlers** on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn’t) must be removed.\n  - Of course, you don’t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.\n\nFor example:\n\n``` javascript\nvar someExternalObservable = ko.observable(123);\n\nfunction SomeComponentViewModel() {\n    this.myComputed = ko.computed(function() {\n        return someExternalObservable() + 1;\n    }, this);\n\n    this.myPureComputed = ko.pureComputed(function() {\n        return someExternalObservable() + 2;\n    }, this);\n\n    this.mySubscription = someExternalObservable.subscribe(function(val) {\n        console.log('The external observable changed to ' + val);\n    }, this);\n\n    this.myIntervalHandle = window.setInterval(function() {\n        console.log('Another second passed, and the component is still alive.');\n    }, 1000);\n}\n\nSomeComponentViewModel.prototype.dispose = function() {\n    this.myComputed.dispose();\n    this.mySubscription.dispose();\n    window.clearInterval(this.myIntervalHandle);\n    // this.myPureComputed doesn't need to be manually disposed.\n}\n\nko.components.register('your-component-name', {\n    viewModel: SomeComponentViewModel,\n    template: 'some template'\n});\n```\n\nIt isn’t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/component-binding.html](https://knockoutjs.com/documentation/component-binding.html)"
- name: Component loaders
  id: component-loaders
  summary: Whenever you inject a component using the component binding or a custom element, Knockout fetches that component’s template and viewmodel using one or more component loaders
  description: "# Component loaders\n\nWhenever you inject a [component](component-overview) using the [component binding](component-binding) or a [custom element](component-custom-elements), Knockout fetches that component’s template and viewmodel using one or more *component loaders*. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.\n\n- [The default component loader](#default-component-loader)\n- [Component loader utility functions](#component-loader-utility-functions)\n- [Implementing a custom component loader](#custom-component-loader)\n  - [Functions you can implement](#functions-you-can-implement)\n    - [getConfig(name, callback)](#getconfigname-callback)\n    - [loadComponent(name, componentConfig, callback)](#loadcomponentname-componentconfig-callback)\n    - [loadTemplate(name, templateConfig, callback)](#loadtemplatename-templateconfig-callback)\n    - [loadViewModel(name, viewModelConfig, callback)](#loadviewmodelname-viewmodelconfig-callback)\n  - [Registering custom component loaders](#registering-custom-component-loaders)\n  - [Controlling precedence](#controlling-precedence)\n  - [Sequence of calls](#sequence-of-calls)\n- [Example 1: A component loader that sets up naming conventions](#example-1-a-component-loader-that-sets-up-naming-conventions)\n- [Example 2: A component loader that loads external files using custom code](#example-2-a-component-loader-that-loads-external-files-using-custom-code)\n- [Note: Custom component loaders and custom elements](#note-custom-component-loaders-and-custom-elements)\n- [Note: Integrating with browserify](#note-integrating-with-browserify)\n\n## The default component loader\n\nThe built-in default component loader, ko.components.defaultLoader, is based around a central “registry” of component definitions. It relies on you explicitly registering a configuration for each component before you can use that component.\n\n[Learn more about configuring and registering components with the default loader](component-registration)\n\n## Component loader utility functions\n\nThe following functions read and write the default component loader’s registry:\n\n- ko.components.register(name, configuration)\n  - Registers a component. See: [full documentation](component-registration).\n- ko.components.isRegistered(name)\n  - Returns true if a component with the specified name is already registered; false otherwise.\n- ko.components.unregister(name)\n  - Removes the named component from the registry. Or if no such component was registered, does nothing.\n\nThe following functions work across the complete list of registered component loaders (not only the default loader):\n\n- ko.components.get(name, callback)\n  - Consults each registered loader in turn (by default, that’s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes callback to return than viewmodel/template declaration. Invokes callback(null) if none of the registered loaders know about this component.\n- ko.components.clearCachedDefinition(name)\n  - Normally, Knockout consults the loaders *once per component name*, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.\n\nAlso, since ko.components.defaultLoader is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:\n\n- ko.components.defaultLoader.getConfig(name, callback)\n- ko.components.defaultLoader.loadComponent(name, componentConfig, callback)\n- ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)\n- ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)\n\nFor documentation on these standard component loader functions, see [implementing a custom component loader](#custom-component-loader).\n\n## Implementing a custom component loader\n\nYou might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party “loader” library to fetch component viewmodels or templates from external locations.\n\n## Functions you can implement\n\nA custom component loader is simply an object whose properties are **any combination** of the following functions:\n\n### getConfig(name, callback)\n\n***Define this if:** you want to supply configurations programmatically based on names, e.g., to implement a naming convention.*\n\nIf declared, Knockout will call this function to obtain a configuration object for each component being instantiated.\n\n- To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.\n- For example, a componentConfig like { template: 'someElementId', viewModel: { require: 'myModule' } } can be understood and instantiated by the default loader.\n- You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.\n- If you do not want your loader to supply a configuration for the named component, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.\n\n### loadComponent(name, componentConfig, callback)\n\n***Define this if:** you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.*\n\nIf declared, Knockout will call this function to convert a componentConfig object into a viewmodel/template pair.\n\n- To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:\n\n  - template - **Required.** An array of DOM nodes\n  - createViewModel(params, componentInfo) - **Optional.** A function that will later be called to supply a viewmodel object for each instance of this component\n\n- If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.\n\n### loadTemplate(name, templateConfig, callback)\n\n***Define this if:** you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).*\n\nThe default component loader will call this function on any registered loaders that declare it, to convert the template part of a component configuration into an array of DOM nodes. The nodes are then cached and cloned for each instance of the component.\n\nThe templateConfig value is simply the template property from any componentConfig object. For example, it may contain \"some markup\" or { element: \"someId\" } or a custom format such as { loadFromUrl: \"someUrl.html\" }.\n\n- To supply an array of DOM nodes, call callback(domNodeArray).\n\n- If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.\n\n### loadViewModel(name, viewModelConfig, callback)\n\n***Define this if:** you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).*\n\nThe default component loader will call this function on any registered loaders that declare it, to convert the viewModel part of a component configuration into a createViewModel factory function. The function is then cached and called for each new instance of the component that needs a viewmodel.\n\nThe viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as { myViewModelType: 'Something', options: {} }.\n\n- To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.\n\n- If you do not want your loader to supply a createViewModel function for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.\n\n## Registering custom component loaders\n\nKnockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.\n\nSo, ko.components.loaders is an array containing all the loaders currently enabled. By default, this array contains just one item: ko.components.defaultLoader. To add additional loaders, simply insert them into the ko.components.loaders array.\n\n## Controlling precedence\n\nIf you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the *beginning* of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the *end* of the array.\n\nExample:\n\n``` javascript\n// Adds myLowPriorityLoader to the end of the loaders array.\n// It runs after other loaders, only if none of them returned a value.\nko.components.loaders.push(myLowPriorityLoader);\n\n// Adds myHighPriorityLoader to the beginning of the loaders array.\n// It runs before other loaders, getting the first chance to return values.\nko.components.loaders.unshift(myHighPriorityLoader)\n```\n\nIf required, you can remove ko.components.defaultLoader from the loaders array altogether.\n\n## Sequence of calls\n\nThe first time Knockout needs to construct a component with a given name, it:\n\n- Calls each of the registered loaders’ getConfig functions in turn, until the first one supplies a non-null componentConfig.\n- Then, with this componentConfig object, calls each of the registered loaders’ loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.\n\nWhen the default loader’s loadComponent runs, it simultaneously:\n\n- Calls each of the registered loaders’ loadTemplate functions in turn, until the first one supplies a non-null DOM array.\n  - The default loader itself has a loadTemplate function that resolves a range of template configuration formats into DOM arrays.\n- Calls each of the registered loaders’ loadViewModel functions in turn, until the first one supplies a non-null createViewModel function.\n  - The default loader itself has a loadViewModel function that resolves a range of viewmodel configuration formats into createViewModel functions.\n\nCustom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside ko.components.loaders, you can control the priority order of different loading strategies.\n\n## Example 1: A component loader that sets up naming conventions\n\nTo implement a naming convention, your custom component loader only needs to implement getConfig. For example:\n\n``` javascript\nvar namingConventionLoader = {\n    getConfig: function(name, callback) {\n        // 1. Viewmodels are classes corresponding to the component name.\n        //    e.g., my-component maps to MyApp.MyComponentViewModel\n        // 2. Templates are in elements whose ID is the component name\n        //    plus '-template'.    \n        var viewModelConfig = MyApp[toPascalCase(name) + 'ViewModel'],\n            templateConfig = { element: name + '-template' };\n\n        callback({ viewModel: viewModelConfig, template: templateConfig });\n    }\n};\n\nfunction toPascalCase(dasherized) {\n    return dasherized.replace(/(^|-)([a-z])/g, function (g, m1, m2) { return m2.toUpperCase(); });\n}\n\n// Register it. Make it take priority over the default loader.\nko.components.loaders.unshift(namingConventionLoader);\n```\n\nNow this is registered, you can reference components with any name (without preregistering them), e.g.:\n\n``` markup\n<div data-bind=\"component: 'my-component'\"></div>\n\n<!-- Declare template -->\n<template id='my-component-template'>Hello World!</template>\n\n<script>\n    // Declare viewmodel\n    window.MyApp = window.MyApp || {};\n    MyApp.MyComponentViewModel = function(params) {\n        // ...\n    }\n</script>\n```\n\n## Example 2: A component loader that loads external files using custom code\n\nIf your custom loader implements loadTemplate and/or loadViewModel, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.\n\nFor example, you might want to enable configuration formats like the following:\n\n``` javascript\nko.components.register('my-component', {\n    template: { fromUrl: 'file.html', maxCacheAge: 1234 },\n    viewModel: { viaLoader: '/path/myvm.js' }\n});\n```\n\n… and you can do so using custom loaders.\n\nThe following custom loader will take care of loading templates configured with a fromUrl value:\n\n``` javascript\nvar templateFromUrlLoader = {\n    loadTemplate: function(name, templateConfig, callback) {\n        if (templateConfig.fromUrl) {\n            // Uses jQuery's ajax facility to load the markup from a file\n            var fullUrl = '/templates/' + templateConfig.fromUrl + '?cacheAge=' + templateConfig.maxCacheAge;\n            $.get(fullUrl, function(markupString) {\n                // We need an array of DOM nodes, not a string.\n                // We can use the default loader to convert to the\n                // required format.\n                ko.components.defaultLoader.loadTemplate(name, markupString, callback);\n            });\n        } else {\n            // Unrecognized config format. Let another loader handle it.\n            callback(null);\n        }\n    }\n};\n\n// Register it\nko.components.loaders.unshift(templateFromUrlLoader);\n```\n\n… and the following custom loader will take care of loading viewmodels configured with a viaLoader value:\n\n``` javascript\nvar viewModelCustomLoader = {\n    loadViewModel: function(name, viewModelConfig, callback) {\n        if (viewModelConfig.viaLoader) {\n            // You could use arbitrary logic, e.g., a third-party\n            // code loader, to asynchronously supply the constructor.\n            // For this example, just use a hard-coded constructor function.\n            var viewModelConstructor = function(params) {\n                this.prop1 = 123;\n            };\n\n            // We need a createViewModel function, not a plain constructor.\n            // We can use the default loader to convert to the\n            // required format.\n            ko.components.defaultLoader.loadViewModel(name, viewModelConstructor, callback);\n        } else {\n            // Unrecognized config format. Let another loader handle it.\n            callback(null);\n        }\n    }\n};\n\n// Register it\nko.components.loaders.unshift(viewModelCustomLoader);\n```\n\nIf you prefer, you could combine templateFromUrlLoader and viewModelCustomLoader into a single loader by putting the loadTemplate and loadViewModel functions on a single object. However it’s quite nice to separate out these concerns, since their implementations are quite independent.\n\n## Note: Custom component loaders and custom elements\n\nIf you are using a component loader to fetch components by a naming convention, and are *not* registering your components using ko.components.register, then those components will not automatically be usable as custom elements (because you haven’t told Knockout that they even exist).\n\nSee: [How to enable custom elements with names that don’t correspond to explicitly registered components](component-custom-elements#registering-custom-elements)\n\n## Note: Integrating with browserify\n\n[Browserify](http://browserify.org/) is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax. It’s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.\n\nSince Browserify is a build-time tool, it doesn’t really need any special integration with KO components, and there’s no need to implement any kind of custom component loader to work with it. You can simply use Browserify’s require statements to grab instances of your component viewmodels, then explicitly register them, e.g.:\n\n``` javascript\n// Note that the following *only* works with Browserify - not with require.js,\n// since it relies on require() returning synchronously.\n\nko.components.register('my-browserify-component', {\n    viewModel: require('myViewModel'),\n    template: require('fs').readFileSync(__dirname + '/my-template.html', 'utf8')\n});\n```\n\nThis uses the [brfs Browserify plugin](https://github.com/substack/brfs) to automatically inline the .html file, so you would need to build the script file using a command similar to:\n\n``` javascript\nnpm install brfs\nbrowserify -t brfs main.js > bundle.js\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/component-loaders.html](https://knockoutjs.com/documentation/component-loaders.html)"
- name: Component registration
  id: component-registration
  summary: For Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here
  description: "# Component registration\n\nFor Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here.\n\n*Note: As an alternative, it’s possible to implement a [custom component loader](component-loaders) that fetches components by your own conventions instead of explicit configuration.*\n\n- [Registering components as a viewmodel/template pair](#registering-components-as-a-viewmodeltemplate-pair)\n  - [Specifying a viewmodel](#specifying-a-viewmodel)\n    - [A constructor function](#a-constructor-function)\n    - [A shared object instance](#a-shared-object-instance)\n    - [A createViewModel factory function](#a-createviewmodel-factory-function)\n    - [An AMD module whose value describes a viewmodel](#an-amd-module-whose-value-describes-a-viewmodel)\n  - [Specifying a template](#specifying-a-template)\n    - [An existing element ID](#an-existing-element-id)\n    - [An existing element instance](#an-existing-element-instance)\n    - [A string of markup](#a-string-of-markup)\n    - [An array of DOM nodes](#an-array-of-dom-nodes)\n    - [A document fragment](#a-document-fragment)\n    - [An AMD module whose value describes a template](#an-amd-module-whose-value-describes-a-template)\n  - [Specifying additional component options](#specifying-additional-component-options)\n    - [Controlling synchronous/asynchronous loading](#controlling-synchronousasynchronous-loading)\n- [How Knockout loads components via AMD](#how-knockout-loads-components-via-amd)\n  - [AMD modules are loaded only on demand](#amd-modules-are-loaded-only-on-demand)\n- [Registering components as a single AMD module](#registering-components-as-a-single-amd-module)\n  - [A recommended AMD module pattern](#a-recommended-amd-module-pattern)\n\n## Registering components as a viewmodel/template pair\n\nYou can register a component as follows:\n\n``` javascript\nko.components.register('some-component-name', {\n    viewModel: <see below>,\n    template: <see below>\n});\n```\n\n- The component **name** can be any nonempty string. It’s recommended, but not mandatory, to use lowercase dash-separated strings (such as your-component-name) so that the component name is valid to use as a [custom element](component-custom-elements) (such as \\<your-component-name\\>).\n- viewModel is optional, and can take any of [the viewModel formats described below](#specifying-a-viewmodel).\n- template is required, and can take any of [the template formats described below](#specifying-a-template).\n\nIf no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.\n\n### Specifying a viewmodel\n\nViewmodels can be specified in any of the following forms:\n\n#### A constructor function\n\n``` javascript\nfunction SomeComponentViewModel(params) {\n    // 'params' is an object whose key/value pairs are the parameters\n    // passed from the component binding or custom element.\n    this.someProperty = params.something;\n}\n\nSomeComponentViewModel.prototype.doSomething = function() { ... };\n\nko.components.register('my-component', {\n    viewModel: SomeComponentViewModel,\n    template: ...\n});\n```\n\nKnockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., someProperty and doSomething in the example above) are available for binding in the component’s view.\n\n#### A shared object instance\n\nIf you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):\n\n``` javascript\nvar sharedViewModelInstance = { ... };\n\nko.components.register('my-component', {\n    viewModel: { instance: sharedViewModelInstance },\n    template: ...\n});\n```\n\nNote that it’s necessary to specify viewModel: { instance: object }, and not just viewModel: object. This differentiates from the other cases below.\n\n#### A createViewModel factory function\n\nIf you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:\n\n``` javascript\nko.components.register('my-component', {\n    viewModel: {\n        createViewModel: function(params, componentInfo) {\n            // - 'params' is an object whose key/value pairs are the parameters\n            //   passed from the component binding or custom element\n            // - 'componentInfo.element' is the element the component is being\n            //   injected into. When createViewModel is called, the template has\n            //   already been injected into this element, but isn't yet bound.\n            // - 'componentInfo.templateNodes' is an array containing any DOM\n            //   nodes that have been supplied to the component. See below.\n\n            // Return the desired view model instance, e.g.:\n            return new MyViewModel(params);\n        }\n    },\n    template: ...\n});\n```\n\nNote that, typically, it’s best to perform direct DOM manipulation only through [custom bindings](custom-bindings) rather than acting on componentInfo.element from inside createViewModel. This leads to more modular, reusable code.\n\nThe componentInfo.templateNodes array is useful if you want to build a component that accepts arbitrary markup to influence its output (for example, a grid, list, dialog, or tab set that injects supplied markup into itself). For a complete example, see [passing markup into components](component-custom-elements#passing-markup-into-components).\n\n#### An AMD module whose value describes a viewmodel\n\nIf you have an AMD loader (such as [require.js](http://requirejs.org/)) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see [how Knockout loads components via AMD](#how-knockout-loads-components-via-amd) below. Example:\n\n``` javascript\nko.components.register('my-component', {\n    viewModel: { require: 'some/module/name' },\n    template: ...\n});\n```\n\nThe returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:\n\n``` javascript\n// AMD module whose value is a component viewmodel constructor\ndefine(['knockout'], function(ko) {\n    function MyViewModel() {\n        // ...\n    }\n\n    return MyViewModel;\n});\n```\n\n… or a shared object instance, e.g.:\n\n``` javascript\n// AMD module whose value is a shared component viewmodel instance\ndefine(['knockout'], function(ko) {\n    function MyViewModel() {\n        // ...\n    }\n\n    return { instance: new MyViewModel() };\n});\n```\n\n… or a createViewModel function, e.g.:\n\n``` javascript\n// AMD module whose value is a 'createViewModel' function\ndefine(['knockout'], function(ko) {\n    function myViewModelFactory(params, componentInfo) {\n        // return something\n    }\n    \n    return { createViewModel: myViewModelFactory };\n});\n```\n\n… or even, though it’s unlikely you’d want to do this, a reference to a different AMD module, e.g.:\n\n``` javascript\n// AMD module whose value is a reference to a different AMD module,\n// which in turn can be in any of these formats\ndefine(['knockout'], function(ko) {\n    return { module: 'some/other/module' };\n});\n```\n\n### Specifying a template\n\nTemplates can be specified in any of the following forms. The most commonly useful are [existing element IDs](#an-existing-element-id) and [AMD modules](#an-amd-module-whose-value-describes-a-template).\n\n#### An existing element ID\n\nFor example, the following element:\n\n``` markup\n<template id='my-component-template'>\n    <h1 data-bind='text: title'></h1>\n    <button data-bind='click: doSomething'>Click me right now</button>\n</template>\n```\n\n… can be used as the template for a component by specifying its ID:\n\n``` javascript\nko.components.register('my-component', {\n    template: { element: 'my-component-template' },\n    viewModel: ...\n});\n```\n\nNote that only the nodes *inside* the specified element will be cloned into each instance of the component. The container element (in this example, the \\<template\\> element), will *not* be treated as part of the component template.\n\nYou’re not limited to using \\<template\\> elements, but these are convenient (on browsers that support them) since they don’t get rendered on their own. Any other element type works too.\n\n#### An existing element instance\n\nIf you have a reference to a DOM element in your code, you can use it as a container for template markup:\n\n``` javascript\nvar elemInstance = document.getElementById('my-component-template');\n\nko.components.register('my-component', {\n    template: { element: elemInstance },\n    viewModel: ...\n});\n```\n\nAgain, only the nodes *inside* the specified element will be cloned for use as the component’s template.\n\n#### A string of markup\n\n``` markup\nko.components.register('my-component', {\n    template: '<h1 data-bind=\"text: title\"></h1>\\\n               <button data-bind=\"click: doSomething\">Clickety</button>',\n    viewModel: ...\n});\n```\n\nThis is mainly useful when you’re fetching the markup from somewhere programmatically (e.g., [AMD - see below](#a-recommended-amd-module-pattern)), or as a build system output that packages components for distribution, since it’s not very convenient to manually edit HTML as a JavaScript string literal.\n\n#### An array of DOM nodes\n\nIf you’re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:\n\n``` javascript\nvar myNodes = [\n    document.getElementById('first-node'),\n    document.getElementById('second-node'),\n    document.getElementById('third-node')\n];\n\nko.components.register('my-component', {\n    template: myNodes,\n    viewModel: ...\n});\n```\n\nIn this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.\n\n#### A document fragment\n\nIf you’re building configurations programmatically and you have a DocumentFragment object, you can use it as a component template:\n\n``` javascript\nko.components.register('my-component', {\n    template: someDocumentFragmentInstance,\n    viewModel: ...\n});\n```\n\nSince document fragments can have multiple top-level nodes, the *entire* document fragment (not just descendants of top-level nodes) is treated as the component template.\n\n#### An AMD module whose value describes a template\n\nIf you have an AMD loader (such as [require.js](http://requirejs.org/)) already in your page, then you can use it to fetch a template. For more details about how this works, see [how Knockout loads components via AMD](#how-knockout-loads-components-via-amd) below. Example:\n\n``` javascript\nko.components.register('my-component', {\n    template: { require: 'some/template' },\n    viewModel: ...\n});\n```\n\nThe returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using [require.js’s text plugin](http://requirejs.org/docs/api.html#text):\n\n``` javascript\nko.components.register('my-component', {\n    template: { require: 'text!path/my-html-file.html' },\n    viewModel: ...\n});\n```\n\n… or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.\n\n### Specifying additional component options\n\nAs well as (or instead of) template and viewModel, your component configuration object can have arbitrary other properties. This configuration object is made available to any [custom component loader](component-loaders) you may be using.\n\n#### Controlling synchronous/asynchronous loading\n\nIf your component configuration has a boolean synchronous property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is false (i.e., forced to be asynchronous). For example,\n\n``` javascript\nko.components.register('my-component', {\n    viewModel: { ... anything ... },\n    template: { ... anything ... },\n    synchronous: true // Injects synchronously if possible, otherwise still async\n});\n```\n\n**Why is component loading normally forced to be asynchronous?**\n\nNormally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because *sometimes it has no choice but to be asynchronous* (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default — it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.\n\n**Why would you ever enable synchronous loading?**\n\nIf you want to change the policy for a particular component, you can specify synchronous: true on that component’s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you’re using a component within a foreach binding and want to use the afterAdd or afterRender options to do post-processing.\n\nPrior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the foreach binding). With Knockout 3.4.0, components use Knockout’s [microtasks](microtasks) to ensure asynchronicity, and so will generally perform as well as synchronous loading.\n\n## How Knockout loads components via AMD\n\nWhen you load a viewmodel or template via require declarations, e.g.,\n\n``` javascript\nko.components.register('my-component', {\n    viewModel: { require: 'some/module/name' },\n    template: { require: 'text!some-template.html' }\n});\n```\n\n…all Knockout does is call require(\\['some/module/name'\\], callback) and require(\\['text!some-template.html'\\], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,\n\n- **This does not take a strict dependency on [require.js](http://requirejs.org/)** or any other particular module loader. *Any* module loader that provides an AMD-style require API will do. If you want to integrate with a module loader whose API is different, you can implement a [custom component loader](component-loaders).\n- **Knockout does not interpret the module name** in any way - it merely passes it through to require(). So of course Knockout does not know or care about where your module files are loaded from. That’s up to your AMD loader and how you’ve configured it.\n- **Knockout doesn’t know or care whether your AMD modules are anonymous or not**. Typically we find it’s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.\n\n#### AMD modules are loaded only on demand\n\nKnockout does not call require(\\[moduleName\\], ...) until your component is being instantiated. This is how components get loaded on demand, not up front.\n\nFor example, if your component is inside some other element with an [if binding](if-binding) (or another control flow binding), then it will not cause the AMD module to be loaded until the if condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the require call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.\n\n## Registering components as a single AMD module\n\nFor even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:\n\n``` javascript\nko.components.register('my-component', { require: 'some/module' });\n```\n\nNotice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file some/module.js could be declared as:\n\n``` markup\n// AMD module 'some/module.js' encapsulating the configuration for a component\ndefine(['knockout'], function(ko) {\n    function MyComponentViewModel(params) {\n        this.personName = ko.observable(params.name);\n    }\n\n    return {\n        viewModel: MyComponentViewModel,\n        template: 'The name is <strong data-bind=\"text: personName\"></strong>'\n    };\n});\n```\n\n### A recommended AMD module pattern\n\nWhat tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.\n\nFor example, if the following is in a file at path/my-component.js,\n\n``` javascript\n// Recommended AMD module pattern for a Knockout component that:\n//  - Can be referenced with just a single 'require' declaration\n//  - Can be included in a bundle using the r.js optimizer\ndefine(['knockout', 'text!./my-component.html'], function(ko, htmlString) {\n    function MyComponentViewModel(params) {\n        // Set up properties, etc.\n    }\n\n    // Use prototype to declare any public methods\n    MyComponentViewModel.prototype.doSomething = function() { ... };\n\n    // Return component definition\n    return { viewModel: MyComponentViewModel, template: htmlString };\n});\n```\n\n… and the template markup is in the file path/my-component.html, then you have these benefits:\n\n- Applications can reference this trivially, i.e., ko.components.register('my-component', { require: 'path/my-component' });\n- You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.\n- Since the dependency on the template is explicitly stated in the define call, this automatically works with the [r.js optimizer](http://requirejs.org/docs/optimization.html) or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.\n  - Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see [Yeoman](http://yeoman.io/) and the [generator-ko](https://www.npmjs.org/package/generator-ko) generator. Blog post coming soon.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/component-registration.html](https://knockoutjs.com/documentation/component-registration.html)"
- name: Computed observable reference
  id: computed-reference
  summary: The following documentation describes how to construct and work with computed observables
  description: "# Computed Observable Reference\n\nThe following documentation describes how to construct and work with computed observables.\n\n## Constructing a computed observable\n\nA computed observable can be constructed using one of the following forms:\n\n1.  ko.computed( evaluator \\[, targetObject, options\\] ) — This form supports the most common case of creating a computed observable.\n    - evaluator — A function that is used to evaluate the computed observable’s current value.\n    - targetObject — If given, defines the value of this whenever KO invokes your callback functions. See the section on [managing this](computedobservables#managing-this) for more information.\n    - options — An object with further properties for the computed observable. See the full list below.\n\n2.  ko.computed( options ) — This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.\n    - read — Required. A function that is used to evaluate the computed observable’s current value.\n    - write — Optional. If given, makes the computed observable *writable*. This is a function that receives values that other code is trying to write to your computed observable. It’s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).\n    - owner — Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.\n    - pure — Optional. If this option is true, the computed observable will be set up as a [*pure* computed observable](computed-pure). This option is an alternative to the ko.pureComputed constructor.\n    - deferEvaluation — Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.\n    - disposeWhen — Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.\n    - disposeWhenNodeIsRemoved — Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.\n\n3.  ko.pureComputed( evaluator \\[, targetObject\\] ) — Constructs a [*pure* computed observable](computed-pure) using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn’t accept an options parameter.\n\n4.  ko.pureComputed( options ) — Constructs a *pure* computed observable using an options object. This accepts the read, write, and owner options described above.\n\n## Using a computed observable\n\nA computed observable provides the following functions:\n\n- dispose() — Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won’t be cleaned.\n- extend(extenders) — Applies the given [extenders](extenders) to the computed observable.\n- getDependenciesCount() — Returns the current number of dependencies of the computed observable.\n- getDependencies() — Returns an array of the current dependencies of the computed observable. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.\n- getSubscriptionsCount( \\[event\\] ) — Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like \"change\") to return just the count of subscriptions for that event.\n- isActive() — Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.\n- peek() — Returns the current value of the computed observable without creating a dependency (see the section on [peek](computed-dependency-tracking#controlling-dependencies-using-peek)).\n- subscribe( callback \\[,callbackTarget, event\\] ) — Registers a [manual subscription](observables#explicitly-subscribing-to-observables) to be notified of changes to the computed observable.\n\n## Determining the observable type\n\nTo check if a property is observable, computed, etc., use the following set of functions:\n\n- ko.isObservable — returns true for observables, observable arrays, and all computed observables.\n- ko.isWritableObservable — returns true for observables, observable arrays, and *writable* computed observables (also aliased as ko.isWriteableObservable).\n- ko.isComputed — returns true for all computed observables.\n- ko.isPureComputed — returns true for *pure* computed observables.\n\n## Using the computed context\n\nDuring the execution of a computed observable’s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:\n\n- isInitial() — A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For *pure* computed observables, isInitial() is always undefined.\n\n- getDependenciesCount() — Returns the number of dependencies of the computed observable detected so far during the current evaluation.\n  - Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.\n\n- getDependencies() — Returns an array of the dependencies of the computed observable detected so far during the current evaluation. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.\n\nExample:\n\n``` javascript\nvar myComputed = ko.computed(function() {\n    // ... Omitted: read some data that might be observable ...\n\n    // Now let's inspect ko.computedContext\n    var isFirstEvaluation = ko.computedContext.isInitial(),\n        dependencyCount = ko.computedContext.getDependenciesCount(),\n    console.log(\"Evaluating \" + (isFirstEvaluation ? \"for the first time\" : \"again\"));\n    console.log(\"By now, this computed has \" + dependencyCount + \" dependencies\");\n\n    // ... Omitted: return the result ...\n});\n```\n\nThese facilities are typically useful only in advanced scenarios, for example when your computed observable’s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/computed-reference.html](https://knockoutjs.com/documentation/computed-reference.html)"
- name: Computed observables
  id: computedobservables
  summary: What if you’ve got an observable for firstName, and another for lastName, and you want to display the full name? That’s where computed observables come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change
  description: "# Computed Observables\n\nWhat if you’ve got an [observable](observables) for firstName, and another for lastName, and you want to display the full name? That’s where *computed observables* come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.\n\nFor example, given the following view model class,\n\n``` javascript\nfunction AppViewModel() {\n    this.firstName = ko.observable('Bob');\n    this.lastName = ko.observable('Smith');\n}\n```\n\n… you could add a computed observable to return the full name:\n\n``` javascript\nfunction AppViewModel() {\n    // ... leave firstName and lastName unchanged ...\n\n    this.fullName = ko.computed(function() {\n        return this.firstName() + \" \" + this.lastName();\n    }, this);\n}\n```\n\nNow you could bind UI elements to it, e.g.:\n\n``` markup\nThe name is <span data-bind=\"text: fullName\"></span>\n```\n\n… and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).\n\n### Dependency chains just work\n\nOf course, you can create whole chains of computed observables if you wish. For example, you might have:\n\n- an **observable** called items representing a set of items\n- another **observable** called selectedIndexes storing which item indexes have been ‘selected’ by the user\n- a **computed observable** called selectedItems that returns an array of item objects corresponding to the selected indexes\n- another **computed observable** that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.\n\nChanges to items or selectedIndexes will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.\n\n### Managing ‘this’\n\nThe second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you’re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren’t part of any object by default.)\n\n#### A popular convention that simplifies things\n\nThere’s a popular convention that avoids the need to track this altogether: if your viewmodel’s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don’t have to worry about it being redefined to refer to something else. For example:\n\n``` javascript\nfunction AppViewModel() {\n    var self = this;\n\n    self.firstName = ko.observable('Bob');\n    self.lastName = ko.observable('Smith');\n    self.fullName = ko.computed(function() {\n        return self.firstName() + \" \" + self.lastName();\n    });\n}\n```\n\nBecause self is captured in the function’s closure, it remains available and consistent in any nested functions, such as the computed observable’s evaluator. This convention is even more useful when it comes to event handlers, as you’ll see in many of the [live examples](https://knockoutjs.com/examples/).\n\n### *Pure* computed observables\n\nIf your computed observable simply calculates and returns a value based on some observable dependencies, then it’s better to declare it as a ko.pureComputed instead of a ko.computed. For example:\n\n``` javascript\nthis.fullName = ko.pureComputed(function() {\n    return this.firstName() + \" \" + this.lastName();\n}, this);\n```\n\nSince this computed is declared to be *pure* (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.\n\nPure computeds were introduced in Knockout 3.2.0. See also: [more about pure computed observables](computed-pure).\n\n### Forcing computed observables to always notify subscribers\n\nWhen a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify [extender](extenders) to ensure that a computed observable’s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:\n\n``` javascript\nmyViewModel.fullName = ko.pureComputed(function() {\n    return myViewModel.firstName() + \" \" + myViewModel.lastName();\n}).extend({ notify: 'always' });\n```\n\n### Delaying and/or suppressing change notifications\n\nNormally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable’s updates and notifications. This is accomplished using the [rateLimit extender](ratelimit-observable) like this:\n\n``` javascript\n// Ensure updates no more than once per 50-millisecond period\nmyViewModel.fullName.extend({ rateLimit: 50 });\n```\n\n### Determining if a property is a computed observable\n\nIn some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, ko.isComputed to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.\n\n``` javascript\nfor (var prop in myObject) {\n    if (myObject.hasOwnProperty(prop) && !ko.isComputed(myObject[prop])) {\n        result[prop] = myObject[prop];\n    }\n}\n```\n\nAdditionally, Knockout provides similar functions that can operate on observables and computed observables:\n\n- ko.isObservable - returns true for observables, observable arrays, and all computed observables.\n- ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).\n\n### When the computed observable is only used in your UI\n\nIf you only need to use the compound full name in the UI you could declare it as:\n\n``` javascript\nfunction AppViewModel() {\n    // ... leave firstName and lastName unchanged ...\n\n    this.fullName = function() {\n        return this.firstName() + \" \" + this.lastName();\n    };\n}\n```\n\nNow your binding in UI elements becomes a method call, e.g.:\n\n``` markup\nThe name is <span data-bind=\"text: fullName()\"></span>\n```\n\nKnockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/computedObservables.html](https://knockoutjs.com/documentation/computedObservables.html)"
- name: Custom bindings
  id: custom-bindings
  summary: You’re not limited to using the built-in bindings like click, value, and so on — you can create your own ones
  description: "# Creating custom bindings\n\nYou’re not limited to using the built-in bindings like click, value, and so on — you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.\n\nFor example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the [grid example](https://knockoutjs.com/examples/grid.html)).\n\n### Registering your binding\n\nTo register a binding, add it as a subproperty of ko.bindingHandlers:\n\n``` javascript\nko.bindingHandlers.yourBindingName = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // This will be called when the binding is first applied to an element\n        // Set up any initial state, event handlers, etc. here\n    },\n    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // This will be called once when the binding is first applied to an element,\n        // and again whenever any observables/computeds that are accessed change\n        // Update the DOM element based on the supplied values here.\n    }\n};\n```\n\n… and then you can use it on any number of DOM elements:\n\n``` markup\n<div data-bind=\"yourBindingName: someValue\"> </div>\n```\n\nNote: you don’t actually have to provide both init *and* update callbacks — you can just provide one or the other if that’s all you need.\n\n### The “update” callback\n\nKnockout will call the update callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the update callback will be called once again. The following parameters are passed to it:\n\n- element — The DOM element involved in this binding\n- valueAccessor — A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.\n- allBindings — A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn’t exist); or allBindings.has('name') to determine if the name binding is present for the current element.\n- viewModel — This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.\n- bindingContext — An object that holds the [binding context](http://knockoutjs.com/documentation/binding-context.html) available to this element’s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.\n\nFor example, you might have been controlling an element’s visibility using the visible binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery’s slideUp/slideDown functions:\n\n``` javascript\nko.bindingHandlers.slideVisible = {\n    update: function(element, valueAccessor, allBindings) {\n        // First get the latest data that we're bound to\n        var value = valueAccessor();\n\n        // Next, whether or not the supplied model property is observable, get its current value\n        var valueUnwrapped = ko.unwrap(value);\n\n        // Grab some more data from another binding property\n        var duration = allBindings.get('slideDuration') || 400; // 400ms is default duration unless otherwise specified\n\n        // Now manipulate the DOM element\n        if (valueUnwrapped == true)\n            $(element).slideDown(duration); // Make the element visible\n        else\n            $(element).slideUp(duration);   // Make the element invisible\n    }\n};\n```\n\nNow you can use this binding as follows:\n\n``` markup\n<div data-bind=\"slideVisible: giftWrap, slideDuration:600\">You have selected the option</div>\n<label><input type=\"checkbox\" data-bind=\"checked: giftWrap\" /> Gift wrap</label>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        giftWrap: ko.observable(true)\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\nOf course, this is a lot of code at first glance, but once you’ve created your custom bindings they can very easily be reused in many places.\n\n### The “init” callback\n\nKnockout will call your init function once for each DOM element that you use the binding on. There are two main uses for init:\n\n- To set any initial state for the DOM element\n- To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable\n\nKO will pass exactly the same set of parameters that it passes to [the update callback](#the-update-callback).\n\nContinuing the previous example, you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:\n\n``` javascript\nko.bindingHandlers.slideVisible = {\n    init: function(element, valueAccessor) {\n        var value = ko.unwrap(valueAccessor()); // Get the current value of the current property we're bound to\n        $(element).toggle(value); // jQuery will hide/show the element depending on whether \"value\" or true or false\n    },\n    update: function(element, valueAccessor, allBindings) {\n        // Leave as before\n    }\n};\n```\n\nThis means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.\n\n### Modifying observables after DOM events\n\nYou’ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.\n\nYou can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,\n\n``` javascript\nko.bindingHandlers.hasFocus = {\n    init: function(element, valueAccessor) {\n        $(element).focus(function() {\n            var value = valueAccessor();\n            value(true);\n        });\n        $(element).blur(function() {\n            var value = valueAccessor();\n            value(false);\n        });\n    },\n    update: function(element, valueAccessor) {\n        var value = valueAccessor();\n        if (ko.unwrap(value))\n            element.focus();\n        else\n            element.blur();\n    }\n};\n```\n\nNow you can both read and write the “focusedness” of an element by binding it to an observable:\n\n``` markup\n<p>Name: <input data-bind=\"hasFocus: editingName\" /></p>\n\n<!-- Showing that we can both read and write the focus state -->\n<div data-bind=\"visible: editingName\">You're editing the name</div>\n<button data-bind=\"enable: !editingName(), click:function() { editingName(true) }\">Edit name</button>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        editingName: ko.observable()\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\n### Note: Supporting virtual elements\n\nIf you want a custom binding to be usable with Knockout’s *virtual elements* syntax, e.g.:\n\n``` markup\n<!-- ko mybinding: somedata --> ... <!-- /ko -->\n```\n\n… then see [the documentation for virtual elements](custom-bindings-for-virtual-elements).\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/custom-bindings.html](https://knockoutjs.com/documentation/custom-bindings.html)"
- name: Custom disposal logic
  id: custom-bindings-disposal
  summary: In a typical Knockout application, DOM elements are dynamically added and removed, for example using the template binding or via control-flow bindings (if, ifnot, with, and foreach)
  description: "# Custom disposal logic\n\nIn a typical Knockout application, DOM elements are dynamically added and removed, for example using the [template](template-binding) binding or via control-flow bindings ([if](if-binding), [ifnot](ifnot-binding), [with](with-binding), and [foreach](foreach-binding)). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.\n\n### Registering a callback on the disposal of an element\n\nTo register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:\n\n``` javascript\nko.bindingHandlers.myWidget = {\n    init: function(element, valueAccessor) {\n        var options = ko.unwrap(valueAccessor()),\n            $el = $(element);\n\n        $el.myWidget(options);\n\n        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {\n            // This will be called when the element is removed by Knockout or\n            // if some other part of your code calls ko.removeNode(element)\n            $el.myWidget(\"destroy\");\n        });\n    }\n};\n```\n\n### Setting computed observables or manual subscriptions to dispose automatically\n\nIf you create a computed observable in a custom binding, rather than using a custom disposal callback, you can set the computed to dispose automatically when the node is removed. When constructing the computed observable, provide the node using the disposeWhenNodeIsRemoved option:\n\n``` javascript\nko.computed({\n    read: function () {\n        element.title = ko.unwrap(valueAccessor());\n    },\n    disposeWhenNodeIsRemoved: element\n});\n```\n\nIf a binding includes a manual subscription, this can be set to dispose automatically by calling its disposeWhenNodeIsRemoved method:\n\n``` javascript\nvar titleSubscription = someObservable.subscribe(function (val) {\n    element.title = val;\n});\ntitleSubscription.disposeWhenNodeIsRemoved(element);\n```\n\n### Overriding the clean-up of external data\n\nWhen removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery’s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:\n\n``` javascript\nko.utils.domNodeDisposal.cleanExternalData = function () {\n    // Do nothing. Now any jQuery data associated with elements will\n    // not be cleaned up when the elements are removed from the DOM.\n};\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/custom-bindings-disposal.html](https://knockoutjs.com/documentation/custom-bindings-disposal.html)"
- name: Custom elements
  id: component-custom-elements
  summary: Custom elements provide a convenient way of injecting components into your views
  description: "# Custom elements\n\nCustom elements provide a convenient way of injecting [components](component-overview) into your views.\n\n- [Introduction](#introduction)\n- [Example](#example)\n- [Passing parameters](#passing-parameters)\n  - [Communication between parent and child components](#communication-between-parent-and-child-components)\n  - [Passing observable expressions](#passing-observable-expressions)\n- [Passing markup into components](#passing-markup-into-components)\n- [Controlling custom element tag names](#controlling-custom-element-tag-names)\n- [Registering custom elements](#registering-custom-elements)\n- [Note: Combining custom elements with regular bindings](#note-combining-custom-elements-with-regular-bindings)\n- [Note: Custom elements cannot be self-closing](#note-custom-elements-cannot-be-self-closing)\n- [Note: Custom elements and Internet Explorer 6 to 8](#note-custom-elements-and-internet-explorer-6-to-8)\n- [Advanced: Accessing $raw parameters](#advanced-accessing-raw-parameters)\n\n### Introduction\n\nCustom elements are a syntactical alternative to the [component binding](component-binding) (and in fact, custom elements make use of a component binding behind the scenes).\n\nFor example, instead of writing this:\n\n``` markup\n<div data-bind='component: { name: \"flight-deals\", params: { from: \"lhr\", to: \"sfo\" } }'></div>\n```\n\n… you can write:\n\n``` markup\n<flight-deals params='from: \"lhr\", to: \"sfo\"'></flight-deals>\n```\n\nThis allows for a very modern, [WebComponents](http://www.w3.org/TR/components-intro/)-like way to organize your code, while retaining support for even very old browsers (see [custom elements and IE 6 to 8](#note-custom-elements-and-internet-explorer-6-to-8)).\n\n### Example\n\nThis example declares a component, and then injects two instances of it into a view. See the source code below.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<h4>First instance, without parameters</h4>\n<message-editor></message-editor>\n\n<h4>Second instance, passing parameters</h4>\n<message-editor params='initialText: \"Hello, world!\"'></message-editor>\n```\n\n#### Source code: View model\n\n``` js\nko.components.register('message-editor', {\n    viewModel: function(params) {\n        this.text = ko.observable(params.initialText || '');\n    },\n    template: 'Message: <input data-bind=\"value: text\" /> '\n            + '(length: <span data-bind=\"text: text().length\"></span>)'\n});\n\nko.applyBindings();\n```\n\nNote: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See [an example](component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand) and [registration documentation](component-registration).\n\n### Passing parameters\n\nAs you have seen in the examples above, you can use a params attribute to supply parameters to the component viewmodel. The contents of the params attribute are interpreted like a JavaScript object literal (just like a data-bind attribute), so you can pass arbitrary values of any type. Example:\n\n``` markup\n<unrealistic-component\n    params='stringValue: \"hello\",\n            numericValue: 123,\n            boolValue: true,\n            objectValue: { a: 1, b: 2 },\n            dateValue: new Date(),\n            someModelProperty: myModelValue,\n            observableSubproperty: someObservable().subprop'>\n</unrealistic-component>\n```\n\n#### Communication between parent and child components\n\nIf you refer to model properties in a params attribute, then you are of course referring to the properties on the viewmodel outside the component (the ‘parent’ or ‘host’ viewmodel), since the component itself is not instantiated yet. In the above example, myModelValue would be a property on the parent viewmodel, and would be received by the child component viewmodel’s constructor as params.someModelProperty.\n\nThis is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.\n\n#### Passing observable expressions\n\nIn the following example,\n\n``` markup\n<some-component\n    params='simpleExpression: 1 + 1,\n            simpleObservable: myObservable,\n            observableExpression: myObservable() + 1'>\n</some-component>\n```\n\n… the component viewmodel’s params parameter will contain three values:\n\n- simpleExpression\n  - This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.\n\n    In general, if a parameter’s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it’s not observable the parent would not know the child had done so.\n- simpleObservable\n  - This will be the [ko.observable](observables) instance declared on the parent viewmodel as myObservable. It is not a wrapper — it’s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.\n\n    In general, if a parameter’s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.\n- observableExpression\n  - This one is trickier. The expression itself, when evaluated, reads an observable. That observable’s value could change over time, so the expression result could change over time.\n\n    To ensure that the child component can react to changes in the expression value, Knockout **automatically upgrades this parameter to a computed property**. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.\n\n    In general, with custom elements, if a parameter’s evaluation involves evaluating an observable, then Knockout automatically constructs a ko.computed value to give the expression’s result, and supplies that to the component.\n\nIn summary, the general rule is:\n\n1.  If a parameter’s evaluation **does not** involve evaluating an observable/computed, it is passed literally.\n2.  If a parameter’s evaluation **does** involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.\n\n### Passing markup into components\n\nSometimes you may want to create a component that receives markup and uses it as part of its output. For example, you may want to build a “container” UI element such as a grid, list, dialog, or tab set that can receive and bind arbitrary markup inside itself.\n\nConsider a special list component that can be invoked as follows:\n\n``` markup\n<my-special-list params=\"items: someArrayOfPeople\">\n    <!-- Look, I'm putting markup inside a custom element -->\n    The person <em data-bind=\"text: name\"></em>\n    is <em data-bind=\"text: age\"></em> years old.\n</my-special-list>\n```\n\nBy default, the DOM nodes inside \\<my-special-list\\> will be stripped out (without being bound to any viewmodel) and replaced by the component’s output. However, those DOM nodes aren’t lost: they are remembered, and are supplied to the component in two ways:\n\n- As an array, $componentTemplateNodes, available to any binding expression in the component’s template (i.e., as a [binding context](binding-context) property). Usually this is the most convenient way to use the supplied markup. See the example below.\n- As an array, componentInfo.templateNodes, passed to its [createViewModel function](component-registration#a-createviewmodel-factory-function)\n\nThe component can then choose to use the supplied DOM nodes as part of its output however it wishes, such as by using template: { nodes: $componentTemplateNodes } on any element in the component’s template.\n\nFor example, the my-special-list component’s template can reference $componentTemplateNodes so that its output includes the supplied markup. Here’s the complete working example:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<!-- This could be in a separate file -->\n<template id=\"my-special-list-template\">\n    <h3>Here is a special list</h3>\n\n    <ul data-bind=\"foreach: { data: myItems, as: 'myItem' }\">\n        <li>\n            <h4>Here is another one of my special items</h4>\n            <!-- ko template: { nodes: $componentTemplateNodes, data: myItem } --><!-- /ko -->\n        </li>\n    </ul>\n</template>\n\n<my-special-list params=\"items: someArrayOfPeople\">\n    <!-- Look, I'm putting markup inside a custom element -->\n    The person <em data-bind=\"text: name\"></em>\n    is <em data-bind=\"text: age\"></em> years old.\n</my-special-list>\n```\n\n#### Source code: View model\n\n``` js\nko.components.register('my-special-list', {\n    template: { element: 'my-special-list-template' },\n    viewModel: function(params) {\n        this.myItems = params.items;\n    }\n});\n\nko.applyBindings({\n    someArrayOfPeople: ko.observableArray([\n        { name: 'Lewis', age: 56 },\n        { name: 'Hathaway', age: 34 }\n    ])\n});\n```\n\nThis “special list” example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog’s heading and borders) wrapped around arbitrary supplied markup.\n\nThis technique is also possible when using components *without* custom elements, i.e., [passing markup when using the component binding directly](component-binding#note-passing-markup-to-components).\n\n### Controlling custom element tag names\n\nBy default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using ko.components.register. This convention-over-configuration strategy is ideal for most applications.\n\nIf you want to have different custom element tag names, you can override getComponentNameForNode to control this. For example,\n\n``` javascript\nko.components.getComponentNameForNode = function(node) {\n    var tagNameLower = node.tagName && node.tagName.toLowerCase();\n\n    if (ko.components.isRegistered(tagNameLower)) {\n        // If the element's name exactly matches a preregistered\n        // component, use that component\n        return tagNameLower;\n    } else if (tagNameLower === \"special-element\") {\n        // For the element <special-element>, use the component\n        // \"MySpecialComponent\" (whether or not it was preregistered)\n        return \"MySpecialComponent\";\n    } else {\n        // Treat anything else as not representing a component\n        return null;\n    }\n}\n```\n\nYou can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.\n\n### Registering custom elements\n\nIf you are using the default component loader, and hence are registering your components using ko.components.register, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.\n\nIf you have implemented a [custom component loader](component-loaders), and are not using ko.components.register, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call ko.components.register - you don’t need to specify any configuration, since your custom component loader won’t be using the configuration anyway. For example,\n\n``` javascript\nko.components.register('my-custom-element', { /* No config needed */ });\n```\n\nAlternatively, you can [override getComponentNameForNode](#controlling-custom-element-tag-names) to control dynamically which elements map to which component names, independently of preregistration.\n\n### Note: Combining custom elements with regular bindings\n\nA custom element can have a regular data-bind attribute (in addition to any params attribute) if needed. For example,\n\n``` markup\n<products-list params='category: chosenCategory'\n               data-bind='visible: shouldShowProducts'>\n</products-list>\n```\n\nHowever, it does not make sense to use bindings that would modify the element’s contents, such as the [text](text-binding) or [template](template-binding) bindings, since they would overwrite the template injected by your component.\n\nKnockout will prevent the use of any bindings that use [controlsDescendantBindings](custom-bindings-controlling-descendant-bindings), because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as if or foreach, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:\n\n``` markup\n<!-- ko if: someCondition -->\n    <products-list></products-list>\n<!-- /ko -->\n```\n\nor:\n\n``` markup\n<ul data-bind='foreach: allProducts'>\n    <product-details params='product: $data'></product-details>\n</ul>\n```\n\n### Note: Custom elements cannot be self-closing\n\nYou must write \\<my-custom-element\\>\\</my-custom-element\\>, and **not** \\<my-custom-element /\\>. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.\n\nThis is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, [ignore any self-closing slashes](http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag) (except on a small number of special “foreign elements”, which are hardcoded into the parser). HTML is not the same as XML.\n\n### Note: Custom elements and Internet Explorer 6 to 8\n\nKnockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:\n\n- HTML5-era browsers, which includes **Internet Explorer 9** and later, automatically allow for custom elements with no difficulties.\n- **Internet Explorer 6 to 8** also supports custom elements, *but only if they are registered before the HTML parser encounters any of those elements*.\n\nIE 6-8’s HTML parser will discard any unrecognized elements. To ensure it doesn’t throw out your custom elements, you must do one of the following:\n\n- Ensure you call ko.components.register('your-component') *before* the HTML parser sees any \\<your-component\\> elements\n- Or, at least call document.createElement('your-component') *before* the HTML parser sees any \\<your-component\\> elements. You can ignore the result of the createElement call — all that matters is that you have called it.\n\nFor example, if you structure your page like this, then everything will be OK:\n\n``` markup\n<!DOCTYPE html>\n<html>\n    <body>\n        <script src='some-script-that-registers-components.js'></script>\n\n        <my-custom-element></my-custom-element>\n    </body>\n</html>\n```\n\nIf you’re working with AMD, then you might prefer a structure like this:\n\n``` markup\n<!DOCTYPE html>\n<html>\n    <body>\n        <script>\n            // Since the components aren't registered until the AMD module\n            // loads, which is asynchronous, the following prevents IE6-8's\n            // parser from discarding the custom element\n            document.createElement('my-custom-element');\n        </script>\n\n        <script src='require.js' data-main='app/startup'></script>\n\n        <my-custom-element></my-custom-element>\n    </body>\n</html>\n```\n\nOr if you really don’t like the hackiness of the document.createElement call, then you could use a [component binding](component-binding) for your top-level component instead of a custom element. As long as all other components are registered before your ko.applyBindings call, they can be used as custom elements on IE6-8 without futher trouble:\n\n``` markup\n<!DOCTYPE html>\n<html>\n    <body>\n        <!-- The startup module registers all other KO components before calling\n             ko.applyBindings(), so they are OK as custom elements on IE6-8 -->\n        <script src='require.js' data-main='app/startup'></script>\n\n        <div data-bind='component: \"my-custom-element\"'></div>\n    </body>\n</html>\n```\n\n### Advanced: Accessing $raw parameters\n\nConsider the following unusual case, in which useObservable1, observable1, and observable2 are all observables:\n\n``` markup\n<some-component\n    params='myExpr: useObservable1() ? observable1 : observable2'>\n</some-component>\n```\n\nSince evaluating myExpr involves reading an observable (useObservable1), KO will supply the parameter to the component as a computed property.\n\nHowever, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., params.myExpr()(), where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).\n\nThis double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.\n\nIn the unlikely event that you *don’t* want the automatic unwrapping, because you want to access the observable1/observable2 instances directly, you can read values from params.$raw. For example,\n\n``` javascript\nfunction MyComponentViewModel(params) {\n    var currentObservableInstance = params.$raw.myExpr();\n    \n    // Now currentObservableInstance is either observable1 or observable2\n    // and you would read its value with \"currentObservableInstance()\"\n}\n```\n\nThis should be a very unusual scenario, so normally you will not need to work with $raw.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/component-custom-elements.html](https://knockoutjs.com/documentation/component-custom-elements.html)"
- name: Custom functions
  id: fn
  summary: Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout’s core value types
  description: "# Adding custom functions using \"fn\"\n\nOccasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout’s core value types. You can define custom functions on any of the following types:\n\nBecause of inheritance, if you attach a function to ko.subscribable, it will be available on all the others too. If you attach a function to ko.observable, it will be inherited by ko.observableArray but not by ko.computed.\n\nTo attach a custom function, add it to one of the following extensibility points:\n\n- ko.subscribable.fn\n- ko.observable.fn\n- ko.observableArray.fn\n- ko.computed.fn\n\nThen, your custom function will become available on all values of that type created from that point onwards.\n\n***Note:*** It’s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don’t need to add a custom function to these namespaces if you’re only planning to use it once.\n\n### Example: A filtered view of an observable array\n\nHere’s a way to define a filterByProperty function that will become available on all subsequently-created ko.observableArray instances:\n\n``` javascript\nko.observableArray.fn.filterByProperty = function(propName, matchValue) {\n    return ko.pureComputed(function() {\n        var allItems = this(), matchingItems = [];\n        for (var i = 0; i < allItems.length; i++) {\n            var current = allItems[i];\n            if (ko.unwrap(current[propName]) === matchValue)\n                matchingItems.push(current);\n        }\n        return matchingItems;\n    }, this);\n}\n```\n\nThis returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.\n\nThe following live example shows how you could use this:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<h3>All tasks (<span data-bind=\"text: tasks().length\"> </span>)</h3>\n<ul data-bind=\"foreach: tasks\">\n    <li>\n        <label>\n            <input type=\"checkbox\" data-bind=\"checked: done\" />\n            <span data-bind=\"text: title\"> </span>\n        </label>\n    </li>\n</ul>\n\n<h3>Done tasks (<span data-bind=\"text: doneTasks().length\"> </span>)</h3>\n<ul data-bind=\"foreach: doneTasks\">\n    <li data-bind=\"text: title\"></li>\n</ul>\n```\n\n#### Source code: View model\n\n``` js\nfunction Task(title, done) {\n    this.title = ko.observable(title);\n    this.done = ko.observable(done);\n}\n\nfunction AppViewModel() {\n    this.tasks = ko.observableArray([\n        new Task('Find new desktop background', true),\n        new Task('Put shiny stickers on laptop', false),\n        new Task('Request more reggae music in the office', true)\n    ]);\n\n    // Here's where we use the custom function\n    this.doneTasks = this.tasks.filterByProperty(\"done\", true);\n}\n\nko.applyBindings(new AppViewModel());\n```\n\n#### It’s not mandatory\n\nIf you tend to filter observable arrays a lot, adding a filterByProperty globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose *not* to attach to ko.observableArray.fn, and instead just construct doneTasks by hand as follows:\n\n``` javascript\nthis.doneTasks = ko.pureComputed(function() {\n    var all = this.tasks(), done = [];\n    for (var i = 0; i < all.length; i++)\n        if (all[i].done())\n            done.push(all[i]);\n    return done;\n}, this);\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/fn.html](https://knockoutjs.com/documentation/fn.html)"
- name: data-bind syntax
  id: binding-syntax
  summary: Knockout’s declarative binding system provides a concise and powerful way to link data to the UI
  description: "# The data-bind syntax\n\nKnockout’s declarative binding system provides a concise and powerful way to link data to the UI. It’s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout’s binding system.\n\n### Binding syntax\n\nA binding consists of two items, the binding *name* and *value*, separated by a colon. Here is an example of a single, simple binding:\n\n``` markup\nToday's message is: <span data-bind=\"text: myMessage\"></span>\n```\n\nAn element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:\n\n``` markup\n<!-- related bindings: valueUpdate is a parameter for value -->\nYour value: <input data-bind=\"value: someValue, valueUpdate: 'afterkeydown'\" />\n\n<!-- unrelated bindings -->\nCellphone: <input data-bind=\"value: cellphoneNumber, enable: hasCellphone\" />\n```\n\nThe binding *name* should generally match a registered binding (either built-in or [custom](custom-bindings)) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn’t appear to work, first check that the name is correct.\n\n#### Binding values\n\nThe binding *value* can be a single [value, variable, or literal](https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals) or almost any valid [JavaScript expression](https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators). Here are examples of various binding values:\n\n``` markup\n<!-- variable (usually a property of the current view model -->\n<div data-bind=\"visible: shouldShowMessage\">...</div>\n\n<!-- comparison and conditional, template literals -->\nThe item is <span data-bind=\"text: price() > 50 ? `expensive` : `cheap`\"></span>.\n\n<!-- function call and comparison -->\n<button data-bind=\"enable: parseAreaCode(cellphoneNumber()) != '555'\">...</button>\n\n<!-- function expression -->\n<div data-bind=\"click: function (data) { myFunction('param1', data) }\">...</div>\n\n<!-- object literal (with unquoted and quoted property names) -->\n<div data-bind=\"with: {emotion: 'happy', 'facial-expression': 'smile'}\">...</div>\n```\n\nThese examples show that the value can be just about any JavaScript expression. Even the comma is fine when it’s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object’s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.\n\n#### Whitespace\n\nBindings can include any amount of *whitespace* (spaces, tab, and newlines), so you’re free to use it to arrange your bindings as you like. The following examples are all equivalent:\n\n``` markup\n<!-- no spaces -->\n<select data-bind=\"options:availableCountries,optionsText:'countryName',value:selectedCountry,optionsCaption:'Choose...'\"></select>\n\n<!-- some spaces -->\n<select data-bind=\"options : availableCountries, optionsText : 'countryName', value : selectedCountry, optionsCaption : 'Choose...'\"></select>\n\n<!-- spaces and newlines -->\n<select data-bind=\"\n    options: availableCountries,\n    optionsText: 'countryName',\n    value: selectedCountry,\n    optionsCaption: 'Choose...'\"></select>\n```\n\n#### Comments\n\nBindings can include JavaScript-style comments (//... and /\\*...\\*/). For example:\n\n``` markup\n<select data-bind=\"\n    options: availableCountries,  // Only list countries that are available\n    optionsText: 'countryName',\n    /* optionsValue: 'countryId',\n    value: selectedCountry, */    // These two bindings are not processed\n    optionsCaption: 'Choose...'\"></select>\n```\n\n#### Skipping the binding value\n\nIf you specify bindings without a value, Knockout will give the binding an undefined value. For example:\n\n``` markup\n<span data-bind=\"text\">Text that will be cleared when bindings are applied.</span>\n```\n\nThis ability is especially useful when paired with [binding preprocessing](binding-preprocessing), which can assign a default value for a binding.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/binding-syntax.html](https://knockoutjs.com/documentation/binding-syntax.html)"
- name: Deferred updates
  id: deferred-updates
  summary: 'Note: This documentation applies to Knockout 3.4.0 and later'
  description: "# Deferred updates\n\n*Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the [Deferred Updates](https://github.com/mbest/knockout-deferred-updates) plugin provides similar support.*\n\nIn complex applications, with multiple, intertwined dependencies, updating a single [observable](observables) might trigger a cascade of [computed observables](computedobservables), manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an [observable array](observablearrays)) can have a similar effect.\n\nUsing deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the [Knockout microtask queue](microtasks). This may sound very similar to [rate-limiting](ratelimit-observable), which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here’s how notification scheduling differs between the standard, deferred, and rate-limited modes:\n\n- *Standard* – Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.\n- *Deferred* – Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.\n- *Rate-limited* – Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).\n\n## Enabling deferred updates\n\nDeferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:\n\n``` javascript\nko.options.deferUpdates = true;\n```\n\nWhen the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to [work around these issues](#forcing-deferred-notifications-to-happen-early)).\n\n### Example: Avoiding multiple UI updates\n\nThe following is a contrived example to demonstrate the ability of deferred updates to eliminate UI updates of intermediate values and how this can improve performance.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<!--ko foreach: $root-->\n<div class=\"example\">\n    <table>\n        <tbody data-bind='foreach: data'>\n            <tr>\n                <td data-bind=\"text: name\"></td>\n                <td data-bind=\"text: position\"></td>\n                <td data-bind=\"text: location\"></td>\n            </tr>\n        </tbody>\n    </table>\n    <button data-bind=\"click: flipData, text: 'Flip ' + type\"></button>\n    <div class=\"time\" data-bind=\"text: (data(), timing() + ' ms')\"></div>\n</div>\n<!--/ko-->\n```\n\n#### Source code: View model\n\n``` js\nfunction AppViewModel(type) {\n    this.type = type;\n    this.data = ko.observableArray([\n        { name: 'Alfred', position: 'Butler', location: 'London' },\n        { name: 'Bruce', position: 'Chairman', location: 'New York' }\n    ]);\n    this.flipData = function () {\n        this.starttime = new Date().getTime();\n        var data = this.data();\n        for (var i = 0; i < 999; i++) {\n            this.data([]);\n            this.data(data.reverse());\n        }\n    }\n    this.timing = function () {\n        return this.starttime ? new Date().getTime() - this.starttime : 0;\n    };\n}\n\nko.options.deferUpdates = true;\nvar vmDeferred = new AppViewModel('deferred');\n\nko.options.deferUpdates = false;\nvar vmStandard = new AppViewModel('standard');\n\nko.applyBindings([vmStandard, vmDeferred]);\n```\n\n## Using deferred updates for specific observables\n\nEven if you don’t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the deferred extender:\n\n``` javascript\nthis.data = ko.observableArray().extend({ deferred: true });\n```\n\nNow we can push a bunch of items into the data array without worrying about causing excessive UI or computed updates. The deferred extender can be applied to any type of observable, including observable arrays and computed observables.\n\n### Example: Avoiding multiple Ajax requests\n\nThe following model represents data that you could render as a paged grid:\n\n``` javascript\nfunction GridViewModel() {\n    this.pageSize = ko.observable(20);\n    this.pageIndex = ko.observable(1);\n    this.currentPageData = ko.observableArray();\n\n    // Query /Some/Json/Service whenever pageIndex or pageSize changes,\n    // and use the results to update currentPageData\n    ko.computed(function() {\n        var params = { page: this.pageIndex(), size: this.pageSize() };\n        $.getJSON('/Some/Json/Service', params, this.currentPageData);\n    }, this);\n}\n```\n\nBecause the computed observable evaluates both pageIndex and pageSize, it becomes dependent on both of them. So, this code will use jQuery’s [$.getJSON function](http://api.jquery.com/jQuery.getJSON/) to reload currentPageData when a GridViewModel is first instantiated *and* whenever the pageIndex or pageSize properties are later changed.\n\nThis is very simple and elegant (and it’s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:\n\n``` javascript\nthis.setPageSize = function(newPageSize) {\n    // Whenever you change the page size, we always reset the page index to 1\n    this.pageSize(newPageSize);\n    this.pageIndex(1);\n}\n```\n\nThe problem is that this will cause *two* Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.\n\nWhen applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just *one* re-evaluation of the computed observable. For example:\n\n``` javascript\nko.computed(function() {\n    // This evaluation logic is exactly the same as before\n    var params = { page: this.pageIndex(), size: this.pageSize() };\n    $.getJSON('/Some/Json/Service', params, this.currentPageData);\n}, this).extend({ deferred: true });\n```\n\nNow you can change pageIndex and pageSize as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.\n\n## Forcing deferred notifications to happen early\n\nAlthough deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the [ko.tasks.runEarly method](microtasks#advanced-queue-control). For example:\n\n``` javascript\n// remove an item from an array\nvar items = myArray.splice(sourceIndex, 1);\n\n// force updates so the UI will see a delete/add rather than a move\nko.tasks.runEarly();\n\n// add the item in a new location\nmyArray.splice(targetIndex, 0, items[0]);\n```\n\n## Forcing deferred observables to always notify subscribers\n\nWhen the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.\n\nTo ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:\n\n``` javascript\nko.options.deferUpdates = true;\n\nmyViewModel.fullName = ko.pureComputed(function() {\n    return myViewModel.firstName() + \" \" + myViewModel.lastName();\n}).extend({ notify: 'always' });\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/deferred-updates.html](https://knockoutjs.com/documentation/deferred-updates.html)"
- name: Descendant bindings
  id: custom-bindings-controlling-descendant-bindings
  summary: 'Note: This is an advanced technique, typically used only when creating libraries of reusable bindings'
  description: "# Creating custom bindings that control descendant bindings\n\n*Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It’s not something you’ll normally need to do when building applications with Knockout.*\n\nBy default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout *not* to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.\n\nTo do this, simply return { controlsDescendantBindings: true } from your binding’s init function.\n\n### Example: Controlling whether or not descendant bindings are applied\n\nFor a very simple example, here’s a custom binding called allowBindings that allows descendant bindings to be applied only if its value is true. If the value is false, then allowBindings tells Knockout that it is responsible for descendant bindings so they won’t be bound as usual.\n\n``` javascript\nko.bindingHandlers.allowBindings = {\n    init: function(elem, valueAccessor) {\n        // Let bindings proceed as normal *only if* my value is false\n        var shouldAllowBindings = ko.unwrap(valueAccessor());\n        return { controlsDescendantBindings: !shouldAllowBindings };\n    }\n};\n```\n\nTo see this take effect, here’s a sample usage:\n\n``` markup\n<div data-bind=\"allowBindings: true\">\n    <!-- This will display Replacement, because bindings are applied -->\n    <div data-bind=\"text: 'Replacement'\">Original</div>\n</div>\n\n<div data-bind=\"allowBindings: false\">\n    <!-- This will display Original, because bindings are not applied -->\n    <div data-bind=\"text: 'Replacement'\">Original</div>\n</div>\n```\n\n### Example: Supplying additional values to descendant bindings\n\nNormally, bindings that use controlsDescendantBindings will also call ko.applyBindingsToDescendants(someBindingContext, element) to apply the descendant bindings against some modified [binding context](binding-context). For example, you could have a binding called withProperties that attaches some extra properties to the binding context that will then be available to all descendant bindings:\n\n``` javascript\nko.bindingHandlers.withProperties = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // Make a modified binding context, with a extra properties, and apply it to descendant elements\n        var innerBindingContext = bindingContext.extend(valueAccessor);\n        ko.applyBindingsToDescendants(innerBindingContext, element);\n\n        // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice\n        return { controlsDescendantBindings: true };\n    }\n};\n```\n\nAs you can see, binding contexts have an extend function that produces a clone with extra properties. The extend function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn’t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.\n\nHere’s an example of using the above custom binding:\n\n``` markup\n<div data-bind=\"withProperties: { emotion: 'happy' }\">\n    Today I feel <span data-bind=\"text: emotion\"></span>. <!-- Displays: happy -->\n</div>\n<div data-bind=\"withProperties: { emotion: 'whimsical' }\">\n    Today I feel <span data-bind=\"text: emotion\"></span>. <!-- Displays: whimsical -->\n</div>\n```\n\n### Example: Adding extra levels in the binding context hierarchy\n\nBindings such as [with](with-binding) and [foreach](foreach-binding) create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using $parent, $parents, $root, or $parentContext.\n\nIf you want to do this in custom bindings, then instead of using bindingContext.extend(), use bindingContext.createChildContext(someData). This returns a new binding context whose viewmodel is someData and whose $parentContext is bindingContext. If you want, you can then extend the child context with extra properties using ko.utils.extend. For example,\n\n``` javascript\nko.bindingHandlers.withProperties = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        // Make a modified binding context, with a extra properties, and apply it to descendant elements\n        var childBindingContext = bindingContext.createChildContext(\n            bindingContext.$rawData, \n            null, // Optionally, pass a string here as an alias for the data item in descendant contexts\n            function(context) {\n                ko.utils.extend(context, valueAccessor());\n            });\n        ko.applyBindingsToDescendants(childBindingContext, element);\n\n        // Also tell KO *not* to bind the descendants itself, otherwise they will be bound twice\n        return { controlsDescendantBindings: true };\n    }\n};\n```\n\nThis updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:\n\n``` markup\n<div data-bind=\"withProperties: { displayMode: 'twoColumn' }\">\n    The outer display mode is <span data-bind=\"text: displayMode\"></span>.\n    <div data-bind=\"withProperties: { displayMode: 'doubleWidth' }\">\n        The inner display mode is <span data-bind=\"text: displayMode\"></span>, but I haven't forgotten\n        that the outer display mode is <span data-bind=\"text: $parentContext.displayMode\"></span>.\n    </div>\n</div>\n```\n\nBy modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html](https://knockoutjs.com/documentation/custom-bindings-controlling-descendant-bindings.html)"
- name: enable and disable bindings
  id: enable-binding
  summary: The enable binding causes the associated DOM element to be enabled when its parameter value is true
  description: "# The \"enable\" and \"disable\" bindings\n\n### Purpose\n\nThe enable binding causes the associated DOM element to be enabled when its parameter value is true. The disable binding works oppositely, causing the associated DOM element to be disabled when its value is true. These bindings are useful with form elements like input, select, and textarea.\n\n### Example\n\n``` markup\n<p>\n    <input type='checkbox' data-bind=\"checked: hasCellphone\" />\n    I have a cellphone\n</p>\n<p>\n    Your cellphone number:\n    <input type='text' data-bind=\"value: cellphoneNumber, enable: hasCellphone\" />\n</p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        hasCellphone : ko.observable(false),\n        cellphoneNumber: \"\"\n    };\n</script>\n```\n\nIn this example, the “Your cellphone number” text box will initially be disabled. It will be enabled only when the user checks the box labelled “I have a cellphone”.\n\n### Parameters\n\n- Main parameter\n\n  A value that controls whether or not the associated DOM element should be enabled.\n\n  Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true.\n\n  If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only set the state once and will not do so again later.\n\n- Additional parameters\n\n  - None\n\n### Note: Using arbitrary JavaScript expressions\n\nYou’re not limited to referencing variables - you can reference arbitrary expressions to control an element’s enabledness. For example,\n\n``` markup\n<button data-bind=\"enable: parseAreaCode(viewModel.cellphoneNumber()) != '555'\">\n    Do something\n</button>\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/enable-binding.html](https://knockoutjs.com/documentation/enable-binding.html)"
- name: event binding
  id: event-binding
  summary: The event binding allows you to add an event handler for a specified event so that your chosen JavaScript function will be invoked when that event is triggered for the associated DOM element
  description: "# The \"event\" binding\n\n### Purpose\n\nThe event binding allows you to add an event handler for a specified event so that your chosen JavaScript function will be invoked when that event is triggered for the associated DOM element. This can be used to bind to any event, such as keypress, mouseover or mouseout.\n\n### Example\n\n``` markup\n<div>\n    <div data-bind=\"event: { mouseover: enableDetails, mouseout: disableDetails }\">\n        Mouse over me\n    </div>\n    <div data-bind=\"visible: detailsEnabled\">\n        Details\n    </div>\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        detailsEnabled: ko.observable(false),\n        enableDetails: function() {\n            this.detailsEnabled(true);\n        },\n        disableDetails: function() {\n            this.detailsEnabled(false);\n        }\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\nNow, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the detailsEnabled observable. The second element reacts to changes to the value of detailsEnabled by either showing or hiding itself.\n\n### Parameters\n\n- Main parameter\n\n  You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.\n\n  You can reference any JavaScript function - it doesn’t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.\n\n- Additional parameters\n\n  - None\n\n### Note 1: Passing a “current item” as a parameter to your handler function\n\nWhen calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you’re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,\n\n``` markup\n<ul data-bind=\"foreach: places\">\n    <li data-bind=\"text: $data, event: { mouseover: $parent.logMouseOver }\"> </li>\n</ul>\n<p>You seem to be interested in: <span data-bind=\"text: lastInterest\"> </span></p>\n\n <script type=\"text/javascript\">\n     function MyViewModel() {\n         var self = this;\n         self.lastInterest = ko.observable();\n         self.places = ko.observableArray(['London', 'Paris', 'Tokyo']);\n\n         // The current item will be passed as the first parameter, so we know which place was hovered over\n         self.logMouseOver = function(place) {\n             self.lastInterest(place);\n         }\n     }\n     ko.applyBindings(new MyViewModel());\n</script>\n```\n\nTwo points to note about this example:\n\n- If you’re inside a nested [binding context](binding-context), for example if you’re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you’ll need to use a prefix such as $parent or $root to locate the handler function.\n- In your viewmodel, it’s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.\n\n### Note 2: Accessing the event object, or passing more parameters\n\nIn some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:\n\n``` markup\n<div data-bind=\"event: { mouseover: myFunction }\">\n    Mouse over me\n</div>\n\n <script type=\"text/javascript\">\n    var viewModel = {\n        myFunction: function(data, event) {\n            if (event.shiftKey) {\n                //do something different when user has shift key down\n            } else {\n                //do normal action\n            }\n        }\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\nIf you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:\n\n``` markup\n<div data-bind=\"event: { mouseover: function(data, event) { myFunction('param1', 'param2', data, event) } }\">\n    Mouse over me\n</div>\n```\n\nNow, KO will pass the event to your function literal, which is then available to be passed to your handler.\n\nAlternatively, if you prefer to avoid the function literal in your view, you can use the [bind](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind) function, which attaches specific parameter values to a function reference:\n\n``` markup\n<button data-bind=\"event: { mouseover: myFunction.bind($data, 'param1', 'param2') }\">\n    Click me\n</button>\n```\n\n### Note 3: Allowing the default action\n\nBy default, Knockout will prevent the event from taking any default action. For example if you use the event binding to capture the keypress event of an input tag, the browser will only call your handler function and will *not* add the value of the key to the input element’s value. A more common example is using [the click binding](click-binding), which internally uses this binding, where your handler function will be called, but the browser will *not* navigate to the link’s href. This is a useful default because when you use the click binding, it’s normally because you’re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.\n\nHowever, if you *do* want to let the default action proceed, just return true from your event handler function.\n\n### Note 4: Preventing the event from bubbling\n\nBy default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a mouseover event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named youreventBubble and passing false to it, as in this example:\n\n``` markup\n<div data-bind=\"event: { mouseover: myDivHandler }\">\n    <button data-bind=\"event: { mouseover: myButtonHandler }, mouseoverBubble: false\">\n        Click me\n    </button>\n</div>\n```\n\nNormally, in this case myButtonHandler would be called first, then the event would bubble up to myDivHandler. However, the mouseoverBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.\n\n### Note 5: Interaction with jQuery\n\nKnockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:\n\n``` javascript\nko.options.useOnlyNativeEvents = true;\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/event-binding.html](https://knockoutjs.com/documentation/event-binding.html)"
- name: Event handling
  id: unobtrusive-event-handling
  summary: In most cases, data-bind attributes provide a clean and succinct way to bind to a view model
  description: "# Using unobtrusive event handlers\n\nIn most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:\n\n``` markup\n<a href=\"#\" data-bind=\"click: function() { viewModel.items.remove($data); }\">\n    remove\n</a>\n```\n\nAs an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:\n\n- ko.dataFor(element) - returns the data that was available for binding against the element\n- ko.contextFor(element) - returns the entire [binding context](binding-context) that was available to the DOM element.\n\nThese helper functions can be used in event handlers that are attached unobtrusively using something like jQuery’s bind or click. The above function could be attached to each link with a remove class like:\n\n``` javascript\n$(\".remove\").click(function () {\n    viewModel.items.remove(ko.dataFor(this));\n});\n```\n\nBetter yet, this techinique could be used to support event delegation. jQuery’s live/delegate/on functions are an easy way to make this happen:\n\n``` javascript\n$(\".container\").on(\"click\", \".remove\", function() {\n    viewModel.items.remove(ko.dataFor(this));\n});\n```\n\nNow, a single event handler is attached at a higher level and handles clicks against any links with the remove class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).\n\n### Live example: nested children\n\nThis example shows “add” and “remove” links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<ul id=\"people\" data-bind='template: { name: \"personTmpl\", foreach: people }'>\n</ul>\n\n<script id=\"personTmpl\" type=\"text/html\">\n    <li>\n        <a class=\"remove\" href=\"#\"> x </a>\n        <span data-bind='text: name'></span>\n        <a class=\"add\" href=\"#\"> add child </a>\n        <ul data-bind='template: { name: \"personTmpl\", foreach: children }'></ul>\n    </li>\n</script>\n```\n\n#### Source code: View model\n\n``` js\nvar Person = function(name, children) {\n    this.name = ko.observable(name);\n    this.children = ko.observableArray(children || []);\n};\n\nvar PeopleModel = function() {\n    this.people = ko.observableArray([\n        new Person(\"Bob\", [\n            new Person(\"Jan\"),\n            new Person(\"Don\", [\n                new Person(\"Ted\"),\n                new Person(\"Ben\", [\n                    new Person(\"Joe\", [\n                        new Person(\"Ali\"),\n                        new Person(\"Ken\")\n                    ])\n                ]),\n                new Person(\"Doug\")\n            ])\n        ]),\n        new Person(\"Ann\", [\n            new Person(\"Eve\"),\n            new Person(\"Hal\")\n        ])\n    ]);\n\n    this.addChild = function(name, parentArray) {\n        parentArray.push(new Person(name));\n    };\n};\n\nko.applyBindings(new PeopleModel());\n\n//attach event handlers\n$(\"#people\").on(\"click\", \".remove\", function() {\n    //retrieve the context\n    var context = ko.contextFor(this),\n        parentArray = context.$parent.people || context.$parent.children;\n\n    //remove the data (context.$data) from the appropriate array on its parent (context.$parent)\n    parentArray.remove(context.$data);\n\n    return false;\n});\n\n$(\"#people\").on(\"click\", \".add\", function() {\n    //retrieve the context\n    var context = ko.contextFor(this),\n        childName = context.$data.name() + \" child\",\n        parentArray = context.$data.people || context.$data.children;\n\n    //add a child to the appropriate parent, calling a method off of the main view model (context.$root)\n    context.$root.addChild(childName, parentArray);\n\n    return false;\n});\n```\n\nNo matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/unobtrusive-event-handling.html](https://knockoutjs.com/documentation/unobtrusive-event-handling.html)"
- name: Extending observables
  id: extenders
  summary: Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes
  description: "# Using extenders to augment observables\n\nKnockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.\n\n### How to create an extender\n\nCreating an extender involves adding a function to the ko.extenders object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.\n\nThis simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.\n\n``` javascript\nko.extenders.logChange = function(target, option) {\n    target.subscribe(function(newValue) {\n       console.log(option + \": \" + newValue);\n    });\n    return target;\n};\n```\n\nYou would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.\n\n``` javascript\nthis.firstName = ko.observable(\"Bob\").extend({logChange: \"first name\"});\n```\n\nIf the firstName observable’s value was changed to Ted, then the console would show first name: Ted.\n\n### Live Example 1: Forcing input to be numeric\n\nThis example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<p><input data-bind=\"value: myNumberOne\" /> (round to whole number)</p>\n<p><input data-bind=\"value: myNumberTwo\" /> (round to two decimals)</p>\n```\n\n#### Source code: View model\n\n``` js\nko.extenders.numeric = function(target, precision) {\n    //create a writable computed observable to intercept writes to our observable\n    var result = ko.pureComputed({\n        read: target,  //always return the original observables value\n        write: function(newValue) {\n            var current = target(),\n                roundingMultiplier = Math.pow(10, precision),\n                newValueAsNum = isNaN(newValue) ? 0 : +newValue,\n                valueToWrite = Math.round(newValueAsNum * roundingMultiplier) / roundingMultiplier;\n\n            //only write if it changed\n            if (valueToWrite !== current) {\n                target(valueToWrite);\n            } else {\n                //if the rounded value is the same, but a different value was written, force a notification for the current field\n                if (newValue !== current) {\n                    target.notifySubscribers(valueToWrite);\n                }\n            }\n        }\n    }).extend({ notify: 'always' });\n\n    //initialize with current value to make sure it is rounded appropriately\n    result(target());\n\n    //return the new computed observable\n    return result;\n};\n\nfunction AppViewModel(one, two) {\n    this.myNumberOne = ko.observable(one).extend({ numeric: 0 });\n    this.myNumberTwo = ko.observable(two).extend({ numeric: 2 });\n}\n\nko.applyBindings(new AppViewModel(221.2234, 123.4525));\n```\n\nNote that for this to automatically erase rejected values from the UI, it’s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it’s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using { notify: 'always' } causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.\n\n### Live Example 2: Adding validation to an observable\n\nThis example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<p data-bind=\"css: { error: firstName.hasError }\">\n    <input data-bind='value: firstName, valueUpdate: \"afterkeydown\"' />\n    <span data-bind='visible: firstName.hasError, text: firstName.validationMessage'> </span>\n</p>\n<p data-bind=\"css: { error: lastName.hasError }\">\n    <input data-bind='value: lastName, valueUpdate: \"afterkeydown\"' />\n    <span data-bind='visible: lastName.hasError, text: lastName.validationMessage'> </span>\n</p>\n```\n\n#### Source code: View model\n\n``` js\nko.extenders.required = function(target, overrideMessage) {\n    //add some sub-observables to our observable\n    target.hasError = ko.observable();\n    target.validationMessage = ko.observable();\n\n    //define a function to do validation\n    function validate(newValue) {\n       target.hasError(newValue ? false : true);\n       target.validationMessage(newValue ? \"\" : overrideMessage || \"This field is required\");\n    }\n\n    //initial validation\n    validate(target());\n\n    //validate whenever the value changes\n    target.subscribe(validate);\n\n    //return the original observable\n    return target;\n};\n\nfunction AppViewModel(first, last) {\n    this.firstName = ko.observable(first).extend({ required: \"Please enter a first name\" });\n    this.lastName = ko.observable(last).extend({ required: \"\" });\n}\n\nko.applyBindings(new AppViewModel(\"Bob\",\"Smith\"));\n```\n\n### Applying multiple extenders\n\nMore than one extender can be applied in a single call to the .extend method of an observable.\n\n``` javascript\nthis.firstName = ko.observable(first).extend({ required: \"Please enter a first name\", logChange: \"first name\" });\n```\n\nIn this case, both the required and logChange extenders would be executed against our observable.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/extenders.html](https://knockoutjs.com/documentation/extenders.html)"
- name: foreach binding
  id: foreach-binding
  summary: The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item
  description: "# The \"foreach\" binding\n\n### Purpose\n\nThe foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.\n\nAssuming your array is an [observable array](observablearrays), whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire foreach output after each array change.\n\nOf course, you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with.\n\n### Example 1: Iterating over an array\n\nThis example uses foreach to produce a read-only table with a row for each array entry.\n\n``` markup\n<table>\n    <thead>\n        <tr><th>First name</th><th>Last name</th></tr>\n    </thead>\n    <tbody data-bind=\"foreach: people\">\n        <tr>\n            <td data-bind=\"text: firstName\"></td>\n            <td data-bind=\"text: lastName\"></td>\n        </tr>\n    </tbody>\n</table>\n\n<script type=\"text/javascript\">\n    ko.applyBindings({\n        people: [\n            { firstName: 'Bert', lastName: 'Bertington' },\n            { firstName: 'Charles', lastName: 'Charlesforth' },\n            { firstName: 'Denise', lastName: 'Dentiste' }\n        ]\n    });\n</script>\n```\n\n### Example 2: Live example with add/remove\n\nThe following example shows that, if your array is observable, then the UI will be kept in sync with changes to that array.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<h4>People</h4>\n<ul data-bind=\"foreach: people\">\n    <li>\n        Name at position <span data-bind=\"text: $index\"> </span>:\n        <span data-bind=\"text: name\"> </span>\n        <a href=\"#\" data-bind=\"click: $parent.removePerson\">Remove</a>\n    </li>\n</ul>\n<button data-bind=\"click: addPerson\">Add</button>\n```\n\n#### Source code: View model\n\n``` js\nfunction AppViewModel() {\n    var self = this;\n\n    self.people = ko.observableArray([\n        { name: 'Bert' },\n        { name: 'Charles' },\n        { name: 'Denise' }\n    ]);\n\n    self.addPerson = function() {\n        self.people.push({ name: \"New at \" + new Date() });\n    };\n\n    self.removePerson = function() {\n        self.people.remove(this);\n    }\n}\n\nko.applyBindings(new AppViewModel());\n```\n\n### Parameters\n\n- Main parameter\n\n  Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.\n\n  Alternatively, pass a JavaScript object literal with a property called data which is the array you wish to iterate over. The object literal may also have other properties, such as afterAdd or includeDestroyed — see below for details of these extra options and examples of their use.\n\n  If the array you supply is observable, the foreach binding will respond to any future changes in the array’s contents by adding or removing corresponding sections of markup in the DOM.\n\n- Additional parameters\n\n  - None\n\n### Note 1: Referring to each array entry using $data\n\nAs shown in the above examples, bindings within the foreach block can refer to properties on the array entries. For example, [Example 1](#example-1-iterating-over-an-array) referenced the firstName and lastName properties on each array entry.\n\nBut what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the [special context property](binding-context) $data. Within a foreach block, it means “the current item”. For example,\n\n``` markup\n<ul data-bind=\"foreach: months\">\n    <li>\n        The current item is: <b data-bind=\"text: $data\"></b>\n    </li>\n</ul>\n\n<script type=\"text/javascript\">\n    ko.applyBindings({\n        months: [ 'Jan', 'Feb', 'Mar', 'etc' ]\n    });\n</script>\n```\n\nIf you wanted, you could use $data as a prefix when referencing properties on each entry. For example, you could rewrite part of [Example 1](#example-1-iterating-over-an-array) as follows:\n\n``` markup\n<td data-bind=\"text: $data.firstName\"></td>\n```\n\n… but you don’t have to, because firstName will be evaluated within the context of $data by default anyway. If the items in the array are observables, $data will refer to the value of each observable. To refer to the observable itself, use $rawData.\n\n### Note 2: Using $index, $parent, and other context properties\n\nAs you can see from Example 2 above, it’s possible to use $index to refer to the zero-based index of the current array item. $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).\n\nSimilarly, you can use $parent to refer to data from outside the foreach, e.g.:\n\n``` markup\n<h1 data-bind=\"text: blogPostTitle\"></h1>\n<ul data-bind=\"foreach: likes\">\n    <li>\n        <b data-bind=\"text: name\"></b> likes the blog post <b data-bind=\"text: $parent.blogPostTitle\"></b>\n    </li>\n</ul>\n```\n\nFor more information about $index and other context properties such as $parent, see documentation for [binding context properties](binding-context).\n\n### Note 3: Using “as” to give an alias to “foreach” items\n\nAs described in Note 1, you can refer to each array entry using the $data [context variable](binding-context). In some cases though, it may be useful to give the current item a more descriptive name using the as option like:\n\n``` markup\n<ul data-bind=\"foreach: { data: people, as: 'person' }\"></ul>\n```\n\nNow anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item that is being rendered from the people array. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:\n\n``` markup\n<ul data-bind=\"foreach: { data: categories, as: 'category' }\">\n    <li>\n        <ul data-bind=\"foreach: { data: items, as: 'item' }\">\n            <li>\n                <span data-bind=\"text: category.name\"></span>:\n                <span data-bind=\"text: item\"></span>\n            </li>\n        </ul>\n    </li>\n</ul>\n\n<script>\n    var viewModel = {\n        categories: ko.observableArray([\n            { name: 'Fruit', items: [ 'Apple', 'Orange', 'Banana' ] },\n            { name: 'Vegetables', items: [ 'Celery', 'Corn', 'Spinach' ] }\n        ])\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\nTip: Remember to pass a *string literal value* to as (e.g., as: 'category', *not* as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.\n\nThe as option also provides a corresponding *index* value. For example, if you set as: 'category', you can access the index of the current item using categoryIndex.\n\n#### Using “as” without creating a child context\n\nThe default behavior of the as option is to add a name for the current item while still also binding the contents to the item. But you may prefer keep the context unchanged and only set the name of the current item. This latter behavior will probably be the default in a future version of Knockout. To turn it on for a specific binding, set the noChildContext option to true. When this option is used along with as, all access to the array items must be through the given name, and $data will remain set to the outer viewmodel. For example:\n\n``` markup\n<ul data-bind=\"foreach: { data: categories, as: 'category', noChildContext: true }\">\n    <li>\n        <ul data-bind=\"foreach: { data: category.items, as: 'item', noChildContext: true }\">\n            <li>\n                <span data-bind=\"text: category.name\"></span>:\n                <span data-bind=\"text: item\"></span>\n            </li>\n        </ul>\n    </li>\n</ul>\n```\n\n### Note 4: Using foreach without a container element\n\nIn some cases, you might want to duplicate a section of markup, but you don’t have any container element on which to put a foreach binding. For example, you might want to generate the following:\n\n``` markup\n<ul>\n    <li class=\"header\">Header item</li>\n    <!-- The following are generated dynamically from an array -->\n    <li>Item A</li>\n    <li>Item B</li>\n    <li>Item C</li>\n</ul>\n```\n\nIn this example, there isn’t anywhere to put a normal foreach binding. You can’t put it on the \\<ul\\> (because then you’d be duplicating the header item), nor can you put a further container inside the \\<ul\\> (because only \\<li\\> elements are allowed inside \\<ul\\>s).\n\nTo handle this, you can use the *containerless control flow syntax*, which is based on comment tags. For example,\n\n``` markup\n<ul>\n    <li class=\"header\">Header item</li>\n    <!-- ko foreach: myItems -->\n        <li>Item <span data-bind=\"text: $data\"></span></li>\n    <!-- /ko -->\n</ul>\n\n<script type=\"text/javascript\">\n    ko.applyBindings({\n        myItems: [ 'A', 'B', 'C' ]\n    });\n</script>\n```\n\nThe \\<!-- ko --\\> and \\<!-- /ko --\\> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.\n\n### Note 5: How array changes are detected and handled\n\nWhen you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.\n\n- When you **add** array entries, foreach will render new copies of your template and insert them into the existing DOM\n- When you **delete** array entries, foreach will simply remove the corresponding DOM elements\n- When you **reorder** array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position\n\nNote that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect “simple” movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an “delete” plus an “add” instead of a single “move”, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won’t encounter this edge case, and even if you do, the end-user experience will usually be identical.\n\n### Note 6: Hiding destroyed entries\n\nSometimes you may want to mark an array entry as deleted without actually losing record of its existence. This is known as a *non-destructive delete*. For details of how to do this, see [the destroy function on observableArray](observablearrays#destroy-and-destroyall).\n\nBy default, the foreach binding will show all array entries, even those that are marked as destroyed. If you want to hide destroyed entries, set the includeDestroyed option to false. For example,\n\n``` markup\n<div data-bind='foreach: { data: myArray, includeDestroyed: false }'>\n    ...\n</div>\n```\n\nPrior to Knockout 3.5.0, the default behavior was to hide destroyed items. To use this behavior as the default in newer versions, you can set a global option: ko.options.foreachHidesDestroyed = true. Then, if you want to show destroyed items for a specific foreach binding, you would set includeDestroyed: true.\n\n### Note 7: Post-processing or animating the generated DOM elements\n\nIf you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below.\n\n> **Note:** These callbacks are *only* intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a [custom binding](custom-bindings) instead, because then you can use that behavior anywhere, independently of the foreach binding.\n\nHere’s a trivial example that uses afterAdd to apply the classic “yellow fade” effect to newly-added items. It requires the [jQuery Color plugin](https://github.com/jquery/jquery-color) to enable animation of background colors.\n\n``` markup\n<ul data-bind=\"foreach: { data: myItems, afterAdd: yellowFadeIn }\">\n    <li data-bind=\"text: $data\"></li>\n</ul>\n\n<button data-bind=\"click: addItem\">Add</button>\n\n<script type=\"text/javascript\">\n    ko.applyBindings({\n        myItems: ko.observableArray([ 'A', 'B', 'C' ]),\n        yellowFadeIn: function(element, index, data) {\n            $(element).filter(\"li\")\n                      .animate({ backgroundColor: 'yellow' }, 200)\n                      .animate({ backgroundColor: 'white' }, 800);\n        },\n        addItem: function() { this.myItems.push('New item'); }\n    });\n</script>\n```\n\nFull details:\n\n- afterRender — is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:\n\n  1.  An array of the inserted DOM elements\n  2.  The data item against which they are being bound\n\n- afterAdd — is like afterRender, except it is invoked only when new entries are added to your array (and *not* when foreach first iterates over your array’s initial contents). A common use for afterAdd is to call a method such as jQuery’s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:\n\n  1.  A DOM node being added to the document\n  2.  The index of the added array element\n  3.  The added array element\n\n- beforeRemove — is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then *it becomes your responsibility to remove the DOM nodes*. The obvious use case here is calling something like jQuery’s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes — in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:\n\n  1.  A DOM node that you should remove\n  2.  The index of the removed array element\n  3.  The removed array element\n\n- beforeMove — is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:\n\n  1.  A DOM node that may be about to move\n  2.  The index of the moved array element\n  3.  The moved array element\n\n- afterMove — is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:\n\n  1.  A DOM node that may have moved\n  2.  The index of the moved array element\n  3.  The moved array element\n\nFor examples of afterAdd and beforeRemove see [animated transitions](https://knockoutjs.com/examples/animatedTransitions.html).\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/foreach-binding.html](https://knockoutjs.com/documentation/foreach-binding.html)"
- name: hasFocus binding
  id: hasfocus-binding
  summary: The hasFocus binding links a DOM element’s focus state with a viewmodel property
  description: "# The \"hasFocus\" binding\n\n### Purpose\n\nThe hasFocus binding links a DOM element’s focus state with a viewmodel property. It is a two-way binding, so:\n\n- If you set the viewmodel property to true or false, the associated element will become focused or unfocused.\n- If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to true or false accordingly.\n\nThis is useful if you’re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.\n\n### Example 1: The basics\n\nThis example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<input data-bind=\"hasFocus: isSelected\" />\n<button data-bind=\"click: setIsSelected\">Focus programmatically</button>\n<span data-bind=\"visible: isSelected\">The textbox has focus</span>\n```\n\n#### Source code: View model\n\n``` js\nvar viewModel = {\n    isSelected: ko.observable(false),\n    setIsSelected: function() { this.isSelected(true) }\n};\nko.applyBindings(viewModel);\n```\n\n### Example 2: Click-to-edit\n\nBecause the hasFocus binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it’s a convenient way to toggle an “edit” mode. In this example, the UI displays either a \\<span\\> or an \\<input\\> element depending on the model’s editing property. Unfocusing the \\<input\\> element sets editing to false, so the UI switches out of “edit” mode.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<p>\n    Name: \n    <b data-bind=\"visible: !editing(), text: name, click: edit\">&nbsp;</b>\n    <input data-bind=\"visible: editing, value: name, hasFocus: editing\" />\n</p>\n<p><em>Click the name to edit it; click elsewhere to apply changes.</em></p>\n```\n\n#### Source code: View model\n\n``` js\nfunction PersonViewModel(name) {\n    // Data\n    this.name = ko.observable(name);\n    this.editing = ko.observable(false);\n        \n    // Behaviors\n    this.edit = function() { this.editing(true) }\n}\n\nko.applyBindings(new PersonViewModel(\"Bert Bertington\"));\n```\n\n### Parameters\n\n- Main parameter\n\n  Pass true (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.\n\n  When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.\n\n  If the value you supply is observable, the hasFocus binding will update the element’s focus state whenever that observable value changes.\n\n- Additional parameters\n\n  - None\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/hasfocus-binding.html](https://knockoutjs.com/documentation/hasfocus-binding.html)"
- name: How dependency tracking works
  id: computed-dependency-tracking
  summary: It’s actually very simple and rather lovely
  description: "# How dependency tracking works\n\n*Beginners don’t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI…*\n\nIt’s actually very simple and rather lovely. The tracking algorithm goes like this:\n\n1.  Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.\n2.  While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).\n3.  KO notifies any subscribers about the new value of your computed observable.\n\nSo, Knockout doesn’t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don’t have to declare dependencies: they’re determined at runtime from the code’s execution. If the evaluator doesn’t access any obsevables, the computed observable will have no dependencies and won’t ever need to call the evaluator function again. In that case, to save resources, the computed observable will be automatically “disposed.”\n\nThe other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.\n\n*Pure* computed observables work slightly differently. For more details, see the documentation for [*pure* computed observables](computed-pure).\n\n## Controlling dependencies using peek\n\nKnockout’s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The peek function lets you access an observable or computed observable without creating a dependency.\n\nIn the example below, a computed observable is used to reload an observable named currentPageData using Ajax with data from two other observable properties. The computed observable will update whenever pageIndex changes, but it ignores changes to selectedItem because it is accessed using peek. In this case, the user might want to use the current value of selectedItem only for tracking purposes when a new set of data is loaded.\n\n``` javascript\nko.computed(function() {\n    var params = {\n        page: this.pageIndex(),\n        selected: this.selectedItem.peek()\n    };\n    $.getJSON('/Some/Json/Service', params, this.currentPageData);\n}, this);\n```\n\nNote: If you just want to prevent a computed observable from updating too often, see the [rateLimit extender](ratelimit-observable).\n\n## Ignoring dependencies within a computed\n\nThe ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed’s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.\n\n``` javascript\nko.ignoreDependencies( callback, callbackTarget, callbackArgs );\n```\n\nExample:\n\n``` javascript\nko.bindingHandlers.myBinding = {\n    update: function(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {\n        var options = ko.unwrap(valueAccessor());\n        var value = ko.unwrap(options.value);\n        var afterUpdateHandler = options.afterUpdate;\n\n        // the developer supplied a function to call when this binding updates, but\n        // we don't really want to track any dependencies that would re-trigger this binding\n        if (typeof afterUpdateHandler === \"function\") {\n            ko.ignoreDependencies(afterUpdateHandler, viewModel, [value, color]);\n        }\n\n        $(element).somePlugin(\"value\", value);\n    }\n}\n```\n\n## Note: Why circular dependencies aren’t meaningful\n\nComputed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn’t make sense to include cycles in your dependency chains. Cycles would *not* be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.\n\nSo what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: **Knockout will not restart evaluation of a computed while it is already evaluating**. This is very unlikely to affect your code. It’s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the deferEvaluation option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the peek function described above.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/computed-dependency-tracking.html](https://knockoutjs.com/documentation/computed-dependency-tracking.html)"
- name: html binding
  id: html-binding
  summary: The html binding causes the associated DOM element to display the HTML specified by your parameter
  description: "# The \"html\" binding\n\n### Purpose\n\nThe html binding causes the associated DOM element to display the HTML specified by your parameter.\n\nTypically this is useful when values in your view model are actually strings of HTML markup that you want to render. If you know your view model value is plain text, use the more efficient [text binding](text-binding) instead.\n\n### Example\n\n``` markup\n<div data-bind=\"html: details\"></div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        details: ko.observable() // Initially blank\n    };\n    viewModel.details(\"<em>For further details, view the report <a href='report.html'>here</a>.</em>\"); // HTML content appears\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  KO clears the previous content and then sets the element’s content to your parameter value using jQuery’s html function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.\n\n  If this parameter is an observable value, the binding will update the element’s content whenever the value changes. If the parameter isn’t observable, it will only set the element’s content once and will not update it again later.\n\n  If you supply something other than a number or a string (e.g., you pass an object or an array), the innerHTML will be equivalent to yourParameter.toString()\n\n- Additional parameters\n\n  - None\n\n### Note: About HTML encoding\n\nSince this binding sets your element’s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user’s input that was stored in your database), then you can use [the text binding](text-binding), which will set the element’s text value instead.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/html-binding.html](https://knockoutjs.com/documentation/html-binding.html)"
- name: if and ifnot bindings
  id: if-binding
  summary: The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string)
  description: "# The \"if\" and \"ifnot\" bindings\n\n### Purpose\n\nThe if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).\n\nThe ifnot binding works just like the if binding, except that it inverts the result of whatever expression you pass to it.\n\nif (and ifnot) play a similar role to [the visible (and hidden) bindings](visible-binding). The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied—the visible binding just uses CSS to toggle the container element’s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.\n\n### Example 1\n\nThis example shows that the if binding can dynamically add and remove sections of markup as observable values change.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<label><input type=\"checkbox\" data-bind=\"checked: displayMessage\" /> Display message</label>\n\n<div data-bind=\"if: displayMessage\">Here is a message. Astonishing.</div>\n```\n\n#### Source code: View model\n\n``` js\nko.applyBindings({\n    displayMessage: ko.observable(false)\n});\n```\n\n### Example 2\n\nIn the following example, the \\<div\\> element will be empty for “Mercury”, but populated for “Earth”. That’s because Earth has a non-null capital property, whereas “Mercury” has null for that property.\n\n``` markup\n<ul data-bind=\"foreach: planets\">\n    <li>\n        Planet: <b data-bind=\"text: name\"> </b>\n        <div data-bind=\"if: capital\">\n            Capital: <b data-bind=\"text: capital.cityName\"> </b>\n        </div>\n    </li>\n</ul>\n\n\n<script>\n    ko.applyBindings({\n        planets: [\n            { name: 'Mercury', capital: null }, \n            { name: 'Earth', capital: { cityName: 'Barnsley' } }        \n        ]\n    });\n</script>\n```\n\nIt’s important to understand that the if binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate capital.cityName in the context of “Mercury” where capital is null. In JavaScript, you’re not allowed to evaluate subproperties of null or undefined values.\n\n### Parameters\n\n- Main parameter\n\n  The expression you wish to evaluate. For the if binding, if it evaluates to true (or a true-ish value), the contained markup will be present in the document, and any data-bind attributes on it will be applied; if your expression evaluates to false, the contained markup will be removed from your document without first applying any bindings to it. For the ifnot binding, the behavior is reversed.\n\n  If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if or ifnot block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to **a new copy of the contained markup** whenever it is re-added.\n\n- Additional parameters\n\n  - None\n\n### Note: Using “if” and “ifnot” without a container element\n\nSometimes you may want to control the presence/absence of a section of markup *without* having any container element that can hold an if or ifnot binding. For example, you might want to control whether a certain \\<li\\> element appears alongside siblings that always appear:\n\n``` markup\n<ul>\n    <li>This item always appears</li>\n    <li>I want to make this item present/absent dynamically</li>\n</ul>\n```\n\nIn this case, you can’t put if on the \\<ul\\> (because then it would affect the first \\<li\\> too), and you can’t put any other container around the second \\<li\\> (because HTML doesn’t allow extra containers within \\<ul\\>s).\n\nTo handle this, you can use the *containerless control flow syntax*, which is based on comment tags. For example,\n\n``` markup\n<ul>\n    <li>This item always appears</li>\n    <!-- ko if: someExpressionGoesHere -->\n        <li>I want to make this item present/absent dynamically</li>\n    <!-- /ko -->\n</ul>\n```\n\nThe \\<!-- ko --\\> and \\<!-- /ko --\\> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.\n\n### Note: “ifnot” is the same as a negated “if”\n\nThe following markup:\n\n``` markup\n<div data-bind=\"ifnot: someProperty\">...</div>\n```\n\n… is equivalent to the following:\n\n``` markup\n<div data-bind=\"if: !someProperty()\">...</div>\n```\n\n… assuming that someProperty is *observable* and hence you need to invoke it as a function to obtain the current value.\n\nThe main reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/if-binding.html](https://knockoutjs.com/documentation/if-binding.html)"
- name: JSON data
  id: json-data
  summary: Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage
  description: "# Loading and Saving JSON data\n\nKnockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in [JSON format](http://json.org/) - the format that the majority of Ajax applications use today.\n\n### Loading or Saving Data\n\nKnockout doesn’t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery’s Ajax helper methods, such as [getJSON](http://api.jquery.com/jQuery.getJSON/), [post](http://api.jquery.com/jQuery.post/), and [ajax](http://api.jquery.com/jQuery.ajax/). You can fetch data from the server:\n\n``` javascript\n$.getJSON(\"/some/url\", function(data) { \n    // Now use this data to update your view models, \n    // and Knockout will update your UI automatically \n})\n```\n\n… or you can send data to the server:\n\n``` javascript\nvar data = /* Your data in JSON format - see below */;\n$.post(\"/some/url\", data, function(returnedData) {\n    // This callback is executed if the post was successful     \n})\n```\n\nOr, if you don’t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:\n\n- For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques\n- For loading, update your view model using data that you’ve received using one of the above techniques\n\n### Converting View Model Data to Plain JSON\n\nYour view models *are* JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as [JSON.stringify](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify) (a native function in modern browsers), or the [json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js) library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won’t always serialize cleanly without additional work on your behalf.\n\nTo make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:\n\n- ko.toJS — this clones your view model’s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts\n- ko.toJSON — this produces a JSON string representing your view model’s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser’s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the [json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js) library.\n\nFor example, define a view model as follows:\n\n``` javascript\nvar viewModel = {\n    firstName : ko.observable(\"Bert\"),\n    lastName : ko.observable(\"Smith\"),\n    pets : ko.observableArray([\"Cat\", \"Dog\", \"Fish\"]),\n    type : \"Customer\"\n};\nviewModel.hasALotOfPets = ko.computed(function() {\n    return this.pets().length > 2\n}, viewModel)\n```\n\nThis contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:\n\n``` javascript\nvar jsonData = ko.toJSON(viewModel);\n\n// Result: jsonData is now a string equal to the following value\n// '{\"firstName\":\"Bert\",\"lastName\":\"Smith\",\"pets\":[\"Cat\",\"Dog\",\"Fish\"],\"type\":\"Customer\",\"hasALotOfPets\":true}'\n```\n\nOr, if you just want the plain JavaScript object graph *before* serialization, use ko.toJS as follows:\n\n``` javascript\nvar plainJs = ko.toJS(viewModel);\n\n// Result: plainJS is now a plain JavaScript object in which nothing is observable. It's just data.\n// The object is equivalent to the following:\n//   {\n//      firstName: \"Bert\",\n//      lastName: \"Smith\",\n//      pets: [\"Cat\",\"Dog\",\"Fish\"],\n//      type: \"Customer\",\n//      hasALotOfPets: true\n//   }\n```\n\nNote that ko.toJSON accepts the same arguments as [JSON.stringify](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify). For example, it can be useful to have a “live” representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the *spaces* argument into ko.toJSON and bind against your view model like:\n\n``` markup\n<pre data-bind=\"text: ko.toJSON($root, null, 2)\"></pre>\n```\n\n### Updating View Model Data using JSON\n\nIf you’ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,\n\n``` javascript\n// Load and parse the JSON\nvar someJSON = /* Omitted: fetch it from the server however you want */;\nvar parsed = JSON.parse(someJSON);\n\n// Update view model properties\nviewModel.firstName(parsed.firstName);\nviewModel.pets(parsed.pets);\n```\n\nIn many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.\n\nHowever, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see [the knockout.mapping plugin](plugins-mapping).\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/json-data.html](https://knockoutjs.com/documentation/json-data.html)"
- name: let binding
  id: let-binding
  summary: The let binding lets you set custom binding context properties that you can then reference in the bindings of all descendant elements
  description: "# The \"let\" binding\n\n### Purpose\n\nThe let binding lets you set custom [binding context](binding-context) properties that you can then reference in the bindings of all descendant elements.\n\n### Example\n\nHere is a basic example of setting values using let that are then available in all descendant elements, regardless of context changes.\n\n``` markup\n<!--ko let: {inventory: {suppliers: suppliers, bins: bins}, calculatedDisplay: someCalculation}-->\n    <div data-bind=\"foreach: {data: inventory.suppliers, as: 'supplier'}>\n        <div data-bind=\"foreach: {data: inventory.bins, as: 'bin'}\">\n            <span data-bind=\"text: calculatedDisplay(supplier, bin)>\n        </div>\n    </div>\n<!--/ko-->\n\n<script type=\"text/javascript\">\n    ko.applyBindings({\n        suppliers: [...],\n        bins: [...],\n        someCalculation: function (supplier, bin) {\n            /* return some calculated value based on parameters */\n        }\n    });\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  A JavaScript object whose properties will be copied to the binding context for descendant elements.\n\n  If the expression you supply unwraps any observable values, the expression will be re-evaluated whenever any of those observables change. Additionally, the bindings for all descendant elements will be re-evaluated as well.\n\n- Additional parameters\n\n  - None\n\n### Note 1: Using “let” without a container element\n\nJust like other control flow bindings, you can use let without any container element to host it. See the documentation for [if](if-binding) or [foreach](foreach-binding) for more details.\n\n### Note 2: Performance considerations when using “let”\n\nIf the expression you provide to the let binding unwraps any observables, each descendant binding will include an additional dependency on the let binding. This is true whether or not the binding references any of the custom context properties. If you want to make an observable value available through let, it is generally better to set the observable itself rather than unwrap it and set the value.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/let-binding.html](https://knockoutjs.com/documentation/let-binding.html)"
- name: Mapping
  id: plugins-mapping
  summary: Knockout is designed to allow you to use arbitrary JavaScript objects as view models
  description: "# Mapping\n\nKnockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model’s properties are [observables](observables), you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.\n\nMost applications need to fetch data from a backend server. Since the server doesn’t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you’ve fetched from the server.\n\n### Download\n\n- **[Version 2.0](https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output)** (8.6kb minified)\n\n### Example: Manual mapping without the ko.mapping plugin\n\nYou want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:\n\n``` javascript\nvar viewModel = {\n    serverTime: ko.observable(),\n    numUsers: ko.observable()\n}\n```\n\nYou could bind this view model to some HTML elements as follows:\n\n``` javascript\nThe time on the server is: <span data-bind='text: serverTime'></span>\nand <span data-bind='text: numUsers'></span> user(s) are connected.\n```\n\nSince the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.\n\nNext, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery’s $.getJSON or $.ajax functions):\n\n``` javascript\nvar data = getDataUsingAjax();          // Gets the data from the server\n```\n\nThe server might return JSON data similar to the following:\n\n``` javascript\n{\n    serverTime: '2010-01-07',\n    numUsers: 3\n}\n```\n\nFinally, to update your view model using this data (without using the mapping plugin), you would write:\n\n``` javascript\n// Every time data is received from the server:\nviewModel.serverTime(data.serverTime);\nviewModel.numUsers(data.numUsers);\n```\n\nYou would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.\n\n### Example: Using ko.mapping\n\nTo create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:\n\n``` javascript\nvar viewModel = ko.mapping.fromJS(data);\n```\n\nThis automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:\n\n``` javascript\n// Every time data is received from the server:\nko.mapping.fromJS(data, viewModel);\n```\n\n### How things are mapped\n\n- All properties of an object are converted into an observable. If an update would change the value, it will update the observable.\n- Arrays are converted into [observable arrays](observablearrays). If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.\n\n### Unmapping\n\nIf you want to convert your mapped object back to a regular JS object, use:\n\n``` javascript\nvar unmapped = ko.mapping.toJS(viewModel);\n```\n\nThis will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the \\_destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the “Advanced Usage” section for more details on how to configure this.\n\n### Working with JSON strings\n\nIf your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function ko.mapping.fromJSON to create and update your view model instead. To unmap, you can use ko.mapping.toJSON.\n\nApart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their \\*JS counterparts.\n\n### Advanced usage\n\nSometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using *mapping options*. They can be specified during the ko.mapping.fromJS call. In subsequent calls you don’t need to specify them again.\n\nHere a few situations in which you might want to use these mapping options.\n\n###### Uniquely identifying objects using “keys”\n\nLet’s say you have a JavaScript object that looks like this:\n\n``` javascript\nvar data = {\n    name: 'Scot',\n    children: [\n        { id : 1, name : 'Alicw' }\n    ]\n}\n```\n\nYou can map this to a view model without any problems:\n\n``` javascript\nvar viewModel = ko.mapping.fromJS(data);\n```\n\nNow, let’s say the data is updated to be without any typos:\n\n``` javascript\nvar data = {\n    name: 'Scott',\n    children: [\n        { id : 1, name : 'Alice' }\n    ]\n}\n```\n\nTwo things have happened here: name was changed from Scot to Scott and children\\[0\\].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:\n\n``` javascript\nko.mapping.fromJS(data, viewModel);\n```\n\nAnd name would have changed as expected. However, in the children array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the name property of the child was updated from Alicw to Alice, not that the entire child was replaced!\n\nThis happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object { id : 1, name : 'Alicw' } does not equal { id : 1, name : 'Alice' } it thinks that the *entire* child needs to be removed and replaced by a new one.\n\nTo solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:\n\n``` javascript\nvar mapping = {\n    'children': {\n        key: function(data) {\n            return ko.utils.unwrapObservable(data.id);\n        }\n    }\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n```\n\nThis way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.\n\n###### Customizing object construction using “create”\n\nIf you want to handle a part of the mapping yourself, you can also provide a create callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.\n\nLet’s say you have a JavaScript object that looks like this:\n\n``` javascript\nvar data = {\n    name: 'Graham',\n    children: [\n        { id : 1, name : 'Lisa' }\n    ]\n}\n```\n\nIf you want to map the children array yourself, you can specify that like this:\n\n``` javascript\nvar mapping = {\n    'children': {\n        create: function(options) {\n            return new myChildModel(options.data);\n        }\n    }\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n```\n\nThe options argument supplied to your create callback is a JavaScript object containing:\n\n- data: The JavaScript object containing the data for this child\n- parent: The parent object or array to which this child belongs\n\nOf course, inside the create callback you can do another call to ko.mapping.fromJS if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional [computed observables](computedobservables):\n\n``` javascript\nvar myChildModel = function(data) {\n    ko.mapping.fromJS(data, {}, this);\n    \n    this.nameLength = ko.computed(function() {\n        return this.name().length;\n    }, this);\n}\n```\n\n###### Customizing object updating using “update”\n\nYou can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.\n\nThe options argument supplied to your update callback is a JavaScript object containing:\n\n- data: The JavaScript object containing the data for this child\n- parent: The parent object or array to which this child belongs\n- observable: If the property is an observable, this will be set to the actual observable\n\nHere is an example of a configuration that will add some text to the incoming data before updating:\n\n``` javascript\nvar data = {\n    name: 'Graham',\n}\n\nvar mapping = {\n    'name': {\n        update: function(options) {\n            return options.data + 'foo!';\n        }\n    }\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\nalert(viewModel.name());\n```\n\nThis will alert Grahamfoo!.\n\n###### Ignoring certain properties using “ignore”\n\nIf you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:\n\n``` javascript\nvar mapping = {\n    'ignore': [\"propertyToIgnore\", \"alsoIgnoreThis\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n```\n\nThe ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:\n\n``` javascript\nvar oldOptions = ko.mapping.defaultOptions().ignore;\nko.mapping.defaultOptions().ignore = [\"alwaysIgnoreThis\"];\n```\n\n###### Including certain properties using “include”\n\nWhen converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated \\_destroy property even if it was not part of your original object. However, you can choose to customize this array:\n\n``` javascript\nvar mapping = {\n    'include': [\"propertyToInclude\", \"alsoIncludeThis\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n```\n\nThe include array you specify in the mapping options is combined with the default include array, which by default only contains \\_destroy. You can manipulate this default array like this:\n\n``` javascript\nvar oldOptions = ko.mapping.defaultOptions().include;\nko.mapping.defaultOptions().include = [\"alwaysIncludeThis\"];\n```\n\n###### Copying certain properties using “copy”\n\nWhen converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained [above](#how-things-are-mapped). If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the “copy” array:\n\n``` javascript\nvar mapping = {\n    'copy': [\"propertyToCopy\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n```\n\nThe copy array you specify in the mapping options is combined with the default copy array, which by default is empty. You can manipulate this default array like this:\n\n``` javascript\nvar oldOptions = ko.mapping.defaultOptions().copy;\nko.mapping.defaultOptions().copy = [\"alwaysCopyThis\"];\n```\n\n###### Observing only certain properties using “observe”\n\nIf you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:\n\n``` javascript\nvar mapping = {\n    'observe': [\"propertyToObserve\"]\n}\nvar viewModel = ko.mapping.fromJS(data, mapping);\n```\n\nThe observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:\n\n``` javascript\nvar oldOptions = ko.mapping.defaultOptions().observe;\nko.mapping.defaultOptions().observe = [\"onlyObserveThis\"];\n```\n\nThe arrays ignore and include still work as normal. The array copy can be used for efficiency to copy array or object properties including children. If an array or object property is not specified in copy or observe then it is recursively mapped:\n\n``` javascript\nvar data = {\n    a: \"a\",\n    b: [{ b1: \"v1\" }, { b2: \"v2\" }] \n};\n\nvar result = ko.mapping.fromJS(data, { observe: \"a\" });\nvar result2 = ko.mapping.fromJS(data, { observe: \"a\", copy: \"b\" }); //will be faster to map.\n```\n\nBoth result and result2 will be:\n\n``` javascript\n{\n    a: observable(\"a\"),\n    b: [{ b1: \"v1\" }, { b2: \"v2\" }] \n}\n```\n\nDrilling down into arrays/objects works but copy and observe can conflict:\n\n``` javascript\nvar data = {\n    a: \"a\",\n    b: [{ b1: \"v1\" }, { b2: \"v2\" }] \n};\nvar result = ko.mapping.fromJS(data, { observe: \"b[0].b1\"});\nvar result2 = ko.mapping.fromJS(data, { observe: \"b[0].b1\", copy: \"b\" });\n```\n\nThe result will be:\n\n``` javascript\n{\n    a: \"a\",\n    b: [{ b1: observable(\"v1\") }, { b2: \"v2\" }] \n}\n```\n\nWhile result2 will be:\n\n``` javascript\n{\n    a: \"a\",\n    b: [{ b1: \"v1\" }, { b2: \"v2\" }] \n}\n```\n\n###### Specifying the update target\n\nIf, like in the example above, you are performing the mapping inside of a class, you would like to have this as the target of your mapping operation. The third parameter to ko.mapping.fromJS indicates the target. For example,\n\n``` javascript\nko.mapping.fromJS(data, {}, someObject); // overwrites properties on someObject\n```\n\nSo, if you would like to map a JavaScript object to this, you can pass this as the third argument:\n\n``` javascript\nko.mapping.fromJS(data, {}, this);\n```\n\n##### Mapping from multiple sources\n\nYou can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:\n\n``` javascript\nvar viewModel = ko.mapping.fromJS(alice, aliceMappingOptions);\nko.mapping.fromJS(bob, bobMappingOptions, viewModel);\n```\n\nMapping options that you specify in each call will be merged.\n\n##### Mapped observable array\n\nObservable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the keys mapping:\n\n- mappedRemove\n- mappedRemoveAll\n- mappedDestroy\n- mappedDestroyAll\n- mappedIndexOf\n\nThey are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:\n\n``` javascript\nvar obj = [\n    { id : 1 },\n    { id : 2 }\n]\n\nvar result = ko.mapping.fromJS(obj, {\n    key: function(item) {\n        return ko.utils.unwrapObservable(item.id);\n    }\n});\n\nresult.mappedRemove({ id : 2 });\n```\n\nThe mapped observable array also exposes a mappedCreate function:\n\n``` javascript\nvar newItem = result.mappedCreate({ id : 3 });\n```\n\nIt will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.\n\n### Download\n\n- **[Version 2.0](https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output)** (8.6kb minified)\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/plugins-mapping.html](https://knockoutjs.com/documentation/plugins-mapping.html)"
- name: Microtasks
  id: microtasks
  summary: 'Note: This documentation applies to Knockout 3.4.0 and later'
  description: "# Microtasks\n\n*Note: This documentation applies to Knockout 3.4.0 and later.*\n\n## Knockout’s microtask queue\n\nKnockout’s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for [Knockout components](component-overview) to maintain asynchronous behavior, and for scheduling [deferred updates](deferred-updates) for observables.\n\n``` javascript\nko.tasks.schedule(function () {\n    // ...\n});\n```\n\nThis will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the [browser’s microtask](#implementation) support if possible. This ensures that the first task and subsequent tasks behave similarly.\n\nMicrotasks can be canceled using the *handle* value returned from ko.tasks.schedule. If the task has already run or was previously canceled, cancel does nothing.\n\n``` javascript\nvar handle = ko.tasks.schedule(/* ... */);\nko.tasks.cancel(handle);\n```\n\n### Error handling\n\nIf a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using [ko.onError](asynchronous-error-handling) or window.onerror.\n\n### Recursive task limit\n\nSince Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:\n\n``` javascript\nfunction loop() {\n    ko.tasks.schedule(loop);\n}\nloop();\n```\n\n### Implementation\n\nWhen the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers’s own microtask capabilities. In modern browsers, it will use a [DOM mutation observer](http://dom.spec.whatwg.org/#mutation-observers), and in older versions of Internet Explorer, it will use a \\<script\\> onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.\n\n### Advanced queue control\n\nKnockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout’s microtask system with another library or add support for additional environments.\n\n- ko.tasks.runEarly() — Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.\n\n- ko.tasks.scheduler — Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/microtasks.html](https://knockoutjs.com/documentation/microtasks.html)"
- name: Observable arrays
  id: observablearrays
  summary: If you want to detect and respond to changes on one object, you’d use observables
  description: "# Observable Arrays\n\nIf you want to detect and respond to changes on one object, you’d use [observables](observables). If you want to detect and respond to changes of a *collection of things*, use an observableArray. This is useful in many scenarios where you’re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.\n\n### Example\n\n``` javascript\nvar myObservableArray = ko.observableArray();    // Initially an empty array\nmyObservableArray.push('Some value');            // Adds the value and notifies observers\n```\n\nTo see how you can bind the observableArray to a UI and let the user modify it, see [the simple list example](https://knockoutjs.com/examples/simpleList.html).\n\n### Key point: An observableArray tracks which objects are *in* the array, *not* the state of those objects\n\nSimply putting an object into an observableArray doesn’t make all of that object’s properties themselves observable. Of course, you can make those properties observable if you wish, but that’s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.\n\n## Prepopulating an observableArray\n\nIf you want your observable array **not** to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,\n\n``` javascript\n// This observable array initially contains three objects\nvar anotherObservableArray = ko.observableArray([\n    { name: \"Bungle\", type: \"Bear\" },\n    { name: \"George\", type: \"Hippo\" },\n    { name: \"Zippy\", type: \"Unknown\" }\n]);\n```\n\n## Reading information from an observableArray\n\nBehind the scenes, an observableArray is actually an [observable](observables) whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,\n\n``` javascript\nalert('The length of the array is ' + myObservableArray().length);\nalert('The first element is ' + myObservableArray()[0]);\n```\n\nTechnically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there’s a better alternative. KO’s observableArray has equivalent functions of its own, and they’re more useful because:\n\n1.  They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn’t work on IE 8 or earlier, but KO’s indexOf works everywhere.)\n2.  For functions that modify the contents of the array, such as push and splice, KO’s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated which means there is a significant difference between using KO’s methods (i.e., observableArray.push(...) ) and JavaScript native array methods (i.e., observableArray().push(...)) as the latter don’t send any notification to the array’s subscribers that its content has changed.\n\nThe rest of this page describes observableArray’s functions for reading and writing array information.\n\n### indexOf\n\nThe indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.\n\n### slice\n\nThe slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).\n\n## Manipulating an observableArray\n\nobservableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.\n\n### pop, push, shift, unshift, reverse, sort, splice\n\nAll of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:\n\n- push( value ) — Adds a new item to the end of array.\n- pop() — Removes the last value from the array and returns it.\n- unshift( value ) — Inserts a new item at the beginning of the array.\n- shift() — Removes the first value from the array and returns it.\n- reverse() — Reverses the order of the array and returns the observableArray (not the underlying array).\n- sort() — Sorts the array contents and returns the observableArray. The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. See the example under sorted below.\n- splice() — Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.\n\nFor more details about these observableArray functions, see the equivalent documentation of the [standard JavaScript array functions](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2).\n\n### sorted and reversed\n\n- sorted() — Returns a sorted **copy** of the array. This is preferable to sort if you want to leave the observable array in its original order but need to display it in a specific order.\n\n  The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of ‘person’ objects by last name, you could write:\n\n  ``` javascript\n  var mySortedArray = ko.pureComputed(function () {\n      return myObservableArray.sorted(function (left, right) {\n          return left.lastName === right.lastName ? 0\n               : left.lastName < right.lastName ? -1\n               : 1;\n      });\n  });\n  ```\n\n- reversed() — Returns a reversed **copy** of the array.\n\n### replace, remove and removeAll\n\nobservableArray adds some more useful methods that aren’t found on JavaScript arrays by default:\n\n- replace( oldItem, newItem ) — Replaces the first value that equals oldItem with newItem.\n- remove( someItem ) — Removes all values that equal someItem and returns them as an array.\n- remove( function (item) { return item.age \\< 18; } ) — Removes all values whose age property is less than 18, and returns them as an array.\n- removeAll( \\['Chad', 132, undefined\\] ) — Removes all values that equal 'Chad', 123, or undefined and returns them as an array.\n- removeAll() — Removes all values and returns them as an array.\n\n### destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)\n\nThe destroy and destroyAll functions are mainly intended as a convenience for developers using Ruby on Rails:\n\n- destroy( someItem ) — Finds any objects in the array that equal someItem and gives them a special property called \\_destroy with value true.\n- destroy( function (someItem) { return someItem.age \\< 18; } ) — Finds any objects in the array whose age property is less than 18, and gives those objects a special property called \\_destroy with value true.\n- destroyAll( \\['Chad', 132, undefined\\] ) — Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called \\_destroy with value true.\n- destroyAll() — Gives a special property called \\_destroy with value true to all objects in the array.\n\nSo, what’s this \\_destroy thing all about? It’s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with \\_destroy set to true.\n\nWhen Knockout renders a foreach binding with the parameter includeDestroyed: false set, it will hide any objects marked with \\_destroy equal to true. So, you can have some kind of “delete” button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).\n\n## Determining if a property is an observableArray\n\nIn some scenarios, it is useful to programmatically determine if you are dealing with an observableArray. Knockout provides a utility function, ko.isObservableArray to help with this situation.\n\n## Delaying and/or suppressing change notifications\n\nNormally, an observableArray notifies its subscribers immediately, as soon as it’s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the [rateLimit extender](ratelimit-observable) like this:\n\n``` javascript\n// Ensure it notifies about changes no more than once per 50-millisecond period\nmyViewModel.myObservableArray.extend({ rateLimit: 50 });\n```\n\n## Tracking array changes\n\nAlthough you can subscribe to and access an observableArray just like any other observable, Knockout also provides a super-fast method to find out how an observable array has changed (i.e., which items were just added, deleted, or moved). You subscribe to array changes as follows:\n\n``` javascript\nobsArray.subscribe(fn, thisArg, \"arrayChange\");\n```\n\nThe main advantages of subscribing to changes:\n\n- Performance is O(1) in most cases, i.e., there’s basically no performance implication at all, because for straightforward operations, (push, splice, etc.) Knockout supplies the change log without running any difference algorithm. Knockout only falls back on an algorithm if you’ve made an arbitrary change without using a typical array mutation function.\n\n- The change log just gives you the items that actually changed.\n\nHere are examples of how the changes are reported:\n\n``` javascript\nvar myArray = ko.observableArray([\"Alpha\", \"Beta\", \"Gamma\"]);\n\nmyArray.push(\"Delta\");\n// Changes: [{ index: 3, status: 'added', value: 'Delta' }]\n// New value: [\"Alpha\", \"Beta\", \"Gamma\", \"Delta\"]\n\nmyArray.pop();\n// Changes: [{ index: 3, status: 'deleted', value: 'Delta' }]\n// New value: [\"Alpha\", \"Beta\", \"Gamma\"]\n\nmyArray.splice(1, 2, \"Omega\");\n// Changes:\n// [{ index: 1, status: 'deleted', value: 'Beta' },\n//  { index: 1, status: 'added', value: 'Omega' },\n//  { index: 2, status: 'deleted', value: 'Gamma' }]\n// New value: [\"Alpha\", \"Omega\"]\n\nmyArray.reverse();\n// Changes:\n// [{ index: 0, moved: 1, status: 'deleted', value: 'Alpha' },\n//  { index: 1, moved: 0, status: 'added', value: 'Alpha' }]\n// New value: [\"Omega\", \"Alpha\"]\n```\n\nAs shown above, the changes are reported as a list of *added* and *deleted* values. The indexes for *deleted* items refer to the original array, and the indexes for *added* items refer to the new array.\n\nWhen items are re-ordered, as shown in the last example above, you will also get *moved* information. You can choose to ignore the *moved* information and just interpret it as the original Alpha being deleted and a different Alpha being added to the array’s end. Or you can recognize that the *moved* information tells you that you can think of the *added* and *deleted* values being the same item that just changes position (by matching up the indexes).\n\nAn observableArray has array tracking enabled at construction, but you can extend any other subscribable (i.e. ko.observable and ko.computed) as follows:\n\n``` javascript\ntrackable = ko.observable().extend({trackArrayChanges: true});\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/observableArrays.html](https://knockoutjs.com/documentation/observableArrays.html)"
- name: Observables
  id: observables
  summary: On this page, you’ll learn about the first of these three
  description: "# Observables\n\nKnockout is built around three core features:\n\n1.  Observables and dependency tracking\n2.  Declarative bindings\n3.  Templating\n\nOn this page, you’ll learn about the first of these three. But before that, let’s examine the MVVM pattern and the concept of a *view model*.\n\n## MVVM and View Models\n\n*Model-View-View Model (MVVM)* is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:\n\n- A *model*: your application’s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.\n\n- A *view model*: a pure-code representation of the data and operations on a UI. For example, if you’re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.\n\n  Note that this is not the UI itself: it doesn’t have any concept of buttons or display styles. It’s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.\n\n- A *view*: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.\n\n  When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.\n\nTo create a view model with KO, just declare any JavaScript object. For example,\n\n``` javascript\nvar myViewModel = {\n    personName: 'Bob',\n    personAge: 123\n};\n```\n\nYou can then create a very simple *view* of this view model using a declarative binding. For example, the following markup displays the personName value:\n\n``` markup\nThe name is <span data-bind=\"text: personName\"></span>\n```\n\n## Activating Knockout\n\nThe data-bind attribute isn’t native to HTML, though it is perfectly OK (it’s strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it’s an unrecognized attribute). But since the browser doesn’t know what it means, you need to activate Knockout to make it take effect.\n\nTo activate Knockout, add the following line to a \\<script\\> block:\n\n``` javascript\nko.applyBindings(myViewModel);\n```\n\nYou can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as [jQuery’s $ function](http://api.jquery.com/jQuery/#jQuery3).\n\nThat does it! Now, your view will display as if you’d written the following HTML:\n\n``` javascript\nThe name is <span>Bob</span>\n```\n\nIn case you’re wondering what the parameters to ko.applyBindings do,\n\n- The first parameter says what view model object you want to use with the declarative bindings it activates\n\n- Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.\n\nPretty simple, really.\n\n## Observables\n\nOK, you’ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as *observables*, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.\n\nFor example, rewrite the preceding view model object as follows:\n\n``` javascript\nvar myViewModel = {\n    personName: ko.observable('Bob'),\n    personAge: ko.observable(123)\n};\n```\n\nYou don’t have to change the view at all - the same data-bind syntax will keep working. The difference is that it’s now capable of detecting changes, and when it does, it will update the view automatically.\n\n## Reading and writing observables\n\nNot all browsers support JavaScript getters and setters (\\* cough \\* IE \\* cough \\*), so for compatibility, ko.observable objects are actually *functions*.\n\n- To **read** the observable’s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.\n\n- To **write** a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.\n\n- To write values to **multiple observable properties** on a model object, you can use *chaining syntax*. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' *and* the age value to 50.\n\nThe whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That’s what many of KO’s built-in bindings do internally. So, when you wrote data-bind=\"text: personName\", the text binding registered itself to be notified when personName changes (assuming it’s an observable value, which it is now).\n\nWhen you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That’s how changes to the view model automatically propagate to the view.\n\n## Explicitly subscribing to observables\n\n*You won’t normally need to set up subscriptions manually, so beginners should skip this section.*\n\nFor advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:\n\n``` javascript\nmyViewModel.personName.subscribe(function(newValue) {\n    alert(\"The person's new name is \" + newValue);\n});\n```\n\nThe subscribe function is how many parts of KO work internally. Most of the time you don’t need to use this, because the built-in bindings and templating system take care of managing subscriptions.\n\nThe subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is \"change\") is the name of the event to receive notification for.\n\nYou can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:\n\n``` javascript\nvar subscription = myViewModel.personName.subscribe(function(newValue) { /* do stuff */ });\n// ...then later...\nsubscription.dispose(); // I no longer want notifications\n```\n\nIf you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:\n\n``` javascript\nmyViewModel.personName.subscribe(function(oldValue) {\n    alert(\"The person's previous name is \" + oldValue);\n}, null, \"beforeChange\");\n```\n\nNote: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it’s up to you to use a subscription to capture and track it.\n\n## Reacting to a specific observable event with “ko.when”\n\n*This advanced technique for working with observables was added in Knockout 3.5.*\n\nSometimes, rather than reacting to every change to an observable, you just need to know when the observable arrives at a specific value. This is what ko.when makes easy. For example:\n\n``` javascript\nko.when(function () {\n    return myViewModel.personName() !== undefined;\n}, function (result) {\n    myViewModel.isInitialized(true);\n});\n```\n\nko.when waits until the first function (predicate) returns true or a true-ish value, at which time it runs the second function (callback), passing the predicate result. You can optionally pass in a third parameter (context) that defines the value of this for the predicate and callback functions. ko.when returns a subscription object that you can use the cancel the action.\n\nko.when can also be called with just the predicate function. In that case, it returns a Promise that will be resolved with the predicate result once the predicate returns a true-ish value.\n\n## Forcing observables to always notify subscribers\n\nWhen writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify [extender](extenders) to ensure that an observable’s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:\n\n``` javascript\nmyViewModel.personName.extend({ notify: 'always' });\n```\n\n## Delaying and/or suppressing change notifications\n\nNormally, an observable notifies its subscribers immediately, as soon as it’s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable’s change notifications. This is accomplished using the [rateLimit extender](ratelimit-observable) like this:\n\n``` javascript\n// Ensure it notifies about changes no more than once per 50-millisecond period\nmyViewModel.personName.extend({ rateLimit: 50 });\n```\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/observables.html](https://knockoutjs.com/documentation/observables.html)"
- name: options binding
  id: options-binding
  summary: The options binding controls what options should appear in a drop-down list (i.e., a <select> element) or multi-select list (e.g., <select size='6'>)
  description: "# The \"options\" binding\n\n### Purpose\n\nThe options binding controls what options should appear in a drop-down list (i.e., a \\<select\\> element) or multi-select list (e.g., \\<select size='6'\\>). This binding cannot be used with anything other than \\<select\\> elements.\n\nThe value you assign should be an array (or observable array). The \\<select\\> element will then display one item for each item in your array.\n\nNote: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use [the selectedOptions binding](selectedoptions-binding). For a single-select list, you can also read and write the selected option using [the value binding](value-binding).\n\n### Example 1: Drop-down list\n\n``` markup\n<p>\n    Destination country:\n    <select data-bind=\"options: availableCountries\"></select>\n</p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        // These are the initial options\n        availableCountries: ko.observableArray(['France', 'Germany', 'Spain'])\n    };\n\n    // ... then later ...\n    viewModel.availableCountries.push('China'); // Adds another option\n</script>\n```\n\n### Example 2: Multi-select list\n\n``` markup\n<p>\n    Choose some countries you would like to visit:\n    <select data-bind=\"options: availableCountries\" size=\"5\" multiple=\"true\"></select>\n</p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        availableCountries: ko.observableArray(['France', 'Germany', 'Spain'])\n    };\n</script>\n```\n\n### Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings\n\n``` markup\n<p>\n    Your country:\n    <select data-bind=\"options: availableCountries,\n                       optionsText: 'countryName',\n                       value: selectedCountry,\n                       optionsCaption: 'Choose...'\"></select>\n</p>\n\n<div data-bind=\"visible: selectedCountry\"> <!-- Appears when you select something -->\n    You have chosen a country with population\n    <span data-bind=\"text: selectedCountry() ? selectedCountry().countryPopulation : 'unknown'\"></span>.\n</div>\n\n<script type=\"text/javascript\">\n    // Constructor for an object with two properties\n    var Country = function(name, population) {\n        this.countryName = name;\n        this.countryPopulation = population;\n    };\n\n    var viewModel = {\n        availableCountries : ko.observableArray([\n            new Country(\"UK\", 65000000),\n            new Country(\"USA\", 320000000),\n            new Country(\"Sweden\", 29000000)\n        ]),\n        selectedCountry : ko.observable() // Nothing selected by default\n    };\n</script>\n```\n\n### Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item\n\n``` markup\n<!-- Same as example 3, except the <select> box expressed as follows: -->\n<select data-bind=\"options: availableCountries,\n                   optionsText: function(item) {\n                       return item.countryName + ' (pop: ' + item.countryPopulation + ')'\n                   },\n                   value: selectedCountry,\n                   optionsCaption: 'Choose...'\"></select>\n```\n\nNote that the only difference between examples 3 and 4 is the optionsText value.\n\n### Parameters\n\n- Main parameter\n\n  You should supply an array (or observable array). For each item, KO will add an \\<option\\> to the associated \\<select\\> node. Any previous options will be removed.\n\n  If your parameter’s value is an array of strings, you don’t need to give any other parameters. The \\<select\\> element will display an option for each string value. However, if you want to let the user choose from an array of *arbitrary JavaScript objects* (not merely strings), then see the optionsText and optionsValue parameters below.\n\n  If this parameter is an observable value, the binding will update the element’s available options whenever the value changes. If the parameter isn’t observable, it will only set the element’s available options once and will not update them again later.\n\n- Additional parameters\n\n  - optionsCaption\n\n    Sometimes, you might not want to select any particular option by default. But a single-select drop-down list usually starts with some item selected, so how can you avoid preselecting something? The usual solution is to prefix the list of options with a special dummy option that just reads “Select an item” or “Please choose an option” or similar, and have that one selected by default.\n\n    This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:\n\n    \\<select data-bind='options: myOptions, optionsCaption: \"Select an item...\", value: myChosenValue'\\>\\</select\\>\n\n    KO will prefix the list of items with one that displays the text “Select an item…” and has the value undefined. So, if myChosenValue holds the value undefined (which observables do by default), then the dummy option will be selected. If the optionsCaption parameter is an observable, then the text of the initial item will update as the observable’s value changes.\n\n  - optionsText\n\n    See Example 3 above to see how you can bind options to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects’ properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called optionsText.\n\n    If you don’t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the optionsText option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.\n\n  - optionsValue\n\n    Similar to optionsText, you can also pass an additional parameter called optionsValue to specify which of the objects’ properties should be used to set the value attribute on the \\<option\\> elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the \\<option\\> element’s value attribute.\n\n    Typically you’d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you’re repeatedly getting a list of “car” objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to \"carId\" or whatever unique identifier each “car” object has, otherwise KO won’t necessarily know which of the previous “car” objects corresponds to which of the new ones.\n\n  - optionsIncludeDestroyed\n\n    Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see [the destroy function on observableArray](observablearrays#destroy-and-destroyall).\n\n    By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:\n\n    \\<select data-bind='options: myOptions, optionsIncludeDestroyed: true'\\>\\</select\\>\n\n  - optionsAfterRender\n\n    If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. See Note 2 below.\n\n  - selectedOptions\n\n    For a multi-select list, you can read and write the selection state using selectedOptions. Technically this is a separate binding, so it has [its own documentation](selectedoptions-binding).\n\n  - valueAllowUnset\n\n    If you want Knockout to allow your model property to take values that have no corresponding entry in your \\<select\\> element (and display this by making the \\<select\\> element blank), then see [documentation for valueAllowUnset](value-binding#using-valueallowunset-with-select-elements).\n\n### Note 1: Selection is preserved when setting/changing options\n\nWhen the options binding changes the set of options in your \\<select\\> element, KO will leave the user’s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you’ve removed one or more of those options).\n\nThat’s because the options binding tries to be independent of the value binding (which controls selection for a single-select list) and the selectedOptions binding (which controls selection for a multi-select list).\n\n### Note 2: Post-processing the generated options\n\nIf you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. The callback function is invoked each time an option element is inserted into the list, with the following parameters:\n\n1.  The inserted option element\n2.  The data item against which it is bound, or undefined for the caption element\n\nHere’s an example that uses optionsAfterRender to add a disable binding to each option.\n\n``` markup\n<select size=3 data-bind=\"\n    options: myItems,\n    optionsText: 'name',\n    optionsValue: 'id',\n    optionsAfterRender: setOptionDisable\">\n</select>\n\n<script type=\"text/javascript\">\n    var vm = {\n        myItems: [\n            { name: 'Item 1', id: 1, disable: ko.observable(false)},\n            { name: 'Item 3', id: 3, disable: ko.observable(true)},\n            { name: 'Item 4', id: 4, disable: ko.observable(false)}\n        ],\n        setOptionDisable: function(option, item) {\n            ko.applyBindingsToNode(option, {disable: item.disable}, item);\n        }\n    };\n    ko.applyBindings(vm);\n</script>\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/options-binding.html](https://knockoutjs.com/documentation/options-binding.html)"
- name: Pure computed observables
  id: computed-pure
  summary: Pure computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications
  description: "# Pure computed observables\n\n*Pure* computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a *pure* computed observable doesn’t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:\n\n- **Prevents memory leaks** from computed observables that are no longer referenced in an application but whose dependencies still exist.\n- **Reduces computation overhead** by not re-calculating computed observables whose value isn’t being observed.\n\nA *pure* computed observable automatically switches between two states based on whether it has change subscribers.\n\n1.  Whenever it has *no* change subscribers, it is ***sleeping***. When entering the *sleeping* state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable’s value is read while it is *sleeping*, it is automatically re-evaluated if any of its dependencies have changed.\n\n2.  Whenever it has *any* change subscribers, it is awake and ***listening***. When entering the *listening* state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in [how dependency tracking works](computed-dependency-tracking).\n\n#### Why “pure”?\n\nWe’ve borrowed the term from [pure functions](http://en.wikipedia.org/wiki/Pure_function) because this feature is generally only applicable for computed observables whose evaluator is a *pure function* as follows:\n\n1.  Evaluating the computed observable should not cause any side effects.\n2.  The value of the computed observable shouldn’t vary based on the number of evaluations or other “hidden” information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.\n\n#### Syntax\n\nThe standard method of defining a *pure* computed observable is to use ko.pureComputed:\n\n``` javascript\nthis.fullName = ko.pureComputed(function() {\n    return this.firstName() + \" \" + this.lastName();\n}, this);\n```\n\nAlternatively, you can use the pure option with ko.computed:\n\n``` javascript\nthis.fullName = ko.computed(function() {\n    return this.firstName() + \" \" + this.lastName();\n}, this, { pure: true });\n```\n\nFor complete syntax, see the [computed observable reference](computed-reference).\n\n### When to use a *pure* computed observable\n\nYou can use the *pure* feature for any computed observable that follows the [*pure function* guidelines](#pure-computed-function-defined). You’ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using *pure* computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.\n\nIn the following example of a simple wizard interface, the fullName *pure* computed is only bound to the view during the final step and so is only updated when that step is active.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<div class=\"log\" data-bind=\"text: computedLog\"></div>\n<!--ko if: step() == 0-->\n    <p>First name: <input data-bind=\"textInput: firstName\" /></p>\n<!--/ko-->\n<!--ko if: step() == 1-->\n    <p>Last name: <input data-bind=\"textInput: lastName\" /></p>\n<!--/ko-->\n<!--ko if: step() == 2-->\n    <div>Prefix: <select data-bind=\"value: prefix, options: ['Mr.', 'Ms.','Mrs.','Dr.']\"></select></div>\n    <h2>Hello, <span data-bind=\"text: fullName\"> </span>!</h2>\n<!--/ko-->\n<p><button type=\"button\" data-bind=\"click: next\">Next</button></p>\n```\n\n#### Source code: View model\n\n``` js\nfunction AppData() {\n    this.firstName = ko.observable('John');\n    this.lastName = ko.observable('Burns');\n    this.prefix = ko.observable('Dr.');\n    this.computedLog = ko.observable('Log: ');\n    this.fullName = ko.pureComputed(function () {\n        var value = this.prefix() + \" \" + this.firstName() + \" \" + this.lastName();\n        // Normally, you should avoid writing to observables within a pure computed \n        // observable (avoiding side effects). But this example is meant to demonstrate \n        // its internal workings, and writing a log is a good way to do so.\n        this.computedLog(this.computedLog.peek() + value + '; ');\n        return value;\n    }, this);\n\n    this.step = ko.observable(0);\n    this.next = function () {\n        this.step(this.step() === 2 ? 0 : this.step()+1);\n    };\n};\nko.applyBindings(new AppData());\n```\n\n### When *not* to use a *pure* computed observable\n\n#### Side effects\n\nYou should not use the *pure* feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:\n\n- Using a computed observable to run a callback based on multiple observables.\n\n  ``` javascript\n  ko.computed(function () {\n      var cleanData = ko.toJS(this);\n      myDataClient.update(cleanData);\n  }, this);\n  ```\n\n- In a binding’s init function, using a computed observable to update the bound element.\n\n  ``` javascript\n  ko.computed({\n      read: function () {\n          element.title = ko.unwrap(valueAccessor());\n      },\n      disposeWhenNodeIsRemoved: element\n  });\n  ```\n\nThe reason you shouldn’t use a *pure* computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it’s important for the evaluator to always run when dependencies change, use a [regular computed](computedobservables) instead.\n\n### Determining if a property is a pure computed observable\n\nIn some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, ko.isPureComputed to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.\n\n``` javascript\nvar result = {};\nko.utils.objectForEach(myObject, function (name, value) {\n    if (!ko.isComputed(value) || ko.isPureComputed(value)) {\n        result[name] = value;\n    }\n});\n```\n\n### State-change notifications\n\nA pure computed observable notifies some events that allow you to respond to changes to the state of the observable.\n\n- awake — Whenever the computed observable enters the *listening* state, it notifies an awake event using its current value. (The awake event also applies to normal computed observables created with the deferEvaluation option.) You won’t normally need to know about the internal state of your observables. But since the internal state can correspond to whether the observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.\n\n  ``` javascript\n  this.someComputedThatWillBeBound = ko.pureComputed(function () {\n      ...\n  }, this);\n\n  this.someComputedThatWillBeBound.subscribe(function () {\n      // do something when this is bound\n  }, this, \"awake\");\n  ```\n\n- asleep — Whevener the computed observable enters the *sleeping* state, it notifies an asleep event with a value of undefined.\n\n  ``` javascript\n  this.someComputedThatWillBeBound.subscribe(function () {\n      // do something when this is un-bound\n  }, this, \"asleep\");\n  ```\n\n- spectate — Whenever the computed observable **records** a change to its value, even while sleeping, it notifies a spectate event with the new value. (The spectate event applies to any type of observable but is generally most useful for pure computed observables.) This event allows you to track the current value of the observable without affecting its sleeping/waking state. Also note that when using rate-limiting or deferred updates, the “spectated” values might include intermediate values that aren’t captured by change notifications.\n\n### Status of a disposed pure computed observable\n\nYou can manually dispose a computed observable by calling its dispose function, which clears all subscriptions to its dependencies. It is also automatically disposed if its evaluator function doesn’t access any observables. Although you can continue to access the most recent value of a disposed computed observable, its evaluator function will not be run again. Additionally, a disposed *pure* computed observables is neither awake nor asleep, and does not notify state-change events. To determine if a computed observable is disposed, call myComputed.isActive().\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/computed-pure.html](https://knockoutjs.com/documentation/computed-pure.html)"
- name: Rate-limiting observable notifications
  id: ratelimit-observable
  summary: 'Note: This rate-limit API was added in Knockout 3.1.0'
  description: "# Rate-limiting observable notifications\n\n*Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the [throttle extender](https://knockoutjs.com/documentation/throttle-extender.html) provides similar functionality.*\n\nNormally, an [observable](observables) that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The rateLimit extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.\n\nThe rateLimit extender can be applied to any type of observable, including [observable arrays](observablearrays) and [computed observables](computedobservables). The main use cases for rate-limiting are:\n\n- Making things respond after a certain delay\n- Combining multiple changes into a single update\n\nIf you only need to combine updates without adding a delay, [deferred updates](deferred-updates) provides a more efficient method.\n\n### Applying the rateLimit extender\n\nrateLimit supports two parameter formats:\n\n``` javascript\n// Shorthand: Specify just a timeout in milliseconds\nsomeObservableOrComputed.extend({ rateLimit: 500 });\n\n// Longhand: Specify timeout and/or method\nsomeObservableOrComputed.extend({ rateLimit: { timeout: 500, method: \"notifyWhenChangesStop\" } });\n```\n\nThe method option controls when notifications fire, and accepts any of the following values:\n\n1.  \"notifyAtFixedRate\" — **Default value if not otherwise specified**. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).\n\n2.  \"notifyWhenChangesStop\" — The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.\n\n3.  A custom function that will handle the scheduling of notifications. For example, you could use Underscore’s throttle method: myObservable.extend({ rateLimit: { timeout: 500, method: \\_.throttle } }); For more details, see the section below on custom rate-limit methods.\n\n### Example 1: The basics\n\nConsider the observables in the following code:\n\n``` javascript\nvar name = ko.observable('Bert');\n\nvar upperCaseName = ko.computed(function() {\n    return name().toUpperCase();\n});\n```\n\nNormally, if you change name as follows:\n\n``` javascript\nname('The New Bert');\n```\n\n… then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:\n\n``` javascript\nvar name = ko.observable('Bert').extend({ rateLimit: 500 });\n```\n\n… then upperCaseName will not be recomputed immediately when name changes—instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.\n\n### Example 2: Doing something when the user stops typing\n\nIn this live example, there’s an instantaneousValue observable that reacts immediately when you press a key. This is then wrapped inside a delayedValue computed observable that’s configured to notify only when changes stop for at least 400 milliseconds, using the notifyWhenChangesStop rate-limit method.\n\nTry it:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<p>Type stuff here: <input data-bind='textInput: instantaneousValue' /></p>\n<p>Current delayed value: <b data-bind='text: delayedValue'> </b></p>\n\n<div data-bind=\"visible: loggedValues().length > 0\">\n    <h3>Stuff you have typed:</h3>\n    <ul data-bind=\"foreach: loggedValues\">\n        <li data-bind=\"text: $data\"></li>\n    </ul>\n</div>\n```\n\n#### Source code: View model\n\n``` js\nfunction AppViewModel() {\n    this.instantaneousValue = ko.observable();\n    this.delayedValue = ko.pureComputed(this.instantaneousValue)\n        .extend({ rateLimit: { method: \"notifyWhenChangesStop\", timeout: 400 } });\n\n    // Keep a log of the throttled values\n    this.loggedValues = ko.observableArray([]);\n    this.delayedValue.subscribe(function (val) {\n        if (val !== '')\n            this.loggedValues.push(val);\n    }, this);\n}\n\nko.applyBindings(new AppViewModel());\n```\n\n## Custom rate-limit methods\n\nKnockout 3.5 introduced the ability to specify a custom rate-limit method by passing a function to the rateLimit extender rather than just a string. The function is called with three parameters (function, timeout, options) and must return a new, rate-limited function. Whenever the observable has a possibly new value to notify, it will call the returned function, which should then call the original function after some delay based on the rules of the custom method. For example, here is a function that implements *debounce* but also immediately notifies the initial value:\n\n``` javascript\nfunction debounceSubsequentChanges(action, timeout) {\n    var timeoutInstance;\n    return function () {\n        if (!timeoutInstance) {\n            action();\n            timeoutInstance = setTimeout(function () {\n                timeoutInstance = undefined;\n            }, timeout);\n        } else {\n            clearTimeout(timeoutInstance);\n            timeoutInstance = setTimeout(function() {\n                timeoutInstance = undefined;\n                action();\n            }, timeout);\n        }\n    };\n}\n```\n\nYour function can also accept a third parameter, an object that includes any additional parameters passed to the rateLimit extender.\n\n## Special consideration for computed observables\n\nFor a computed observable, the rate-limit timer is triggered when one of the computed observable’s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed—after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed’s most recent evaluation, you can do so with the peek method.\n\n## Forcing rate-limited observables to always notify subscribers\n\nWhen the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.\n\nIf you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender in addition to rateLimit:\n\n``` javascript\nmyViewModel.fullName = ko.computed(function() {\n    return myViewModel.firstName() + \" \" + myViewModel.lastName();\n}).extend({ notify: 'always', rateLimit: 500 });\n```\n\n## Comparison with deferred updates\n\nKnockout version 3.4.0 added support for [*deferred updates*](deferred-updates), which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:\n\n``` javascript\nko.computed(function() {\n    // ....\n}).extend({ deferred: true });\n```\n\n## Comparison with the throttle extender\n\nIf you’d like to migrate code from using the deprecated throttle extender, you should note the following ways that the rateLimit extender is different from the throttle extender.\n\nWhen using rateLimit:\n\n1.  *Writes* to observables are not delayed; the observable’s value is updated right away. For writable computed observables, this means that the write function is always run right away.\n2.  All change notifications are delayed, including when calling valueHasMutated manually. This means you can’t use valueHasMutated to force a rate-limited observable to notify an un-changed value.\n3.  The default rate-limit method is different from the throttle algorithm. To match the throttle behavior, use the notifyWhenChangesStop method.\n4.  Evaluation of a rate-limited computed observable isn’t rate-limited; it will re-evaluate if you read its value.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/rateLimit-observable.html](https://knockoutjs.com/documentation/rateLimit-observable.html)"
- name: selectedOptions binding
  id: selectedoptions-binding
  summary: The selectedOptions binding controls which elements in a multi-select list are currently selected
  description: "# The \"selectedOptions\" binding\n\n### Purpose\n\nThe selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a \\<select\\> element and the options binding.\n\nWhen the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it’s an *observable* array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It’s a 2-way binding.\n\nNote: To control which element in a single-select drop-down list is selected, you can use [the value binding](value-binding) instead.\n\n### Example\n\n``` markup\n<p>\n    Choose some countries you'd like to visit: \n    <select data-bind=\"options: availableCountries, selectedOptions: chosenCountries\" size=\"5\" multiple=\"true\"></select>\n</p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        availableCountries : ko.observableArray(['France', 'Germany', 'Spain']),\n        chosenCountries : ko.observableArray(['Germany']) // Initially, only Germany is selected\n    };\n    \n    // ... then later ...\n    viewModel.chosenCountries.push('France'); // Now France is selected too\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  This should be an array (or an observable array). KO sets the element’s selected options to match the contents of the array. Any previous selection state will be overwritten.\n\n  If your parameter is an observable array, the binding will update the element’s selection whenever the array changes (e.g., via push, pop or [other observable array methods](observablearrays)). If the parameter isn’t observable, it will only set the element’s selection state once and will not update it again later.\n\n  Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.\n\n- Additional parameters\n\n  - None\n\n### Note: Letting the user select from arbitrary JavaScript objects\n\nIn the example code above, the user can choose from an array of string values. You’re *not* limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See [the options binding](options-binding) for details on how to control how arbitrary objects should be displayed in the list.\n\nIn this scenario, the values you can read and write using selectedOptions are those objects themselves, *not* their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/selectedOptions-binding.html](https://knockoutjs.com/documentation/selectedOptions-binding.html)"
- name: style binding
  id: style-binding
  summary: The style binding adds or removes one or more style values to the associated DOM element
  description: "# The \"style\" binding\n\n### Purpose\n\nThe style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.\n\n(Note: If you don’t want to apply an explicit style value but instead want to assign a CSS class, see [the class or css binding](css-binding).)\n\n### Example\n\n``` markup\n<div data-bind=\"style: { color: currentProfit() < 0 ? 'red' : 'black' }\">\n   Profit Information\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        currentProfit: ko.observable(150000) // Positive value, so initially black\n    };\n    viewModel.currentProfit(-50); // Causes the DIV's contents to go red\n</script>\n```\n\nThis will set the element’s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.\n\n### Parameters\n\n- Main parameter\n\n  You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.\n\n  You can set multiple style values at once. For example, if your view model has a property called isSevere,\n\n  \\<div data-bind=\"style: { color: currentProfit() \\< 0 ? 'red' : 'black', 'font-weight': isSevere() ? 'bold' : '' }\"\\>...\\</div\\>\n\n  If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn’t reference an observable value, it will only set the styles once and will not update them later.\n\n  As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to detemine the style values to apply.\n\n- Additional parameters\n\n  - None\n\n### Note 1: Applying styles whose names aren’t legal JavaScript variable names\n\nIf you want to apply a style whose name isn’t a legal JavaScript identifier (e.g., because it contains a hyphen), you can either put it in quotes or use the JavaScript name for that style. For example,\n\n- Either { 'font-weight': someValue } or { fontWeight: someValue }\n- Either { 'text-decoration': someValue } or { textDecoration: someValue }\n\n### Note 2: Setting styles which require a unit\n\nIf you apply a simple numeric value to a style that requires a unit, Knockout will append px to the value before setting the style. For example, style: { width: 100 } will set the width to 100px.\n\n### Note 3: Enhanced functionality when jQuery is present\n\nKnockout will use jQuery’s [css](http://api.jquery.com/css/) function to set the styles, if available. This lets you take advantage of the extra compatibility features of jQuery, such as setting browser-specific prefixes.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/style-binding.html](https://knockoutjs.com/documentation/style-binding.html)"
- name: submit binding
  id: submit-binding
  summary: The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted
  description: "# The \"submit\" binding\n\n### Purpose\n\nThe submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.\n\nWhen you use the submit binding on a form, Knockout will prevent the browser’s default submit action for that form. In other words, the browser will call your handler function but will *not* submit the form to the server. This is a useful default because when you use the submit binding, it’s normally because you’re using the form as an interface to your view model, not as a regular HTML form. If you *do* want to let the form submit like a normal HTML form, just return true from your submit handler.\n\n### Example\n\n``` markup\n<form data-bind=\"submit: doSomething\">\n    ... form contents go here ...\n    <button type=\"submit\">Submit</button>\n</form>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        doSomething : function(formElement) {\n            // ... now do something\n        }\n    };\n</script>\n```\n\nAs illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:\n\n- Extracting additional data or state from the form elements\n\n- Triggering UI-level validation using a library such as [jQuery Validation](https://github.com/jzaefferer/jquery-validation), using code similar to the following snippet: if ($(formElement).valid()) { /\\* do something \\*/ }.\n\n### Why not just put a click handler on the submit button?\n\nInstead of using submit on the form, you *could* use click on the submit button. However, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the *enter* key while typing into a text box.\n\n### Parameters\n\n- Main parameter\n\n  The function you want to bind to the element’s submit event.\n\n  You can reference any JavaScript function - it doesn’t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.\n\n  Functions on your view model are slightly special because you can reference them by name, i.e., you can write submit: doSomething and *don’t* have to write submit: viewModel.doSomething (though technically that’s also valid).\n\n- Additional parameters\n\n  - None\n\n### Notes\n\nFor information about how to pass additional parameters to your submit handler function, or how to control the this handle when invoking functions that aren’t on your view model, see the notes relating to the [click binding](click-binding). All the notes on that page apply to submit handlers too.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/submit-binding.html](https://knockoutjs.com/documentation/submit-binding.html)"
- name: template binding
  id: template-binding
  summary: The template binding populates the associated DOM element with the results of rendering a template
  description: "# The \"template\" binding\n\n### Purpose\n\nThe template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.\n\nThere are two main ways of using templates:\n\n- *Native templating* is the mechanism that underpins foreach, if, with, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn’t require any external library.\n- *String-based templating* is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the *jquery.tmpl* and *Underscore* template engines.\n\n### Parameters\n\n- Main parameter\n\n  - Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.\n\n  - For more control, pass a JavaScript object with some combination of the following properties:\n\n    - name — the ID of an element that contains the template you wish to render - see [Note 5](#note-5-dynamically-choosing-which-template-is-used) for how to vary this programmatically.\n    - nodes — directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.\n    - data — an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.\n    - if — if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.\n    - foreach — instructs KO to render the template in “foreach” mode - see [Note 2](#note-2-using-the-foreach-option-with-a-named-template) for details.\n    - as — when used in conjunction with foreach, defines an alias for each item being rendered - see [Note 3](#note-3-using-as-to-give-an-alias-to-foreach-items) for details.\n    - afterRender, afterAdd, or beforeRemove — callback functions to be invoked against the rendered DOM elements - see [Note 4](#note-4-using-afterrender-afteradd-and-beforeremove)\n\n### Note 1: Rendering a named template\n\nNormally, when you’re using control flow bindings (foreach, with, if, etc.), there’s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:\n\n``` markup\n<h2>Participants</h2>\nHere are the participants:\n<div data-bind=\"template: { name: 'person-template', data: buyer }\"></div>\n<div data-bind=\"template: { name: 'person-template', data: seller }\"></div>\n\n<script type=\"text/html\" id=\"person-template\">\n    <h3 data-bind=\"text: name\"></h3>\n    <p>Credits: <span data-bind=\"text: credits\"></span></p>\n</script>\n\n<script type=\"text/javascript\">\n     function MyViewModel() {\n         this.buyer = { name: 'Franklin', credits: 250 };\n         this.seller = { name: 'Mario', credits: 5800 };\n     }\n     ko.applyBindings(new MyViewModel());\n</script>\n```\n\nIn this example, the person-template markup is used twice: once for buyer, and once for seller. Notice that the template markup is wrapped in a \\<script type=\"text/html\"\\> — the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.\n\nIt’s not very often that you’ll need to use named templates, but on occasion it can help to minimise duplication of markup.\n\n### Note 2: Using the “foreach” option with a named template\n\nIf you want the equivalent of a foreach binding, but using a named template, you can do so in the natural way:\n\n``` markup\n<h2>Participants</h2>\nHere are the participants:\n<div data-bind=\"template: { name: 'person-template', foreach: people }\"></div>\n\n<script type=\"text/html\" id=\"person-template\">\n    <h3 data-bind=\"text: name\"></h3>\n    <p>Credits: <span data-bind=\"text: credits\"></span></p>\n</script>\n\n function MyViewModel() {\n     this.people = [\n         { name: 'Franklin', credits: 250 },\n         { name: 'Mario', credits: 5800 }\n     ]\n }\n ko.applyBindings(new MyViewModel());\n```\n\nThis gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:\n\n``` markup\n<div data-bind=\"foreach: people\">\n    <h3 data-bind=\"text: name\"></h3>\n    <p>Credits: <span data-bind=\"text: credits\"></span></p>\n</div>\n```\n\n### Note 3: Using “as” to give an alias to “foreach” items\n\nWhen nesting foreach templates, it’s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other [binding context](binding-context) variables in your bindings.\n\nA simpler and more elegant option, however, is to use as to declare a name for your iteration variables. For example:\n\n``` markup\n<ul data-bind=\"template: { name: 'employeeTemplate',\n                                  foreach: employees,\n                                  as: 'employee' }\"></ul>\n```\n\nNotice the string value 'employee' associated with as. Now anywhere inside this foreach loop, bindings in your child templates will be able to refer to employee to access the employee object being rendered.\n\nThis is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here’s a complete example, showing how season can be referenced while rendering a month:\n\n``` markup\n<ul data-bind=\"template: { name: 'seasonTemplate', foreach: seasons, as: 'season' }\"></ul>\n\n<script type=\"text/html\" id=\"seasonTemplate\">\n    <li>\n        <strong data-bind=\"text: name\"></strong>\n        <ul data-bind=\"template: { name: 'monthTemplate', foreach: months, as: 'month' }\"></ul>\n    </li>\n</script>\n\n<script type=\"text/html\" id=\"monthTemplate\">\n    <li>\n        <span data-bind=\"text: month\"></span>\n        is in\n        <span data-bind=\"text: season.name\"></span>\n    </li>\n</script>\n\n<script>\n    var viewModel = {\n        seasons: ko.observableArray([\n            { name: 'Spring', months: [ 'March', 'April', 'May' ] },\n            { name: 'Summer', months: [ 'June', 'July', 'August' ] },\n            { name: 'Autumn', months: [ 'September', 'October', 'November' ] },\n            { name: 'Winter', months: [ 'December', 'January', 'February' ] }\n        ])\n    };\n    ko.applyBindings(viewModel);\n</script>\n```\n\nTip: Remember to pass a *string literal value* to as (e.g., as: 'season', *not* as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.\n\n### Note 4: Using “afterRender”, “afterAdd”, and “beforeRemove”\n\nSometimes you might want to run custom post-processing logic on the DOM elements generated by your templates. For example, if you’re using a JavaScript widgets library such as jQuery UI, you might want to intercept your templates’ output so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.\n\nGenerally, the best way to perform such post-processing on DOM elements is to write a [custom binding](custom-bindings), but if you really just want to access the raw DOM elements emitted by a template, you can use afterRender.\n\nPass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you’re using foreach, Knockout will invoke your afterRender callback for each item added to your observable array. For example,\n\n``` markup\n<div data-bind='template: { name: \"personTemplate\",\n                            data: myData,\n                            afterRender: myPostProcessingLogic }'> </div>\n```\n\n… and define a corresponding function on your view model (i.e., the object that contains myData):\n\n``` javascript\nviewModel.myPostProcessingLogic = function(elements) {\n    // \"elements\" is an array of DOM nodes just rendered by the template\n    // You can add custom post-processing logic here\n}\n```\n\nIf you are using foreach and only want to be notified about elements that are specifically being added or are being removed, you can use afterAdd and beforeRemove instead. For details, see documentation for the [foreach binding](foreach-binding).\n\n### Note 5: Dynamically choosing which template is used\n\nIf you have multiple named templates, you can pass an observable for the name option. As the observable’s value is updated, the element’s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the foreach template mode, Knockout will evaluate the function for each item in your array, passing that item’s value as the only argument. Otherwise, the function will be given the data option’s value or fall back to providing your whole current model object.\n\nFor example,\n\n``` markup\n<ul data-bind='template: { name: displayMode,\n                           foreach: employees }'> </ul>\n\n<script>\n    var viewModel = {\n        employees: ko.observableArray([\n            { name: \"Kari\", active: ko.observable(true) },\n            { name: \"Brynn\", active: ko.observable(false) },\n            { name: \"Nora\", active: ko.observable(false) }\n        ]),\n        displayMode: function(employee) {\n            // Initially \"Kari\" uses the \"active\" template, while the others use \"inactive\"\n            return employee.active() ? \"active\" : \"inactive\";\n        }\n    };\n\n    // ... then later ...\n    viewModel.employees()[1].active(true); // Now \"Brynn\" is also rendered using the \"active\" template.\n</script>\n```\n\nIf your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.\n\nIf your function accepts a second parameter, then it will receive the entire [binding context](binding-context). You can then access $parent or any other [binding context](binding-context) variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:\n\n``` javascript\ndisplayMode: function(employee, bindingContext) {\n    // Now return a template name string based on properties of employee or bindingContext\n}\n```\n\n### Note 6: Using jQuery.tmpl, an external string-based template engine\n\nIn the vast majority of cases, Knockout’s native templating and the foreach, if, with and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the [Underscore template engine](http://documentcloud.github.com/underscore/#template) or [jquery.tmpl](http://api.jquery.com/jquery.tmpl/), Knockout offers a way to do it.\n\nBy default, Knockout comes with support for [jquery.tmpl](https://github.com/BorisMoore/jquery-tmpl). To use it, you need to reference the following libraries, in this order:\n\n``` markup\n<!-- First jQuery -->     <script src=\"http://code.jquery.com/jquery-1.7.1.min.js\"></script>\n<!-- Then jQuery.tmpl --> <script src=\"jquery.tmpl.js\"></script>\n<!-- Then Knockout -->    <script src=\"knockout-x.y.z.js\"></script>\n```\n\nThen, you can use jQuery.tmpl syntax in your templates. For example,\n\n``` markup\n<h1>People</h1>\n<div data-bind=\"template: 'peopleList'\"></div>\n\n<script type=\"text/html\" id=\"peopleList\">\n    {{each people}}\n        <p>\n            <b>${name}</b> is ${age} years old\n        </p>\n    {{/each}}\n</script>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        people: ko.observableArray([\n            { name: 'Rod', age: 123 },\n            { name: 'Jane', age: 125 },\n        ])\n    }\n    ko.applyBindings(viewModel);\n</script>\n```\n\nThis works because {{each ...}} and ${ ... } are jQuery.tmpl syntaxes. What’s more, it’s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=\"template: ...\" inside a template to render a nested one.\n\nPlease note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout’s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.\n\n### Note 7: Using the Underscore.js template engine\n\nThe [Underscore.js template engine](http://documentcloud.github.com/underscore/#template) by default uses ERB-style delimiters (\\<%= ... %\\>). Here’s how the preceding example’s template might look with Underscore:\n\n``` markup\n<script type=\"text/html\" id=\"peopleList\">\n    <% _.each(people(), function(person) { %>\n        <li>\n            <b><%= person.name %></b> is <%= person.age %> years old\n        </li>\n    <% }) %>\n</script>\n```\n\nHere’s [a simple implementation of integrating Underscore templates with Knockout](http://jsfiddle.net/rniemeyer/NW5Vn/). The integration code is just 16 lines long, but it’s enough to support Knockout data-bind attributes (and hence nested templates) and Knockout [binding context](binding-context) variables ($parent, $root, etc.).\n\nIf you’re not a fan of the \\<%= ... %\\> delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.\n\n### Dependencies\n\n- **Native templating** does not require any library other than Knockout itself\n- **String-based templating** works only once you’ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/template-binding.html](https://knockoutjs.com/documentation/template-binding.html)"
- name: text binding
  id: text-binding
  summary: The text binding causes the associated DOM element to display the text value of your parameter
  description: "# The \"text\" binding\n\n### Purpose\n\nThe text binding causes the associated DOM element to display the text value of your parameter.\n\nTypically this is useful with elements like \\<span\\> or \\<em\\> that traditionally display text, but technically you can use it with any element.\n\n### Example\n\n``` markup\nToday's message is: <span data-bind=\"text: myMessage\"></span>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        myMessage: ko.observable() // Initially blank\n    };\n    viewModel.myMessage(\"Hello, world!\"); // Text appears\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  Knockout sets the element’s content to a text node with your parameter value. Any previous content will be overwritten.\n\n  If this parameter is an observable value, the binding will update the element’s text whenever the value changes. If the parameter isn’t observable, it will only set the element’s text once and will not update it again later.\n\n  If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString()\n\n- Additional parameters\n\n  - None\n\n### Note 1: Using functions and expressions to detemine text values\n\nIf you want to detemine text programmatically, one option is to create a [computed observable](computedobservables), and use its evaluator function as a place for your code that works out what text to display.\n\nFor example,\n\n``` markup\nThe item is <span data-bind=\"text: priceRating\"></span> today.\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        price: ko.observable(24.95)\n    };\n    viewModel.priceRating = ko.pureComputed(function() {\n        return this.price() > 50 ? \"expensive\" : \"affordable\";\n    }, viewModel);\n</script>\n```\n\nNow, the text will switch between “expensive” and “affordable” as needed whenever price changes.\n\nAlternatively, you don’t need to create a computed observable if you’re doing something simple like this. You can pass an arbitrary JavaScript expression to the text binding. For example,\n\n``` markup\nThe item is <span data-bind=\"text: price() > 50 ? 'expensive' : 'affordable'\"></span> today.\n```\n\nThis has exactly the same result, without requiring the priceRating computed observable.\n\n### Note 2: About HTML encoding\n\nSince this binding sets your text value using a text node, it’s safe to set any string value without risking HTML or script injection. For example, if you wrote:\n\n``` javascript\nviewModel.myMessage(\"<i>Hello, world!</i>\");\n```\n\n… this would *not* render as italic text, but would render as literal text with visible angle brackets.\n\nIf you need to set HTML content in this manner, see [the html binding](html-binding).\n\n### Note 3: Using “text” without a container element\n\nSometimes you may want to set text using Knockout without including an extra element for the text binding. For example, you’re not allowed to include other elements within an option element, so the following will not work.\n\n``` markup\n<select data-bind=\"foreach: items\">\n    <option>Item <span data-bind=\"text: name\"></span></option>\n</select>\n```\n\nTo handle this, you can use the *containerless syntax*, which is based on comment tags.\n\n``` markup\n<select data-bind=\"foreach: items\">\n    <option>Item <!--ko text: name--><!--/ko--></option>\n</select>\n```\n\nThe \\<!--ko--\\> and \\<!--/ko--\\> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.\n\n### Note 4: About an IE 6 whitespace quirk\n\nIE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:\n\n``` markup\nWelcome, <span data-bind=\"text: userName\"></span> to our web site.\n```\n\n… and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the \\<span\\>, e.g.:\n\n``` markup\nWelcome, <span data-bind=\"text: userName\">&nbsp;</span> to our web site.\n```\n\nOther browsers, and newer versions of IE, don’t have this quirk.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/text-binding.html](https://knockoutjs.com/documentation/text-binding.html)"
- name: textInput binding
  id: textinput-binding
  summary: The textInput binding links a text box (<input>) or text area (<textarea>) with a viewmodel property, providing two-way updates between the viewmodel property and the element’s value
  description: "# The \"textInput\" binding\n\n### Purpose\n\nThe textInput binding links a text box (\\<input\\>) or text area (\\<textarea\\>) with a viewmodel property, providing two-way updates between the viewmodel property and the element’s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.\n\n### Example\n\n``` markup\n<p>Login name: <input data-bind=\"textInput: userName\" /></p>\n<p>Password: <input type=\"password\" data-bind=\"textInput: userPassword\" /></p>\n\nViewModel:\n<pre data-bind=\"text: ko.toJSON($root, null, 2)\"></pre>\n\n<script>\n    ko.applyBindings({\n        userName: ko.observable(\"\"),        // Initially blank\n        userPassword: ko.observable(\"abc\")  // Prepopulate\n    });\n</script>\n```\n\n### Parameters\n\n- Main Parameter\n\n  KO sets the element’s text content to your parameter value. Any previous value will be overwritten.\n\n  If this parameter is an observable value, the binding will update the element’s value whenever the observable value changes. If the parameter isn’t observable, it will only set the element’s value once and will not update it again later.\n\n  If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that’s usually not very useful, so it’s best to supply string or numeric values).\n\n  Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.\n\n- Additional parameters\n\n  - None\n\n### Note 1: textInput vs value binding\n\nAlthough the [value binding](value-binding) can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates. The main differences are:\n\n- **Immediate updates**\n\n  value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don’t necessarily raise any focus change events).\n\n- **Browser event quirks handling**\n\n  Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The value binding, even with extra options such as valueUpdate: afterkeydown to get updates on particular events, does not cover all text entry scenarios on all browsers.\n\n  The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.\n\nDon’t try to use the value and textInput bindings together on the same element, as that won’t achieve anything useful.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/textinput-binding.html](https://knockoutjs.com/documentation/textinput-binding.html)"
- name: uniqueName binding
  id: uniquename-binding
  summary: The uniqueName binding ensures that the associated DOM element has a nonempty name attribute
  description: "# The \"uniqueName\" binding\n\n### Purpose\n\nThe uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.\n\nYou won’t need to use this often. It’s only useful in a few rare cases, e.g.:\n\n- Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you’re using KO. For example, [jQuery Validation](http://jqueryvalidation.org/) currently will only validate elements that have names. To use this with a Knockout UI, it’s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See [an example of using jQuery Validation with KO](https://knockoutjs.com/examples/gridEditor.html).\n\n- IE 6 does not allow radio buttons to be checked if they don’t have a name attribute. Most of the time this is irrelevant because your radio button elements *will* have name attributes to put them into mutually-exclusive groups. However, just in case you didn’t add a name attribute because it’s unnecessary in your case, KO will internally use uniqueName on those elements to ensure they can be checked.\n\n### Example\n\n``` markup\n<input data-bind=\"value: someModelProperty, uniqueName: true\" />\n```\n\n### Parameters\n\n- Main parameter\n\n  Pass true (or some value that evaluates as true) to enable the uniqueName binding, as in the preceding example.\n\n- Additional parameters\n\n  - None\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/uniqueName-binding.html](https://knockoutjs.com/documentation/uniqueName-binding.html)"
- name: value binding
  id: value-binding
  summary: The value binding links the associated DOM element’s value with a property on your view model
  description: "# The \"value\" binding\n\n### Purpose\n\nThe value binding links the associated DOM element’s value with a property on your view model. This is typically useful with form elements such as \\<input\\>, \\<select\\> and \\<textarea\\>.\n\nWhen the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.\n\nNote: If you’re working with checkboxes or radio buttons, use [the checked binding](checked-binding) to read and write your element’s checked state, not the value binding.\n\n### Example\n\n``` markup\n<p>Login name: <input data-bind=\"value: userName\" /></p>\n<p>Password: <input type=\"password\" data-bind=\"value: userPassword\" /></p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        userName: ko.observable(\"\"),        // Initially blank\n        userPassword: ko.observable(\"abc\"), // Prepopulate\n    };\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  KO sets the element’s value property to your parameter value. Any previous value will be overwritten.\n\n  If this parameter is an observable value, the binding will update the element’s value whenever the value changes. If the parameter isn’t observable, it will only set the element’s value once and will not update it again later.\n\n  If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that’s usually not very useful, so it’s best to supply string or numeric values).\n\n  Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.\n\n- Additional parameters\n\n  - valueUpdate\n\n    If your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event. The following string values are the most commonly useful choices:\n\n    - \"input\" - updates your view model when the value of an \\<input\\> or \\<textarea\\> element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).\n    - \"keyup\" - updates your view model when the user releases a key\n    - \"keypress\" - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down\n    - \"afterkeydown\" - updates your view model as soon as the user begins typing a character. This works by catching the browser’s keydown event and handling the event asynchronously. This does not work in some mobile browsers.\n\n  - valueAllowUnset\n\n    See [Note 2](#using-valueallowunset-with-select-elements) below. Note that valueAllowUnset is only applicable when using value to control selection on a \\<select\\> element. On other elements it has no effect.\n\n### Note 1: Getting value updates instantly from inputs\n\nIf you are trying to bind an \\<input type=\"text\" /\\> or \\<textarea\\> to get instant updates to your viewmodel, use the [the textInput binding](textinput-binding). It has better support for browser edge cases than any combination of valueUpdate options.\n\n### Note 2: Working with drop-down lists (i.e., \\<select\\> elements)\n\nKnockout has special support for drop-down lists (i.e., \\<select\\> elements). The value binding works in conjunction with the options binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see [the options binding](options-binding) or for handling multi-select lists, see the documentation for [the selectedOptions binding](selectedoptions-binding).\n\nYou can also use the value binding with a \\<select\\> element that does not use the options binding. In this case, you can choose to specify your \\<option\\> elements in markup or build them using the foreach or template bindings. You can even nest options within \\<optgroup\\> elements and Knockout will set the selected value appropriately.\n\n#### Using valueAllowUnset with \\<select\\> elements\n\nNormally, when you use the value binding on a \\<select\\> element, it means that you want the associated model value to describe which item in the \\<select\\> is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.\n\nHowever, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the \\<select\\>, then specify valueAllowUnset: true. In this case, whenever your model value cannot be represented in the \\<select\\>, then the \\<select\\> simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:\n\n``` markup\n<p>\n    Select a country:\n    <select data-bind=\"options: countries,\n                       optionsCaption: 'Choose one...',\n                       value: selectedCountry,\n                       valueAllowUnset: true\"></select>\n</p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        countries: ['Japan', 'Bolivia', 'New Zealand'],\n        selectedCountry: ko.observable('Latvia')\n    };\n</script>\n```\n\nIn the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option.\n\nIf valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry.\n\n### Note 3: Updating observable and non-observable property values\n\nIf you use value to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.\n\nHowever, if you use value to link a form element to a *non*-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:\n\n- If you reference a *simple property*, i.e., it is just a regular property on your view model, KO will set the form element’s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn’t observable), so this is only a 1-way binding.\n\n- If you reference something that is *not* a simple property, e.g., the result of a function call or comparison operation, KO will set the form element’s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it’s a one-time-only value setter, not an ongoing binding that reacts to changes.\n\nExample:\n\n``` markup\n<!-- Two-way binding. Populates textbox; syncs both ways. -->\n<p>First value: <input data-bind=\"value: firstValue\" /></p>\n\n<!-- One-way binding. Populates textbox; syncs only from textbox to model. -->\n<p>Second value: <input data-bind=\"value: secondValue\" /></p>\n\n<!-- No binding. Populates textbox, but doesn't react to any changes. -->\n<p>Third value: <input data-bind=\"value: secondValue.length > 8\" /></p>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        firstValue: ko.observable(\"hello\"), // Observable\n        secondValue: \"hello, again\"         // Not observable\n    };\n</script>\n```\n\n### Note 4: Using the value binding with the checked binding\n\nThe [checked](checked-binding) binding should be used to bind a view model property against the value of a checkbox (\\<input type='checkbox'\\>) or radio button (\\<input type='radio'\\>). If you do include the value binding with the checked binding on one of these elements, then the value binding acts similarly to the [checkedValue](checked-binding#checkedValue) option that can be used with the checked binding and will control the value that is used for updating your view model.\n\n### Note 5: Interaction with jQuery\n\nKnockout will use jQuery, if it is present, for handling UI events such as change. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:\n\n``` javascript\nko.options.useOnlyNativeEvents = true;\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/value-binding.html](https://knockoutjs.com/documentation/value-binding.html)"
- name: Virtual elements
  id: custom-bindings-for-virtual-elements
  summary: 'Note: This is an advanced technique, typically used only when creating libraries of reusable bindings'
  description: "# Creating custom bindings that support virtual elements\n\n*Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It’s not something you’ll normally need to do when building applications with Knockout.*\n\nKnockout’s *control flow bindings* (e.g., [if](if-binding) and [foreach](foreach-binding)) can be applied not only to regular DOM elements, but also to “virtual” DOM elements defined by a special comment-based syntax. For example:\n\n``` markup\n<ul>\n    <li class=\"heading\">My heading</li>\n    <!-- ko foreach: items -->\n        <li data-bind=\"text: $data\"></li>\n    <!-- /ko -->\n</ul>\n```\n\nCustom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the ko.virtualElements.allowedBindings API.\n\n### Example\n\nTo get started, here’s a custom binding that randomises the order of DOM nodes:\n\n``` javascript\nko.bindingHandlers.randomOrder = {\n    init: function(elem, valueAccessor) {\n        // Pull out each of the child elements into an array\n        var childElems = [];\n        while(elem.firstChild)\n            childElems.push(elem.removeChild(elem.firstChild));\n\n        // Put them back in a random order\n        while(childElems.length) {\n            var randomIndex = Math.floor(Math.random() * childElems.length),\n                chosenChild = childElems.splice(randomIndex, 1);\n            elem.appendChild(chosenChild[0]);\n        }\n    }\n};\n```\n\nThis works nicely with regular DOM elements. The following elements will be shuffled into a random order:\n\n``` markup\n<div data-bind=\"randomOrder: true\">\n    <div>First</div>\n    <div>Second</div>\n    <div>Third</div>\n</div>\n```\n\nHowever, it does *not* work with virtual elements. If you try the following:\n\n``` markup\n<!-- ko randomOrder: true -->\n    <div>First</div>\n    <div>Second</div>\n    <div>Third</div>\n<!-- /ko -->\n```\n\n… then you’ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let’s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:\n\n``` javascript\nko.virtualElements.allowedBindings.randomOrder = true;\n```\n\nNow there won’t be an error. However, it still won’t work properly, because our randomOrder binding is coded using normal DOM API calls (firstChild, appendChild, etc.) which don’t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it’s not going to work properly!\n\nLet’s update the code for randomOrder, this time using KO’s virtual element APIs:\n\n``` javascript\nko.bindingHandlers.randomOrder = {\n    init: function(elem, valueAccessor) {\n        // Build an array of child elements\n        var child = ko.virtualElements.firstChild(elem),\n            childElems = [];\n        while (child) {\n            childElems.push(child);\n            child = ko.virtualElements.nextSibling(child);\n        }\n\n        // Remove them all, then put them back in a random order\n        ko.virtualElements.emptyNode(elem);\n        while(childElems.length) {\n            var randomIndex = Math.floor(Math.random() * childElems.length),\n                chosenChild = childElems.splice(randomIndex, 1);\n            ko.virtualElements.prepend(elem, chosenChild[0]);\n        }\n    }\n};\n```\n\nNotice how, instead of using APIs like domElement.firstChild, we’re now using ko.virtualElements.firstChild(domOrVirtualElement). The randomOrder binding will now correctly work with virtual elements, e.g., \\<!-- ko randomOrder: true --\\>...\\<!-- /ko --\\>.\n\nAlso, randomOrder will still work with regular DOM elements, because all of the ko.virtualElements APIs are backwardly compatible with regular DOM elements.\n\n### Virtual Element APIs\n\nKnockout provides the following functions for working with virtual elements.\n\n- ko.virtualElements.allowedBindings\n\n  An object whose keys determine which bindings are usable with virtual elements. Set ko.virtualElements.allowedBindings.mySuperBinding = true to allow mySuperBinding to be used with virtual elements.\n\n- ko.virtualElements.emptyNode(containerElem)\n\n  Removes all child nodes from the real or virtual element containerElem (cleaning away any data associated with them to avoid memory leaks).\n\n- ko.virtualElements.firstChild(containerElem)\n\n  Returns the first child of the real or virtual element containerElem, or null if there are no children.\n\n- ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)\n\n  Inserts nodeToInsert as a child of the real or virtual element containerElem, positioned immediately after insertAfter (where insertAfter must be a child of containerElem).\n\n- ko.virtualElements.nextSibling(node)\n\n  Returns the sibling node that follows node in its real or virtual parent element, or null if there is no following sibling.\n\n- ko.virtualElements.prepend(containerElem, nodeToPrepend)\n\n  Inserts nodeToPrepend as the first child of the real or virtual element containerElem.\n\n- ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)\n\n  Removes all child nodes from the real or virtual element containerElem (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from arrayOfNodes as its new children.\n\nNotice that this is *not* intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html](https://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html)"
- name: visible and hidden bindings
  id: visible-binding
  summary: The visible and hidden bindings cause the associated DOM element to become hidden or visible according to the value you pass to the binding
  description: "# The \"visible\" and \"hidden\" bindings\n\n### Purpose\n\nThe visible and hidden bindings cause the associated DOM element to become hidden or visible according to the value you pass to the binding.\n\n### Example\n\n``` markup\n<div data-bind=\"visible: shouldShowMessage\">\n    You will see this message only when \"shouldShowMessage\" holds a true value.\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        shouldShowMessage: ko.observable(true) // Message initially visible\n    };\n    viewModel.shouldShowMessage(false); // ... now it's hidden\n    viewModel.shouldShowMessage(true); // ... now it's visible again\n</script>\n```\n\n### Parameters\n\n- Main parameter\n\n  - When the parameter resolves to a **false-like value** (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the visible binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you’ve defined using CSS.\n\n  - When the parameter resolves to a **true-like value** (e.g., the boolean value true, or a non-null object or array), the visible binding removes the yourElement.style.display value, causing it to become visible.\n\n    Note that any display style you’ve configured using your CSS rules will then apply (so CSS rules like x { display:table-row } work fine in conjunction with this binding).\n\n  The hidden binding works oppositely—when the parameter is true, it hides the element by setting the display style to none; and when the parameter is false, it removes the display style.\n\n  If this parameter is an observable value, the binding will update the element’s visibility whenever the value changes. If the parameter isn’t observable, it will only set the element’s visibility once and will not update it again later.\n\n- Additional parameters\n\n  - None\n\n### Note: Using functions and expressions to control element visibility\n\nYou can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.\n\nFor example,\n\n``` markup\n<div data-bind=\"visible: myValues().length > 0\">\n    You will see this message only when 'myValues' has at least one member.\n</div>\n\n<script type=\"text/javascript\">\n    var viewModel = {\n        myValues: ko.observableArray([]) // Initially empty, so message hidden\n    };\n    viewModel.myValues.push(\"some value\"); // Now visible\n</script>\n```\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/visible-binding.html](https://knockoutjs.com/documentation/visible-binding.html)"
- name: with and using bindings
  id: with-binding
  summary: The with and using bindings create a new binding context, so that descendant elements are bound in the context of a specified object
  description: "# The \"with\" and \"using\" bindings\n\n### Purpose\n\nThe with and using bindings create a new [binding context](binding-context), so that descendant elements are bound in the context of a specified object. (The differences between these binding are described below under [Parameters](#parameters).)\n\nOf course, you can arbitrarily nest with and using bindings along with the other control-flow bindings such as [if](if-binding) and [foreach](foreach-binding).\n\n### Example 1\n\nHere is a very basic example of switching the binding context to a child object. Notice that in the data-bind attributes, it is *not* necessary to prefix latitude or longitude with coords., because the binding context is switched to coords.\n\n``` markup\n<h1 data-bind=\"text: city\"> </h1>\n<p data-bind=\"using: coords\">\n    Latitude: <span data-bind=\"text: latitude\"> </span>,\n    Longitude: <span data-bind=\"text: longitude\"> </span>\n</p>\n\n<script type=\"text/javascript\">\n    ko.applyBindings({\n        city: \"London\",\n        coords: {\n            latitude:  51.5001524,\n            longitude: -0.1262362\n        }\n    });\n</script>\n```\n\n### Example 2\n\nThis interactive example demonstrates that:\n\n- The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not\n- If you want to access data/functions from parent binding contexts, you can use [special context properties such as $parent and $root](binding-context).\n\nTry it out:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<form data-bind=\"submit: getTweets\">\n    Twitter account:\n    <input data-bind=\"value: twitterName\" />\n    <button type=\"submit\">Get tweets</button>\n</form>\n\n<div data-bind=\"with: resultData\">\n    <h3>Recent tweets fetched at <span data-bind=\"text: retrievalDate\"> </span></h3>\n    <ol data-bind=\"foreach: topTweets\">\n        <li data-bind=\"text: text\"></li>\n    </ol>\n\n    <button data-bind=\"click: $parent.clearResults\">Clear tweets</button>\n</div>\n```\n\n#### Source code: View model\n\n``` js\nfunction AppViewModel() {\n    var self = this;\n    self.twitterName = ko.observable('@example');\n    self.resultData = ko.observable(); // No initial value\n\n    self.getTweets = function() {\n        var name = self.twitterName(),\n            simulatedResults = [\n                { text: name + ' What a nice day.' },\n                { text: name + ' Building some cool apps.' },\n                { text: name + ' Just saw a famous celebrity eating lard. Yum.' }\n            ];\n\n        self.resultData({ retrievalDate: new Date(), topTweets: simulatedResults });\n    }\n\n    self.clearResults = function() {\n        self.resultData(undefined);\n    }\n}\n\nko.applyBindings(new AppViewModel());\n```\n\n### Parameters\n\n- Main parameter\n\n  The object that you want to use as the context for binding descendant elements.\n\n  These bindings differ in how they deal with a value of null or undefined:\n\n  - For the with binding, descendant elements will *not* be bound at all, but will instead be removed from the document.\n  - For the using binding, it is generally incorrect to supply a null or undefined value since it will try to use that value as the context for descendant elements.\n\n  If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. These bindings differ in how they react when the bound value changes:\n\n  - For the with binding, descendant elements will be cleared out, and **a new copy of the markup** will be added to your document and bound in the context of the new value.\n  - For the using binding, descendant elements will remain in the document and their bindings re-evaluated with the new context value.\n\n- Additional parameters\n\n  - as\n\n    The as option allows you set an alias for the new context object. Although you can refer to the object using the $data [context variable](binding-context), it may be useful to give it a more descriptive name using the as option like:\n\n    ``` markup\n    <div data-bind=\"with: currentPerson, as: 'person'\"></div>\n    ```\n\n    Now any descendant binding will be able to refer to person to access this context object. This can be especially useful in scenarios where you have nested contexts and you need to refer to something declared at a higher level in the hierarchy.\n\n  - noChildContext\n\n    The default behavior of the as option is to set a name for the provided object while still also binding the contents to the object. But you may prefer to keep the context unchanged and only set the name of the object. This latter behavior will probably be the default in a future version of Knockout. To turn it on for a specific binding, set the noChildContext option to true. When this option is used along with as, all access to the object must be through the given name, and $data will remain set to the outer viewmodel.\n\n    For the using binding, although you can use this option, it would generally be more efficient and descriptive to use the [let binding](let-binding) instead. Rather than using: currentPerson, as: 'person', noChildContext: true, you’d use let: { person: currentPerson }.\n\n### Note 1: Using “with” or “using” without a container element\n\nJust like other control flow bindings such as [if](if-binding) and [foreach](foreach-binding), you can use with and using without any container element to host it. This is useful if you need to use these bindings in a place where it would not be legal to introduce a new container element just to hold the binding. See the documentation for [if](if-binding) or [foreach](foreach-binding) for more details.\n\nExample:\n\n``` markup\n<ul>\n    <li>Header element</li>\n    <!-- ko with: outboundFlight -->\n        ...\n    <!-- /ko -->\n    <!-- ko with: inboundFlight -->\n        ...\n    <!-- /ko -->\n</ul>\n```\n\nThe \\<!-- ko --\\> and \\<!-- /ko --\\> comments act as start/end markers, defining a “virtual element” that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.\n\n### Note 2: Why are there two similar bindings?\n\nThe using binding was introduced in Knockout 3.5 as a replacement for with when re-rendering descendant elements isn’t desired. Because using re-evaluates descendant bindings instead of re-rendering, each descendant binding will include an additional dependency on the using context.\n\n### Dependencies\n\nNone, other than the core Knockout library.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/with-binding.html](https://knockoutjs.com/documentation/with-binding.html)"
- name: Writable computed observables
  id: computed-writable
  summary: Normally, computed observables have a value that is computed from other observables and are therefore read-only
  description: "# Writable computed observables\n\n*Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations*\n\nNormally, computed observables have a value that is computed from other observables and are therefore *read-only*. What may seem surprising, then, is that it is possible to make computed observables *writable*. You just need to supply your own callback function that does something sensible with written values.\n\nYou can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using *chaining syntax*. For example, myViewModel.fullName('Joe Smith').age(50).\n\nWritable computed observables are a powerful feature with a wide range of possible uses.\n\n### Example 1: Decomposing user input\n\nGoing back to the classic “first name + last name = full name” example, you can turn things back-to-front: make the fullName computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying firstName and lastName observables. In this example, the write callback handles incoming values by splitting the incoming text into “firstName” and “lastName” components, and writing those values back to the underlying observables.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<div>First name: <span data-bind=\"text: firstName\"></span></div>\n<div>Last name: <span data-bind=\"text: lastName\"></span></div>\n<div class=\"heading\">Hello, <input data-bind=\"textInput: fullName\"/></div>\n```\n\n#### Source code: View model\n\n``` js\nfunction MyViewModel() {\n    this.firstName = ko.observable('Planet');\n    this.lastName = ko.observable('Earth');\n\n    this.fullName = ko.pureComputed({\n        read: function () {\n            return this.firstName() + \" \" + this.lastName();\n        },\n        write: function (value) {\n            var lastSpacePos = value.lastIndexOf(\" \");\n            if (lastSpacePos > 0) { // Ignore values with no space character\n                this.firstName(value.substring(0, lastSpacePos)); // Update \"firstName\"\n                this.lastName(value.substring(lastSpacePos + 1)); // Update \"lastName\"\n            }\n        },\n        owner: this\n    });\n}\n\nko.applyBindings(new MyViewModel());\n```\n\nThis is the exact opposite of the [Hello World](https://knockoutjs.com/examples/helloWorld.html) example, in that here the first and last names are not editable, but the combined full name is editable.\n\nThe preceding view model code demonstrates the *single parameter syntax* for initializing computed observables. See the [computed observable reference](computed-reference) for the full list of available options.\n\n### Example 2: Selecting/deselecting all items\n\nWhen presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<div class=\"heading\">\n    <input type=\"checkbox\" data-bind=\"checked: selectedAllProduce\" title=\"Select all/none\"/> Produce\n</div>\n<div data-bind=\"foreach: produce\">\n    <label>\n        <input type=\"checkbox\" data-bind=\"checkedValue: $data, checked: $parent.selectedProduce\"/>\n        <span data-bind=\"text: $data\"></span>\n    </label>\n</div>\n```\n\n#### Source code: View model\n\n``` js\nfunction MyViewModel() {\n    this.produce = [ 'Apple', 'Banana', 'Celery', 'Corn', 'Orange', 'Spinach' ];\n    this.selectedProduce = ko.observableArray([ 'Corn', 'Orange' ]);\n    this.selectedAllProduce = ko.pureComputed({\n        read: function () {\n            // Comparing length is quick and is accurate if only items from the\n            // main array are added to the selected array.\n            return this.selectedProduce().length === this.produce.length;\n        },\n        write: function (value) {\n            this.selectedProduce(value ? this.produce.slice(0) : []);\n        },\n        owner: this\n    });\n}\nko.applyBindings(new MyViewModel());\n```\n\n### Example 3: A value converter\n\nSometimes you might want to represent a data point on the screen in a different format than its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<div>Enter bid price: <input data-bind=\"value: formattedPrice\"/></div>\n<div>(Raw value: <span data-bind=\"text: price\"></span>)</div>\n```\n\n#### Source code: View model\n\n``` js\nfunction MyViewModel() {\n    this.price = ko.observable(25.99);\n\n    this.formattedPrice = ko.pureComputed({\n        read: function () {\n            return '$' + this.price().toFixed(2);\n        },\n        write: function (value) {\n            // Strip out unwanted characters, parse as float, then write the \n            // raw data back to the underlying \"price\" observable\n            value = parseFloat(value.replace(/[^\\.\\d]/g, \"\"));\n            this.price(isNaN(value) ? 0 : value); // Write to underlying storage\n        },\n        owner: this\n    });\n}\n\nko.applyBindings(new MyViewModel());\n```\n\nNow, whenever the user enters a new price, the text box updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can’t enter more than two decimal places, because if they try to, the additional decimal places are removed. Similarly, they can’t enter negative values, because the write callback strips off any minus sign.\n\n### Example 4: Filtering and validating user input\n\nExample 1 showed how a writable computed observable can effectively *filter* its incoming data by choosing not to write certain values back to the underlying observables if they don’t meet some criteria. It ignored full name values that didn’t include a space.\n\nTaking this a step further, you could also toggle an isValid flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There’s an easier way of doing validation (explained below), but first consider the following example, which demonstrates the mechanism:\n\nLive examples are not available on DevDocs, sorry.\n\n#### Source code: View\n\n``` html\n<div>Enter a numeric value: <input data-bind=\"textInput: attemptedValue\"/></div>\n<div class=\"error\" data-bind=\"visible: !lastInputWasValid()\">That's not a number!</div>\n<div>(Accepted value: <span data-bind=\"text: acceptedNumericValue\"></span>)</div>\n```\n\n#### Source code: View model\n\n``` js\nfunction MyViewModel() {\n    this.acceptedNumericValue = ko.observable(123);\n    this.lastInputWasValid = ko.observable(true);\n\n    this.attemptedValue = ko.pureComputed({\n        read: this.acceptedNumericValue,\n        write: function (value) {\n            if (isNaN(value))\n                this.lastInputWasValid(false);\n            else {\n                this.lastInputWasValid(true);\n                this.acceptedNumericValue(value); // Write to underlying storage\n            }\n        },\n        owner: this\n    });\n}\n\nko.applyBindings(new MyViewModel());\n```\n\nNow, acceptedNumericValue will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating acceptedNumericValue.\n\n**Note:** For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the \\<input\\> element. Knockout and jQuery Validation work together nicely, as demonstrated on the [grid editor](https://knockoutjs.com/examples/gridEditor.html) example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.\n\n© Steven Sanderson, the Knockout.js team, and other contributors  \nLicensed under the MIT License.  \n[https://knockoutjs.com/documentation/computed-writable.html](https://knockoutjs.com/documentation/computed-writable.html)"
