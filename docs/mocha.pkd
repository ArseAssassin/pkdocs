---
name: Mocha
slug: mocha
text_format: markdown
generator: src:devdocs
generator_command: src:devdocs
version: null
copyright: |-
  © 2011–2021 JS Foundation and contributors
  Licensed under the Creative Commons Attribution 4.0 International
  License.
  https://mochajs.org/
homepage: https://mochajs.org/

---
- name: About node Flags
  id: index#about-node-flags
  summary: The mocha executable supports all applicable flags which the node executable supports
  description: |-
    ### About `node` Flags

    The `mocha` executable supports all applicable flags which the `node` executable supports.

    These flags vary depending on your version of Node.js.

    `node` flags can be defined in Mocha’s [configuration](#configuring-mocha-nodejs).

    ### `--enable-source-maps`

    > *New in Node.js v12.12.0*

    If the [`--enable-source-maps`](https://nodejs.org/dist/latest-v12.x/docs/api/cli.html#cli_enable_source_maps) flag is passed to mocha, source maps will be collected and used to provide accurate stack traces for transpiled code:

    ``` javascript
    Error: cool
        at Object.<anonymous> (/Users/fake-user/bigco/nodejs-tasks/build/src/index.js:27:7)
            -> /Users/fake-user/bigco/nodejs-tasks/src/index.ts:24:7
    ```
- name: About Option Types
  id: index#about-option-types
  summary: Updated in v6.0.0
  description: |-
    ### About Option Types

    > *Updated in v6.0.0.*

    Each flag annotated of type `[boolean]` in Mocha’s `--help` output can be *negated* by prepending `--no-` to the flag name. For example, `--no-color` will disable Mocha’s color output, which is enabled by default.

    Unless otherwise noted, *all* boolean flags default to `false`.
- name: About V8 Flags
  id: index#about-v8-flags
  summary: Prepend --v8- to any flag listed in the output of node --v8-options (excluding --v8-options itself) to use it
  description: |-
    ### About V8 Flags

    Prepend `--v8-` to any flag listed in the output of `node --v8-options` (excluding `--v8-options` itself) to use it.

    V8 flags can be defined in Mocha’s [configuration](#configuring-mocha-nodejs).
- name: Arrow Functions
  id: index#arrow-functions
  summary: Passing arrow functions (aka “lambdas”) to Mocha is discouraged
  description: |-
    ## Arrow Functions

    Passing [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) (aka “lambdas”) to Mocha is discouraged. Lambdas lexically bind `this` and cannot access the Mocha context. For example, the following code will fail:

    ``` javascript
    describe('my suite', () => {
      it('my test', () => {
        // should set the timeout of this test to 1000 ms; instead will fail
        this.timeout(1000);
        assert.ok(true);
      });
    });
    ```

    *If you do not need to use* Mocha’s context, lambdas should work. Be aware that using lambdas will be more painful to refactor if the need eventually arises!
- name: Assertions
  id: index#assertions
  summary: Mocha allows you to use any assertion library you wish
  description: |-
    ## Assertions

    Mocha allows you to use any assertion library you wish. In the above example, we’re using Node.js’ built-in [assert](https://nodejs.org/api/assert.html) module — but generally, if it throws an `Error`, it will work! This means you can use libraries such as:

    - [should.js](https://github.com/shouldjs/should.js) - BDD style shown throughout these docs
    - [expect.js](https://github.com/LearnBoost/expect.js) - `expect()` style assertions
    - [chai](https://www.chaijs.com/) - `expect()`, `assert()` and `should`-style assertions
    - [better-assert](https://github.com/visionmedia/better-assert) - C-style self-documenting `assert()`
    - [unexpected](https://unexpected.js.org/) - “the extensible BDD assertion toolkit”

    &nbsp;
- name: Asynchronous Hooks
  id: index#asynchronous-hooks
  summary: All hooks (before(), after(), beforeEach(), afterEach()) may be sync or async as well, behaving much like a regular test-case
  description: |-
    ### Asynchronous Hooks

    All hooks (`before()`, `after()`, `beforeEach()`, `afterEach()`) may be sync or async as well, behaving much like a regular test-case. For example, you may wish to populate database with dummy content before each test:

    ``` javascript
    describe('Connection', function() {
      var db = new Connection(),
        tobi = new User('tobi'),
        loki = new User('loki'),
        jane = new User('jane');

      beforeEach(function(done) {
        db.clear(function(err) {
          if (err) return done(err);
          db.save([tobi, loki, jane], done);
        });
      });

      describe('#find()', function() {
        it('respond with matching records', function(done) {
          db.find({type: 'User'}, function(err, res) {
            if (err) return done(err);
            res.should.have.length(3);
            done();
          });
        });
      });
    });
    ```
- name: Available Root Hooks
  id: index#available-root-hooks
  summary: Root hooks work with any interface, but the property names do not change
  description: |-
    ### Available Root Hooks

    Root hooks work with any interface, but *the property names do not change*. In other words, if you are using the `tdd` interface, `suiteSetup` maps to `beforeAll`, and `setup` maps to `beforeEach`.

    Available root hooks and their behavior:

    - `beforeAll`:
      - In **serial** mode (Mocha’s default), *before all tests begin, once only*
      - In **parallel** mode, run *before all tests begin, for each file*
    - `beforeEach`:
      - In **both** modes, run *before each test*
    - `afterAll`:
      - In **serial** mode, run *after all tests end, once only*
      - In **parallel** mode, run *after all tests end, for each file*
    - `afterEach`:
      - In **both** modes, run *after every test*

    > *Tip: If you need to ensure code runs once and only once in any mode, use [global fixtures](#global-fixtures).*

    As with other hooks, `this` refers to to the current context object:

    ``` javascript
    // test/hooks.mjs

    export const mochaHooks = {
      beforeAll() {
        // skip all tests for bob
        if (require('os').userInfo().username === 'bob') {
          return this.skip();
        }
      }
    };
    ```
- name: Browser Configuration
  id: index#browser-configuration
  summary: Mocha options can be set via mocha.setup()
  description: |-
    ### Browser Configuration

    Mocha options can be set via `mocha.setup()`. Examples:

    ``` javascript
    // Use "tdd" interface.  This is a shortcut to setting the interface;
    // any other options must be passed via an object.
    mocha.setup('tdd');

    // This is equivalent to the above.
    mocha.setup({
      ui: 'tdd'
    });

    // Examples of options:
    mocha.setup({
      allowUncaught: true,
      asyncOnly: true,
      bail: true,
      checkLeaks: true,
      dryRun: true,
      forbidOnly: true,
      forbidPending: true,
      global: ['MyLib'],
      retries: 3,
      slow: '100',
      timeout: '2000',
      ui: 'bdd'
    });
    ```
- name: Browser-based notifications
  id: index#browser-based-notifications
  summary: Web notification support is being made available for current versions of modern browsers
  description: |-
    ### Browser-based notifications

    Web notification support is being made available for current versions of modern browsers. Ensure your browser version supports both [promises](https://caniuse.com/#feat=promises) and [web notifications](https://caniuse.com/#feat=notifications). As the Notification API evolved over time, **do not expect** the minimum possible browser version to necessarily work.

    Enable Mocha’s web notifications with a slight modification to your client-side mocha HTML. Add a call to `mocha.growl()` prior to running your tests as shown below:

    ``` javascript
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <title>Mocha Tests</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="https://unpkg.com/mocha/mocha.css" />
      </head>
      <body>
        <div id="mocha"></div>

        <script src="https://unpkg.com/chai/chai.js"></script>
        <script src="https://unpkg.com/mocha/mocha.js"></script>

        <script class="mocha-init">
          mocha.setup('bdd');
          mocha.growl(); // <-- Enables web notifications
        </script>
        <script src="test.spec.js"></script>
        <script class="mocha-exec">
          mocha.run();
        </script>
      </body>
    </html>
    ```
- name: Browser-specific Option(s)
  id: index#browser-specific-options
  summary: Browser Mocha supports many, but not all cli options
  description: |-
    ### Browser-specific Option(s)

    Browser Mocha supports many, but not all [cli options](#command-line-usage). To use a [cli option](#command-line-usage) that contains a “-”, please convert the option to camel-case, (eg. `check-leaks` to `checkLeaks`).

    #### [\#](#options-that-differ-slightly-from-cli-options) Options that differ slightly from [cli options](#command-line-usage):

    `reporter`*{string\|constructor}* You can pass a reporter’s name or a custom reporter’s constructor. You can find **recommended** reporters for the browser [here](#reporting). It is possible to use [built-in reporters](#reporters) as well. Their employment in browsers is neither recommended nor supported, open the console to see the test results.

    #### [\#](#options-that-only-function-in-browser-context) Options that *only* function in browser context:

    `noHighlighting`*{boolean}* If set to `true`, do not attempt to use syntax highlighting on output test code.
- name: Caveats About Testing in Parallel
  id: index#caveats-about-testing-in-parallel
  summary: Some types of tests are not so well-suited to run in parallel
  description: |-
    ### Caveats About Testing in Parallel

    Some types of tests are *not* so well-suited to run in parallel. For example, extremely timing-sensitive tests, or tests which make I/O requests to a limited pool of resources (such as opening ports, or automating browser windows, hitting a test DB, or remote server, etc.).

    Free-tier cloud CI services may not provide a suitable multi-core container or VM for their build agents. Regarding expected performance gains in CI: your mileage may vary. It may help to use a conditional in a `.mocharc.js` to check for `process.env.CI`, and adjust the job count as appropriate.

    It’s unlikely (but not impossible) to see a performance gain from a [job count](#-jobs-count-j-count) *greater than* the number of available CPU cores. That said, *play around with the job count*–there’s no one-size-fits all, and the unique characteristics of your tests will determine the optimal number of jobs; it may even be that fewer is faster!
- name: Configuration Format
  id: index#configuration-format
  summary: For more configuration examples, see the example/config directory on GitHub
  description: |-
    ### Configuration Format

    - Any “boolean” flag (which doesn’t require a parameter, such as `--bail`), can be specified using a boolean value, e.g.: `"bail": true`.
    - Any “array”-type option (see `mocha --help` for a list) can be a single string value.
    - For options containing a dash (`-`), the option name can be specified using camelCase.
    - Aliases are valid names, e.g., `R` instead of `reporter`.
    - Test files can be specified using `spec`, e.g., `"spec": "test/**/*.spec.js"`.
    - Flags to `node` are *also* supported in configuration files. Use caution, as these can vary between versions of Node.js!

    **For more configuration examples, see the [`example/config`](https://github.com/mochajs/mocha/tree/master/example/config) directory on GitHub.**
- name: Configuring Mocha (Node.js)
  id: index#configuring-mocha-nodejs
  summary: null
  description: |-
    ## Configuring Mocha (Node.js)

    > *New in v6.0.0*

    Mocha supports configuration files, typical of modern command-line tools, in several formats:

    - **JavaScript**: Create a `.mocharc.js` (or `.mocharc.cjs` when using [`"type"="module"`](#nodejs-native-esm-support) in your `package.json`) in your project’s root directory, and export an object (`module.exports = {/* ... */}`) containing your configuration.
    - **YAML**: Create a `.mocharc.yaml` (or `.mocharc.yml`) in your project’s root directory.
    - **JSON**: Create a `.mocharc.json` (or `.mocharc.jsonc`) in your project’s root directory. Comments — while not valid JSON — are allowed in this file, and will be ignored by Mocha.
    - **package.json**: Create a `mocha` property in your project’s `package.json`.

    &nbsp;
- name: Current Limitations
  id: index#current-limitations
  summary: null
  description: |-
    ### Current Limitations

    - [Watch mode](#-watch-w) does not support ES Module test files
    - [Custom reporters](#third-party-reporters) and [custom interfaces](#interfaces) can only be CommonJS files
    - [Configuration file](#configuring-mocha-nodejs) can only be a CommonJS file (`.mocharc.js` or `.mocharc.cjs`)
    - When using module-level mocks via libs like `proxyquire`, `rewiremock` or `rewire`, hold off on using ES modules for your test files. You can switch to using `testdouble`, which does support ESM.

    &nbsp;
- name: Custom Locations
  id: index#custom-locations
  summary: You can specify a custom location for your configuration file with the --config <path> option
  description: |-
    ### Custom Locations

    You can specify a custom location for your configuration file with the `--config <path>` option. Mocha will use the file’s extension to determine how to parse the file, and will assume JSON if unknown.

    You can specify a custom `package.json` location as well, using the `--package <path>` option.
- name: Defining a Root Hook Plugin
  id: index#defining-a-root-hook-plugin
  summary: A Root Hook Plugin file is a script which exports (via module.exports) a mochaHooks property
  description: |-
    ### Defining a Root Hook Plugin

    A Root Hook Plugin file is a script which exports (via `module.exports`) a `mochaHooks` property. It is loaded via `--require <file>`.

    Here’s a simple example which defines a root hook, written using CJS and ESM syntax.

    #### [\#](#with-commonjs) With CommonJS

    ``` javascript
    // test/hooks.js

    exports.mochaHooks = {
      beforeEach(done) {
        // do something before every test
        done();
      }
    };
    ```

    #### [\#](#with-es-modules) With ES Modules

    We’re using the `.mjs` extension in these examples.

    > *Tip: If you’re having trouble getting ES modules to work, refer to [the Node.js documentation](https://nodejs.org/api/esm.html).*

    ``` javascript
    // test/hooks.mjs

    export const mochaHooks = {
      beforeEach(done) {
        // do something before every test
        done();
      }
    };
    ```

    > *Note: Further examples will use ESM syntax.*
- name: Describing Hooks
  id: index#describing-hooks
  summary: Any hook can be invoked with an optional description, making it easier to pinpoint errors in your tests
  description: |-
    ### Describing Hooks

    Any hook can be invoked with an optional description, making it easier to pinpoint errors in your tests. If a hook is given a named function, that name will be used if no description is supplied.

    ``` javascript
    beforeEach(function() {
      // beforeEach hook
    });

    beforeEach(function namedFun() {
      // beforeEach:namedFun
    });

    beforeEach('some description', function() {
      // beforeEach:some description
    });
    ```
- name: Desktop Notification Support
  id: index#desktop-notification-support
  summary: Desktop notifications allow asynchronous communication of events without forcing you to react to a notification immediately
  description: |-
    ## Desktop Notification Support

    Desktop notifications allow asynchronous communication of events without forcing you to react to a notification immediately. Their appearance and specific functionality vary across platforms. They typically disappear automatically after a short delay, but their content is often stored in some manner that allows you to access past notifications.

    [Growl](http://growl.info/) was an early notification system implementation for OS X and Windows, hence, the name of Mocha’s `--growl` option.

    Once enabled, when your root suite completes test execution, a desktop notification should appear informing you whether your tests passed or failed.
- name: Detects Multiple Calls to done()
  id: index#detects-multiple-calls-to-done
  summary: If you use callback-based async tests, Mocha will throw an error if done() is called multiple times
  description: |-
    ## Detects Multiple Calls to `done()`

    If you use callback-based async tests, Mocha will throw an error if `done()` is called multiple times. This is handy for catching accidental double callbacks.

    ``` javascript
    it('double done', function(done) {
      // Calling `done()` twice is an error
      setImmediate(done);
      setImmediate(done);
    });
    ```

    Running the above test will give you the below error message:

    ``` javascript
    $ ./node_modules/.bin/mocha mocha.test.js


      ✓ double done
      1) double done

      1 passing (6ms)
      1 failing

      1) double done:
         Error: done() called multiple times
          at Object.<anonymous> (mocha.test.js:1:63)
          at require (internal/module.js:11:18)
          at Array.forEach (<anonymous>)
          at startup (bootstrap_node.js:187:16)
          at bootstrap_node.js:608:3
    ```
- name: Diffs
  id: index#diffs
  summary: Mocha supports the err.expected and err.actual properties of any thrown AssertionErrors from an assertion library
  description: |-
    ## Diffs

    Mocha supports the `err.expected` and `err.actual` properties of any thrown `AssertionError`s from an assertion library. Mocha will attempt to display the difference between what was expected, and what the assertion actually saw. Here’s an example of a “string” diff using `--inline-diffs`:
- name: Doc
  id: index#doc
  summary: The Doc reporter outputs a hierarchical HTML body representation of your tests
  description: |-
    ### Doc

    Alias: `Doc`, `doc`

    The Doc reporter outputs a hierarchical HTML body representation of your tests. Wrap it with a header, footer, and some styling, then you have some fantastic documentation!

    For example, suppose you have the following JavaScript:

    ``` javascript
    describe('Array', function() {
      describe('#indexOf()', function() {
        it('should return -1 when the value is not present', function() {
          [1, 2, 3].indexOf(5).should.equal(-1);
          [1, 2, 3].indexOf(0).should.equal(-1);
        });
      });
    });
    ```

    The command `mocha --reporter doc array` would yield:

    ``` javascript
    <section class="suite">
      <h1>Array</h1>
      <dl>
        <section class="suite">
          <h1>#indexOf()</h1>
          <dl>
            <dt>should return -1 when the value is not present</dt>
            <dd>
              <pre><code>[1,2,3].indexOf(5).should.equal(-1);
    [1,2,3].indexOf(0).should.equal(-1);</code></pre>
            </dd>
          </dl>
        </section>
      </dl>
    </section>
    ```

    The SuperAgent request library [test documentation](https://visionmedia.github.io/superagent/docs/test.html) was generated with Mocha’s doc reporter using this Bash command:

    ``` javascript
    $ mocha --reporter=doc | cat docs/head.html - docs/tail.html > docs/test.html
    ```

    View SuperAgent’s [Makefile](https://github.com/visionmedia/superagent/blob/master/Makefile) for reference.
- name: Dot Matrix
  id: index#dot-matrix
  summary: The Dot Matrix reporter is a series of characters which represent test cases
  description: |-
    ### Dot Matrix

    Alias: `Dot`, `dot`

    The Dot Matrix reporter is a series of characters which represent test cases. Failures highlight in red exclamation marks (`!`), pending tests with a blue comma (`,`), and slow tests as yellow. Good if you prefer minimal output.
- name: Dynamically Generating Tests
  id: index#dynamically-generating-tests
  summary: Given Mocha’s use of function expressions to define suites and test cases, it’s straightforward to generate your tests dynamically
  description: |-
    ## Dynamically Generating Tests

    Given Mocha’s use of function expressions to define suites and test cases, it’s straightforward to generate your tests dynamically. No special syntax is required — plain ol’ JavaScript can be used to achieve functionality similar to “parameterized” tests, which you may have seen in other frameworks.

    Take the following example:

    ``` javascript
    const assert = require('assert');

    function add(args) {
      return args.reduce((prev, curr) => prev + curr, 0);
    }

    describe('add()', function() {
      const tests = [
        {args: [1, 2], expected: 3},
        {args: [1, 2, 3], expected: 6},
        {args: [1, 2, 3, 4], expected: 10}
      ];

      tests.forEach(({args, expected}) => {
        it(`correctly adds ${args.length} args`, function() {
          const res = add(args);
          assert.strictEqual(res, expected);
        });
      });
    });
    ```

    The above code will produce a suite with three specs:

    ``` javascript
    $ mocha

      add()
        ✓ correctly adds 2 args
        ✓ correctly adds 3 args
        ✓ correctly adds 4 args
    ```

    Tests added inside a `.forEach` handler often don’t play well with editor plugins, especially with “right-click run” features. Another way to parameterize tests is to generate them with a closure. This following example is equivalent to the one above:

    ``` javascript
    describe('add()', function() {
      const testAdd = ({args, expected}) =>
        function() {
          const res = add(args);
          assert.strictEqual(res, expected);
        };

      it('correctly adds 2 args', testAdd({args: [1, 2], expected: 3}));
      it('correctly adds 3 args', testAdd({args: [1, 2, 3], expected: 6}));
      it('correctly adds 4 args', testAdd({args: [1, 2, 3, 4], expected: 10}));
    });
    ```

    With `top-level await` you can collect your test data in a dynamic and asynchronous way while the test file is being loaded:

    ``` javascript
    // testfile.mjs
    import assert from 'assert';

    // top-level await: Node >= v14.8.0 with ESM test file
    const tests = await new Promise(resolve => {
      setTimeout(() => {
        resolve([
          {args: [1, 2], expected: 3},
          {args: [1, 2, 3], expected: 6},
          {args: [1, 2, 3, 4], expected: 10}
        ]);
      }, 5000);
    });

    // in suites ASYNCHRONOUS callbacks are NOT supported
    describe('add()', function() {
      tests.forEach(({args, expected}) => {
        it(`correctly adds ${args.length} args`, function() {
          const res = args.reduce((sum, curr) => sum + curr, 0);
          assert.strictEqual(res, expected);
        });
      });
    });
    ```
- name: Editor Plugins
  id: index#editor-plugins
  summary: null
  description: |-
    ## Editor Plugins

    The following editor-related packages are available:
- name: Emacs
  id: index#emacs
  summary: Emacs support for running Mocha tests is available via a 3rd party package mocha.el
  description: |-
    ### Emacs

    [Emacs](https://www.gnu.org/software/emacs/) support for running Mocha tests is available via a 3rd party package [mocha.el](https://github.com/scottaj/mocha.el). The package is available on MELPA, and can be installed via `M-x package-install mocha`.
- name: Error Codes
  id: index#error-codes
  summary: When Mocha itself throws exception, the associated Error will have a code property
  description: |-
    ## Error Codes

    > *New in v6.0.0*

    When Mocha itself throws exception, the associated `Error` will have a `code` property. Where applicable, consumers should check the `code` property instead of string-matching against the `message` property. The following table describes these error codes:

    | Code                             | Description                                                  |
    |----------------------------------|--------------------------------------------------------------|
    | ERR_MOCHA_INVALID_ARG_TYPE       | wrong type was passed for a given argument                   |
    | ERR_MOCHA_INVALID_ARG_VALUE      | invalid or unsupported value was passed for a given argument |
    | ERR_MOCHA_INVALID_EXCEPTION      | a falsy or otherwise underspecified exception was thrown     |
    | ERR_MOCHA_INVALID_INTERFACE      | interface specified in options not found                     |
    | ERR_MOCHA_INVALID_REPORTER       | reporter specified in options not found                      |
    | ERR_MOCHA_NO_FILES_MATCH_PATTERN | test file(s) could not be found                              |
    | ERR_MOCHA_UNSUPPORTED            | requested behavior, option, or parameter is unsupported      |
- name: Exclusive Tests are Disallowed
  id: index#exclusive-tests-are-disallowed
  summary: You cannot use it.only, describe.only, this.only(), etc., in parallel mode
  description: |-
    ### Exclusive Tests are Disallowed

    **You cannot use `it.only`, `describe.only`, `this.only()`, etc., in parallel mode.** This is for the same reason as the incompatible reporters noted above: in parallel mode, Mocha does not load all files and suites into memory before running tests.

    Suggested workarounds:

    1.  Use [`--grep`](#-grep-regexp-g-regexp) or [`--fgrep`](http://localhost:8080/#-fgrep-string-f-string) instead; it’s not particularly efficient, but it will work.
    2.  Don’t use parallel mode. Likely, you won’t be running very many exclusive tests, so you won’t see a great benefit from parallel mode anyhow.

    > *TIP: If parallel mode is defined in your config file, you can temporarily disable it on the command-line by using either the `--no-parallel` flag or reducing the job count, e.g., `--jobs=0`.*
- name: Extending Configuration
  id: index#extending-configuration
  summary: Configurations can inherit from other modules using the extends keyword
  description: |-
    ### Extending Configuration

    Configurations can inherit from other modules using the `extends` keyword. See [here](http://yargs.js.org/docs/#api-configobject-extends-keyword) for more information.
- name: File Order is Non-Deterministic
  id: index#file-order-is-non-deterministic
  summary: In parallel mode, Mocha does not guarantee the order in which test files will run, nor which worker process runs them
  description: |-
    ### File Order is Non-Deterministic

    In parallel mode, Mocha does not guarantee the order in which test files will run, nor which worker process runs them.

    Because of this, the following options, which depend on order, *cannot be used* in parallel mode:

    - [`--file`](#-file-filedirectoryglob)
    - [`--sort`](#-sort-s)
    - [`--delay`](#delayed-root-suite)

    &nbsp;
- name: Global Fixtures
  id: index#global-fixtures
  summary: At first glance, global fixtures seem similar to root hooks
  description: |-
    ## Global Fixtures

    > New in v8.2.0

    At first glance, *global fixtures* seem similar to [root hooks](#root-hook-plugins). However, unlike root hooks, global fixtures:

    1.  Are *guaranteed* to execute *once and only once*
    2.  Work identically parallel mode, watch mode, and serial mode
    3.  Do not share a context with tests, suites, or other hooks

    There are two types of global fixtures: [global setup fixtures](#global-setup-fixtures) and [global teardown fixtures](#global-teardown-fixtures).
- name: Global Setup Fixtures
  id: index#global-setup-fixtures
  summary: To use it, load this file when running Mocha via mocha --require fixtures.cjs (or whatever you have named the file)
  description: |-
    ### Global Setup Fixtures

    To create a global setup fixture, export `mochaGlobalSetup` from a script, e.g.,:

    ``` javascript
    // fixtures.cjs

    // can be async or not
    exports.mochaGlobalSetup = async function() {
      this.server = await startSomeServer({port: process.env.TEST_PORT});
      console.log(`server running on port ${this.server.port}`);
    };
    ```

    …or an ES module:

    ``` javascript
    // fixtures.mjs

    // can be async or not
    export async function mochaGlobalSetup() {
      this.server = await startSomeServer({port: process.env.TEST_PORT});
      console.log(`server running on port ${this.server.port}`);
    }
    ```

    To use it, load this file when running Mocha via `mocha --require fixtures.cjs` (or whatever you have named the file).

    > Remember: you can define “requires” in a [configuration file](#configuring-mocha-nodejs).

    Now, before Mocha loads and runs your tests, it will execute the above global setup fixture, starting a server for testing. This won’t shut *down* the server when Mocha is done, however! To do that, use a [*global teardown fixture*](#global-teardown-fixtures).
- name: Global Teardown Fixtures
  id: index#global-teardown-fixtures
  summary: You’ll note that we used this in the fixture examples
  description: |-
    ### Global Teardown Fixtures

    Just like a [global setup fixture](#global-setup-fixtures), a *global teardown fixture* can be created by exporting from a “required” script (we can put both types of fixtures in a single file):

    ``` javascript
    // fixtures.cjs, cont'd

    // can be async or not
    exports.mochaGlobalTeardown = async function() {
      await this.server.stop();
      console.log('server stopped!');
    };
    ```

    …or an ES module:

    ``` javascript
    // fixtures.mjs, cont'd

    // can be async or not
    export async function mochaGlobalTeardown() {
      await this.server.stop();
      console.log('server stopped!');
    }
    ```

    You’ll note that we used `this` in the fixture examples. Global setup fixtures and global teardown fixtures *share a context*, which means we can add properties to the context object (`this`) in the setup fixture, and reference them later in the teardown fixture. This is more useful when the fixtures are in separate files, since you can just use JS’ variable scoping rules instead ([example below](#when-not-to-use-global-fixtures)).

    As explained [above](#global-fixtures)–and [below](#when-not-to-use-global-fixtures)–test files *do not* have access to this context object.
- name: Grep
  id: index#grep
  summary: The browser may use the --grep as functionality
  description: |-
    ### Grep

    The browser may use the `--grep` as functionality. Append a query-string to your URL: `?grep=api`.
- name: Hook-level
  id: index#hook-level
  summary: Again, use this.timeout(0) to disable the timeout for a hook
  description: |-
    ### Hook-level

    Hook-level timeouts may also be applied:

    ``` javascript
    describe('a suite of tests', function() {
      beforeEach(function(done) {
        this.timeout(3000); // A very long environment setup.
        setTimeout(done, 2500);
      });
    });
    ```

    Again, use `this.timeout(0)` to disable the timeout for a hook.

    > In v3.0.0 or newer, a parameter passed to `this.timeout()` greater than the [maximum delay value](https://developer.mozilla.org/docs/Web/API/WindowTimers/setTimeout#Maximum_delay_value) will cause the timeout to be disabled. In v8.0.0 or newer, `this.enableTimeouts()` has been removed. **Warning:** With async tests if you disable timeouts via `this.timeout(0)` and then do not call `done()`, your test will exit silently.
- name: HTML Reporter
  id: index#html-reporter
  summary: The HTML reporter is not intended for use on the command-line
  description: |-
    ### HTML Reporter

    Alias: `HTML`, `html`

    **The HTML reporter is not intended for use on the command-line.**
- name: Ignoring Config Files
  id: index#ignoring-config-files
  summary: To skip looking for config files, use --no-config
  description: |-
    ### Ignoring Config Files

    To skip looking for config files, use `--no-config`. Likewise, use `--no-package` to stop Mocha from looking for configuration in a `package.json`.
- name: Interfaces
  id: index#interfaces
  summary: Mocha’s “interface” system allows developers to choose their style of DSL
  description: |-
    ## Interfaces

    Mocha’s “interface” system allows developers to choose their style of DSL. Mocha has **BDD**, **TDD**, **Exports**, **QUnit** and **Require**-style interfaces.
- name: JetBrains
  id: index#jetbrains
  summary: JetBrains provides a NodeJS plugin for its suite of IDEs (IntelliJ IDEA, WebStorm, etc.), which contains a Mocha test runner, among other things
  description: |-
    ### JetBrains

    [JetBrains](https://www.jetbrains.com/) provides a [NodeJS plugin](https://www.jetbrains.com/idea/features/nodejs.html) for its suite of IDEs (IntelliJ IDEA, WebStorm, etc.), which contains a Mocha test runner, among other things.

    The plugin is titled **NodeJS**, and can be installed via **Preferences** \> **Plugins**, assuming your license allows it.
- name: JSON
  id: index#json
  summary: The JSON reporter outputs a single large JSON object when the tests have completed (failures or not)
  description: |-
    ### JSON

    Alias: `JSON`, `json`

    The JSON reporter outputs a single large JSON object when the tests have completed (failures or not).
- name: JSON Stream
  id: index#json-stream
  summary: The JSON Stream reporter outputs newline-delimited JSON “events” as they occur, beginning with a “start” event, followed by test passes or failures, and then the final “end” event
  description: |-
    ### JSON Stream

    Alias: `JSONStream`, `json-stream`

    The JSON Stream reporter outputs newline-delimited JSON “events” as they occur, beginning with a “start” event, followed by test passes or failures, and then the final “end” event.
- name: Landing Strip
  id: index#landing-strip
  summary: null
  description: |-
    ### Landing Strip

    Alias: `Landing`, `landing`

    The Landing Strip reporter is a gimmicky test reporter simulating a plane landing 😃 unicode ftw
- name: Limited Reporter API for Third-Party Reporters
  id: index#limited-reporter-api-for-third-party-reporters
  summary: Third-party reporters may encounter issues when attempting to access non-existent properties within Test, Suite, and Hook objects
  description: |-
    ### Limited Reporter API for Third-Party Reporters

    Third-party reporters may encounter issues when attempting to access non-existent properties within `Test`, `Suite`, and `Hook` objects. If a third-party reporter does not work in parallel mode (but otherwise works in serial mode), please [file an issue](https://github.com/mochajs/mocha/issues/new).
- name: List
  id: index#list
  summary: The List reporter outputs a simple specifications list as test cases pass or fail, outputting the failure details at the bottom of the output
  description: |-
    ### List

    Alias: `List`, `list`

    The List reporter outputs a simple specifications list as test cases pass or fail, outputting the failure details at the bottom of the output.
- name: Markdown
  id: index#markdown
  summary: The Markdown reporter generates a markdown TOC and body for your test suite
  description: |-
    ### Markdown

    Alias: `Markdown`, `markdown`

    The Markdown reporter generates a markdown TOC and body for your test suite. This is great if you want to use the tests as documentation within a Github wiki page, or a markdown file in the repository that Github can render. For example, here is the Connect [test output](https://github.com/senchalabs/connect/blob/90a725343c2945aaee637e799b1cd11e065b2bff/tests.md).
- name: Merging
  id: index#merging
  summary: Mocha will also merge any options found in package.json into its run-time configuration
  description: |-
    ### Merging

    Mocha will also *merge* any options found in `package.json` into its run-time configuration. In case of conflict, the priority is:

    1.  Arguments specified on command-line
    2.  Configuration file (`.mocharc.js`, `.mocharc.yml`, etc.)
    3.  `mocha` property of `package.json`

    Options which can safely be repeated (e.g., `--require`) will be *concatenated*, with higher-priorty configuration sources appearing earlier in the list. For example, a `.mocharc.json` containing `"require": "bar"`, coupled with execution of `mocha --require foo`, would cause Mocha to require `foo`, then `bar`, in that order.
- name: Migrating a Library to use Root Hook PLugins
  id: index#migrating-a-library-to-use-root-hook-plugins
  summary: null
  description: |-
    ### Migrating a Library to use Root Hook PLugins

    If you’re a library maintainer, and your library uses root hooks, you can migrate by refactoring your entry point:

    - Your library should *always* export a [`mochaHooks` object](#defining-a-root-hook-plugin).
    - To maintain backwards compatibility, run your root hooks *if and only if* `global.beforeEach` (or other relevant hook) exists.
    - Instruct your users to `--require <your-package>` when running `mocha`.

    &nbsp;
- name: Migrating Tests to use Root Hook Plugins
  id: index#migrating-tests-to-use-root-hook-plugins
  summary: 'NOTE: Careful! after becomes afterAll and before becomes beforeAll'
  description: |-
    ### Migrating Tests to use Root Hook Plugins

    To migrate your tests using root hooks to a root hook plugin:

    1.  Find your root hooks (hooks defined *outside* of a suite–usually `describe()` callback).
    2.  Create a new file, e.g., `test/hooks.js`.
    3.  *Move* your root hooks into `test/hooks.js`.
    4.  In `test/hooks.js`, make your hooks a member of an exported `mochaHooks` property.
    5.  Use `--require test/hooks.js` (even better: use a [config file](#configuring-mocha-nodejs) with `{"require": "test/hooks.js"}`) when running your tests.

    For example, given the following file, `test/test.spec.js`, containing root hooks:

    ``` javascript
    // test/test.spec.js

    beforeEach(function() {
      // global setup for all tests
    });

    after(function() {
      // one-time final cleanup
    });

    describe('my test suite', function() {
      it('should have run my global setup', function() {
        // make assertion
      });
    });
    ```

    Your `test/hooks.js` (for this example, a CJS module) should contain:

    ``` javascript
    // test/hooks.js

    exports.mochaHooks = {
      beforeEach: function() {
        // global setup for all tests
      },
      afterAll: function() {
        // one-time final cleanup
      }
    };
    ```

    > *NOTE: Careful! `after` becomes `afterAll` and `before` becomes `beforeAll`.*

    Your original `test/test.spec.js` should now contain:

    ``` javascript
    // test/test.spec.js

    describe('my test suite', function() {
      it('should have run my global setup', function() {
        // make assertion
      });
    });
    ```

    Running `mocha --require test/hooks.js test/test.spec.js` will run as before (and is now ready to be used with [`--parallel`](#-parallel-p)).
- name: Min
  id: index#min
  summary: The Min reporter displays the summary only, while still outputting errors on failure
  description: |-
    ### Min

    Alias: `Min`, `min`

    The Min reporter displays the summary only, while still outputting errors on failure. This reporter works great with `--watch` as it clears the terminal in order to keep your test summary at the top.
- name: Mocha Sidebar (VS Code)
  id: index#mocha-sidebar-vs-code
  summary: Mocha sidebar is the most complete mocha extension for vs code
  description: "### Mocha Sidebar (VS Code)\n\n[Mocha sidebar](https://marketplace.visualstudio.com/items?itemName=maty.vscode-mocha-sidebar) is the most complete mocha extension for vs code.\n\n#### [\\#](#features-2) Features\n\n- see all tests in VS Code sidebar menu\n- run & debug tests for each level hierarchy from all tests to a single test (and each suite)\n- auto run tests on file save\n- see tests results directly in the code editor\n\n## Examples\n\nReal live example code:\n\n- [Mocha examples](https://github.com/mochajs/mocha-examples)\n- [Express](https://github.com/visionmedia/express/tree/master/test)\n- [Connect](https://github.com/senchalabs/connect/tree/master/test)\n- [SuperAgent](https://github.com/visionmedia/superagent/tree/master/test/node)\n- [WebSocket.io](https://github.com/LearnBoost/websocket.io/tree/master/test)\n- [Mocha tests](https://github.com/mochajs/mocha/tree/master/test)\n\n## Testing Mocha\n\nTo run Mocha’s tests, you will need GNU Make or compatible; Cygwin should work.\n\n``` javascript\n$ cd /path/to/mocha\n$ npm install\n$ npm test\n```\n\n© 2011–2021 JS Foundation and contributors  \nLicensed under the Creative Commons Attribution 4.0 International License.  \n[https://mochajs.org/](https://mochajs.org/)"
- name: Multiple Root Hook Plugins
  id: index#multiple-root-hook-plugins
  summary: Multiple root hook plugins can be registered by using --require multiple times
  description: |-
    ### Multiple Root Hook Plugins

    Multiple root hook plugins can be registered by using `--require` multiple times. For example, to register the root hooks in `hooks-a.js` and `hooks-b.js`, use `--require hooks-a.js --require hooks-b.js`. These will be registered (and run) *in order*.
- name: Multiple Root Hooks in a Single Plugin
  id: index#multiple-root-hooks-in-a-single-plugin
  summary: Multiple root hooks can be defined in a single plugin, for organizational purposes
  description: |-
    ### Multiple Root Hooks in a Single Plugin

    Multiple root hooks can be defined in a single plugin, for organizational purposes. For example:

    ``` javascript
    // test/hooks.mjs

    export const mochaHooks = {
      beforeEach: [
        function(done) {
          // do something before every test,
          // then run the next hook in this array
        },
        async function() {
          // async or Promise-returning functions allowed
        }
      ]
    };
    ```
- name: No Browser Support
  id: index#no-browser-support
  summary: Parallel mode is only available in Node.js, for now
  description: |-
    ### No Browser Support

    Parallel mode is only available in Node.js, for now.
- name: Node-based notifications
  id: index#node-based-notifications
  summary: In order to use desktop notifications with the command-line interface (CLI), you must first install some platform-specific prerequisite software
  description: |-
    ### Node-based notifications

    In order to use desktop notifications with the command-line interface (CLI), you **must** first install some platform-specific prerequisite software. Instructions for doing so can be found [here](https://github.com/mochajs/mocha/wiki/Growl-Notifications).

    Enable Mocha’s desktop notifications as follows:

    ``` javascript
    $ mocha --growl
    ```
- name: Node.JS native ESM support
  id: index#nodejs-native-esm-support
  summary: Mocha supports writing your tests as ES modules, and not just using CommonJS
  description: |-
    ## Node.JS native ESM support

    > *New in v7.1.0*

    Mocha supports writing your tests as ES modules, and not just using CommonJS. For example:

    ``` javascript
    // test.mjs
    import {add} from './add.mjs';
    import assert from 'assert';

    it('should add to numbers from an es module', () => {
      assert.equal(add(3, 5), 8);
    });
    ```

    To enable this you don’t need to do anything special. Write your test file as an ES module. In Node.js this means either ending the file with a `.mjs` extension, or, if you want to use the regular `.js` extension, by adding `"type": "module"` to your `package.json`. More information can be found in the [Node.js documentation](https://nodejs.org/api/esm.html).
- name: Nyan
  id: index#nyan
  summary: null
  description: |-
    ### Nyan

    Alias: `Nyan`, `nyan`

    The Nyan reporter is exactly what you might expect:
- name: Parallel Mode
  id: index#parallel-mode
  summary: null
  description: |-
    ### Parallel Mode

    1.  Repeat steps 1 through 6 from [Serial Mode](#serial-mode) above, skipping reporter validation
    2.  All test files found are put into a queue (they are *not* loaded by the main process)
    3.  Mocha runs [global setup fixtures](#global-setup-fixtures), if any
    4.  Mocha creates a pool of subprocesses (“workers”)
    5.  *Immediately before* a worker runs the first test it receives, the worker “bootstraps” itself by:
        1.  Loading all `--require`’d modules
        2.  Registering any root hook plugins
        3.  *Ignoring* global fixtures and custom reporters
        4.  Asserting the built-in or custom interface is valid
    6.  When a worker receives a test file to run, the worker creates a new Mocha instance *for the single test file*, and:
    7.  The worker repeats step 8 from [above](#serial-mode)
    8.  The worker repeats step 10 from [above](#serial-mode), with the caveat that the worker *does not* report test results directly; it holds them in a memory buffer
    9.  When the worker completes the test file, buffered results are returned to the main process, which then gives them to the user-specified reporter (`spec` by default)
    10. The worker makes itself available to the pool; the pool gives the worker another test file to run, if any remain
    11. Mocha prints a final summary/epilog, if applicable
    12. Mocha runs [global teardown fixtures](#global-teardown-fixtures), if any

    &nbsp;
- name: Parallel Tests
  id: index#parallel-tests
  summary: New in v.8.0.0
  description: |-
    ## Parallel Tests

    > *New in v.8.0.0.*

    Depending on the number and nature of your tests, you may find a significant performance benefit when running tests in parallel (using the [`--parallel`](#-parallel-p) flag).

    Parallel tests should work out-of-the box for many use cases. However, you must be aware of some important implications of the behavior.

    > *Note: Authors of third-party libraries built on Mocha should read this!*
- name: Pending Tests
  id: index#pending-tests
  summary: Pending tests will be included in the test results, and marked as pending
  description: |-
    ## Pending Tests

    “Pending”–as in “someone should write these test cases eventually”–test-cases are those *without* a callback:

    ``` javascript
    describe('Array', function() {
      describe('#indexOf()', function() {
        // pending test below
        it('should return -1 when the value is not present');
      });
    });
    ```

    Pending tests will be included in the test results, and marked as pending. A pending test is not considered a failed test.

    Read the [inclusive tests section](#inclusive-tests) for an example of conditionally marking a test as pending via `this.skip()`.
- name: Priorities
  id: index#priorities
  summary: If no custom path was given, and if there are multiple configuration files in the same directory, Mocha will search for — and use — only one
  description: |-
    ### Priorities

    If no custom path was given, and if there are multiple configuration files in the same directory, Mocha will search for — and use — only one. The priority is:

    1.  `.mocharc.js`
    2.  `.mocharc.yaml`
    3.  `.mocharc.yml`
    4.  `.mocharc.jsonc`
    5.  `.mocharc.json`

    &nbsp;
- name: Progress
  id: index#progress
  summary: null
  description: |-
    ### Progress

    Alias: `Progress`, `progress`

    The Progress reporter implements a simple progress-bar:
- name: QUnit
  id: index#qunit
  summary: The QUnit-inspired interface matches the “flat” look of QUnit, where the test suite title is defined before the test-cases
  description: |-
    ### QUnit

    The [QUnit](https://qunitjs.com/)-inspired interface matches the “flat” look of QUnit, where the test suite title is defined *before* the test-cases. Like TDD, it uses `suite()` and `test()`, but resembling BDD, it also contains `before()`, `after()`, `beforeEach()`, and `afterEach()`.

    ``` javascript
    function ok(expr, msg) {
      if (!expr) throw new Error(msg);
    }

    suite('Array');

    test('#length', function() {
      var arr = [1, 2, 3];
      ok(arr.length == 3);
    });

    test('#indexOf()', function() {
      var arr = [1, 2, 3];
      ok(arr.indexOf(1) == 0);
      ok(arr.indexOf(2) == 1);
      ok(arr.indexOf(3) == 2);
    });

    suite('String');

    test('#length', function() {
      ok('foo'.length == 3);
    });
    ```
- name: Reporter Limitations
  id: index#reporter-limitations
  summary: These reporters expect Mocha to know how many tests it plans to run before execution
  description: |-
    ### Reporter Limitations

    Due to the nature of the following reporters, they cannot work when running tests in parallel:

    - [`markdown`](#markdown)
    - [`progress`](#progress)
    - [`json-stream`](#json-stream)

    These reporters expect Mocha to know *how many tests it plans to run* before execution. This information is unavailable in parallel mode, as test files are loaded only when they are about to be run.

    In serial mode, tests results will “stream” as they occur. In parallel mode, reporter output is *buffered*; reporting will occur after each file is completed. In practice, the reporter output will appear in “chunks” (but will otherwise be identical). If a test file is particularly slow, there may be a significant pause while it’s running.
- name: Reporters
  id: index#reporters
  summary: Mocha reporters adjust to the terminal window, and always disable ANSI-escape coloring when the stdio streams are not associated with a TTY
  description: |-
    ## Reporters

    Mocha reporters adjust to the terminal window, and always disable ANSI-escape coloring when the stdio streams are not associated with a TTY.
- name: Reporting
  id: index#reporting
  summary: The HTML reporter is the default reporter when running Mocha in the browser
  description: |-
    ### Reporting

    The HTML reporter is the default reporter when running Mocha in the browser. It looks like this:

    [Mochawesome](https://npm.im/mochawesome) is a great alternative to the default HTML reporter.
- name: Retry Tests
  id: index#retry-tests
  summary: You can choose to retry failed tests up to a certain number of times
  description: |-
    ## Retry Tests

    You can choose to retry failed tests up to a certain number of times. This feature is designed to handle end-to-end tests (functional tests/Selenium…) where resources cannot be easily mocked/stubbed. **It’s not recommended to use this feature for unit tests**.

    This feature does re-run a failed test and its corresponding `beforeEach/afterEach` hooks, but not `before/after` hooks. `this.retries()` has no effect on failing hooks.

    **NOTE**: Example below was written using Selenium webdriver (which [overwrites global Mocha hooks](https://github.com/SeleniumHQ/selenium/blob/c10e8a955883f004452cdde18096d70738397788/javascript/node/selenium-webdriver/testing/index.js) for `Promise` chain).

    ``` javascript
    describe('retries', function() {
      // Retry all tests in this suite up to 4 times
      this.retries(4);

      beforeEach(function() {
        browser.get('http://www.yahoo.com');
      });

      it('should succeed on the 3rd try', function() {
        // Specify this test to only retry up to 2 times
        this.retries(2);
        expect($('.foo').isDisplayed()).to.eventually.be.true;
      });
    });
    ```
- name: Root Hook Plugins
  id: index#root-hook-plugins
  summary: New in v8.0.0
  description: |-
    ## Root Hook Plugins

    > *New in v8.0.0.*

    In some cases, you may want a [hook](#hooks) before (or after) every test in every file. These are called *root hooks*. Previous to v8.0.0, the way to accomplish this was to use `--file` combined with root hooks (see [example above](#root-hooks-are-not-global)). This still works in v8.0.0, but *not* when running tests in parallel mode! For that reason, running root hooks using this method is *strongly discouraged*, and may be deprecated in the future.

    A *Root Hook Plugin* is a JavaScript file loaded via [`--require`](#-require-module-r-module) which “registers” one or more root hooks to be used across all test files.
- name: Root Hook Plugins Can Export a Function
  id: index#root-hook-plugins-can-export-a-function
  summary: If you need to perform some logic–such as choosing a root hook conditionally, based on the environment–mochaHooks can be a function which returns the expected object
  description: |-
    ### Root Hook Plugins Can Export a Function

    If you need to perform some logic–such as choosing a root hook conditionally, based on the environment–`mochaHooks` can be a *function* which returns the expected object.

    ``` javascript
    // test/hooks.mjs

    export const mochaHooks = () => {
      if (process.env.CI) {
        // root hooks object
        return {
          beforeEach: [
            function() {
              // CI-specific beforeEach
            },
            function() {
              // some other CI-specific beforeEach
            }
          ]
        };
      }
      // root hooks object
      return {
        beforeEach() {
          // regular beforeEach
        }
      };
    };
    ```

    If you need to perform an async operation, `mochaHooks` can be `Promise`-returning:

    ``` javascript
    // test/hooks.mjs

    export const mochaHooks = async () => {
      const result = await checkSomething();
      // only use a root hook if `result` is truthy
      if (result) {
        // root hooks object
        return {
          beforeEach() {
            // something
          }
        };
      }
    };
    ```
- name: Root Hooks Are Not Global
  id: index#root-hooks-are-not-global
  summary: 'NOTE: This only applies when running in parallel mode'
  description: |-
    ### Root Hooks Are Not Global

    > *NOTE: This only applies when running in parallel mode.*

    A *root hook* is a hook in a test file which is *not defined* within a suite. An example using the `bdd` interface:

    ``` javascript
    // test/setup.js

    // root hook to run before every test (even in other files)
    beforeEach(function() {
      doMySetup();
    });

    // root hook to run after every test (even in other files)
    afterEach(function() {
      doMyTeardown();
    });
    ```

    When run (in the default “serial” mode) via this command:

    ``` javascript
    mocha --file "./test/setup.js" "./test/**/*.spec.js"
    ```

    `setup.js` will be executed *first*, and install the two hooks shown above for every test found in `./test/**/*.spec.js`.

    **The above example does not work in parallel mode.**

    When Mocha runs in parallel mode, **test files do not share the same process,** nor do they share the same instance of Mocha. Consequently, a hypothetical root hook defined in test file *A* **will not be present** in test file *B*.

    Here are a couple suggested workarounds:

    1.  `require('./setup.js')` or `import './setup.js'` at the top of every test file. Best avoided for those averse to boilerplate.
    2.  *Recommended*: Define root hooks in a “required” file, using the new (also as of v8.0.0) [Root Hook Plugin](#root-hook-plugins) system.

    If you need to run some code *once and only once*, use a [global fixture](#global-fixtures) instead.
- name: Root-Level Hooks
  id: index#root-level-hooks
  summary: A hook defined at the top scope of a test file (outside of a suite) is a root hook
  description: |-
    ### Root-Level Hooks

    A hook defined at the top scope of a test file (outside of a suite) is a *root hook*.

    As of v8.0.0, [Root Hook Plugins](#root-hook-plugins) are the preferred mechanism for setting root hooks.
- name: Run Cycle Overview
  id: index#run-cycle-overview
  summary: Updated for v8.0.0
  description: |-
    ## Run Cycle Overview

    > Updated for v8.0.0.

    The following is a mid-level outline of Mocha’s “flow of execution” when run in Node.js; the “less important” details have been omitted.

    In a browser, test files are loaded by `<script>` tags, and calling `mocha.run()` begins at step 9 [below](#serial-mode).
- name: Serial Mode
  id: index#serial-mode
  summary: null
  description: |-
    ### Serial Mode

    1.  User (that’s you) executes `mocha`
    2.  Loads options from config files, if present
    3.  Mocha processes any command-line options provided (see section on [configuration merging](#merging) for details)
    4.  If known flags for the `node` executable are found:
        1.  Mocha will spawn `node` in a child process, executing itself with these flags
        2.  Otherwise, Mocha does not spawn a child process
    5.  Mocha loads modules specified by `--require`
        1.  If a file loaded this way contains known Mocha-specific exports (e.g., [root hook plugins](#root-hook-plugins)), Mocha “registers” these
        2.  If not, Mocha ignores any exports of a `--require`’d module
    6.  Mocha validates any custom reporters or interfaces which were loaded via `--require` or otherwise
    7.  Mocha *discovers* test files; when given no files or directories, it finds files with extensions `.js`, `.mjs` or `.cjs` in the `test` directory (but not its children), relative to the current working directory
    8.  The (default) [bdd interface](#bdd) loads the test files *in no particular order*, which are given an interface-specific `global` context (this is how, e.g., `describe()` ends up as a global in a test file)
        1.  When a test file is loaded, Mocha executes all of its suites and finds–*but does not execute*–any hooks and tests therein.
        2.  Top-level hooks, tests and suites are all made members of an “invisible” *root suite*; there is only *one* root suite for the entire process
    9.  Mocha runs [global setup fixtures](#global-setup-fixtures), if any
    10. Starting with the “root” suite, Mocha executes:
    11. Any “before all” hooks (for the *root* suite, this only happens once; see [root hook plugins](#root-hook-plugins))
    12. For each test, Mocha executes:
        1.  Any “before each” hooks
        2.  The test (and reports the result)
        3.  Any “after each” hooks
    13. If the current suite has a child suite, repeat the steps in 10. for each child suite; each child suite *inherits* any “before each” and “after each” hooks defined in its parent
    14. Any “after all” hooks (for the *root* suite, this only happens once; see [root hook plugins](#root-hook-plugins))
    15. Mocha prints a final summary/epilog, if applicable
    16. Mocha runs [global teardown fixtures](#global-teardown-fixtures), if any
- name: Spec
  id: index#spec
  summary: This is the default reporter
  description: |-
    ### Spec

    Alias: `Spec`, `spec`

    This is the default reporter. The Spec reporter outputs a hierarchical view nested just as the test cases are.
- name: Suite-level
  id: index#suite-level
  summary: Suite-level timeouts may be applied to entire test “suites”, or disabled via this.timeout(0)
  description: |-
    ### Suite-level

    Suite-level timeouts may be applied to entire test “suites”, or disabled via `this.timeout(0)`. This will be inherited by all nested suites and test-cases that do not override the value.

    ``` javascript
    describe('a suite of tests', function() {
      this.timeout(500);

      it('should take less than 500ms', function(done) {
        setTimeout(done, 300);
      });

      it('should take less than 500ms as well', function(done) {
        setTimeout(done, 250);
      });
    });
    ```
- name: Synchronous Code
  id: index#synchronous-code
  summary: When testing synchronous code, omit the callback and Mocha will automatically continue on to the next test
  description: |-
    ## Synchronous Code

    When testing synchronous code, omit the callback and Mocha will automatically continue on to the next test.

    ``` javascript
    describe('Array', function() {
      describe('#indexOf()', function() {
        it('should return -1 when the value is not present', function() {
          [1, 2, 3].indexOf(5).should.equal(-1);
          [1, 2, 3].indexOf(0).should.equal(-1);
        });
      });
    });
    ```
- name: TAP
  id: index#tap
  summary: The TAP reporter emits lines for a Test-Anything-Protocol consumer
  description: |-
    ### TAP

    Alias: `TAP`, `tap`

    The TAP reporter emits lines for a [Test-Anything-Protocol](https://en.wikipedia.org/wiki/Test_Anything_Protocol) consumer.
- name: Test duration
  id: index#test-duration
  summary: null
  description: |-
    ## Test duration

    Many reporters will display test duration and flag tests that are slow (default: 75ms), as shown here with the SPEC reporter:

    There are three levels of test duration (depicted in the following image):

    1.  FAST: Tests that run within half of the “slow” threshold will show the duration in green (if at all).
    2.  NORMAL: Tests that run exceeding half of the threshold (but still within it) will show the duration in yellow.
    3.  SLOW: Tests that run exceeding the threshold will show the duration in red.

    To tweak what’s considered “slow”, you can use the `slow()` method:

    ``` javascript
    describe('something slow', function() {
      this.slow(300000); // five minutes

      it('should take long enough for me to go make a sandwich', function() {
        // ...
      });
    });
    ```
- name: Test Duration Variability
  id: index#test-duration-variability
  summary: Running tests in parallel mode will naturally use more system resources
  description: |-
    ### Test Duration Variability

    Running tests in parallel mode will naturally use more system resources. The OS may take extra time to schedule and complete some operations, depending on system load. For this reason, the timeouts of *individual tests* may need to be increased either [globally](#-timeout-ms-t-ms) or [otherwise](#timeouts).
- name: Test Fixture Decision-Tree Wizard Thing
  id: index#test-fixture-decision-tree-wizard-thing
  summary: This flowchart will help you decide which of hooks, root hook plugins or global fixtures you should use
  description: |-
    ## Test Fixture Decision-Tree Wizard Thing

    This flowchart will help you decide which of [hooks](#hooks), [root hook plugins](#root-hook-plugins) or [global fixtures](#global-fixtures) you should use.
- name: Test-level
  id: index#test-level
  summary: null
  description: |-
    ### Test-level

    Test-specific timeouts may also be applied, or the use of `this.timeout(0)` to disable timeouts all together:

    ``` javascript
    it('should take less than 500ms', function(done) {
      this.timeout(500);
      setTimeout(done, 300);
    });
    ```
- name: TextMate
  id: index#textmate
  summary: The Mocha TextMate bundle includes snippets to make writing tests quicker and more enjoyable
  description: |-
    ### TextMate

    The [Mocha TextMate bundle](https://github.com/mochajs/mocha.tmbundle) includes snippets to make writing tests quicker and more enjoyable.
- name: The test/ Directory
  id: index#the-test-directory
  summary: By default, mocha looks for the glob "./test/*.{js,cjs,mjs}", so you may want to put your tests in test/ folder
  description: |-
    ## The `test/` Directory

    By default, `mocha` looks for the glob `"./test/*.{js,cjs,mjs}"`, so you may want to put your tests in `test/` folder. If you want to include subdirectories, pass the `--recursive` option.

    To configure where `mocha` looks for tests, you may pass your own glob:

    ``` javascript
    $ mocha --recursive "./spec/*.js"
    ```

    Some shells support recursive matching by using the globstar (`**`) wildcard. Bash \>= 4.3 supports this with the [`globstar` option](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html) which [must be enabled](https://github.com/mochajs/mocha/pull/3348#issuecomment-383937247) to get the same results as passing the `--recursive` option ([ZSH](http://zsh.sourceforge.net/Doc/Release/Expansion.html#Recursive-Globbing) and [Fish](https://fishshell.com/docs/current/#expand-wildcard) support this by default). With recursive matching enabled, the following is the same as passing `--recursive`:

    ``` javascript
    $ mocha "./spec/**/*.js"
    ```

    [You should *always* quote your globs in npm scripts](https://medium.com/@jakubsynowiec/you-should-always-quote-your-globs-in-npm-scripts-621887a2a784). If you use double quotes, it’s the shell on UNIX that will expand the glob. On the other hand, if you use single quotes, the [`node-glob`](https://www.npmjs.com/package/glob) module will handle its expansion.

    See this [tutorial](https://gist.github.com/reggi/475793ea1846affbcfe8) on using globs.

    *Note*: Double quotes around the glob are recommended for portability.
- name: Third-Party Reporters
  id: index#third-party-reporters
  summary: Mocha allows you to define custom reporters
  description: |-
    ### Third-Party Reporters

    Mocha allows you to define custom reporters. For more information see the [wiki](https://github.com/mochajs/mocha/wiki/Third-party-reporters).

    Examples:

    - the [TeamCity reporter](https://github.com/travisjeffery/mocha-teamcity-reporter)
    - our [working example](https://github.com/mochajs/mocha-examples/tree/master/packages/third-party-reporter)

    &nbsp;
- name: Troubleshooting Parallel Mode
  id: index#troubleshooting-parallel-mode
  summary: null
  description: |-
    ### Troubleshooting Parallel Mode

    If you find your tests don’t work properly when run with [`--parallel`](#-parallel-p), either shrug and move on, or use this handy-dandy checklist to get things working:

    - ✅ Ensure you are using a [supported reporter](#reporter-limitations).
    - ✅ Ensure you are not using [other unsupported flags](#file-order-is-non-deterministic).
    - ✅ Double-check your [config file](#configuring-mocha-nodejs); options set in config files will be merged with any command-line option.
    - ✅ Look for root hooks (they look like [this](#root-hooks-are-not-global)) in your tests. Move them into a [Root Hook Plugin](#root-hook-plugins).
    - ✅ Do any assertion, mock, or other test libraries you’re consuming use root hooks? They may need to be [migrated](#migrating-a-library-to-use-root-hook-plugins) for compatibility with parallel mode.
    - ✅ If tests are unexpectedly timing out, you may need to increase the default test timeout (via [`--timeout`](#-timeout-ms-t-ms))
    - ✅ Ensure your tests do not depend on being run in a specific order.
    - ✅ Ensure your tests clean up after themselves; remove temp files, handles, sockets, etc. Don’t try to share state or resources between test files.

    &nbsp;
- name: Using async / await
  id: index#using-async-await
  summary: null
  description: |-
    ### Using async / await

    If your JS environment supports [async / await](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/async_function), you can also write asynchronous tests like this:

    ``` javascript
    beforeEach(async function() {
      await db.clear();
      await db.save([tobi, loki, jane]);
    });

    describe('#find()', function() {
      it('responds with matching records', async function() {
        const users = await db.find({type: 'User'});
        users.should.have.length(3);
      });
    });
    ```
- name: Wallaby.js
  id: index#wallabyjs
  summary: Wallaby.js is a continuous testing tool that enables real-time code coverage for Mocha with any assertion library in VS Code, Atom, JetBrains IDEs (IntelliJ IDEA, WebStorm, etc.), Sublime Text and Visual Studio for both browser and node.js projects
  description: |-
    ### Wallaby.js

    [Wallaby.js](https://wallabyjs.com/) is a continuous testing tool that enables real-time code coverage for Mocha with any assertion library in VS Code, Atom, JetBrains IDEs (IntelliJ IDEA, WebStorm, etc.), Sublime Text and Visual Studio for both browser and node.js projects.
- name: When Not To Use Global Fixtures
  id: index#when-not-to-use-global-fixtures
  summary: If you need to access an in-memory value (such as a file handle or database connection), don’t use global fixtures to do this, because your tests will not have access to the value
  description: |-
    ### When Not To Use Global Fixtures

    If you need to access an in-memory value (such as a file handle or database connection), *don’t* use global fixtures to do this, because your tests will not have access to the value.

    > You could be clever and try to get around this restriction by assigning something to the `global` object, but this will *not* work in parallel mode. It’s probably best to play by the rules!

    Instead, use the global fixture to *start* the database, and use [root hook plugins](#root-hook-plugins) or plain ol’ [hooks](#hooks) to create a connection.

    Here’s an example of using global fixtures and “before all” hooks to get the job done. Note that we do not reference the `server` object anywhere in our tests!

    First, use a global fixture to start and stop a test server:

    ``` javascript
    // fixtures.mjs

    let server;

    export const mochaGlobalSetup = async () => {
      server = await startSomeServer({port: process.env.TEST_PORT});
      console.log(`server running on port ${server.port}`);
    };

    export const mochaGlobalTeardown = async () => {
      await server.stop();
      console.log('server stopped!');
    };
    ```

    Then, connect to the server in your tests:

    ``` javascript
    // test.spec.mjs

    import {connect} from 'my-server-connector-thingy';

    describe('my API', function() {
      let connection;

      before(async function() {
        connection = await connect({port: process.env.TEST_PORT});
      });

      it('should be a nice API', function() {
        // assertions here
      });

      after(async function() {
        return connection.close();
      });
    });
    ```

    Finally, use this command to bring it together: `mocha --require fixtures.mjs test.spec.mjs`.
- name: When To Use Global Fixtures
  id: index#when-to-use-global-fixtures
  summary: Global fixtures are good for spinning up a server, opening a socket, or otherwise creating a resource that your tests will repeatedly access via I/O
  description: |-
    ### When To Use Global Fixtures

    Global fixtures are good for spinning up a server, opening a socket, or otherwise creating a resource that your tests will repeatedly access via I/O.
- name: Working with Promises
  id: index#working-with-promises
  summary: Alternately, instead of using the done() callback, you may return a Promise
  description: |-
    ### Working with Promises

    Alternately, instead of using the `done()` callback, you may return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). This is useful if the APIs you are testing return promises instead of taking callbacks:

    ``` javascript
    beforeEach(function() {
      return db.clear().then(function() {
        return db.save([tobi, loki, jane]);
      });
    });

    describe('#find()', function() {
      it('respond with matching records', function() {
        return db.find({type: 'User'}).should.eventually.have.length(3);
      });
    });
    ```

    > The latter example uses [Chai as Promised](https://www.npmjs.com/package/chai-as-promised) for fluent promise assertions.

    In Mocha v3.0.0 and newer, returning a `Promise` *and* calling `done()` will result in an exception, as this is generally a mistake:

    ``` javascript
    const assert = require('assert');

    // antipattern
    it('should complete this test', function(done) {
      return new Promise(function(resolve) {
        assert.ok(true);
        resolve();
      }).then(done);
    });
    ```

    The above test will fail with `Error: Resolution method is overspecified. Specify a callback *or* return a Promise; not both.`. In versions older than v3.0.0, the call to `done()` is effectively ignored.
- name: XUnit
  id: index#xunit
  summary: The XUnit reporter is also available
  description: |-
    ### XUnit

    Alias: `XUnit`, `xunit`

    The XUnit reporter is also available. It outputs an XUnit-compatible XML document, often applicable in CI servers.

    By default, it will output to the console. To write directly to a file, use `--reporter-option output=filename.xml`.

    To specify custom report title, use `--reporter-option suiteName="Custom name"`.
- name: “Bail” is “Best Effort”
  id: index#bail-is-best-effort
  summary: When used with --bail (or this.bail()) to exit after the first failure, it’s likely other tests will be running at the same time
  description: |-
    ### “Bail” is “Best Effort”

    When used with `--bail` (or `this.bail()`) to exit after the first failure, it’s likely other tests will be running at the same time. Mocha must shut down its worker processes before exiting.

    Likewise, subprocesses may throw uncaught exceptions. When used with `--allow-uncaught`, Mocha will “bubble” this exception to the main process, but still must shut down its processes.

    Either way, Mocha will abort the test run “very soon.”
